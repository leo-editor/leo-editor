<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20140902155015.18674"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20150425145248.1"><vh>@data history-list</vh></v>
<v t="ekr.20190406193429.1"><vh>@@enabled-plugins</vh></v>
<v t="ekr.20140920064112.17946"><vh>@int fts_max_hits = 100</vh></v>
<v t="ekr.20131111060930.18010"><vh>@shortcuts</vh></v>
<v t="ekr.20140916101314.19538"><vh>@string target_language = python</vh></v>
<v t="ekr.20160122104332.1"><vh>Buttons</vh>
<v t="ekr.20201013034659.1"><vh>Unused buttons</vh>
<v t="ekr.20180324065741.1"><vh>@@button copy-to-next</vh></v>
<v t="ekr.20150507170849.1"><vh>@@button create decorators</vh>
<v t="ekr.20150508063538.1"><vh>create_d</vh></v>
<v t="ekr.20150508071622.1"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150508063412.1"><vh>create_decorators</vh></v>
<v t="ekr.20150508074623.1"><vh>create_fixups</vh></v>
<v t="ekr.20150508063926.1"><vh>find_class</vh></v>
<v t="ekr.20150507174711.1"><vh>find_next_clone</vh></v>
<v t="ekr.20150507175246.1"><vh>munge_lines</vh></v>
<v t="ekr.20150508062944.1"><vh>run</vh></v>
</v>
<v t="ekr.20150509183433.1"><vh>@@button make-decorators2</vh>
<v t="ekr.20150509183433.2"><vh>create_d</vh></v>
<v t="ekr.20150509183433.3"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150509183433.4"><vh>create_decorators V2</vh></v>
<v t="ekr.20150509183433.8"><vh>munge_lines</vh></v>
<v t="ekr.20150509183433.9"><vh>run V2</vh></v>
</v>
<v t="ekr.20190406154306.1"><vh>@@button open-pyzo</vh></v>
<v t="ekr.20150703061709.1"><vh>@@button run-pylint</vh></v>
<v t="ekr.20180824065751.1"><vh>@@button show-gnx</vh></v>
<v t="ekr.20131121084830.16362"><vh>@@button toggle-debug</vh></v>
</v>
<v t="ekr.20201013034742.1"><vh>Unused buttons re plugins</vh>
<v t="ekr.20201013034742.2"><vh>@@button make-importer</vh>
<v t="ekr.20201013034742.3"><vh>&lt;&lt; define run &amp; helpers &gt;&gt;</vh>
<v t="ekr.20201013034742.4"><vh>copy_tree</vh></v>
<v t="ekr.20201013034742.5"><vh>make_substitutions</vh></v>
<v t="ekr.20201013034742.6"><vh>run</vh></v>
<v t="ekr.20201013034742.7"><vh>substitue</vh></v>
</v>
<v t="ekr.20201013034742.8"><vh>@@file importers/{{name}}.py</vh>
<v t="ekr.20201013034742.9"><vh>class {{cap_name}}_Importer</vh>
<v t="ekr.20201013034742.10"><vh>{{name}}.Overrides</vh>
<v t="ekr.20201013034742.11"><vh>{{name}}.clean_headline</vh></v>
<v t="ekr.20201013034742.12"><vh>{{name}}.clean_nodes</vh></v>
</v>
</v>
<v t="ekr.20201013034742.13"><vh>class {{cap_name}}_ScanState</vh>
<v t="ekr.20201013034742.14"><vh>{{name}}_state.level</vh></v>
<v t="ekr.20201013034742.15"><vh>{{name}}_state.update</vh></v>
</v>
</v>
</v>
<v t="ekr.20201013034742.16"><vh>@@button pep8 @key=Ctrl-5</vh>
<v t="ekr.20201013034742.17"><vh>class Pep8</vh>
<v t="ekr.20201013034742.18"><vh>change_all &amp; helpers</vh>
<v t="ekr.20201013034742.19"><vh>change_body</vh></v>
<v t="ekr.20201013034742.20"><vh>change_headline</vh></v>
</v>
<v t="ekr.20201013034742.21"><vh>get_name</vh></v>
<v t="ekr.20201013034742.22"><vh>run</vh></v>
<v t="ekr.20201013034742.23"><vh>to_pep8</vh></v>
</v>
<v t="ekr.20201013034742.24"><vh>clear</vh></v>
</v>
<v t="ekr.20201013034742.25"><vh>@@button test-jup-export</vh></v>
<v t="ekr.20201013034742.26"><vh>@@button test-jup-import</vh></v>
</v>
<v t="ekr.20150502050609.1"><vh>@button backup</vh></v>
<v t="ekr.20170811173924.1"><vh>@button backup-repo</vh></v>
<v t="ekr.20150413091056.1"><vh>@button check-clones</vh></v>
<v t="ekr.20201018062305.1"><vh>@button write-leoPyRef</vh>
<v t="ekr.20201018065757.1"><vh>check_file_names</vh></v>
<v t="ekr.20201018065921.1"><vh>check_nodes</vh></v>
<v t="ekr.20201018063747.1"><vh>get_content</vh></v>
<v t="ekr.20201018070822.1"><vh>main</vh></v>
<v t="ekr.20201018072911.1"><vh>oops</vh></v>
</v>
</v>
<v t="ekr.20200212095937.1"><vh>Beautify command settings</vh>
<v t="ekr.20200212095937.2"><vh>@bool beautify-allow-joined-strings = False</vh></v>
<v t="ekr.20200212095937.3"><vh>@bool beautify-keep-comment-indentation = True</vh></v>
<v t="ekr.20200212095937.5"><vh>@int beautify-max-join-line-length = 0</vh></v>
<v t="ekr.20200212095937.6"><vh>@int beautify-max-split-line-length = 90</vh></v>
</v>
</v>
<v t="ekr.20140103105930.16446"><vh>@views</vh>
<v t="ekr.20140102162014.16438"><vh>@view added strip_comments keyword arg to two config.getData methods</vh></v>
</v>
<v t="ekr.20140808103117.18035"><vh>@persistence</vh>
<v t="ekr.20140808103117.18038"><vh>@data:@auto ../plugins/qt_main.py</vh>
<v t="ekr.20160425070345.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18040"><vh>@data:@auto ../plugins/qt_main.ui</vh>
<v t="ekr.20160425070345.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18042"><vh>@data:@auto ../plugins/qt_quicksearch.py</vh>
<v t="ekr.20160420054135.4"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18044"><vh>@data:@auto ../plugins/qt_quicksearch.ui</vh>
<v t="ekr.20160420054135.5"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150604130353.1"><vh>@data:@auto test/unit_tests.py</vh>
<v t="ekr.20150604130353.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20201012111649.1"><vh>@data:@auto leo_cloud.py</vh>
<v t="ekr.20201217205859.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20201012111649.3"><vh>@data:@auto leo_cloud_server.py</vh>
<v t="ekr.20201012142922.2"><vh>@gnxs</vh></v>
</v>
</v>
<v t="ekr.20170427114412.1"><vh>scripts</vh>
<v t="ekr.20170427112302.1"><vh>check leoPy.leo</vh></v>
<v t="ekr.20170428084123.1"><vh>Recursive import script</vh></v>
<v t="ekr.20200308193719.1"><vh>script: check gnx's</vh></v>
<v t="ekr.20180816105258.1"><vh>script: diff-branches/revs (one file)</vh></v>
<v t="ekr.20201208114843.1"><vh>script: diff-pr</vh></v>
<v t="ekr.20190402091335.1"><vh>script: diff-revs</vh></v>
<v t="ekr.20201015145257.1"><vh>script: import legacy file</vh></v>
<v t="ekr.20200222083959.1"><vh>script: start loggin</vh></v>
<v t="ekr.20181102040815.1"><vh>script: warn about long lines</vh></v>
<v t="ekr.20200222151754.1"><vh>script: yoton "other end"</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20191029023442.1"><vh> 4 kinds of documentation</vh></v>
<v t="ekr.20170302123956.1"><vh>@file ../doc/leoAttic.txt</vh></v>
<v t="ekr.20031218072017.329"><vh>@file ../doc/leoNotes.txt</vh></v>
<v t="ekr.20200522082827.1"><vh>From leoMenu.py</vh>
<v t="ekr.20051022044950"><vh>LeoMenu.computeOldStyleShortcutKey</vh></v>
<v t="ekr.20031218072017.4117"><vh>LeoMenu.defineMenuCallback</vh></v>
</v>
<v t="ekr.20100120072650.6089"><vh>@file ../doc/leoProjects.txt</vh></v>
<v t="ekr.20100119205347.6015"><vh>@file ../doc/leoToDo.txt</vh></v>
<v t="ekr.20190122185223.1"><vh>regex: find all kwargs</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20140902032918.18591"><vh> About this file</vh>
<v t="ekr.20140831085423.18639"><vh>About widgets and wrappers</vh></v>
<v t="ekr.20140831085423.18630"><vh>Terminology</vh></v>
<v t="ekr.20140831085423.18631"><vh>Official ivars</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20141012064706.18389"><vh>@file leoAst.py</vh></v>
<v t="ekr.20150323150718.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20161026193447.1"><vh>@file leoBackground.py</vh></v>
<v t="ekr.20150521115018.1"><vh>@file leoBeautify.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20140827092102.18574"><vh>@file leoColorizer.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20180212072657.2"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20130925160837.11429"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20130302121602.10208"><vh>@file leoDebugger.py</vh></v>
<v t="ekr.20160306114544.1"><vh>@file leoExternalFiles.py</vh></v>
<v t="ekr.20181202062518.1"><vh>@file leoFastRedraw.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d7100285806000000302e31372e3071017d71025808000000616e6e6f7461746571037d7104735806000000302e31382e3071057d71065808000000616e6e6f7461746571077d7108735806000000302e32302e3171097d710a5808000000616e6e6f74617465710b7d710c735806000000302e32312e31710d7d710e5808000000616e6e6f74617465710f7d711073752e"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20150514154159.1"><vh>@file leoHistory.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20120401063816.10072"><vh>@file leoIPython.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
<v t="ekr.20140821055201.18331"><vh>@file leoPersistence.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20150419124739.1"><vh>@file leoPrinting.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20140810053602.18074"><vh>@file leoQt.py</vh></v>
<v t="ekr.20140526082700.18440"><vh>@file leoRope.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20120420054855.14241" descendentVnodeUnknownAttributes="7d7100285805000000302e332e3071017d71022858090000007374725f6374696d657103580c000000313331393439313330362e30710458090000007374725f6d74696d657105580d000000313331393439323330312e3532710658090000007374725f6174696d657107580d000000313331393534393339302e38397108755805000000302e332e3171097d710a2858090000007374725f6374696d65710b580c000000313331393436303438332e30710c58090000007374725f6d74696d65710d580d000000313331393436373033382e3235710e58090000007374725f6174696d65710f580c000000313332303432323637302e397110755805000000302e332e3271117d71122858090000007374725f6374696d657113580c000000313331393436303438332e30711458090000007374725f6d74696d657115580d000000313331393436373035302e3438711658090000007374725f6174696d657117580d000000313331393436373035302e34387118755805000000302e332e3371197d711a2858090000007374725f6374696d65711b580c000000313331393436303438332e30711c58090000007374725f6d74696d65711d580d000000313332303432323639302e3534711e58090000007374725f6174696d65711f580d000000313332303433343235372e33367120755805000000302e332e3471217d71222858090000007374725f6374696d657123580c000000313331393633383634382e30712458090000007374725f6d74696d657125580d000000313331393634313038352e3038712658090000007374725f6174696d657127580c000000313331393634353330362e327128755805000000302e332e3571297d712a2858090000007374725f6374696d65712b580c000000313331393633383634382e30712c58090000007374725f6d74696d65712d580c000000313331393634313131372e39712e58090000007374725f6174696d65712f580d000000313331393634313435352e3937713075752e"><vh>@file leoSessions.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20180121041003.1"><vh>@file leoTips.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
<v t="ekr.20131109170017.16504"><vh>@file leoVim.py</vh></v>
</v>
<v t="ekr.20150514035207.1"><vh>Command classes</vh>
<v t="ekr.20150514035236.1"><vh>@file ../commands/abbrevCommands.py</vh></v>
<v t="ekr.20150514035943.1"><vh>@file ../commands/baseCommands.py</vh></v>
<v t="ekr.20150514035559.1"><vh>@file ../commands/bufferCommands.py</vh></v>
<v t="ekr.20161021090740.1"><vh>@file ../commands/checkerCommands.py</vh></v>
<v t="ekr.20171123135539.1"><vh>@file ../commands/commanderEditCommands.py</vh></v>
<v t="ekr.20171123095353.1"><vh>@file ../commands/commanderFileCommands.py</vh></v>
<v t="ekr.20171124072110.1"><vh>@file ../commands/commanderFindCommands.py</vh></v>
<v t="ekr.20171124073126.1"><vh>@file ../commands/commanderHelpCommands.py</vh></v>
<v t="ekr.20171124080430.1"><vh>@file ../commands/commanderOutlineCommands.py</vh></v>
<v t="ekr.20150514040100.1"><vh>@file ../commands/controlCommands.py</vh></v>
<v t="ekr.20160316095222.1"><vh>@file ../commands/convertCommands.py</vh></v>
<v t="ekr.20150514040118.1"><vh>@file ../commands/debugCommands.py</vh></v>
<v t="ekr.20150514035813.1"><vh>@file ../commands/editCommands.py</vh></v>
<v t="ekr.20150514041209.1"><vh>@file ../commands/editFileCommands.py</vh></v>
<v t="ekr.20150624112334.1"><vh>@file ../commands/gotoCommands.py</vh></v>
<v t="ekr.20150514040138.1"><vh>@file ../commands/helpCommands.py</vh></v>
<v t="ekr.20150514040140.1"><vh>@file ../commands/keyCommands.py</vh></v>
<v t="ekr.20150514040142.1"><vh>@file ../commands/killBufferCommands.py</vh></v>
<v t="ekr.20150514040146.1"><vh>@file ../commands/rectangleCommands.py</vh></v>
<v t="ekr.20150514040236.1"><vh>@file ../commands/searchCommands.py</vh></v>
<v t="ekr.20150514040239.1"><vh>@file ../commands/spellCommands.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20201012111545.1"><vh>Plugins</vh>
<v t="ekr.20090430075506.3"><vh>@file ../plugins/leoPluginNotes.txt</vh></v>
<v t="EKR.20040517090508"><vh>  Enable plugins using @enabled-plugins nodes</vh></v>
<v t="ekr.20050303051035"><vh>  Templates</vh>
<v t="ekr.20041114102139"><vh>Notes for plugin writers</vh></v>
<v t="ekr.20050306071629"><vh>Template for plugins that override commander methods</vh>
<v t="ekr.20050306071629.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050306071629.3"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050306071629.4"><vh>init</vh></v>
<v t="ekr.20050306071540"><vh>onStart2</vh></v>
</v>
<v t="ekr.20050303051035.2"><vh>Template for plugins with per-commander controller class</vh>
<v t="ekr.20050303051035.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050303051101"><vh>init</vh></v>
<v t="ekr.20050303051150"><vh>onCreate</vh></v>
<v t="ekr.20050303051222"><vh>class pluginController</vh>
<v t="ekr.20050303051222.1"><vh>__init__</vh></v>
</v>
</v>
</v>
<v t="ekr.20100103093121.5365"><vh>Auto completion</vh>
<v t="ekr.20091118065749.5261"><vh>@file ../plugins/ctagscompleter.py</vh></v>
</v>
<v t="edream.110203113231.667"><vh>Commands &amp; directives</vh>
<v t="edream.110203113231.741"><vh>@file ../plugins/add_directives.py</vh></v>
<v t="ekr.20101110084839.5682"><vh>@file ../plugins/bzr_qcommands.py</vh></v>
<v t="EKR.20040517080049.1"><vh>@file ../plugins/empty_leo_file.py</vh></v>
<v t="edream.110203113231.669"><vh>@file ../plugins/import_cisco_config.py</vh></v>
<v t="ekr.20101110092851.5812"><vh>@file ../plugins/initinclass.py</vh></v>
<v t="ekr.20101110091234.5700"><vh>@file ../plugins/leo_interface.py</vh></v>
<v t="ekr.20040419105219"><vh>@file ../plugins/lineNumbers.py</vh></v>
<v t="ekr.20040916084945"><vh>@file ../plugins/macros.py</vh></v>
<v t="edream.110203113231.724"><vh>@file ../plugins/mod_autosave.py</vh></v>
<v t="ekr.20050301083306"><vh>@file ../plugins/mod_read_dir_outline.py</vh></v>
<v t="edream.110203113231.727"><vh>@file ../plugins/mod_timestamp.py</vh></v>
<v t="TL.20090225102340.32"><vh>@file ../plugins/nodeActions.py</vh></v>
<v t="edream.110203113231.720"><vh>@file ../plugins/outline_export.py</vh></v>
<v t="danr7.20060912105041.1"><vh>@file ../plugins/paste_as_headlines.py</vh></v>
<v t="tbrown.20070117104409"><vh>@file ../plugins/quickMove.py</vh></v>
<v t="ekr.20081214160729.1"><vh>@file ../plugins/setHomeDirectory.py</vh></v>
<v t="danr7.20061010105952.1"><vh>@file ../plugins/word_count.py</vh></v>
</v>
<v t="edream.110203113231.729"><vh>Debugging</vh>
<v t="ekr.20101110091234.5689"><vh>@file ../plugins/debugger_pudb.py</vh></v>
<v t="edream.110203113231.730"><vh>@file ../plugins/dump_globals.py</vh></v>
<v t="edream.110203113231.732"><vh>@file ../plugins/enable_gc.py</vh></v>
<v t="edream.110203113231.734"><vh>@file ../plugins/quit_leo.py</vh></v>
<v t="edream.110203113231.735"><vh>@file ../plugins/trace_gc_plugin.py</vh></v>
<v t="edream.110203113231.736"><vh>@file ../plugins/trace_keys.py</vh></v>
<v t="edream.110203113231.738"><vh>@file ../plugins/trace_tags.py</vh></v>
</v>
<v t="ekr.20041030092101"><vh>Dyna plugins by e</vh></v>
<v t="ekr.20040722141148"><vh>Examples</vh>
<v t="ekr.20040828105233"><vh>@file ../plugins/examples/chinese_menu.py</vh></v>
<v t="EKR.20040517080202.3"><vh>@file ../plugins/examples/french_fm.py</vh></v>
<v t="edream.110203113231.916"><vh>@file ../plugins/examples/override_classes.py</vh></v>
<v t="edream.110203113231.919"><vh>@file ../plugins/examples/override_commands.py</vh></v>
<v t="ekr.20060621123339"><vh>@file ../plugins/examples/print_cp.py</vh></v>
<v t="edream.110203113231.921"><vh>@file ../plugins/examples/redefine_put.py</vh></v>
<v t="ekr.20180119164431.1"><vh>@file ../plugins/patch_python_colorizer.py</vh></v>
</v>
<v t="ekr.20101110150056.9457"><vh>Experimental</vh>
<v t="ekr.20090704103932.5160"><vh>@file ../plugins/leo_pdf.py</vh></v>
<v t="danr7.20060902083957"><vh>@file ../plugins/leo_to_rtf.py</vh></v>
<v t="ekr.20040205071616"><vh>@file ../plugins/mnplugins.py</vh></v>
<v t="ekr.20101110094759.5843"><vh>@file ../plugins/mod_speedups.py</vh></v>
<v t="ekr.20040910070811.1"><vh>@file ../plugins/run_nodes.py</vh></v>
<v t="ekr.20170313020320.1"><vh>@file ../plugins/settings_finder.py</vh></v>
<v t="ekr.20100103093121.5339"><vh>@file ../plugins/stickynotes_plus.py</vh></v>
<v t="ekr.20140225222704.16748"><vh>@file ../plugins/viewrendered2.py</vh></v>
<v t="ekr.20040331071919"><vh>Leo to AsciiDoc</vh>
<v t="ekr.20101110093449.5822"><vh>@file ../plugins/mod_leo2ascd.py</vh></v>
<v t="ekr.20101110150056.9445"><vh>@file ../plugins/mod_leo2ascd.txt</vh></v>
</v>
</v>
<v t="EKR.20040517075715"><vh>External programs</vh>
<v t="ekr.20110125103904.12504"><vh>@file ../plugins/gitarchive.py</vh></v>
<v t="EKR.20040517080049.4"><vh>@file ../plugins/open_shell.py</vh></v>
<v t="ville.20090503124249.1"><vh>@file ../plugins/tomboy_import.py</vh></v>
<v t="EKR.20040517075715.10"><vh>@file ../plugins/vim.py</vh></v>
<v t="EKR.20040517075715.12"><vh>@file ../plugins/xemacs.py</vh></v>
<v t="EKR.20040517075715.13"><vh>Word export</vh>
<v t="EKR.20040517075715.14"><vh>@file ../plugins/word_export.py</vh></v>
<v t="EKR.20040517075715.20"><vh>@file-nosent ../plugins/word_export.ini</vh></v>
</v>
</v>
<v t="edream.110203113231.872"><vh>Files and nodes</vh>
<v t="tbrown.20080613095157.2"><vh>@file ../plugins/active_path.py</vh></v>
<v t="edream.110203113231.873"><vh>@file ../plugins/at_folder.py</vh></v>
<v t="ekr.20040915085351"><vh>@file ../plugins/at_produce.py</vh></v>
<v t="ktenney.20041211072654.1"><vh>@file ../plugins/at_view.py</vh></v>
<v t="ekr.20170619151859.2"><vh>@file ../plugins/auto_colorize2_0.py</vh></v>
<v t="tbrown.20081223111325.3"><vh>@file ../plugins/backlink.py</vh></v>
<v t="tbrown.20070322113635"><vh>@file ../plugins/bookmarks.py</vh></v>
<v t="ekr.20060807103814.1"><vh>@file ../plugins/datenodes.py</vh></v>
<v t="ajones.20070122153625"><vh>@file ../plugins/expfolder.py</vh></v>
<v t="ekr.20040915105758.13"><vh>@file ../plugins/FileActions.py</vh></v>
<v t="ekr.20110110105526.5463"><vh>@file ../plugins/ftp.py</vh></v>
<v t="tbrown.20091214233510.5347"><vh>@file ../plugins/geotag.py</vh></v>
<v t="tbrown.20100228141752.5691"><vh>@file ../plugins/leocursor.py</vh></v>
<v t="ville.20120503224623.3574"><vh>@file ../plugins/leomylyn.py</vh></v>
<v t="ekr.20101110092851.5742"><vh>@file ../plugins/leoOPML.py</vh></v>
<v t="dan.20090217132953.1"><vh>@file ../plugins/mime.py</vh></v>
<v t="mork.20041018204908.1"><vh>@file ../plugins/multifile.py</vh></v>
<v t="ekr.20040331151007"><vh>@file ../plugins/niceNosent.py</vh></v>
<v t="edream.110203113231.876"><vh>@file ../plugins/read_only_nodes.py</vh></v>
<v t="ekr.20040828103325"><vh>@file ../plugins/startfile.py</vh></v>
<v t="ekr.20130808211520.15893"><vh>@file ../plugins/timestamp.py</vh></v>
<v t="tbrown.20110428144124.29061"><vh>@file ../plugins/xml_edit.py</vh></v>
<v t="mork.20041010095009"><vh>@file ../plugins/xsltWithNodes.py</vh></v>
</v>
<v t="ekr.20181030041436.1"><vh>Gui</vh>
<v t="ekr.20150107090324.1"><vh>@file ../plugins/cursesGui.py</vh></v>
<v t="ekr.20170419092835.1"><vh>@file ../plugins/cursesGui2.py</vh></v>
<v t="ekr.20181103094900.1"><vh>@file ../plugins/leoflexx.py</vh></v>
<v t="ekr.201811100000000.1"><vh>@file ../plugins/leoflexx_js.py</vh></v>
<v t="peckj.20150428142633.1"><vh>@file ../plugins/python_terminal.py</vh></v>
</v>
<v t="ekr.20140723122936.17925"><vh>Importer plugins</vh>
<v t="ekr.20140723122936.18139"><vh>@file ../plugins/importers/__init__.py</vh></v>
<v t="ekr.20140723122936.17926"><vh>@file ../plugins/importers/c.py</vh></v>
<v t="ekr.20160505094722.1"><vh>@file ../plugins/importers/coffeescript.py</vh></v>
<v t="ekr.20140723122936.18140"><vh>@file ../plugins/importers/csharp.py</vh></v>
<v t="tbrown.20140801105909.47549"><vh>@file ../plugins/importers/ctext.py</vh></v>
<v t="ekr.20200619141135.1"><vh>@file ../plugins/importers/cython.py</vh></v>
<v t="ekr.20141116100154.1"><vh>@file ../plugins/importers/dart.py</vh></v>
<v t="ekr.20140723122936.18141"><vh>@file ../plugins/importers/elisp.py</vh></v>
<v t="ekr.20140723122936.18138"><vh>@file ../plugins/importers/html.py</vh></v>
<v t="ekr.20140723122936.18142"><vh>@file ../plugins/importers/ini.py</vh></v>
<v t="ekr.20160412101008.1"><vh>@file ../plugins/importers/ipynb.py</vh></v>
<v t="ekr.20140723122936.18143"><vh>@file ../plugins/importers/java.py</vh></v>
<v t="ekr.20140723122936.18144"><vh>@file ../plugins/importers/javascript.py</vh></v>
<v t="ekr.20160504080826.1"><vh>@file ../plugins/importers/leo_json.py</vh></v>
<v t="ekr.20140723122936.18151"><vh>@file ../plugins/importers/leo_rst.py</vh></v>
<v t="ekr.20161108125620.1"><vh>@file ../plugins/importers/linescanner.py</vh></v>
<v t="ekr.20170530024520.2"><vh>@file ../plugins/importers/lua.py</vh></v>
<v t="ekr.20140725190808.18066"><vh>@file ../plugins/importers/markdown.py</vh></v>
<v t="ekr.20140723122936.18146"><vh>@file ../plugins/importers/org.py</vh></v>
<v t="ekr.20140723122936.18150"><vh>@file ../plugins/importers/otl.py</vh></v>
<v t="ekr.20140723122936.18147"><vh>@file ../plugins/importers/pascal.py</vh></v>
<v t="ekr.20161027100313.1"><vh>@file ../plugins/importers/perl.py</vh></v>
<v t="ekr.20140723122936.18148"><vh>@file ../plugins/importers/php.py</vh></v>
<v t="ekr.20140723122936.18149"><vh>@file ../plugins/importers/python.py</vh></v>
<v t="ekr.20200316100818.1"><vh>@file ../plugins/importers/rust.py</vh></v>
<v t="ekr.20170615153639.2"><vh>@file ../plugins/importers/tcl.py</vh></v>
<v t="ekr.20180201203240.2"><vh>@file ../plugins/importers/treepad.py</vh></v>
<v t="ekr.20140723122936.18152"><vh>@file ../plugins/importers/typescript.py</vh></v>
<v t="ekr.20140723122936.18137"><vh>@file ../plugins/importers/xml.py</vh></v>
</v>
<v t="ekr.20180504192522.1"><vh>leo_babel</vh>
<v t="ekr.20180504191650.34"><vh>@clean ../plugins/leo_babel/__init__.py</vh></v>
<v t="ekr.20180504191650.36"><vh>examples</vh>
<v t="bob.20170716135108.2"><vh>@file ../plugins/leo_babel/examples/slowOut.py</vh></v>
<v t="bob.20170716135108.3"><vh>@file ../plugins/leo_babel/examples/slowOutNoFlush.py</vh></v>
</v>
<v t="ekr.20180504191650.42"><vh>tests</vh>
<v t="ekr.20180504191650.68"><vh>@clean ../plugins/leo_babel/tests/__init__.py</vh></v>
<v t="bob.20180206123613.1"><vh>@file ../plugins/leo_babel/tests/idle_time.py</vh></v>
<v t="bob.20180205135005.1"><vh>@file ../plugins/leo_babel/tests/lib_test.py</vh></v>
<v t="bob.20180125160225.1"><vh>@file ../plugins/leo_babel/tests/tests.py</vh></v>
</v>
</v>
<v t="ekr.20130927050813.13031"><vh>Obsolete</vh>
<v t="ajones.20070122160142"><vh>@file ../plugins/textnode.py</vh></v>
<v t="ekr.20050817132814"><vh>rst3</vh>
<v t="ekr.20050805162550"><vh>@@file ../plugins/rst3.py</vh>
<v t="ekr.20050805162550.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050805162550.2"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050806162146"><vh>&lt;&lt; to do &gt;&gt;</vh>
<v t="ekr.20050804081215"><vh>More options</vh></v>
</v>
<v t="ekr.20050805162550.4"><vh>Module level</vh>
<v t="ekr.20050805162550.5"><vh> init</vh></v>
<v t="ekr.20050805162550.6"><vh>onCreate</vh></v>
<v t="ekr.20050806101253"><vh>code_block</vh></v>
<v t="ekr.20090429055156.63"><vh>runUnitTests</vh></v>
</v>
<v t="ekr.20050805162550.39"><vh>html parser classes</vh>
<v t="ekr.20050805162550.40"><vh> &lt;&lt; class linkAnchorParserClass &gt;&gt; (subclass of HTMLParser.HTMLParser)</vh>
<v t="ekr.20050805162550.41"><vh>__init__</vh></v>
<v t="ekr.20050805162550.42"><vh>is_anchor</vh></v>
<v t="ekr.20050805162550.43"><vh>is_link</vh></v>
<v t="ekr.20050815164715"><vh>is_node_marker</vh></v>
</v>
<v t="ekr.20050805162550.44"><vh>class htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.45"><vh>__init__</vh></v>
<v t="ekr.20050805162550.46"><vh>handle_starttag</vh>
<v t="ekr.20050815164715.1"><vh>&lt;&lt; trace the unknownAttribute &gt;&gt;</vh></v>
</v>
<v t="ekr.20050805162550.47"><vh>handle_endtag</vh></v>
<v t="ekr.20050805162550.49"><vh>feed</vh></v>
</v>
<v t="ekr.20050805162550.50"><vh>class anchor_htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.51"><vh> __init__</vh></v>
<v t="ekr.20050805162550.52"><vh>handle_starttag</vh></v>
</v>
<v t="ekr.20050805162550.53"><vh>class link_htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.54"><vh>__init__</vh></v>
<v t="ekr.20050805162550.55"><vh>handle_starttag</vh></v>
<v t="ekr.20050805162550.56"><vh>get_replacements</vh></v>
</v>
</v>
<v t="ekr.20050805162550.8"><vh>class rstClass</vh>
<v t="ekr.20050805162550.9"><vh> Birth &amp; init</vh>
<v t="ekr.20050805162550.10"><vh> ctor (rstClass)</vh>
<v t="ekr.20050805162550.11"><vh>&lt;&lt; init ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050805162550.12"><vh>addMenu (rstClass, rst3.py) (obsolete)</vh></v>
<v t="ekr.20050813083007"><vh>initHeadlineCommands</vh></v>
<v t="ekr.20050813085236"><vh>initSingleNodeOptions</vh></v>
<v t="ekr.20050808072943"><vh>munge</vh></v>
</v>
<v t="ekr.20050812122236"><vh>options...</vh>
<v t="ekr.20050808064245"><vh>createDefaultOptionsDict</vh></v>
<v t="ekr.20050812120933"><vh>dumpSettings (debugging)</vh></v>
<v t="ekr.20050814134351"><vh>getOption</vh></v>
<v t="ekr.20071015110830"><vh>initCodeBlockString</vh></v>
<v t="ekr.20050807120331.1"><vh>preprocessTree &amp; helpers</vh>
<v t="ekr.20051204070141"><vh>preprocessNode</vh></v>
<v t="ekr.20050808072943.1"><vh>parseOptionLine</vh></v>
<v t="ekr.20050808070018.2"><vh>scanForOptionDocParts</vh></v>
<v t="ekr.20050811173750"><vh>scanHeadlineForOptions</vh></v>
<v t="ekr.20050807120331.2"><vh>scanNodeForOptions</vh></v>
<v t="ekr.20050808070018"><vh>scanOption</vh></v>
<v t="ekr.20050808070018.1"><vh>scanOptions</vh></v>
</v>
<v t="ekr.20050808142313.28"><vh>scanAllOptions &amp; helpers</vh>
<v t="ekr.20050805162550.13"><vh>initOptionsFromSettings</vh></v>
<v t="ekr.20050810103731"><vh>handleSingleNodeOptions</vh></v>
</v>
<v t="ekr.20050811135526"><vh>setOption</vh></v>
</v>
<v t="ekr.20050809074827"><vh>write methods</vh>
<v t="ekr.20050809082854"><vh> Top-level write code</vh>
<v t="ekr.20050809075309"><vh>initWrite</vh></v>
<v t="ekr.20050809080925"><vh>writeNormalTree</vh></v>
<v t="ekr.20051121102358"><vh>processTopTree</vh></v>
<v t="ekr.20050805162550.17"><vh>processTree</vh></v>
<v t="ekr.20050805162550.21"><vh>writeSpecialTree</vh></v>
<v t="ekr.20050809082854.1"><vh>writeToDocutils (sets argv) &amp; helper</vh>
<v t="ekr.20090428082801.64"><vh>handleMissingStyleSheetArgs</vh></v>
</v>
<v t="ekr.20060525102337"><vh>writeNodeToString (New in 4.4.1)</vh></v>
</v>
<v t="ekr.20050811154552"><vh>getDocPart</vh>
<v t="ekr.20060610104435"><vh>&lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;</vh></v>
</v>
<v t="ekr.20050811102607"><vh>skip_literal_block</vh></v>
<v t="ekr.20050811101550.1"><vh>writeBody &amp; helpers</vh>
<v t="ekr.20050811150541"><vh>handleCodeMode &amp; helper</vh>
<v t="ekr.20050811152104"><vh>formatCodeModeLine</vh></v>
<v t="ekr.20050813155021"><vh>rstripList</vh></v>
<v t="ekr.20050813160208"><vh>finishCodePart</vh></v>
</v>
<v t="ekr.20060608094815"><vh>handleDocOnlyMode</vh></v>
<v t="ekr.20060608094815.1"><vh>isAnyDocPart</vh></v>
<v t="ekr.20050811153208"><vh>isSpecialDocPart</vh></v>
<v t="ekr.20050811163802"><vh>isAnySpecialDocPart</vh></v>
<v t="ekr.20050811105438"><vh>removeLeoDirectives</vh></v>
<v t="ekr.20050811105438.1"><vh>handleSpecialDocParts</vh></v>
<v t="ekr.20050805162550.30"><vh>replaceCodeBlockDirectives</vh></v>
</v>
<v t="ekr.20050805162550.26"><vh>writeHeadline &amp; helper</vh>
<v t="ekr.20060608102001"><vh>writeHeadlineHelper</vh></v>
</v>
<v t="ekr.20050810083057"><vh>writeNode</vh></v>
<v t="ekr.20071115061253"><vh>writePreformat</vh></v>
<v t="ekr.20050805162550.23"><vh>writeTree</vh></v>
</v>
<v t="ekr.20050810083314"><vh>Utils</vh>
<v t="ekr.20051202070028"><vh>computeOutputFileName</vh></v>
<v t="ekr.20050805162550.16"><vh>encode</vh></v>
<v t="ekr.20050805162550.20"><vh>report</vh></v>
<v t="ekr.20050810083856"><vh>rstComment</vh></v>
<v t="ekr.20050805162550.19"><vh>underline</vh></v>
<v t="ekr.20050809080031"><vh>write</vh></v>
</v>
<v t="ekr.20050805162550.33"><vh>Support for http plugin</vh>
<v t="ekr.20050815091008.1"><vh>http_addNodeMarker</vh></v>
<v t="ekr.20050805162550.34"><vh>http_endTree &amp; helpers</vh>
<v t="ekr.20050805162550.36"><vh>set_initial_http_attributes</vh></v>
<v t="ekr.20050805162550.38"><vh>find_anchors</vh></v>
<v t="ekr.20050805162550.37"><vh>relocate_references</vh></v>
<v t="ekr.20050805162550.35"><vh>http_attribute_iter</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20181028052650.1"><vh>@file ../plugins/leowapp.py</vh></v>
<v t="ekr.20190410171646.1"><vh>Unused: pyzo_support.py</vh>
<v t="ekr.20190412042616.1"><vh>&lt;&lt; copyright &gt;&gt;</vh></v>
<v t="ekr.20190410171905.1"><vh>init (pyzo_support.py)</vh></v>
<v t="ekr.20190418161712.1"><vh>class PyzoInterface</vh>
<v t="ekr.20190803175344.1"><vh>pyzo_x.patch_pyzo</vh></v>
</v>
</v>
<v t="ekr.20190813161639.1"><vh>Obsolete: @file ../plugins/pyzo_in_leo.py</vh>
<v t="ekr.20190930051422.1"><vh>Top-level functions (pyzo_in_leo)</vh>
<v t="ekr.20190813161639.4"><vh>init (pyzo_in_leo)</vh></v>
<v t="ekr.20190928061911.1"><vh>onCreate</vh></v>
<v t="ekr.20190816163728.1"><vh>close_handler</vh></v>
<v t="ekr.20191012094334.1"><vh>patched: setShortcut</vh></v>
<v t="ekr.20191012093236.1"><vh>patched: _get_interpreters_win</vh></v>
</v>
<v t="ekr.20190930051034.1"><vh>class PyzoController</vh>
<v t="ekr.20190929180053.1"><vh>pz.init_pyzo_menu</vh></v>
<v t="ekr.20190814050859.1"><vh>pz.load_all_pyzo_docks</vh></v>
<v t="ekr.20190816131753.1"><vh>pz.main_window_ctor</vh></v>
<v t="ekr.20190816132847.1"><vh>pz.main_window_populate</vh></v>
<v t="ekr.20190813161921.1"><vh>pz.make_global_dock</vh></v>
<v t="ekr.20190816131343.1"><vh>pz.pyzo_start</vh></v>
</v>
</v>
<v t="ekr.20190805022257.1"><vh>Unused: @file ../plugins/file pyzo_file_browser.py</vh>
<v t="ekr.20190809093446.1"><vh> &lt;&lt; pyzo_file_browser imports &gt;&gt;</vh></v>
<v t="ekr.20190809093459.1"><vh> top-level Leo functions</vh>
<v t="ekr.20190809093459.3"><vh>init (pyzo_file_browser)</vh></v>
<v t="ekr.20190809093459.4"><vh>onCreate</vh></v>
<v t="ekr.20190814050007.1"><vh>make_dock</vh></v>
</v>
</v>
</v>
<v t="ekr.20041001210557"><vh>Scripting</vh>
<v t="tbrown.20100226095909.12777"><vh>@file ../plugins/leoscreen.py</vh></v>
<v t="tbrown.20140806084727.30174"><vh>@file ../plugins/livecode.py</vh></v>
<v t="ekr.20060328125248"><vh>@file ../plugins/mod_scripting.py</vh></v>
<v t="edream.110203113231.925"><vh>@file ../plugins/script_io_to_body.py</vh></v>
</v>
<v t="ekr.20120309073937.9878"><vh>Searching</vh>
<v t="ekr.20120309073748.9872"><vh>@file ../plugins/bigdash.py</vh></v>
<v t="peckj.20140804114520.9427"><vh>@file ../plugins/nodetags.py</vh></v>
<v t="peckj.20131130132659.5964"><vh>@file ../plugins/nodewatch.py</vh></v>
</v>
<v t="ekr.20050111122605"><vh>Servers &amp; web stuff</vh>
<v t="ekr.20170925083314.1"><vh>@auto ../plugins/leo_cloud.py</vh></v>
<v t="ekr.20170925083853.1"><vh>@auto ../plugins/leo_cloud_server.py</vh></v>
<v t="ville.20110206142055.10640"><vh>@file ../plugins/leofeeds.py</vh></v>
<v t="ville.20110125222411.10536"><vh>@file ../plugins/leomail.py</vh></v>
<v t="ville.20091009202416.10040"><vh>@file ../plugins/leoremote.py</vh></v>
<v t="EKR.20040517080250.1"><vh>@file ../plugins/mod_http.py</vh></v>
<v t="ekr.20131004162848.11444"><vh>@file ../plugins/rss.py</vh></v>
<v t="peckj.20140811080604.9496"><vh>@file ../plugins/sftp.py</vh></v>
</v>
<v t="ekr.20101004082701.5674"><vh>Slideshows, screencasts &amp; screenshots</vh>
<v t="ekr.20170128213103.1"><vh>@file ../plugins/demo.py</vh></v>
<v t="ekr.20120913110135.10579"><vh>@file ../plugins/screencast.py</vh></v>
<v t="ekr.20101121031443.5330"><vh>@file ../plugins/screenshots.py</vh></v>
<v t="ekr.20060831165821"><vh>@file ../plugins/slideshow.py</vh></v>
</v>
<v t="ekr.20071113084440"><vh>Testing</vh>
<v t="ekr.20080214092357"><vh>@file ../plugins/test/ekr_test.py</vh></v>
<v t="ekr.20050130120433"><vh>@@file ../plugins/test/failed_import.py</vh></v>
<v t="ekr.20071113085315"><vh>@file ../plugins/test/failed_to_load_plugin.py</vh></v>
<v t="ekr.20051016160700"><vh>@file ../plugins/testRegisterCommand.py</vh></v>
</v>
<v t="ekr.20050306081349"><vh>Text formatting</vh>
<v t="timo.20050213160555"><vh>@file ../plugins/bibtex.py</vh></v>
<v t="ekr.20070119094733.1"><vh>@file ../plugins/dtest.py</vh></v>
<v t="ville.20110409151021.5699"><vh>@file ../plugins/jinjarender.py</vh></v>
<v t="danr7.20060902215215.1"><vh>@file ../plugins/leo_to_html.py</vh></v>
<v t="tbrown.20130930160706.23451"><vh>@file ../plugins/markup_inline.py</vh></v>
<v t="vitalije.20180804172140.1"><vh>@file ../plugins/md_docer.py</vh></v>
<v t="peckj.20140113150237.7083"><vh>@file ../plugins/nodediff.py</vh></v>
<v t="tbrown.20130813134319.11942"><vh>@file ../plugins/richtext.py</vh></v>
<v t="ekr.20170217164004.1"><vh>@file ../plugins/tables.py</vh></v>
</v>
<v t="ekr.20121126102050.10134"><vh>Threading</vh>
<v t="ekr.20121126095734.12418"><vh>@file ../plugins/threadutil.py</vh></v>
</v>
<v t="ekr.20040915073259"><vh>User interface</vh>
<v t="ekr.20101110150056.9453"><vh> Qt only plugins</vh>
<v t="tbrown.20091029123555.5319"><vh>@file ../plugins/attrib_edit.py</vh></v>
<v t="ville.20090310191936.10"><vh>@file ../plugins/colorize_headlines.py</vh></v>
<v t="ekr.20090701111504.5294"><vh>@file ../plugins/contextmenu.py</vh></v>
<v t="tbrown.20090206153748.1"><vh>@file ../plugins/graphcanvas.py</vh></v>
<v t="ville.20090518182905.5419"><vh>@file ../plugins/nav_qt.py</vh></v>
<v t="ville.20120604212857.4215"><vh>@file ../plugins/notebook.py</vh></v>
<v t="ekr.20090622063842.5264"><vh>@file ../plugins/projectwizard.py</vh></v>
<v t="ekr.20160928073518.1"><vh>@file ../plugins/pyplot_backend.py</vh></v>
<v t="ville.20090314215508.4"><vh>@file ../plugins/quicksearch.py</vh></v>
<v t="tbrown.20130420091241.44181"><vh>@file ../plugins/screen_capture.py</vh></v>
<v t="ville.20090815203828.5235"><vh>@file ../plugins/spydershell.py</vh></v>
<v t="ekr.20100103093121.5329"><vh>@file ../plugins/stickynotes.py</vh></v>
<v t="tbrown.20090119215428.2" descendentVnodeUnknownAttributes="7d71005808000000302e362e31332e3071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323031382d30382d313871077573732e"><vh>@file ../plugins/todo.py</vh></v>
<v t="ville.20110403115003.10348"><vh>@file ../plugins/valuespace.py</vh></v>
<v t="tbrown.20100318101414.5990"><vh>@file ../plugins/viewrendered.py</vh></v>
<v t="TomP.20191215195433.1"><vh>@file ../plugins/viewrendered3.py</vh></v>
</v>
<v t="ekr.20160519123329.1"><vh>@edit ../plugins/QNCalendarWidget.py</vh></v>
<v t="ekr.20060328125925"><vh>@file ../plugins/chapter_hoist.py</vh></v>
<v t="ville.20110115234843.8742"><vh>@file ../plugins/dragdropgoodies.py</vh></v>
<v t="vitalije.20190928154420.1"><vh>@file ../plugins/history_tracer.py</vh></v>
<v t="tbrown.20090513125417.5244"><vh>@file ../plugins/interact.py</vh></v>
<v t="vitalije.20170727201534.1"><vh>@file ../plugins/line_numbering.py</vh></v>
<v t="ekr.20040915073259.1"><vh>@file ../plugins/maximizeNewWindows.py</vh></v>
<v t="ekr.20101110093301.5818"><vh>@file ../plugins/mod_framesize.py</vh></v>
<v t="EKR.20040517080555.2"><vh>@file ../plugins/plugins_menu.py</vh></v>
<v t="edream.110203113231.924"><vh>@file ../plugins/redirect_to_log.py</vh></v>
<v t="ville.20110304230157.6513"><vh>@file ../plugins/systray.py</vh></v>
<v t="tbrown.20141101114322.1"><vh>@file ../plugins/wikiview.py</vh></v>
<v t="ekr.20181004143535.1"><vh>@file ../plugins/xdb_pane.py</vh></v>
<v t="ekr.20101110095202.5882"><vh>@file ../plugins/zenity_file_dialogs.py</vh></v>
</v>
<v t="ekr.20140726091031.18071"><vh>Writer plugins</vh>
<v t="ekr.20140726091031.18152"><vh>@file ../plugins/writers/__init__.py</vh></v>
<v t="ekr.20140726091031.18143"><vh>@file ../plugins/writers/basewriter.py</vh></v>
<v t="tbrown.20140804103545.29975"><vh>@file ../plugins/writers/ctext.py</vh></v>
<v t="ekr.20141116100154.2"><vh>@file ../plugins/writers/dart.py</vh></v>
<v t="ekr.20160412101901.1"><vh>@file ../plugins/writers/ipynb.py</vh></v>
<v t="ekr.20160504083330.1"><vh>@file ../plugins/writers/leo_json.py</vh></v>
<v t="ekr.20180202053206.1"><vh>@file ../plugins/writers/treepad.py</vh></v>
<v t="ekr.20140726091031.18080"><vh>@file ../plugins/writers/leo_rst.py</vh></v>
<v t="ekr.20140726091031.18073"><vh>@file ../plugins/writers/markdown.py</vh></v>
<v t="ekr.20140726091031.18079"><vh>@file ../plugins/writers/org.py</vh></v>
<v t="ekr.20140726091031.18078"><vh>@file ../plugins/writers/otl.py</vh></v>
</v>
</v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20171031111403.1"><vh>Leo Edit Pane</vh>
<v t="tbrown.20171029210211.1"><vh>@file ../plugins/editpane/clicky_splitter.py</vh></v>
<v t="tbrown.20171028115144.6"><vh>@file ../plugins/editpane/editpane.py</vh></v>
<v t="tbrown.20171028115144.5"><vh>@file ../plugins/editpane/leotextedit.py</vh></v>
<v t="tbrown.20171028115144.4"><vh>@file ../plugins/editpane/markdownview.py</vh></v>
<v t="tbrown.20171028115144.3"><vh>@file ../plugins/editpane/pandownview.py</vh></v>
<v t="tbrown.20171028115144.2"><vh>@file ../plugins/editpane/plaintextedit.py</vh></v>
<v t="tbrown.20171028115144.1"><vh>@file ../plugins/editpane/plaintextview.py</vh></v>
<v t="tbrown.20171028115143.3"><vh>@file ../plugins/editpane/vanillascintilla.py</vh></v>
<v t="tbrown.20171028115143.2"><vh>@file ../plugins/editpane/webengineview.py</vh></v>
<v t="tbrown.20171028115143.1"><vh>@file ../plugins/editpane/webkitview.py</vh></v>
<v t="tbrown.20171028115144.8"><vh>@file ../plugins/editpane/__init__.py</vh></v>
<v t="tbrown.20171028115541.1"><vh>@file signal_manager.py</vh></v>
</v>
<v t="ekr.20120419093256.10048"><vh>@file ../plugins/free_layout.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qt_commands.py</vh></v>
<v t="ekr.20140907103315.18766"><vh>@file ../plugins/qt_events.py</vh></v>
<v t="ekr.20140907123524.18774"><vh>@file ../plugins/qt_frame.py</vh></v>
<v t="ekr.20140907085654.18699"><vh>@file ../plugins/qt_gui.py</vh></v>
<v t="ekr.20140907103315.18777"><vh>@file ../plugins/qt_idle_time.py</vh></v>
<v t="ekr.20140907123524.18777"><vh>@file ../plugins/qt_quickheadlines.py</vh></v>
<v t="ekr.20140831085423.18598"><vh>@file ../plugins/qt_text.py</vh></v>
<v t="ekr.20140907131341.18707"><vh>@file ../plugins/qt_tree.py</vh></v>
<v t="ekr.20110605121601.18002"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20161223152017.1"><vh>@edit ../plugins/qt_quicksearch.py</vh></v>
<v t="ekr.20161223152353.1"><vh>@edit ../plugins/qt_quicksearch_sub.py</vh></v>
</v>
<v t="ekr.20180225010644.1"><vh>Other files</vh>
<v t="ekr.20180225010707.1"><vh>In leo-editor directory</vh>
<v t="maphew.20180224170853.1"><vh>@file ../../setup.py</vh></v>
<v t="ekr.20150304125314.4"><vh>@clean ../../leo_to_html.xsl</vh>
<v t="ekr.20150304130753.5"><vh>&lt;&lt;style&gt;&gt;</vh></v>
<v t="ekr.20150304130753.6"><vh>&lt;&lt;scripts&gt;&gt;</vh></v>
</v>
<v t="ekr.20181009072707.1"><vh>@clean ../../run_travis_unit_tests.py</vh></v>
<v t="ekr.20181014073705.1"><vh>@file ../../run_pytest_tests.py</vh></v>
<v t="ekr.20150304130753.4"><vh>leo-viewer/leo_to_html.xsl</vh></v>
</v>
<v t="ekr.20180225010913.1"><vh>In leo/core</vh>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py</vh></v>
</v>
<v t="ekr.20180225010743.1"><vh>In leo/external</vh>
<v t="ekr.20190607124533.1"><vh>@nopylint</vh>
<v t="ekr.20160123142722.1"><vh>@clean ../external/make_stub_files.cfg</vh></v>
<v t="ekr.20180708145905.1"><vh>@clean ../external/py2cs_theory.md</vh>
<v t="ekr.20180708152000.1"><vh>The problem</vh></v>
<v t="ekr.20180708152018.1"><vh>Design</vh></v>
<v t="ekr.20180708145905.6"><vh>Using TokenSync class</vh></v>
<v t="ekr.20180708145905.7"><vh>Summary</vh></v>
</v>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ekr.20130805134749.12436"><vh>@file ../external/edb.py</vh></v>
<v t="ekr.20120519121124.9919"><vh>@file ../external/leosax.py</vh></v>
<v t="ekr.20170429161422.1"><vh>@file ../external/log_broadcast.py</vh></v>
<v t="ekr.20170429153135.1"><vh>@file ../external/log_listener.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20160317054700.1"><vh>@file ../external/make_stub_files.py</vh></v>
<v t="ekr.20160316091132.1"><vh>@file ../external/py2cs.py</vh></v>
<v t="ekr.20170428085201.1"><vh>npyscreen</vh>
<v t="ekr.20170428084207.3"><vh>@file ../external/npyscreen/apNPSApplication.py</vh></v>
<v t="ekr.20170428084207.11"><vh>@file ../external/npyscreen/apNPSApplicationAdvanced.py</vh></v>
<v t="ekr.20170428084207.15"><vh>@file ../external/npyscreen/apNPSApplicationEvents.py</vh></v>
<v t="ekr.20170428084207.29"><vh>@file ../external/npyscreen/apNPSApplicationManaged.py</vh></v>
<v t="ekr.20170428084207.50"><vh>@file ../external/npyscreen/apOptions.py</vh></v>
<v t="ekr.20170428084207.111"><vh>@file ../external/npyscreen/eveventhandler.py</vh></v>
<v t="ekr.20170428084207.121"><vh>@file ../external/npyscreen/fmActionForm.py</vh></v>
<v t="ekr.20170428084207.131"><vh>@file ../external/npyscreen/fmActionFormV2.py</vh></v>
<v t="ekr.20170428084207.153"><vh>@file ../external/npyscreen/fmFileSelector.py</vh></v>
<v t="ekr.20170428084207.174"><vh>@file ../external/npyscreen/fmForm.py</vh></v>
<v t="ekr.20170428084207.223"><vh>@file ../external/npyscreen/fmFormMultiPage.py</vh></v>
<v t="ekr.20170428084207.248"><vh>@file ../external/npyscreen/fmFormMutt.py</vh></v>
<v t="ekr.20170428084207.258"><vh>@file ../external/npyscreen/fmFormMuttActive.py</vh></v>
<v t="ekr.20170428084207.285"><vh>@file ../external/npyscreen/fmFormWithMenus.py</vh></v>
<v t="ekr.20170428084207.303"><vh>@file ../external/npyscreen/fmPopup.py</vh></v>
<v t="ekr.20170428084207.311"><vh>@file ../external/npyscreen/fm_form_edit_loop.py</vh></v>
<v t="ekr.20170428084207.322"><vh>@file ../external/npyscreen/globals.py</vh></v>
<v t="ekr.20170428084207.324"><vh>@file ../external/npyscreen/muMenu.py</vh></v>
<v t="ekr.20170428084207.332"><vh>@file ../external/npyscreen/muNewMenu.py</vh></v>
<v t="ekr.20170428084207.351"><vh>@file ../external/npyscreen/npysGlobalOptions.py</vh></v>
<v t="ekr.20170428084207.353"><vh>@file ../external/npyscreen/npysNPSFilteredData.py</vh></v>
<v t="ekr.20170428084207.364"><vh>@file ../external/npyscreen/npyspmfuncs.py</vh></v>
<v t="ekr.20170428084207.370"><vh>@file ../external/npyscreen/npyssafewrapper.py</vh></v>
<v t="ekr.20170428084207.377"><vh>@file ../external/npyscreen/npysThemeManagers.py</vh></v>
<v t="ekr.20170428084207.390"><vh>@file ../external/npyscreen/npysThemes.py</vh></v>
<v t="ekr.20170428084207.399"><vh>@file ../external/npyscreen/npysTree.py</vh></v>
<v t="ekr.20170428084207.422"><vh>@file ../external/npyscreen/proto_fm_screen_area.py</vh></v>
<v t="ekr.20170428084207.434"><vh>@file ../external/npyscreen/stdfmemail.py</vh></v>
<v t="ekr.20170428084207.464"><vh>@file ../external/npyscreen/utilNotify.py</vh></v>
<v t="ekr.20170428084207.477"><vh>@file ../external/npyscreen/util_viewhelp.py</vh></v>
<v t="ekr.20170428084207.480"><vh>@file ../external/npyscreen/wgannotatetextbox.py</vh></v>
<v t="ekr.20170428084207.494"><vh>@file ../external/npyscreen/wgautocomplete.py</vh></v>
<v t="ekr.20170428084207.503"><vh>@file ../external/npyscreen/wgboxwidget.py</vh></v>
<v t="ekr.20170428084207.524"><vh>@file ../external/npyscreen/wgbutton.py</vh></v>
<v t="ekr.20170428084207.536"><vh>@file ../external/npyscreen/wgcheckbox.py</vh></v>
<v t="ekr.20170428084207.561"><vh>@file ../external/npyscreen/wgcombobox.py</vh></v>
<v t="ekr.20170428084207.575"><vh>@file ../external/npyscreen/wgdatecombo.py</vh></v>
<v t="ekr.20170428084207.586"><vh>@file ../external/npyscreen/wgeditmultiline.py</vh></v>
<v t="ekr.20170428084207.611"><vh>@file ../external/npyscreen/wgfilenamecombo.py</vh></v>
<v t="ekr.20170428084207.618"><vh>@file ../external/npyscreen/wgFormControlCheckbox.py</vh></v>
<v t="ekr.20170428084208.1"><vh>@file ../external/npyscreen/wggrid.py</vh></v>
<v t="ekr.20170428084208.36"><vh>@file ../external/npyscreen/wggridcoltitles.py</vh></v>
<v t="ekr.20170428084208.43"><vh>@file ../external/npyscreen/wgmonthbox.py</vh></v>
<v t="ekr.20170428084208.68"><vh>@file ../external/npyscreen/wgmultiline.py</vh></v>
<v t="ekr.20170428084208.157"><vh>@file ../external/npyscreen/wgmultilineeditable.py</vh></v>
<v t="ekr.20170428084208.173"><vh>@file ../external/npyscreen/wgmultilinetree.py</vh></v>
<v t="ekr.20170428084208.213"><vh>@file ../external/npyscreen/wgmultilinetreeselectable.py</vh></v>
<v t="ekr.20170428084208.225"><vh>@file ../external/npyscreen/wgmultiselect.py</vh></v>
<v t="ekr.20170428084208.245"><vh>@file ../external/npyscreen/wgmultiselecttree.py</vh></v>
<v t="ekr.20170428084208.253"><vh>@file ../external/npyscreen/wgNMenuDisplay.py</vh></v>
<v t="ekr.20170428084208.285"><vh>@file ../external/npyscreen/wgpassword.py</vh></v>
<v t="ekr.20170428084208.290"><vh>@file ../external/npyscreen/wgselectone.py</vh></v>
<v t="ekr.20170428084208.297"><vh>@file ../external/npyscreen/wgslider.py</vh></v>
<v t="ekr.20170428084208.318"><vh>@file ../external/npyscreen/wgtextbox.py</vh></v>
<v t="ekr.20170428084208.354"><vh>@file ../external/npyscreen/wgtextboxunicode.py</vh></v>
<v t="ekr.20170428084208.359"><vh>@file ../external/npyscreen/wgtextbox_controlchrs.py</vh></v>
<v t="ekr.20170428084208.366"><vh>@file ../external/npyscreen/wgtexttokens.py</vh></v>
<v t="ekr.20170428084208.381"><vh>@file ../external/npyscreen/wgtitlefield.py</vh></v>
<v t="ekr.20170428084208.398"><vh>@file ../external/npyscreen/wgwidget.py</vh></v>
<v t="ekr.20170428084208.436"><vh>@file ../external/npyscreen/wgwidget_proto.py</vh></v>
<v t="ekr.20170428084208.443"><vh>@@file ../external/npyscreen/__init__.py</vh>
<v t="ekr.20170428084208.444"><vh>Declarations</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20180225010850.1"><vh>In leo/modes</vh>
<v t="ekr.20150326145530.1"><vh>@clean ../modes/forth.py</vh>
<v t="ekr.20150326145530.2"><vh>&lt;&lt; define mode rules &gt;&gt;</vh></v>
<v t="ekr.20150326145530.3"><vh>&lt;&lt; define mode data &gt;&gt;</vh></v>
<v t="ekr.20150326145530.4"><vh>&lt;&lt; define extendForth class &gt;&gt;</vh>
<v t="ekr.20150326145530.5"><vh>ctor</vh></v>
<v t="ekr.20150326145530.6"><vh>init &amp; helper</vh>
<v t="ekr.20150326145530.7"><vh>splitList</vh></v>
</v>
<v t="ekr.20150326145530.8"><vh>createBracketRules &amp; helper</vh></v>
<v t="ekr.20150326145530.9"><vh>createDefiningWordRules &amp; helper</vh></v>
<v t="ekr.20150326145530.10"><vh>createKeywords</vh></v>
<v t="ekr.20150326145530.11"><vh>createStringRule</vh></v>
<v t="ekr.20150326145530.12"><vh>extendRulesDict</vh></v>
</v>
</v>
</v>
<v t="ekr.20181013081645.1"><vh>In leo/core/test</vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20160517182239.1"><vh>@file ../../flake8-leo.py</vh></v>
<v t="ekr.20160518000549.1"><vh>@file ../../pyflakes-leo.py</vh></v>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh></v>
<v t="ekr.20170805060844.1"><vh>@file ../test/leo-bridge-test.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904"><vh>@file leoTest.py</vh></v>
<v t="ekr.20201129023817.1"><vh>@file leoTest2.py</vh></v>
<v t="ekr.20201202144529.1"><vh>leo/unittests</vh>
<v t="ekr.20201202144422.1"><vh>@file ../unittests/commands/test_editCommands.py</vh></v>
<v t="ekr.20201203042030.1"><vh>@file ../unittests/core/test_leoNodes.py</vh></v>
</v>
</v>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943">@nosearch
</t>
<t tx="EKR.20040517075715"></t>
<t tx="EKR.20040517075715.13"></t>
<t tx="EKR.20040517075715.20">[Main]
use_styles = Yes
use_section_numbers = Yes
use_current_document = Yes
max_headings = 6
header_style = Heading
</t>
<t tx="EKR.20040517090508">@nocolor-node

Enable plugins by creating@enabled-plugins nodes in leoSettings files,
typically myLeoSettings.leo.See the node

Users Guide-- &gt; Chapter 8: Customizing Leo-- &gt;@rst
html\customizing.html-- &gt; Specifying settings-- &gt; Complex settings nodes

in LeoDocs.leo for full details.

**Important**: Leo no longer uses pluginsManager.txt to enable or disable plugins.
</t>
<t tx="TomP.20191215195433.13">def show_scrolled_message(tag, kw):
    if g.unitTesting:
        return None # This just slows the unit tests.

    c = kw.get('c')
    flags = kw.get('flags') or 'rst'
    vr3 = viewrendered(event=kw)
    title = kw.get('short_title', '').strip()
    vr3.setWindowTitle(title)
    s = '\n'.join([
        title,
        '=' * len(title),
        '',
        kw.get('msg')
    ])
    vr3.show_dock_or_pane() # #1332.
    vr3.update(
        tag='show-scrolled-message',
        keywords={'c': c, 'force': True, 's': s, 'flags': flags},
    )
    return True
</t>
<t tx="TomP.20191215195433.9">def init():
    """Return True if the plugin has loaded successfully."""
    #global got_docutils
    if g.app.gui.guiName() != 'qt':
        return False
            # #1248.
    # if g.app.gui.guiName()
    if not QtWidgets or not g.app.gui.guiName().startswith('qt'):
        if (not g.unitTesting\
            and not g.app.batchMode\
            and g.app.gui.guiName() in ('browser', 'curses')  # EKR.
           ):
            g.es_print('viewrendered3 requires Qt')
        return False
    if not QWebView:
        g.es_print('viewrendered3.py requires QtWebKitWidgets.QWebView')
        g.es_print('pip install PyQtWebEngine')
        return False
    if not got_docutils:
        g.es_print('Warning: viewrendered3.py running without docutils.')
    # Always enable this plugin, even if imports fail.
    g.plugin_signon(__name__)
    g.registerHandler('after-create-leo-frame', onCreate)
    g.registerHandler('close-frame', onClose)
    g.registerHandler('scrolledMessage', show_scrolled_message)
    return True
</t>
<t tx="ajones.20070122153625.2">def on_icondclick(tag, keywords):
    c = keywords.get("c")
    p = keywords.get("p")
    h = p.h
    if g.match_word(h,0,"@expfolder"):
        if p.hasChildren():
            result = g.app.gui.runAskYesNoDialog(c, "Reread?", "Reread contents of folder "+h[11:]+"?")
            if result == "no":
                return
            kids = []
            for cp in p.subtree():
                if cp.isDirty() and g.match_word(cp.h, 0, "@text"):
                    kids.append(cp.copy())
            if kids != []:
                result = g.app.gui.runAskYesNoDialog(c, "Reread?", "Save changed @text nodes?")
                if result == "yes":
                    for kid in kids:
                        savetextnode(c, kid)

            # delete children
            while p.firstChild():
                p.firstChild().doDelete()

        #changed = c.isChanged()
        dir = h[11:]
        dirs = []
        files = []
        for file in os.listdir(dir):
            path = os.path.join(dir, file)
            if os.path.isdir(path):
                dirs.append(path)
            else:
                files.append(path)

        #g.es('dirs: '+str(dirs))
        #g.es('files: '+str(files))

        dirs.sort()
        files.sort()
        for f in files:
            pn = p.insertAsNthChild(0)
            if os.path.splitext(f)[1] in textexts:
                c.setHeadString(pn, "@text "+f)
                pn.clearDirty()
            else:
                pn.h = f
        for d in dirs:
            pn = p.insertAsNthChild(0)
            c.setHeadString(pn, "@expfolder "+d)
        c.expandSubtree(p)
</t>
<t tx="ajones.20070122161942">def on_save(tag,keywords):
    c = keywords.get("c")
    if not c: return

    for p in c.all_positions():
        h = p.h
        if g.match_word(h,0,"@text") and p.isDirty():
            savetextnode(c, p)
            p.b = ""
</t>
<t tx="ajones.20070122181914.1">def readtextnode(c, p):

    name = getPath(c,p)
    try:
        file = open(name,"rU")
        g.es("..." + name)
        p.b = file.read()
        p.clearDirty()
        file.close()
    except IOError as msg:
        g.es("error reading %s: %s" % (name, msg))
        g.es("...not found: " + name)
        p.b = ''
        p.setDirty()
</t>
<t tx="btheado.20120129145543.8180">def pageUpDown(self, op, moveMode):
    """
    The QTextEdit PageUp/PageDown functionality seems to be "baked-in"
    and not externally accessible. Since Leo has its own keyhandling
    functionality, this code emulates the QTextEdit paging. This is a
    straight port of the C++ code found in the pageUpDown method of
    gui/widgets/qtextedit.cpp.
    """
    control = self.widget
    cursor = control.textCursor()
    moved = False
    lastY = control.cursorRect(cursor).top()
    distance = 0
    # move using movePosition to keep the cursor's x
    while True:
        y = control.cursorRect(cursor).top()
        distance += abs(y - lastY)
        lastY = y
        moved = cursor.movePosition(op, moveMode)
        if (not moved or distance &gt;= control.height()):
            break
    tc = QtGui.QTextCursor
    sb = control.verticalScrollBar()
    if moved:
        if (op == tc.Up):
            cursor.movePosition(tc.Down, moveMode)
            sb.triggerAction(QtWidgets.QAbstractSlider.SliderPageStepSub)
        else:
            cursor.movePosition(tc.Up, moveMode)
            sb.triggerAction(QtWidgets.QAbstractSlider.SliderPageStepAdd)
    control.setTextCursor(cursor)
</t>
<t tx="btheado.20131124162237.16303">def init_mode_from_module(self, name, mode):
    """
    Name may be a language name or a delegate name.
    Mode is a python module or class containing all
    coloring rule attributes for the mode.
    """
    language, rulesetName = self.nameToRulesetName(name)
    if mode:
        # A hack to give modes/forth.py access to c.
        if hasattr(mode, 'pre_init_mode'):
            mode.pre_init_mode(self.c)
    else:
        # Create a dummy bunch to limit recursion.
        self.modes[rulesetName] = self.modeBunch = g.Bunch(
            attributesDict={},
            defaultColor=None,
            keywordsDict={},
            language='unknown-language',
            mode=mode,
            properties={},
            rulesDict={},
            rulesetName=rulesetName,
            word_chars=self.word_chars,  # 2011/05/21
        )
        self.rulesetName = rulesetName
        self.language = 'unknown-language'
        return False
    self.language = language
    self.rulesetName = rulesetName
    self.properties = getattr(mode, 'properties', None) or {}
    #
    # #1334: Careful: getattr(mode, ivar, {}) might be None!
    #
    d = getattr(mode, 'keywordsDictDict', {}) or {}
    self.keywordsDict = d.get(rulesetName, {})
    self.setKeywords()
    d = getattr(mode, 'attributesDictDict', {}) or {}
    self.attributesDict = d.get(rulesetName, {})
    self.setModeAttributes()
    d = getattr(mode, 'rulesDictDict', {}) or {}
    self.rulesDict = d.get(rulesetName, {})
    self.addLeoRules(self.rulesDict)
    self.defaultColor = 'null'
    self.mode = mode
    self.modes[rulesetName] = self.modeBunch = g.Bunch(
        attributesDict=self.attributesDict,
        defaultColor=self.defaultColor,
        keywordsDict=self.keywordsDict,
        language=self.language,
        mode=self.mode,
        properties=self.properties,
        rulesDict=self.rulesDict,
        rulesetName=self.rulesetName,
        word_chars=self.word_chars,  # 2011/05/21
    )
    # Do this after 'officially' initing the mode, to limit recursion.
    self.addImportedRules(mode, self.rulesDict, rulesetName)
    self.updateDelimsTables()
    initialDelegate = self.properties.get('initialModeDelegate')
    if initialDelegate:
        # Replace the original mode by the delegate mode.
        self.init_mode(initialDelegate)
        language2, rulesetName2 = self.nameToRulesetName(initialDelegate)
        self.modes[rulesetName] = self.modes.get(rulesetName2)
        self.language = language2  # 2017/01/31
    else:
        self.language = language  # 2017/01/31
    return True
</t>
<t tx="danr7.20060912105041.6">def paste_as_headlines(c):
    # g.es("Starting...")
    currentPos = c.p
    clipText = g.app.gui.getTextFromClipboard()
    # Split clipboard text elements into a list
    clipList = clipText.split("\n")
    init_indent = len(clipList[0]) - len(clipList[0].lstrip())
    cur_pos = currentPos.copy()
    ancestors = [(init_indent,cur_pos)]
    for tempHead in clipList:
        indent = len(tempHead) - len(tempHead.lstrip())
        tempHead = tempHead.strip()
        # Make sure list item has some content
        if tempHead:
            if indent &gt; ancestors[-1][0]:
                ancestors.append((indent,cur_pos))
            else:
                while init_indent &lt;= indent &lt; ancestors[-1][0]:
                    ancestors.pop()
            # cur_indent = indent
            insertNode = ancestors[-1][1].insertAsLastChild()
            cur_pos = insertNode.copy()
            if len(tempHead)&gt;50:
                c.setHeadString(insertNode,tempHead[:50])
                insertNode.b = tempHead
            else:
                insertNode.h = tempHead
    currentPos.expand()
    c.redraw()
</t>
<t tx="edream.110203113231.667"></t>
<t tx="edream.110203113231.673"># name = tkFileDialog.askopenfilename(
    # title="Import Cisco Configuration File",
    # filetypes=[("All files", "*")]
    # )

name = g.app.gui.runOpenFileDialog (c,
    title="Import Cisco Configuration File",
    filetypes=[("All files", "*")],
    defaultextension='ini',
)

if not name:
    return

p = current.insertAsNthChild(0)
p.h = "cisco config: %s" % name
c.redraw()

try:
    fh = open(name)
    g.es("importing: %s" % name)
    linelist = fh.read().splitlines()
    fh.close()
except IOError as msg:
    g.es("error reading %s: %s" % (name, msg))
    return
</t>
<t tx="edream.110203113231.674">if customLine not in blocks:
    blocks[customLine] = []
    out.append(g.angleBrackets(customLine))
    # create first-level child
    child = p.insertAsNthChild(0)
    child.h = g.angleBrackets(customLine)
    children.append(child)

blocks[customLine].append(linelist[i])
</t>
<t tx="edream.110203113231.675">space = linelist[i].find(' ')
if space == -1:
    space = len(linelist[i])
key = linelist[i][:space]
if key in blocks:
    blocks[key] = []
    out.append(g.angleBrackets(key))
    # create first-level child
    child = p.insertAsNthChild(0)
    child.h = g.angleBrackets(key)
    children.append(child)

value = [linelist[i]]
# loop through the indented lines
i = i+1
try:
    while linelist[i].startswith(' '):
        value.append(linelist[i])
        i = i+1
except Exception:
    # EOF
    pass
i = i-1 # restore index
# now add the value to the dictionary
blocks[key].append(value)
</t>
<t tx="edream.110203113231.676"># first print the level-0 text
outClean = []
prev = ''
for line in out:
    if line=='!' and prev=='!':
        pass # skip repeated comment lines
    else:
        outClean.append(line)
    prev = line
p.b = '\n'.join(outClean)

# scan through the created outline and add children
for child in children:
    # extract the key from the headline. Uhm... :)
    key = child.h.split('&lt;&lt;'
        )[1].split('&gt;&gt;')[0].strip()
    if key in blocks:
        # if type(blocks[key][0]) == type(''):
        if g.isString(blocks[key][0]):
            # it's a string, no sub-children, so just print the text
            child.b = '\n'.join(blocks[key])
        else:
            # it's a multi-level node
            for value in blocks[key]:
                # each value is a list containing the headline and then the text
                subchild = child.insertAsNthChild(0)
                subchild.h = value[0]
                subchild.b = '\n'.join(value)
        # child.sortChildren()
    else:
        # this should never happen
        g.es("Unknown key: %s" % key)
# p.sortChildren()
current.expand()
c.redraw()
</t>
<t tx="edream.110203113231.729"></t>
<t tx="edream.110203113231.872">@nocolor-node

These plugins create new kinds of nodes, some of which affect the file system.</t>
<t tx="edream.110203113231.875">def sync_node_to_folder(c,parent,d):

    oldlist = {}
    newlist = []
    #get children info
    v = parent
    after_v = parent.nodeAfterTree()
    while v != after_v:
        if not v.hasChildren():
            oldlist[v.h] = v.b
        v = v.threadNext()
    #compare folder content to children
    for name in os.listdir(d):
        if name in oldlist:
            del oldlist[name]
        else:
            newlist.append(name)
    #insert newlist
    newlist.sort()
    newlist.reverse()
    for name in newlist:
        v = parent.insertAsNthChild(0)
        v.h = name
        v.setMarked()
    #warn for orphan oldlist
    if oldlist:
        g.es('missing: '+','.join(oldlist.keys()))
</t>
<t tx="edream.110203113231.894"># Sets p's body text from the file with the given name.
# Returns True if the body text changed.
def insert_read_only_node (c,p,name):
    if name=="":
        name = g.app.gui.runOpenFileDialog(c,
            title="Open",
            filetypes=[("All files", "*")],
        )
        p.h = "@read-only %s" % name
        c.redraw()
    parse = urlparse(name)
    try:
        if parse[0] == 'ftp':
            f = FTPurl(name)  # FTP URL
        elif parse[0] == 'http':
            f = urlopen(name)  # HTTP URL
        else:
            f = open(name,"r")  # local file
        g.es("..." + name)
        new = f.read()
        f.close()
    except IOError: # as msg:
        p.b = "" # Clear the body text.
        return True # Mark the node as changed.
    else:
        ext = os.path.splitext(parse[2])[1]
        if ext.lower() in ['.htm', '.html']:
            &lt;&lt; convert HTML to text &gt;&gt;
        previous = p.b
        p.b = new
        changed = (g.toUnicode(new) != g.toUnicode(previous))
        if changed and previous != "":
            g.es("changed: %s" % name) # A real change.
        return changed
</t>
<t tx="edream.110203113231.895">fh = StringIO()
fmt = AbstractFormatter(DumbWriter(fh))
# the parser stores parsed data into fh (file-like handle)
parser = HTMLParser(fmt)

# send the HTML text to the parser
parser.feed(new)
parser.close()

# now replace the old string with the parsed text
new = fh.getvalue()
fh.close()

# finally, get the list of hyperlinks and append to the end of the text
hyperlinks = parser.anchorlist
numlinks = len(hyperlinks)
if numlinks &gt; 0:
    hyperlist = ['\n\n--Hyperlink list follows--']
    for i in range(numlinks):
        hyperlist.append("\n[%d]: %s" % (i+1,hyperlinks[i])) # 3/26/03: was i.
    new = new + ''.join(hyperlist)
</t>
<t tx="edream.110203113231.928"># Same as frame.put except sends output to the end of the body text.
def newPut (self,s,*args,**keys):

    body = self.frame.body
    w = body.wrapper
    if w:
        w.insert("end",s)
        body.onBodyChanged('put-to-body-text')
    # else: g.pr(s,newline=False)

# Same as frame.putnl except sends output to the end of the body text.
def newPutNl (self,s,*args,**keys):

    newPut (self,'\n')
</t>
<t tx="ekr.20031218072017.1193">@g.commander_command('delete-node')
def deleteOutline(self, event=None, op_name="Delete Node"):
    """Deletes the selected outline."""
    c, u = self, self.undoer
    p = c.p
    if not p: return
    c.endEditing()  # Make sure we capture the headline for Undo.
    if False:  # c.config.getBool('select-next-after-delete'):
        # #721: Optionally select next node after delete.
        if p.hasVisNext(c): newNode = p.visNext(c)
        elif p.hasParent(): newNode = p.parent()
        else: newNode = p.back()  # _not_ p.visBack(): we are at the top level.
    else:
        # Legacy: select previous node if possible.
        if p.hasVisBack(c): newNode = p.visBack(c)
        else: newNode = p.next()  # _not_ p.visNext(): we are at the top level.
    if not newNode: return
    undoData = u.beforeDeleteNode(p)
    p.setDirty()
    p.doDelete(newNode)
    c.setChanged()
    u.afterDeleteNode(newNode, op_name, undoData)
    c.redraw(newNode)
    c.validateOutline()
</t>
<t tx="ekr.20031218072017.1329">def onBodyChanged(self, undoType, oldSel=None):
    """
    Update Leo after the body has been changed.
    
    This method is deprecated. New Leo commands and scripts should
    call u.before/afterChangeBody instead.
    """
    p, u, w = self.c.p, self.c.undoer, self.wrapper
    #
    # Shortcut.
    newText = w.getAllText()
    if p.b == newText:
        return
    #
    # Init data.
    newSel = w.getSelectionRange()
    newInsert = w.getInsertPoint()
    #
    # The "Before" snapshot.
    #
    # #1743: Restore oldSel for u.beforeChangeBody
    if oldSel and newSel and oldSel != newSel:
        i, j = oldSel
        w.setSelectionRange(i, j, insert=j)
    bunch = u.beforeChangeBody(p)
    #
    # #1743: Restore newSel if necessary.
    if oldSel and newSel and oldSel != newSel:
        i, j = newSel
        w.setSelectionRange(i, j, insert=newInsert)
    #
    # Careful. Don't redraw unless necessary.
    p.v.b = newText  # p.b would cause a redraw.
    #
    # "after" snapshot.
    u.afterChangeBody(p, undoType, bunch)
</t>
<t tx="ekr.20031218072017.1490">def doTyping(self, p, undo_type, oldText, newText,
    newInsert=None, oldSel=None, newSel=None, oldYview=None,
):
    """
    Save enough information to undo or redo a typing operation efficiently,
    that is, with the proper granularity.
    
    Do nothing when called from the undo/redo logic because the Undo
    and Redo commands merely reset the bead pointer.
    
    **Important**: Code should call this method *only* when the user has
    actually typed something. Commands should use u.beforeChangeBody and
    u.afterChangeBody.
    
    Only qtm.onTextChanged and ec.selfInsertCommand now call this method.
    """
    c, u, w = self.c, self, self.c.frame.body.wrapper
    # Leo 6.4: undo_type must be 'Typing'.
    undo_type = undo_type.capitalize()
    assert undo_type == 'Typing', (repr(undo_type), g.callers())
    &lt;&lt; return if there is nothing to do &gt;&gt;
    &lt;&lt; init the undo params &gt;&gt;
    &lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
    &lt;&lt; save undo text info &gt;&gt;
    &lt;&lt; save the selection and scrolling position &gt;&gt;
    &lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;
    if 'undo' in g.app.debug and 'verbose' in g.app.debug:
        print(f"u.doTyping: {len(oldText)} =&gt; {len(newText)}")
    if u.per_node_undo:
        u.putIvarsToVnode(p)
    #
    # Finish updating the text.
    p.v.setBodyString(newText)
    u.updateAfterTyping(p, w)
        
# Compatibility

setUndoTypingParams = doTyping
</t>
<t tx="ekr.20031218072017.1491">@ Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c
old_lines = oldText.split('\n')
new_lines = newText.split('\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len, new_len)
i = 0
while i &lt; min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i
if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i &lt; min_len - leading:
        if old_lines[old_len - i - 1] != new_lines[new_len - i - 1]:
            break
        i += 1
    trailing = i
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading : -trailing]
    new_middle_lines = new_lines[leading : -trailing]
# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1; old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1
i = len(newText) - 1; new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1
</t>
<t tx="ekr.20031218072017.1492">u.oldText = None
u.newText = None
u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
</t>
<t tx="ekr.20031218072017.1553">def getLeoFile(self,
    theFile,
    fileName,
    readAtFileNodesFlag=True,
    silent=False,
    checkOpenFiles=True,
):
    """
        Read a .leo file.
        The caller should follow this with a call to c.redraw().
    """
    fc, c = self, self.c
    t1 = time.time()
    c.clearChanged()  # May be set when reading @file nodes.
    fc.warnOnReadOnlyFiles(fileName)
    fc.checking = False
    fc.mFileName = c.mFileName
    fc.initReadIvars()
    recoveryNode = None
    try:
        c.loading = True  # disable c.changed
        if not silent and checkOpenFiles:
            # Don't check for open file when reverting.
            g.app.checkForOpenFile(c, fileName)
        #
        # Read the .leo file and create the outline.
        if fileName.endswith('.db'):
            v = fc.retrieveVnodesFromDb(theFile) or fc.initNewDb(theFile)
        else:
            v = FastRead(c, self.gnxDict).readFile(theFile, fileName)
            if v:
                c.hiddenRootNode = v
        if v:
            fc.resolveTnodeLists()
                # Do this before reading external files.
            c.setFileTimeStamp(fileName)
            if readAtFileNodesFlag:
                # c.redraw()
                    # Does not work.
                    # Redraw before reading the @file nodes so the screen isn't blank.
                    # This is important for big files like LeoPy.leo.
                recoveryNode = fc.readExternalFiles(fileName)
    finally:
        p = recoveryNode or c.p or c.lastTopLevel()
            # lastTopLevel is a better fallback, imo.
        c.selectPosition(p)
        c.redraw_later()
            # Delay the second redraw until idle time.
            # This causes a slight flash, but corrects a hangnail.
        c.checkOutline()
            # Must be called *after* ni.end_holding.
        c.loading = False
            # reenable c.changed
        if not isinstance(theFile, sqlite3.Connection):
            theFile.close()
            # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1208942
            # Leo holding directory/file handles after file close?
    if c.changed:
        fc.propegateDirtyNodes()
    fc.initReadIvars()
    t2 = time.time()
    g.es(f"read outline in {t2 - t1:2.2f} seconds")
    return v, c.frame.ratio
</t>
<t tx="ekr.20031218072017.1554">def warnOnReadOnlyFiles(self, fileName):
    # os.access may not exist on all platforms.
    try:
        self.read_only = not os.access(fileName, os.W_OK)
    except AttributeError:
        self.read_only = False
    except UnicodeError:
        self.read_only = False
    if self.read_only and not g.unitTesting:
        g.error("read only:", fileName)
</t>
<t tx="ekr.20031218072017.1623">@g.commander_command('file-new')
@g.commander_command('new')
def new(self, event=None, gui=None):
    """Create a new Leo window."""
    from leo.core import leoApp
    lm = g.app.loadManager
    old_c = self
    # Clean out the update queue so it won't interfere with the new window.
    self.outerUpdate()
    # Supress redraws until later.
    g.app.disable_redraw = True
    # Send all log messages to the new frame.
    g.app.setLog(None)
    g.app.lockLog()
    # Retain all previous settings. Very important for theme code.
    c = g.app.newCommander(
        fileName=None,
        gui=gui,
        previousSettings=leoApp.PreviousSettings(
            settingsDict=lm.globalSettingsDict,
            shortcutsDict=lm.globalBindingsDict,
        ))
    frame = c.frame
    g.app.unlockLog()
    if not old_c:
        frame.setInitialWindowGeometry()
    # #1643: This doesn't work.
        # g.app.restoreWindowState(c)
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    lm.createMenu(c)
    lm.finishOpen(c)
    g.app.writeWaitingLog(c)
    g.doHook("new", old_c=old_c, c=c, new_c=c)
    c.setLog()
    c.clearChanged()  # Fix #387: Clear all dirty bits.
    g.app.disable_redraw = False
    c.redraw()
    return c  # For unit tests and scripts.
</t>
<t tx="ekr.20031218072017.1980">def setIDFromFile(self, verbose):
    """Attempt to set g.app.leoID from leoID.txt."""
    tag = ".leoID.txt"
    for theDir in (self.homeLeoDir, self.globalConfigDir, self.loadDir):
        if not theDir:
            continue  # Do not use the current directory!
        fn = g.os_path_join(theDir, tag)
        try:
            with open(fn, 'r') as f:
                s = f.readline().strip()
            if not s:
                continue
            # #1404: Ensure valid ID.
            id_ = self.cleanLeoID(s, tag)
                # cleanLeoID raises a warning dialog.
            if len(id_) &gt; 2:
                self.leoID = id_
                return
        except IOError:
            pass
        except Exception:
            g.error('unexpected exception in app.setLeoID')
            g.es_exception()
</t>
<t tx="ekr.20031218072017.1981">def setIdFromDialog(self):
    """Get leoID from a Tk dialog."""
    #
    # Don't put up a splash screen: it would obscure the coming dialog.
    self.use_splash_screen = False
    #
    # Get the id, making sure it is at least three characters long.
    while True:
        dialog = g.TkIDDialog()
        dialog.run()
        # #1404: Make sure the id will not corrupt the .leo file.
        id_ = self.cleanLeoID(dialog.val, "")
        if id_ and len(id_) &gt; 2:
            break
    #
    # Put result in g.app.leoID.
    self.leoID = id_
    g.blue('leoID=', repr(self.leoID), spaces=False)
</t>
<t tx="ekr.20031218072017.2377">def getSelectionLines(self):
    """
    Return before,sel,after where:

    before is the all lines before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is all lines after the selected text
    (or the text after the insert point if no selection)
    """
    if g.app.batchMode:
        return '', '', ''
    # At present, called only by c.getBodyLines.
    body = self
    w = body.wrapper
    s = w.getAllText()
    i, j = w.getSelectionRange()
    if i == j:
        i, j = g.getLine(s, i)
    else:
        # #1742: Move j back if it is at the start of a line.
        if j &gt; i and j &gt; 0 and s[j-1] == '\n':
            j -= 1
        i, junk = g.getLine(s, i)
        junk, j = g.getLine(s, j)
    before = g.checkUnicode(s[0:i])
    sel = g.checkUnicode(s[i:j])
    after = g.checkUnicode(s[j : len(s)])
    return before, sel, after  # 3 strings.
</t>
<t tx="ekr.20031218072017.2406" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e"># This file contains almost all of Leo's sources.

# See the "About this file" node for important notes.
</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2609">def closeLeoWindow(self, frame, new_c=None, finish_quit=True):
    """
    Attempt to close a Leo window.

    Return False if the user veto's the close.

    finish_quit - usually True, close Leo when last file closes, but
                  False when closing an already-open-elsewhere file
                  during initial load, so UI remains for files
                  further along the command line.
    """
    c = frame.c
    if 'shutdown' in g.app.debug:
        g.trace(f"changed: {c.changed} {c.shortFileName()}")
    c.endEditing()  # Commit any open edits.
    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False
    g.app.recentFilesManager.writeRecentFilesFile(c)
        # Make sure .leoRecentFiles.txt is written.
    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False
    g.app.setLog(None)  # no log until we reactive a window.
    g.doHook("close-frame", c=c)
    #
    # Save the window state for *all* open files.
    g.app.commander_cacher.commit()
        # store cache, but don't close it.
    # This may remove frame from the window list.
    if frame in g.app.windowList:
        g.app.destroyWindow(frame)
        g.app.windowList.remove(frame)
    else:
        # #69.
        g.app.forgetOpenFile(fn=c.fileName(), force=True)
    if g.app.windowList:
        c2 = new_c or g.app.windowList[0].c
        g.app.selectLeoWindow(c2)
    elif finish_quit and not g.app.unitTesting:
        g.app.finishQuit()
    return True  # The window has been closed.
</t>
<t tx="ekr.20031218072017.2916">@g.commander_command('goto-next-clone')
def goToNextClone(self, event=None):
    """
    Select the next node that is a clone of the selected node.
    If the selected node is not a clone, do find-next-clone.
    """
    c, p = self, self.p
    cc = c.chapterController; p = c.p
    if not p:
        return
    if not p.isCloned():
        c.findNextClone()
        return
    v = p.v
    p.moveToThreadNext()
    wrapped = False
    while 1:
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()
    if p:
        c.expandAllAncestors(p)
        if cc:
            # #252: goto-next clone activate chapter.
            chapter = cc.getSelectedChapter()
            old_name = chapter and chapter.name
            new_name = cc.findChapterNameForPosition(p)
            if new_name == old_name:
                # Always do a full redraw.
                c.redraw(p)
            else:
                if 1:
                    cc.selectChapterByName(new_name)
                    c.redraw(p)
                else:  # Old code.
                    c.selectPosition(p)
                    cc.selectChapterByName(new_name)
        else:
            # Always do a full redraw.
            c.redraw(p)
    else:
        g.blue('done')
</t>
<t tx="ekr.20031218072017.2943">@g.commander_command('open-leo-settings')
@g.commander_command('open-leo-settings-leo')  # #1343.
@g.commander_command('leo-settings')
def openLeoSettings(self, event=None):
    """Open leoSettings.leo in a new Leo window."""
    c, lm = self, g.app.loadManager
    path = lm.computeLeoSettingsPath()
    if path:
        return g.openWithFileName(path, old_c=c)
    g.es('not found: leoSettings.leo')
    return None

@g.commander_command('open-my-leo-settings')
@g.commander_command('open-my-leo-settings-leo')  # #1343.
@g.commander_command('my-leo-settings')
def openMyLeoSettings(self, event=None):
    """Open myLeoSettings.leo in a new Leo window."""
    c, lm = self, g.app.loadManager
    path = lm.computeMyLeoSettingsPath()
    if path:
        return g.openWithFileName(path, old_c=c)
    g.es('not found: myLeoSettings.leo')
    return createMyLeoSettings(c)
</t>
<t tx="ekr.20031218072017.3029">def readAtFileNodes(self):
    
    c, p = self.c, self.c.p
    c.endEditing()
    c.atFileCommands.readAll(p, force=True)
    c.redraw()
    # Force an update of the body pane.
    c.setBodyString(p, p.b)  # Not a do-nothing!
    
</t>
<t tx="ekr.20031218072017.3043">def saveAs(self, fileName):
    c = self.c
    p = c.p
    if not g.doHook("save1", c=c, p=p, fileName=fileName):
        c.endEditing()  # Set the current headline text.
        if c.sqlite_connection:
            c.sqlite_connection.close()
            c.sqlite_connection = None
        self.setDefaultDirectoryForNewFiles(fileName)
        g.app.commander_cacher.save(c, fileName, changeName=True)
        # Disable path-changed messages in writeAllHelper.
        c.ignoreChangedPaths = True
        try:
            if self.write_Leo_file(fileName, outlineOnlyFlag=False):
                c.clearChanged()  # Clears all dirty bits.
                self.putSavedMessage(fileName)
        finally:
            c.ignoreChangedPaths = False  # #1367.
        c.redraw_after_icons_changed()
    g.doHook("save2", c=c, p=p, fileName=fileName)
</t>
<t tx="ekr.20031218072017.3069">def changeAll(self):

    c, current, u = self.c, self.c.p, self.c.undoer
    undoType = 'Replace All'
    t1 = time.process_time()
    if not self.checkArgs():
        return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    u.beforeChangeGroup(current, undoType)
    # Fix bug 338172: ReplaceAll will not replace newlines
    # indicated as \n in target string.
    if not self.find_text:
        return
    if not self.search_headline and not self.search_body:
        return
    self.change_text = self.replaceBackSlashes(self.change_text)
    if self.pattern_match:
        ok = self.precompilePattern()
        if not ok:
            return
    # #1428: Honor limiters in replace-all.
    if self.node_only:
        positions = [c.p]
    elif self.suboutline_only:
        positions = c.p.self_and_subtree()
    else:
        positions = c.all_unique_positions()
    count = 0
    for p in positions:
        count_h, count_b = 0, 0
        undoData = u.beforeChangeNodeContents(p)
        if self.search_headline:
            count_h, new_h = self.batchSearchAndReplace(p.h)
            if count_h:
                count += count_h
                p.h = new_h
        if self.search_body:
            count_b, new_b = self.batchSearchAndReplace(p.b)
            if count_b:
                count += count_b
                p.b = new_b
        if count_h or count_b:
            u.afterChangeNodeContents(p, 'Replace All', undoData)
    p = c.p
    u.afterChangeGroup(p, undoType, reportFlag=True)
    t2 = time.process_time()
    g.es_print(f"changed {count} instances{g.plural(count)} in {t2 - t1:4.2f} sec.")
    c.recolor()
    c.redraw(p)
    self.restore(saveData)
</t>
<t tx="ekr.20031218072017.3070"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):
    c = self.c
    p = self.p or c.p  # 2015/06/22
    wrapper = c.frame.body and c.frame.body.wrapper
    w = c.edit_widget(p) if self.in_headline else wrapper
    if not w:
        self.in_headline = False
        w = wrapper
    if not w: return False
    oldSel = sel = w.getSelectionRange()
    start, end = sel
    if start &gt; end: start, end = end, start
    if start == end:
        g.es("no text selected"); return False
    # Replace the selection in _both_ controls.
    start, end = oldSel
    change_text = self.change_text
    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text, groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)
    for w2 in (w, self.s_ctrl):
        if start != end: w2.delete(start, end)
        w2.insert(start, change_text)
        w2.setInsertPoint(start if self.reverse else start + len(change_text))
    # Update the selection for the next match.
    w.setSelectionRange(start, start + len(change_text))
    c.widgetWantsFocus(w)
    # No redraws here: they would destroy the headline selection.
    if self.mark_changes:
        p.setMarked()
        p.setDirty()
    if self.in_headline:
        pass
    else:
        c.frame.body.onBodyChanged('Change', oldSel=oldSel)
    c.frame.tree.updateIcon(p)  # redraw only the icon.
    return True
</t>
<t tx="ekr.20031218072017.3084">def initBatchCommands(self):
    """Init for find-all and replace-all commands."""
    c = self.c
    self.errors = 0
    self.in_headline = self.search_headline  # Search headlines first.
    # Select the first node.
    if self.suboutline_only or self.node_only:
        self.p = c.p
        # #188: Find/Replace All Suboutline only same as Node only.
        self.onlyPosition = self.p.copy()
    else:
        p = c.rootPosition()
        if self.reverse:
            while p and p.next():
                p = p.next()
            p = p.lastNode()
        self.p = p
    # Set the insert point.
    self.initBatchText()
</t>
<t tx="ekr.20031218072017.3091">def showSuccess(self, pos, newpos, showState=True):
    """Display the result of a successful find operation."""
    c = self.c
    self.p = p = self.p or c.p
    # Set state vars.
    # Ensure progress in backwards searches.
    insert = min(pos, newpos) if self.reverse else max(pos, newpos)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p
    if c.sparse_find:
        c.expandOnlyAncestorsOfNode(p=p)
    if self.in_headline:
        c.endEditing()
        selection = pos, newpos, insert
        c.redrawAndEdit(p,
            selection=selection,
            keepMinibuffer=True)
        w = c.edit_widget(p)
        self.was_in_headline = True  # 2015/03/25
    else:
        # Tricky code.  Do not change without careful thought.
        w = c.frame.body.wrapper
        # *Always* do the full selection logic.
        # This ensures that the body text is inited  and recolored.
        c.selectPosition(p)
        c.bodyWantsFocus()
        if showState:
            c.k.showStateAndMode(w)
        c.bodyWantsFocusNow()
        w.setSelectionRange(pos, newpos, insert=insert)
        k = g.see_more_lines(w.getAllText(), insert, 4)
        w.see(k)
            # #78: find-next match not always scrolled into view.
        c.outerUpdate()
            # Set the focus immediately.
        if c.vim_mode and c.vimCommands:
            c.vimCommands.update_selection_after_search()
    # Support for the console gui.
    if hasattr(g.app.gui, 'show_find_success'):
        g.app.gui.show_find_success(c, self.in_headline, insert, p)
    c.frame.bringToFront()
    return w  # Support for isearch.
</t>
<t tx="ekr.20031218072017.3103">def computeWindowTitle(fileName):

    branch, commit = g.gitInfoForFile(fileName)  # #1616
    if not fileName:
        return branch + ": untitled" if branch else 'untitled'
    path, fn = g.os_path_split(fileName)
    if path:
        title = fn + " in " + path
    else:
        title = fn
    # Yet another fix for bug 1194209: regularize slashes.
    if os.sep in '/\\':
        title = title.replace('/', os.sep).replace('\\', os.sep)
    if branch:
        title = branch + ": " + title
    return title
</t>
<t tx="ekr.20031218072017.3119">def makeAllNonExistentDirectories(theDir):
    """
    A wrapper from os.makedirs.
    Attempt to make all non-existent directories.

    Return True if the directory exists or was created successfully.
    """
    # Return True if the directory already exists.
    theDir = g.os_path_normpath(theDir)
    ok = g.os_path_isdir(theDir) and g.os_path_exists(theDir)
    if ok:
        return theDir
    # #1450: Create the directory with os.makedirs.
    try:
        os.makedirs(theDir, mode=0o777, exist_ok=False)
        return theDir
    except Exception:
        return None
</t>
<t tx="ekr.20031218072017.3210">def createOutline(self,
    fileName,
    parent,
    atShadow=False,  # For error messages only.
    ext=None,
    s=None,
    # force_at_others=False,  # tag:no-longer-used
):
    """
    Create an outline by importing a file, reading the file with the
    given encoding if string s is None.

    ext,        The file extension to be used, or None.
    fileName:   A string or None. The name of the file to be read.
    parent:     The parent position of the created outline.
    s:          A string or None. The file's contents.
    """
    c = self.c
    p = parent.copy()
    self.treeType = '@file'
        # Fix #352.
    fn = self.get_import_filename(fileName, parent)
    if g.is_binary_external_file(fileName):
        return self.import_binary_file(fn, parent)
    # Init ivars.
    self.setEncoding(
        p=parent,
        default=c.config.default_at_auto_file_encoding,
    )
    ext, s = self.init_import(atShadow, ext, fileName, s)
    if s is None:
        return None
    # Get the so-called scanning func.
    func = self.dispatch(ext, p)
        # Func is a callback. It must have a c argument.
    # Call the scanning function.
    if g.unitTesting:
        assert func or ext in ('.txt', '.w', '.xxx'), (repr(func), ext, p.h)
    if func and not c.config.getBool('suppress-import-parsing', default=False):
        s = g.toUnicode(s, encoding=self.encoding)
        s = s.replace('\r', '')
        # func is actually a factory: it instantiates the importer class.
        func(c=c, parent=p, s=s)
            # force_at_others=force_at_others #tag:no-longer-used
    else:
        # Just copy the file to the parent node.
        s = g.toUnicode(s, encoding=self.encoding)
        s = s.replace('\r', '')
        self.scanUnknownFileType(s, p, ext)
    # Fix bug 488894: unsettling dialog when saving Leo file
    # Fix bug 889175: Remember the full fileName.
    c.atFileCommands.rememberReadPath(fileName, p)
    p.contract()
    w = c.frame.body.wrapper
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
</t>
<t tx="ekr.20031218072017.3344">def __init__(self, context, gnx=None):
    """
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = 1 whenever
    v.unknownAttributes or any mutable VNode object changes.
    """
    # The primary data: headline and body text.
    self._headString = 'newHeadline'
    self._bodyString = ''
    # Structure data...
    self.children = []
        # Ordered list of all children of this node.
    self.parents = []
        # Unordered list of all parents of this node.
    # Other essential data...
    self.fileIndex = None
        # The immutable fileIndex (gnx) for this node. Set below.
    self.iconVal = 0
        # The present value of the node's icon.
    self.statusBits = 0
        # status bits
    # Information that is never written to any file...
    self.context = context  # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.expandedPositions = []
        # Positions that should be expanded.
    self.insertSpot = None
        # Location of previous insert point.
    self.scrollBarSpot = None
        # Previous value of scrollbar position.
    self.selectionLength = 0
        # The length of the selected body text.
    self.selectionStart = 0
        # The start of the selected body text.
    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
</t>
<t tx="ekr.20031218072017.3351">def isAtIgnoreNode(self):
    """
    Returns True if:
        
    - the vnode' body contains @ignore at the start of a line or

    - the vnode's headline starts with @ignore.
    """
    # v = self
    if g.match_word(self._headString, 0, '@ignore'):
        return True
    flag, i = g.is_special(self._bodyString, "@ignore")
    return flag
</t>
<t tx="ekr.20031218072017.3395">def contract(self):
    """Contract the node."""
    self.statusBits &amp;= ~self.expandedBit

def expand(self):
    """Expand the node."""
    self.statusBits |= self.expandedBit

def initExpandedBit(self):
    """Init self.statusBits."""
    self.statusBits |= self.expandedBit

def isExpanded(self):
    """Return True if the VNode expansion bit is set."""
    return (self.statusBits &amp; self.expandedBit) != 0
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.3783">def canonicalizeMenuName(self, name):

    # #1121 &amp; #1188. Allow Chinese characters in command names
    if g.isascii(name):
        return ''.join([ch for ch in name.lower() if ch.isalnum()])
    return name

def canonicalizeTranslatedMenuName(self, name):

    # #1121 &amp; #1188. Allow Chinese characters in command names
    if g.isascii(name):
        return ''.join([ch for ch in name.lower() if ch not in '&amp; \t\n\r'])
    return ''.join([ch for ch in name if ch not in '&amp; \t\n\r'])
</t>
<t tx="ekr.20031218072017.4117">def defineMenuCallback(self, command, name, minibufferCommand):
    # pylint: disable=no-else-return
        # This code is simpler as it is.
    c = self.c
    if minibufferCommand:
        # Create a dummy event as a signal to doCommand.
        event = g.app.gui.create_key_event(c)
        # The first parameter must be event, and it must default to None.

        def minibufferMenuCallback(event=event, self=self, command=command, label=name):
            c = self.c
            return c.doCommand(command, label, event)

        return minibufferMenuCallback
    else:
        # The first parameter must be event, and it must default to None.

        def legacyMenuCallback(event=None, self=self, command=command, label=name):
            c = self.c # 2012/03/04.
            c.check_event(event)
            return c.doCommand(command, label)

        return legacyMenuCallback
</t>
<t tx="ekr.20040205071616.4">def setHeadOK(c,v):

    v.h = OKFLAG + v.h

</t>
<t tx="ekr.20040205071616.5">def insertBodystamp (c,v):

    p, u, w = c.p, c.undoer, c.frame.body.wrapper
    stamp = mnOKstamp() + '\n'
    bunch = u.beforeChangeBody(p)
    ins = w.getInsertPoint()
    w.insert(ins,stamp)
    p.v.b = w.getAllText()  # p.b would cause a redraw.
    u.afterChangeBody(p, 'insert-timestamp', bunch)
</t>
<t tx="ekr.20040205071616.9">def insertUser (self,event=None):
    """Handle the Insert User command."""
    c = self
    w = c.frame.body.wrapper
    oldSel = w.getSelectionRange()
    w.deleteTextSelection() # Works if nothing is selected.
    stamp = mnstamp()
    i = w.getInsertPoint()
    w.insert(i,stamp)
    c.frame.body.onBodyChanged('insert-user',oldSel=oldSel)
</t>
<t tx="ekr.20040303175026.6">def moveToRoot(self):
    """Move self to the root position."""
    p = self  # Do NOT copy the position!
    #
    # #1631. The old root can not possibly be affected by unlinking p.
    p._unlink()
    p._linkAsRoot()
    return p
</t>
<t tx="ekr.20040305223225">def setHeadString(self, p, s):
    """
    Set the p's headline and the corresponding tree widget to s.

    This is used in by unit tests to restore the outline.
    """
    c = self
    p.initHeadString(s)
    p.setDirty()
    # Change the actual tree widget so
    # A later call to c.endEditing or c.redraw will use s.
    c.frame.tree.setHeadline(p, s)
</t>
<t tx="ekr.20040305223522">def setBodyString(self, p, s):
    """
    This is equivalent to p.b = s.
    
    Warning: This method may call c.recolor() or c.redraw().
    """
    c, v = self, p.v
    if not c or not v:
        return
    s = g.toUnicode(s)
    current = c.p
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v == current.v:
        w = c.frame.body.wrapper
        w.setAllText(s)
        v.setSelection(0,0)
        c.recolor()
    # Keep the body text in the VNode up-to-date.
    if v.b != s:
        v.setBodyString(s)
        v.setSelection(0, 0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged()
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20040315032503">def appendStringToBody(self, p, s):

    if s:
        p.b = p.b + g.toUnicode(s)
</t>
<t tx="ekr.20040324061854">if u.redoing or u.undoing:
    return None
if undo_type is None:
    return None
if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes()  # Must still recalculate the menu labels.
    return None
if oldText == newText:
    u.setUndoTypes()  # Must still recalculate the menu labels.
    return None
</t>
<t tx="ekr.20040324061854.1">u.clearOptionalIvars()
# Set the params.
u.undoType = undo_type
u.p = p.copy()
</t>
<t tx="ekr.20040324061854.2"># Remember the selection.
u.oldSel = oldSel
u.newSel = newSel
# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.wrapper.getYScrollPosition()
</t>
<t tx="ekr.20040324061854.3">@
New in Leo 4.3. Instead of creating a new bead on every character, we
may adjust the top bead:
word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c
granularity = u.granularity
old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')
&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;
# Save end selection as new "previous" selection
u.prevSel = u.newSel
if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p=p.copy(),
        kind='typing',  # lowercase.
        undoType=undo_type,  # capitalized.
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldMarked=old_p.isMarked() if old_p else p.isMarked(), # #1694
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d
bunch.leading = u.leading
bunch.trailing = u.trailing
bunch.newMarked = p.isMarked()  # #1694 
bunch.newNewlines = u.newNewlines
bunch.newMiddleLines = u.newMiddleLines
bunch.newSel = u.newSel
bunch.newText = u.newText
bunch.yview = u.yview
</t>
<t tx="ekr.20040327105706">def __init__(self, c, title, gui):
    """Ctor for the NullFrame class."""
    super().__init__(c, gui)
    assert self.c
    self.wrapper = None
    self.iconBar = NullIconBarClass(self.c, self)
    self.initComplete = True
    self.isNullFrame = True
    self.outerFrame = None
    self.ratio = self.secondary_ratio = 0.5
    self.statusLineClass = NullStatusLineClass
    self.title = title
    self.top = None  # Always None.
    # Create the component objects.
    self.body = NullBody(frame=self, parentFrame=None)
    self.log = NullLog(frame=self, parentFrame=None)
    self.menu = leoMenu.NullMenu(frame=self)
    self.tree = NullTree(frame=self)
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
</t>
<t tx="ekr.20040331071919"></t>
<t tx="ekr.20040331071919.31">@language python
@tabwidth -4

@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:10 CST 2004  michael@redpriest _OpenWith_Plugin__140659092.py"

Leo's Open_With plugin can be modified so that the body text of any
outline node can be edited in XEmacs by choosing "File; OpenWith;
XEmacs" or "File; OpenWith; XEmacs - noshow"  from the menu.

What actually happens is that Leo places the text in a temporary
file, and calls XEmacs with the address of that temporary file.  Leo
then watches for changes in the temporary file.  When and if the
temporary file changes, Leo copies the contents to the body text of
the Leo node.

Below is the standard open_with.py plugin that came with Leo 4.1-rc3
The only modification I've made is to insert
@code
&lt;&lt;call XEmacs&gt;&gt;=
table = (
    ("X&amp;Emacs", "Alt+Shift+O", ("os.system","/usr/bin/gnuclient -q ", None)),
    ("X&amp;Emacs - noshow", "Ctrl+Shift+O", ("os.system","/mrc2/linux-bin/gnuclient-noshow ", None))
    )
@doc
as noted below.  A similar alteration should work for future
versions.

Note: this alteration is for XEmacs running under Linux, but a
similar command should work in the Windows environment.

I use the "gnuclient-noshow" selection to load the temporary open_with file in
the background.  It is a small bash shell script:
---
#!/bin/bash
gnuclient -eval "(find-file-noselect \"${1}\")"
---

To implement this, edit a copy of the open_with.py file that comes
with your version of Leo.  Move the original copy to a safe place,
and put your edited copy in the Leo plugins directory.  Check to see
it is included in "pluginsManager.txt" in that directory.
@ascskip on
@root "other/xemacs/open_with.py"
&lt;&lt; Open_With Plugin&gt;&gt;
@code
"""Create menu for Open With command and handle the resulting commands"""

import os
from leo.core import leoGlobals as g
Tk = g.import_module('tkinter')


if Tk: # Register the handlers...

    def on_idle (tag,keywords):
        a = g.app
        if g.app.killed: return
        for dict in a.openWithFiles:
            path = dict.get("path")
            c = dict.get("c")
            encoding = dict.get("encoding",None)
            v = dict.get("v")
            old_body = dict.get("body")
            if path and os.path.exists(path):
                try:
                    time = os.path.getmtime(path)
                    if time and time != dict.get("time"):
                        dict["time"] = time # inhibit endless dialog loop.
                        # The file has changed.
                        try:
                            # Update v from the changed temp file.
                            f=open(path)
                            s=f.read()
                            f.close()
                        except Exception:
                            g.es("can not open " + g.shortFileName(path))
                            break

                        # Convert body and s to whatever encoding is in effect.
                        body = v.bodyString()
                        body = g.toEncodedString(body,encoding,reportErrors=True)
                        s = g.toEncodedString(s,encoding,reportErrors=True) # 10/13/03

                        conflict = body != old_body and body != s

                        # Set update if we should update the outline from the file.
                        if conflict:
                            # See how the user wants to resolve the conflict.
                            g.error("conflict in " + g.shortFileName(path))
                            message = "Replace changed outline with external changes?"
                            result = g.app.gui.runAskYesNoDialog(c,"Conflict!",message)
                            update = result.lower() == "yes"
                        else:
                            update = s != body

                        if update:
                            g.blue("updated from: " + g.shortFileName(path))
                            v.b = s
                            c.selectVnode(v)
                            dict["body"] = s
                        elif conflict:
                            g.warning("not updated from: " + g.shortFileName(path))
                except Exception:
                    g.es_exception() # testing
                    pass
    def create_open_with_menu (tag,keywords):

        if  (tag in ("start2","open2") or
            (tag=="command2" and keywords.get("label")=="new")):

            # Entries in the following table are the tuple
            # (commandName,shortcut,data).
            #
            # - data is the tuple (command,arg,ext).
            # - command is one of "os.system", "os.startfile", "os.spawnl",
            # "os.spawnv" or "exec".
            #
            # Leo executes command(arg+path) where path is the full path to
            # the temp file.
            # If ext is not None, the temp file has the extension ext,
            # Otherwise, Leo computes an extension based on what @language
            # directive is in effect.

            idle_arg = "c:/python22/tools/idle/idle.py -e "

@doc
Here is where we insert the &lt; Call XEmacs &gt; code fragment defined above:
@code
            if 1: # Default table.


&lt;&lt; Call XEmacs &gt;&gt;
#               table = (
#                   # Opening idle this way doesn't work so well.
#                   # ("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
#                   ("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
#                   ("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
#           elif 1: # Test table.
#               table = ("&amp;Word","Alt+Shift+W",("os.startfile",None,".doc")),
#           else: # David McNab's table.
#               table = ("X&amp;Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)),

            c.frame.menu.createOpenWithMenuFromTable(table)

    if g.app.gui is None:
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":

        g.app.hasOpenWithMenu = True
        g.registerHandler("idle", on_idle)
        g.registerHandler(("start2","menu2","command2"), create_open_with_menu)

        __version__ = "1.4" # Set version for the plugin handler.
        g.plugin_signon(__name__)

</t>
<t tx="ekr.20040331151007.1">def onPreSave(tag=None, keywords=None):

    """Before saving an @nosent file, make sure that all nodes have a blank line at the end."""

    global nosentNodes
    c = keywords.get('c')
    if c:
        for p in c.all_positions():
            if p.isAtNoSentinelsFileNode() and p.isDirty():
                nosentNodes.append(p.copy())
                for p2 in p.self_and_subtree():
                    s = p2.b
                    lastline = s.split('\n')[-1]
                    if lastline.strip():
                        p2.b = s + '\n'
</t>
<t tx="ekr.20040722141148">@nocolor-node
@

You would typically not enable any of the following "plugins".

These plugins contain example code only.
</t>
<t tx="ekr.20040915073259">@nocolor-node

These plugins add buttons and other widgets to the icon area or
affect Leo's panes and windows in various ways.

</t>
<t tx="ekr.20041001210557"></t>
<t tx="ekr.20041005105605.144">def write(self, kind, root, sentinels=True):
    """Write a 4.x derived file.
    root is the position of an @&lt;file&gt; node.
    sentinels will be False for @clean and @nosent nodes.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(
            root, root.anyAtFileNodeName(), kind=kind, sentinels=sentinels)
        if not fileName or not at.precheck(fileName, root):
            if sentinels:
                # Raise dialog warning of data loss.
                at.addToOrphanList(root)
            else:
                # #1450: No danger of data loss.
                pass
            return
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        at.warnAboutOrphandAndIgnoredNodes()
        contents = at.closeOutputStream()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
</t>
<t tx="ekr.20041005105605.15">def initWriteIvars(self, root, targetFileName,
    atEdit=False,
    atShadow=False,
    defaultDirectory=None,
    forcePythonSentinels=False,
    kind=None,
    sentinels=True,
):
    """
    Compute default values of all write-related ivars.
    Return the finalized name of the output file.
    """
    at, c = self, self.c
    assert root
    self.initCommonIvars()
    assert at.checkPythonCodeOnWrite is not None
    assert at.underindentEscapeString is not None
    #
    # Copy args
    at.kind = kind
    at.atEdit = atEdit
        # Used only by putBody.
    at.atShadow = atShadow
    at.root = root
    at.sentinels = sentinels
    #
    # Override initCommonIvars.
    if forcePythonSentinels:
        at.endSentinelComment = None
        at.startSentinelComment = "#"
    if g.app.unitTesting:
        at.output_newline = '\n'
    #
    # Set other ivars.
    at.force_newlines_in_at_nosent_bodies = c.config.getBool(
        'force-newlines-in-at-nosent-bodies')
        # For at.putBody only.
    at.outputList = []
        # For stream output.
    at.targetFileName = targetFileName
        # For at.writeError only.
    at.scanAllDirectives(root, forcePythonSentinels=forcePythonSentinels)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width
    #
    # Overrides of at.scanAllDirectives...
    if defaultDirectory:
        at.default_directory = defaultDirectory
    if at.language == 'python':
        # Encoding directive overrides everything else.
        encoding = g.getPythonEncodingFromString(root.b)
        if encoding:
            at.encoding = encoding
    #
    # Clean root.v.
    if not at.errors and at.root:
        if hasattr(at.root.v, 'tnodeList'):
            delattr(at.root.v, 'tnodeList')
        at.root.v._p_changed = True
    #
    # Return the finalized file name.
    # #1341 and #1450.
    make_dirs = c and c.config and c.config.create_nonexistent_directories
    if at.default_directory:
        at.default_directory = c.expand_path_expression(at.default_directory)
        if make_dirs:
            ok = g.makeAllNonExistentDirectories(at.default_directory)
            if not ok:
                g.error(f"Did not create default directory: {at.default_directory}")
                return None
    # #1341 and #1450.
    targetFileName = c.expand_path_expression(targetFileName)
    if targetFileName:
        theDir = g.os_path_dirname(targetFileName)
        if theDir and make_dirs:
            ok = g.makeAllNonExistentDirectories(theDir)
            if not ok:
                g.trace(f"Did not create {theDir} for {targetFileName}")
                return None
    # #1341.
    return g.os_path_realpath(
        g.os_path_finalize_join(at.default_directory, targetFileName))
</t>
<t tx="ekr.20041005105605.151">def writeMissing(self, p):
    at, c = self, self.c
    writtenFiles = False
    c.init_error_dialogs()
    # #1450.
    at.initWriteIvars(root=p.copy(), targetFileName='')
    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after:  # Don't use iterator.
        if (
            p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode())
        ):
            fileName = p.anyAtFileNodeName()
            if fileName:
                fileName = c.expand_path_expression(fileName)  # #1341
                fileName = g.os_path_finalize_join(
                    at.default_directory, fileName)  # #1341
                if at.precheck(fileName, p):
                    at.writeMissingNode(p)
                    writtenFiles = True
                else:
                    at.addToOrphanList(p)
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    if not g.unitTesting:
        if writtenFiles &gt; 0:
            g.es("finished")
        else:
            g.es("no @file node in the selected tree")
    c.raise_error_dialogs(kind='write')
</t>
<t tx="ekr.20041005105605.152">def writeMissingNode(self, p):

    at = self
    if p.isAtAsisFileNode():
        at.asisWrite(p)
    elif p.isAtNoSentFileNode():
        at.write('@nosent', p, sentinels=False)
    elif p.isAtFileNode():
        at.write('@file', p)
    elif p.isAtAutoNode() or p.isAtAutoRstNode():
        g.es('Can not write missing @auto node', p.h, color='red')
    else:
        g.trace('can not happen: unknown @file node')
</t>
<t tx="ekr.20041005105605.154">def asisWrite(self, root):
    at, c = self, self.c
    try:
        c.endEditing()
        c.init_error_dialogs()
        fileName = at.initWriteIvars(root, root.atAsisFileNodeName())
        # #1450.
        if not fileName or not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return
        at.openOutputStream()
        for p in root.self_and_subtree(copy=False):
            at.writeAsisNode(p)
        contents = at.closeOutputStream()
        at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        at.writeException(fileName, root)

silentWrite = asisWrite  # Compatibility with old scripts.
</t>
<t tx="ekr.20041005105605.157">def putFile(self, root, fromString='', sentinels=True):
    '''Write the contents of the file to the output stream.'''
    at = self
    s = fromString if fromString else root.v.b
    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=5")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root, fromString=fromString)
    at.putCloseNodeSentinel(root)
    # The -leo sentinel is required to handle @last.
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
</t>
<t tx="ekr.20041005105605.161">def putBody(self, p, fromString=''):
    '''
    Generate the body enclosed in sentinel lines.
    Return True if the body contains an @others line.
    '''
    at = self
    #
    # New in 4.3 b2: get s from fromString if possible.
    s = fromString if fromString else p.b
    p.v.setVisited()
        # Make sure v is never expanded again.
        # Suppress orphans check.
    #
    # Fix #1048 &amp; #1037: regularize most trailing whitespace.
    if s and (at.sentinels or at.force_newlines_in_at_nosent_bodies):
        if not s.endswith('\n'):
            s = s + '\n'
    at.raw = False  # Bug fix.
    i = 0
    status = g.Bunch(
        at_comment_seen=False,
        at_delims_seen=False,
        at_warning_given=False,
        has_at_others=False,
        in_code=True,
    )
    while i &lt; len(s):
        next_i = g.skip_line(s, i)
        assert next_i &gt; i, 'putBody'
        kind = at.directiveKind4(s, i)
        at.putLine(i, kind, p, s, status)
        i = next_i
    # pylint: disable=no-member
        # g.bunch *does* have .in_code and has_at_others members.
    if not status.in_code:
        at.putEndDocLine()
    return status.has_at_others
</t>
<t tx="ekr.20041005105605.163">def putLine(self, i, kind, p, s, status):
    '''Put the line at s[i:] of the given kind, updating the status.'''
    at = self
    if kind == at.noDirective:
        if status.in_code:
            if at.raw:
                at.putCodeLine(s, i)
            else:
                name, n1, n2 = at.findSectionName(s, i)
                if name:
                    at.putRefLine(s, i, n1, n2, name, p)
                else:
                    at.putCodeLine(s, i)
        else:
            at.putDocLine(s, i)
    elif at.raw:
        if kind == at.endRawDirective:
            at.raw = False
            at.putSentinel("@@end_raw")
        else:
            # Fix bug 784920: @raw mode does not ignore directives
            at.putCodeLine(s, i)
    elif kind in (at.docDirective, at.atDirective):
        if not status.in_code:
            # Bug fix 12/31/04: handle adjacent doc parts.
            at.putEndDocLine()
        at.putStartDocLine(s, i, kind)
        status.in_code = False
    elif kind in (at.cDirective, at.codeDirective):
        # Only @c and @code end a doc part.
        if not status.in_code:
            at.putEndDocLine()
        at.putDirective(s, i, p)
        status.in_code = True
    elif kind == at.allDirective:
        if status.in_code:
            if p == self.root:
                at.putAtAllLine(s, i, p)
            else:
                at.error(f"@all not valid in: {p.h}")
        else: at.putDocLine(s, i)
    elif kind == at.othersDirective:
        if status.in_code:
            if status.has_at_others:
                at.error(f"multiple @others in: {p.h}")
            else:
                at.putAtOthersLine(s, i, p)
                status.has_at_others = True
        else:
            at.putDocLine(s, i)
    elif kind == at.rawDirective:
        at.raw = True
        at.putSentinel("@@raw")
    elif kind == at.endRawDirective:
        # Fix bug 784920: @raw mode does not ignore directives
        at.error(f"unmatched @end_raw directive: {p.h}")
    elif kind == at.startVerbatim:
        # Fix bug 778204: @verbatim not a valid Leo directive.
        if g.unitTesting:
            # A hack: unit tests for @shadow use @verbatim as a kind of directive.
            pass
        else:
            at.error(f"@verbatim is not a Leo directive: {p.h}")
    elif kind == at.miscDirective:
        # Fix bug 583878: Leo should warn about @comment/@delims clashes.
        if g.match_word(s, i, '@comment'):
            status.at_comment_seen = True
        elif g.match_word(s, i, '@delims'):
            status.at_delims_seen = True
        if (
            status.at_comment_seen and
            status.at_delims_seen and not
            status.at_warning_given
        ):
            status.at_warning_given = True
            at.error(f"@comment and @delims in node {p.h}")
        at.putDirective(s, i, p)
    else:
        at.error(f"putBody: can not happen: unknown directive kind: {kind}")
</t>
<t tx="ekr.20041005105605.174">def putCodeLine(self, s, i):
    '''Put a normal code line.'''
    at = self
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s, i)
    if g.match(s, k, self.startSentinelComment + '@'):
        self.putSentinel('@verbatim')
    j = g.skip_line(s, i)
    line = s[i:j]
    # Don't put any whitespace in otherwise blank lines.
    if len(line) &gt; 1:  # Preserve *anything* the user puts on the line!!!
        if not at.raw:
            at.putIndent(at.indent, line)
        if line[-1:] == '\n':
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    elif line:
        at.os(line)  # Bug fix: 2013/09/16
    else:
        g.trace('Can not happen: completely empty line')
</t>
<t tx="ekr.20041005105605.176">def putRefLine(self, s, i, n1, n2, name, p):
    """Put a line containing one or more references."""
    at = self
    ref = at.findReference(name, p)
    if not ref:
        if hasattr(at, 'allow_undefined_refs'):
            # Allow apparent section reference: just write the line.
            at.putCodeLine(s, i)
        return
    # Compute delta only once.
    junk, delta = g.skip_leading_ws_with_indent(s, i, at.tab_width)
    # Write the lead-in sentinel only once.
    at.putLeadInSentinel(s, i, n1, delta)
    self.putRefAt(name, ref, delta)
    n_refs = 0
    while 1:
        progress = i
        i = n2
        n_refs += 1
        name, n1, n2 = at.findSectionName(s, i)
        if self.kind == '@clean' and n_refs &gt; 1:
            # #1232: allow only one section reference per line in @clean.
            i1, i2 = g.getLine(s, i)
            line = s[i1:i2].rstrip()
            at.writeError(f"Too many section references:\n{line!s}")
            break
        if name:
            ref = at.findReference(name, p)
                # Issues error if not found.
            if ref:
                middle_s = s[i:n1]
                self.putAfterMiddleRef(middle_s, delta)
                self.putRefAt(name, ref, delta)
        else:
            break
        assert progress &lt; i
    self.putAfterLastRef(s, i, delta)
</t>
<t tx="ekr.20041005105605.177">def putRefAt(self, name, ref, delta):
    at = self
    # #132: Section Reference causes clone...
    #
    # Never put any @+middle or @-middle sentinels.
    at.indent += delta
    at.putSentinel("@+" + name)
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    at.putSentinel("@-" + name)
    at.indent -= delta
</t>
<t tx="ekr.20041005105605.178">def putAfterLastRef(self, s, start, delta):
    """Handle whatever follows the last ref of a line."""
    at = self
    j = g.skip_ws(s, start)
    if j &lt; len(s) and s[j] != '\n':
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        end = g.skip_line(s, start)
        after = s[start:end]
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl()  # Add a newline if the line didn't end with one.
        at.indent -= delta
</t>
<t tx="ekr.20041005105605.179">def putAfterMiddleRef(self, s, delta):
    """Handle whatever follows a ref that is not the last ref of a line."""
    at = self
    if s:
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(s)
        at.onl_sent()  # Not a real newline.
        at.indent -= delta
</t>
<t tx="ekr.20041005105605.181">def putBlankDocLine(self):
    at = self
    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment)
        # #1496: Retire the @doc convention.
        #        Remove the blank.
        # at.oblank()
    at.onl()
</t>
<t tx="ekr.20041005105605.183">def putDocLine(self, s, i):
    """Handle one line of a doc part."""
    at = self
    j = g.skip_line(s, i)
    s = s[i:j]
    #
    # #1496: Retire the @doc convention:
    #        Strip all trailing ws here.
    if not s.strip():
        # A blank line.
        at.putBlankDocLine()
        return
    # Write the line as it is.
    at.putIndent(at.indent)
    if not at.endSentinelComment:
        at.os(at.startSentinelComment)
        # #1496: Retire the @doc convention.
        #        Leave this blank. The line is not blank.
        at.oblank()
    at.os(s)
    if not s.endswith('\n'):
        at.onl()
</t>
<t tx="ekr.20041005105605.19">def openFileForReading(self, fromString=False):
    """
    Open the file given by at.root.
    This will be the private file for @shadow nodes.
    """
    at, c = self, self.c
    if fromString:
        if at.atShadow:
            return at.error(
                'can not call at.read from string for @shadow files')
        at.initReadLine(fromString)
        return None, None
    #
    # Not from a string. Carefully read the file.
    fn = g.fullPath(c, at.root)
        # Returns full path, including file name.
    at.setPathUa(at.root, fn)
        # Remember the full path to this node.
    if at.atShadow:
        fn = at.openAtShadowFileForReading(fn)
        if not fn:
            return None, None
    assert fn
    try:
        s = at.readFileToUnicode(fn)
            # Sets at.encoding, regularizes whitespace and calls at.initReadLines.
        # #1466.
        if s is None:
            # The error has been given.
            at._file_bytes = g.toEncodedString('')
            return None, None
        at.warnOnReadOnlyFile(fn)
    except Exception:
        at.error(f"unexpected exception opening: '@file {fn}'")
        at._file_bytes = g.toEncodedString('')
        fn, s = None, None
    return fn, s
</t>
<t tx="ekr.20041005105605.199">def findSectionName(self, s, i):
    """
    Return n1, n2 representing a section name.
    The section name, *including* brackes is s[n1:n2]
    """
    end = s.find('\n', i)
    if end == -1:
        n1 = s.find("&lt;&lt;", i)
        n2 = s.find("&gt;&gt;", i)
    else:
        n1 = s.find("&lt;&lt;", i, end)
        n2 = s.find("&gt;&gt;", i, end)
    ok = -1 &lt; n1 &lt; n2
    if ok:
        # Warn on extra brackets.
        for ch, j in (('&lt;', n1 + 2), ('&gt;', n2 + 2)):
            if g.match(s, j, ch):
                line = g.get_line(s, i)
                g.es('dubious brackets in', line)
                break
        name = s[n1 : n2 + 2]
        return name, n1, n2 + 2
    return None, n1, len(s)
</t>
<t tx="ekr.20041005105605.204">def os(self, s):
    """
    Append a string to at.outputList.

    All output produced by leoAtFile module goes here.
    """
    at = self
    if s.startswith(self.underindentEscapeString):
        try:
            junk, s = at.parseUnderindentTag(s)
        except Exception:
            at.exception("exception writing:" + s)
            return
    s = g.toUnicode(s, at.encoding)
    at.outputList.append(s)
</t>
<t tx="ekr.20041005105605.206">def putDirective(self, s, i, p):
    r'''
    Output a sentinel a directive or reference s.

    It is important for PHP and other situations that \@first and \@last
    directives get translated to verbatim lines that do *not* include what
    follows the @first &amp; @last directives.
    '''
    at = self
    k = i
    j = g.skip_to_end_of_line(s, i)
    directive = s[i:j]
    if g.match_word(s, k, "@delims"):
        at.putDelims(directive, s, k)
    elif g.match_word(s, k, "@language"):
        self.putSentinel("@" + directive)
    elif g.match_word(s, k, "@comment"):
        self.putSentinel("@" + directive)
    elif g.match_word(s, k, "@last"):
        # #1307.
        if p.isAtCleanNode():
            at.error(f"ignoring @last directive in {p.h!r}")
            g.es_print('@last is not valid in @clean nodes')
        # #1297.
        elif g.app.inScript or g.unitTesting or p.isAnyAtFileNode():
            self.putSentinel("@@last")
                # Convert to an verbatim line _without_ anything else.
        else:
            at.error(f"ignoring @last directive in {p.h!r}")
    elif g.match_word(s, k, "@first"):
        # #1307.
        if p.isAtCleanNode():
            at.error(f"ignoring @first directive in {p.h!r}")
            g.es_print('@first is not valid in @clean nodes')
        # #1297.
        elif g.app.inScript or g.unitTesting or p.isAnyAtFileNode():
            self.putSentinel("@@first")
                # Convert to an verbatim line _without_ anything else.
        else:
            at.error(f"ignoring @first directive in {p.h!r}")
    else:
        self.putSentinel("@" + directive)
    i = g.skip_line(s, k)
    return i
</t>
<t tx="ekr.20041005105605.207">def putDelims(self, directive, s, k):
    '''Put an @delims directive.'''
    at = self
    # Put a space to protect the last delim.
    at.putSentinel(directive + " ")  # 10/23/02: put @delims, not @@delims
    # Skip the keyword and whitespace.
    j = i = g.skip_ws(s, k + len("@delims"))
    # Get the first delim.
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s, i):
        i += 1
    if j &lt; i:
        at.startSentinelComment = s[j:i]
        # Get the optional second delim.
        j = i = g.skip_ws(s, i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s, i):
            i += 1
        at.endSentinelComment = s[j:i] if j &lt; i else ""
    else:
        at.writeError("Bad @delims directive")
</t>
<t tx="ekr.20041005105605.216"># Called from putFile.

def warnAboutOrphandAndIgnoredNodes(self):
    # Always warn, even when language=="cweb"
    at, root = self, self.root
    if at.errors:
        return  # No need to repeat this.
    for p in root.self_and_subtree(copy=False):
        if not p.v.isVisited():
            at.writeError("Orphan node:  " + p.h)
            if p.hasParent():
                g.blue("parent node:", p.parent().h)
    p = root.copy()
    after = p.nodeAfterTree()
    while p and p != after:
        if p.isAtAllNode():
            p.moveToNodeAfterTree()
        else:
            # #1050: test orphan bit.
            if p.isOrphan():
                at.writeError("Orphan node: " + p.h)
                if p.hasParent():
                    g.blue("parent node:", p.parent().h)
            p.moveToThreadNext()
</t>
<t tx="ekr.20041005105605.22">def initFileName(self, fromString, importFileName, root):
    """Return the fileName to be used in messages."""
    # at = self
    c = self.c
    if fromString:
        fileName = "&lt;string-file&gt;"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
        # #102, #1341: expand user expression.
        fileName = c.expand_path_expression(fileName)  # #1341:
    else:
        fileName = None
    if fileName:
        fileName = g.os_path_finalize(fileName)  # #1341:
    return fileName
</t>
<t tx="ekr.20041030092101">@Notes by EKR: The dyna plugin is a remarkable body of work by 'e'. Have fun with it.

You may download the latest version at: http: // rclick.netfirms.com / dyna_menu.py.html
</t>
<t tx="ekr.20041114102139">@nocolor

Comments
--------

Most of the comments in the style guide are comments*about*the style guide.
You would replace these comments with your own, or eliminate them entirely in
your plugin.

Docstrings
----------

Several plugins show the docstring, so please take care to do a good job of
describing what the plugin does and how to use it.

Directives
----------

Please put the following at the end of the plugin's top-level node.

    @language python
    @tabwidth-4

Imports
-------

-Do* not*assume that modules like Qt are always available.

-Do* not*use from m import*

-Your code should test whether modules have been imported only if those modules
  may not be available on all platforms.

-To fail gracefully if the Qt gui is not in effect, put the following at
  the top level::

      g.assertUi('qt')

Exceptions
----------

It is usually best* not*to catch exceptions in plugins: doHook catches all
exceptions and disables further calls to plugins.

If a plugin catches exceptions during startup it should do either raise the
exception again or provide an init function at the top level that reports the
failure by returning False.

Use separate nodes
------------------

**Please**define each class, function or method in a separate node!To
make this work, just put@others in the root of your plugin as shown.Note
that@others may be nested, as shown in class myClass.
</t>
<t tx="ekr.20041120112043">def parseShortcutLine(self, kind, s):
    """Parse a shortcut line.  Valid forms:

    --&gt; entry-command
    settingName = shortcut
    settingName ! paneName = shortcut
    command-name --&gt; mode-name = binding
    command-name --&gt; same = binding
    """
    # c = self.c
    s = s.replace('\x7f', '')
        # Can happen on MacOS. Very weird.
    name = val = nextMode = None; nextMode = 'none'
    i = g.skip_ws(s, 0)
    if g.match(s, i, '--&gt;'):  # New in 4.4.1 b1: allow mode-entry commands.
        j = g.skip_ws(s, i + 3)
        i = g.skip_id(s, j, '-')
        entryCommandName = s[j:i]
        return None, g.BindingInfo('*entry-command*', commandName=entryCommandName)
    j = i
    i = g.skip_id(s, j, '-@')  # #718.
    name = s[j:i]
    # #718: Allow @button- and @command- prefixes.
    for tag in ('@button-', '@command-'):
        if name.startswith(tag):
            name = name[len(tag) :]
            break
    if not name:
        return None, None
    # New in Leo 4.4b2.
    i = g.skip_ws(s, i)
    if g.match(s, i, '-&gt;'):  # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s, i + 2)
        i = g.skip_id(s, j)
        nextMode = s[j:i]
    i = g.skip_ws(s, i)
    if g.match(s, i, '!'):  # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s, i + 1)
        i = g.skip_id(s, j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'
    i = g.skip_ws(s, i)
    if g.match(s, i, '='):
        i = g.skip_ws(s, i + 1)
        val = s[i:]
    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    if val:
        i = val.find('#')
        if i &gt; 0 and val[i - 1] in (' ', '\t'):
            val = val[:i].strip()
    if not val:
        return name, None
    stroke = g.KeyStroke(binding=val) if val else None
    bi = g.BindingInfo(kind=kind, nextMode=nextMode, pane=pane, stroke=stroke)
    return name, bi
</t>
<t tx="ekr.20041130173135"># This is a bad idea.

def hash(self):
    c = self
    if c.mFileName:
        return g.os_path_finalize(c.mFileName).lower()  # #1341.
    return 0
</t>
<t tx="ekr.20050111122605"></t>
<t tx="ekr.20050125203937"># Fix #653: undoer problem: be wary of the ternary operator here.
old_start = old_end = new_start = new_end = 0
if oldSel:
    old_start, old_end = oldSel
if newSel:
    new_start, new_end = newSel
prev_start, prev_end = u.prevSel
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    # 2011/04/01: Patch by Sam Hartsfield
    old_row, old_col = g.convertPythonIndexToRowCol(
        oldText, old_start)
    new_row, new_col = g.convertPythonIndexToRowCol(
        newText, new_start)
    prev_row, prev_col = g.convertPythonIndexToRowCol(
        oldText, prev_start)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col - new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        # py-lint: disable=W0511
        # W0511:1362: TODO
        # TODO this is not true, we might as well just have entered a
        # char at the beginning of an existing line
        pass  # We have just inserted a line.
    else:
        # 2011/04/01: Patch by Sam Hartsfield
        old_s = old_lines[old_row]
        new_s = new_lines[new_row]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col - 1 &gt;= len(old_s) or new_col - 1 &gt;= len(new_s):
            newBead = True
        else:
            old_ch = old_s[old_col - 1]
            new_ch = new_s[new_col - 1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines, old_row, old_col, old_ch,
                new_lines, new_row, new_col, new_ch,
                prev_row, prev_col)
</t>
<t tx="ekr.20050125220613"># Set newBead to True if undo_type is not 'Typing' so that commands that
# get treated like typing (by onBodyChanged) don't get lumped
# with 'real' typing.
@c
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True  # We can't share the previous node.
elif granularity == 'char':
    newBead = True  # This was the old way.
elif granularity == 'node':
    newBead = False  # Always replace previous bead.
else:
    assert granularity in ('line', 'word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading', 0) != u.leading or
        old_d.get('trailing', 0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            &lt;&lt; set newBead if the change does not continue a word &gt;&gt;
        except Exception:
            g.error('Unexpected exception...')
            g.es_exception()
            newBead = True
</t>
<t tx="ekr.20050126081529">def recognizeStartOfTypingWord(self,
    old_lines, old_row, old_col, old_ch,
    new_lines, new_row, new_col, new_ch,
    prev_row, prev_col
):
    """
    A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.

    u.doTyping calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.

    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.

    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.
    """
    # Start a word if new_ch begins whitespace + word
    new_word_started = not old_ch.isspace() and new_ch.isspace()
    # Start a word if the cursor has been moved since the last change
    moved_cursor = new_row != prev_row or new_col != prev_col + 1
    return new_word_started or moved_cursor
</t>
<t tx="ekr.20050130120433">'''A plugin to test import problems.'''

from leo.core import leoGlobals as g

def onStart(tag,keywords):
    pass

# pylint: disable=unused-import
try:
    import xyzzy
except ImportError:
    g.cantImport('xyzzy',pluginName='failed_import')

def init():
    '''Return True if the plugin has loaded successfully.'''
    g.registerHandler("start2", onStart)
    g.plugin_signon(__name__)
    return True
</t>
<t tx="ekr.20050303051035">@nocolor-node

The following nodes show recommended style when writing plugins.</t>
<t tx="ekr.20050303051035.2">'''
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
'''
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4
</t>
<t tx="ekr.20050303051035.5">from leo.core import leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050303051101">def init():
    '''Return True if the plugin has loaded successfully.'''
    ok=g.app.gui.guiName() in('qt','qttabs')
    if ok:
        if 1: # Use this if you want to create the commander class before the frame is fully created.
            g.registerHandler('before-create-leo-frame',onCreate)
        else: # Use this if you want to create the commander class after the frame is fully created.
            g.registerHandler('after-create-leo-frame',onCreate)
    return ok</t>
<t tx="ekr.20050303051150">def onCreate(tag, keys):

    c=keys.get('c')
    if not c: return

    thePluginController=pluginController(c)
</t>
<t tx="ekr.20050303051222">class pluginController:

    @others</t>
<t tx="ekr.20050303051222.1">def __init__(self,c):

    self.c=c
    # Warning: hook handlers must use keywords.get('c'), NOT self.c.
</t>
<t tx="ekr.20050306071540">def onStart2(tag, keywords):

    """
    Showing how to define a global hook that affects all commanders.
    """

    log=c.frame.log.__class__

    # Replace frame.put with newPut (not shown).
    g.funcToMethod(newPut,log,"put")</t>
<t tx="ekr.20050306071629">'''
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
'''
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4</t>
<t tx="ekr.20050306071629.1">'''This docstring should be a clear, concise description of
what the plugin does and how to use it.
'''
</t>
<t tx="ekr.20050306071629.3">from leo.core import leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050306071629.4">def init():
    '''Return True if the plugin has loaded successfully.'''
    ok=True # This might depend on imports, etc.
    if ok:
        g.registerHandler('start2',onStart2)
    return ok</t>
<t tx="ekr.20050306081349"></t>
<t tx="ekr.20050315133212.2">def beforeChangeNodeContents(self, p):
    """Return data that gets passed to afterChangeNode."""
    c, u = self.c, self
    w = c.frame.body.wrapper
    bunch = u.createCommonBunch(p)
    bunch.oldBody = p.b
    bunch.oldHead = p.h
    # #1413: Always restore yScroll if possible.
    bunch.oldYScroll = w.getYScrollPosition() if w else 0
    return bunch
</t>
<t tx="ekr.20050315134017.2">def afterChangeNodeContents(self, p, command, bunch):
    """Create an undo node using d created by beforeChangeNode."""
    u = self
    c = self.c
    w = c.frame.body.wrapper
    if u.redoing or u.undoing:
        return
    # Set the type &amp; helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents
    bunch.inHead = False  # 2013/08/26
    bunch.newBody = p.b
    bunch.newHead = p.h
    bunch.newMarked = p.isMarked()
    # Bug fix 2017/11/12: don't use ternary operator.
    if w:
        bunch.newSel = w.getSelectionRange()
    else:
        bunch.newSel = 0, 0
    bunch.newYScroll = w.getYScrollPosition() if w else 0
    u.pushBead(bunch)
</t>
<t tx="ekr.20050318085432.7">def redoNodeContents(self):
    c, u = self.c, self
    w = c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    # Restore the body.
    u.p.setBodyString(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p)
    # Restore the headline.
    u.p.initHeadString(u.newHead)
    # This is required so.  Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.newHead)  # New in 4.4b2.
    if u.groupCount == 0 and u.newSel:
        i, j = u.newSel
        w.setSelectionRange(i, j)
    if u.groupCount == 0 and u.newYScroll is not None:
        w.setYScrollPosition(u.newYScroll)
    u.updateMarks('new')
    u.p.setDirty()
</t>
<t tx="ekr.20050318085713.1">def undoNodeContents(self):
    """
    Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    """
    c, u = self.c, self
    w = c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    u.p.b = u.oldBody
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p)
    u.p.h = u.oldHead
    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.oldHead)
    if u.groupCount == 0 and u.oldSel:
        i, j = u.oldSel
        w.setSelectionRange(i, j)
    if u.groupCount == 0 and u.oldYScroll is not None:
        w.setYScrollPosition(u.oldYScroll)
    u.updateMarks('old')
</t>
<t tx="ekr.20050408100042">def undoRedoTree(self, p, new_data, old_data):
    """Replace p and its subtree using old_data during undo."""
    # Same as undoReplace except uses g.Bunch.
    u = self; c = u.c
    if new_data is None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch
    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p, p.b)  # This is not a do-nothing.
    return p  # Nothing really changes.
</t>
<t tx="ekr.20050412084532">def redoInsertNode(self):
    u = self; c = u.c; cc = c.chapterController
    if cc:
        cc.selectChapterByName('main')
    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent, 0)
    else:
        u.newP._linkAsRoot()
    if u.pasteAsClone:
        for bunch in u.afterTree:
            v = bunch.v
            if u.newP.v == v:
                u.newP.b = bunch.body
                u.newP.h = bunch.head
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
    u.newP.setDirty()
    c.selectPosition(u.newP)
</t>
<t tx="ekr.20050412085112">def undoInsertNode(self):
    u = self; c = u.c; cc = c.chapterController
    if cc: cc.selectChapterByName('main')
    u.newP.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.newP)
    c.deleteOutline()
        # Bug fix: 2016/03/30.
        # This always selects the proper new position.
        # c.selectPosition(u.p)
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            v = bunch.v
            if u.p.v == v:
                u.p.b = bunch.body
                u.p.h = bunch.head
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
</t>
<t tx="ekr.20050721093241">@nobeautify
@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1.

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.

- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20050804081215">@nocolor
@
http://sourceforge.net/forum/message.php?msg_id=3276408

Leo has great potential for smoothing some of the bumps
outside of learning the details of the markup.
Here is my wish list;

(done) - Section level handling.
  - one of the problems with using rst comes when a new
    section level is inserted into a document. Leo can
    take care of this effortlessly, providing a correct
   underline character for each section heading.

    Other than the section management, I want Leo to
    assume that I'm writing rst, and should be rendered
    as-is. If I want to include some pretty Python, I put
    it in a ..  python-code:: block (or some such)

    On top of this base could be built special case
    handling.

- Assist in viewing rendered output
  - easy access to the command to render a tree to  html.
  - I would like an option which automatically inserted
    a @url node which pointed to the rendered file, or
    some other trick to make switching between source
    and output painless.

- Assist in working with the CSS file
  - a CSS file is now required by docutils. A @setting
    could specify the file. I would like some kind of
    sugar which made it easy to edit the CSS file, maybe
    an option to create a @file node automatically,
    like the @url node above. Again, I want to be able
    to effortlessly edit the CSS and see the results.

- The third file of interest when writing rst is the config
   file which controls many behaviours of the renderer.
   Again, some intelligence which located it, made it
   convenient to edit it, maybe even linked to
   documentation for it, would be very nice.

(done) - I would like a setting which would save the file with the
  rst markup and make it easy to examine and edit.

- On the someday/maybe list would be a @publish
  feature, which configured a directory to ftp the rendered
  file to.
</t>
<t tx="ekr.20050805162550">&lt;&lt; docstring &gt;&gt;

# Original rst code by Josef Dalcolmo:
# contributed under the same licensed as Leo.py itself.
# rst3.py based on rst2.py v2.4.
# This has largely been superceded by leo.core.leoRst.

&lt;&lt; imports &gt;&gt;
&lt;&lt; to do &gt;&gt;

bwm_file = None
if 0:
    bwm_file = open("bwm_file", "w")
controllers = {} # For use by @button rst3 code.

@others
</t>
<t tx="ekr.20050805162550.1">''' Creates output files from Leo outlines containing rST (reStructuredText)
markup. This plugin has been superseded by Leo's core rst3 command.

This is a powerful plugin with many options.  The full documentation is at:
http://leoeditor.com//rstplugin3.html

The rst3 plugin adds the Write Restructured Text command to Leo's Edit menu. This
command searches the selected outline looking for **rst root nodes** whose
headline have the form @rst &lt;filename&gt;. The plugin then creates the named file
in various ways depending which rst3 options are in effect.

By default, the rst3 plugin creates rST headings automatically from outlines, so
the higher-level nodes in the outline correspond to higher-level sections in the
output. Creating rST headings automatically eliminates one of the most tedious
chores associated with rST markup.

To use this plugin effectively, Python's docutils module must be installed. The
rst3 plugin will use the SilverCity syntax coloring package if it installed.

This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.

rst3 options control most aspects of this plugin's operations. You can set
options in @settings trees, in headlines and in body text. There are too many
details to discuss here. For full details see:
http://leoeditor.com//rstplugin3.html

'''
</t>
<t tx="ekr.20050805162550.10">def __init__ (self,c):

    global SilverCity
    self.c = c
    &lt;&lt; init ivars &gt;&gt;

    self.createDefaultOptionsDict()
    self.initOptionsFromSettings() # Still needed.
    self.initHeadlineCommands() # Only needs to be done once.
    self.initSingleNodeOptions()
    self.addMenu()
</t>
<t tx="ekr.20050805162550.11">self.silverCityWarningGiven = False

# The options dictionary.
self.optionsDict = {}
self.option_prefix = '@rst-option'

# Formatting...
self.code_block_string = ''
self.node_counter = 0
self.toplevel = 0
self.topNode = None
self.use_alternate_code_block = SilverCity is None

# Http support...
self.nodeNumber = 0
# All nodes are numbered so that unique anchors can be generated.

self.http_map = {}
# Keys are named hyperlink targets.  Value are positions.
# The targets mark the beginning of the html code specific
# for this position.

self.anchor_map = {}
# Maps anchors (generated by this module) to positions

self.rst3_all = False
# Set to True by the button which processes all @rst trees.

# For writing.
self.defaultEncoding = 'utf-8'
self.leoDirectivesList = g.globalDirectiveList
self.encoding = self.defaultEncoding
self.ext = None # The file extension.
self.outputFileName = None # The name of the file being written.
self.outputFile = None # The open file being written.
self.path = '' # The path from any @path directive.
self.source = None # The written source as a string.
</t>
<t tx="ekr.20050805162550.12">def addMenu (self):

    c = self.c
    editMenu = c.frame.menu.getMenu('Edit')

    def rst3PluginCallback (event=None):
        self.processTopTree(c.p)

    c.k.registerCommand('write-restructured-text', rst3PluginCallback)
    table = (
        ("-",None,None),
        # ("Write Restructed Text","",rst3PluginCallback),
        '&amp;write-restructured-text',
    )
    c.frame.menu.createMenuEntries(editMenu, table)
</t>
<t tx="ekr.20050805162550.13">def initOptionsFromSettings (self):
    '''Init all options from settings.'''
    c = self.c
    d = self.defaultOptionsDict
    for key in sorted(d.keys()):
        for getter,kind in (
            (c.config.getBool,'@bool'),
            (c.config.getString,'@string'),
            (d.get,'default'),
        ):
            val = getter(key)
            if kind == 'default' or val is not None:
                self.setOption(key,val,'initOptionsFromSettings')
                break
    # Special case.
    if self.getOption('http_server_support') and not mod_http:
        g.error('No http_server_support: can not import mod_http plugin')
        self.setOption('http_server_support',False,tag='initOptionsFromSettings')
</t>
<t tx="ekr.20050805162550.16">def encode (self,s):

    return g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
</t>
<t tx="ekr.20050805162550.17">def processTree(self,p,ext,toString,justOneFile):

    '''Process all @rst nodes in a tree.'''

    self.preprocessTree(p)
    found = False ; self.stringOutput = ''
    p = p.copy() ; after= p.nodeAfterTree()
    while p and p != after:
        h = p.h.strip()
        if g.match_word(h,0,"@rst"):
            self.outputFileName = h[4:].strip()
            if (
                (self.outputFileName and self.outputFileName[0] != '-') or
                (toString and not self.outputFileName)
            ):
                found = True
                self.toplevel = p.level() # Define toplevel separately for each rst file.
                if toString:
                    self.ext = ext
                else:
                    self.ext = g.os_path_splitext(self.outputFileName)[1].lower()
                if self.ext in ('.htm','.html','.tex','.pdf'):
                    ok = self.writeSpecialTree(p,toString=toString,justOneFile=justOneFile)
                else:
                    ok = self.writeNormalTree(p,toString=toString)
                self.scanAllOptions(p) # Restore the top-level verbose setting.
                if toString:
                    return p.copy(),self.stringOutput
                else:
                    if ok: self.report(self.outputFileName)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else: p.moveToThreadNext()
    if not found:
        g.warning('No @rst nodes in selected tree')
    return None,None
</t>
<t tx="ekr.20050805162550.19">def underline (self,s,p):
    '''Return the underlining string to be used at the given level for string s.'''
    u = self.getOption('underline_characters') #  '''#=+*^~"'`-:&gt;&lt;_'''
    level = max(0,p.level()-self.toplevel)
    level = min(level+1,len(u)-1) # Reserve the first character for explicit titles.
    ch = u [level]
    n = max(4,len(s))
    return ch * n + '\n'
</t>
<t tx="ekr.20050805162550.2">from leo.core import leoGlobals as g

import html.parser as HTMLParser
import os
import pprint
import io
StringIO = io.StringIO
import sys

# Make sure the present directory in in sys.path.
dir,junk = os.path.split(__file__)
if dir not in sys.path: sys.path.append(dir)

try:
    from leo.plugins import mod_http
except ImportError:
    mod_http = None

try:
    import docutils
    import docutils.parsers.rst
    import docutils.core
    import docutils.io
except ImportError:
    # This message given in init.
    # g.pr('rst3 plugin: can not import docutils')
    docutils = None

try:
    import SilverCity
except ImportError:
    if '--silent' not in sys.argv and not g.unitTesting and not g.app.batchMode:
        g.pr('rst3 plugin: SilverCity not loaded')
    SilverCity = None
</t>
<t tx="ekr.20050805162550.20">def report (self,name):

    if self.getOption('verbose'):

        name = g.os_path_finalize(name)

        g.blue('wrote: %s' % (name))
</t>
<t tx="ekr.20050805162550.21">def writeSpecialTree (self,p,toString,justOneFile):

    c = self.c
    isHtml = self.ext in ('.html','.htm')
    if isHtml and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            g.es('SilverCity not present so no syntax highlighting')

    self.initWrite(p)
        # was ,encoding=g.choose(isHtml,'utf-8','iso-8859-1'))
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if not toString:
        # Compute this here for use by intermediate file.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)

        # Create the directory if it doesn't exist.
        theDir, junk = g.os_path_split(self.outputFileName)
        theDir = g.os_path_finalize(theDir) # #1341.
        if not g.os_path_exists(theDir):
            ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
            if not ok:
                g.error('did not create:',theDir)
                return False

        # if not os.access(theDir,os.F_OK):
            # os.mkdir(theDir)

        if self.getOption('write_intermediate_file'):
            name = self.outputFileName + '.txt'
            f = open(name,'w')
            f.write(self.source)
            f.close()
            self.report(name)

    try:
        output = self.writeToDocutils(self.source)
        ok = True
    except Exception:
        g.pr('Exception in docutils')
        g.es_exception()
        ok = False

    if ok:
        if isHtml:
            import re
            idxTitle = output.find('&lt;title&gt;&lt;/title&gt;')
            if idxTitle &gt; -1:
                m = re.search('&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;', output)
                if not m:
                    m = re.search('&lt;h1&gt;&lt;[^&gt;]+&gt;([^&lt;]*)&lt;/a&gt;&lt;/h1&gt;', output)
                if m:
                    output = output.replace(
                        '&lt;title&gt;&lt;/title&gt;',
                        '&lt;title&gt;%s&lt;/title&gt;' % m.group(1)
                    )


        if toString:
            self.stringOutput = output
        else:
            # Write the file to the directory containing the .leo file.
            f = open(self.outputFileName,'w')
            f.write(output)
            f.close()
            self.http_endTree(self.outputFileName, p, justOneFile=justOneFile)

    return ok
</t>
<t tx="ekr.20050805162550.23">def writeTree(self,p):
    '''Write p's tree to self.outputFile.'''
    self.scanAllOptions(p)
    if self.getOption('generate_rst'):
        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % self.outputFileName))
    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.writeNode(p)
</t>
<t tx="ekr.20050805162550.26">def writeHeadline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''

    docOnly             =  self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.writeHeadlineHelper(p)
</t>
<t tx="ekr.20050805162550.30">def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
</t>
<t tx="ekr.20050805162550.33"></t>
<t tx="ekr.20050805162550.34"># Was http_support_main

def http_endTree (self,filename,p,justOneFile):

    '''Do end-of-tree processing to support the http plugin.'''

    if (
        self.getOption('http_server_support') and
        self.getOption('generate_rst')
    ):
        self.set_initial_http_attributes(filename)
        self.find_anchors(p)
        if justOneFile:
            self.relocate_references(p.self_and_subtree)

        g.blue('html updated for http plugin')

        if self.getOption('clear_http_attributes'):
            g.es_print("http attributes cleared")
</t>
<t tx="ekr.20050805162550.35">def http_attribute_iter (self, p):
    """
    Iterator for all the nodes which have html code.
    Look at the descendents of p.
    Used for relocation.
    """

    for p1 in p.self_and_subtree():
        attr = mod_http.get_http_attribute(p1)
        if attr:
            yield (p1.copy(),attr)
</t>
<t tx="ekr.20050805162550.36">def set_initial_http_attributes (self,filename):

    f = open(filename)
    parser = htmlParserClass(self)

    for line in f.readlines():
        parser.feed(line)

    f.close()
</t>
<t tx="ekr.20050805162550.37">@ Relocate references here if we are only running for one file.

Otherwise we must postpone the relocation until we have processed all files.
@c

def relocate_references (self, iterator_generator):

    for p in iterator_generator():
        attr = mod_http.get_http_attribute(p)
        if not attr:
            continue
        if bwm_file:
            print &gt;&gt; bwm_file
            print &gt;&gt; bwm_file, "relocate_references(1): Position, attr:"
            pprint.pprint((p, attr), bwm_file)
        # http_lines = attr [3:]
        parser = link_htmlparserClass(self,p)
        for line in attr [3:]:
            try:
                parser.feed(line)
            except Exception:
                line = ''.join([ch for ch in line if ord(ch) &lt;= 127])
                parser.feed(line)
        replacements = parser.get_replacements()
        replacements.reverse()
        if not replacements:
            continue
        if bwm_file:
            print &gt;&gt; bwm_file, "relocate_references(2): Replacements:"
            pprint.pprint(replacements, bwm_file)
        for line, column, href, href_file, http_node_ref in replacements:
            if bwm_file:
                print &gt;&gt; bwm_file, ( "relocate_references(3): line:",
                    line, "Column:", column, "href:", href,
                    "href_file:", href_file, "http_node_ref:", http_node_ref)
            marker_parts = href.split("#")
            if len(marker_parts) == 2:
                marker = marker_parts [1]
                replacement = "%s#%s" % (http_node_ref,marker)
                try:
                    attr [line + 2] = attr [line + 2].replace(
                        'href="%s"' % href,'href="%s"' % replacement)
                except Exception:
                    g.es("Skipped ", attr[line + 2])
            else:
                # filename = marker_parts [0]
                try:
                    attr [line + 2] = attr [line + 2].replace(
                        'href="%s"' % href,
                        'href="%s"' % http_node_ref)
                except Exception:
                    g.es("Skipped", attr[line+2])
</t>
<t tx="ekr.20050805162550.38">def find_anchors (self, p):

    '''Find the anchors in all the nodes.'''

    for p1, attrs in self.http_attribute_iter(p):
        html = mod_http.reconstruct_html_from_attrs(attrs)
        parser = anchor_htmlParserClass(self, p1)
        for line in html:
            try:
                parser.feed(line)
            except Exception:
                line = ''.join([ch for ch in line if ord(ch) &lt;= 127])
                # filter out non-ascii characters.
                # bwm: not quite sure what's going on here.
                parser.feed(line)
</t>
<t tx="ekr.20050805162550.39">@
The parser classes are used to construct the html code for nodes. The algorithm has two phases:
    1. In the first phase, the html code for each node is identified.
    2. The second phase identifies all links and checks if these links need to be modified.
The first phase of scanning is done by the anchor_hmlParserClass. The second phase of this algorithm is
done with the link_htmlParserClass.
@code

&lt;&lt; class linkAnchorParserClass &gt;&gt;

@others
</t>
<t tx="ekr.20050805162550.4"></t>
<t tx="ekr.20050805162550.40">class linkAnchorParserClass (HTMLParser.HTMLParser):

    '''
    A class to recognize anchors and links in HTML documents.
    A special marker is the "node_marker" which demarkates the border between
    node and the next.
    '''

    @others
</t>
<t tx="ekr.20050805162550.41">def __init__(self,rst):

    super().__init__()
    self.rst = rst

    # Set ivars from options.  This works only if we don't change nodes!
    self.node_begin_marker      = rst.getOption('node_begin_marker')
    self.clear_http_attributes  = rst.getOption('clear_http_attributes')
    self.current_file = rst.outputFileName
</t>
<t tx="ekr.20050805162550.42">def is_anchor(self, tag, attrs):
    """
    Check if the current tag is an anchor.
    Returns *all* anchors.
    Works with docutils 0.4
    """

    if tag == 'a':
        return True

    if self.is_node_marker(attrs):
        return True
    return tag == "span"
</t>
<t tx="ekr.20050805162550.43">def is_link(self, tag, attrs):
    '''
    Return True if tag, attrs is represents a link.
    '''

    if tag != 'a':
        return False

    result = 'href' in dict(attrs)
    return result
</t>
<t tx="ekr.20050805162550.44">class htmlParserClass (linkAnchorParserClass):

    '''
    The responsibility of the html parser is:
        1. Find out which html code belongs to which node.
        2. Keep a stack of open tags which apply to the current node.
        3. Keep a list of tags which should be included in the nodes, even
           though they might be closed.
           The &lt;style&gt; tag is one example of that.

    Later, we have to relocate inter-file links: if a reference to another location
    is in a file, we must change the link.

    '''

    @others
</t>
<t tx="ekr.20050805162550.45">def __init__ (self,rst):

    super().__init__(rst) # Init the base class.

    self.stack = None
    # The stack contains lists of the form:
        # [text1, text2, previous].
        # text1 is the opening tag
        # text2 is the closing tag
        # previous points to the previous stack element

    self.node_marker_stack = []
    # self.node_marker_stack.pop() returns True for a closing
    # tag if the opening tag identified an anchor belonging to a vnode.

    self.node_code = []
        # Accumulated html code.
        # Once the hmtl code is assigned a vnode, it is deleted here.

    self.deleted_lines = 0 # Number of lines deleted in self.node_code

    self.endpos_pending = False
    # Do not include self.node_code[0:self.endpos_pending] in the html code.

    self.last_position = None
    # Last position; we must attach html code to this node.

    self.last_marker = None
</t>
<t tx="ekr.20050805162550.46">def handle_starttag (self,tag,attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If it is an anchor, we check if this anchor marks the beginning of a new
       node
    3. If a new node begins, then we might have to store html code for the previous
       node.
    4. In any case, put the new tag on the stack.
    '''
    is_node_marker = False
    if self.is_anchor(tag,attrs) and self.is_node_marker(attrs):
        is_node_marker = self.is_node_marker(attrs)
        line, column = self.getpos()
        if self.last_position:
            lines = self.node_code [:]
            lines [0] = lines [0] [self.startpos:]
            del lines [line-self.deleted_lines-1:]
            mod_http.get_http_attribute(self.last_position).extend(lines)
            &lt;&lt; trace the unknownAttribute &gt;&gt;
        if self.deleted_lines &lt; line-1:
            del self.node_code [: line-1-self.deleted_lines]
            self.deleted_lines = line-1
            self.endpos_pending = True
    starttag = self.get_starttag_text()
    self.stack = [starttag, None, self.stack]
    self.node_marker_stack.append(is_node_marker)
</t>
<t tx="ekr.20050805162550.47">def handle_endtag(self, tag):
    '''
    1. Set the second element of the current top of stack.
    2. If this is the end tag for an anchor for a node,
       store the current stack for that node.
    '''
    self.stack[1] = "&lt;/" + tag + "&gt;"

    if self.endpos_pending:
        line, column = self.getpos()
        self.startpos = self.node_code[0].find("&gt;", column) + 1
        self.endpos_pending = False

    is_node_marker = self.node_marker_stack.pop()

    if is_node_marker and not self.clear_http_attributes:
        self.last_position = self.rst.http_map[is_node_marker]
        if is_node_marker != self.last_marker:
            if bwm_file: print &gt;&gt; bwm_file, "Handle endtag:", is_node_marker, self.stack
            mod_http.set_http_attribute(self.rst.http_map[is_node_marker], self.stack)
            self.last_marker = is_node_marker
            #bwm: last_marker is not needed?

    self.stack = self.stack[2]
</t>
<t tx="ekr.20050805162550.49">def feed(self, line):

    self.node_code.append(line)

    HTMLParser.HTMLParser.feed(self, line) # Call the base class's feed().
</t>
<t tx="ekr.20050805162550.5">def init ():
    '''Return True if the plugin has loaded successfully.'''
    ok = docutils is not None # Ok for unit testing.
    if ok:
        g.registerHandler('after-create-leo-frame', onCreate)
        g.plugin_signon(__name__)
    else:
        g.error('rst3 plugin not loaded: can not load docutils')
    return ok
</t>
<t tx="ekr.20050805162550.50">class anchor_htmlParserClass (linkAnchorParserClass):

    '''
    This htmlparser does the first step of relocating: finding all the anchors within the html nodes.

    Each anchor is mapped to a tuple:
        (current_file, position).

    Filters out markers which mark the beginning of the html code for a node.
    '''

    @others
</t>
<t tx="ekr.20050805162550.51">def __init__ (self,rst,p):

    super().__init__(rst)

    self.p = p.copy()
    self.anchor_map = rst.anchor_map
</t>
<t tx="ekr.20050805162550.52">def handle_starttag(self, tag, attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If the current tag is an anchor, update the mapping;
         anchor -&gt; (filename, p)
    '''
    if not self.is_anchor(tag, attrs):
        return

    if self.current_file not in self.anchor_map:
        self.anchor_map[self.current_file] = (self.current_file, self.p)
        simple_name = g.os_path_split(self.current_file)[1]
        self.anchor_map[simple_name] = self.anchor_map[self.current_file]
        if bwm_file: print &gt;&gt; bwm_file, (
            "anchor(1): current_file:", self.current_file,
            "position:", self.p,
            "Simple name:", simple_name,
        )
        # Not sure what to do here, exactly. Do I need to manipulate
        # the pathname?

    for name, value in attrs:
        if name == 'name' or tag == 'span' and name == 'id':
            if not value.startswith(self.node_begin_marker):
                if bwm_file: print &gt;&gt; bwm_file, "anchor(2):", value, self.p
                self.anchor_map[value] = (self.current_file, self.p.copy())
</t>
<t tx="ekr.20050805162550.53">class link_htmlparserClass (linkAnchorParserClass):

    '''This html parser does the second step of relocating links:
    1. It scans the html code for links.
    2. If there is a link which links to a previously processed file
       then this link is changed so that it now refers to the node.
    '''

    @others
</t>
<t tx="ekr.20050805162550.54">def __init__ (self,rst,p):

    super().__init__(rst)

    self.p = p.copy()
    self.anchor_map = rst.anchor_map
    self.replacements = []
</t>
<t tx="ekr.20050805162550.55">def handle_starttag(self, tag, attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If the current tag is an anchor, update the mapping;
         anchor -&gt; p
        Update the list of replacements for the document.
    '''
    if bwm_file: print &gt;&gt; bwm_file, "Is link?", tag, attrs
    if not self.is_link(tag, attrs):
        return

    marker = self.node_begin_marker
    for name, value in attrs:
        if name == 'href':
            href = value
            href_parts = href.split("#")
            if len(href_parts) == 1:
                href_a = href_parts[0]
            else:
                href_a = href_parts[1]
            if bwm_file: print &gt;&gt; bwm_file, "link(1):", name, value, href_a
            if not href_a.startswith(marker):
                if href_a in self.anchor_map:
                    href_file, href_node = self.anchor_map[href_a]
                    http_node_ref = mod_http.node_reference(href_node)
                    line, column = self.getpos()
                    if bwm_file: print &gt;&gt; bwm_file, "link(2):", line, column, href, href_file, http_node_ref
                    self.replacements.append((line, column, href, href_file, http_node_ref))
</t>
<t tx="ekr.20050805162550.56">def get_replacements(self):

    return self.replacements
</t>
<t tx="ekr.20050805162550.6">def onCreate(tag, keywords):

    c = keywords.get('new_c') or keywords.get('c')
    if c:
        global controllers
        controllers[c] = rstClass(c)
        # Warning: Do not return anything but None here!
        # Doing so suppresses the loading of other 'new' or 'open2' hooks!
</t>
<t tx="ekr.20050805162550.8">class rstClass:

    '''A class to write rst markup in Leo outlines.'''

@ This plugin optionally stores information for the http plugin.

Each node can have one additional attribute, with the name rst_http_attributename, which is a list.

The first three elements are stack of tags, the rest is html code.

[&lt;tag n start&gt;, &lt;tag n end&gt;, &lt;other stack elements&gt;, &lt;html line 1&gt;, &lt;html line 2&gt;, ...]

&lt;other stack elements has the same structure:
    [&lt;tag n-1 start&gt;, &lt;tag n-1 end&gt;, &lt;other stack elements&gt;]
@c

    @others
</t>
<t tx="ekr.20050805162550.9"></t>
<t tx="ekr.20050806101253">def code_block (name,arguments,options,content,lineno,content_offset,block_text,state,state_machine):

    '''Implement the code-block directive for docutils.'''

    try:
        language = arguments [0]
        # See http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252170
        module = SilverCity and getattr(SilverCity,language)
        generator = module and getattr(module,language+"HTMLGenerator")
        if generator:
            io = StringIO()
            generator().generate_html(io,'\n'.join(content))
            html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n' % io.getvalue()
        else:
            html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n' % '&lt;br&gt;\n'.join(content)
        raw = docutils.nodes.raw('',html,format='html')
        return [raw]
    except Exception: # Return html as shown.  Lines are separated by &lt;br&gt; elements.
        g.es_trace('exception in rst3:code_block()')
        g.es_exception()
        return [None]

# See http://docutils.sourceforge.net/spec/howto/rst-directives.html
code_block.arguments = (
    1, # Number of required arguments.
    0, # Number of optional arguments.
    0) # True if final argument may contain whitespace.

# A mapping from option name to conversion function.
if docutils:
    code_block.options = {
        'language':
        docutils.parsers.rst.directives.unchanged # Return the text argument, unchanged.
    }
    code_block.content = 1 # True if content is allowed.

    # Register the directive with docutils.
    docutils.parsers.rst.directives.register_directive('code-block',code_block)
else:
    code_block.options = {}

</t>
<t tx="ekr.20050806162146">@nocolor
@

- Specify option for the spelling of special doc parts.
    - The present code assumes to much about these commands.
- Warn if option gets set twice in same vnode.

Later or never:
    - show_context option.
    - encoding option: can override @encoding directives
    - Support docutils config files.

@c

@others
</t>
<t tx="ekr.20050807120331.1">def preprocessTree (self,root):

    self.tnodeOptionDict = {}

    # Bug fix 12/4/05: must preprocess parents too.
    for p in root.parents():
        self.preprocessNode(p)

    for p in root.self_and_subtree():
        self.preprocessNode(p)

    if 0:
        g.trace(root.h)
        for key in self.tnodeOptionDict.keys():
            g.trace(key)
            g.printDict(self.tnodeOptionDict.get(key))
</t>
<t tx="ekr.20050807120331.2">def scanNodeForOptions (self,p):
    '''
    Return a dictionary containing all the option-name:value entries in p.

    Such entries may arise from @rst-option or @rst-options in the headline,
    or from @ @rst-options doc parts.
    '''
    d = self.scanHeadlineForOptions(p)
    d2 = self.scanForOptionDocParts(p,p.b)
    # A fine point: body options over-ride headline options.
    d.update(d2)
    return d
</t>
<t tx="ekr.20050808064245">def createDefaultOptionsDict(self):

    # Warning: changing the names of options changes the names of the corresponding ivars.

    self.defaultOptionsDict = {
        # Http options...
        'rst3_clear_http_attributes':   False,
        'rst3_http_server_support':     False,
        'rst3_http_attributename':      'rst_http_attribute',
        'rst3_node_begin_marker':       'http-node-marker-',
        # Path options...
        'rst3_default_path': None, # New in Leo 4.4a4 # Bug fix: must be None, not ''.
        'rst3_stylesheet_name': 'default.css',
        'rst3_stylesheet_path': None, # Bug fix: must be None, not ''.
        'rst3_publish_argv_for_missing_stylesheets': None,
        # Global options...
        'rst3_code_block_string': '',
        'rst3_number_code_lines': True,
        'rst3_underline_characters': '''#=+*^~"'`-:&gt;&lt;_''',
        'rst3_verbose':True,
        'rst3_write_intermediate_file': False, # Used only if generate_rst is True.
        # Mode options...
        'rst3_code_mode': False, # True: generate rst markup from @code and @doc parts.
        'rst3_doc_only_mode': False, # True: generate only from @doc parts.
        'rst3_generate_rst': True, # True: generate rst markup.  False: generate plain text.
        'rst3_generate_rst_header_comment': True,
            # True generate header comment (requires generate_rst option)
        # Formatting options that apply to both code and rst modes....
        'rst3_show_headlines': True,  # Can be set by @rst-no-head headlines.
        'rst3_show_organizer_nodes': True,
        'rst3_show_options_nodes': False,
        'rst3_show_sections': True,
        'rst3_strip_at_file_prefixes': True,
        'rst3_show_doc_parts_in_rst_mode': True,
        # Formatting options that apply only to code mode.
        'rst3_show_doc_parts_as_paragraphs': False,
        'rst3_show_leo_directives': True,
        'rst3_show_markup_doc_parts': False,
        'rst3_show_options_doc_parts': False,
        # *Names* of headline commands...
        'rst3_code_prefix':             '@rst-code',     # Enter code mode.
        'rst3_doc_only_prefix':         '@rst-doc-only', # Enter doc-only mode.
        'rst3_rst_prefix':              '@rst',          # Enter rst mode.
        'rst3_ignore_headline_prefix':  '@rst-no-head',
        'rst3_ignore_headlines_prefix': '@rst-no-headlines',
        'rst3_ignore_node_prefix':      '@rst-ignore-node',
        'rst3_ignore_prefix':           '@rst-ignore',
        'rst3_ignore_tree_prefix':      '@rst-ignore-tree',
        'rst3_option_prefix':           '@rst-option',
        'rst3_options_prefix':          '@rst-options',
        'rst3_preformat_prefix':        '@rst-preformat',
        'rst3_show_headline_prefix':    '@rst-head',
    }
</t>
<t tx="ekr.20050808070018">def scanOption (self,p,s):
    '''
    Return { name:val } if s is a line of the form name=val.
    Otherwise return {}
    '''
    if not s.strip() or s.strip().startswith('..'):
        return {}
    data = self.parseOptionLine(s)
    if data:
        name,val = data
        fullName = 'rst3_' + self.munge(name)
        if fullName in self.defaultOptionsDict.keys():
            if   val.lower() == 'true': val = True
            elif val.lower() == 'false': val = False
            return { self.munge(name): val }
        else:
            g.error('ignoring unknown option: %s' % (name))
            return {}
    else:
        g.trace(repr(s))
        g.error('bad rst3 option in %s: %s' % (p.h,s))
        return {}
</t>
<t tx="ekr.20050808070018.1">def scanOptions (self,p,s):

    '''Return a dictionary containing all the options in s.'''

    d = {}

    for line in g.splitLines(s):
        d2 = self.scanOption(p,line)
        if d2: d.update(d2)

    return d
</t>
<t tx="ekr.20050808070018.2">def scanForOptionDocParts (self,p,s):

    '''Return a dictionary containing all options from @rst-options doc parts in p.
    Multiple @rst-options doc parts are allowed: this code aggregates all options.
    '''

    d = {} ; n = 0 ; lines = g.splitLines(s)
    while n &lt; len(lines):
        line = lines[n] ; n += 1
        if line.startswith('@'):
            i = g.skip_ws(line,1)
            for kind in ('@rst-options','@rst-option'):
                if g.match_word(line,i,kind):
                    # Allow options on the same line.
                    line = line[i+len(kind):]
                    d.update(self.scanOption(p,line))
                    # Add options until the end of the doc part.
                    while n &lt; len(lines):
                        line = lines[n] ; n += 1 ; found = False
                        for stop in ('@c','@code', '@'):
                            if g.match_word(line,0,stop):
                                found = True ; break
                        if found:
                            break
                        else:
                            d.update(self.scanOption(p,line))
                    break
    return d
</t>
<t tx="ekr.20050808072943">def munge (self,name):

    '''Convert an option name to the equivalent ivar name.'''

    i = 3 if name.startswith('rst') else 0

    while i &lt; len(name) and name[i].isdigit():
        i += 1

    if i &lt; len(name) and name[i] == '_':
        i += 1

    s = name[i:].lower()
    s = s.replace('-','_')

    return s
</t>
<t tx="ekr.20050808072943.1">def parseOptionLine (self,s):
    '''
    Parse a line containing name=val and return (name,value) or None.
    If no value is found, default to True.
    '''
    s = s.strip()
    if s.endswith(','): s = s[:-1]
    # Get name.  Names may contain '-' and '_'.
    i = g.skip_id(s,0,chars='-_')
    name = s [:i]
    if not name:
        return None,'False'
    j = g.skip_ws(s,i)
    if g.match(s,j,'='):
        val = s [j+1:].strip()
        return name,val
    else:
        return name,'True'
</t>
<t tx="ekr.20050808142313.28"># Once an option is seen, no other related options in ancestor nodes have any effect.

def scanAllOptions(self,p):

    '''Scan position p and p's ancestors looking for options,
    setting corresponding ivars.
    '''

    self.initOptionsFromSettings()
        # Must be done on every node.
    self.handleSingleNodeOptions(p)
    seen = self.singleNodeOptions[:]
        # Suppress inheritance of single-node options.
    for p in p.self_and_parents():
        d = self.tnodeOptionDict.get(p.v,{})
        for key in d.keys():
            ivar = self.munge(key)
            if ivar not in seen:
                seen.append(ivar)
                val = d.get(key)
                self.setOption(key,val,p.h)
    # self.dumpSettings()
    if self.rst3_all:
        self.setOption("generate_rst", True, "rst3_all")
        self.setOption("generate_rst_header_comment",True, "rst3_all")
        self.setOption("http_server_support", True, "rst3_all")
        self.setOption("write_intermediate_file", True, "rst3_all")
</t>
<t tx="ekr.20050809074827"></t>
<t tx="ekr.20050809075309">def initWrite (self,p):

    self.initOptionsFromSettings() # Still needed.

    # Set the encoding from any parent @encoding directive.
    # This can be overridden by @rst-option encoding=whatever.
    c = self.c
    d = c.scanAllDirectives(p)
    self.encoding = d.get('encoding') or self.defaultEncoding
    self.path = d.get('path') or ''
</t>
<t tx="ekr.20050809080031">def write (self,s):

    s = self.encode(s)

    self.outputFile.write(s)
</t>
<t tx="ekr.20050809080925">def writeNormalTree (self,p,toString=False):

    self.initWrite(p)

    # Always write to a string first.
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.stringOutput = self.outputFile.getvalue()

    # Copy to a file if requested.
    if not toString:
        # Comput the output file name *after* calling writeTree.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)
        self.outputFile = open(self.outputFileName,'w')
        self.outputFile.write(self.stringOutput)
        self.outputFile.close()

    return True
</t>
<t tx="ekr.20050809082854"></t>
<t tx="ekr.20050809082854.1">def writeToDocutils (self,s):
    '''
    Send s to docutils using the writer implied by self.ext and return the
    result.
    '''
    # openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }
    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()
    writer = None
    for ext,writer in (
        ('.html','html'),
        ('.htm','html'),
        ('.tex','latex'),
        ('.pdf','leo_pdf'),
    ):
        if self.ext == ext:
            break
    else:
        g.error('unknown docutils extension: %s' % (self.ext))
        return ''

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if g.os_path_exists(path):
        if self.ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.error('stylesheet not found: %s' % (path))
    else:
        g.error('stylesheet not found\n',path)
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        res = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer_name=writer,
                settings_overrides=overrides)
    except docutils.ApplicationError as error:
        g.es_print('Error (%s): %s' % (error.__class__.__name__, error))
    return res
</t>
<t tx="ekr.20050810083057">def writeNode (self,p):

    '''Format a node according to the options presently in effect.'''

    self.initCodeBlockString(p)
    self.scanAllOptions(p)

    if 0:
        g.trace('%24s code_mode %s' % (p.h,self.getOption('code_mode')))

    h = p.h.strip()

    if self.getOption('preformat_this_node'):
        self.http_addNodeMarker(p)
        self.writePreformat(p)
        p.moveToThreadNext()
    elif self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.writeHeadline(p)
        self.writeBody(p)
        p.moveToThreadNext()
</t>
<t tx="ekr.20050810083314"></t>
<t tx="ekr.20050810083856">def rstComment (self,s):

    return '.. %s' % s
</t>
<t tx="ekr.20050810103731">def handleSingleNodeOptions (self,p):

    '''Init the settings of single-node options from the tnodeOptionsDict.

    All such options default to False.'''

    d = self.tnodeOptionDict.get(p.v, {} )

    for ivar in self.singleNodeOptions:
        val = d.get(ivar,False)
        self.setOption(ivar,val,p.h)

</t>
<t tx="ekr.20050811101550.1">def writeBody (self,p):

    # remove trailing cruft and split into lines.
    lines = p.b.rstrip().split('\n')

    if self.getOption('code_mode'):
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    s = '\n'.join(lines).strip()
    if s:
        self.write('%s\n\n' % s)
</t>
<t tx="ekr.20050811102607">def skip_literal_block (self,lines,n):

    s = lines[n] ; result = [s] ; n += 1
    indent = g.skip_ws(s,0)

    # Skip lines until a non-blank line is found with same or less indent.
    while n &lt; len(lines):
        s = lines[n]
        indent2 = g.skip_ws(s,0)
        if s and not s.isspace() and indent2 &lt;= indent:
            break # We will rescan lines [n]
        n += 1
        result.append(s)

    # g.printList(result,tag='literal block')
    return n, result
</t>
<t tx="ekr.20050811105438">def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,0,key):
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20050811105438.1">def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20050811135526">def setOption (self,name,val,tag):

    ivar = self.munge(name)
    self.optionsDict [ivar] = val
</t>
<t tx="ekr.20050811150541">def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or
            (self.getOption('show_doc_parts_as_paragraphs') and self.isSpecialDocPart(s,None))
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []
    return self.rstripList(result)
</t>
<t tx="ekr.20050811152104">def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
</t>
<t tx="ekr.20050811153208">def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) &gt; 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    return result
</t>
<t tx="ekr.20050811154552">def getDocPart (self,lines,n):

    result = []
    &lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
            break
        result.append(s)
    return n, result
</t>
<t tx="ekr.20050811163802">def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
</t>
<t tx="ekr.20050811173750">def scanHeadlineForOptions (self,p):

    '''Return a dictionary containing the options implied by p's headline.'''

    h = p.h.strip()

    if p == self.topNode:
        return {} # Don't mess with the root node.
    elif g.match_word(h,0,self.getOption('option_prefix')): # '@rst-option'
        s = h [len(self.option_prefix):]
        return self.scanOption(p,s)
    elif g.match_word(h,0,self.getOption('options_prefix')): # '@rst-options'
        return self.scanOptions(p,p.b)
    else:
        # Careful: can't use g.match_word because options may have '-' chars.
        i = g.skip_id(h,0,chars='@-')
        word = h[0:i]

        for prefix,ivar,val in (
            ('code_prefix','code_mode',True), # '@rst-code'
            ('doc_mode_prefix','doc_only_mode',True), # @rst-doc-only.
            ('default_path_prefix','default_prefix',''), # '@rst-default-path'
            ('rst_prefix','code_mode',False), # '@rst'
            ('ignore_headline_prefix','ignore_this_headline',True), # '@rst-no-head'
            ('show_headline_prefix','show_this_headline',True), # '@rst-head'
            ('ignore_headlines_prefix','show_headlines',False), # '@rst-no-headlines'
            ('ignore_prefix','ignore_this_tree',True),      # '@rst-ignore'
            ('ignore_node_prefix','ignore_this_node',True), # '@rst-ignore-node'
            ('ignore_tree_prefix','ignore_this_tree',True), # '@rst-ignore-tree'
            ('preformat_prefix','preformat_this_node',True), # '@rst-preformat
        ):
            prefix = self.getOption(prefix)
            if prefix and word == prefix: # Do _not_ munge this prefix!
                d = { ivar: val }
                if ivar != 'code_mode':
                    d ['code_mode'] = False # Enter rst mode.
                    d ['doc_only_mode'] = False
                # Special case: Treat a bare @rst like @rst-no-head
                if h == self.getOption('rst_prefix'):
                    d ['ignore_this_headline'] = True
                return d

        if h.startswith('@rst'):
            g.trace('word',word,'rst_prefix',self.getOption('rst_prefix'))
            g.trace('unknown kind of @rst headline',p.h)

        return {}
</t>
<t tx="ekr.20050812120933">def dumpSettings (self):

    d = self.optionsDict
    keys = list(d.keys())
    keys.sort()

    g.pr('present settings...')
    for key in keys:
        g.pr('%20s %s' % (key,d.get(key)))
</t>
<t tx="ekr.20050812122236"></t>
<t tx="ekr.20050813083007">def initHeadlineCommands (self):

    '''Init the list of headline commands used by writeHeadline.'''

    self.headlineCommands = [
        self.getOption('code_prefix'),
        self.getOption('doc_only_prefix'),
        self.getOption('default_path_prefix'),
        self.getOption('rst_prefix'),
        self.getOption('ignore_headline_prefix'),
        self.getOption('ignore_headlines_prefix'),
        self.getOption('ignore_node_prefix'),
        self.getOption('ignore_tree_prefix'),
        self.getOption('option_prefix'),
        self.getOption('options_prefix'),
        self.getOption('show_headline_prefix'),
        # # Suggested by Hemanth P.S.: prevent @file nodes from creating headings.
        # self.getOption('keep_at_file_prefix'),
        # self.getOption('strip_at_file_prefix'),
    ]
</t>
<t tx="ekr.20050813085236">def initSingleNodeOptions (self):

    self.singleNodeOptions = [
        'ignore_this_headline',
        'ignore_this_node',
        'ignore_this_tree',
        'preformat_this_node',
        'show_this_headline',
    ]
</t>
<t tx="ekr.20050813155021">def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    s = '\n'.join(theList).rstrip()
    return s.split('\n')
</t>
<t tx="ekr.20050813160208">def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
</t>
<t tx="ekr.20050814134351">def getOption (self,name):

    bwm = False
    if bwm:
        g.trace("bwm: getOption self:%s, name:%s, value:%s" % (
            self, name, self.optionsDict.get(name)))

    return self.optionsDict.get(name)
</t>
<t tx="ekr.20050815091008.1">def http_addNodeMarker (self,p):

    if (
        self.getOption('http_server_support') and
        self.getOption('generate_rst')
    ):
        self.nodeNumber += 1
        anchorname = "%s%s" % (self.getOption('node_begin_marker'),self.nodeNumber)
        s = "\n\n.. _%s:\n\n" % anchorname
        self.write(s)
        self.http_map [anchorname] = p.copy()
        if bwm_file: print &gt;&gt; bwm_file, "addNodeMarker", anchorname, p
</t>
<t tx="ekr.20050815164715">def is_node_marker (self,attrs):
    '''
    Return the name of the anchor, if this is an anchor for the beginning of a node,
    False otherwise.
    '''

    d = dict(attrs)
    result = 'id' in d and d['id'].startswith(self.node_begin_marker)
    if result:
        return d['id']
    return result
</t>
<t tx="ekr.20050815164715.1">if 0:
    g.pr("rst3: unknownAttributes[self.http_attributename]")
    g.pr("For:", self.last_position)
    pprint.pprint(mod_http.get_http_attribute(self.last_position))
</t>
<t tx="ekr.20050817132814">@nocolor-node

Important: the rst3 plugin has largely been superceded by similar
commands built into Leo's core.

To activate the rst3 plugin, do the following:

1. Go to http://silvercity.sourceforge.net/.
- Follow the link 'SilverCity Releases'.
- Download the release that fits to your Python version.
- Double-klick on the downloaded file.

2. Go to http://docutils.sourceforge.net/.
- Have a look for item 'Download'
- Get, as the editor says, the latest snapshot by following the link
  'docutils-snapshot.tgz'.
- Make sure you have a application that can handle this format. 7zip is doing this great.
- Unpack it to a temporary folder.
- Open a console window, go to the temporary folder and type 'setup.py install'
  or '&lt;path_to_python.exe&gt;\python setup.py install'.

3. Start up Leo
- Check in the menu 'Edit' for item 'Write-Restructured-Text'.
</t>
<t tx="ekr.20051009045404">def createFirstTreeNode(self):
    c= self.c
    v = leoNodes.VNode(context=c)
    p = leoNodes.Position(v)
    v.initHeadString("NewHeadline")
    #
    # #1631: Initialize here, not in p._linkAsRoot.
    c.hiddenRootNode.children = []
    #
    # New in Leo 4.5: p.moveToRoot would be wrong: the node hasn't been linked yet.
    p._linkAsRoot()
</t>
<t tx="ekr.20051022044950">def computeOldStyleShortcutKey(self, s):
    '''Compute the old-style shortcut key for @shortcuts entries.'''
    # #1121: Allow Chinese characters in command names
    return s.strip()
</t>
<t tx="ekr.20051031040240" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032302d31312d31307103752e">g.cls()
import importlib
import leo.core.leoTest2 as leoTest2
importlib.reload(leoTest2)
import os
#
# In unittest: python -m commands.editCommands
# 
path = os.path.abspath(os.path.join(g.app.loadDir, '..', 'unittest'))
os.chdir(path)
if 0:
    os.system('python -c "import os; print(\'cwd:\', os.getcwd())"')
python_args = ''  # '-v', 
module = 'commands.editCommands'
test = '' # '-k "test_rectangle_yank"'
output_file = ''  # r'&gt; C:\Users\edreamleo\Desktop\trace.txt'
command = f"python {python_args} -m {module} {test} {output_file}"
print(command)
os.system(command)
if test:
    print('done')
elif g.isWindows:
    os.system(f"start {path}\\htmlcov")
else:
    print(f"done: html is in {path}\\htmlcov")</t>
<t tx="ekr.20051104075904.84">def setUp(self):

    c = self.c; temp_p = self.temp_p
    d = self.dialog
    assert(d)
    temp_p.setBodyString('')
    # Create a node under temp_p.
    child = temp_p.insertAsLastChild()
    assert(child)
    child.h = "import/export test: " + self.p.h
    c.selectPosition(child)
    # Get the dialog name and the fileName from the dialog node.
    # This is used below to set up the dialog dict for NullGui.simulateDialog.
    s = d.bodyString()
    lines = s.split('\n')
    name = lines[0]
    fileName = lines[1]
    # Replace '\\' by os.path.sep in fileName
    fileName = fileName.replace('\\', os.path.sep)
    self.fileName = fileName = g.os_path_finalize_join(g.app.loadDir, "..", fileName)
    # Set the dict for UnitTestGui, a subclass of NullGui.
    # NullGui.simulateDialog uses this dict to return values for dialogs.
    if self.doImport:
        theDict = {name: [fileName]}
    else:
        theDict = {name: fileName}
    self.oldGui = g.app.gui
    self.gui = leoGui.UnitTestGui(theDict)
</t>
<t tx="ekr.20051104075904.93">def checkFileSyntax(self, fileName, s, reraise=True, suppress=False):
    """Called by a unit test to check the syntax of a file."""
    try:
        s = s.replace('\r', '')
        tree = compile(s + '\n', fileName, 'exec')
        # #1454: To suppress -Wd ResourceWarning.
        del tree
        return True
    except SyntaxError:
        if not suppress:
            g.warning("syntax error in:", fileName)
            g.es_print_exception(full=True, color="black")
        if reraise: raise
        return False
    except Exception:
        if not suppress:
            g.warning("unexpected error in:", fileName)
            # g.es_print_exception(full=False,color="black")
        if reraise: raise
        return False
</t>
<t tx="ekr.20051121102358">def processTopTree (self,p,justOneFile=False):

    current = p.copy()
    for p in current.self_and_parents():
        h = p.h
        if h.startswith('@rst') and not h.startswith('@rst-'):
            self.processTree(p,
                ext=None,
                toString=False,
                justOneFile=justOneFile,
            )
            break
    else:
        self.processTree(current,
            ext=None,
            toString=False,
            justOneFile=justOneFile,
        )
    g.blue('done')
</t>
<t tx="ekr.20051202070028">def computeOutputFileName (self,fileName):

    openDirectory = self.c.frame.openDirectory
    default_path = self.getOption('default_path')
    if default_path:
        path = g.os_path_finalize_join(self.path,default_path,fileName)
    elif self.path:
        path = g.os_path_finalize_join(self.path,fileName)
    elif openDirectory:
        path = g.os_path_finalize_join(self.path,openDirectory,fileName)
    else:
        path = g.os_path_finalize_join(fileName)

    return path
</t>
<t tx="ekr.20051204070141">def preprocessNode (self,p):

    d = self.tnodeOptionDict.get(p.v)
    if d is None:
        d = self.scanNodeForOptions(p)
        self.tnodeOptionDict [p.v] = d
</t>
<t tx="ekr.20060127070008">def setIvarsFromBunch(self, bunch):
    u = self
    u.clearOptionalIvars()
    if 0:  # Debugging.
        g.pr('-' * 40)
        for key in list(bunch.keys()):
            g.trace(f"{key:20} {bunch.get(key)!r}")
        g.pr('-' * 20)
    if g.unitTesting:  # #1694: An ever-present unit test.
        val = bunch.get('oldMarked')
        assert val in (True, False), f"{val!r} {g.callers()!s}"
    # bunch is not a dict, so bunch.keys() is required.
    for key in list(bunch.keys()):
        val = bunch.get(key)
        setattr(u, key, val)
        if key not in u.optionalIvars:
            u.optionalIvars.append(key)
</t>
<t tx="ekr.20060328125248.8">def createAllButtons(self):
    '''Scan for @button, @rclick, @command, @plugin and @script nodes.'''
    c = self.c
    if self.scanned:
        return # Defensive.
    self.scanned = True
    #
    # First, create standard buttons.
    if self.createRunScriptButton:
        self.createRunScriptIconButton()
    if self.createScriptButtonButton:
        self.createScriptButtonIconButton()
    if self.createDebugButton:
        self.createDebugIconButton()
    #
    # Next, create common buttons and commands.
    self.createCommonButtons()
    self.createCommonCommands()
    #
    # Handle all other nodes.
    d = {
        'button': self.handleAtButtonNode,
        'command': self.handleAtCommandNode,
        'plugin': self.handleAtPluginNode,
        'rclick': self.handleAtRclickNode,
        'script': self.handleAtScriptNode,
    }
    pattern = re.compile(r'^@(button|command|plugin|rclick|script)\b')
    p = c.rootPosition()
    while p:
        gnx = p.v.gnx
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif gnx in self.seen:
            # #657
            # if g.match_word(p.h, 0, '@rclick'):
            if p.h.startswith('@rlick'):
                self.handleAtRclickNode(p)
            p.moveToThreadNext()
        else:
            self.seen.add(gnx)
            m = pattern.match(p.h)
            if m:
                func = d.get(m.group(1))
                func(p)
            p.moveToThreadNext()
</t>
<t tx="ekr.20060525102337">def writeNodeToString (self,p=None,ext=None):
    '''
    Scan p's tree (defaults to presently selected tree) looking for @rst nodes.
    Convert the first node found to an ouput of the type specified by ext.

    The @rst may or may not be followed by a filename; the filename is *ignored*,
    and its type does not affect ext or the output generated in any way.

    ext should start with a period:  .html, .tex or None (specifies rst output).

    Returns p, s, where p is the position of the @rst node and s is the converted text.
    '''
    c = self.c
    current = p or c.p
    for p in current.self_and_parents():
        if p.h.startswith('@rst'):
            return self.processTree(p,ext=ext,toString=True,justOneFile=True)
    return self.processTree(current,ext=ext,toString=True,justOneFile=True)
</t>
<t tx="ekr.20060526201951">def makeRegexSubs(self, change_text, groups):
    """
    Substitute group[i-1] for \\i strings in change_text.
    """

    def repl(match_object):
        # # 1494...
        n = int(match_object.group(1)) - 1
        if 0 &lt;= n &lt; len(groups):
            return (
                groups[n].
                    replace(r'\b', r'\\b').
                    replace(r'\f', r'\\f').
                    replace(r'\n', r'\\n').
                    replace(r'\r', r'\\r').
                    replace(r'\t', r'\\t').
                    replace(r'\v', r'\\v'))
        # No replacement.
        return match_object.group(0)

    result = re.sub(r'\\([0-9])', repl, change_text)
    # print(
        # f"makeRegexSubs:\n"
        # f"change_text: {change_text!s}\n"
        # f"     groups: {groups!s}\n"
        # f"     result: {result!s}")
    return result
</t>
<t tx="ekr.20060608094815">def handleDocOnlyMode (self,p,lines):
    '''
    Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.
    '''
    # ignore            = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')
    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            self.writeHeadlineHelper(p)
    return result
</t>
<t tx="ekr.20060608094815.1">def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
</t>
<t tx="ekr.20060608102001">def writeHeadlineHelper (self,p):

    h = p.h.strip()

    # Remove any headline command before writing the
    i = g.skip_id(h,0,chars='@-')
    word = h [:i]
    if word:
        # Never generate a section for @rst-option or @rst-options.
        if word in (self.getOption('option_prefix'),self.getOption('options_prefix')):
            return
        # Remove all other headline commands from the headline.
        for prefix in self.headlineCommands:
            if word == prefix:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write('%s\n%s\n' % (h,self.underline(h,p)))
        else:
            self.write('\n%s\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
</t>
<t tx="ekr.20060610104435">if n &gt; 0:
    line = lines[n-1]
    if line.startswith('@doc'):
        s = line[4:].lstrip()
    elif line.startswith('@'):
        s = line[1:].lstrip()
    else:
        s = ''

    # New in Leo 4.4.4: remove these special tags.
    for tag in ('@rst-options','@rst-option','@rst-markup'):
        if g.match_word(s,0,tag):
            s = s[len(tag):].strip()

    if s.strip():
        result.append(s)
</t>
<t tx="ekr.20060928062431">@g.commander_command('expand-ancestors-only')
def expandOnlyAncestorsOfNode(self, event=None, p=None):
    """Contract all nodes in the outline."""
    c = self
    level = 1
    if p: c.selectPosition(p)  # 2013/12/25
    root = c.p
    for p in c.all_unique_positions():
        p.v.expandedPositions = []
        p.v.contract()
    for p in root.parents():
        p.expand()
        level += 1
    c.expansionLevel = level  # Reset expansion level.
</t>
<t tx="ekr.20060929135558">def cleanButtonText(self, s, minimal=False):
    '''
    Clean the text following @button or @command so
    that it is a valid name of a minibuffer command.
    '''
    # #1121: Don't lowercase anything.
    if minimal:
        return s.replace(' ','-').strip('-')
    for tag in ('@key', '@args', '@color',):
        i = s.find(tag)
        if i &gt; -1:
            j = s.find('@', i + 1)
            if i &lt; j:
                s = s[: i] + s[j:]
            else:
                s = s[: i]
            s = s.strip()
    return s.replace(' ','-').strip('-')
</t>
<t tx="ekr.20061008140603">def runEditCommandTest(self, p):
    tm = self
    c = self.c
    atTest = p.copy()
    w = c.frame.body.wrapper
    h = atTest.h
    assert h.startswith('@test '), f"expected head: {'@test'}, got: {h}"
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, f"no command: {commandName}"
    work, before, after = tm.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node, h in ((work, 'work'), (before, before_h), (after, after_h)):
        h2 = node.h
        assert h2.startswith(h), f"expected head: {h}, got: {h2}"
    sels = []
    for node, h in ((before, before_h), (after, after_h)):
        sel = node.h[len(h) :].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    # pylint: disable=unbalanced-tuple-unpacking
    sel1, sel2 = sels
    c.selectPosition(work)
    work.b = before.b
    w.setSelectionRange(sel1[0], sel1[1], insert=sel1[1])
    ### g.trace(commandName, sel1[0], sel1[1])
    ### g.printObj(g.splitLines(w.getSelectedText()))
    c.k.simulateCommand(commandName)
    s1 = work.b; s2 = after.b
    assert s1 == s2, (
        f"mismatch in body\n"
        f"expected: {s2!r}\n"
        f"     got: {s1!r}")
    sel3 = w.getSelectionRange()
    # Convert both selection ranges to gui indices.
    sel2_orig = sel2
    assert len(sel2) == 2, f"Bad headline index.  Expected index,index.  got: {sel2}"
    i, j = sel2; sel2 = w.toPythonIndex(i), w.toPythonIndex(j)
    assert len(sel3) == 2, f"Bad headline index.  Expected index,index.  got: {sel3}"
    i, j = sel3; sel3 = w.toPythonIndex(i), w.toPythonIndex(j)
    if 0:  # Be more permissive.
        if sel2 != sel3:
            print(f"\n{p.h}\nexpected: {sel2_orig} = {sel2}, got: {sel3}")
    else:
        message = f"mismatch in sel\nexpected: {sel2_orig} = {sel2}, got: {sel3}"
        assert sel2 == sel3, message
    c.selectPosition(atTest)
    atTest.contract()
    # Don't redraw.
</t>
<t tx="ekr.20061031131434.10">@cmd('auto-complete-force')
def autoCompleteForce(self, event=None):
    """Show autocompletion, even if autocompletion is not presently enabled."""
    return self.autoComplete(event, force=True)
</t>
<t tx="ekr.20061031131434.100">def addModeCommands(self):
    """Add commands created by @mode settings to c.commandsDict."""
    k = self; c = k.c
    d = g.app.config.modeCommandsDict  # Keys are command names: enter-x-mode.
    # Create the callback functions and update c.commandsDict.
    for key in d.keys():
        # pylint: disable=cell-var-from-loop

        def enterModeCallback(event=None, name=key):
            k.enterNamedMode(event, name)

        c.commandsDict[key] = enterModeCallback
</t>
<t tx="ekr.20061031131434.101">def initSpecialIvars(self):
    """Set ivars for special keystrokes from previously-existing bindings."""
    c, k = self.c, self
    warn = c.config.getBool('warn-about-missing-settings')
    for ivar, commandName in (
        ('fullCommandKey', 'full-command'),
        ('abortAllModesKey', 'keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey', 'auto-complete-force'),
        ('demoNextKey', 'demo-next'),
        ('demoPrevKey', 'demo-prev'),
    ):
        junk, aList = c.config.getShortcut(commandName)
        aList, found = aList or [], False
        for pane in ('text', 'all'):
            for bi in aList:
                if bi.pane == pane:
                    setattr(k, ivar, bi.stroke)
                    found = True; break
        if not found and warn:
            g.trace(f"no setting for {commandName}")
</t>
<t tx="ekr.20061031131434.102">def makeBindingsFromCommandsDict(self):
    """Add bindings for all entries in c.commandsDict."""
    c, k = self.c, self
    d = c.commandsDict
    #
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of bi with bi.stroke == stroke.
    d2 = g.TypedDict(  # was TypedDictOfLists.
        name='makeBindingsFromCommandsDict helper dict',
        keyType=g.KeyStroke,
        valType=g.BindingInfo,
    )
    for commandName in sorted(d):
        command = d.get(commandName)
        key, aList = c.config.getShortcut(commandName)
        for bi in aList:
            # Important: bi.stroke is already canonicalized.
            stroke = bi.stroke
            bi.commandName = commandName
            if stroke:
                assert g.isStroke(stroke)
                d2.add_to_list(stroke, bi)
    #
    # Step 2: make the bindings.
    for stroke in sorted(d2.keys()):
        aList2 = d2.get(stroke)
        for bi in aList2:
            commandName = bi.commandName
            command = c.commandsDict.get(commandName)
            tag = bi.kind
            pane = bi.pane
            if stroke and not pane.endswith('-mode'):
                k.bindKey(pane, stroke, command, commandName, tag=tag)
</t>
<t tx="ekr.20061031131434.103">def makeMasterGuiBinding(self, stroke, w=None):
    """Make a master gui binding for stroke in pane w, or in all the standard widgets."""
    k = self; c = k.c; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = (
            f.tree
            and hasattr(f.tree, 'bindingWidget')
            and f.tree.bindingWidget
            or None)
        wrapper = f.body and hasattr(f.body, 'wrapper') and f.body.wrapper or None
        canvas = f.tree and hasattr(f.tree, 'canvas') and f.tree.canvas or None
        widgets = (c.miniBufferWidget, wrapper, canvas, bindingWidget)
    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke, [])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict[stroke] = aList
</t>
<t tx="ekr.20061031131434.104"></t>
<t tx="ekr.20061031131434.108">def callStateFunction(self, event):
    """Call the state handler associated with this event."""
    k = self
    ch = event.char
    #
    # Defensive programming
    if not k.state.kind:
        return None
    if not k.state.handler:
        g.error('callStateFunction: no state function for', k.state.kind)
        return None
    #
    # Handle auto-completion before checking for unbound keys.
    if k.state.kind == 'auto-complete':
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        return val
    #
    # Ignore unbound non-ascii keys.
    if (
        k.ignore_unbound_non_ascii_keys and
        len(ch) == 1 and
        ch and ch not in ('\b', '\n', '\r', '\t') and
        (ord(ch) &lt; 32 or ord(ch) &gt; 128)
    ):
        return None
    #
    # Call the state handler.
    val = k.state.handler(event)
    return val
</t>
<t tx="ekr.20061031131434.11">def auto_completer_state_handler(self, event):
    """Handle all keys while autocompleting."""
    c, k, tag = self.c, self.k, 'auto-complete'
    state = k.getState(tag)
    ch = event.char if event else ''
    stroke = event.stroke if event else ''
    is_plain = k.isPlainKey(stroke)
    if state == 0:
        c.frame.log.clearTab(self.tabName)
        common_prefix, prefix, tabList = self.compute_completion_list()
        if tabList:
            k.setState(tag, 1, handler=self.auto_completer_state_handler)
        else:
            self.exit()
    elif ch in ('\n', 'Return'):
        self.exit()
    elif ch == 'Escape':
        self.exit()
    elif ch in ('\t', 'Tab'):
        self.compute_completion_list()
    elif ch in ('\b', 'BackSpace'):
        self.do_backspace()
    elif ch == '.':
        self.insert_string('.')
        self.compute_completion_list()
    elif ch == '?':
        self.info()
    elif ch == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        kind = 'ON' if self.verbose else 'OFF'
        message = f"verbose completions {kind}"
        g.es_print(message)
        # This doesn't work because compute_completion_list clears the autocomplete tab.
        # self.put('', message, tabName=self.tabName)
        # This is almost invisible: the fg='red' is not honored.
        c.frame.putStatusLine(message, fg='red')
        self.compute_completion_list()
    # elif ch == 'Down' and hasattr(self,'onDown'):
        # self.onDown()
    # elif ch == 'Up' and hasattr(self,'onUp'):
        # self.onUp()
    elif is_plain and ch and ch in string.printable:
        self.insert_general_char(ch)
    elif stroke == k.autoCompleteForceKey:
        # This is probably redundant because completions will exist.
        # However, it doesn't hurt, and it may be useful rarely.
        common_prefix, prefix, tabList = self.compute_completion_list()
        if tabList:
            self.show_completion_list(common_prefix, prefix, tabList)
        else:
            g.warning('No completions')
            self.exit()
    else:
        self.abort()
        return 'do-standard-keys'
    return None
</t>
<t tx="ekr.20061031131434.111">@cmd('full-command')
def fullCommand(
    self,
    event,
    specialStroke=None,
    specialFunc=None,
    help=False,
    helpHandler=None,
):
    """Handle 'full-command' (alt-x) mode."""
    try:
        k = self; c = k.c
        state = k.getState('full-command')
        helpPrompt = 'Help for command: '
        c.check_event(event)
        ch = char = event.char if event else ''
        stroke = event.stroke if event else ''
        if state &gt; 0:
            k.setLossage(char, stroke)
        if state == 0:
            k.mb_event = event  # Save the full event for later.
            k.setState('full-command', 1, handler=k.fullCommand)
            prompt = helpPrompt if help else k.altX_prompt
            k.setLabelBlue(prompt)
            k.mb_help = help
            k.mb_helpHandler = helpHandler
            c.minibufferWantsFocus()
        elif char == 'Ins' or k.isFKey(char):
            pass
        elif char == 'Escape':
            k.keyboardQuit()
        elif char == 'Down':
            k.commandHistoryFwd()
        elif char == 'Up':
            k.commandHistoryBackwd()
        elif char in ('\n', 'Return'):
            # Fix bug 157: save and restore the selection.
            w = k.mb_event and k.mb_event.w
            if w and hasattr(w, 'hasSelection') and w.hasSelection():
                sel1, sel2 = w.getSelectionRange()
                ins = w.getInsertPoint()
                c.frame.log.deleteTab('Completion')
                w.setSelectionRange(sel1, sel2, insert=ins)
            else:
                c.frame.log.deleteTab('Completion')
                    # 2016/04/27
            if k.mb_help:
                s = k.getLabel()
                commandName = s[len(helpPrompt) :].strip()
                k.clearState()
                k.resetLabel()
                if k.mb_helpHandler: k.mb_helpHandler(commandName)
            else:
                s = k.getLabel(ignorePrompt=True)
                commandName = s.strip()
                ok = k.callAltXFunction(k.mb_event)
                if ok:
                    k.addToCommandHistory(commandName)
        elif char in ('\t', 'Tab'):
            k.doTabCompletion(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif char in ('\b', 'BackSpace'):
            k.doBackSpace(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif k.ignore_unbound_non_ascii_keys and len(ch) &gt; 1:
            if specialStroke:
                g.trace(specialStroke)
                specialFunc()
            c.minibufferWantsFocus()
        else:
            # Clear the list, any other character besides tab indicates that a new prefix is in effect.
            k.mb_tabList = []
            k.updateLabel(event)
            k.mb_tabListPrefix = k.getLabel()
            c.minibufferWantsFocus()
    except Exception:
        g.es_exception()
        self.keyboardQuit()
</t>
<t tx="ekr.20061031131434.112">def callAltXFunction(self, event):
    """Call the function whose name is in the minibuffer."""
    c, k = self.c, self
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.

        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))

    else:
        func = c.commandsDict.get(commandName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
        else:
            c.widgetWantsFocusNow(event and event.widget)  # So cut-text works, e.g.
        try:
            func(event)
        except Exception:
            g.es_exception()
        return True
    # Show possible completions if the command does not exist.
    k.doTabCompletion(list(c.commandsDict.keys()))
    return False
</t>
<t tx="ekr.20061031131434.114"></t>
<t tx="ekr.20061031131434.119">@cmd('show-bindings')
def printBindings(self, event=None):
    """Print all the bindings presently in effect."""
    k = self; c = k.c
    d = k.bindingsDict; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] @mode, @button, @command

'''
    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend, c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke), stroke
        aList = d.get(stroke, [])
        for bi in aList:
            s1 = '' if bi.pane == 'all' else bi.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = bi.commandName
            s4 = bi.kind or '&lt;no hash&gt;'
            data.append((s1, s2, s3, s4),)
    # Print keys by type:
    result = []
    result.append('\n' + legend)
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Ctrl', 'Alt+Shift', 'Alt',  # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift', 'Ctrl+Meta', 'Ctrl+Shift', 'Ctrl',  # Ctrl+Key: done by Ctrl.
        'Meta+Key', 'Meta+Shift', 'Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1, s2, s3, s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append(f"***** {prefix}...\n")
        self.printBindingsHelper(result, data2, prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result, data, prefix=None)
    if not g.unitTesting:
        g.es_print('', ''.join(result), tabName=tabName)
    k.showStateAndMode()
    return result  # for unit test.
</t>
<t tx="ekr.20061031131434.12">@cmd('disable-autocompleter')
def disableAutocompleter(self, event=None):
    """Disable the autocompleter."""
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

@cmd('disable-calltips')
def disableCalltips(self, event=None):
    """Disable calltips."""
    self.k.enable_calltips = False
    self.showCalltipsStatus()

@cmd('enable-autocompleter')
def enableAutocompleter(self, event=None):
    """Enable the autocompleter."""
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

@cmd('enable-calltips')
def enableCalltips(self, event=None):
    """Enable calltips."""
    self.k.enable_calltips = True
    self.showCalltipsStatus()

@cmd('toggle-autocompleter')
def toggleAutocompleter(self, event=None):
    """Toggle whether the autocompleter is enabled."""
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

@cmd('toggle-calltips')
def toggleCalltips(self, event=None):
    """Toggle whether calltips are enabled."""
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
</t>
<t tx="ekr.20061031131434.120">def printBindingsHelper(self, result, data, prefix):
    """Helper for k.printBindings"""
    c, lm = self.c, g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        letter = lm.computeBindingLetter(c, kind)
        pane = f"{pane if pane else 'all':4}: "
        left = pane + key  # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
</t>
<t tx="ekr.20061031131434.121">@cmd('show-commands')
def printCommands(self, event=None):
    """Print all the known commands and their bindings, if any."""
    k = self; c = k.c; tabName = 'Commands'
    c.frame.log.clearTab(tabName)
    inverseBindingDict = k.computeInverseBindingDict()
    data, n = [], 0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName, [('', ''),])
        for z in dataList:
            pane, key = z
            pane = f"{pane} " if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key', '')
            s1 = pane + key
            s2 = commandName
            n = max(n, len(s1))
            data.append((s1, s2),)
    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n, z1, z2) for z1, z2 in data]
    g.es_print('', ''.join(lines), tabName=tabName)
</t>
<t tx="ekr.20061031131434.122">@cmd('repeat-complex-command')
def repeatComplexCommand(self, event):
    """Repeat the previously executed minibuffer command."""
    k = self
    if k.mb_history:
        k.setState('last-full-command', 1, handler=k.repeatComplexCommandHelper)
        k.setLabelBlue(f"Redo: {str(k.mb_history[0])}")
    else:
        g.warning('no previous minibuffer command')
</t>
<t tx="ekr.20061031131434.123">@cmd('set-command-state')
def setCommandState(self, event):
    """Enter the 'command' editing state."""
    k = self
    k.setInputState('command', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-insert-state')
def setInsertState(self, event):
    """Enter the 'insert' editing state."""
    k = self
    k.setInputState('insert', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-overwrite-state')
def setOverwriteState(self, event):
    """Enter the 'overwrite' editing state."""
    k = self
    k.setInputState('overwrite', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.124">@cmd('toggle-input-state')
def toggleInputState(self, event=None):
    """The toggle-input-state command."""
    k = self; c = k.c
    default = c.config.getString('top-level-unbound-key-action') or 'insert'
    state = k.unboundKeyAction
    if default == 'insert':
        state = 'command' if state == 'insert' else 'insert'
    elif default == 'overwrite':
        state = 'command' if state == 'overwrite' else 'overwrite'
    else:
        state = 'insert' if state == 'command' else 'command'  # prefer insert to overwrite.
    k.setInputState(state)
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.125"></t>
<t tx="ekr.20061031131434.126">def manufactureKeyPressForCommandName(self, w, commandName):
    """
    Implement a command by passing a keypress to the gui.
    
    **Only unit tests use this method.**
    """
    c, k = self.c, self
    stroke = k.getStrokeForCommandName(commandName)
    assert g.isStroke(stroke), (commandName, stroke.__class__.__name__)
    shortcut = stroke.s
    shortcut = g.checkUnicode(shortcut)
    if shortcut and w:
        g.app.gui.set_focus(c, w)
        g.app.gui.event_generate(c, None, shortcut, w)
    else:
        message = f"no shortcut for {commandName}"
        if g.app.unitTesting:
            raise AttributeError(message)
        g.error(message)
</t>
<t tx="ekr.20061031131434.127">def simulateCommand(self, commandName, event=None):
    """Execute a Leo command by name."""
    c = self.c
    if not event:
        # Create a default key event.
        event = g.app.gui.create_key_event(c)
    c.doCommandByName(commandName, event)
</t>
<t tx="ekr.20061031131434.13">@cmd('show-calltips')
def showCalltips(self, event=None, force=False):
    """Show the calltips at the cursor."""
    c, k = self.c, self.c.k
    w = event and event.w
    if not w:
        return
    is_headline = c.widget_name(w).startswith('head')
    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not is_headline:
        self.w = w
        self.calltip()
    else:
        c.insertCharFromEvent(event)
</t>
<t tx="ekr.20061031131434.130">@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True):
    """Clears the state and the minibuffer label."""
    k = self; c = k.c
    if g.app.quitting:
        return
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
    k.resetCommandHistory()
</t>
<t tx="ekr.20061031131434.131">def registerCommand(self, commandName, func,
    allowBinding=False,
    pane='all',
    shortcut=None,  # Must be None unless allowBindings is True.
    ** kwargs
):
    """
    Make the function available as a minibuffer command.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.
    
    Ignore the 'shortcut' arg unless 'allowBinding' is True.
    
    Only k.bindOpenWith and the mod_scripting.py plugin should set
    allowBinding.
    """
    c, k = self.c, self
    if not func:
        g.es_print('Null func passed to k.registerCommand\n', commandName)
        return
    f = c.commandsDict.get(commandName)
    if f and f.__name__ != func.__name__:
        g.trace('redefining', commandName, f, '-&gt;', func)
    c.commandsDict[commandName] = func
    # Warn about deprecated arguments.
    if shortcut and not allowBinding:
        g.es_print('The "shortcut" keyword arg to k.registerCommand will be ignored')
        g.es_print('Called from', g.callers())
        shortcut = None
    for arg, val in kwargs.items():
        if val is not None:
            g.es_print(f'The "{arg}" keyword arg to k.registerCommand is deprecated')
            g.es_print('Called from', g.callers())
    # Make requested bindings, even if a warning has been given.
    # This maintains strict compatibility with existing plugins and scripts.
    k.registerCommandShortcut(
        commandName=commandName,
        func=func,
        pane=pane,
        shortcut=shortcut,
    )
</t>
<t tx="ekr.20061031131434.133">def setInputState(self, state, set_border=False):
    k = self
    k.unboundKeyAction = state
</t>
<t tx="ekr.20061031131434.135"># def minibufferWantsFocus(self):
    # c = self.c
    # c.widgetWantsFocus(c.miniBufferWidget)
</t>
<t tx="ekr.20061031131434.14">@cmd('show-calltips-force')
def showCalltipsForce(self, event=None):
    """Show the calltips at the cursor, even if calltips are not presently enabled."""
    return self.showCalltips(event, force=True)
</t>
<t tx="ekr.20061031131434.145"></t>
<t tx="ekr.20061031131434.146">def masterKeyHandler(self, event):
    """The master key handler for almost all key bindings."""
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    c, k = self.c, self
    # Setup...
    if trace:
        g.trace(repr(k.state.kind), repr(event.char), repr(event.stroke))
    k.checkKeyEvent(event)
    k.setEventWidget(event)
    k.traceVars(event)
    # Order is very important here...
    if k.isSpecialKey(event):
        return
    # Add *all* characters to the lossage.
    k.setLossage(event.char, event.stroke)
    if k.doKeyboardQuit(event):
        return
    if k.doDemo(event):
        return
    if k.doMode(event):
        return
    if k.doVim(event):
        return
    if k.doBinding(event):
        return
    # Handle abbreviations.
    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, event.stroke):
        return
    # Handle the character given by event *without*
    # executing any command that might be bound to it.
    c.insertCharFromEvent(event)
</t>
<t tx="ekr.20061031131434.15">def showAutocompleterStatus(self):
    """Show the autocompleter status."""
    k = self.k
    if not g.unitTesting:
        s = f"autocompleter {'On' if k.enable_autocompleter else 'Off'}"
        g.red(s)

def showCalltipsStatus(self):
    """Show the autocompleter status."""
    k = self.k
    if not g.unitTesting:
        s = f"calltips {'On'}" if k.enable_calltips else 'Off'
        g.red(s)
</t>
<t tx="ekr.20061031131434.152">def handleMiniBindings(self, event, state, stroke):
    """Find and execute commands bound to the event."""
    k = self
    #
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    #
    # Ignore other special keys in the minibuffer.
    if state in ('getArg', 'full-command'):
        if stroke in (
            '\b', 'BackSpace',
            '\r', 'Linefeed',
            '\n', 'Return',
            '\t', 'Tab',
            'Escape',
        ):
            return False
        if k.isFKey(stroke):
            return False
    #
    # Ignore autocompletion state.
    if state.startswith('auto-'):
        return False
    #
    # Ignore plain key binding in the minibuffer.
    if not stroke or k.isPlainKey(stroke):
        return False
    #
    # Get the command, based on the pane.
    for pane in ('mini', 'all', 'text'):
        result = k.handleMinibufferHelper(event, pane, state, stroke)
        assert result in ('continue', 'found', 'ignore')
        if result == 'ignore':
            return False  # Let getArg handle it.
        if result == 'found':
            # Do not call k.keyboardQuit here!
            return True
    #
    # No binding exists.
    return False
</t>
<t tx="ekr.20061031131434.156"></t>
<t tx="ekr.20061031131434.157">def badMode(self, modeName):
    k = self
    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey(f"@mode {modeName} is not defined (or is empty)")
</t>
<t tx="ekr.20061031131434.158">def createModeBindings(self, modeName, d, w):
    """Create mode bindings for the named mode using dictionary d for w, a text widget."""
    k = self; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*', '*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:', commandName, 'Referenced from', modeName)
            continue
        aList = d.get(commandName, [])
        for bi in aList:
            stroke = bi.stroke
            # Important: bi.val is canonicalized.
            if stroke and stroke not in ('None', 'none', None):
                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)
                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName, {})
                d2[stroke] = g.BindingInfo(
                    kind=f"mode&lt;{modeName}&gt;",
                    commandName=commandName,
                    func=func,
                    nextMode=bi.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
</t>
<t tx="ekr.20061031131434.16"></t>
<t tx="ekr.20061031131434.160">def enterNamedMode(self, event, commandName):
    k = self; c = k.c
    modeName = commandName[6:]
    c.inCommand = False  # Allow inner commands in the mode.
    k.generalModeHandler(event, modeName=modeName)
</t>
<t tx="ekr.20061031131434.161">@cmd('exit-named-mode')
def exitNamedMode(self, event=None):
    """Exit an input mode."""
    k = self
    if k.inState():
        k.endMode()
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.163">def initMode(self, event, modeName):

    k = self; c = k.c
    if not modeName:
        g.trace('oops: no modeName')
        return
    d = g.app.config.modeCommandsDict.get('enter-' + modeName)
    if not d:
        self.badMode(modeName)
        return
    k.modeBindingsDict = d
    bi = d.get('*command-prompt*')
    prompt = bi.kind if bi else modeName
    k.inputModeName = modeName
    k.silentMode = False
    aList = d.get('*entry-commands*', [])
    if aList:
        for bi in aList:
            commandName = bi.commandName
            k.simulateCommand(commandName)
            # Careful, the command can kill the commander.
            if g.app.quitting or not c.exists: return
            # New in Leo 4.5: a startup command can immediately transfer to another mode.
            if commandName.startswith('enter-'):
                return
    # Create bindings after we know whether we are in silent mode.
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    k.showStateAndMode(prompt=prompt)
</t>
<t tx="ekr.20061031131434.164">def reinitMode(self, modeName):
    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName + ': ')  # ,protect=True)
</t>
<t tx="ekr.20061031131434.165">@cmd('mode-help')
def modeHelp(self, event):
    """
    The mode-help command.

    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.
    """
    k = self; c = k.c
    c.endEditing()
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-' + k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
</t>
<t tx="ekr.20061031131434.166">def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for bi in aList:
                stroke = bi.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[:-4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', f"{prompt.kind.strip()}\n\n", tabName=tabName)
    else:
        g.es('', f"{modeName} mode\n\n", tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
</t>
<t tx="ekr.20061031131434.176">def computeInverseBindingDict(self):
    k = self
    d = {}
        # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        aList = k.bindingsDict.get(stroke, [])
        for bi in aList:
            shortcutList = k.bindingsDict.get(bi.commandName, [])
                # Bug fix: 2017/03/26.
            bi_list = k.bindingsDict.get(
                stroke, g.BindingInfo(kind='dummy', pane='all'))
                # Important: only bi.pane is required below.
            for bi in bi_list:
                pane = f"{bi.pane}:"
                data = (pane, stroke)
                if data not in shortcutList:
                    shortcutList.append(data)
            d[bi.commandName] = shortcutList
    return d
</t>
<t tx="ekr.20061031131434.179">def getStrokeForCommandName(self, commandName):
    k = self; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke, aList in k.bindingsDict.items():
            for bi in aList:
                if bi.commandName == commandName:
                    return stroke
    return None
</t>
<t tx="ekr.20061031131434.18">def appendTabName(self, word):
    self.setTabName(self.tabName + '.' + word)

def beginTabName(self, word):
    self.setTabName('AutoComplete ' + word)

def clearTabName(self):
    self.setTabName('AutoComplete ')

def popTabName(self):
    s = self.tabName
    i = s.rfind('.', 0, -1)
    if i &gt; -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!

def setTabName(self, s):
    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_', '') or ''
    c.frame.log.clearTab(self.tabName)
</t>
<t tx="ekr.20061031131434.181"></t>
<t tx="ekr.20061031131434.182">def isPlainKey(self, stroke):
    """Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key."""
    if not stroke:
        return False
    if not g.isStroke(stroke):
        # Happens during unit tests.
        stroke = g.KeyStroke(stroke)
    #
    # altgr combos (Alt+Ctrl) are always plain keys
    # g.KeyStroke does not handle this, because it has no "c" ivar.
    #
    if stroke.isAltCtrl() and not self.enable_alt_ctrl_bindings:
        return True
    return stroke.isPlainKey()
</t>
<t tx="ekr.20061031131434.191">def prettyPrintKey(self, stroke, brief=False):

    if not stroke:
        return ''
    if not g.assert_is(stroke, g.KeyStroke):
        return stroke
    return stroke.prettyPrint()
</t>
<t tx="ekr.20061031131434.192">def showStateAndMode(self, w=None, prompt=None, setFocus=True):
    """Show the state and mode at the start of the minibuffer."""
    c, k = self.c, self
    state = k.unboundKeyAction
    mode = k.getStateKind()
    if not g.app.gui:
        return
    if not w:
        if hasattr(g.app.gui, 'set_minibuffer_label'):
            pass  # we don't need w
        else:
            w = g.app.gui.get_focus(c)
            if not w:
                return
    isText = g.isTextWrapper(w)
    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return
    wname = g.app.gui.widget_name(w).lower()
    # Get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree, 'getWrapper'):
            if hasattr(w, 'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2, item=None)
            isText = bool(w)  # A benign hack.
    if mode:
        if mode in ('getArg', 'getFileName', 'full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = f"{mode.capitalize()} Mode"
    elif c.vim_mode and c.vimCommands:
        c.vimCommands.show_status()
        return
    else:
        s = f"{state.capitalize()} State"
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'
    if s:
        k.setLabelBlue(s)
    if w and isText:
        # k.showStateColors(inOutline,w)
        k.showStateCursor(state, w)
    # 2015/07/11: reset the status line.
    if hasattr(c.frame.tree, 'set_status_line'):
        c.frame.tree.set_status_line(c.p)
</t>
<t tx="ekr.20061031131434.193"></t>
<t tx="ekr.20061031131434.194">def clearState(self):
    """Clear the key handler state."""
    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
</t>
<t tx="ekr.20061031131434.195">def getStateHandler(self):
    return self.state.handler
</t>
<t tx="ekr.20061031131434.196">def getState(self, kind):
    k = self
    val = k.state.n if k.state.kind == kind else 0
    return val
</t>
<t tx="ekr.20061031131434.197">def getStateKind(self):
    return self.state.kind
</t>
<t tx="ekr.20061031131434.198">def inState(self, kind=None):
    k = self
    if kind:
        return k.state.kind == kind and k.state.n is not None
    return k.state.kind and k.state.n is not None
</t>
<t tx="ekr.20061031131434.199">def setState(self, kind, n, handler=None):

    k = self
    if kind and n is not None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()
    # k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.20">def calltip(self):
    """Show the calltips for the present prefix.
    ch is '(' if the user has just typed it.
    """
    obj, prefix = self.get_object()
    if obj:
        self.calltip_success(prefix, obj)
    else:
        self.calltip_fail(prefix)
    self.exit()
</t>
<t tx="ekr.20061031131434.28">def compute_completion_list(self):
    """Return the autocompleter completion list."""
    prefix = self.get_autocompleter_prefix()
    key, options = self.get_cached_options(prefix)
    if not options:
        options = self.get_completions(prefix)
    tabList, common_prefix = g.itemsMatchingPrefixInList(
        prefix, options, matchEmptyPrefix=False)
    if not common_prefix:
        tabList, common_prefix = g.itemsMatchingPrefixInList(
            prefix, options, matchEmptyPrefix=True)
    if tabList:
        self.show_completion_list(common_prefix, prefix, tabList)
    return common_prefix, prefix, tabList
</t>
<t tx="ekr.20061031131434.29">def do_backspace(self):
    """Delete the character and recompute the completion list."""
    c, w = self.c, self.w
    c.bodyWantsFocusNow()
    i = w.getInsertPoint()
    if i &lt;= 0:
        self.exit()
        return
    w.delete(i - 1, i)
    w.setInsertPoint(i - 1)
    if i &lt;= 1:
        self.exit()
    else:
        # Update the list. Abort if there is no prefix.
        common_prefix, prefix, tabList = self.compute_completion_list()
        if not prefix:
            self.exit()
</t>
<t tx="ekr.20061031131434.31">def insert_string(self, s, select=False):
    """
    Insert an auto-completion string s at the insertion point.
    
    Leo 6.4. This *part* of auto-completion is no longer undoable.
    """
    c, w = self.c, self.w
    if not g.isTextWrapper(w):
        return
    c.widgetWantsFocusNow(w)
    #
    # Don't make this undoable.
        # oldText = w.getAllText()
        # oldSel = w.getSelectionRange()
        # bunch = u.beforeChangeBody(p)
    i = w.getInsertPoint()
    w.insert(i, s)
    if select:
        j = i + len(s)
        w.setSelectionRange(i, j, insert=j)
    #
    # Don't make this undoable.
        # if 0:
            # u.doTyping(p, 'Typing',
                # oldSel=oldSel,
                # oldText=oldText,
                # newText=w.getAllText(),
                # newInsert=w.getInsertPoint(), 
                # newSel=w.getSelectionRange())
        # else:
            # u.afterChangeBody(p, 'auto-complete', bunch)
    if self.use_qcompleter and self.qw:
        c.widgetWantsFocusNow(self.qw.leo_qc)
</t>
<t tx="ekr.20061031131434.38">def info(self):
    """Show the docstring for the present completion."""
    c = self.c
    obj, prefix = self.get_object()
    c.frame.log.clearTab('Info', wrap='word')
    put = lambda s: self.put('', s, tabName='Info')
    put(prefix)
    try:
        argspec = inspect.getargspec(obj)
        # uses None instead of empty list
        argn = len(argspec.args or [])
        defn = len(argspec.defaults or [])
        put("args:")
        simple_args = argspec.args[: argn - defn]
        if not simple_args:
            put('    (none)')
        else:
            put('    ' + ', '.join(' ' + i for i in simple_args))
        put("keyword args:")
        if not argspec.defaults:
            put('    (none)')
        for i in range(defn):
            arg = argspec.args[-defn + i]
            put(f"    {arg} = {repr(argspec.defaults[i])}")
        if argspec.varargs:
            put("varargs: *" + argspec.varargs)
        if argspec.keywords:
            put("keywords: **" + argspec.keywords)
        put('\n')  # separate docstring
    except TypeError:
        put('\n')  # not a callable
    doc = inspect.getdoc(obj)
    put(doc if doc else "No docstring for " + repr(prefix))
</t>
<t tx="ekr.20061031131434.39">def insert_general_char(self, ch):

    trace = all(z in g.app.debug for z in ('abbrev', 'verbose'))
    k, w = self.k, self.w
    if g.isWordChar(ch):
        if trace: g.trace('ch', repr(ch))
        self.insert_string(ch)
        common_prefix, prefix, aList = self.compute_completion_list()
        if not aList:
            if self.forbid_invalid:
                # Delete the character we just inserted.
                self.do_backspace()
        # @bool auto_tab_complete is deprecated.
        # Auto-completion makes no sense if it is False.
        elif self.auto_tab and len(common_prefix) &gt; len(prefix):
            extend = common_prefix[len(prefix) :]
            ins = w.getInsertPoint()
            if trace: g.trace('extend', repr(extend))
            w.insert(ins, extend)
        return
    if ch == '(' and k.enable_calltips:
        # This calls self.exit if the '(' is valid.
        self.calltip()
    else:
        if trace: g.trace('ch', repr(ch))
        self.insert_string(ch)
        self.exit()
</t>
<t tx="ekr.20061031131434.4">class AutoCompleterClass:
    """A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    """
    @others
</t>
<t tx="ekr.20061031131434.46">def start(self, event):
    """Init the completer and start the state handler."""
    # We don't need to clear this now that we don't use ContextSniffer.
    c = self.c
    if c.config.getBool('use-jedi', default=True):
        self.completionsDict = {}
    if self.use_qcompleter:
        self.init_qcompleter(event)
    else:
        self.init_tabcompleter(event)
</t>
<t tx="ekr.20061031131434.5">def __init__(self, k):
    """Ctor for AutoCompleterClass class."""
    # Ivars...
    self.c = k.c
    self.k = k
    self.force = None
    self.language = None
    self.namespaces = []
        # additional namespaces to search for objects, other code
        # can append namespaces to this to extend scope of search
    self.qw = None
        # The object that supports qcompletion methods.
    self.tabName = None
        # The name of the main completion tab.
    self.verbose = False
        # True: print all members, regardless of how many there are.
    self.w = None
        # The widget that gets focus after autocomplete is done.
    self.warnings = {}
        # Keys are language names.
    # Codewise pre-computes...
    self.codewiseSelfList = []
        # The (global) completions for "self."
    self.completionsDict = {}
        # Keys are prefixes, values are completion lists.
    self.reloadSettings()

def reloadSettings(self):
    c = self.c
    self.auto_tab = c.config.getBool('auto-tab-complete', True)
    self.forbid_invalid = c.config.getBool('forbid-invalid-completions', False)
    self.use_jedi = c.config.getBool('use-jedi', False)
    self.use_qcompleter = c.config.getBool('use-qcompleter', False)
        # True: show results in autocompleter tab.
        # False: show results in a QCompleter widget.
</t>
<t tx="ekr.20061031131434.74">class KeyHandlerClass:
    """
    A class to support emacs-style commands.
    c.k is an instance of this class.
    """
    @others
</t>
<t tx="ekr.20061031131434.75"></t>
<t tx="ekr.20061031131434.76">def __init__(self, c):
    """Create a key handler for c."""
    self.c = c
    self.dispatchEvent = None
    self.fnc = None
        # A singleton defined in k.finishCreate.
    self.getArgInstance = None
        # A singleton defined in k.finishCreate.
    self.inited = False
        # Set at end of finishCreate.
    self.killedBindings = []
        # A list of commands whose bindings have been set to None in the local file.
    self.replace_meta_with_alt = False
        # True: (Mac only) swap Meta and Alt keys.
    self.w = None
        # Note: will be None for NullGui.
    # Generalize...
    self.x_hasNumeric = ['sort-lines', 'sort-fields']
    self.altX_prompt = 'full-command: '
    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke
    # Define all ivars...
    self.defineExternallyVisibleIvars()
    self.defineInternalIvars()
    self.reloadSettings()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None  # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction()
</t>
<t tx="ekr.20061031131434.78">def defineExternallyVisibleIvars(self):

    self.abbrevOn = False  # True: abbreviations are on.
    self.arg = ''  # The value returned by k.getArg.
    self.getArgEscapeFlag = False  # True: the user escaped getArg in an unusual way.
    self.getArgEscapes = []
    self.inputModeName = ''  # The name of the input mode, or None.
    self.modePrompt = ''  # The mode promopt.
    self.state = g.bunch(kind=None, n=None, handler=None)
    
    # Remove ???
    self.givenArgs = []  # Args specified after the command name in k.simulateCommand.
    self.functionTail = None  # For commands that take minibuffer arguments.
</t>
<t tx="ekr.20061031131434.79">def defineInternalIvars(self):
    """Define internal ivars of the KeyHandlerClass class."""
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of BindingInfo objects.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are BindingInfo objects.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None  # New support for the demo.py plugin.
    self.demoPrevKey = None  # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
</t>
<t tx="ekr.20061031131434.8"></t>
<t tx="ekr.20061031131434.80">def finishCreate(self):
    """
    Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.
    """
    c, k = self.c, self
    k.w = c.frame.miniBufferWidget
        # Will be None for NullGui.
    k.fnc = FileNameChooser(c)
        # A singleton. Defined here so that c.k will exist.
    k.getArgInstance = GetArg(c)
        # a singleton. Defined here so that c.k will exist.
    k.makeAllBindings()
        # Important: This must be called this now,
        # even though LM.laod calls g.app.makeAllBindings later.
    k.initCommandHistory()
    k.inited = True
    k.setDefaultInputState()
    k.resetLabel()
</t>
<t tx="ekr.20061031131434.82">def setDefaultUnboundKeyAction(self, allowCommandState=True):
    k = self; c = k.c
    defaultAction = c.config.getString('top-level-unbound-key-action') or 'insert'
    defaultAction.lower()
    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command', 'insert', 'overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace(f"ignoring top_level_unbound_key_action setting: {defaultAction}")
        self.unboundKeyAction = 'insert'
    self.defaultUnboundKeyAction = self.unboundKeyAction
    k.setInputState(self.defaultUnboundKeyAction)
</t>
<t tx="ekr.20061031131434.88"></t>
<t tx="ekr.20061031131434.89">def bindKey(self, pane, shortcut, callback, commandName, modeFlag=False, tag=None):
    """
    Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict
    and k.bindingsDict.

    tag gives the source of the binding.
    
    Return True if the binding was made successfully.
    """
    k = self
    if not shortcut:
        # Don't use this method to undo bindings.
        return False
    if not k.check_bind_key(commandName, pane, shortcut):
        return False
    aList = k.bindingsDict.get(shortcut, [])
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s, stroke
        else:
            assert shortcut, g.callers()
            stroke = g.KeyStroke(binding=shortcut)
        bi = g.BindingInfo(
            kind=tag,
            pane=pane,
            func=callback,
            commandName=commandName,
            stroke=stroke)
        if shortcut:
            k.bindKeyToDict(pane, shortcut, bi)
                # Updates k.masterBindingsDict
        if shortcut and not modeFlag:
            aList = k.remove_conflicting_definitions(
                aList, commandName, pane, shortcut)
            # 2013/03/02: a real bug fix.
        aList.append(bi)
        if shortcut:
            assert stroke
            k.bindingsDict[stroke] = aList
        return True
    except Exception:  # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding', shortcut, 'to', commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey  # For compatibility
</t>
<t tx="ekr.20061031131434.9">@cmd('auto-complete')
def autoComplete(self, event=None, force=False):
    """An event handler for autocompletion."""
    c, k = self.c, self.k
    # pylint: disable=consider-using-ternary
    w = event and event.w or c.get_focus()
    self.force = force
    if k.unboundKeyAction not in ('insert', 'overwrite'):
        return
    if not force:
        # Ctrl-period does *not* insert a period,
        # but plain periods *must* be inserted!
        c.insertCharFromEvent(event)
    if c.exists:
        c.frame.updateStatusLine()
    # Allow autocompletion only in the body pane.
    if not c.widget_name(w).lower().startswith('body'):
        return
    self.language = g.scanForAtLanguage(c, c.p)
    if w and (k.enable_autocompleter or force):
        self.w = w
        self.start(event)
</t>
<t tx="ekr.20061031131434.92">def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):

    k = self
    result = []
    for bi in aList:
        if pane in ('button', 'all', bi.pane):
            k.kill_one_shortcut(shortcut)
        else:
            result.append(bi)
    return result
</t>
<t tx="ekr.20061031131434.93">def bindKeyToDict(self, pane, stroke, bi):
    """Update k.masterBindingsDict for the stroke."""
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = bi
    k.masterBindingsDict[pane] = d
</t>
<t tx="ekr.20061031131434.94">def bindOpenWith(self, d):
    """Register an open-with command."""
    k = self; c = k.c
    shortcut = d.get('shortcut') or ''
    name = d.get('name')
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = f"open-with-{name.lower()}"
    k.registerCommand(
        allowBinding=True,
        commandName=commandName,
        func=openWithCallback,
        pane='all',
        shortcut=shortcut,
    )
</t>
<t tx="ekr.20061031131434.95">def checkBindings(self):
    """
    Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course."""
    k = self; c = k.c
    if not c.config.getBool('warn-about-missing-settings'): return
    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;', '')
        if not c.config.exists(key, 'shortcut'):
            if abbrev:
                g.trace(f"No shortcut for abbrev {name} -&gt; {abbrev} = {key}")
            else:
                g.trace(f"No shortcut for {name} = {key}")
</t>
<t tx="ekr.20061031131434.96">def completeAllBindingsForWidget(self, w):
    """Make all a master gui binding for widget w."""
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
</t>
<t tx="ekr.20061031131434.97">def completeAllBindings(self, w=None):
    """
    Make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.
    """
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
</t>
<t tx="ekr.20061031131434.98">def makeAllBindings(self):
    """Make all key bindings in all of Leo's panes."""
    k = self
    k.bindingsDict = {}
    k.addModeCommands()
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    k.completeAllBindings()
    k.checkBindings()
</t>
<t tx="ekr.20061031131434.99">def initAbbrev(self):
    k = self; c = k.c; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass  # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName, key)
</t>
<t tx="ekr.20061031170011.10">def setLabelBlue(self, label, protect=True):
    """Set the minibuffer label."""
    k, w = self, self.w
    if hasattr(g.app.gui, 'set_minibuffer_label'):
        g.app.gui.set_minibuffer_label(self.c, label)
    elif w:
        w.setStyleClass('')  # normal state, not warning or error
        if label is not None:
            k.setLabel(label, protect=protect)
</t>
<t tx="ekr.20061031170011.11">def setLabelGrey(self, label=None):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_warning')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
</t>
<t tx="ekr.20061031170011.12">def updateLabel(self, event):
    """
    Mimic what would happen with the keyboard and a Text editor
    instead of plain accumulation.
    """
    k = self; c = k.c; w = self.w
    ch = event.char if event else ''
    if ch and ch not in ('\n', '\r'):
        c.widgetWantsFocusNow(w)
        i, j = w.getSelectionRange()
        ins = w.getInsertPoint()
        if i != j:
            w.delete(i, j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) &gt; len(k.mb_prefix):
                w.delete(i - 1)
                i -= 1
        else:
            w.insert(ins, ch)
            i = ins + 1
</t>
<t tx="ekr.20061031170011.13">def getEditableTextRange(self):
    k = self; w = self.w
    s = w.getAllText()
    i = len(k.mb_prefix)
    j = len(s)
    return i, j
</t>
<t tx="ekr.20061031170011.3"># These may be overridden, but this code is now gui-independent.
</t>
<t tx="ekr.20061031170011.5">def getLabel(self, ignorePrompt=False):
    k = self; w = self.w
    if not w: return ''
    s = w.getAllText()
    if ignorePrompt:
        return s[len(k.mb_prefix) :]
    return s or ''
</t>
<t tx="ekr.20061031170011.6">def protectLabel(self):
    k = self; w = self.w
    if not w: return
    k.mb_prefix = w.getAllText()
</t>
<t tx="ekr.20061031170011.7">def resetLabel(self):
    """Reset the minibuffer label."""
    k = self
    c, w = k.c, k.w
    k.setLabelGrey('')
    k.mb_prefix = ''
    if w:
        w.setSelectionRange(0, 0, insert=0)
        state = k.unboundKeyAction
        if c.vim_mode and c.vimCommands:
            c.vimCommands.show_status()
        else:
            k.setLabelBlue(label=f"{state.capitalize()} State")
</t>
<t tx="ekr.20061031170011.8">def setLabel(self, s, protect=False):
    """Set the label of the minibuffer."""
    c, k, w = self.c, self, self.w
    if w:
        # Support for the curses gui.
        if hasattr(g.app.gui, 'set_minibuffer_label'):
            g.app.gui.set_minibuffer_label(c, s)
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n, n, insert=n)
        if protect:
            k.mb_prefix = s
</t>
<t tx="ekr.20061031170011.9">def extendLabel(self, s, select=False, protect=False):

    k = self; c = k.c; w = self.w
    if not (w and s):
        return
    c.widgetWantsFocusNow(w)
    w.insert('end', s)
    if select:
        i, j = k.getEditableTextRange()
        w.setSelectionRange(i, j, insert=j)
    if protect:
        k.protectLabel()
</t>
<t tx="ekr.20061101071425">def oops(self):

    g.trace('Should be defined in subclass:', g.callers(4))
</t>
<t tx="ekr.20070115135502">def writeScriptFile(self, script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script-file-path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = g.os_path_finalize_join(*allParts)  # #1431
    else:
        path = g.os_path_finalize_join(g.app.homeLeoDir, 'scriptFile.py')  # #1431
    #
    # Write the file.
    try:
        with open(path, encoding='utf-8', mode='w') as f:
            f.write(script)
    except Exception:
        g.es_exception()
        g.es(f"Failed to write script to {path}")
        # g.es("Check your configuration of script_file_path, currently %s" %
            # c.config.getString('script-file-path'))
        path = None
    return path
</t>
<t tx="ekr.20070130115927.6">@cmd('cut-text')
def cutText(self, event=None):
    """Invoked from the mini-buffer and from shortcuts."""
    f = self; c = f.c; w = event and event.widget
    if not w or not g.isTextWrapper(w):
        return
    name = c.widget_name(w)
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    i, j = w.getSelectionRange()
    # Update the widget and set the clipboard text.
    s = w.get(i, j)
    if i != j:
        w.delete(i, j)
        w.see(i)  # 2016/01/19: important
        g.app.gui.replaceClipboardWith(s)
    else:
        ins = w.getInsertPoint()
        i, j = g.getLine(oldText, ins)
        s = w.get(i, j)
        w.delete(i, j)
        w.see(i)  # 2016/01/19: important
        g.app.gui.replaceClipboardWith(s)
    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut', oldSel=oldSel)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s = w.getAllText()
        # 2011/11/14: Not used at present.
        # width = f.tree.headWidth(p=None,s=s)
        # w.setWidth(width)
    else: pass

OnCutFromMenu = cutText
</t>
<t tx="ekr.20070130115927.7">@cmd('paste-text')
def pasteText(self, event=None, middleButton=False):
    """
    Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.
    """
    c = self.c
    w = event and event.widget
    wname = c.widget_name(w)
    if not w or not g.isTextWrapper(w):
        return
    if self.cursorStay and wname.startswith('body'):
        tCurPosition = w.getInsertPoint()
    i, j = oldSel = w.getSelectionRange()
        # Returns insert point if no selection.
    if middleButton and c.k.previousSelection is not None:
        start, end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = g.app.gui.getTextFromClipboard()
    s = g.checkUnicode(s)
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s[-1] in ('\n', '\r'):
            s = s[:-1]
    # Save the horizontal scroll position.
    if hasattr(w, 'getXScrollPosition'):
        x_pos = w.getXScrollPosition()
    # Update the widget.
    if i != j:
        w.delete(i, j)
    w.insert(i, s)
    w.see(i + len(s) + 2)
    if wname.startswith('body'):
        if self.cursorStay:
            if tCurPosition == j:
                offset = len(s) - (j - i)
            else:
                offset = 0
            newCurPosition = tCurPosition + offset
            w.setSelectionRange(i=newCurPosition, j=newCurPosition)
        c.frame.body.onBodyChanged('Paste', oldSel=oldSel)
    elif singleLine:
        s = w.getAllText()
        while s and s[-1] in ('\n', '\r'):
            s = s[:-1]
        # 2011/11/14: headline width methods do nothing at present.
        # if wname.startswith('head'):
            # The headline is not officially changed yet.
            # p.initHeadString(s)
            # width = f.tree.headWidth(p=None,s=s)
            # w.setWidth(width)
    else:
        pass
    # Never scroll horizontally.
    if hasattr(w, 'getXScrollPosition'):
        w.setXScrollPosition(x_pos)

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20070218130238">def dumpMasterBindingsDict(self):
    """Dump k.masterBindingsDict."""
    k = self; d = k.masterBindingsDict
    g.pr('\nk.masterBindingsDict...\n')
    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            bi = d2.get(key2)
            g.pr(f"{key2:20} {bi.commandName}")
</t>
<t tx="ekr.20070227093629.1">try:
    # #1472: Simplify import of g
    from leo.core import leoGlobals as g
    self.g = g
except ImportError:
    print("Error importing leoGlobals.py")
#
# Create the application object.
try:
    g.in_bridge = True
        # Tell leoApp.createDefaultGui not to create a gui.
        # This module will create the gui later.
    from leo.core import leoApp
    g.app = leoApp.LeoApp()
except ImportError:
    print("Error importing leoApp.py")
g.app.leoID = None
if self.tracePlugins:
    g.app.debug.append('plugins')
g.app.silentMode = self.silentMode
#
# Create the g.app.pluginsController here.
from leo.core import leoPlugins
leoPlugins.init()  # Necessary. Sets g.app.pluginsController.
try:
    from leo.core import leoNodes
except ImportError:
    print("Error importing leoNodes.py")
    import traceback; traceback.print_exc()
try:
    from leo.core import leoConfig
except ImportError:
    print("Error importing leoConfig.py")
    import traceback; traceback.print_exc()
</t>
<t tx="ekr.20070302061713">def adjustSysPath(self):
    """Adjust sys.path to enable imports as usual with Leo."""
    import sys
    g = self.g
    leoDirs = (
        'config', 'doc', 'extensions', 'modes', 'plugins', 'core', 'test')  # 2008/7/30
    for theDir in leoDirs:
        path = g.os_path_finalize_join(g.app.loadDir, '..', theDir)
        if path not in sys.path:
            sys.path.append(path)
    # #258: leoBridge does not work with @auto-md subtrees.
    for theDir in ('importers', 'writers'):
        path = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins', theDir)
        if path not in sys.path:
            sys.path.append(path)
</t>
<t tx="ekr.20070317085437.2">def __init__(self, c):
    """Ctor for ChapterController class."""
    self.c = c
    self.chaptersDict = {}
        # Keys are chapter names, values are chapters.
        # Important: chapter names never change,
        # even if their @chapter node changes.
    self.initing = True
        # #31
        # True: suppress undo when creating chapters.
    self.re_chapter = None
        # Set where used.
    self.selectedChapter = None
    self.selectChapterLockout = False
        # True: cc.selectChapterForPosition does nothing.
        # Note: Used in qt_frame.py.
    self.tt = None  # May be set in finishCreate.
    self.reloadSettings()

def reloadSettings(self):
    c = self.c
    self.use_tabs = c.config.getBool('use-chapter-tabs')
</t>
<t tx="ekr.20070325104904"># This must be called late in the init process, after the first redraw.

def finishCreate(self):
    """Create the box in the icon area."""
    cc = self
    cc.createIcon()
    cc.setAllChapterNames()
        # Create all chapters.
    # #31.
    cc.initing = False
    cc.selectChapterByName('main', collapse=False)
        # Always select the main chapter.
        # It can be alarming to open a small chapter in a large .leo file.
</t>
<t tx="ekr.20070413061552">def putSavedMessage(self, fileName):
    c = self.c
    # #531: Optionally report timestamp...
    if c.config.getBool('log-show-save-time', default=False):
        format = c.config.getString('log-timestamp-format') or "%H:%M:%S"
        timestamp = time.strftime(format) + ' '
    else:
        timestamp = ''
    zipMark = '[zipped] ' if c.isZipped else ''
    g.es(f"{timestamp} saved: {zipMark}{g.shortFileName(fileName)}")
</t>
<t tx="ekr.20070613133500">def menuCommandKey(self, event=None):
    # This method must exist, but it never gets called.
    pass
</t>
<t tx="ekr.20070713075352">def scanUnknownFileType(self, s, p, ext):
    """Scan the text of an unknown file type."""
    body = ''
    if ext in ('.html', '.htm'): body += '@language html\n'
    elif ext in ('.txt', '.text'): body += '@nocolor\n'
    else:
        language = self.languageForExtension(ext)
        if language: body += f"@language {language}\n"
    self.setBodyString(p, body + self.rootLine + s)
    for p in p.self_and_subtree():
        p.clearDirty()
    g.app.unitTestDict = {'result': True}
    return True
</t>
<t tx="ekr.20070806141607">def writeOneAtAutoNode(self, p):
    '''
    Write p, an @auto node.
    File indices *must* have already been assigned.
    Return True if the node was written successfully.
    '''
    at, c = self, self.c
    root = p.copy()
    try:
        c.endEditing()
        if not p.atAutoNodeName():
            return False
        fileName = at.initWriteIvars(root, p.atAutoNodeName(),
            defaultDirectory=g.setDefaultDirectory(c, p, importing=True),
            sentinels=False,
        )
        # #1450.
        if not fileName or not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return False
        if c.persistenceController:
            c.persistenceController.update_before_write_foreign_file(root)
        contents = at.writeAtAutoContents(fileName, root)
        if contents is None:
            g.es("not written:", fileName)
            at.addToOrphanList(root)
            return False
        at.replaceFile(contents, at.encoding, fileName, root,
            ignoreBlankLines=root.isAtAutoRstNode())
        return True
    except Exception:
        at.writeException(fileName, root)
        return False
</t>
<t tx="ekr.20070909100252">def readOneAtAutoNode(self, fileName, p):
    '''Read an @auto file into p. Return the *new* position.'''
    at, c, ic = self, self.c, self.c.importCommands
    # #1521 &amp; #1341.
    fileName = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fileName)
    if not g.os_path_exists(fileName):
        g.error(f"not found: {p.h!r}", nodeLink=p.get_UNL(with_proto=True))
        return p
    # Remember that we have seen the @auto node.
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName, p)
    # if not g.unitTesting: g.es("reading:", p.h)
    try:
        # For #451: return p.
        old_p = p.copy()
        at.scanAllDirectives(
            p,
            forcePythonSentinels=False,
            importing=True,
            reading=True,
        )
        p.v.b = ''  # Required for @auto API checks.
        p.v._deleteAllChildren()
        p = ic.createOutline(fileName, parent=p.copy())
        # Do *not* select a postion here.
        # That would improperly expand nodes.
            # c.selectPosition(p)
    except Exception:
        p = old_p
        ic.errors += 1
        g.es_print('Unexpected exception importing', fileName)
        g.es_exception()
    if ic.errors:
        g.error(f"errors inhibited read @auto {fileName}")
    elif c.persistenceController:
        c.persistenceController.update_after_read_foreign_file(p)
    # Finish.
    if ic.errors or not g.os_path_exists(fileName):
        p.clearDirty()
    else:
        g.doHook('after-auto', c=c, p=p)
    return p
</t>
<t tx="ekr.20070926141716">def doItems(self, p, aList):

    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        self.debug_count += 1
        h = p.h
        for tag in ('@menu', '@item', '@ifplatform'):
            if g.match_word(h, 0, tag):
                itemName = h[len(tag) :].strip()
                if itemName:
                    lines = [z for z in g.splitLines(p.b) if
                        z.strip() and not z.strip().startswith('#')]
                    body = lines[0].strip() if lines else ''
                        # Only the first body line is significant.
                        # This allows following comment lines.
                    if tag == '@menu':
                        aList2 = []
                        kind = f"{tag} {itemName}"
                        self.doItems(p, aList2)
                        aList.append((kind, aList2, body),)
                            # #848: Body was None.
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        # Wrong: we must not clean non-unicode characters!
                            # # Fix #1117: Similar to cleanButtonText in mod_scripting.py.
                            # s = ''.join([ch if ch in chars else '' for ch in g.toUnicode(head)])
                            # head2 = s.replace('--', '-').lower()
                            # aList.append((kind, head2, body),)
                        aList.append((kind, head, body),)
                        p.moveToThreadNext()
                        break
        else:
            p.moveToThreadNext()
</t>
<t tx="ekr.20071015110830">def initCodeBlockString(self,p):

    # New in Leo 4.4.4: do this here, not in initWrite:
    c = self.c
    d = c.scanAllDirectives(p)
    language = d.get('language')
    if language is None:
        language = 'python'
    else:
        language = language.lower()
    syntax = SilverCity is not None
    s = self.getOption('code_block_string')
    if s:
        self.code_block_string = s.replace('\\n','\n')
    elif syntax and language in ('python','ruby','perl','c'):
        self.code_block_string = '**code**:\n\n.. code-block:: %s\n' % language.title()
    else:
        self.code_block_string = '**code**:\n\n.. class:: code\n..\n\n::\n'
</t>
<t tx="ekr.20071113084440"># These plugins are for testing Leo's own plugin loading logic.
# There is no reason ever to enable these plugins.</t>
<t tx="ekr.20071115061253">def writePreformat (self,p):

    '''Write p's body text lines as if preformatted.

     ::

        line 1
        line 2 etc.
    '''
    lines = p.b.split('\n')
    lines = [' '*4 + z for z in lines]
    lines.insert(0,'::\n')
    s = '\n'.join(lines)
    if s.strip():
        self.write('%s\n\n' % s)
</t>
<t tx="ekr.20071212104050">def overrideCommand(self, commandName, func):
    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            bi = d2.get(key2)
            if bi.commandName == commandName:
                bi.func = func
                d2[key2] = bi
</t>
<t tx="ekr.20080408060320.790">def selectAll(self):
    """Select all the user-editable text of the minibuffer."""
    w = self.w
    i, j = self.getEditableTextRange()
    w.setSelectionRange(i, j, insert=j)
</t>
<t tx="ekr.20080408060320.791">def killLine(self, protect=True):
    k = self
    w = k.w
    s = w.getAllText()
    s = s[: len(k.mb_prefix)]
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n, n, insert=n)
    if protect:
        k.mb_prefix = s
</t>
<t tx="ekr.20080412053100.5">@language rest
</t>
<t tx="ekr.20080416161551.196">def isVisible(self, c):
    """Return True if p is visible in c's outline."""
    p = self

    def visible(p, root=None):
        for parent in p.parents(copy=False):
            if parent and parent == root:
                # #12.
                return True
            if not c.shouldBeExpanded(parent):
                return False
        return True

    if c.hoistStack:
        root = c.hoistStack[-1].p
        if p == root:
            # #12.
            return True
        return root.isAncestorOf(p) and visible(p, root=root)
    for root in c.rootPosition().self_and_siblings(copy=False):
        if root == p or root.isAncestorOf(p):
            return visible(p)
    return False
</t>
<t tx="ekr.20080509064108.6">def defineSingleLineCommands(self):
    k = self
    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home',  # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
            # 'negative-argument',
            # 'number-command',
            # 'number-command-0',
            # 'number-command-1',
            # 'number-command-2',
            # 'number-command-3',
            # 'number-command-4',
            # 'number-command-5',
            # 'number-command-6',
            # 'number-command-7',
            # 'number-command-8',
            # 'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere',  # 2011/06/07
        'set-find-node-only',  # 2011/06/07
        'set-find-suboutline-only',  # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    ]
</t>
<t tx="ekr.20080509064108.7">def defineMultiLineCommands(self):
    k = self
    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
</t>
<t tx="ekr.20080510153327.2">def setLabelRed(self, label=None, protect=False):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_error')
    if label is not None:
        k.setLabel(label, protect)
</t>
<t tx="ekr.20080511122507.4">def setDefaultInputState(self):
    k = self; state = k.defaultUnboundKeyAction
    k.setInputState(state)
</t>
<t tx="ekr.20080708094444.36">def propagate_changes(self, old_public_file, old_private_file):
    """
    Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)
    """
    x, at = self, self.c.atFileCommands
    at.errors = 0
    self.encoding = at.encoding
    s = at.readFileToUnicode(old_private_file)
        # Sets at.encoding and inits at.readLines.
    old_private_lines = g.splitLines(s or '')  # #1466.
    s = at.readFileToUnicode(old_public_file)
    if at.encoding != self.encoding:
        g.trace(f"can not happen: encoding mismatch: {at.encoding} {self.encoding}")
        at.encoding = self.encoding
    old_public_lines = g.splitLines(s)
    if 0:
        g.trace(f"\nprivate lines...{old_private_file}")
        for s in old_private_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
        g.trace(f"\npublic lines...{old_public_file}")
        for s in old_public_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
    marker = x.markerFromFileLines(old_private_lines, old_private_file)
    new_private_lines = x.propagate_changed_lines(
        old_public_lines, old_private_lines, marker)
    # Important bug fix: Never create the private file here!
    fn = old_private_file
    exists = g.os_path_exists(fn)
    different = new_private_lines != old_private_lines
    copy = exists and different
    # 2010/01/07: check at.errors also.
    if copy and x.errors == 0 and at.errors == 0:
        s = ''.join(new_private_lines)
        x.replaceFileWithString(at.encoding, fn, s)
    return copy
</t>
<t tx="ekr.20080708094444.38">def propagate_changed_lines(
    self, new_public_lines, old_private_lines, marker, p=None):
    &lt;&lt; docstring &gt;&gt;
    x = self
    x.init_ivars(new_public_lines, old_private_lines, marker)
    sm = difflib.SequenceMatcher(None, x.a, x.b)
    # Ensure leading sentinels are put first.
    x.put_sentinels(0)
    x.sentinels[0] = []
    for tag, ai, aj, bi, bj in sm.get_opcodes():
        f = x.dispatch_dict.get(tag, x.op_bad)
        f(tag, ai, aj, bi, bj)
    # Put the trailing sentinels &amp; check the result.
    x.results.extend(x.trailing_sentinels)
    # check_output is likely to be more buggy than the code under test.
    # x.check_output()
    return x.results
</t>
<t tx="ekr.20080708094444.40">def init_ivars(self, new_public_lines, old_private_lines, marker):
    """Init all ivars used by propagate_changed_lines &amp; its helpers."""
    x = self
    x.delim1, x.delim2 = marker.getDelims()
    x.marker = marker
    x.old_sent_lines = old_private_lines
    x.results = []
    x.verbatim_line = f"{x.delim1}@verbatim{x.delim2}\n"
    old_public_lines = x.init_data()
    x.b = x.preprocess(new_public_lines)
    x.a = x.preprocess(old_public_lines)
</t>
<t tx="ekr.20080710101653.1"># see: http://www.diveintopython.org/xml_processing/unicode.html

def pr(*args, **keys):
    """
    Print all non-keyword args. This is a wrapper for the print statement.

    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    """
    # Compute the effective args.
    d = {'commas': False, 'newline': True, 'spaces': True}
    d = doKeywordArgs(keys, d)
    newline = d.get('newline')
    stdout = sys.stdout if sys.stdout and g.unitTesting else sys.__stdout__
        # Unit tests require sys.stdout.
    if not stdout:
        # #541.
        return
    if sys.platform.lower().startswith('win'):
        encoding = 'ascii'  # 2011/11/9.
    elif getattr(stdout, 'encoding', None):
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = stdout.encoding
    else:
        encoding = 'utf-8'
    s = translateArgs(args, d)
        # Translates everything to unicode.
    s = g.toUnicode(s, encoding=encoding, reportErrors=False)
    if newline:
        s += '\n'
    #
    # Python's print statement *can* handle unicode, but
    # sitecustomize.py must have sys.setdefaultencoding('utf-8')
    try:
        # #783: print-* commands fail under pythonw.
        stdout.write(s)
    except Exception:
        pass
</t>
<t tx="ekr.20080711093251.7">def readOneAtShadowNode(self, fn, p, force=False):

    at = self; c = at.c; x = c.shadowController
    if not fn == p.atShadowFileNodeName():
        at.error(
            f"can not happen: fn: {fn} != atShadowNodeName: "
            f"{p.atShadowFileNodeName()}")
        return
    # #1521 &amp; #1341.
    fn = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fn)
    # #889175: Remember the full fileName.
    at.rememberReadPath(fn, p)
    shadow_fn = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    if shadow_exists:
        at.read(p, atShadow=True, force=force)
    else:
        ok = at.importAtShadowNode(fn, p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p)
</t>
<t tx="ekr.20080712080505.1">def importAtShadowNode(self, fn, p):
    at = self; c = at.c; ic = c.importCommands
    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()
    # Import the outline, exactly as @auto does.
    ic.createOutline(fn, parent=p.copy(), atShadow=True)
    if ic.errors:
        g.error('errors inhibited read @shadow', fn)
    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
    # else: g.doHook('after-shadow', p = p)
    return ic.errors == 0
</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20080811174246.1">def languageForExtension(self, ext):
    """Return the language corresponding to the extension ext."""
    unknown = 'unknown_language'
    if ext.startswith('.'): ext = ext[1:]
    if ext:
        z = g.app.extra_extension_dict.get(ext)
        if z not in (None, 'none', 'None'):
            language = z
        else:
            language = g.app.extension_dict.get(ext)
        if language in (None, 'none', 'None'):
            language = unknown
    else:
        language = unknown
    # Return the language even if there is no colorizer mode for it.
    return language
</t>
<t tx="ekr.20080828103146.15">def scanAtPathDirectives(self, aList):
    """
    Scan aList for @path directives.
    Return a reasonable default if no @path directive is found.
    """
    c = self
    c.scanAtPathDirectivesCount += 1  # An important statistic.
    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":
            base = g.app.loadDir
        elif base and base == ".":
            base = c.openDirectory
    base = c.expand_path_expression(base)  # #1341:
    absbase = g.os_path_finalize_join(g.app.loadDir, base)  # #1341:
    # Step 2: look for @path directives.
    paths = []
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        warning = d.get('@path_in_body')
        if path is not None:  # retain empty paths for warnings.
            # Convert "path" or &lt;path&gt; to path.
            path = g.stripPathCruft(path)
            if path and not warning:
                path = c.expand_path_expression(path)  # #1341.
                paths.append(path)
            # We will silently ignore empty @path directives.
    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()
    # Step 3: Compute the full, effective, absolute path.
    path = g.os_path_finalize_join(*paths)  # #1341.
    return path or g.getBaseDirectory(c)
        # 2010/10/22: A useful default.
</t>
<t tx="ekr.20080921060401.14">def os_path_finalize(path):
    """
    Expand '~', then return os.path.normpath, os.path.abspath of the path.
    There is no corresponding os.path method
    """
    path = path.replace('\x00', '')  # Fix Pytyon 3 bug on Windows 10.
    path = os.path.expanduser(path)  # #1383.
    path = os.path.abspath(path)
    path = os.path.normpath(path)
    if g.isWindows:
        path = path.replace('\\', '/')
    # calling os.path.realpath here would cause problems in some situations.
    return path
</t>
<t tx="ekr.20080921091311.1">import os
import sys
# Partial fix for #541.
# See https://stackoverflow.com/questions/24835155/
if sys.executable.endswith("pythonw.exe"):
    sys.stdout = open(os.devnull, "w");
    sys.stderr = open(
        os.path.join(os.getenv("TEMP"),
        "stderr-" + os.path.basename(sys.argv[0])),
        "w")
path = os.getcwd()
if path not in sys.path:
    # print('appending %s to sys.path' % path)
    sys.path.append(path)
try:
    # #1472: bind to g immediately.
    from leo.core import leoGlobals as g
    from leo.core import leoApp
    g.app = leoApp.LeoApp()
except Exception as e:
    print(e)
    msg = "\n*** Leo could not be started ***"
    msg += "\nPlease verify you've installed the required dependencies:"
    msg += "\nhttps://leoeditor.com/installing.html"
    sys.exit(msg)
</t>
<t tx="ekr.20081006100835.1"># Not used in Leo's core.
# Used by the UNl plugin.  Does not need to create a path.

def getNodePath(self, p):
    """Return the path in effect at node p."""
    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path

# Not used in Leo's core.

def getNodeFileName(self, p):
    """
    Return the full file name at node p,
    including effects of all @path directives.
    Return None if p is no kind of @file node.
    """
    c = self
    path = g.scanAllAtPathDirectives(c, p)
    name = ''
    for p in p.self_and_parents(copy=False):
        name = p.anyAtFileNodeName()
        if name: break
    if name:
        # The commander method supports {{expr}}; the global function does not.
        path = c.expand_path_expression(path)  # #1341.
        name = c.expand_path_expression(name)  # #1341.
        name = g.os_path_finalize_join(path, name)
    return name
</t>
<t tx="ekr.20090110073010.1">@cmd('redraw')
def redraw_command(self, event):
    c = event.get('c')
    if c:
        c.redraw()

def redraw(self, p=None):
    """Redraw the screen immediately."""
    c = self
    # New in Leo 5.6: clear the redraw request.
    c.requestLaterRedraw = False
    if not p:
        p = c.p or c.rootPosition()
    if not p:
        return
    c.expandAllAncestors(p)
    if p:
        # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1183855
        # This looks redundant, but it is probably the only safe fix.
        c.frame.tree.select(p)
    # tree.redraw will change the position if p is a hoisted @chapter node.
    p2 = c.frame.tree.redraw(p)
    # Be careful.  NullTree.redraw returns None.
    # #503: NullTree.redraw(p) now returns p.
    c.selectPosition(p2 or p)
    # Do not call treeFocusHelper here.
        # c.treeFocusHelper()
    # Clear the redraw request, again.
    c.requestLaterRedraw = False

# Compatibility with old scripts

force_redraw = redraw
redraw_now = redraw
</t>
<t tx="ekr.20090122201952.4">def appendStringToBody(self, p, s):
    """Similar to c.appendStringToBody,
    but does not recolor the text or redraw the screen."""
    if s:
        p.b = p.b + g.toUnicode(s, self.encoding)

def setBodyString(self, p, s):
    """
    Similar to c.setBodyString, but does not recolor the text or
    redraw the screen.
    """
    c, v = self.c, p.v
    if not c or not p:
        return
    s = g.toUnicode(s, self.encoding)
    if c.p and p.v == c.p.v:
        w = c.frame.body.wrapper
        i = len(s)
        w.setAllText(s)
        w.setSelectionRange(i, i, insert=i)
    # Keep the body text up-to-date.
    if v.b != s:
        v.setBodyString(s)
        v.setSelection(0, 0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged()
</t>
<t tx="ekr.20090128083459.74"></t>
<t tx="ekr.20090128083459.75">def __get_b(self):
    """Return the body text of a position."""
    p = self
    return p.bodyString()

def __set_b(self, val):
    """
    Set the body text of a position.

    **Warning: the p.b = whatever is *expensive* because it calls
    c.setBodyString().

    Usually, code *should* use this setter, despite its cost, because it
    update's Leo's outline pane properly. Calling c.redraw() is *not*
    enough.

    This performance gotcha becomes important for repetitive commands, like
    cff, replace-all and recursive import. In such situations, code should
    use p.v.b instead of p.b.
    """
    p = self
    c = p.v and p.v.context
    if c:
        c.setBodyString(p, val)
        # Warning: c.setBodyString is *expensive*.

b = property(
    __get_b, __set_b,
    doc="position body string property")
</t>
<t tx="ekr.20090128083459.76">def __get_h(self):
    p = self
    return p.headString()

def __set_h(self, val):
    """
    Set the headline text of a position.

    **Warning: the p.h = whatever is *expensive* because it calls
    c.setHeadString().

    Usually, code *should* use this setter, despite its cost, because it
    update's Leo's outline pane properly. Calling c.redraw() is *not*
    enough.

    This performance gotcha becomes important for repetitive commands, like
    cff, replace-all and recursive import. In such situations, code should
    use p.v.h instead of p.h.
    """
    p = self
    c = p.v and p.v.context
    if c:
        c.setHeadString(p, val)
        # Warning: c.setHeadString is *expensive*.

h = property(
    __get_h, __set_h,
    doc="position property returning the headline string")
</t>
<t tx="ekr.20090202191501.1">def createQtGui(self, fileName='', verbose=False):
    # Do NOT omit fileName param: it is used in plugin code.
    """A convenience routines for plugins to create the Qt gui class."""
    app = self
    try:
        from leo.core.leoQt import Qt
        assert Qt
    except Exception:
        # #1215: Raise an emergency dialog.
        message = 'Can not Import Qt'
        print(message)
        try:
            d = g.EmergencyDialog(title=message, message=message)
            d.run()
        except Exception:
            g.es_exception()
        sys.exit(1)
    try:
        from leo.plugins import qt_gui
    except Exception:
        g.es_exception()
        print('can not import leo.plugins.qt_gui')
        sys.exit(1)
    try:
        from leo.plugins.editpane.editpane import edit_pane_test_open, edit_pane_csv
        g.command('edit-pane-test-open')(edit_pane_test_open)
        g.command('edit-pane-csv')(edit_pane_csv)
    except ImportError:
        print('Failed to import editpane')
    #
    # Complete the initialization.
    qt_gui.init()
    if app.gui and fileName and verbose:
        print(f"Qt Gui created in {fileName}")
</t>
<t tx="ekr.20090214075058.10">def update_directives_pat():
    """Init/update g.directives_pat"""
    global globalDirectiveList, directives_pat
    # Use a pattern that guarantees word matches.
    aList = [
        fr"\b{z}\b" for z in globalDirectiveList if z != 'others'
    ]
    pat = f"^@(%s)" % "|".join(aList)
    directives_pat = re.compile(pat, re.MULTILINE)

# #1688: Initialize g.directives_pat
update_directives_pat()
</t>
<t tx="ekr.20090214075058.6">def findLanguageDirectives(c, p):
    """Return the language in effect at position p."""
    if c is None or p is None:
        return None  # c may be None for testing.
        
    v0 = p.v
        
    def find_language(p_or_v):
        for s in p_or_v.h, p_or_v.b:
            for m in g_language_pat.finditer(s):
                language = m.group(1)
                if g.isValidLanguage(language):
                    return language
        return None

    # First, search up the tree.
    for p in p.self_and_parents(copy=False):
        language = find_language(p)
        if language:
            return language
    # #1625: Second, expand the search for cloned nodes.
    seen = [] # vnodes that have already been searched.
    parents = v0.parents[:] # vnodes whose ancestors are to be searched.
    while parents:
        parent_v = parents.pop()
        if parent_v in seen:
            continue
        seen.append(parent_v)
        language = find_language(parent_v)
        if language:
            return language
        for grand_parent_v in parent_v.parents:
            if grand_parent_v not in seen:
                parents.append(grand_parent_v)
    # Finally, fall back to the defaults.
    return c.target_language.lower() if c.target_language else 'python'
</t>
<t tx="ekr.20090214075058.9"># The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

def get_directives_dict(p, root=None):
    """
    Scan p for Leo directives found in globalDirectiveList.

    Returns a dict containing the stripped remainder of the line
    following the first occurrence of each recognized directive
    """
    if root:
        root_node = root[0]
    d = {}
    #
    # #1688:    legacy: Always compute the pattern.
    #           g.directives_pat is updated whenever loading a plugin.
    #
    # The headline has higher precedence because it is more visible.
    for kind, s in (('head', p.h), ('body', p.b)):
        anIter = g.directives_pat.finditer(s)
        for m in anIter:
            word = m.group(1).strip()
            i = m.start(1)
            if word in d: continue
            j = i + len(word)
            if j &lt; len(s) and s[j] not in ' \t\n':
                continue
                    # Not a valid directive: just ignore it.
                    # A unit test tests that @path:any is invalid.
            k = g.skip_line(s, j)
            val = s[j:k].strip()
            if word in ('root-doc', 'root-code'):
                d['root'] = val  # in addition to optioned version
            d[word] = val
            # New in Leo 5.7.1: @path is allowed in body text.
            # This is very useful when doing recursive imports.
    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"] = 0  # value not immportant
            else:
                g.es(f'{g.angleBrackets("*")} may only occur in a topmost node (i.e., without a parent)')
            break
    return d
</t>
<t tx="ekr.20090215165030.3">def __get_gnx(self):
    p = self
    return p.v.fileIndex

gnx = property(
    __get_gnx,  # __set_gnx,
    doc="position gnx property")
</t>
<t tx="ekr.20090225080846.3">def readOneAtEditNode(self, fn, p):
    at = self
    c = at.c
    ic = c.importCommands
    # #1521
    fn = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fn)
    junk, ext = g.os_path_splitext(fn)
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fn, p)
    # if not g.unitTesting: g.es("reading: @edit %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None: return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    head = ''
    ext = ext.lower()
    if ext in ('.html', '.htm'): head = '@language html\n'
    elif ext in ('.txt', '.text'): head = '@nocolor\n'
    else:
        language = ic.languageForExtension(ext)
        if language and language != 'unknown_language':
            head = f"@language {language}\n"
        else:
            head = '@nocolor\n'
    p.b = head + g.toUnicode(s, encoding=encoding, reportErrors='True')
    g.doHook('after-edit', p=p)
</t>
<t tx="ekr.20090225080846.5">def writeOneAtEditNode(self, p):
    '''Write one @edit node.'''
    at, c = self, self.c
    root = p.copy()
    try:
        c.endEditing()
        c.init_error_dialogs()
        if not p.atEditNodeName():
            return False
        if p.hasChildren():
            g.error('@edit nodes must not have children')
            g.es('To save your work, convert @edit to @auto, @file or @clean')
            return False
        fileName = at.initWriteIvars(root, p.atEditNodeName(),
            atEdit=True,
            defaultDirectory=g.setDefaultDirectory(c, p, importing=True),
            sentinels=False,
        )
        # #1450.
        if not fileName or not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return False
        contents = ''.join([s for s in g.splitLines(p.b)
            if at.directiveKind4(s, 0) == at.noDirective])
        at.replaceFile(contents, at.encoding, fileName, root)
        c.raise_error_dialogs(kind='write')
        return True
    except Exception:
        at.writeException(fileName, root)
        return False
</t>
<t tx="ekr.20090428082801.64">def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    d = {}
    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return d

    args = s.strip()
    if args.find(',') == -1:
        args = [args]
    else:
        args = args.split(',')

    for arg in args:
        data = arg.split('=')
        if len(data) == 1:
            key = data[0]
            d[str(key)] = ""
        elif len(data) == 2:
            key,value = data
            d[str(key)] = str(value)
        else:
            g.error('bad option: %s' % s)
            break

    return d
</t>
<t tx="ekr.20090429055156.63">def runUnitTests(c):

    rstClass(c)
    p = g.findNodeAnywhere(c,'UnitTests')
    if p:
        c.selectPosition(p)
        c.testManager.doTests(all=None, marked=None, verbosity=1)
</t>
<t tx="ekr.20090502071837.65">def writeToDocutils(self, p, s, ext):
    """Send s to docutils using the writer implied by ext and return the result."""
    if not docutils:
        g.error('writeToDocutils: docutils not present')
        return None
    openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding}
    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs(p)
    if ext == '.pdf':
        module = g.import_module('leo.plugins.leo_pdf')
        if not module:
            return None
        writer = module.Writer()  # Get an instance.
        writer_name = None
    else:
        writer = None
        for ext2, writer_name in (
            ('.html', 'html'),
            ('.htm', 'html'),
            ('.tex', 'latex'),
            ('.pdf', 'leo.plugins.leo_pdf'),  # 2011/11/03
            ('.s5', 's5'),  # 2011/03/27
            ('.odt', 'odt'),  # 2011/03/27
        ):
            if ext2 == ext: break
        else:
            g.error(f"unknown docutils extension: {ext}")
            return None
    # SilverCity seems not to be supported, so this warning is strange.
    if False and ext in ('.html', '.htm') and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            if not g.unitTesting:
                g.es('SilverCity not present so no syntax highlighting')
    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption(p, 'stylesheet_path') or ''
    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        openDirectory, rel_stylesheet_path)
    stylesheet_name = self.getOption(p, 'stylesheet_name')
    assert stylesheet_name
    path = g.os_path_finalize_join(stylesheet_path, stylesheet_name)
    if self.getOption(p, 'stylesheet_embed') is False:
        rel_path = g.os_path_join(
            rel_stylesheet_path, self.getOption(p, 'stylesheet_name'))
        rel_path = rel_path.replace('\\', '/')  # 2010/01/28
        overrides['stylesheet'] = rel_path
        overrides['stylesheet_path'] = None
        overrides['embed_stylesheet'] = None
    elif g.os_path_exists(path):
        if ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.error(f"stylesheet not found: {path}")
    else:
        g.error('stylesheet not found\n', path)
        if self.path: g.es_print('@path:', self.path)
        g.es_print('open path:', openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        result = None  # Ensure that result is defined.
        # #1454: This call may print a -Wd warning:
            # site-packages\docutils\io.py:245:
            # DeprecationWarning: 'U' mode is deprecated
            #
            # The actual culprit is 'rU' mode at line 207.
        result = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer=writer,
                writer_name=writer_name,
                settings_overrides=overrides)
        if isinstance(result, bytes):
            result = g.toUnicode(result)
    except docutils.ApplicationError as error:
        # g.error('Docutils error (%s):' % (error.__class__.__name__))
        g.error('Docutils error:')
        g.blue(error)
    except Exception:
        g.es_print('Unexpected docutils exception')
        g.es_exception()
    return result
</t>
<t tx="ekr.20090502071837.66">def handleMissingStyleSheetArgs(self, p, s=None):
    """
    Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.
    """
    force = False
    if force:
        # See http://docutils.sourceforge.net/docs/user/config.html#documentclass
        return {
            'documentclass': 'report', 'documentoptions': 'english,12pt,lettersize'}
    if not s:
        s = self.getOption(p, 'publish_argv_for_missing_stylesheets')
    if not s:
        return {}
    # Handle argument lists such as this:
    # --language=en,--documentclass=report,--documentoptions=[english,12pt,lettersize]
    d = {}
    while s:
        s = s.strip()
        if not s.startswith('--'): break
        s = s[2:].strip()
        eq = s.find('=')
        cm = s.find(',')
        if eq == -1 or (-1 &lt; cm &lt; eq):  # key[nl] or key,
            val = ''
            cm = s.find(',')
            if cm == -1:
                key = s.strip()
                s = ''
            else:
                key = s[:cm].strip()
                s = s[cm + 1 :].strip()
        else:  # key = val
            key = s[:eq].strip()
            s = s[eq + 1 :].strip()
            if s.startswith('['):  # [...]
                rb = s.find(']')
                if rb == -1: break  # Bad argument.
                val = s[: rb + 1]
                s = s[rb + 1 :].strip()
                if s.startswith(','):
                    s = s[1:].strip()
            else:  # val[nl] or val,
                cm = s.find(',')
                if cm == -1:
                    val = s
                    s = ''
                else:
                    val = s[:cm].strip()
                    s = s[cm + 1 :].strip()
        if not key:
            break
        if not val.strip(): val = '1'
        d[str(key)] = str(val)
    return d
</t>
<t tx="ekr.20090514111518.5661">def checkPythonCode(self, contents, fileName, root, pyflakes_errors_only=False):
    """Perform python-related checks on root."""
    at = self
    if contents and fileName and fileName.endswith(
        '.py') and at.checkPythonCodeOnWrite:
        # It's too slow to check each node separately.
        if pyflakes_errors_only:
            ok = True
        else:
            ok = at.checkPythonSyntax(root, contents)
        # Syntax checking catches most indentation problems.
            # if ok: at.tabNannyNode(root,s)
        if ok and at.runPyFlakesOnWrite and not g.unitTesting:
            ok2 = self.runPyflakes(root, pyflakes_errors_only=pyflakes_errors_only)
        else:
            ok2 = True
        if not ok or not ok2:
            g.app.syntax_error_files.append(g.shortFileName(fileName))
</t>
<t tx="ekr.20090514111518.5663">def checkPythonSyntax(self, p, body, supress=False):
    at = self
    try:
        body = body.replace('\r', '')
        fn = f"&lt;node: {p.h}&gt;"
        compile(body + '\n', fn, 'exec')
        return True
    except SyntaxError:
        if not supress:
            at.syntaxError(p, body)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
    return False
</t>
<t tx="ekr.20090514111518.5665">def tabNannyNode(self, p, body, suppress=False):
    import parser
    import tabnanny
    import tokenize
    try:
        readline = g.ReadLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
    except parser.ParserError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("ParserError in", p.h)
        g.es('', str(msg))
    except IndentationError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("IndentationError in", p.h)
        g.es('', str(msg))
    except tokenize.TokenError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("TokenError in", p.h)
        g.es('', str(msg))
    except tabnanny.NannyNag:
        junk, nag, junk = sys.exc_info()
        if suppress:
            raise
        badline = nag.get_lineno()
        line = nag.get_line()
        message = nag.get_msg()
        g.error("indentation error in", p.h, "line", badline)
        g.es(message)
        line2 = repr(str(line))[1:-1]
        g.es("offending line:\n", line2)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        if suppress: raise
</t>
<t tx="ekr.20090514111518.5666">def syntaxError(self, p, body):
    """Report a syntax error."""
    g.error(f"Syntax error in: {p.h}")
    typ, val, tb = sys.exc_info()
    message = hasattr(val, 'message') and val.message
    if message: g.es_print(message)
    if val is None: return
    lines = g.splitLines(body)
    n = val.lineno
    offset = val.offset or 0
    if n is None: return
    i = val.lineno - 1
    for j in range(max(0, i - 2), min(i + 2, len(lines) - 1)):
        if j == i:
            mark = '*'
            node_link = f"{p.get_UNL(with_proto=True, with_count=True)},-{j+1:d}"
        else:
            mark = ' '
            node_link = None
        text = f"{j+1:5}:{mark} {lines[j].rstrip()}"
        g.es_print(text, nodeLink=node_link)
        if j == i:
            g.es_print(' ' * (7 + offset) + '^')
</t>
<t tx="ekr.20090518072506.8494">def isFKey(self, stroke):
    # k = self
    if not stroke: return False
    assert isinstance(stroke, str) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) &lt;= 3 and s[1:].isdigit()
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20091230094319.6240">def getPaneBinding(self, event):

    c, k, state = self.c, self, self.unboundKeyAction
    stroke, w = event.stroke, event.w
    if not g.assert_is(stroke, g.KeyStroke):
        return None
    #
    # #1757: Always insert plain keys in the body.
    #        Valid because mode bindings have already been handled.
    if (
        k.isPlainKey(stroke)
        and w == c.frame.body.widget
        and state in ('insert', 'overwrite')
    ):
        return None
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'),  # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        bi = k.getBindingHelper(key, name, stroke, w)
        if bi:
            return bi
    return None
</t>
<t tx="ekr.20091230094319.6244">def doMode(self, event):
    """
    Handle mode bindings.
    Return True if k.masterKeyHandler should return.
    """
    #
    # #1757: Leo's default vim bindings make heavy use of modes.
    #        Retain these traces!
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    k = self
    state = k.state.kind
    stroke = event.stroke
    if not k.inState():
        return False
    #
    # First, honor minibuffer bindings for all except user modes.
    if state == 'input-shortcut':
        k.handleInputShortcut(event, stroke)
        if trace: g.trace(state, 'k.handleInputShortcut', stroke)
        return True
    if state in (
        'getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'
    ):
        if k.handleMiniBindings(event, state, stroke):
            if trace: g.trace(state, 'k.handleMiniBindings', stroke)
            return True
    #
    # Second, honor general modes.
    #
    if state == 'getArg':
        # New in Leo 5.8: Only call k.getArg for keys it can handle.
        if k.isPlainKey(stroke):
            k.getArg(event, stroke=stroke)
            if trace: g.trace(state, 'k.isPlain: getArg', stroke)
            return True
        if stroke.s in ('Escape', 'Tab', 'BackSpace'):
            k.getArg(event, stroke=stroke)
            if trace: g.trace(state, f"{stroke.s!r}: getArg", stroke)
            return True
        return False
    if state in ('getFileName', 'get-file-name'):
        k.getFileName(event)
        if trace: g.trace(state, 'k.getFileName', stroke)
        return True
    if state in ('full-command', 'auto-complete'):
        val = k.callStateFunction(event)
            # Do the default state action.
            # Calls end-command.
        if val != 'do-standard-keys':
            handler = k.state.handler and k.state.handler.__name__ or '&lt;no handler&gt;'
            if trace: g.trace(state, 'k.callStateFunction:', handler, stroke)
            return True
        return False
    #
    # Third, pass keys to user modes.
    #
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        bi = d.get(stroke)
        if bi:
            # Bound keys continue the mode.
            k.generalModeHandler(event,
                commandName=bi.commandName,
                func=bi.func,
                modeName=state,
                nextMode=bi.nextMode)
            if trace: g.trace(state, 'k.generalModeHandler', stroke)
            return True
        # Unbound keys end mode.
        k.endMode()
        return False
    #
    # Fourth, call the state handler.
    #
    handler = k.getStateHandler()
    if handler:
        handler(event)
    if trace:
        handler_name = handler and handler.__name__ or '&lt;no handler&gt;'
        g.trace(state, 'handler:', handler_name, stroke)
    return True
</t>
<t tx="ekr.20100103093121.5365"># These are experimental plugins.
</t>
<t tx="ekr.20100124110832.6212">def propegateDirtyNodes(self):
    fc = self; c = fc.c
    aList = [z for z in c.all_positions() if z.isDirty()]
    for p in aList:
        p.setAllAncestorAtFileNodesDirty()
</t>
<t tx="ekr.20100205060712.8314">def handleNodeConflicts(self):
    """Create a 'Recovered Nodes' node for each entry in c.nodeConflictList."""
    c = self.c
    if not c.nodeConflictList:
        return None
    if not c.make_node_conflicts_node:
        s = f"suppressed {len(c.nodeConflictList)} node conflicts"
        g.es(s, color='red')
        g.pr('\n' + s + '\n')
        return None
    # Create the 'Recovered Nodes' node.
    last = c.lastTopLevel()
    root = last.insertAfter()
    root.setHeadString('Recovered Nodes')
    root.expand()
    # For each conflict, create one child and two grandchildren.
    for bunch in c.nodeConflictList:
        tag = bunch.get('tag') or ''
        gnx = bunch.get('gnx') or ''
        fn = bunch.get('fileName') or ''
        b1, h1 = bunch.get('b_old'), bunch.get('h_old')
        b2, h2 = bunch.get('b_new'), bunch.get('h_new')
        root_v = bunch.get('root_v') or ''
        child = root.insertAsLastChild()
        h = f'Recovered node "{h1}" from {g.shortFileName(fn)}'
        child.setHeadString(h)
        if b1 == b2:
            lines = [
                'Headline changed...',
                f"{tag} gnx: {gnx} root: {(root_v and root.v)!r}",
                f"old headline: {h1}",
                f"new headline: {h2}",
            ]
            child.setBodyString('\n'.join(lines))
        else:
            line1 = f"{tag} gnx: {gnx} root: {root_v and root.v!r}\nDiff...\n"
            d = difflib.Differ().compare(g.splitLines(b1), g.splitLines(b2))
                # 2017/06/19: reverse comparison order.
            diffLines = [z for z in d]
            lines = [line1]
            lines.extend(diffLines)
            # There is less need to show trailing newlines because
            # we don't report changes involving only trailing newlines.
            child.setBodyString(''.join(lines))
            n1 = child.insertAsNthChild(0)
            n2 = child.insertAsNthChild(1)
            n1.setHeadString('old:' + h1)
            n1.setBodyString(b1)
            n2.setHeadString('new:' + h2)
            n2.setBodyString(b2)
    return root
</t>
<t tx="ekr.20100908125007.6024">def loadOnePlugin(self, moduleOrFileName, tag='open0', verbose=False):
    """
    Load one plugin from a file name or module.
    Use extensive tracing if --trace-plugins is in effect.

    Using a module name allows plugins to be loaded from outside the leo/plugins directory.
    """
    global optional_modules
    trace = 'plugins' in g.app.debug

    def report(message):
        if trace and not g.unitTesting:
            g.es_print(f"loadOnePlugin: {message}")

    # Define local helper functions.
    @others
    if not g.app.enablePlugins:
        report(f"plugins disabled: {moduleOrFileName}")
        return None
    if moduleOrFileName.startswith('@'):
        report(f"ignoring Leo directive: {moduleOrFileName}")
        return None
            # Return None, not False, to keep pylint happy.
            # Allow Leo directives in @enabled-plugins nodes.
    moduleName = self.regularizeName(moduleOrFileName)
    if self.isLoaded(moduleName):
        module = self.loadedModules.get(moduleName)
        return module
    assert g.app.loadDir
    moduleName = g.toUnicode(moduleName)
    #
    # Try to load the plugin.
    try:
        self.loadingModuleNameStack.append(moduleName)
        result = loadOnePluginHelper(moduleName)
    finally:
        self.loadingModuleNameStack.pop()
    if not result:
        if trace:
            reportFailedImport()
        return None
    #
    # Last-minute checks.
    try:
        self.loadingModuleNameStack.append(moduleName)
        result = finishImport(result)
    finally:
        self.loadingModuleNameStack.pop()
    if result:
        # #1688: Plugins can update globalDirectiveList.
        #        Recalculate g.directives_pat.
        g.update_directives_pat()
        report(f"loaded: {moduleName}")
    self.signonModule = result  # for self.plugin_signon.
    return result
</t>
<t tx="ekr.20101004082701.5674"></t>
<t tx="ekr.20101101175644.5891">def put(self, *args, **keys):
    """Put s to the given tab.

    May be overridden in subclasses."""
    # print('autoCompleter.put',args,keys)
    if g.unitTesting:
        pass
    else:
        g.es(*args, **keys)
</t>
<t tx="ekr.20101110150056.9453"># Some of the most important recent plugins work only with the Qt gui.
</t>
<t tx="ekr.20101110150056.9457"></t>
<t tx="ekr.20101112195628.5426"># Must have this signature: called by leoPlugins.callTagHandler.

def update(self, tag, keywords):
    '''Update the vr pane. Called at idle time.'''
    pc = self
    p = pc.c.p
    # #1256.
    if self.locked:
        return
    if pc.must_update(keywords):
        #
        # Suppress updates until we change nodes.
        pc.node_changed = pc.gnx != p.v.gnx
        pc.gnx = p.v.gnx
        pc.length = len(p.b) # not s
        #
        # Remove Leo directives.
        s = keywords.get('s') if 's' in keywords else p.b
        s = pc.remove_directives(s)
        #
        # Use plain text if we are hidden.
        # This avoids annoying messages with rst.
        if pc.isHidden():
            w = pc.ensure_text_widget()
            w.setPlainText(s)
            return
        #
        # Dispatch based on the computed kind.
        kind = keywords.get('flags') if 'flags' in keywords else pc.get_kind(p)
        if not kind:
            # Do *not* try to render plain text.
            w = pc.ensure_text_widget()
            w.setPlainText(s)
            pc.show() # Must be last.
            return
        f = pc.dispatch_dict.get(kind)
        if not f:
            g.trace('no handler for kind: %s' % kind)
            f = pc.update_rst
        f(s, keywords)
    else:
        # Save the scroll position.
        w = pc.w
        if w.__class__ == QtWidgets.QTextBrowser:
            # 2011/07/30: The widget may no longer exist.
            try:
                sb = w.verticalScrollBar()
                pc.scrollbar_pos_dict[p.v] = sb.sliderPosition()
            except Exception:
                g.es_exception()
                pc.deactivate()
</t>
<t tx="ekr.20110202111105.15439">def showStateCursor(self, state, w):
    pass
</t>
<t tx="ekr.20110209093958.15411">def setEditingState(self):
    k = self; state = k.defaultEditingAction
    k.setInputState(state)
</t>
<t tx="ekr.20110209093958.15413">def setDefaultEditingAction(self):
    k = self; c = k.c
    action = c.config.getString('default-editing-state') or 'insert'
    action.lower()
    if action not in ('command', 'insert', 'overwrite'):
        g.trace(f"ignoring default_editing_state: {action}")
        action = 'insert'
    self.defaultEditingAction = action
</t>
<t tx="ekr.20110314115639.14269">def is_leo_source_file(self):
    """Return True if this is one of Leo's source files."""
    c = self.c
    table = (z.lower() for z in (
        'leoDocs.leo',
        'LeoGui.leo', 'LeoGuiPluginsRef.leo',
        # 'leoPlugins.leo', 'leoPluginsRef.leo',
        'leoPy.leo', 'leoPyRef.leo',
        'myLeoSettings.leo', 'leoSettings.leo',
        'ekr.leo',
        # 'test.leo',
    ))
    return c.shortFileName().lower() in table
</t>
<t tx="ekr.20110320120020.14476">def must_update(self, keywords):
    '''Return True if we must update the rendering pane.'''
    pc = self
    c, p = pc.c, pc.c.p
    if g.unitTesting:
        return False
    if keywords.get('force'):
        pc.active = True
        return True
    if c != keywords.get('c') or not pc.active:
        return False
    if pc.locked:
        return False
    if pc.gnx != p.v.gnx:
        return True
    if len(p.b) != pc.length:
        if pc.get_kind(p) in ('html', 'pyplot'):
            pc.length = len(p.b)
            return False # Only update explicitly.
        return True
    # This trace would be called at idle time.
        # g.trace('no change')
    return False
</t>
<t tx="ekr.20110320120020.14477">def update_rst(self, s, keywords):
    '''Update rst in the vr pane.'''
    pc = self
    s = s.strip().strip('"""').strip("'''").strip()
    isHtml = s.startswith('&lt;') and not s.startswith('&lt;&lt;')
    # Do this regardless of whether we show the widget or not.
    w = pc.ensure_text_widget()
    assert pc.w
    if s:
        pc.show()
    if got_docutils:
        # Fix #420: viewrendered does not render some nodes
        # Users (rightly) complained, so don't be clever here:
            # c, p = pc.c, pc.c.p
            # force = keywords.get('force')
            # colorizer = c.frame.body.colorizer
            # language = colorizer.scanLanguageDirectives(p)
            # force or language in ('rst', 'rest', 'markdown', 'md'):
        if not isHtml:
            s = pc.convert_to_html(s)
        pc.set_html(s, w)
    else:
        w.setPlainText(s)
</t>
<t tx="ekr.20110320120020.14479"># http://doc.trolltech.com/4.4/qtsvg.html
# http://doc.trolltech.com/4.4/painting-svgviewer.html
def update_svg(self, s, keywords):
    pc = self
    if pc.must_change_widget(QtSvg.QSvgWidget):
        w = QtSvg.QSvgWidget()
        pc.embed_widget(w)
        assert(w == pc.w)
    else:
        w = pc.w
    if s.strip().startswith('&lt;'):
        # Assume it is the svg (xml) source.
        s = g.adjustTripleString(s, pc.c.tab_width).strip()
            # Sensitive to leading blank lines.
        s = g.toEncodedString(s)
        pc.show()
        w.load(QtCore.QByteArray(s))
        w.show()
    else:
        # Get a filename from the headline or body text.
        ok, path = pc.get_fn(s, '@svg')
        if ok:
            pc.show()
            w.load(path)
            w.show()
</t>
<t tx="ekr.20110320120020.14481">movie_warning = False

def update_movie(self, s, keywords):
    '''Update a movie in the vr pane.'''
    # pylint: disable=maybe-no-member
        # 'PyQt4.phonon' has no 'VideoPlayer' member
        # 'PyQt4.phonon' has no 'VideoCategory' member
        # 'PyQt4.phonon' has no 'MediaSource' member
    pc = self
    ok, path = pc.get_fn(s, '@movie')
    if not ok:
        w = pc.ensure_text_widget()
        w.setPlainText('Not found: %s' % (path))
        return
    if not phonon and not QtMultimedia:
        if not self.movie_warning:
            self.movie_warning = True
            g.es_print('No phonon and no QtMultimedia modules')
        w = pc.ensure_text_widget()
        w.setPlainText('')
        return
    if pc.vp:
        vp = pc.vp
        pc.vp.stop()
        pc.vp.deleteLater()
    # Create a fresh player.
    g.es_print('playing', path)
    if QtMultimedia:
        url= QtCore.QUrl.fromLocalFile(path)
        content= QtMultimedia.QMediaContent(url)
        pc.vp = vp = QtMultimedia.QMediaPlayer()
        vp.setMedia(content)
        # Won't play .mp4 files: https://bugreports.qt.io/browse/QTBUG-32783
        vp.play()
    else:
        pc.vp = vp = phonon.VideoPlayer(phonon.VideoCategory)
        vw = vp.videoWidget()
        vw.setObjectName('video-renderer')
        # Embed the widgets
    
        def delete_callback():
            if pc.vp:
                pc.vp.stop()
                pc.vp.deleteLater()
                pc.vp = None

        pc.embed_widget(vp, delete_callback=delete_callback)
        pc.show()
        vp = pc.vp
        vp.load(phonon.MediaSource(path))
        vp.play()
</t>
<t tx="ekr.20110320120020.14482">def update_image(self, s, keywords):
    '''Update an image in the vr pane.'''
    pc = self
    if not s.strip():
        return
    lines = g.splitLines(s) or []
    fn = lines and lines[0].strip()
    if not fn:
        return
    w = pc.ensure_text_widget()
    ok, path = pc.get_fn(fn, '@image')
    if not ok:
        w.setPlainText('@image: file not found: %s' % (path))
        return
    path = path.replace('\\', '/')
    template = image_template % (path)
    # Only works in Python 3.x.
    template = g.adjustTripleString(template, pc.c.tab_width).strip()
        # Sensitive to leading blank lines.
    # template = g.toUnicode(template)
    pc.show()
    w.setReadOnly(False)
    w.setHtml(template)
    w.setReadOnly(True)
</t>
<t tx="ekr.20110320120020.14483">def get_kind(self, p):
    '''Return the proper rendering kind for node p.'''
    
    def get_language(p):
        """
        Return the language in effect at position p.
        Headline directives over-ride normal Leo directives in body text.
        """
        h = p.h
        # First, look for headline directives.
        if h.startswith('@'):
            i = g.skip_id(h, 1, chars='-')
            word = h[1: i].lower().strip()
            if word in self.dispatch_dict:
                return word
        # Look for @language directives.
        # Warning: (see #344): don't use c.target_language as a default.
        return g.findFirstValidAtLanguageDirective(p.copy())
    #
    #  #1287: Honor both kind of directives node by node.
    for p in p.self_and_parents(p):
        language = get_language(p)
        if got_markdown and language in ('md', 'markdown'):
            return language
        if got_docutils and language in ('rest', 'rst'):
            return language
        if language and language in self.dispatch_dict:
            return language
    return None
</t>
<t tx="ekr.20110320120020.14484">def update_networkx(self, s, keywords):
    '''Update a networkx graphic in the vr pane.'''
    pc = self
    w = pc.ensure_text_widget()
    w.setPlainText('') # 'Networkx: len: %s' % (len(s)))
    pc.show()
</t>
<t tx="ekr.20110320120020.14485">def remove_directives(self, s):
    lines = g.splitLines(s)
    result = []
    for s in lines:
        if s.startswith('@'):
            i = g.skip_id(s, 1)
            word = s[1: i]
            if word in g.globalDirectiveList:
                continue
        result.append(s)
    return ''.join(result)
</t>
<t tx="ekr.20110320120020.14486">def embed_widget(self, w, delete_callback=None):
    '''Embed widget w in the free_layout splitter.'''
    pc = self; c = pc.c #X ; splitter = pc.splitter
    pc.w = w
    layout = self.layout()
    for i in range(layout.count()):
        layout.removeItem(layout.itemAt(0))
    self.layout().addWidget(w)
    w.show()
    # Special inits for text widgets...
    if w.__class__ == QtWidgets.QTextBrowser:
        text_name = 'body-text-renderer'
        w.setObjectName(text_name)
        # Do not do this! It interferes with themes.
            # pc.setBackgroundColor(pc.background_color, text_name, w)
        w.setReadOnly(True)
        # Create the standard Leo bindings.
        wrapper_name = 'rendering-pane-wrapper'
        wrapper = qt_text.QTextEditWrapper(w, wrapper_name, c)
        w.leo_wrapper = wrapper
        c.k.completeAllBindingsForWidget(wrapper)
        w.setWordWrapMode(QtGui.QTextOption.WrapAtWordBoundaryOrAnywhere)
</t>
<t tx="ekr.20110320233639.5776">def get_fn(self, s, tag):
    pc = self
    c = pc.c
    fn = s or c.p.h[len(tag):]
    fn = fn.strip()
    # Similar to code in g.computeFileUrl
    if fn.startswith('~'):
        # Expand '~' and handle Leo expressions.
        fn = fn[1:]
        fn = g.os_path_expanduser(fn)
        fn = c.expand_path_expression(fn)
        fn = g.os_path_finalize(fn)
    else:
        # Handle Leo expressions.
        fn = c.expand_path_expression(fn)
        # Handle ancestor @path directives.
        if c and c.openDirectory:
            base = c.getNodePath(c.p)
            fn = g.os_path_finalize_join(c.openDirectory, base, fn)
        else:
            fn = g.os_path_finalize(fn)
    ok = g.os_path_exists(fn)
    # if not ok: g.trace('not found', fn)
    return ok, fn
</t>
<t tx="ekr.20110321005148.14534">update_html_count = 0

def update_html(self, s, keywords):
    '''Update html in the vr pane.'''
    pc = self
    c = pc.c
    if pc.must_change_widget(BaseTextWidget):
        w = self.create_base_text_widget()
        pc.embed_widget(w)
        assert(w == pc.w)
    else:
        w = pc.w
    if isQt5:
        w.hide() # This forces a proper update.
    w.setHtml(s)
    w.show()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20110321005148.14536">def get_url(self, s, tag):
    p = self.c.p
    url = s or p.h[len(tag):]
    url = url.strip()
    return url
</t>
<t tx="ekr.20110321005148.14537">def update_url(self, s, keywords):
    pc = self
    c, p = self.c, self.c.p
    colorizer = c.frame.body.colorizer
    language = colorizer.scanLanguageDirectives(p)
    if language == 'asciidoc':
        p.update_asciidoc(s, keywords)
    elif language in ('rest', 'rst'):
        pc.update_rst(s, keywords)
    elif language in ('markdown', 'md'):
        pc.update_md(s, keywords)
    elif pc.default_kind in ('rest', 'rst'):
        pc.update_rst(s, keywords)
    elif pc.default_kind in ('markdown', 'md'):
        pc.update_md(s, keywords)
    else:
        # Do nothing.
        g.trace('ignore',s)
        w = pc.ensure_text_widget()
        pc.show()
        w.setPlainText('')
</t>
<t tx="ekr.20110321072702.14510">def setBackgroundColor(self, colorName, name, w):
    '''Set the background color of the vr pane.'''
    if 0: # Do not do this! It interferes with themes.
        pc = self
        if not colorName: return
        styleSheet = 'QTextEdit#%s { background-color: %s; }' % (name, colorName)
        if QtGui.QColor(colorName).isValid():
            w.setStyleSheet(styleSheet)
        elif colorName not in pc.badColors:
            pc.badColors.append(colorName)
            g.warning('invalid body background color: %s' % (colorName))
</t>
<t tx="ekr.20110321151523.14463">def update_graphics_script(self, s, keywords):
    '''Update the graphics script in the vr pane.'''
    pc = self; c = pc.c
    force = keywords.get('force')
    if pc.gs and not force:
        return
    if not pc.gs:
        splitter = c.free_layout.get_top_splitter()
        # Careful: we may be unit testing.
        if not splitter:
            g.trace('no splitter')
            return
        # Create the widgets.
        pc.gs = QtWidgets.QGraphicsScene(splitter)
        pc.gv = QtWidgets.QGraphicsView(pc.gs)
        w = pc.gv.viewport() # A QWidget
        # Embed the widgets.

        def delete_callback():
            for w in (pc.gs, pc.gv):
                w.deleteLater()
            pc.gs = pc.gv = None

        pc.embed_widget(w, delete_callback=delete_callback)
    c.executeScript(
        script=s,
        namespace={'gs': pc.gs, 'gv': pc.gv})
</t>
<t tx="ekr.20110322031455.5763">def must_change_widget(self, widget_class):
    pc = self
    return not pc.w or pc.w.__class__ != widget_class
</t>
<t tx="ekr.20110322031455.5764">def ensure_text_widget(self):
    '''Swap a text widget into the rendering pane if necessary.'''
    c, pc = self.c, self
    if pc.must_change_widget(QtWidgets.QTextBrowser):
        # Instantiate a new QTextBrowser.
        # Allow non-ctrl clicks to open url's.
        w = QtWidgets.QTextBrowser()
        # #1286.
        w.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        w.customContextMenuRequested.connect(self.onContextMenuCallback)

        def handleClick(url, w=w):
            from leo.plugins import qt_text
            wrapper = qt_text.QTextEditWrapper(w, name='vr-body', c=c)
            event = g.Bunch(c=c, w=wrapper)
            g.openUrlOnClick(event, url=url)

        # if self.w and hasattr(self.w, 'anchorClicked'):
            # try:
                # self.w.anchorClicked.disconnect()
            # except Exception:
                # g.es_exception()

        w.anchorClicked.connect(handleClick)
        w.setOpenLinks(False)
        pc.embed_widget(w) # Creates w.wrapper
        assert(w == pc.w)
    return pc.w
</t>
<t tx="ekr.20110322031455.5765"></t>
<t tx="ekr.20110509064011.14556">def attr_matches(self, s, namespace):
    """Compute matches when string s is of the form name.name....name.

    Evaluates s using eval(s,namespace)

    Assuming the text is of the form NAME.NAME....[NAME], and is evaluatable in
    the namespace, it will be evaluated and its attributes (as revealed by
    dir()) are used as possible completions.

    For class instances, class members are are also considered.)

    **Warning**: this can still invoke arbitrary C code, if an object
    with a __getattr__ hook is evaluated.

    """
    # Seems to work great. Catches things like ''.&lt;tab&gt;
    m = re.match(r"(\S+(\.\w+)*)\.(\w*)$", s)
    if not m:
        return []
    expr, attr = m.group(1, 3)
    try:
        safe_expr = self.strip_brackets(expr)
        obj = eval(safe_expr, namespace)
    except Exception:
        return []
    # Build the result.
    words = dir(obj)
    n = len(attr)
    result = [f"{expr}.{w}" for w in words if w[:n] == attr]
    return result
</t>
<t tx="ekr.20110509064011.14557">def get_leo_completions(self, prefix):
    """Return completions in an environment defining c, g and p."""
    aList = []
    for d in self.namespaces + [self.get_leo_namespace(prefix)]:
        aList.extend(self.attr_matches(prefix, d))
    aList.sort()
    return aList
</t>
<t tx="ekr.20110509064011.14561">def get_autocompleter_prefix(self):
    # Only the body pane supports auto-completion.
    w = self.c.frame.body.wrapper
    s = w.getAllText()
    if not s: return ''
    i = w.getInsertPoint() - 1
    i = j = max(0, i)
    while i &gt;= 0 and (s[i].isalnum() or s[i] in '._'):
        i -= 1
    i += 1
    j += 1
    prefix = s[i:j]
    return prefix
</t>
<t tx="ekr.20110510071925.14586">def init_qcompleter(self, event=None):

    # Compute the prefix and the list of options.
    prefix = self.get_autocompleter_prefix()
    options = self.get_completions(prefix)
    w = self.c.frame.body.wrapper.widget
        # A LeoQTextBrowser.  May be none for unit tests.
    if w and options:
        self.qw = w
        self.qcompleter = w.init_completer(options)
        self.auto_completer_state_handler(event)
    else:
        if not g.unitTesting:
            g.warning('No completions')
        self.exit()
</t>
<t tx="ekr.20110510120621.14539">def get_codewise_completions(self, prefix):
    """Use codewise to generate a list of hits."""
    c = self.c
    m = re.match(r"(\S+(\.\w+)*)\.(\w*)$", prefix)
    if m:
        varname = m.group(1)
        ivar = m.group(3)
        kind, aList = self.guess_class(c, varname)
    else:
        kind, aList = 'none', []
        varname, ivar = None, None
    if aList:
        if kind == 'class':
            hits = self.lookup_methods(aList, ivar)
            hits.extend(self.codewiseSelfList)
        elif kind == 'module':
            hits = self.lookup_modules(aList, ivar)
    else:
        aList2 = prefix.split('.')
        if aList2:
            func = aList2[-1]
            hits = self.lookup_functions(func)
        else:
            hits = []
    if 1:  # A kludge: add the prefix to each hit.
        hits = [f"{varname}.{z}" for z in hits]
    return hits
</t>
<t tx="ekr.20110510120621.14540">def clean(self, hits):
    """Clean up hits, a list of ctags patterns, for use in completion lists."""
    # Just take the function name: ignore the signature &amp; file.
    aList = list(set([z[0] for z in hits]))
    aList.sort()
    return aList
</t>
<t tx="ekr.20110510120621.14542">def guess_class(self, c, varname):
    """Return kind, class_list"""
    # if varname == 'g':
        # return 'module',['leoGlobals']
    if varname == 'p':
        return 'class', ['position']
    if varname == 'c':
        return 'class', ['Commands']
    if varname == 'self':
        # Return the nearest enclosing class.
        for p in c.p.parents():
            h = p.h
            m = re.search(r'class\s+(\w+)', h)
            if m:
                return 'class', [m.group(1)]
    if 1:
        aList = []
    else:
        # This is not needed now that we add the completions for 'self'.
        aList = ContextSniffer().get_classes(c.p.b, varname)
    return 'class', aList
</t>
<t tx="ekr.20110510120621.14543">def lookup_functions(self, prefix):
    aList = codewise.cmd_functions([prefix])
    hits = [z.split(None, 1) for z in aList if z.strip()]
    return self.clean(hits)

def lookup_methods(self, aList, prefix):  # prefix not used, only aList[0] used.
    aList = codewise.cmd_members([aList[0]])
    hits = [z.split(None, 1) for z in aList if z.strip()]
    return self.clean(hits)

def lookup_modules(self, aList, prefix):  # prefix not used, only aList[0] used.
    aList = codewise.cmd_functions([aList[0]])
    hits = [z.split(None, 1) for z in aList if z.strip()]
    return self.clean(hits)
</t>
<t tx="ekr.20110510133719.14548">def do_qcompleter_tab(self, prefix, options):
    """Return the longest common prefix of all the options."""
    matches, common_prefix = g.itemsMatchingPrefixInList(
        prefix, options, matchEmptyPrefix=False)
    return common_prefix
</t>
<t tx="ekr.20110511133940.14552">def init_tabcompleter(self, event=None):
    # Compute the prefix and the list of options.
    prefix = self.get_autocompleter_prefix()
    options = self.get_completions(prefix)
    if options:
        self.clearTabName()  # Creates the tabbed pane.
        self.auto_completer_state_handler(event)
    else:
        g.warning('No completions')
        self.exit()
</t>
<t tx="ekr.20110511133940.14561">def show_completion_list(self, common_prefix, prefix, tabList):

    c = self.c
    aList = common_prefix.split('.')
    header = '.'.join(aList[:-1])
    # "!" toggles self.verbose.
    if self.verbose or self.use_qcompleter or len(tabList) &lt; 20:
        tabList = self.clean_completion_list(header, tabList,)
    else:
        tabList = self.get_summary_list(header, tabList)
    if self.use_qcompleter:
        # Put the completions in the QListView.
        if self.qw:
            self.qw.show_completions(tabList)
    else:
        # Update the tab name, creating the tab if necessary.
        c.widgetWantsFocus(self.w)
        c.frame.log.clearTab(self.tabName)
        self.beginTabName(header + '.' if header else '')
        s = '\n'.join(tabList)
        self.put('', s, tabName=self.tabName)
</t>
<t tx="ekr.20110512090917.14466">def get_leo_namespace(self, prefix):
    """
    Return an environment in which to evaluate prefix.
    Add some common standard library modules as needed.
    """
    k = self.k
    d = {'c': k.c, 'p': k.c.p, 'g': g}
    aList = prefix.split('.')
    if len(aList) &gt; 1:
        name = aList[0]
        m = sys.modules.get(name)
        if m:
            d[name] = m
    return d
</t>
<t tx="ekr.20110512090917.14468">def calltip_fail(self, prefix):
    """Evaluation of prefix failed."""
    self.insert_string('(')
</t>
<t tx="ekr.20110512090917.14469">def calltip_success(self, prefix, obj):
    try:
        # Get the parenthesized argument list.
        s1, s2, s3, s4 = inspect.getargspec(obj)
        s = inspect.formatargspec(s1, s2, s3, s4)
    except Exception:
        self.insert_string('(')
        return
    # Clean s and insert it: don't include the opening "(".
    if g.match(s, 1, 'self,'):
        s = s[6:].strip()
    elif g.match_word(s, 1, 'self'):
        s = s[5:].strip()
    else:
        s = s[1:].strip()
    self.insert_string("(", select=False)
    self.insert_string(s, select=True)
</t>
<t tx="ekr.20110512170111.14471">def strip_brackets(self, s):
    """Return s with all brackets removed.

    This (mostly) ensures that eval will not execute function calls, etc.
    """
    for ch in '[]{}()':
        s = s.replace(ch, '')
    return s
</t>
<t tx="ekr.20110512170111.14472">def get_object(self):
    """Return the object corresponding to the current prefix."""
    common_prefix, prefix1, aList = self.compute_completion_list()
    if not aList:
        return None, prefix1
    if len(aList) == 1:
        prefix = aList[0]
    else:
        prefix = common_prefix
    if prefix.endswith('.') and self.use_qcompleter:
        prefix += self.qcompleter.get_selection()
    safe_prefix = self.strip_brackets(prefix)
    for d in self.namespaces + [self.get_leo_namespace(prefix)]:
        try:
            obj = eval(safe_prefix, d)
            break  # only reached if none of the exceptions below occur
        except AttributeError:
            obj = None
        except NameError:
            obj = None
        except SyntaxError:
            obj = None
        except Exception:
            g.es_exception()
            obj = None
    return obj, prefix
</t>
<t tx="ekr.20110512212836.14469">def exit(self):

    trace = all(z in g.app.debug for z in ('abbrev', 'verbose'))
    if trace: g.trace('(AutoCompleterClass)')
    c, p, u = self.c, self.c.p, self.c.undoer
    w = self.w or c.frame.body.wrapper
    c.k.keyboardQuit()
    if self.use_qcompleter:
        if self.qw:
            self.qw.end_completer()
            self.qw = None  # Bug fix: 2013/09/24.
    else:
        for name in (self.tabName, 'Modules', 'Info'):
            c.frame.log.deleteTab(name)
    # Restore the selection range that may have been destroyed by changing tabs.
    c.widgetWantsFocusNow(w)
    i, j = w.getSelectionRange()
    w.setSelectionRange(i, j, insert=j)
    newText = w.getAllText()
    if p.b == newText:
        return
    bunch = u.beforeChangeBody(p)
    p.v.b = newText  # p.b would cause a redraw.
    u.afterChangeBody(p, 'auto-completer', bunch)

finish = exit
abort = exit
</t>
<t tx="ekr.20110512212836.14471">jedi_warning = False

def get_completions(self, prefix):
    """Return jedi or codewise completions."""
    d = self.completionsDict
    if self.use_jedi:
        try:
            import jedi
        except ImportError:
            if not self.jedi_warning:
                self.jedi_warning = False
                g.es_print('can not import jedi')
                g.es_print('ignoring @bool use_jedi = True')
        if jedi:
            aList = (
                self.get_jedi_completions(prefix) or
                    # Prefer the jedi completions.
                self.get_leo_completions(prefix))
            d[prefix] = aList
            return aList
    #
    # Not jedi. Use codewise.
    # Precompute the codewise completions for '.self'.
    if not self.codewiseSelfList:
        aList = self.get_codewise_completions('self.')
        self.codewiseSelfList = [z[5:] for z in aList]
        d['self.'] = self.codewiseSelfList
    # Use the cached list if it exists.
    aList = d.get(prefix)
    if aList:
        return aList
    aList = (
        self.get_leo_completions(prefix) or
            # Prefer the Leo completions.
        self.get_codewise_completions(prefix)
    )
    d[prefix] = aList
    return aList
</t>
<t tx="ekr.20110512232915.14481">def clean_for_display(self, hits):
    """Clean up hits, a list of ctags patterns, for display purposes."""
    aList = []
    for h in hits:
        s = h[0]
        # Display oriented: no good for completion list.
        fn = h[1].strip()
        if fn.startswith('/'):
            sig = fn[2:-4].strip()
        else:
            sig = fn
        aList.append(f"{s}: {sig}")
    aList = list(set(aList))
    aList.sort()
    return aList
</t>
<t tx="ekr.20110513104728.14453">def clean_completion_list(self, header, tabList):
    """Return aList with header removed from the start of each list item."""
    return [
        z[len(header) + 1 :] if z.startswith(header) else z
            for z in tabList]
</t>
<t tx="ekr.20110513104728.14454">def get_summary_list(self, header, tabList):
    """Show the possible starting letters,
    but only if there are more than one.
    """
    d = {}
    for z in tabList:
        tail = z[len(header) :] if z else ''
        if tail.startswith('.'): tail = tail[1:]
        ch = tail[0] if tail else ''
        if ch:
            n = d.get(ch, 0)
            d[ch] = n + 1
    aList = [f"{ch2} {d.get(ch2)}" for ch2 in sorted(d)]
    if len(aList) &gt; 1:
        tabList = aList
    else:
        tabList = self.clean_completion_list(header, tabList)
    return tabList
</t>
<t tx="ekr.20110514051607.14524">def get_cached_options(self, prefix):
    d = self.completionsDict
    # Search the completions Dict for shorter and shorter prefixes.
    i = len(prefix)
    while i &gt; 0:
        key = prefix[:i]
        i -= 1
        # Make sure we report hits only of real objects.
        if key.endswith('.'):
            return key, []
        options = d.get(key)
        if options:
            return key, options
    return None, []
</t>
<t tx="ekr.20110530124245.18245">@g.commander_command('import-file')
def importAnyFile(self, event=None):
    """Import one or more files."""
    c = self
    ic = c.importCommands
    types = [
        ("All files", "*"),
        ("C/C++ files", "*.c"),
        ("C/C++ files", "*.cpp"),
        ("C/C++ files", "*.h"),
        ("C/C++ files", "*.hpp"),
        ("FreeMind files", "*.mm.html"),
        ("Java files", "*.java"),
        ("JavaScript files", "*.js"),
        # ("JSON files", "*.json"),
        ("Mindjet files", "*.csv"),
        ("MORE files", "*.MORE"),
        ("Lua files", "*.lua"),
        ("Pascal files", "*.pas"),
        ("Python files", "*.py"),
        ("Text files", "*.txt"),
    ]
    names = g.app.gui.runOpenFileDialog(c,
        title="Import File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()
    if names:
        g.chdir(names[0])
    else:
        names = []
    if not names:
        if g.unitTesting:
            # a kludge for unit testing.
            c.init_error_dialogs()
            c.raise_error_dialogs(kind='read')
        return
    # New in Leo 4.9: choose the type of import based on the extension.
    c.init_error_dialogs()
    derived = [z for z in names if c.looksLikeDerivedFile(z)]
    others = [z for z in names if z not in derived]
    if derived:
        ic.importDerivedFiles(parent=c.p, paths=derived)
    for fn in others:
        junk, ext = g.os_path_splitext(fn)
        ext = ext.lower()  # #1522
        if ext.startswith('.'):
            ext = ext[1:]
        if ext == 'csv':
            ic.importMindMap([fn])
        elif ext in ('cw', 'cweb'):
            ic.importWebCommand([fn], "cweb")
        # Not useful. Use @auto x.json instead.
        # elif ext == 'json':
            # ic.importJSON([fn])
        elif fn.endswith('mm.html'):
            ic.importFreeMind([fn])
        elif ext in ('nw', 'noweb'):
            ic.importWebCommand([fn], "noweb")
        elif ext == 'more':
            leoImport.MORE_Importer(c).import_file(fn)  # #1522.
        elif ext == 'txt':
            # #1522: Create an @edit node.
            import_txt_file(c, fn)
        else:
            # Make *sure* that parent.b is empty.
            last = c.lastTopLevel()
            parent = last.insertAfter()
            parent.v.h = 'Imported Files'
            ic.importFilesCommand(
                files=[fn],
                parent=parent,
                treeType='@auto',  # was '@clean'
                    # Experimental: attempt to use permissive section ref logic.
            )
    c.raise_error_dialogs(kind='read')

g.command_alias('importAtFile', importAnyFile)
g.command_alias('importAtRoot', importAnyFile)
g.command_alias('importCWEBFiles', importAnyFile)
g.command_alias('importDerivedFile', importAnyFile)
g.command_alias('importFlattenedOutline', importAnyFile)
g.command_alias('importMOREFiles', importAnyFile)
g.command_alias('importNowebFiles', importAnyFile)
g.command_alias('importTabFiles', importAnyFile)
</t>
<t tx="ekr.20110530124245.18248">def looksLikeDerivedFile(self, fn):
    """
    Return True if fn names a file that looks like an
    external file written by Leo.
    """
    # c = self
    try:
        with open(fn, 'rb') as f:  # 2020/11/14: Allow unicode characters!
            s = f.read()
            s = g.toUnicode(s)
        return s.find('@+leo-ver=') &gt; -1
    except Exception:
        g.es_exception()
        return False
</t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.
</t>
<t tx="ekr.20110605121601.17875">def drawNode(self, p, parent_item):
    """Draw the node p."""
    c = self.c
    v = p.v
    # Allocate the QTreeWidgetItem.
    item = self.createTreeItem(p, parent_item)
    #
    # Update the data structures.
    itemHash = self.itemHash(item)
    self.position2itemDict[p.key()] = item
    self.item2positionDict[itemHash] = p.copy()  # was item
    self.item2vnodeDict[itemHash] = v  # was item
    d = self.vnode2itemsDict
    aList = d.get(v, [])
    if item not in aList:
        aList.append(item)
    d[v] = aList
    # Set the headline and maybe the icon.
    self.setItemText(item, p.h)
    # #1310: Add a tool tip.
    item.setToolTip(0, p.h)
    if self.use_declutter:
        icon = self.declutter_node(c, p, item)
        if icon:
            item.setIcon(0, icon)
        return item
    # Draw the icon.
    v.iconVal = v.computeIcon()
    icon = self.getCompositeIconImage(p, v.iconVal)
        # **Slow**, but allows per-vnode icons.
    if icon:
        item.setIcon(0, icon)
    return item
</t>
<t tx="ekr.20110605121601.17911">def endEditLabel(self):
    """
    Override LeoTree.endEditLabel.

    Just end editing of the presently-selected QLineEdit!
    This will trigger the editingFinished_callback defined in createEditorForItem.
    """
    item = self.getCurrentItem()
    if not item:
        return
    e = self.getTreeEditorForItem(item)
    if not e:
        return
    # Trigger the end-editing event.
    w = self.treeWidget
    w.closeEditor(e, QtWidgets.QAbstractItemDelegate.NoHint)
    w.setCurrentItem(item)
</t>
<t tx="ekr.20110605121601.18005">if QtWidgets:


    class LeoQTextBrowser(QtWidgets.QTextBrowser):
        """A subclass of QTextBrowser that overrides the mouse event handlers."""
        @others
</t>
<t tx="ekr.20110605121601.18006">def __init__(self, parent, c, wrapper):
    """ctor for LeoQTextBrowser class."""
    for attr in ('leo_c', 'leo_wrapper',):
        assert not hasattr(QtWidgets.QTextBrowser, attr), attr
    self.leo_c = c
    self.leo_s = ''  # The cached text.
    self.leo_wrapper = wrapper
    self.htmlFlag = True
    super().__init__(parent)
    self.setCursorWidth(c.config.getInt('qt-cursor-width') or 1)
    
    # Connect event handlers...
    if 0:  # Not a good idea: it will complicate delayed loading of body text.
        self.textChanged.connect(self.onTextChanged)
    # #1286
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.onContextMenu)
    # This event handler is the easy way to keep track of the vertical scroll position.
    self.leo_vsb = vsb = self.verticalScrollBar()
    vsb.valueChanged.connect(self.onSliderChanged)
    # For QCompleter
    self.leo_q_completer = None
    self.leo_options = None
    self.leo_model = None
</t>
<t tx="ekr.20110605121601.18007">def __repr__(self):
    return f"(LeoQTextBrowser) {id(self)}"

__str__ = __repr__
</t>
<t tx="ekr.20110605121601.18008"></t>
<t tx="ekr.20110605121601.18009">class LeoQListWidget(QtWidgets.QListWidget):
    @others
</t>
<t tx="ekr.20110605121601.18010">def __init__(self, c):
    """ctor for LeoQListWidget class"""
    super().__init__()
    self.setWindowFlags(QtCore.Qt.Popup | self.windowFlags())
    # Make this window a modal window.
    # Calling this does not fix the Ubuntu-specific modal behavior.
    # self.setWindowModality(QtCore.Qt.NonModal) # WindowModal)
    # Inject the ivars
    self.leo_w = c.frame.body.wrapper.widget
        # A LeoQTextBrowser, a subclass of QtWidgets.QTextBrowser.
    self.leo_c = c
    # A weird hack.
    self.leo_geom_set = False  # When true, self.geom returns global coords!
    self.itemClicked.connect(self.select_callback)
</t>
<t tx="ekr.20110605121601.18011">def closeEvent(self, event):
    """Kill completion and close the window."""
    self.leo_c.k.autoCompleter.abort()
</t>
<t tx="ekr.20110605121601.18012">def end_completer(self):
    """End completion."""
    c = self.leo_c
    c.in_qt_dialog = False
    # This is important: it clears the autocompletion state.
    c.k.keyboardQuit()
    c.bodyWantsFocusNow()
    try:
        self.deleteLater()
    except RuntimeError:
        # Avoid bug 1338773: Autocompleter error
        pass
</t>
<t tx="ekr.20110605121601.18013">def keyPressEvent(self, event):
    """Handle a key event from QListWidget."""
    c = self.leo_c
    w = c.frame.body.wrapper
    qt = QtCore.Qt
    key = event.key()
    if event.modifiers() != qt.NoModifier and not event.text():
        # A modifier key on it's own.
        pass
    elif key in (qt.Key_Up, qt.Key_Down):
        QtWidgets.QListWidget.keyPressEvent(self, event)
    elif key == qt.Key_Tab:
        self.tab_callback()
    elif key in (qt.Key_Enter, qt.Key_Return):
        self.select_callback()
    else:
        # Pass all other keys to the autocompleter via the event filter.
        w.ev_filter.eventFilter(obj=self, event=event)
</t>
<t tx="ekr.20110605121601.18014">def select_callback(self):
    """
    Called when user selects an item in the QListWidget.
    """
    c = self.leo_c
    p = c.p
    w = c.k.autoCompleter.w or c.frame.body.wrapper
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    # Replace the tail of the prefix with the completion.
    completion = self.currentItem().text()
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &gt; 1:
        tail = parts[-1]
    else:
        tail = prefix
    if tail != completion:
        j = w.getInsertPoint()
        i = j - len(tail)
        w.delete(i, j)
        w.insert(i, completion)
        j = i + len(completion)
        c.setChanged()
        w.setInsertPoint(j)
        c.undoer.doTyping(p, 'Typing', oldText,
            newText=w.getAllText(),
            newInsert=w.getInsertPoint(),
            newSel=w.getSelectionRange(),
            oldSel=oldSel,
        )
    self.end_completer()
</t>
<t tx="ekr.20110605121601.18015">def set_position(self, c):
    """Set the position of the QListWidget."""

    def glob(obj, pt):
        """Convert pt from obj's local coordinates to global coordinates."""
        return obj.mapToGlobal(pt)

    w = self.leo_w
    vp = self.viewport()
    r = w.cursorRect()
    geom = self.geometry()  # In viewport coordinates.
    gr_topLeft = glob(w, r.topLeft())
    # As a workaround to the Qt setGeometry bug,
    # The window is destroyed instead of being hidden.
    if self.leo_geom_set:
        g.trace('Error: leo_geom_set')
        return
    # This code illustrates the Qt bug...
        # if self.leo_geom_set:
            # # Unbelievable: geom is now in *global* coords.
            # gg_topLeft = geom.topLeft()
        # else:
            # # Per documentation, geom in local (viewport) coords.
            # gg_topLeft = glob(vp,geom.topLeft())
    gg_topLeft = glob(vp, geom.topLeft())
    delta_x = gr_topLeft.x() - gg_topLeft.x()
    delta_y = gr_topLeft.y() - gg_topLeft.y()
    # These offset are reasonable. Perhaps they should depend on font size.
    x_offset, y_offset = 10, 60
    # Compute the new geometry, setting the size by hand.
    geom2_topLeft = QtCore.QPoint(
        geom.x() + delta_x + x_offset,
        geom.y() + delta_y + y_offset)
    geom2_size = QtCore.QSize(400, 100)
    geom2 = QtCore.QRect(geom2_topLeft, geom2_size)
    # These tests fail once offsets are added.
    if x_offset == 0 and y_offset == 0:
        if self.leo_geom_set:
            if geom2.topLeft() != glob(w, r.topLeft()):
                g.trace(
                    f"Error: geom.topLeft: {geom2.topLeft()}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
        else:
            if glob(vp, geom2.topLeft()) != glob(w, r.topLeft()):
                g.trace(
                    f"Error 2: geom.topLeft: {glob(vp, geom2.topLeft())}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
    self.setGeometry(geom2)
    self.leo_geom_set = True
</t>
<t tx="ekr.20110605121601.18016">def show_completions(self, aList):
    """Set the QListView contents to aList."""
    self.clear()
    self.addItems(aList)
    self.setCurrentRow(0)
    self.activateWindow()
    self.setFocus()
</t>
<t tx="ekr.20110605121601.18017">def init_completer(self, options):
    """Connect a QCompleter."""
    c = self.leo_c
    self.leo_qc = qc = self.LeoQListWidget(c)
    # Move the window near the body pane's cursor.
    qc.set_position(c)
    # Show the initial completions.
    c.in_qt_dialog = True
    qc.show()
    qc.activateWindow()
    c.widgetWantsFocusNow(qc)
    qc.show_completions(options)
    return qc
</t>
<t tx="ekr.20110605121601.18018">def end_completer(self):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.end_completer()
        delattr(self, 'leo_qc')

def show_completions(self, aList):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.show_completions(aList)
</t>
<t tx="ekr.20110605121601.18019">def leo_dumpButton(self, event, tag):

    button = event.button()
    table = (
        (QtCore.Qt.NoButton, 'no button'),
        (QtCore.Qt.LeftButton, 'left-button'),
        (QtCore.Qt.RightButton, 'right-button'),
        (QtCore.Qt.MidButton, 'middle-button'),
    )
    for val, s in table:
        if button == val:
            kind = s; break
    else:
        kind = f"unknown: {repr(button)}"
    return kind
</t>
<t tx="ekr.20110605121601.18077">def leoMoveCursorHelper(self, kind, extend=False, linesPerPage=15):
    """QTextEditWrapper."""
    w = self.widget
    tc = QtGui.QTextCursor
    d = {
        'begin-line': tc.StartOfLine,  # Was start-line
        'down': tc.Down,
        'end': tc.End,
        'end-line': tc.EndOfLine,  # Not used.
        'exchange': True,  # Dummy.
        'home': tc.Start,
        'left': tc.Left,
        'page-down': tc.Down,
        'page-up': tc.Up,
        'right': tc.Right,
        'up': tc.Up,
    }
    kind = kind.lower()
    op = d.get(kind)
    mode = tc.KeepAnchor if extend else tc.MoveAnchor
    if not op:
        g.trace(f"can not happen: bad kind: {kind}")
        return
    if kind in ('page-down', 'page-up'):
        self.pageUpDown(op, mode)
    elif kind == 'exchange':  # exchange-point-and-mark
        cursor = w.textCursor()
        anchor = cursor.anchor()
        pos = cursor.position()
        cursor.setPosition(pos, tc.MoveAnchor)
        cursor.setPosition(anchor, tc.KeepAnchor)
        w.setTextCursor(cursor)
    else:
        if not extend:
            # Fix an annoyance. Make sure to clear the selection.
            cursor = w.textCursor()
            cursor.clearSelection()
            w.setTextCursor(cursor)
        w.moveCursor(op, mode)
    self.seeInsertPoint()
    self.rememberSelectionAndScroll()
    # #218.
    cursor = w.textCursor()
    sel = cursor.selection().toPlainText()
    if sel and hasattr(g.app.gui, 'setClipboardSelection'):
        g.app.gui.setClipboardSelection(sel)
    self.c.frame.updateStatusLine()
</t>
<t tx="ekr.20110605121601.18090">def see(self, see_i):
    """Scroll so that position see_i is visible."""
    w = self.widget
    tc = w.textCursor()
    # Put see_i in range.
    s = self.getAllText()
    see_i = max(0, min(see_i, len(s)))
    # Remember the old cursor
    old_cursor = QtGui.QTextCursor(tc)
    # Scroll so that see_i is visible.
    tc.setPosition(see_i)
    w.setTextCursor(tc)
    w.ensureCursorVisible()
    # Restore the old cursor
    w.setTextCursor(old_cursor)

def seeInsertPoint(self):
    """Make sure the insert point is visible."""
    self.widget.ensureCursorVisible()
</t>
<t tx="ekr.20110605121601.18096">def setSelectionRange(self, i, j, insert=None, s=None):
    """Set the selection range and the insert point."""
    #
    # Part 1
    w = self.widget
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    if s is None:
        s = self.getAllText()
    n = len(s)
    i = max(0, min(i, n))
    j = max(0, min(j, n))
    if insert is None:
        ins = max(i, j)
    else:
        ins = self.toPythonIndex(insert)
        ins = max(0, min(ins, n))
    #
    # Part 2:
    # 2010/02/02: Use only tc.setPosition here.
    # Using tc.movePosition doesn't work.
    tc = w.textCursor()
    if i == j:
        tc.setPosition(i)
    elif ins == j:
        # Put the insert point at j
        tc.setPosition(i)
        tc.setPosition(j, tc.KeepAnchor)
    elif ins == i:
        # Put the insert point at i
        tc.setPosition(j)
        tc.setPosition(i, tc.KeepAnchor)
    else:
        # 2014/08/21: It doesn't seem possible to put the insert point somewhere else!
        tc.setPosition(j)
        tc.setPosition(i, tc.KeepAnchor)
    w.setTextCursor(tc)
    # #218.
    if hasattr(g.app.gui, 'setClipboardSelection'):
        if s[i:j]:
            g.app.gui.setClipboardSelection(s[i:j])
    #
    # Remember the values for v.restoreCursorAndScroll.
    v = self.c.p.v  # Always accurate.
    v.insertSpot = ins
    if i &gt; j: i, j = j, i
    assert(i &lt;= j)
    v.selectionStart = i
    v.selectionLength = j - i
    v.scrollBarSpot = w.verticalScrollBar().value()
</t>
<t tx="ekr.20110605121601.18139">def construct(self, master=None):
    """ Factor 'heavy duty' code out from the DynamicWindow ctor """
    c = self.leo_c
    self.leo_master = master
        # A LeoTabbedTopLevel for tabbed windows.
        # None for non-tabbed windows.
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    self.reloadSettings()
    main_splitter, secondary_splitter = self.createMainWindow()
    self.iconBar = self.addToolBar("IconBar")
    self.iconBar.setObjectName('icon-bar')
        # Required for QMainWindow.saveState().
    self.set_icon_bar_orientation(c)
    # #266 A setting to hide the icon bar.
    # Calling reloadSettings again would also work.
    if not self.show_iconbar:
        self.iconBar.hide()
    self.leo_menubar = self.menuBar()
    self.statusBar = QtWidgets.QStatusBar()
    self.setStatusBar(self.statusBar)
    orientation = c.config.getString('initial-split-orientation')
    self.setSplitDirection(main_splitter, secondary_splitter, orientation)
    if hasattr(c, 'styleSheetManager'):
        c.styleSheetManager.set_style_sheets(top=self, all=True)
</t>
<t tx="ekr.20110605121601.18145">def createLogPane(self, parent):
    """Create all parts of Leo's log pane."""
    c = self.leo_c
    #
    # Create the log frame.
    logFrame = self.createFrame(parent, 'logFrame',
        vPolicy=QtWidgets.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame, 'logInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred,
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame, 'logTabWidget')
    #
    # Pack.
    innerGrid = self.createGrid(innerFrame, 'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame, 'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)
    #
    # Create the Find tab, embedded in a QScrollArea.
    findScrollArea = QtWidgets.QScrollArea()
    findScrollArea.setObjectName('findScrollArea')
    # Find tab.
    findTab = QtWidgets.QWidget()
    findTab.setObjectName('findTab')
    #
    # #516 and #1507: Create a Find tab unless we are using a dialog.
    #
    # Careful: @bool minibuffer-ding-mode overrides @bool use-find-dialog.
    use_minibuffer = c.config.getBool('minibuffer-find-mode', default=False)
    use_dialog = c.config.getBool('use-find-dialog', default=False)
    if use_minibuffer or not use_dialog:
        tabWidget.addTab(findScrollArea, 'Find')
    # Complete the Find tab in LeoFind.finishCreate.
    self.findScrollArea = findScrollArea
    self.findTab = findTab
    #
    # Spell tab.
    spellTab = QtWidgets.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab, 'Spell')
    self.createSpellTab(spellTab)
    tabWidget.setCurrentIndex(1)
    #
    # Official ivars
    self.tabWidget = tabWidget  # Used by LeoQtLog.
</t>
<t tx="ekr.20110605121601.18278">def setInitialWindowGeometry(self):
    """Set the position and size of the frame to config params."""
    c = self.c
    h = c.config.getInt("initial-window-height") or 500
    w = c.config.getInt("initial-window-width") or 600
    x = c.config.getInt("initial-window-left") or 50  # #1190: was 10
    y = c.config.getInt("initial-window-top") or 50  # #1190: was 10
    if h and w and x and y:
        if 'size' in g.app.debug:
            g.trace(w, h, x, y)
        self.setTopGeometry(w, h, x, y)
</t>
<t tx="ekr.20110605121601.18315">def finishCreate(self):
    """Finish creating the LeoQtLog class."""
    c, log, w = self.c, self, self.tabWidget
    #
    # Create the log tab as the leftmost tab.
    log.createTab('Log')
    self.logWidget = logWidget = self.contentsDict.get('Log')
    option = QtGui.QTextOption
    logWidget.setWordWrapMode(option.WordWrap if self.wrap else option.NoWrap)
    w.insertTab(0, logWidget, 'Log')
        # Required.
    #
    # set up links in log handling
    logWidget.setTextInteractionFlags(
        QtCore.Qt.LinksAccessibleByMouse |
        QtCore.Qt.TextEditable |
        QtCore.Qt.TextSelectableByMouse
    )
    logWidget.setOpenLinks(False)
    logWidget.setOpenExternalLinks(False)
    logWidget.anchorClicked.connect(self.linkClicked)
    #
    # Show the spell tab.
    c.spellCommands.openSpellTab()
    #
    #794: Clicking Find Tab should do exactly what pushing Ctrl-F does

    def tab_callback(index):
        name = w.tabText(index)
        if name == 'Find':
            c.findCommands.startSearch(event=None)

    w.currentChanged.connect(tab_callback)
    # #1286.
    w.customContextMenuRequested.connect(self.onContextMenu)
</t>
<t tx="ekr.20110605121601.18322">def put(self, s, color=None, tabName='Log', from_redirect=False, nodeLink=None):
    """
    Put s to the Qt Log widget, converting to html.
    All output to the log stream eventually comes here.

    The from_redirect keyword argument is no longer used.
    """
    c = self.c
    if g.app.quitting or not c or not c.exists:
        return
    # Note: g.actualColor does all color translation.
    if color:
        color = leoColor.getColor(color)
    if not color:
        # #788: First, fall back to 'log_black_color', not 'black.
        color = c.config.getColor('log-black-color')
        if not color:
            # Should never be necessary.
            color = 'black'
    self.selectTab(tabName or 'Log')
    # Must be done after the call to selectTab.
    wrapper = self.logCtrl
    if not isinstance(wrapper, qt_text.QTextEditWrapper):
        g.trace('BAD wrapper', wrapper.__class__.__name__)
        return
    w = wrapper.widget
    if not isinstance(w, QtWidgets.QTextEdit):
        g.trace('BAD widget', w.__class__.__name__)
        return
    sb = w.horizontalScrollBar()
    s = s.replace('&amp;', '&amp;amp;').replace('&lt;', '&amp;lt;').replace('&gt;', '&amp;gt;')
    # #884: Always convert leading blanks and tabs to &amp;nbsp.
    n = len(s) - len(s.lstrip())
    if n &gt; 0 and s.strip():
        s = '&amp;nbsp;' * (n) + s[n:]
    if not self.wrap:
        # Convert all other blanks to &amp;nbsp;
        s = s.replace(' ', '&amp;nbsp;')
    s = s.replace('\n', '&lt;br&gt;')
        # The caller is responsible for newlines!
    s = f'&lt;font color="{color}"&gt;{s}&lt;/font&gt;'
    if nodeLink:
        url = nodeLink
        for scheme in 'file', 'unl':
            # QUrl requires paths start with '/'
            if url.startswith(
                scheme + '://') and not url.startswith(scheme + ':///'):
                url = url.replace('://', ':///', 1)
        s = f'&lt;a href="{url}" title="{nodeLink}"&gt;{s}&lt;/a&gt;'
    w.insertHtml(s)
    w.moveCursor(QtGui.QTextCursor.End)
    sb.setSliderPosition(0)  # Force the slider to the initial position.
    w.repaint()  # Slow, but essential.
</t>
<t tx="ekr.20110605121601.18326">def createTab(self, tabName, createText=True, widget=None, wrap='none'):
    """
    Create a new tab in tab widget
    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """
    c = self.c
    if widget is None:
        widget = qt_text.LeoQTextBrowser(parent=None, c=c, wrapper=self)
            # widget is subclass of QTextBrowser.
        contents = qt_text.QTextEditWrapper(widget=widget, name='log', c=c)
            # contents a wrapper.
        widget.leo_log_wrapper = contents
            # Inject an ivar into the QTextBrowser that points to the wrapper.
        option = QtGui.QTextOption
        widget.setWordWrapMode(option.WordWrap if self.wrap else option.NoWrap)
        widget.setReadOnly(False)  # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.logCtrl = contents
            widget.setObjectName('log-widget')
        # Set binding on all log pane widgets.
        g.app.gui.setFilter(c, widget, self, tag='log')
        self.contentsDict[tabName] = widget
        self.tabWidget.addTab(widget, tabName)
    else:
        # #1161: Don't set the wrapper unless it has the correct type.
        contents = widget
            # Unlike text widgets, contents is the actual widget.
        if isinstance(contents, qt_text.QTextEditWrapper):
            widget.leo_log_wrapper = widget
                # The leo_log_wrapper is the widget itself.
        else:
            widget.leo_log_wrapper = None
                # Tell the truth.
        g.app.gui.setFilter(c, widget, contents, 'tabWidget')
        self.contentsDict[tabName] = contents
        self.tabWidget.addTab(contents, tabName)
    return contents
</t>
<t tx="ekr.20110605121601.18365">def dropEvent(self, ev):
    """Handle a drop event in the QTreeWidget."""
    if not ev:
        return
    md = ev.mimeData()
    if not md:
        g.trace('no mimeData!')
        return
    mods = int(ev.keyboardModifiers())
    self.was_alt_drag = (mods &amp; QtCore.Qt.AltModifier) != 0
    self.was_control_drag = (mods &amp; QtCore.Qt.ControlModifier) != 0
    c, tree = self.c, self.c.frame.tree
    p = None
    item = self.itemAt(ev.pos())
    if item:
        itemHash = tree.itemHash(item)
        p = tree.item2positionDict.get(itemHash)
    if not p:
        # #59: Drop at last node.
        p = c.rootPosition()
        while p.hasNext():
            p.moveToNext()
    formats = set(str(f) for f in md.formats())
    ev.setDropAction(QtCore.Qt.IgnoreAction)
    ev.accept()
    hookres = g.doHook("outlinedrop", c=c, p=p, dropevent=ev, formats=formats)
    if hookres:
        # A plugin handled the drop.
        pass
    else:
        if md.hasUrls():
            self.urlDrop(md, p)
        else:
            self.nodeDrop(md, p)
    g.app.dragging = False
</t>
<t tx="ekr.20110605121601.18366">def nodeDrop(self, md, p):
    """
    Handle a drop event when not md.urls().
    This will happen when we drop an outline node.
    We get the copied text from md.text().
    """
    c = self.c
    fn, s = self.parseText(md)
    if not s or not fn:
        return
    if fn == self.fileName():
        if p and p == c.p:
            pass
        elif g.os_path_exists(fn):
            self.intraFileDrop(fn, c.p, p)
    else:
        self.interFileDrop(fn, p, s)
</t>
<t tx="ekr.20110605121601.18367">def interFileDrop(self, fn, p, s):
    """Paste the mime data after (or as the first child of) p."""
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(s)
        # Paste the node after the presently selected node.
    if not pasted:
        return
    if c.config.getBool('inter-outline-drag-moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged()
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged()
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw(pasted)
    c.recolor()
</t>
<t tx="ekr.20110605121601.18368">def intraFileDrop(self, fn, p1, p2):
    """Move p1 after (or as the first child of) p2."""
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag:
                p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag:
                p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if ok:
        undoData = u.beforeMoveNode(p1)
        p1.setDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            for z in p1.self_and_subtree():
                z.setDirty()
        c.setChanged()
        u.afterMoveNode(p1, 'Drag', undoData)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw(p1)
        else:
            c.redraw(p2)
</t>
<t tx="ekr.20110605121601.18369">def urlDrop(self, md, p):
    """Handle a drop when md.urls()."""
    c, u, undoType = self.c, self.c.undoer, 'Drag Urls'
    urls = md.urls()
    if not urls:
        return
    c.undoer.beforeChangeGroup(c.p, undoType)
    changed = False
    for z in urls:
        url = QtCore.QUrl(z)
        scheme = url.scheme()
        if scheme == 'file':
            changed |= self.doFileUrl(p, url)
        elif scheme in ('http',):  # 'ftp','mailto',
            changed |= self.doHttpUrl(p, url)
    if changed:
        c.setChanged()
        u.afterChangeGroup(c.p, undoType, reportFlag=False)
        c.redraw()
</t>
<t tx="ekr.20110605121601.18370">def doFileUrl(self, p, url):
    """Read the file given by the url and put it in the outline."""
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb')  # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print(
        f"not found: {fn}", nodeLink=p.get_UNL(with_proto=True, with_count=True))
    return False
</t>
<t tx="ekr.20110605121601.18371">def doFileUrlHelper(self, fn, p, s):
    """
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    """
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False  # Don't set the changed marker in the original file.
    u, undoType = c.undoer, 'Drag File'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
        parent = p
    elif p.h.startswith('@path '):
        # #60: create relative paths &amp; urls when dragging files.
        p2 = p.insertAsNthChild(0)
        p.expand()
        parent = p
    else:
        p2 = p.insertAfter()
        parent = p.parent()
    # #60: create relative paths &amp; urls when dragging files.
    aList = g.get_directives_dict_list(parent)
    path = g.scanAtPathDirectives(c, aList)
    if path:
        fn = os.path.relpath(fn, path)
        fn = g.toUnicodeFileEncoding(fn)
    self.createAtFileNode(fn, p2, s)
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
    return True  # The original .leo file has changed.
</t>
<t tx="ekr.20110605121601.18372">def createAtFileNode(self, fn, p, s):
    """
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    """
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
</t>
<t tx="ekr.20110605121601.18373">def createAtAutoTree(self, fn, p):
    """
    Make p an @auto node and create the tree using s, the file's contents.
    """
    c = self.c; at = c.atFileCommands
    p.h = f"@auto {fn}"
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty()  # Don't automatically rewrite this node.
</t>
<t tx="ekr.20110605121601.18374">def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = f"@edit {fn}"
    p.clearDirty()  # Don't automatically rewrite this node.
</t>
<t tx="ekr.20110605121601.18375">def createAtFileTree(self, fn, p, s):
    """Make p an @file node and create the tree using
    s, the file's contents.
    """
    c = self.c; at = c.atFileCommands
    p.h = f"@file {fn}"
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True)  # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = ''  # Safe: will not cause a write later.
        p.clearDirty()  # Don't automatically rewrite this node.
</t>
<t tx="ekr.20110605121601.18376">def isThinFile(self, fn, s):
    """
    Return true if the file whose contents is s
    was created from an @thin or @file tree.
    """
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    # Like at.isFileLike.
    j, k = g.getLine(s, i)
    line = s[j:k]
    valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
    return valid and new_df and isThin
</t>
<t tx="ekr.20110605121601.18377">def isAutoFile(self, fn):
    """Return true if fn (a file name) can be parsed with an @auto parser."""
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
</t>
<t tx="ekr.20110605121601.18378">def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
</t>
<t tx="ekr.20110605121601.18379">def doPathUrlHelper(self, fn, p):
    """Insert fn as an @path node after p."""
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
</t>
<t tx="ekr.20110605121601.18380">def doHttpUrl(self, p, url):
    """Insert the url in an @url node after p."""
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@url'
    p2.b = s
    p2.clearDirty()  # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
</t>
<t tx="ekr.20110605121601.18383">def parseText(self, md):
    """Parse md.text() into (fn,s)"""
    fn = ''
    s = md.text()
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[:i]
            s = s[i + 1 :]
    return fn, s
</t>
<t tx="ekr.20110605121601.18411">def getIcon(self, p):
    """Return the proper icon for position p."""
    if self.use_declutter:
        item = self.position2item(p)
        return item and self.declutter_node(self.c, p, item)
    p.v.iconVal = iv = p.v.computeIcon()
    return self.getCompositeIconImage(p, iv)


</t>
<t tx="ekr.20110605121601.18412">def getCompositeIconImage(self, p, val):
    """Get the icon at position p."""
    fnames = self.icon_filenames_for_node(p, val)
    h = ':'.join(fnames)
    icon = g.app.gui.iconimages.get(h)
    loaded_images = self.loaded_images
    images = list(map(loaded_images.get, fnames))
    if not icon:
        icon = self.make_composite_icon(images)
        g.app.gui.iconimages[h] = icon
    return icon
</t>
<t tx="ekr.20110605121601.18418">def connectEditorWidget(self, e, item):
    """
    Connect QLineEdit e to QTreeItem item.
    
    Also callback for when the editor ends.
    
    New in Leo 6.4: The callback handles all updates w/o calling onHeadChanged.
    """
    c, p, u = self.c, self.c.p, self.c.undoer
    @others  # define the callback.
    if e:
        # Hook up the widget.
        wrapper = self.getWrapper(e, item)
        e.editingFinished.connect(editingFinished_callback)
        return wrapper  # 2011/02/12
    g.trace('can not happen: no e')
    return None
</t>
<t tx="ekr.20110605121601.18437">def onContextMenu(self, point):
    """LeoQtTree: Callback for customContextMenuRequested events."""
    # #1286.
    c, w = self.c, self.treeWidget
    g.app.gui.onContextMenu(c, w, point)
</t>
<t tx="ekr.20110605121601.18466">def createFrame(self, leoFrame):

    c = leoFrame.c
    tabw = self.masterFrame
    dw = DynamicWindow(c, tabw)
    self.leoFrames[dw] = leoFrame
    # Shorten the title.
    title = os.path.basename(c.mFileName) if c.mFileName else leoFrame.title
    tip = leoFrame.title
    dw.setWindowTitle(tip)
    idx = tabw.addTab(dw, title)
    if tip:
        tabw.setTabToolTip(idx, tip)
    dw.construct(master=tabw)
    tabw.setCurrentIndex(idx)
    g.app.gui.setFilter(c, dw, dw, tag='tabbed-frame')
    #
    # Work around the problem with missing dirty indicator
    # by always showing the tab.
    tabw.tabBar().setVisible(self.alwaysShowTabs or tabw.count() &gt; 1)
    tabw.setTabsClosable(c.config.getBool('outline-tabs-show-close', True))
    if True:  # #1327: Must always do this.
        dw.show()
        tabw.show()
    return dw
</t>
<t tx="ekr.20110605121601.18468">def createMaster(self):

    window = self.masterFrame = LeoTabbedTopLevel(factory=self)
    tabbar = window.tabBar()
    g.app.gui.attachLeoIcon(window)
    try:
        tabbar.setTabsClosable(True)
        tabbar.tabCloseRequested.connect(self.slotCloseRequest)
    except AttributeError:
        pass  # Qt 4.4 does not support setTabsClosable
    window.currentChanged.connect(self.slotCurrentChanged)
    if 'size' in g.app.debug:
        g.trace(
            f"minimized: {g.app.start_minimized}, "
            f"maximized: {g.app.start_maximized}, "
            f"fullscreen: {g.app.start_fullscreen}")
    #
    # #1189: We *can* (and should) minimize here, to eliminate flash.
    if g.app.start_minimized:
        window.showMinimized()
</t>
<t tx="ekr.20110605121601.18480"># Called from eventFilter

def onActivateEvent(self, event, c, obj, tag):
    """
    Restore the focus when the Leo window is activated.
    Called several times for each window activation.
    """
    trace = 'focus' in g.app.debug
    w = self.get_focus() or self.deactivated_widget
    self.deactivated_widget = None
    w_name = w and w.objectName()
    # Fix #270: Vim keys don't always work after double Alt+Tab.
    # Fix #359: Leo hangs in LeoQtEventFilter.eventFilter
    # #1273: add teest on c.vim_mode.
    if c.exists and c.vim_mode and c.vimCommands and not self.active and not g.app.killed:
        c.vimCommands.on_activate()
    self.active = True
        # Used only by c.idle_focus_helper.
    if g.isMac:
        pass  # Fix #757: MacOS: replace-then-find does not work in headlines.
    else:
        # Leo 5.6: Recover from missing focus.
        # c.idle_focus_handler can't do this.
        if w and w_name in ('log-widget', 'richTextEdit', 'treeWidget'):
            # Restore focus **only** to body or tree
            if trace: g.trace('==&gt;', w_name)
            c.widgetWantsFocusNow(w)
        else:
            if trace: g.trace(repr(w_name), '==&gt; BODY')
            c.bodyWantsFocusNow()
    # Cause problems elsewhere.
        # if c.exists and self.deactivated_name:
            # self.active = True
            # w_name = self.deactivated_name
            # self.deactivated_name = None
            # if c.p.v:
                # c.p.v.restoreCursorAndScroll()
            # if w_name.startswith('tree') or w_name.startswith('head'):
                # c.treeWantsFocusNow()
            # else:
                # c.bodyWantsFocusNow()
    g.doHook('activate', c=c, p=c.p, v=c.p, event=event)
</t>
<t tx="ekr.20110605121601.18532"># #1121. Like sc.cleanButtonText
buttonCommandName = f"press-{buttonText.replace(' ', '-').strip('-')}-button"
#
# This will use any shortcut defined in an @shortcuts node.
k.registerCommand(buttonCommandName, executeScriptCallback, pane='button')
</t>
<t tx="ekr.20110605121601.18539">def __init__(self, c, w, tag=''):
    """Ctor for LeoQtEventFilter class."""
    super().__init__()
    self.c = c
    self.w = w  # A leoQtX object, *not* a Qt object.
    self.tag = tag
    # Debugging.
    self.keyIsActive = False
    # Pretend there is a binding for these characters.
    close_flashers = c.config.getString('close-flash-brackets') or ''
    open_flashers = c.config.getString('open-flash-brackets') or ''
    self.flashers = open_flashers + close_flashers
    # #1563: Support German keyboards.
    self.use_german_keyboard = c.config.getBool('use-german-keyboard', default=False)
    # Support for ctagscompleter.py plugin.
    self.ctagscompleter_active = False
    self.ctagscompleter_onKey = None
</t>
<t tx="ekr.20110605121601.18540">def eventFilter(self, obj, event):
    """Return False if Qt should handle the event."""
    c, k = self.c, self.c.k
    #
    # Handle non-key events first.
    if not self.c.p:
        return False  # Startup.
    #
    # Trace events.
    if 'events' in g.app.debug:
        if isinstance(event, QtGui.QKeyEvent):
            self.traceKeys(obj, event)
        else:
            self.traceEvent(obj, event)
            self.traceWidget(event)
    #
    # Let Qt handle the non-key events.
    if self.doNonKeyEvent(event, obj):
        return False
    #
    # Ignore incomplete key events.
    if self.shouldIgnoreKeyEvent(event, obj):
        return False
    #
    # Generate a g.KeyStroke for k.masterKeyHandler.
    try:
        binding, ch = self.toBinding(event)
        if not binding:
            return False  # Not the correct event type.
        #
        # Pass the KeyStroke to masterKeyHandler.
        key_event = self.createKeyEvent(event, c, self.w, ch, binding)
        k.masterKeyHandler(key_event)
        c.outerUpdate()
    except Exception:
        g.es_exception()
    return True
        # Whatever happens, suppress all other Qt key handling.
</t>
<t tx="ekr.20110605121601.18543">def toBinding(self, event):
    """
    Return (binding, actual_ch):

    binding:    A user binding, to create g.KeyStroke.
                Spelling no longer fragile.
    actual_ch:  The insertable key, or ''.
    """
    mods = self.qtMods(event)
    keynum, text, toString, ch = self.qtKey(event)
    actual_ch = text or toString
    #
    # Never allow empty chars, or chars in g.app.gui.ignoreChars
    if toString in g.app.gui.ignoreChars:
        return None, None
    ch = ch or toString or ''
    if not ch:
        return None, None
    #
    # Check for AltGr and Alt+Ctrl keys *before* creating a binding.
    actual_ch, ch, mods = self.doMacTweaks(actual_ch, ch, mods)
    mods = self.doAltTweaks(actual_ch, keynum, mods, toString)
    #
    # Use *ch* in the binding.
    # Clearer w/o f-strings.
    binding = '%s%s' % (''.join([f"{z}+" for z in mods]), ch)
    #
    # Return the tweaked *actual* char.
    binding, actual_ch = self.doLateTweaks(binding, actual_ch)
    return binding, actual_ch
</t>
<t tx="ekr.20110605121601.18544">def qtKey(self, event):
    """
    Return the components of a Qt key event.

    Modifiers are handled separately.

    Return (keynum, text, toString, ch).

    keynum: event.key()
    ch:     chr(keynum) or '' if there is an exception.
    toString:
        For special keys: made-up spelling that become part of the setting.
        For all others:   QtGui.QKeySequence(keynum).toString()
    text:   event.text()
    """
    keynum = event.key()
    text = event.text()  # This is the unicode character!
    qt = QtCore.Qt
    d = {
        qt.Key_Alt: 'Key_Alt',
        qt.Key_AltGr: 'Key_AltGr',
            # On Windows, when the KeyDown event for this key is sent,
            # the Ctrl+Alt modifiers are also set.
        qt.Key_Control: 'Key_Control',  # MacOS: Command key
        qt.Key_Meta: 'Key_Meta',
            # MacOS: Control key, Alt-Key on Microsoft keyboard on MacOs.
        qt.Key_Shift: 'Key_Shift',
        qt.Key_NumLock: 'Num_Lock',
            # 868.
        qt.Key_Super_L: 'Key_Super_L',
        qt.Key_Super_R: 'Key_Super_R',
        qt.Key_Hyper_L: 'Key_Hyper_L',
        qt.Key_Hyper_R: 'Key_Hyper_R',
    }
    if d.get(keynum):
        if 0:  # Allow bare modifier key.
            toString = d.get(keynum)
        else:
            toString = ''
    else:
        toString = QtGui.QKeySequence(keynum).toString()
    # Fix bug 1244461: Numpad 'Enter' key does not work in minibuffer
    if toString == 'Enter':
        toString = 'Return'
    if toString == 'Esc':
        toString = 'Escape'
    try:
        ch = chr(keynum)
    except ValueError:
        ch = ''
    # g.trace(keynum, ch)
    return keynum, text, toString, ch
</t>
<t tx="ekr.20110605121601.18581">def init_mode(self, name):
    """Name may be a language name or a delegate name."""
    if not name:
        return False
    if name == 'latex':
        name = 'tex'
            # #1088: use tex mode for both tex and latex.
    language, rulesetName = self.nameToRulesetName(name)
    bunch = self.modes.get(rulesetName)
    if bunch:
        if bunch.language == 'unknown-language':
            return False
        self.initModeFromBunch(bunch)
        self.language = language  # 2011/05/30
        return True
    # Don't try to import a non-existent language.
    path = g.os_path_join(g.app.loadDir, '..', 'modes')
    fn = g.os_path_join(path, f"{language}.py")
    if g.os_path_exists(fn):
        mode = g.import_module(name=f"leo.modes.{language}")
    else:
        mode = None
    return self.init_mode_from_module(name, mode)
</t>
<t tx="ekr.20110605121601.18582">def nameToRulesetName(self, name):
    """
    Compute language and rulesetName from name, which is either a language
    name or a delegate name.
    """
    if not name:
        return ''
    name = name.lower()
        # #1334. Lower-case the name, regardless of the spelling in @language.
    i = name.find('::')
    if i == -1:
        language = name
        # New in Leo 5.0: allow delegated language names.
        language = g.app.delegate_language_dict.get(language, language)
        rulesetName = f"{language}_main"
    else:
        language = name[:i]
        delegate = name[i + 2 :]
        rulesetName = self.munge(f"{language}_{delegate}")
    return language, rulesetName
</t>
<t tx="ekr.20110605121601.18583">def setKeywords(self):
    """
    Initialize the keywords for the present language.

     Set self.word_chars ivar to string.letters + string.digits
     plus any other character appearing in any keyword.
     """
    # Add any new user keywords to leoKeywordsDict.
    d = self.keywordsDict
    keys = list(d.keys())
    for s in g.globalDirectiveList:
        key = '@' + s
        if key not in keys:
            d[key] = 'leokeyword'
    # Create a temporary chars list.  It will be converted to a dict later.
    chars = [z for z in string.ascii_letters + string.digits]
    for key in list(d.keys()):
        for ch in key:
            if ch not in chars:
                chars.append(g.checkUnicode(ch))
    # jEdit2Py now does this check, so this isn't really needed.
    # But it is needed for forth.py.
    for ch in (' ', '\t'):
        if ch in chars:
            # g.es_print('removing %s from word_chars' % (repr(ch)))
            chars.remove(ch)
    # Convert chars to a dict for faster access.
    self.word_chars = {}
    for z in chars:
        self.word_chars[z] = z
</t>
<t tx="ekr.20110605121601.18584">def setModeAttributes(self):
    """
    Set the ivars from self.attributesDict,
    converting 'true'/'false' to True and False.
    """
    d = self.attributesDict
    aList = (
        ('default', 'null'),
        ('digit_re', ''),
        ('escape', ''),  # New in Leo 4.4.2.
        ('highlight_digits', True),
        ('ignore_case', True),
        ('no_word_sep', ''),
    )
    for key, default in aList:
        val = d.get(key, default)
        if val in ('true', 'True'): val = True
        if val in ('false', 'False'): val = False
        setattr(self, key, val)
</t>
<t tx="ekr.20110605121601.18585">def initModeFromBunch(self, bunch):
    self.modeBunch = bunch
    self.attributesDict = bunch.attributesDict
    self.setModeAttributes()
    self.defaultColor = bunch.defaultColor
    self.keywordsDict = bunch.keywordsDict
    self.language = bunch.language
    self.mode = bunch.mode
    self.properties = bunch.properties
    self.rulesDict = bunch.rulesDict
    self.rulesetName = bunch.rulesetName
    self.word_chars = bunch.word_chars  # 2011/05/21
</t>
<t tx="ekr.20110605121601.18586">def updateDelimsTables(self):
    """Update g.app.language_delims_dict if no entry for the language exists."""
    d = self.properties
    lineComment = d.get('lineComment')
    startComment = d.get('commentStart')
    endComment = d.get('commentEnd')
    if lineComment and startComment and endComment:
        delims = f"{lineComment} {startComment} {endComment}"
    elif startComment and endComment:
        delims = f"{startComment} {endComment}"
    elif lineComment:
        delims = f"{lineComment}"
    else:
        delims = None
    if delims:
        d = g.app.language_delims_dict
        if not d.get(self.language):
            d[self.language] = delims
</t>
<t tx="ekr.20110605121601.18624">def restart_match_span(self, s,
    delegate, end, exclude_match, kind,
    no_escape, no_line_break, no_word_break
):
    """Remain in this state until 'end' is seen."""
    self.matcher_name = 'restart:' + self.matcher_name.replace('restart:','')
    i = 0
    j = self.match_span_helper(s, i, end, no_escape, no_line_break, no_word_break)
    if j == -1:
        j2 = len(s) + 1
    elif j &gt; len(s):
        j2 = j
    else:
        j2 = j + len(end)
    if delegate:
        self.colorRangeWithTag(s, i, j, kind,
            delegate=delegate, exclude_match=exclude_match)
        self.colorRangeWithTag(s, j, j2, kind,
            delegate=None, exclude_match=exclude_match)
    else:  # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s, i, j2, kind,
            delegate=None, exclude_match=exclude_match)
    j = j2
    self.trace_match(kind, s, i, j)
    if j &gt; len(s):

        def span(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate, end, exclude_match, kind,
                no_escape, no_line_break, no_word_break)

        self.setRestart(span,
            # These must be keywords args.
            delegate=delegate, end=end, kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)
    else:
        self.clearState()
    return j  # Return the new i, *not* the length of the match.
</t>
<t tx="ekr.20110605121601.18637">def colorRangeWithTag(self, s, i, j, tag, delegate='', exclude_match=False):
    """
    Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.
    """
    trace = 'coloring' in g.app.debug and not g.unitTesting
        # setTag does most tracing.
    if not self.inColorState():
        # Do *not* check x.flag here. It won't work.
        if trace: g.trace('not in color state')
        return
    self.delegate_name = delegate
    if delegate:
        if trace:
            if len(repr(s[i:j])) &lt;= 20:
                s2 = repr(s[i:j])
            else:
                s2 = repr(s[i : i + 17 - 2] + '...')
            kind_s = f"{delegate}:{tag}"
            print(
                f"\ncolorRangeWithTag: {kind_s:25} {i:3} {j:3} "
                f"{s2:&gt;20} {self.matcher_name}\n")
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 &lt;= i &lt; j and i &lt; len(s):
            progress = i
            assert j &gt;= 0, j
            for f in self.rulesDict.get(s[i], []):
                n = f(self, s, i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n &gt; 0:
                    self.matcher_name = f.__name__
                    i += n
                    break
            else:
                # Use the default chars for everything else.
                # Use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                self.setTag(default_tag or tag, s, i, i + 1)
                i += 1
            assert i &gt; progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        self.setTag(tag, s, i, j)
    if tag != 'url':
        # Allow UNL's and URL's *everywhere*.
        j = min(j, len(s))
        while i &lt; j:
            ch = s[i].lower()
            if ch == 'u':
                n = self.match_unl(s, i)
                i += max(1, n)
            elif ch in 'fh':  # file|ftp|http|https
                n = self.match_any_url(s, i)
                i += max(1, n)
            else:
                i += 1
</t>
<t tx="ekr.20110605121601.18638">tot_time = 0.0

def mainLoop(self, n, s):
    """Colorize a *single* line s, starting in state n."""
    trace = 'coloring' in g.app.debug
    t1 = time.process_time()
    f = self.restartDict.get(n)
    if trace:
        p = self.c and self.c.p
        if p and p.v != self.last_v:
            self.last_v = p.v
            f_name = f.__name__ if f else 'None'
            print('')
            g.trace(f"NEW NODE: state {n} = {f_name} {p.h}\n")
    i = f(s) if f else 0
    while i &lt; len(s):
        progress = i
        functions = self.rulesDict.get(s[i], [])
        for f in functions:
            n = f(self, s, i)
            if n is None:
                g.trace('Can not happen: n is None', repr(f))
                break
            elif n &gt; 0:  # Success. The match has already been colored.
                self.matcher_name = f.__name__  # For traces.
                i += n
                break
            elif n &lt; 0:  # Total failure.
                i += -n
                break
            else:  # Partial failure: Do not break or change i!
                pass
        else:
            i += 1
        assert i &gt; progress
    # Don't even *think* about changing state here.
    self.tot_time += time.process_time() - t1
</t>
<t tx="ekr.20110605121601.18640">def recolor(self, s):
    """
    jEdit.recolor: Recolor a *single* line, s.
    QSyntaxHighligher calls this method repeatedly and automatically.
    """
    p = self.c.p
    self.recolorCount += 1
    block_n = self.currentBlockNumber()
    n = self.prevState()
    if p.v == self.old_v:
        new_language = self.n2languageDict.get(n)
        if new_language != self.language:
            self.language = new_language
            self.init(p)
    else:
        self.updateSyntaxColorer(p)  # Force a full recolor
        assert self.language
        self.init_all_state(p.v)
        self.init(p)
    if block_n == 0:
        n = self.initBlock0()
    n = self.setState(n)  # Required.
    # Always color the line, even if colorizing is disabled.
    if s:
        self.mainLoop(n, s)
</t>
<t tx="ekr.20110605121601.18641">last_v = None

def setTag(self, tag, s, i, j):
    """Set the tag in the highlighter."""
    trace = 'coloring' in g.app.debug and not g.unitTesting
    self.n_setTag += 1
    if i == j:
        return
    wrapper = self.wrapper  # A QTextEditWrapper
    if not tag.strip():
        return
    tag = tag.lower().strip()
    # A hack to allow continuation dots on any tag.
    dots = tag.startswith('dots')
    if dots:
        tag = tag[len('dots') :]
    colorName = wrapper.configDict.get(tag)
        # This color name should already be valid.
    if not colorName:
        return
    #
    # New in Leo 5.8.1: allow symbolic color names here.
    # This now works because all keys in leo_color_database are normalized.
    colorName = colorName.replace(
        ' ', '').replace('-', '').replace('_', '').lower().strip()
    colorName = leo_color_database.get(colorName, colorName)
    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            g.trace('unknown color name', colorName, g.callers())
            return
    underline = wrapper.configUnderlineDict.get(tag)
    format = QtGui.QTextCharFormat()
    font = self.fonts.get(tag)
    if font:
        format.setFont(font)
    if tag in ('blank', 'tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setUnderlineStyle(format.SingleUnderline)
        format.setFontUnderline(True)
    elif dots or tag == 'trailing_whitespace':
        format.setForeground(color)
        format.setUnderlineStyle(format.DotLine)
    else:
        format.setForeground(color)
        format.setUnderlineStyle(format.NoUnderline)
    self.tagCount += 1
    if trace:
        # A superb trace.
        ###
            # p = self.c and self.c.p
            # if p and p.v != self.last_v:
                # print(f'\nsetTag: NEW NODE: {p.h}\n')
                # self.last_v = p.v
        if len(repr(s[i:j])) &lt;= 20:
            s2 = repr(s[i:j])
        else:
            s2 = repr(s[i : i + 17 - 2] + '...')
        kind_s = f"{self.language}.{tag}"
        kind_s2 = f"{self.delegate_name}:" if self.delegate_name else ''
        print(
            f"setTag: {kind_s:25} {i:3} {j:3} {s2:&gt;20} "
            f"{self.rulesetName}:{kind_s2}{self.matcher_name}"
        )
    self.highlighter.setFormat(i, j - i, format)
</t>
<t tx="ekr.20110605195119.16937">def createKeyEvent(self, event, c, w, ch, binding):

    return leoGui.LeoKeyEvent(
        c=self.c,
        char=ch,
            # char = None doesn't work at present.
            # But really, the binding should suffice.
        event=event,
        binding=binding,
        w=w,
        x=getattr(event, 'x', None) or 0,
        y=getattr(event, 'y', None) or 0,
        x_root=getattr(event, 'x_root', None) or 0,
        y_root=getattr(event, 'y_root', None) or 0,
    )
</t>
<t tx="ekr.20110606004638.16929">def stroke2char(self, stroke):
    """
    Convert a stroke to an (insertable) char.
    This method allows Leo to use strokes everywhere.
    """
    if not stroke:
        return ''
    if not g.isStroke(stroke):
        # vim commands pass a plain key.
        stroke = g.KeyStroke(stroke)
    return stroke.toInsertableChar()
</t>
<t tx="ekr.20110609161752.16459">def setLossage(self, ch, stroke):

    # k = self
    if ch or stroke:
        if len(g.app.lossage) &gt; 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0, (ch, stroke),)
</t>
<t tx="ekr.20111002125540.7021">def getYScrollPosition(self):
    """Get the vertical scrollbar position."""
    w = self
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setYScrollPosition(self, pos):
    """Set the position of the vertical scrollbar."""
    w = self
    if pos is None: pos = 0
    sb = w.verticalScrollBar()
    sb.setSliderPosition(pos)
</t>
<t tx="ekr.20111005081134.15543">def createMoveMarkedNode(c):
    oldRoot = c.rootPosition()
    p = oldRoot.insertAfter()
    p.h = 'Moved marked nodes'
    p.moveToRoot()
    return p
</t>
<t tx="ekr.20111010082822.15545">def getLanguageFromAncestorAtFileNode(p):
    """
    Return the language in effect from the nearest enclosing @&lt;file&gt; node:
    1. An unambiguous @language directive of the @&lt;file&gt; node.
    2. The file extension of the @&lt;file&gt; node.
    """
    v0 = p.v
        
    def find_language(p):
        # #1693: First, scan p.b for an *unambiguous* @language directive.
        if p.b.strip():
            languages = g.findAllValidLanguageDirectives(p)
            if len(languages) == 1:  # An unambiguous language
                language = languages[0]
                return language
        # Second: use the file's extension.
        if p.isAnyAtFileNode():
            name = p.anyAtFileNodeName()
            junk, ext = g.os_path_splitext(name)
            ext = ext[1:]  # strip the leading .
            language = g.app.extension_dict.get(ext)
            if g.isValidLanguage(language):
                return language
        return None

    # First, look at the direct parents.
    for p in p.self_and_parents(copy=False):
        language = find_language(p)
        if language:
            return language
    #
    # #1625: Expand the search for cloned nodes.
    seen = [] # vnodes that have already been searched.
    parents = v0.parents[:] # vnodes whose ancestors are to be searched.
    while parents:
        parent_v = parents.pop()
        if parent_v in seen:
            continue
        seen.append(parent_v)
        language = find_language(parent_v)
        if language:
            return language
        for grand_parent_v in parent_v.parents:
            if grand_parent_v not in seen:
                parents.append(grand_parent_v)
    return None
</t>
<t tx="ekr.20111015194452.15686">def onSelectItem(self, it, it_prev=None):

    c = self.c
    tgt = self.its.get(it and id(it))
    if not tgt:
        return
    # if Ctrl key is down, delete item and
    # children (based on indent) and return
    modifiers = QtWidgets.QApplication.keyboardModifiers()
    if modifiers == QtCore.Qt.ControlModifier:
        row = self.lw.row(it)
        init_indent = len(it.text()) - len(str(it.text()).lstrip())
        self.lw.blockSignals(True)
        while row &lt; self.lw.count():
            self.lw.item(row).setHidden(True)
            row += 1
            cur = self.lw.item(row)
            # #1751.
            if not cur:
                break
            s = cur.text() or ''
            indent = len(s) - len(str(s).lstrip())
            if indent &lt;= init_indent:
                break
        self.lw.setCurrentRow(row)
        self.lw.blockSignals(False)
        return
    # generic callable
    if callable(tgt):
        tgt()
    elif len(tgt) == 2:
        p, pos = tgt
        if hasattr(p,'v'): #p might be "Root"
            if not c.positionExists(p):
                g.es("Node moved or deleted.\nMaybe re-do search.",
                    color='red')
                return
            c.selectPosition(p)
            if pos is not None:
                st, en = pos
                w = c.frame.body.wrapper
                w.setSelectionRange(st,en)
                w.seeInsertPoint()
            self.lw.setFocus()
</t>
<t tx="ekr.20111028060955.16568">def getMenuEntryBindings(self, command, label):
    """Compute commandName from command."""
    c = self.c
    if isinstance(command, str):
        # Command is really a command name.
        commandName = command
    else:
        # First, get the old-style name.
        # #1121: Allow Chinese characters in command names
        commandName = label.strip()
    command = c.commandsDict.get(commandName)
    return commandName
</t>
<t tx="ekr.20111102072143.10016">def createMasterMenuCallback(self, command, commandName):
    """
    Create a callback for the given args.
    
    - If command is a string, it is treated as a command name.
    - Otherwise, it should be a callable representing the actual command.
    """
    c = self.c

    def getWidget():
        """Carefully return the widget that has focus."""
        w = c.frame.getFocus()
        if w and g.isMac:
            # Redirect (MacOS only).
            wname = c.widget_name(w)
            if wname.startswith('head'):
                w = c.frame.tree.edit_widget(c.p)
        # Return a wrapper if possible.
        if not g.isTextWrapper(w):
            w = getattr(w, 'wrapper', w)
        return w

    if isinstance(command, str):
        
        def static_menu_callback():
            event = g.app.gui.create_key_event(c, w=getWidget())
            c.doCommandByName(commandName, event)

        return static_menu_callback
        
    # The command must be a callable.
    if not callable(command):

        def dummy_menu_callback(event=None):
            pass
    
        g.trace(f"bad command: {command!r}", color='red')
        return dummy_menu_callback

    # Create a command dynamically.

    def dynamic_menu_callback():
        event = g.app.gui.create_key_event(c, w=getWidget())
        return c.doCommand(command, commandName, event)  # #1595

    return dynamic_menu_callback
</t>
<t tx="ekr.20111217154130.10285">def raise_error_dialogs(self, kind='read'):
    """Warn abouit read/write failures."""
    c = self
    use_dialogs = True
    if g.unitTesting:
        d = g.app.unitTestDict
        tag = 'raise_error_dialogs'
        d[tag] = 1 + d.get(tag, 0)
        # This trace catches all too-many-calls failures.
            # g.trace(g.callers())
        c.init_error_dialogs()
        return
    #
    # Issue one or two dialogs or messages.
    saved_body = c.rootPosition().b
        # Save the root's body. Somehow the dialog destroys it!
    if c.import_error_nodes or c.ignored_at_file_nodes or c.orphan_at_file_nodes:
        g.app.gui.dismiss_splash_screen()
    else:
        # #1007: Exit now, so we don't have to restore c.rootPosition().b.
        c.init_error_dialogs()
        return
    if c.import_error_nodes:
        files = '\n'.join(sorted(set(c.import_error_nodes)))
        if use_dialogs:
            message = (
                'The following were not imported properly. '
                f"Inserted @ignore in...\n{files}")
            g.app.gui.runAskOkDialog(c, message=message, title='Import errors')
        else:
            g.es('import errors...', color='red')
            g.es('\n'.join(sorted(files)), color='blue')
    if c.ignored_at_file_nodes:
        files = '\n'.join(sorted(set(c.ignored_at_file_nodes)))
        kind = 'read' if kind.startswith('read') else 'written'
        if use_dialogs:
            message = (
                f"The following were not {kind} "
                f"because they contain @ignore:\n{files}")
            g.app.gui.runAskOkDialog(c,
                message=message,
                title=f"Not {kind.capitalize()}")
        else:
            g.es(f"not {kind} (@ignore)...", color='red')
            g.es(files, color='blue')
    #
    # #1050: always raise a dialog for orphan @&lt;file&gt; nodes.
    if c.orphan_at_file_nodes:
        message = '\n'.join([
            'The following were not written because of errors:\n',
            '\n'.join(sorted(set(c.orphan_at_file_nodes))),
            '',
            'Warning: changes to these files will be lost\n'
            'unless you can save the files successfully.'
        ])
        g.app.gui.runAskOkDialog(c, message=message, title='Not Written')
        # Mark all the nodes dirty.
        for z in c.all_unique_positions():
            if z.isOrphan():
                z.setDirty()
                z.clearOrphan()
        c.setChanged()
        c.redraw()
    # Restore the root position's body.
    c.rootPosition().v.b = saved_body
        # #1007: just set v.b.
    c.init_error_dialogs()
</t>
<t tx="ekr.20120110174009.9965">def shouldPromptForDangerousWrite(self, fn, p):
    '''
    Return True if Leo should warn the user that p is an @&lt;file&gt; node that
    was not read during startup. Writing that file might cause data loss.
    
    See #50: https://github.com/leo-editor/leo-editor/issues/50
    '''
    trace = 'save' in g.app.debug
    sfn = g.shortFileName(fn)
    c = self.c
    efc = g.app.externalFilesController
    if p.isAtNoSentFileNode():
        # #1450.
        # No danger of overwriting a file.
        # It was never read.
        return False
    if not g.os_path_exists(fn):
        # No danger of overwriting fn.
        if trace: g.trace('Return False: does not exist:', sfn)
        return False
    # #1347: Prompt if the external file is newer.
    if efc:
        # Like c.checkFileTimeStamp.
        if c.sqlite_connection and c.mFileName == fn:
            # sqlite database file is never actually overwriten by Leo,
            # so do *not* check its timestamp.
            pass
        elif efc.has_changed(fn):
            if trace: g.trace('Return True: changed:', sfn)
            return True
    if hasattr(p.v, 'at_read'):
        # Fix bug #50: body text lost switching @file to @auto-rst
        d = p.v.at_read
        for k in d:
            # Fix bug # #1469: make sure k still exists.
            if (
                os.path.exists(k) and os.path.samefile(k, fn)
                and p.h in d.get(k, set())
            ):
                d[fn] = d[k]
                if trace: g.trace('Return False: in p.v.at_read:', sfn)
                return False
        aSet = d.get(fn, set())
        if trace:
            g.trace(f"Return {p.h not in aSet()}: p.h not in aSet(): {sfn}")
        return p.h not in aSet
    if trace:
        g.trace('Return True: never read:', sfn)
    return True  # The file was never read.
</t>
<t tx="ekr.20120112084820.10001">def rememberReadPath(self, fn, p):
    '''
    Remember the files that have been read *and*
    the full headline (@&lt;file&gt; type) that caused the read.
    '''
    v = p.v
    # Fix bug #50: body text lost switching @file to @auto-rst
    if not hasattr(v, 'at_read'):
        v.at_read = {}
    d = v.at_read
    aSet = d.get(fn, set())
    aSet.add(p.h)
    d[fn] = aSet
</t>
<t tx="ekr.20120130074511.10227">def kill_one_shortcut(self, stroke):
    """
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    """
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDict(  # was TypedDictOfLists.
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.BindingInfo,
        )
    inv_d = lm.invert(d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
</t>
<t tx="ekr.20120130074511.10228">def check_bind_key(self, commandName, pane, stroke):
    """
    Return True if the binding of stroke to commandName for the given
    pane can be made.
    """
    # k = self
    assert g.isStroke(stroke)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if stroke.lower().find(s) &gt; -1:
            g.warning('ignoring invalid key binding:', f"{commandName} = {stroke}")
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', stroke, commandName, g.callers())
        return False
    return True
</t>
<t tx="ekr.20120204061120.10067">def __repr__(self):
    return f"&lt;KeyStroke: {repr(self.s)}&gt;"

def __str__(self):
    return repr(self.s)
</t>
<t tx="ekr.20120204061120.10084">def qtMods(self, event):
    """Return the text version of the modifiers of the key event."""
    qt = QtCore.Qt
    modifiers = event.modifiers()
    mod_table = (
        (qt.AltModifier, 'Alt'),
        (qt.ControlModifier, 'Control'),
        (qt.MetaModifier, 'Meta'),
        (qt.ShiftModifier, 'Shift'),
        (qt.KeypadModifier, 'KeyPad'),
            # #1448: Replacing this by 'Key' would make separate keypad bindings impossible.
    )
    mods = [b for a, b in mod_table if (modifiers &amp; a)]
    #
    # MacOS: optionally convert Meta (Ctrl key) to Alt.
    # 945: remove @bool swap-mac-keys and @bool replace-meta-with-alt.
    # if g.isMac:
        # c = self.c
        # if c.k.replace_meta_with_alt:
            # if 'Meta' in mods:
                # mods.remove('Meta')
                # mods.append('Alt')
        # if c.k.swap_mac_keys:
            # # Swap the Command (clover) and Control keys.
            # # That is, swap the meaning of the Control and Meta modifiers.
            # if 'Meta' in mods and 'Control' not in mods:
                # mods.remove('Meta')
                # mods.append('Control')
            # elif 'Control' in mods and 'Meta' not in mods:
                # mods.remove('Control')
                # mods.append('Meta')
    return mods
</t>
<t tx="ekr.20120208064440.10179">def endMode(self):
    k = self; c = k.c
    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode')  # Changes focus to the body pane
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()  # Restores focus.
    if w:
        c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20120208064440.10190"></t>
<t tx="ekr.20120208064440.10199">def generalModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    """Handle a mode defined by an @mode node in leoSettings.leo."""
    k = self; c = k.c
    state = k.getState(modeName)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, w=k.modeWidget)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName)  # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False  # All silent modes must do --&gt; set-silent-mode.
                self.initMode(event, nextMode)  # Enter another mode.
</t>
<t tx="ekr.20120209051836.10260">def computeHomeLeoDir(self):
    # lm = self
    homeLeoDir = g.os_path_finalize_join(g.app.homeDir, '.leo')
    if g.os_path_exists(homeLeoDir):
        return homeLeoDir
    ok = g.makeAllNonExistentDirectories(homeLeoDir)
    return homeLeoDir if ok else ''  # #1450
</t>
<t tx="ekr.20120211121736.10772">def computeWorkbookFileName(self):
    """
    Return full path to the workbook.
    
    Return None if testing, or in batch mode, or if the containing
    directory does not exist.
    """
    # lm = self
    # Never create a workbook during unit tests or in batch mode.
    if g.unitTesting or g.app.batchMode:
        return None
    fn = g.app.config.getString(setting='default_leo_file') or '~/.leo/workbook.leo'
    fn = g.os_path_finalize(fn)
    directory = g.os_path_finalize(os.path.dirname(fn))
    # #1415.
    return fn if os.path.exists(directory) else None
</t>
<t tx="ekr.20120212220616.10537">def readExternalFiles(self, fileName):
    """Read all external files."""
    c, fc = self.c, self
    c.atFileCommands.readAll(c.rootPosition(), force=False)
    recoveryNode = fc.handleNodeConflicts()
    # Do this after reading external files.
    # The descendent nodes won't exist unless we have read
    # the @thin nodes!
    fc.restoreDescendentAttributes()
    fc.setPositionsFromVnodes()
    return recoveryNode
</t>
<t tx="ekr.20120214060149.15851">def __init__(self):

    #
    # Global settings &amp; shortcuts dicts...
    # The are the defaults for computing settings and shortcuts for all loaded files.
    #
    self.globalSettingsDict = None
        # A g.TypedDict: the join of settings in leoSettings.leo &amp; myLeoSettings.leo
    self.globalBindingsDict = None
        # A g.TypedDict: the join of shortcuts in leoSettings.leo &amp; myLeoSettings.leo.
    #
    # LoadManager ivars corresponding to user options...
    #
    self.files = []
        # List of files to be loaded.
    self.options = {}
        # Dictionary of user options. Keys are option names.
    self.old_argv = []
        # A copy of sys.argv for debugging.
    self.more_cmdline_files = False
        # True when more files remain on the command line to be
        # loaded.  If the user is answering "No" to each file as Leo asks
        # "file already open, open again", this must be False for
        # a complete exit to be appropriate (finish_quit=True param for
        # closeLeoWindow())
    self.theme_c = None
        # #1374.
</t>
<t tx="ekr.20120214132927.10723">def mergeShortcutsDicts(self, c, old_d, new_d, localFlag):
    """
    Create a new dict by overriding all shortcuts in old_d by shortcuts in new_d.

    Both old_d and new_d remain unchanged.
    """
    lm = self
    if not old_d: return new_d
    if not new_d: return old_d
    bi_list = new_d.get(g.app.trace_setting)
    if bi_list:
        # This code executed only if g.app.trace_setting exists.
        for bi in bi_list:
            fn = bi.kind.split(' ')[-1]
            stroke = c.k.prettyPrintKey(bi.stroke)
            if bi.pane and bi.pane != 'all':
                pane = f" in {bi.pane} panes"
            else:
                pane = ''
    inverted_old_d = lm.invert(old_d)
    inverted_new_d = lm.invert(new_d)
    # #510 &amp; #327: always honor --trace-binding here.
    if g.app.trace_binding:
        binding = g.app.trace_binding
        # First, see if the binding is for a command. (Doesn't work for plugin commands).
        if localFlag and binding in c.k.killedBindings:
            g.es_print(
                f"--trace-binding: {c.shortFileName()} "
                f"sets {binding} to None")
        elif localFlag and binding in c.commandsDict:
             d = c.k.computeInverseBindingDict()
             g.trace(
                f"--trace-binding: {c.shortFileName():20} "
                f"binds {binding} to {d.get(binding) or []}")
        else:
            binding = g.app.trace_binding
            stroke = g.KeyStroke(binding)
            bi_list = inverted_new_d.get(stroke)
            if bi_list:
                print('')
                for bi in bi_list:
                    fn = bi.kind.split(' ')[-1]  # bi.kind #
                    stroke2 = c.k.prettyPrintKey(stroke)
                    if bi.pane and bi.pane != 'all':
                        pane = f" in {bi.pane} panes"
                    else:
                        pane = ''
                    g.es_print(
                        f"--trace-binding: {fn:20} binds {stroke2} "
                        f"to {bi.commandName:&gt;20}{pane}")
                print('')
    # Fix bug 951921: check for duplicate shortcuts only in the new file.
    lm.checkForDuplicateShortcuts(c, inverted_new_d)
    inverted_old_d.update(inverted_new_d)  # Updates inverted_old_d in place.
    result = lm.uninvert(inverted_old_d)
    return result
</t>
<t tx="ekr.20120214132927.10724">def invert(self, d):
    """
    Invert a shortcut dict whose keys are command names,
    returning a dict whose keys are strokes.
    """
    result = g.TypedDict(  # was TypedDictOfLists.
        name=f"inverted {d.name()}",
        keyType=g.KeyStroke,
        valType=g.BindingInfo,
    )
    for commandName in d.keys():
        for bi in d.get(commandName, []):
            stroke = bi.stroke  # This is canonicalized.
            bi.commandName = commandName  # Add info.
            assert stroke
            result.add_to_list(stroke, bi)
    return result
</t>
<t tx="ekr.20120214132927.10725">def uninvert(self, d):
    """
    Uninvert an inverted shortcut dict whose keys are strokes,
    returning a dict whose keys are command names.
    """
    assert d.keyType == g.KeyStroke, d.keyType
    result = g.TypedDict(  # was TypedDictOfLists.
        name=f"uninverted {d.name()}",
        keyType=type('commandName'),
        valType=g.BindingInfo,
    )
    for stroke in d.keys():
        for bi in d.get(stroke, []):
            commandName = bi.commandName
            assert commandName
            result.add_to_list(commandName, bi)
    return result
</t>
<t tx="ekr.20120215072959.12475">def set(self, p, kind, name, val, warn=True):
    """
    Init the setting for name to val.
    
    The "p" arg is not used.
    """
    c = self.c
    # Note: when kind is 'shortcut', name is a command name.
    key = g.app.config.munge(name)
    d = self.settingsDict
    assert isinstance(d, g.TypedDict), repr(d)
    gs = d.get(key)
    if gs:
        assert isinstance(gs, g.GeneralSetting), repr(gs)
        path = gs.path
        if warn and g.os_path_finalize(
            c.mFileName) != g.os_path_finalize(path):  # #1341.
            g.es("over-riding setting:", name, "from", path)
    d[key] = g.GeneralSetting(kind, path=c.mFileName, val=val, tag='setting')
</t>
<t tx="ekr.20120217070122.10479">def reloadSettings(self):
    # Part 1: These were in the ctor.
    c = self.c
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter = getBool('enable-autocompleter-initially')
    self.enable_calltips = getBool('enable-calltips-initially')
    self.ignore_unbound_non_ascii_keys = getBool('ignore-unbound-non-ascii-keys')
    self.minibuffer_background_color = getColor(
        'minibuffer-background-color') or 'lightblue'
    self.minibuffer_foreground_color = getColor(
        'minibuffer-foreground-color') or 'black'
    self.minibuffer_warning_color = getColor(
        'minibuffer-warning-color') or 'lightgrey'
    self.minibuffer_error_color = getColor('minibuffer-error-color') or 'red'
    self.replace_meta_with_alt = getBool('replace-meta-with-alt')
    self.warn_about_redefined_shortcuts = getBool('warn-about-redefined-shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings = c.config.getBool('enable-alt-ctrl-bindings')
    # Part 2: These were in finishCreate.
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body-text-background-color') or 'white'
    fg = c.config.getColor('body-text-foreground-color') or 'black'
    self.command_mode_bg_color = getColor('command-mode-bg-color') or bg
    self.command_mode_fg_color = getColor('command-mode-fg-color') or fg
    self.insert_mode_bg_color = getColor('insert-mode-bg-color') or bg
    self.insert_mode_fg_color = getColor('insert-mode-fg-color') or fg
    self.overwrite_mode_bg_color = getColor('overwrite-mode-bg-color') or bg
    self.overwrite_mode_fg_color = getColor('overwrite-mode-fg-color') or fg
    self.unselected_body_bg_color = getColor('unselected-body-bg-color') or bg
    self.unselected_body_fg_color = getColor('unselected-body-fg-color') or bg
</t>
<t tx="ekr.20120219154958.10452">def load(self, fileName=None, pymacs=None):
    """This is Leo's main startup method."""
    lm = self
    #
    # Phase 1: before loading plugins.
    # Scan options, set directories and read settings.
    t1 = time.process_time()
    print('')  # Give some separation for the coming traces.
    if not lm.isValidPython():
        return
    lm.doPrePluginsInit(fileName, pymacs)
        # sets lm.options and lm.files
    g.app.computeSignon()
    g.app.printSignon()
    if lm.options.get('version'):
        return
    if not g.app.gui:
        return
    g.app.disable_redraw = True
        # Disable redraw until all files are loaded.
    #
    # Phase 2: load plugins: the gui has already been set.
    t2 = time.process_time()
    g.doHook("start1")
    t3 = time.process_time()
    if g.app.killed:
        return
    g.app.idleTimeManager.start()
    #
    # Phase 3: after loading plugins. Create one or more frames.
    t3 = time.process_time()
    if lm.options.get('script') and not self.files:
        ok = True
    else:
        ok = lm.doPostPluginsInit()
        # Fix #579: Key bindings don't take for commands defined in plugins
        g.app.makeAllBindings()
        if ok and g.app.diff:
            lm.doDiff()
    if not ok:
        return
    g.es('')  # Clears horizontal scrolling in the log pane.
    if g.app.listen_to_log_flag:
        g.app.listenToLog()
    if 'startup' in g.app.debug:
        t4 = time.process_time()
        print('')
        g.es_print(f"settings:{t2 - t1:5.2f} sec")
        g.es_print(f" plugins:{t3 - t2:5.2f} sec")
        g.es_print(f"   files:{t4 - t3:5.2f} sec")
        g.es_print(f"   total:{t4 - t1:5.2f} sec")
        print('')
    # #1128: support for restart-leo.
    if not g.app.start_minimized:
        try: # Careful: we may be unit testing.
            g.app.log.c.frame.bringToFront()
        except Exception:
            pass
    g.app.gui.runMainLoop()
    # For scripts, the gui is a nullGui.
    # and the gui.setScript has already been called.
</t>
<t tx="ekr.20120219154958.10477">def doPrePluginsInit(self, fileName, pymacs):
    """ Scan options, set directories and read settings."""
    lm = self
    lm.computeStandardDirectories()
    lm.adjustSysPath()
        # A do-nothing.
    # Scan the options as early as possible.
    lm.options = options = lm.scanOptions(fileName, pymacs)
        # also sets lm.files.
    if options.get('version'):
        return
    script = options.get('script')
    verbose = script is None
    # Init the app.
    lm.initApp(verbose)
    g.app.setGlobalDb()
    lm.reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    lm.readGlobalSettingsFiles()
        # reads only standard settings files, using a null gui.
        # uses lm.files[0] to compute the local directory
        # that might contain myLeoSettings.leo.
    # Read the recent files file.
    localConfigFile = lm.files[0] if lm.files else None
    g.app.recentFilesManager.readRecentFiles(localConfigFile)
    # Create the gui after reading options and settings.
    lm.createGui(pymacs)
    # We can't print the signon until we know the gui.
    g.app.computeSignon()  # Set app.signon/signon1 for commanders.
</t>
<t tx="ekr.20120219154958.10478">def createGui(self, pymacs):
    lm = self
    gui_option = lm.options.get('gui')
    windowFlag = lm.options.get('windowFlag')
    script = lm.options.get('script')
    if g.app.gui:
        if g.app.gui == g.app.nullGui:
            g.app.gui = None  # Enable g.app.createDefaultGui
            g.app.createDefaultGui(__file__)
        else:
            pass
            # This can happen when launching Leo from IPython.
            # This can also happen when leoID does not exist.
    elif gui_option is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        lm.createSpecialGui(gui_option, pymacs, script, windowFlag)
</t>
<t tx="ekr.20120219154958.10479">def createSpecialGui(self, gui, pymacs, script, windowFlag):
    # lm = self
    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.args = []
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        g.app.createDefaultGui()
</t>
<t tx="ekr.20120219154958.10480">def adjustSysPath(self):
    """
    Adjust sys.path to enable imports as usual with Leo.

    This method is no longer needed:
    """
    pass
</t>
<t tx="ekr.20120219154958.10482">def getDefaultFile(self):
    # Get the name of the workbook.
    fn = g.app.config.getString('default-leo-file')
    fn = g.os_path_finalize(fn)
    if not fn:
        return None
    if g.os_path_exists(fn):
        return fn
    if g.os_path_isabs(fn):
        # Create the file.
        g.error(f"Using default leo file name:\n{fn}")
        return fn
    # It's too risky to open a default file if it is relative.
    return None
</t>
<t tx="ekr.20120219154958.10483">def computeFilesList(self, options, fileName):
    """Return the list of files on the command line."""
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = g.glob_glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return [g.os_path_normslashes(z) for z in result]
</t>
<t tx="ekr.20120219154958.10484">def initApp(self, verbose):

    self.createAllImporterData()
        # Can be done early. Uses only g.app.loadDir
    assert g.app.loadManager
    from leo.core import leoBackground
    from leo.core import leoConfig
    from leo.core import leoNodes
    from leo.core import leoPlugins
    from leo.core import leoSessions
    # Import leoIPython only if requested.  The import is quite slow.
    self.setStdStreams()
    if g.app.useIpython:
        from leo.core import leoIPython
            # This launches the IPython Qt Console.  It *is* required.
        assert leoIPython  # suppress pyflakes/flake8 warning.
    # Make sure we call the new leoPlugins.init top-level function.
    leoPlugins.init()
    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    # Create early classes *after* doing plugins.init()
    g.app.idleTimeManager = IdleTimeManager()
    g.app.backgroundProcessManager = leoBackground.BackgroundProcessManager()
    g.app.externalFilesController = leoExternalFiles.ExternalFilesController()
    g.app.recentFilesManager = RecentFilesManager()
    g.app.config = leoConfig.GlobalConfigManager()
    g.app.nodeIndices = leoNodes.NodeIndices(g.app.leoID)
    g.app.sessionManager = leoSessions.SessionManager()
    # Complete the plugins class last.
    g.app.pluginsController.finishCreate()
</t>
<t tx="ekr.20120219154958.10486">def scanOptions(self, fileName, pymacs):
    """Handle all options, remove them from sys.argv and set lm.options."""
    lm = self
    table = (
        '--dock',
        '--global-docks',  # #1643. use --use-docks instead.
        '--init-docks',
        '--no-cache',
        '--no-dock',  # #1171 and #1514: use --use-docks instead.
        '--session-restore',
        '--session-save',
        '--use-docks',
    )
    trace_m = '''abbrev,beauty,cache,coloring,drawing,events,focus,
      git,gnx,importers,ipython,keys,layouts,plugins,save,
      select,shutdown,size,startup,themes,undo,verbose,zoom'''
    for bad_option in table:
        if bad_option in sys.argv:
            sys.argv.remove(bad_option)
            print(f"Ignoring the unused/deprecated {bad_option} option")
    lm.old_argv = sys.argv[:]
    parser = optparse.OptionParser(
        usage="usage: launchLeo.py [options] file1, file2, ...")
        # Automatically implements the --help option.
    #
    # Parse the options, and remove them from sys.argv.
    self.addOptionsToParser(parser, trace_m)
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]]
    sys.argv.extend(args)
    # Handle simple args...
    self.doSimpleOptions(options, trace_m)
    # Compute the lm.files ivar.
    lm.files = lm.computeFilesList(options, fileName)
    script = None if pymacs else self.doScriptOption(options, parser)
    d = {
        'gui': lm.doGuiOption(options),
        'load_type': lm.doLoadTypeOption(options),
        'screenshot_fn': lm.doScreenShotOption(options),
            # --screen-shot=fn
        'script': script,
        'select': options.select and options.select.strip('"'),
            # --select=headline
        'theme_path': options.theme,
            # --theme=name
        'version': options.version,
            # --version: print the version and exit.
        'windowFlag': script and options.script_window,
        'windowSize': lm.doWindowSizeOption(options),
        'windowSpot': lm.doWindowSpotOption(options),
    }
    return d
</t>
<t tx="ekr.20120219154958.10487">def doPostPluginsInit(self):
    """Create a Leo window for each file in the lm.files list."""
    # Clear g.app.initing _before_ creating commanders.
    lm = self
    g.app.initing = False  # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.Show it and all queued messages.
    c = c1 = fn = None
    if lm.files:
        try:  # #1403.
            for n, fn in enumerate(lm.files):
                lm.more_cmdline_files = n &lt; len(lm.files) - 1
                c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
                    # Returns None if the file is open in another instance of Leo.
                if c and not c1:  # #1416:
                    c1 = c
        except Exception:
            g.es_print(f"Unexpected exception reading {fn!r}")
            g.es_exception()
            c = None
    # Load (and save later) a session *only* if the command line contains no files.
    g.app.loaded_session = not lm.files
    if g.app.sessionManager and g.app.loaded_session:
        try:  # #1403.
            aList = g.app.sessionManager.load_snapshot()
            if aList:
                g.app.sessionManager.load_session(c1, aList)
                # #659.
                if g.app.windowList:
                    c = c1 = g.app.windowList[0].c
                else:
                    c = c1 = None
        except Exception:
            g.es_print('Can not load session')
            g.es_exception()
    # Enable redraws.
    g.app.disable_redraw = False
    if not c1:
        try:  # #1403.
            c1 = lm.openEmptyWorkBook()
                # Calls LM.loadLocalFile.
        except Exception:
            g.es_print('Can not create empty workbook')
            g.es_exception()
    c = c1
    if not c:
        # Leo is out of options: Force an immediate exit.
        return False
    # #199.
    g.app.runAlreadyOpenDialog(c1)
    #
    # Final inits...
    # For qt gui, select the first-loaded tab.
    if hasattr(g.app.gui, 'frameFactory'):
        factory = g.app.gui.frameFactory
        if factory and hasattr(factory, 'setTabForCommander'):
            factory.setTabForCommander(c)
    g.app.logInited = True
    g.app.initComplete = True
    c.setLog()
    c.redraw()
    g.doHook("start2", c=c, p=c.p, fileName=c.fileName())
    c.initialFocusHelper()
    screenshot_fn = lm.options.get('screenshot_fn')
    if screenshot_fn:
        lm.make_screen_shot(screenshot_fn)
        return False  # Force an immediate exit.
    return True
</t>
<t tx="ekr.20120219154958.10489">def make_screen_shot(self, fn):
    """Create a screenshot of the present Leo outline and save it to path."""
    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
</t>
<t tx="ekr.20120219154958.10491">def isValidPython(self):
    if sys.platform == 'cli':
        return True
    message = (
        f"Leo requires Python {g.minimum_python_version} or higher"
        f"You may download Python from http://python.org/download/")
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0, 1, 2)])
        ok = g.CheckVersion(version, g.minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                d = g.EmergencyDialog(
                    title='Python Version Error',
                    message=message)
                d.run()
            except Exception:
                g.es_exception()
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
</t>
<t tx="ekr.20120219154958.10499">def run(fileName=None, pymacs=None, *args, **keywords):
    """Initialize and run Leo"""
    # #1403: sys.excepthook doesn't help.
    # sys.excepthook = leo_excepthook
    assert g.app
    g.app.loadManager = leoApp.LoadManager()
    g.app.loadManager.load(fileName, pymacs)
</t>
<t tx="ekr.20120222103014.10314">def config_iter(self, c):
    """Letters:
      leoSettings.leo
    D default settings
    F loaded .leo File
    M myLeoSettings.leo
    @ @button, @command, @mode.
    """
    lm = g.app.loadManager
    d = c.config.settingsDict if c else lm.globalSettingsDict
    limit = c.config.getInt('print-settings-at-data-limit')
    if limit is None:
        limit = 20  # A resonable default.
    # pylint: disable=len-as-condition
    for key in sorted(list(d.keys())):
        gs = d.get(key)
        assert isinstance(gs, g.GeneralSetting), repr(gs)
        if gs and gs.kind:
            letter = lm.computeBindingLetter(c, gs.path)
            val = gs.val
            if gs.kind == 'data':
                # #748: Remove comments
                aList = [' ' * 8 + z.rstrip() for z in val
                    if z.strip() and not z.strip().startswith('#')]
                if not aList:
                    val = '[]'
                elif limit == 0 or len(aList) &lt; limit:
                    val = '\n    [\n' + '\n'.join(aList) + '\n    ]'
                    # The following doesn't work well.
                    # val = g.objToString(aList, indent=' '*4)
                else:
                    val = f"&lt;{len(aList)} non-comment lines&gt;"
            elif isinstance(val, str) and val.startswith('&lt;?xml'):
                val = '&lt;xml&gt;'
            key2 = f"@{gs.kind:&gt;6} {key}"
            yield key2, val, c, letter
</t>
<t tx="ekr.20120223062418.10393">def loadLocalFile(self, fn, gui, old_c):
    """Completely read a file, creating the corresonding outline.

    1. If fn is an existing .leo file (possibly zipped), read it twice:
    the first time with a NullGui to discover settings,
    the second time with the requested gui to create the outline.

    2. If fn is an external file:
    get settings from the leoSettings.leo and myLeoSetting.leo, then
    create a "wrapper" outline continain an @file node for the external file.

    3. If fn is empty:
    get settings from the leoSettings.leo and myLeoSetting.leo or default settings,
    or open an empty outline.
    """
    lm = self
    # Step 0: Return if the file is already open.
    fn = g.os_path_finalize(fn)
    if fn:
        c = lm.findOpenFile(fn)
        if c:
            return c
    # Step 1: get the previous settings.
    # For .leo files (and zipped .leo files) this pre-reads the file in a null gui.
    # Otherwise, get settings from leoSettings.leo, myLeoSettings.leo, or default settings.
    previousSettings = lm.getPreviousSettings(fn)
    # Step 2: open the outline in the requested gui.
    # For .leo files (and zipped .leo file) this opens the file a second time.
    c = lm.openFileByName(fn, gui, old_c, previousSettings)
    return c
</t>
<t tx="ekr.20120223062418.10394">def openFileByName(self, fn, gui, old_c, previousSettings):
    """Read the local file whose full path is fn using the given gui.
    fn may be a Leo file (including .leo or zipped file) or an external file.

    This is not a pre-read: the previousSettings always exist and
    the commander created here persists until the user closes the outline.

    Reads the entire outline if fn exists and is a .leo file or zipped file.
    Creates an empty outline if fn is a non-existent Leo file.
    Creates an wrapper outline if fn is an external file, existing or not.
    """
    lm = self
    # Disable the log.
    g.app.setLog(None)
    g.app.lockLog()
    # Create the a commander for the .leo file.
    # Important.  The settings don't matter for pre-reads!
    # For second read, the settings for the file are *exactly* previousSettings.
    c = g.app.newCommander(fileName=fn, gui=gui, previousSettings=previousSettings)
    # Open the file, if possible.
    g.doHook('open0')
    theFile = lm.openLeoOrZipFile(fn)
    if isinstance(theFile, sqlite3.Connection):
        # this commander is associated with sqlite db
        c.sqlite_connection = theFile
    # Enable the log.
    g.app.unlockLog()
    c.frame.log.enable(True)
    # Phase 2: Create the outline.
    g.doHook("open1", old_c=None, c=c, new_c=c, fileName=fn)
    if theFile:
        readAtFileNodesFlag = bool(previousSettings)
        # The log is not set properly here.
        ok = lm.readOpenedLeoFile(c, fn, readAtFileNodesFlag, theFile)
            # Call c.fileCommands.openLeoFile to read the .leo file.
        if not ok: return None
    else:
        # Create a wrapper .leo file if:
        # a) fn is a .leo file that does not exist or
        # b) fn is an external file, existing or not.
        lm.initWrapperLeoFile(c, fn)
    g.doHook("open2", old_c=None, c=c, new_c=c, fileName=fn)
    # Phase 3: Complete the initialization.
    g.app.writeWaitingLog(c)
    c.setLog()
    lm.createMenu(c, fn)
    lm.finishOpen(c)
    return c
</t>
<t tx="ekr.20120223062418.10405">def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
            # c.enableMenuBar()
</t>
<t tx="ekr.20120223062418.10406">def findOpenFile(self, fn):

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # Don't call frame.bringToFront(), it breaks --minimize
            c.setLog()
            # Selecting the new tab ensures focus is set.
            master = getattr(frame.top, 'leo_master', None)
            if master:  # master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
</t>
<t tx="ekr.20120223062418.10407">def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # #181: Honor focus requests.
</t>
<t tx="ekr.20120223062418.10408">def initWrapperLeoFile(self, c, fn):
    """
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    """
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    # #1570: Resize the _new_ frame.
    frame.splitVerticalFlag, r1, r2 = frame.initialRatios()
    frame.resizePanesToRatio(r1, r2)
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        # Fix #1070: Use "newHeadline", not fn.
        p.h = "newHeadline" if fn.endswith('.leo') else f"@edit {fn}"
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None)  # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @&lt;file&gt; node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString(f"{load_type} {fn}")
            c.refreshFromDisk()
            c.selectPosition(p)

    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else f"{fn}.leo"
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use-chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.clearChanged()
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
</t>
<t tx="ekr.20120223062418.10410">def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        s = g.toUnicode(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
</t>
<t tx="ekr.20120223062418.10412">def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = g.os_path_finalize(g.os_path_dirname(fn))  # 1341
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=False)
            # #970: Never close Leo here.
    return ok
</t>
<t tx="ekr.20120223062418.10416">def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
</t>
<t tx="ekr.20120223062418.10419">def isLeoFile(self, fn):
    return fn and (
        zipfile.is_zipfile(fn) or fn.endswith('.leo') or fn.endswith('.db'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
</t>
<t tx="ekr.20120224161905.10030">def openLeoOrZipFile(self, fn):
    lm = self
    if fn.endswith('.db'):
        return sqlite3.connect(fn)
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
</t>
<t tx="ekr.20120304214900.9940">def onCurrentChanged(self, idx):

    tabw = self.tabWidget
    w = tabw.widget(idx)
    #
    # #917814: Switching Log Pane tabs is done incompletely
    wrapper = getattr(w, 'leo_log_wrapper', None)
    #
    # #1161: Don't change logs unless the wrapper is correct.
    if wrapper and isinstance(wrapper, qt_text.QTextEditWrapper):
        self.logCtrl = wrapper
</t>
<t tx="ekr.20120309073937.9878"></t>
<t tx="ekr.20120309075544.9881">def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict)
        val = ext not in keys
    return val
</t>
<t tx="ekr.20120309075544.9882">def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) &gt; 3:  # Don't just strip off c:\.
        p.h = abs_fn[len(prefix) :].strip()
    else:
        p.h = f"@url file://{fn}"
</t>
<t tx="ekr.20120311070142.9904">def checkForDuplicateShortcuts(self, c, d):
    """
    Check for duplicates in an "inverted" dictionary d
    whose keys are strokes and whose values are lists of BindingInfo nodes.

    Duplicates happen only if panes conflict.
    """
    # lm = self
    # Fix bug 951921: check for duplicate shortcuts only in the new file.
    for ks in sorted(list(d.keys())):
        duplicates, panes = [], ['all']
        aList = d.get(ks)
            # A list of bi objects.
        aList2 = [z for z in aList if not z.pane.startswith('mode')]
        if len(aList) &gt; 1:
            for bi in aList2:
                if bi.pane in panes:
                    duplicates.append(bi)
                else:
                    panes.append(bi.pane)
        if duplicates:
            bindings = list(set([z.stroke.s for z in duplicates]))
            if len(bindings) == 1:
                kind = 'duplicate, (not conflicting)'
            else:
                kind = 'conflicting'
            g.es_print(f"{kind} key bindings in {c.shortFileName()}")
            for bi in aList2:
                g.es_print(f"{bi.pane:6} {bi.stroke.s} {bi.commandName}")
</t>
<t tx="ekr.20120320053907.9776">def computeFileUrl(fn, c=None, p=None):
    """
    Compute finalized url for filename fn.
    """
    # First, replace special characters (especially %20, by their equivalent).
    url = urllib.parse.unquote(fn)
    # Finalize the path *before* parsing the url.
    i = url.find('~')
    if i &gt; -1:
        # Expand '~'.
        path = url[i:]
        path = g.os_path_expanduser(path)
        # #1338: This is way too dangerous, and a serious security violation.
            # path = g.os_path_expandExpression(path, c=c)
        path = g.os_path_finalize(path)
        url = url[:i] + path
    else:
        tag = 'file://'
        tag2 = 'file:///'
        if sys.platform.startswith('win') and url.startswith(tag2):
            path = url[len(tag2) :].lstrip()
        elif url.startswith(tag):
            path = url[len(tag) :].lstrip()
        else:
            path = url
        # #1338: This is way too dangerous, and a serious security violation.
            # path = g.os_path_expandExpression(path, c=c)
        # Handle ancestor @path directives.
        if c and c.openDirectory:
            base = c.getNodePath(p)
            path = g.os_path_finalize_join(c.openDirectory, base, path)
        else:
            path = g.os_path_finalize(path)
        url = f"{tag}{path}"
    return url
</t>
<t tx="ekr.20120420054855.14248">def load_snapshot(self):
    """
    Load a snapshot of a session from the leo.session file.

    Called when --restore-session is in effect.
    """
    fn = self.path
    if fn and g.os_path_exists(fn):
        try:
            with open(fn) as f:
                session = json.loads(f.read())
            return session
        except Exception:
            pass
    #
    # #1107: No need for this message.
        # print('can not load session: no leo.session file')
    return None
</t>
<t tx="ekr.20120427064024.10064">def checkForOpenFile(self, c, fn):
    """Warn if fn is already open and add fn to already_open_files list."""
    d, tag = g.app.db, 'open-leo-files'
    if g.app.reverting:
        # #302: revert to saved doesn't reset external file change monitoring
        g.app.already_open_files = []
    if (d is None or
        g.app.unitTesting or
        g.app.batchMode or
        g.app.reverting or
        g.app.inBridge
    ):
        return
    # #1519: check os.path.exists.
    aList = g.app.db.get(tag) or []
    if [x for x in aList if os.path.exists(x) and os.path.samefile(x, fn)]:
        # The file may be open in another copy of Leo, or not:
        # another Leo may have been killed prematurely.
        # Put the file on the global list.
        # A dialog will warn the user such files later.
        if fn not in g.app.already_open_files:
            g.es('may be open in another Leo:', color='red')
            g.es(fn)
            g.app.already_open_files.append(fn)
    else:
        g.app.rememberOpenFile(fn)
</t>
<t tx="ekr.20120427064024.10065">def rememberOpenFile(self, fn):

    #
    # Do not call g.trace, etc. here.
    d, tag = g.app.db, 'open-leo-files'
    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        pass
    elif g.app.preReadFlag:
        pass
    else:
        aList = d.get(tag) or []
        # It's proper to add duplicates to this list.
        aList.append(fn)
        d[tag] = aList
</t>
<t tx="ekr.20120427064024.10066">def forgetOpenFile(self, fn, force=False):
    """Forget the open file, so that is no longer considered open."""
    trace = 'shutdown' in g.app.debug
    d, tag = g.app.db, 'open-leo-files'
    if not d or not fn:
        # #69.
        return
    if not force and (
        d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting):
        return
    aList = d.get(tag) or []
    if fn in aList:
        aList.remove(fn)
        if trace:
            g.pr(f"forgetOpenFile: {g.shortFileName(fn)}")
        d[tag] = aList
    # elif trace: g.pr(f"forgetOpenFile: did not remove: {fn}")
</t>
<t tx="ekr.20120427064024.10068"></t>
<t tx="ekr.20120520174745.9867">@cmd('show-buttons')
def printButtons(self, event=None):
    """Print all @button and @command commands, their bindings and their source."""
    k = self; c = k.c
    tabName = '@buttons &amp;&amp; @commands'
    c.frame.log.clearTab(tabName)

    def put(s):
        g.es('', s, tabName=tabName)

    data = []
    for aList in [c.config.getButtons(), c.config.getCommands()]:
        for z in aList:
            p, script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h, tag),)
    for aList in [g.app.config.atLocalButtonsList, g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h, 'L'),)
    result = [f"{z[1]} {z[0]}" for z in sorted(data)]
    result.extend([
        '',
        'legend:',
        'G leoSettings.leo',
        'L local .leo File',
        'M myLeoSettings.leo',
    ])
    put('\n'.join(result))
</t>
<t tx="ekr.20120925061642.13506">def onSliderChanged(self, arg):
    """Handle a Qt onSliderChanged event."""
    c = self.leo_c
    p = c.p
    # Careful: changing nodes changes the scrollbars.
    if hasattr(c.frame.tree, 'tree_select_lockout'):
        if c.frame.tree.tree_select_lockout:
            return
    # Only scrolling in the body pane should set v.scrollBarSpot.
    if not c.frame.body or self != c.frame.body.wrapper.widget:
        return
    if p:
        p.v.scrollBarSpot = arg
</t>
<t tx="ekr.20120928142052.10116" annotate="7d71002e">def actualColor(color):
    """Return the actual color corresponding to the requested color."""
    c = g.app.log and g.app.log.c
    # Careful: c.config may not yet exist.
    if not c or not c.config:
        return color
    # Don't change absolute colors.
    if color and color.startswith('#'):
        return color
    # #788: Translate colors to theme-defined colors.
    if color is None:
        # Prefer text_foreground_color'
        color2 = c.config.getColor('log-text-foreground-color')
        if color2: return color2
        # Fall back to log_black_color.
        color2 = c.config.getColor('log-black-color')
        return color2 or 'black'
    if color == 'black':
        # Prefer log_black_color.
        color2 = c.config.getColor('log-black-color')
        if color2: return color2
        # Fall back to log_text_foreground_color.
        color2 = c.config.getColor('log-text-foreground-color')
        return color2 or 'black'
    color2 = c.config.getColor(f"log_{color}_color")
    return color2 or color
</t>
<t tx="ekr.20121126102050.10134"></t>
<t tx="ekr.20130823083943.12615">def __init__(self, c, kind,
    # force_at_others = False, #tag:no-longer-used
    add_context=None,  # Override setting only if True/False
    add_file_context=None,  # Override setting only if True/False
    add_path=True,
    recursive=True,
    safe_at_file=True,
    theTypes=None,
    ignore_pattern=None,
):
    """Ctor for RecursiveImportController class."""
    self.c = c
    self.add_path = add_path
    self.file_pattern = re.compile(r'^(([@])+(auto|clean|edit|file|nosent))')
    self.kind = kind
        # in ('@auto', '@clean', '@edit', '@file', '@nosent')
    # self.force_at_others = force_at_others #tag:no-longer-used
    self.recursive = recursive
    self.root = None
    self.safe_at_file = safe_at_file
    self.theTypes = theTypes
    self.ignore_pattern = ignore_pattern or re.compile(r'\.git|node_modules')
    # #1605:

    def set_bool(setting, val):
        if val not in (True, False):
            return
        c.config.set(None, 'bool', setting, val, warn=True)
        
    set_bool('add-context-to-headlines', add_context)
    set_bool('add-file-context-to-headlines', add_file_context)
</t>
<t tx="ekr.20130924035029.12741">def initOneAbbrev(self, commandName, key):
    """Enter key as an abbreviation for commandName in c.commandsDict."""
    c = self.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s', key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            c.commandsDict[key] = func
        else:
            g.warning('bad abbrev:', key, 'unknown command name:', commandName)
</t>
<t tx="ekr.20130927050813.13031"></t>
<t tx="ekr.20130930062914.15996">def new_qt_console(self, event=None):
    """
    Start a new qtconsole connected to our kernel.
    
    Called from qt_gui.runWithIpythonKernel.
    """
    trace = 'ipython' in g.app.debug
    console = None
    if not self.namespace.get('_leo'):
        self.namespace['_leo'] = LeoNameSpace()
    if trace:
        self.put_log('new_qt_console: connecting...')
        self.put_log(self.kernelApp.connection_file, raw=True)
    try:
        # #213: leo --ipython fails to connect with python3.5 and jupyter
        #
        # The connection file has the form kernel-nnn.json.
        # Using the defaults lets connect_qtconsole find the .json file.
        console = connect_qtconsole()
            # ipykernel.connect.connect_qtconsole
        if console:
            if trace: g.trace('console:', console)
            self.consoles.append(console)
        else:
            self.put_warning('new_qt_console: no console!')
    except OSError as e:
        # Print statements do not work here.
        self.put_warning('new_qt_console: failed to connect to console')
        self.put_warning(e, raw=True)
    except Exception as e:
        self.put_warning('new_qt_console: unexpected exception')
        self.put_warning(e)
    return console
</t>
<t tx="ekr.20130930062914.15998">def cleanup_consoles(self, event=None):
    """Kill all ipython consoles.  Called from app.finishQuit."""
    trace = 'ipython' in g.app.debug
    for console in self.consoles:
        # console is a process returned by the Python subprocess module.
        if trace: g.trace('kill', console)
        # #1677: neither console.kill nor console.kill works!
        # console.terminate()  
        console.kill()
</t>
<t tx="ekr.20131016032805.16721" annotate="7d71002e">def execute_shell_commands(commands, trace=False):
    """
    Execute each shell command in a separate process.
    Wait for each command to complete, except those starting with '&amp;'
    """
    if isinstance(commands, str):
        commands = [commands]
    for command in commands:
        wait = not command.startswith('&amp;')
        if trace: g.trace(command)
        if command.startswith('&amp;'):
            command = command[1:].strip()
        proc = subprocess.Popen(command, shell=True)
        if wait:
            proc.communicate()
        else:
            if trace: print('Start:', proc)
            # #1489: call proc.poll at idle time.

            def proc_poller(timer, proc=proc):
                val = proc.poll()
                if val is not None:
                    # This trace can be disruptive.
                    if trace: print('  End:', proc, val)
                    timer.stop()

            g.IdleTime(proc_poller, delay=0).start()
</t>
<t tx="ekr.20131017100903.16689">def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState()  # Bug fix.
        if last.isdigit():
            # Special case: for the number Easter Egg.
            c.goToLineNumber(int(last))
        else:
            c.commandsDict[last](event)
    else:
        k.keyboardQuit()
</t>
<t tx="ekr.20131017174814.17480">def shouldBeExpanded(self, p):
    """Return True if the node at position p should be expanded."""
    c, v = self, p.v
    if not p.hasChildren():
        return False
    # Always clear non-existent positions.
    v.expandedPositions = [z for z in v.expandedPositions if c.positionExists(z)]
    if not p.isCloned():
        # Do not call p.isExpanded here! It calls this method.
        return p.v.isExpanded()
    if p.isAncestorOf(c.p):
        return True
    for p2 in v.expandedPositions:
        if p == p2:
            return True
    return False
</t>
<t tx="ekr.20131028155339.17098">def openEmptyWorkBook(self):
    """Open an empty frame and paste the contents of CheatSheet.leo into it."""
    lm = self
    # Create an empty frame.
    fn = lm.computeWorkbookFileName()
    if not fn:
        return None  # #1415
    c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
    if not c:
        return None  # #1201: AttributeError below.
    # Open the cheatsheet, but not in batch mode.
    if not g.app.batchMode and not g.os_path_exists(fn):
        # #933: Save clipboard.
        old_clipboard = g.app.gui.getTextFromClipboard()
        # Paste the contents of CheetSheet.leo into c.
        c2 = c.openCheatSheet(redraw=False)
        if c2:
            for p2 in c2.rootPosition().self_and_siblings():
                c2.setCurrentPosition(p2)  # 1380
                c2.copyOutline()
                p = c.pasteOutline()
                # #1380 &amp; #1381: Add guard &amp; use vnode methods to prevent redraw.
                if p:
                    c.setCurrentPosition(p)  # 1380
                    p.v.contract()
                    p.v.clearDirty()
            c2.close(new_c=c)
            # Delete the dummy first node.
            root = c.rootPosition()
            root.doDelete(newNode=root.next())
            c.target_language = 'rest'
                # Settings not parsed the first time.
            c.clearChanged()
            c.redraw(c.rootPosition())  # # 1380: Select the root.
        # #933: Restore clipboard
        g.app.gui.replaceClipboardWith(old_clipboard)
    return c
</t>
<t tx="ekr.20131111060930.18010"># Standard bindings...
# run-selected-unit-tests-externally = Alt-4 
# run-marked-unit-tests-externally = Alt-5
# run-marked-unit-tests-locally = Alt-6
run-selected-unit-tests-locally = Alt-4
do-nothing = Alt-5
run-marked-unit-tests-locally = Alt-6
</t>
<t tx="ekr.20131111105746.16544">def vim_dot(self):
    """Repeat the last command."""
    if self.in_dot:
        return
    try:
        self.in_dot = True
        # Save the dot list.
        self.old_dot_list = self.dot_list[:]
        # Copy the list so it can't change in the loop.
        for event in self.dot_list[:]:
            # Only k.masterKeyHandler can insert characters!
            #
            # #1757: Create a LeoKeyEvent.
            event = LeoKeyEvent(
                binding=g.KeyStroke(event.stroke),
                c = self.c,
                char=event.char,
                event=event,
                w=self.w,
            )
            self.k.masterKeyHandler(event)
        # For the dot list to be the old dot list, whatever happens.
        self.command_list = self.old_dot_list[:]
        self.dot_list = self.old_dot_list[:]
    finally:
        self.in_dot = False
    self.done()
</t>
<t tx="ekr.20131111140646.16544"># Similar to runEditCommandTest.

def runVimTest(self, p):
    tm = self
    c = self.c
    vc = c.vimCommands
    atTest = p.copy()
    w = c.frame.body.wrapper
    h = atTest.h
    assert h.startswith('@test '), f"expected head: {'@test'}, got: {h}"
    s = h[6:].strip()
    # The vim command is everything up to the first blank.
    i = 0
    while i &lt; len(s) and s[i] not in ' \t\n':
        i += 1
    command = s[:i]
    assert command, 'empty vim command'
    assert command, f"no command: {command}"
    work, before, after = tm.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node, h in ((work, 'work'), (before, before_h), (after, after_h)):
        h2 = node.h
        assert h2.startswith(h), f"expected head: {h}, got: {h2}"
    sels = []
    for node, h in ((before, before_h), (after, after_h)):
        sel = node.h[len(h) :].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    if 1:
        # pylint: disable=unbalanced-tuple-unpacking
        sel1, sel2 = sels
    c.selectPosition(work)
    work.b = before.b
    w.setSelectionRange(sel1[0], sel1[1], insert=sel1[1])
    # The vim-specific part.
    status, n1, command, n2, motion = vc.scan(command)
    assert status == 'done', repr(status)
    vc.exec_(command, n1, n2, motion)
    # Check the result.
    s1 = work.b; s2 = after.b
    assert s1 == s2, (
        f"mismatch in body\n"
        f"expected: {s2!r}\n"
        f"     got: {s1!r}")
    sel3 = w.getSelectionRange()
    # Convert both selection ranges to gui indices.
    sel2_orig = sel2
    assert len(sel2) == 2, f"Bad headline index.  Expected index,index.  got: {sel2}"
    i, j = sel2; sel2 = w.toPythonIndex(i), w.toPythonIndex(j)
    assert len(sel3) == 2, f"Bad headline index.  Expected index,index.  got: {sel3}"
    i, j = sel3; sel3 = w.toPythonIndex(i), w.toPythonIndex(j)
    assert sel2 == sel3, f"mismatch in sel\nexpected: {sel2_orig} = {sel2}, got: {sel3}"
    c.selectPosition(atTest)
    atTest.contract()
    # Don't redraw.
</t>
<t tx="ekr.20131115120119.17390">def __init__(self, *args, **kwargs):

    #
    # Called from frameFactory.createMaster.
    #
    self.factory = kwargs.get('factory')
    if self.factory:
        del kwargs['factory']
    super().__init__(*args, **kwargs)
    self.detached = []
    self.setMovable(True)

    def tabContextMenu(point):
        index = self.tabBar().tabAt(point)
        if index &lt; 0:  # or (self.count() &lt; 1 and not self.detached):
            return
        menu = QtWidgets.QMenu()
        # #310: Create new file on right-click in file tab in UI.
        if True:
            a = menu.addAction("New Outline")
            a.triggered.connect(lambda checked: self.new_outline(index))
        if self.count() &gt; 1:
            a = menu.addAction("Detach")
            a.triggered.connect(lambda checked: self.detach(index))
            a = menu.addAction("Horizontal tile")
            a.triggered.connect(
                lambda checked: self.tile(index, orientation='H'))
            a = menu.addAction("Vertical tile")
            a.triggered.connect(
                lambda checked: self.tile(index, orientation='V'))
        if self.detached:
            a = menu.addAction("Re-attach All")
            a.triggered.connect(lambda checked: self.reattach_all())
        menu.exec_(self.mapToGlobal(point))

    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(tabContextMenu)
</t>
<t tx="ekr.20131118152731.16852">def create_find_buttons(self, grid, parent, max_row2, row):
    """
    Per #1342, this method now creates labels, not real buttons.
    """
    dw, k = self, self.leo_c.k

    # Create Buttons in column 2 (Leo 4.11.1.)
    table = (
        (0, 2, 'findButton', 'find-next'),
        (1, 2, 'findPreviousButton', 'find-prev'),
        (2, 2, 'findAllButton', 'find-all'),
        (3, 2, 'changeButton', 'replace'),
        (4, 2, 'changeThenFindButton', 'replace-then-find'),
        (5, 2, 'changeAllButton', 'replace-all'),
    )
    for row2, col, func_name, cmd_name in table:
        stroke = k.getStrokeForCommandName(cmd_name)
        if stroke:
            label = f"{cmd_name}:  {k.prettyPrintKey(stroke)}"
        else:
            label = cmd_name
        # #1342: Create a label, not a button.
        w = dw.createLabel(parent, cmd_name, label)
        w.setObjectName('find-label')
        grid.addWidget(w, row + row2, col)
    row += max_row2
    row += 2
    return row
</t>
<t tx="ekr.20131118172620.16858">def finishCreateLogPane(self):
    """It's useful to create this late, because c.config is now valid."""
    assert self.findTab
    self.createFindTab(self.findTab, self.findScrollArea)
    self.findScrollArea.setWidget(self.findTab)
</t>
<t tx="ekr.20131118172620.16891">def override_events(self):
    # dw = self
    c = self.leo_c
    fc = c.findCommands
    ftm = fc.ftm
    # Define class EventWrapper.
    @others
    EventWrapper(
        c, w=ftm.find_findbox, next_w=ftm.find_replacebox, func=fc.findNextCommand)
    EventWrapper(
        c, w=ftm.find_replacebox, next_w=ftm.find_next_button, func=fc.findNextCommand)

    if 0:  # #1342: These are no longer needed, because there are no buttons.
        table = (
            ('findNextCommand', 'find-next'),
            ('findPrevCommand', 'find-prev'),
            ('findAll', 'find-all'),
            ('changeCommand', 'replace'),
            ('changeThenFind', 'replace-then-find'),
            ('changeAll', 'replace-all'),
        )
        for func_name, cmd_name in table:
            ivar = f"{cmd_name}-{'button'}"
            ivar = ivar.replace('-', '_')
            w = getattr(ftm, ivar, None)
            func = getattr(fc, func_name, None)
            if w and func:
                next_w = ftm.check_box_whole_word if cmd_name == 'replace-all' else None
                EventWrapper(c, w=w, next_w=next_w, func=func)
            else:
                g.trace('**oops**')
    # Finally, checkBoxMarkChanges goes back to ftm.find_findBox.
    EventWrapper(c, w=ftm.check_box_mark_changes, next_w=ftm.find_findbox, func=None)
</t>
<t tx="ekr.20131118172620.16892">class EventWrapper:

    def __init__(self, c, w, next_w, func):
        self.c = c
        self.d = self.create_d()
            # Keys: stroke.s; values: command-names.
        self.w = w
        self.next_w = next_w
        self.eventFilter = qt_events.LeoQtEventFilter(c, w, 'EventWrapper')
        self.func = func
        self.oldEvent = w.event
        w.event = self.wrapper
    @others
</t>
<t tx="ekr.20131118172620.16893">def wrapper(self, event):

    e = QtCore.QEvent
    type_ = event.type()
    # Must intercept KeyPress for events that generate FocusOut!
    if type_ == e.KeyPress:
        return self.keyPress(event)
    if type_ == e.KeyRelease:
        return self.keyRelease(event)
    return self.oldEvent(event)
</t>
<t tx="ekr.20131118172620.16894">def keyPress(self, event):

    s = event.text()
    out = s and s in '\t\r\n'
    if out:
        # Move focus to next widget.
        if s == '\t':
            if self.next_w:
                self.next_w.setFocus(QtCore.Qt.TabFocusReason)
            else:
                # Do the normal processing.
                return self.oldEvent(event)
        elif self.func:
            self.func()
        return True
    # Stay in the present widget.
    binding, ch = self.eventFilter.toBinding(event)
    if binding:
        cmd_name = self.d.get(binding)
        if cmd_name:
            self.c.k.simulateCommand(cmd_name)
            return True
    # Do the normal processing.
    return self.oldEvent(event)
</t>
<t tx="ekr.20131118172620.16895">def keyRelease(self, event):
    return self.oldEvent(event)
</t>
<t tx="ekr.20131120054058.16281">def create_d(self):
    """Create self.d dictionary."""
    c = self.c
    d = {}
    table = (
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # New in Leo 5.2: Support these in the Find Dialog.
        'find-all',
        'find-next',
        'find-prev',
        'hide-find-tab',
        'replace',
        'replace-all',
        'replace-then-find',
        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
    )
    for cmd_name in table:
        stroke = c.k.getStrokeForCommandName(cmd_name)
        if stroke:
            d[stroke.s] = cmd_name
    return d
</t>
<t tx="ekr.20131121084830.16362">@language python

# Toggle the settings.
g.app.debug_app = not g.app.debug_app
g.app.debug_widgets = not g.app.debug_widgets
# Report the new settings.
print('g.app.debug_app: %s' % g.app.debug_app)
print('g.app.debug_widgets: %s' % g.app.debug_widgets)
</t>
<t tx="ekr.20131222112420.16371">def contract(self):
    """Contract p.v and clear p.v.expandedPositions list."""
    p, v = self, self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    v.contract()

def expand(self):
    p = self
    v = self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    for p2 in v.expandedPositions:
        if p == p2:
            break
    else:
        v.expandedPositions.append(p.copy())
    v.expand()

def isExpanded(self):
    p = self
    if p.isCloned():
        c = p.v.context
        return c.shouldBeExpanded(p)
    return p.v.isExpanded()
</t>
<t tx="ekr.20131224085853.16443">def findReference(self, name, p):
    """Find a reference to name.  Raise an error if not found."""
    at = self
    ref = g.findReference(name, p)
    if not ref and not hasattr(at, 'allow_undefined_refs'):
        # Do give this error even if unit testing.
        at.writeError(
            f"undefined section: {g.truncate(name, 60)}\n"
            f"  referenced from: {g.truncate(p.h, 60)}")
    return ref
</t>
<t tx="ekr.20140102162014.16438">unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class LocalConfigManager--&gt;c.config.Getters--&gt;c.config.Getters--&gt;c.config.getData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class GlobalConfigManager--&gt;gcm.Getters...--&gt;gcm.getData &amp; getOutlineData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;&lt;&lt; class ParserBaseClass &gt;&gt;--&gt;kind handlers (ParserBaseClass)--&gt;doData
@language rest
The parser for @data nodes, doData, no longer strips *anything*.</t>
<t tx="ekr.20140103105930.16446"></t>
<t tx="ekr.20140114145953.16691">def isLocalSetting(self, setting, kind):
    """Return True if the indicated setting comes from a local .leo file."""
    if not kind or kind in ('shortcut', 'shortcuts', 'openwithtable'):
        return False
    key = g.app.config.munge(setting)
    if key is None:
        return False
    if not self.settingsDict:
        return False
    gs = self.settingsDict.get(key)
    if not gs:
        return False
    assert isinstance(gs, g.GeneralSetting), repr(gs)
    path = gs.path.lower()
    for fn in ('myLeoSettings.leo', 'leoSettings.leo'):
        if path.endswith(fn.lower()):
            return False
    return True
</t>
<t tx="ekr.20140203082618.15486">def __get_script(self):
    p = self
    return g.getScript(p.v.context, p,
        useSelectedText=False,  # Always return the entire expansion.
        forcePythonSentinels=True,
        useSentinels=False)

script = property(
    __get_script,  # __set_script,
    doc="position property returning the script formed by p and its descendants")
</t>
<t tx="ekr.20140218040104.16761">def __get_nosentinels(self):
    p = self
    return ''.join([z for z in g.splitLines(p.b) if not g.isDirective(z)])

nosentinels = property(
    __get_nosentinels,  # __set_nosentinels
    doc="position property returning the body text without sentinels")
</t>
<t tx="ekr.20140221085636.16685">def do_key(self, event):
    """
    Handle the next key in vim mode:
    - Set event, w, stroke and ch ivars for *all* handlers.
    - Call handler().
    Return True if k.masterKeyHandler should handle this key.
    """
    try:
        self.init_scanner_vars(event)
        self.do_trace(blank_line=True)
        self.return_value = None
        if not self.handle_specials():
            self.handler()
        if self.return_value not in (True, False):
            # It looks like no acceptance method has been called.
            self.oops(
                f"bad return_value: {repr(self.return_value)} "
                f"{self.state} {self.next_func}")
            self.done()  # Sets self.return_value to True.
    except Exception:
        g.es_exception()
        self.quit()
    return self.return_value
</t>
<t tx="ekr.20140613141207.17667">def openfolder_rclick_cb():
    
    if g.os_path_exists(path):
        g.os_startfile(path)
    else:
        # #1257:
        g.es_print('file not found:', repr(path))
</t>
<t tx="ekr.20140711071454.17654">def recursiveUNLFind(unlList, c, depth=0, p=None, maxdepth=0, maxp=None,
                     soft_idx=False, hard_idx=False):
    """
    Internal part of recursiveUNLSearch which doesn't change the
    selected position or call c.frame.bringToFront()

    returns found, depth, p, where:

        - found is True if a full match was found
        - depth is the depth of the best match
        - p is the position of the best match

    NOTE: maxdepth is max depth seen in recursion so far, not a limit on
          how far we will recurse.  So it should default to 0 (zero).

    - `unlList`: list of 'headline', 'headline:N', or 'headline:N,M'
      elements, where N is the node's position index and M the zero based
      count of like named nodes, eg. 'foo:2', 'foo:4,1', 'foo:12,3'
    - `c`: outline
    - `soft_idx`: use index when matching name not found
    - `hard_idx`: use only indexes, ignore node names
    - `depth`: part of recursion, don't set explicitly
    - `p`: part of recursion, don't set explicitly
    - `maxdepth`: part of recursion, don't set explicitly
    - `maxp`: part of recursion, don't set explicitly
    """
    if depth == 0:
        nds = list(c.rootPosition().self_and_siblings())
        unlList = [i.replace('--%3E', '--&gt;') for i in unlList if i.strip()]
        # drop empty parts so "--&gt;node name" works
    else:
        nds = list(p.children())
    heads = [i.h for i in nds]
    # work out order in which to try nodes
    order = []
    nth_sib = nth_same = nth_line_no = nth_col_no = None
    try:
        target = unlList[depth]
    except IndexError:
        target = ''
    try:
        target = g_pos_pattern.sub('', unlList[depth])
        nth_sib, nth_same, nth_line_no, nth_col_no = recursiveUNLParts(unlList[depth])
        pos = nth_sib is not None
    except IndexError:
        # #36.
        pos = False
    if pos:
        use_idx_mode = True  # ok to use hard/soft_idx
        target = re.sub(g_pos_pattern, "", target).replace('--%3E', '--&gt;')
        if hard_idx:
            if nth_sib &lt; len(heads):
                order.append(nth_sib)
        else:
            # First we try the nth node with same header
            if nth_same:
                nths = [n for n, i in enumerate(heads) if i == target]
                if nth_same &lt; len(nths) and heads[nths[nth_same]] == target:
                    order.append(nths[nth_same])
            # Then we try *all* other nodes with same header
            order += [n for n, s in enumerate(heads)
                        if n not in order and s == target]
            # Then position based, if requested
            if soft_idx and nth_sib &lt; len(heads):
                order.append(nth_sib)
    elif hard_idx:
        pass  # hard_idx mode with no idx in unl, go with empty order list
    else:
        order = range(len(nds))
        target = target.replace('--%3E', '--&gt;')
        use_idx_mode = False  # not ok to use hard/soft_idx
        # note, the above also fixes calling with soft_idx=True and an old UNL

    for ndi in order:
        nd = nds[ndi]
        if (
            target == nd.h or
            (use_idx_mode and (soft_idx or hard_idx) and ndi == nth_sib)
        ):
            if depth + 1 == len(unlList):  # found it
                return True, maxdepth, nd
            if maxdepth &lt; depth + 1:
                maxdepth = depth + 1
                maxp = nd.copy()
            found, maxdepth, maxp = g.recursiveUNLFind(
                unlList, c, depth + 1, nd,
                maxdepth, maxp, soft_idx=soft_idx, hard_idx=hard_idx)
            if found:
                return found, maxdepth, maxp
            # else keep looking through nds
    if depth == 0 and maxp:  # inexact match
        g.es('Partial UNL match')
    if soft_idx and depth + 2 &lt; len(unlList):
        aList = []
        for p in c.all_unique_positions():
            if any([p.h.replace('--%3E', '--&gt;') in unl for unl in unlList]):
                aList.append((p.copy(), p.get_UNL(False, False, True)))
        maxcount = 0
        singleMatch = True
        for iter_unl in aList:
            count = 0
            compare_list = unlList[:]
            for header in reversed(iter_unl[1].split('--&gt;')):
                if (re.sub(g_pos_pattern, "", header).replace('--%3E', '--&gt;') ==
                     compare_list[-1]
                ):
                    count = count + 1
                    compare_list.pop(-1)
                else:
                    break
            if count &gt; maxcount:
                p = iter_unl[0]
                singleMatch = True
            elif count == maxcount:
                singleMatch = False
        if maxcount and singleMatch:
            maxp = p
            maxdepth = p.level()
    return False, maxdepth, maxp
</t>
<t tx="ekr.20140717074441.17772"># refresh_pattern = re.compile(r'^(@[\w-]+)')

@g.commander_command('refresh-from-disk')
def refreshFromDisk(self, event=None):
    """Refresh an @&lt;file&gt; node from disk."""
    c, p, u = self, self.p, self.undoer
    c.nodeConflictList = []
    fn = p.anyAtFileNodeName()
    shouldDelete = c.sqlite_connection is None
    if not fn:
        g.warning(f"not an @&lt;file&gt; node: {p.h!r}")
        return
    # #1603.
    if os.path.isdir(fn):
        g.warning(f"not a file: {fn!r}")
        return
    b = u.beforeChangeTree(p)
    redraw_flag = True
    at = c.atFileCommands
    c.recreateGnxDict()
        # Fix bug 1090950 refresh from disk: cut node ressurection.
    i = g.skip_id(p.h, 0, chars='@')
    word = p.h[0:i]
    if word == '@auto':
        # This includes @auto-*
        if shouldDelete: p.v._deleteAllChildren()
        # Fix #451: refresh-from-disk selects wrong node.
        p = at.readOneAtAutoNode(fn, p)
    elif word in ('@thin', '@file'):
        if shouldDelete: p.v._deleteAllChildren()
        at.read(p, force=True)
    elif word == '@clean':
        # Wishlist 148: use @auto parser if the node is empty.
        if p.b.strip() or p.hasChildren():
            at.readOneAtCleanNode(p)
        else:
            # Fix #451: refresh-from-disk selects wrong node.
            p = at.readOneAtAutoNode(fn, p)
    elif word == '@shadow':
        if shouldDelete: p.v._deleteAllChildren()
        at.read(p, force=True, atShadow=True)
    elif word == '@edit':
        at.readOneAtEditNode(fn, p)
            # Always deletes children.
    elif word == '@asis':
        # Fix #1067.
        at.readOneAtAsisNode(fn, p)
            # Always deletes children.
    else:
        g.es_print(f"can not refresh from disk\n{p.h!r}")
        redraw_flag = False
    if redraw_flag:
        # Fix #451: refresh-from-disk selects wrong node.
        c.selectPosition(p)
        u.afterChangeTree(p, command='refresh-from-disk', bunch=b)
        # Create the 'Recovered Nodes' tree.
        c.fileCommands.handleNodeConflicts()
        c.redraw()
</t>
<t tx="ekr.20140723122936.17925"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins now contain the importer code for all kinds of @auto nodes.
# Each plugin must define a top-level importer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20140723140445.18076">def parse_importer_dict(self, sfn, m):
    """
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    """
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        # scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning(f"leo/plugins/importers/{sfn} has no importer_dict")
</t>
<t tx="ekr.20140724064952.18037">def createImporterData(self):
    """Create the data structures describing importer plugins."""
    # Allow plugins to be defined in ~/.leo/plugins.
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(
            g.app.loadDir, '..', 'plugins', 'importers', '*.py')
        for fn in g.glob_glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    module_name = sfn[:-3]
                    # Important: use importlib to give imported modules
                    # their fully qualified names.
                    m = importlib.import_module(
                        f"leo.plugins.importers.{module_name}")
                    self.parse_importer_dict(sfn, m)
                    # print('createImporterData', m.__name__)
                except Exception:
                    g.warning(f"can not import leo.plugins.importers.{module_name}")
</t>
<t tx="ekr.20140724064952.18038">def dispatch(self, ext, p):
    """Return the correct scanner function for p, an @auto node."""
    # Match the @auto type first, then the file extension.
    c = self.c
    return g.app.scanner_for_at_auto(c, p) or g.app.scanner_for_ext(c, ext)
</t>
<t tx="ekr.20140724073946.18050">def get_import_filename(self, fileName, parent):
    """Return the absolute path of the file and set .default_directory."""
    c = self.c
    self.default_directory = g.setDefaultDirectory(c, parent, importing=False)
    fileName = g.os_path_finalize_join(self.default_directory, fileName)  # 1341
    fileName = fileName.replace('\\', '/')  # 2011/11/25
    return fileName
</t>
<t tx="ekr.20140724175458.18052">def init_import(self, atShadow, ext, fileName, s):
    """
    Init ivars imports and read the file into s.
    Return ext, s.
    """
    junk, self.fileName = g.os_path_split(fileName)
    self.methodName, self.fileType = g.os_path_splitext(self.fileName)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        # Set the kind for error messages in readFileIntoString.
        s, e = g.readFileIntoString(
            fileName,
            encoding=self.encoding,
            kind='@shadow ' if atShadow else '@auto ',
        )
            # Kind is used only for messages.
        if s is None:
            return None, None
        if e: self.encoding = e
    if self.treeType == '@root':
        self.rootLine = "@root-code " + self.fileName + '\n'
    else:
        self.rootLine = ''
    return ext, s
</t>
<t tx="ekr.20140726091031.18071"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins now contain the write code for all kinds special @auto nodes.
# Each plugin must define a top-level writer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20140728040812.17990">def createWritersData(self):
    """Create the data structures describing writer plugins."""
    trace = False and 'createWritersData' not in g.app.debug_dict
        # Do *not* remove this trace.
    if trace:
        # Suppress multiple traces.
        g.app.debug_dict['createWritersData'] = True
    g.app.writersDispatchDict = {}
    g.app.atAutoWritersDict = {}
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(g.app.loadDir,
            '..', 'plugins', 'writers', '*.py')
        for fn in g.glob_glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module(f"leo.plugins.writers.{sfn[:-3]}")
                    self.parse_writer_dict(sfn, m)
                except Exception:
                    g.es_exception()
                    g.warning(f"can not import leo.plugins.writers.{sfn}")
    if trace:
        g.trace('LM.writersDispatchDict')
        g.printDict(g.app.writersDispatchDict)
        g.trace('LM.atAutoWritersDict')
        g.printDict(g.app.atAutoWritersDict)
    # Creates problems: See #40.
</t>
<t tx="ekr.20140728040812.17991">def parse_writer_dict(self, sfn, m):
    """
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    """
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace(
                        f"{sfn}: duplicate {s} class {aClass.__name__} "
                        f"in {m.__file__}:")
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace(f"{sfn}: duplicate {ext} class", aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning(f"leo/plugins/writers/{sfn} has no writer_dict")
</t>
<t tx="ekr.20140728040812.17993">def dispatch(self, ext, p):
    """Return the correct writer function for p, an @auto node."""
    at = self
    # Match @auto type before matching extension.
    return at.writer_for_at_auto(p) or at.writer_for_ext(ext)
</t>
<t tx="ekr.20140728040812.17995">def writer_for_at_auto(self, root):
    """A factory returning a writer function for the given kind of @auto directive."""
    at = self
    d = g.app.atAutoWritersDict
    for key in d:
        aClass = d.get(key)
        if aClass and g.match_word(root.h, 0, key):

            def writer_for_at_auto_cb(root):
                # pylint: disable=cell-var-from-loop
                try:
                    writer = aClass(at.c)
                    s = writer.write(root)
                    return s
                except Exception:
                    g.es_exception()
                    return None

            return writer_for_at_auto_cb
    return None
</t>
<t tx="ekr.20140728040812.17997">def writer_for_ext(self, ext):
    """A factory returning a writer function for the given file extension."""
    at = self
    d = g.app.writersDispatchDict
    aClass = d.get(ext)
    if aClass:

        def writer_for_ext_cb(root):
            try:
                return aClass(at.c).write(root)
            except Exception:
                g.es_exception()
                return None

        return writer_for_ext_cb

    return None
</t>
<t tx="ekr.20140802120757.18001">def save_body(self):
    """Undoably preserve any changes to body text."""
    c = self.c
    w = self.command_w or self.w
    name = c.widget_name(w)
    if w and name.startswith('body'):
        # Similar to selfInsertCommand.
        oldSel = self.old_sel or w.getSelectionRange()
        newText = w.getAllText()
        if c.p.b != newText:
            # To do: set undoType to the command spelling?
            # undoType = ''.join(self.command_list) or 'Typing'
            c.frame.body.onBodyChanged(undoType='vc-save-body', oldSel=oldSel)
</t>
<t tx="ekr.20140802120757.18003">def init_scanner_vars(self, event):
    """Init all ivars used by the scanner."""
    assert event
    self.event = event
    stroke = event.stroke
    self.ch = event.char  # Required for f,F,t,T.
    self.stroke = stroke.s if g.isStroke(stroke) else stroke
    self.w = event and event.w
    if not self.in_command:
        self.in_command = True  # May be cleared later.
        if self.is_text_wrapper(self.w):
            self.old_sel = self.w.getSelectionRange()
</t>
<t tx="ekr.20140802225657.18021">def handle_specials(self):
    """Return True self.stroke is an Escape or a Return in the outline pane."""
    if self.stroke == 'Escape':
        # k.masterKeyHandler handles Ctrl-G.
        # Escape will end insert mode.
        self.vim_esc()
        return True
    if self.stroke == '\n' and self.in_headline(self.w):
        # End headline editing and enter normal mode.
        self.c.endEditing()
        self.done()
        return True
    return False
</t>
<t tx="ekr.20140805064952.18153">def on_idle(self, tag, keys):
    """The idle-time handler for the VimCommands class."""
    c = keys.get('c')
    if c and c.vim_mode and self == c.vimCommands:
        # #1273: only for vim mode.
        g.trace('=====')
        # Call set_border only for the presently selected tab.
        try:
            # Careful: we may not have tabs.
            w = g.app.gui.frameFactory.masterFrame
        except AttributeError:
            w = None
        if w:
            i = w.indexOf(c.frame.top)
            if i == w.currentIndex():
                self.set_border()
        else:
            self.set_border()
</t>
<t tx="ekr.20140807070500.18161">def set_property(self, w, focus_flag):
    """Set the property of w, depending on focus and state."""
    c, state = self.c, self.state
    #
    # #1221: Use a style sheet based on new settings.
    if focus_flag:
        d = {
            'normal': ('vim-mode-normal-border', 'border: 3px solid white'),
            'insert': ('vim-mode-insert-border', 'border: 3px solid red'),
            'visual': ('vim-mode-visual-border', 'border: 3px solid yellow'),
        }
        data = d.get(state)
        if not data:
            g.trace('bad vim mode', repr(state))
            return
        setting, default_border = data
    else:
        setting = 'vim-mode-unfocused-border'
        default_border = 'border: 3px dashed white'
    border = c.config.getString(setting) or default_border
    # g.trace(setting, border)
    w.setStyleSheet(border)
    return
    #
    # This code doesn't work on Qt 5, because of a Qt bug.
    # It probably isn't coming back.
        # selector = f"vim_{state}" if focus_flag else 'vim_unfocused'
        # w.setProperty('vim_state', selector)
        # w.style().unpolish(w)
        # w.style().polish(w)
</t>
<t tx="ekr.20140808103117.18035"></t>
<t tx="ekr.20140808103117.18038">gnx: ekr.20110605121601.18698
</t>
<t tx="ekr.20140808103117.18040">gnx: ekr.20110605121601.18703
</t>
<t tx="ekr.20140808103117.18042">gnx: ekr.20110605121601.18704
</t>
<t tx="ekr.20140808103117.18044">gnx: ekr.20110605121601.18709
</t>
<t tx="ekr.20140813052702.18196">def compute_tab_list(self):
    """Compute the list of completions."""
    path = self.get_label()
    # #215: insert-file-name doesn't process ~
    path = g.os_path_expanduser(path)
    sep = os.path.sep
    if g.os_path_exists(path):
        if g.os_path_isdir(path):
            if path.endswith(os.sep):
                aList = g.glob_glob(path + '*')
            else:
                aList = g.glob_glob(path + sep + '*')
            tabList = [z + sep if g.os_path_isdir(z) else z for z in aList]
        else:
            # An existing file.
            tabList = [path]
    else:
        if path and path.endswith(sep):
            path = path[:-1]
        aList = g.glob_glob(path + '*')
        tabList = [z + sep if g.os_path_isdir(z) else z for z in aList]
    if self.filterExt:
        for ext in self.filterExt:
            tabList = [z for z in tabList if not z.endswith(ext)]
    tabList = [g.os_path_normslashes(z) for z in tabList]
    junk, common_prefix = g.itemsMatchingPrefixInList(path, tabList)
    return common_prefix, tabList
</t>
<t tx="ekr.20140813052702.18200">def get_file_name(self, event, callback, filterExt, prompt, tabName):
    """Get a file name, supporting file completion."""
    c, k = self.c, self.c.k
    tag = 'get-file-name'
    state = k.getState(tag)
    char = event.char if event else ''
    if state == 0:
        # Re-init all ivars.
        self.log = c.frame.log or g.NullObject()
        self.callback = callback
        self.filterExt = filterExt or ['.pyc', '.bin',]
        self.prompt = prompt
        self.tabName = tabName
        join = g.os_path_finalize_join
        finalize = g.os_path_finalize
        normslashes = g.os_path_normslashes
        # #467: Add setting for preferred directory.
        directory = c.config.getString('initial-chooser-directory')
        if directory:
            directory = finalize(directory)
            if not g.os_path_exists(directory):
                g.es_print('@string initial-chooser-directory not found',
                    normslashes(directory))
                directory = None
        if not directory:
            directory = finalize(os.curdir)
        # Init the label and state.
        tail = k.functionTail and k.functionTail.strip()
        label = join(directory, tail) if tail else directory + os.sep
        self.set_label(normslashes(label))
        k.setState(tag, 1, self.get_file_name)
        self.log.selectTab(self.tabName)
        junk, tabList = self.compute_tab_list()
        self.show_tab_list(tabList)
        c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n', 'Return'):
        self.log.deleteTab(self.tabName)
        path = self.get_label()
        k.keyboardQuit()
        if self.callback:
            # pylint: disable=not-callable
            self.callback(path)
        else:
            g.trace('no callback')
    elif char in ('\t', 'Tab'):
        self.do_tab()
        c.minibufferWantsFocus()
    elif char in ('\b', 'BackSpace'):
        self.do_back_space()
        c.minibufferWantsFocus()
    elif k.isPlainKey(char):
        self.do_char(char)
    else:
        pass
</t>
<t tx="ekr.20140813052702.18203">def getFileName(self, event, callback=None,
    filterExt=None, prompt='Enter File Name: ', tabName='Dired'
):
    """Get a file name from the minibuffer."""
    k = self
    k.fnc.get_file_name(event, callback, filterExt, prompt, tabName)
</t>
<t tx="ekr.20140816165728.18965"># Called from k.fullCommand: with defaultTabList = list(c.commandsDict.keys())

def do_back_space(self, tabList, completion=True):
    """Handle a backspace and update the completion list."""
    k = self.k
    self.tabList = tabList[:] if tabList else []
    # Update the label.
    w = k.w
    i, j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if ins &gt; len(k.mb_prefix):
        # Step 1: actually delete the character.
        i, j = w.getSelectionRange()
        if i == j:
            ins -= 1
            w.delete(ins)
            w.setSelectionRange(ins, ins, insert=ins)
        else:
            ins = i
            w.delete(i, j)
            w.setSelectionRange(i, i, insert=ins)
    if w.getAllText().strip():
        junk, tabList = self.compute_tab_list(self.tabList)
        # Do *not* extend the label to the common prefix.
    else:
        tabList = []
    if completion:
        # #323.
        common_prefix, tabList = self.compute_tab_list(tabList)
        self.show_tab_list(tabList)
        self.reset_tab_cycling()
</t>
<t tx="ekr.20140816165728.18968"># New in Leo 5.4

def getNextArg(self, handler):
    """
    Get the next arg.  For example, after a Tab in the find commands.
    See the docstring for k.get1Arg for examples of its use.
    """
    # Replace the current handler.
    self.getArgInstance.after_get_arg_state = ('getarg', 1, handler)
    self.c.minibufferWantsFocusNow()

# New in Leo 5.4

def get1Arg(self, event, handler,
    # returnKind=None, returnState=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    &lt;&lt; docstring for k.get1arg &gt;&gt;
    returnKind, returnState = None, None
    assert handler, g.callers()
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def getArg(self, event,
    returnKind=None, returnState=None, handler=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    """Convenience method mapping k.getArg to ga.get_arg."""
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def doBackSpace(self, tabList, completion=True):
    """Convenience method mapping k.doBackSpace to ga.do_back_space."""
    self.getArgInstance.do_back_space(tabList, completion)

def doTabCompletion(self, tabList):
    """Convenience method mapping k.doTabCompletion to ga.do_tab."""
    self.getArgInstance.do_tab(tabList)

def getMinibufferCommandName(self):
    """
    Convenience method mapping k.getMinibufferCommandName to
    ga.get_minibuffer_command_name.
    """
    return self.getArgInstance.get_minibuffer_command_name()
</t>
<t tx="ekr.20140817110228.18323"># Used by ga.get_arg and k.fullCommand.

def do_tab(self, tabList, completion=True):
    """Handle tab completion when the user hits a tab."""
    c = self.c
    if completion:
        tabList = self.tabList = tabList[:] if tabList else []
        common_prefix, tabList = self.compute_tab_list(tabList)
        if self.cycling_prefix and not self.cycling_prefix.startswith(common_prefix):
            self.cycling_prefix = common_prefix
        #
        # No tab cycling for completed commands having
        # a 'tab_callback' attribute.
        if len(tabList) == 1 and self.do_tab_callback():
            return
        # #323: *Always* call ga.do_tab_list.
        self.do_tab_cycling(common_prefix, tabList)
    c.minibufferWantsFocus()
</t>
<t tx="ekr.20140818074502.18221">def is_command(self, s):
    """Return False if something, even a blank, follows a command."""
    # #1121: only ascii space terminates a command.
    return ' ' not in s
</t>
<t tx="ekr.20140818074502.18222">def get_command(self, s):
    """Return the command part of a minibuffer contents s."""
    # #1121.
    if ' ' in s:
        return s[: s.find(' ')].strip()
    return s
</t>
<t tx="ekr.20140818145250.18235">def do_tab_callback(self):
    """
    If the command-name handler has a tab_callback,
    call handler.tab_callback() and return True.
    """
    c, k = self.c, self.k
    commandName, tail = k.getMinibufferCommandName()
    handler = c.commandsDict.get(commandName)
    if hasattr(handler, 'tab_callback'):
        self.reset_tab_cycling()
        k.functionTail = tail
            # For k.getFileName.
        handler.tab_callback()
        return True
    return False
</t>
<t tx="ekr.20140819050118.18317">def do_tab_cycling(self, common_prefix, tabList):
    """Put the next (or first) completion in the minibuffer."""
    s = self.get_label()
    if not common_prefix:
        # Leave the minibuffer as it is.
        self.show_tab_list(tabList)
    # #323.
    elif (
        self.cycling_prefix and
        s.startswith(self.cycling_prefix) and
        sorted(self.cycling_tabList) == sorted(tabList)  # Bug fix: 2016/10/14
    ):
        n = self.cycling_index
        n = self.cycling_index = n + 1 if n + 1 &lt; len(self.cycling_tabList) else 0
        self.set_label(self.cycling_tabList[n])
        self.show_tab_list(self.cycling_tabList)
    else:
        # Restart.
        self.show_tab_list(tabList)
        self.cycling_tabList = tabList[:]
        self.cycling_prefix = common_prefix
        self.set_label(common_prefix)
        if tabList and common_prefix == tabList[0]:
            self.cycling_index = 0
        else:
            self.cycling_index = -1
</t>
<t tx="ekr.20140819050118.18318">def reset_tab_cycling(self):
    """Reset all tab cycling ivars."""
    self.cycling_prefix = None
    self.cycling_index = -1
    self.cycling_tabList = []
</t>
<t tx="ekr.20140822051549.18298">def setStatusLabel(self, s):
    """
    Set the label to s.

    Use k.setStatusLabel, not k.setLael, to report the status of a Leo
    command. This allows the option to use g.es instead of the minibuffer
    to report status.
    """
    k = self
    k.setLabel(s, protect=False)
</t>
<t tx="ekr.20140829053801.18453">def unselect_helper(self, old_p, p):
    """Unselect the old node, calling the unselect hooks."""
    c = self.c
    call_event_handlers = p != old_p
    if call_event_handlers:
        unselect = not g.doHook(
            "unselect1", c=c, new_p=p, old_p=old_p, new_v=p, old_v=old_p)
    else:
        unselect = True

    # Actually unselect the old node.
    if unselect and old_p and old_p != p:
        self.endEditLabel()
        # #1168: Ctrl-minus selects multiple nodes.
        if hasattr(self, 'unselectItem'):
            # pylint: disable=no-member
            self.unselectItem(old_p)
    if call_event_handlers:
        g.doHook("unselect2", c=c, new_p=p, old_p=old_p, new_v=p, old_v=old_p)
</t>
<t tx="ekr.20140831085423.18630">This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:

si:     a g.ShortcutInfo object.
ks:     a g.KeyStroke object
stroke: a KeyStroke object.

btw:    leoFrame.BaseTextWrapper
stw:    leoFrame.StringTextWrapper

bqtw:   qt_text.BaseQTextWrapper
lqtb:   qt_text.LeoQTextBrowser
qhlw:   qt_text.QHeadlineWrapper
qmbw:   qt_text.QMinibufferWrapper
qlew:   qt_text.QLineEditWrapper
qsciw:  qt_text.QScintiallaWrapper
qtew:   qt_text.QTextEditWrapper</t>
<t tx="ekr.20140831085423.18631">The following 'official' ivars will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.widget     The gui widget for the body pane.
c.frame.body.wrapper    The high level interface for the body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.log.widget      The gui widget for the log pane.
c.frame.log.wrapper     The high-level inteface for the log pane.
c.frame.tree            The tree pane.

The following were official ivars that no longer exist:

c.frame.body.bodyCtrl   Use c.frame.body.wrapper instead.
c.frame.log.logCtrl     Use c.frame.log.wrapper instead.
</t>
<t tx="ekr.20140831085423.18639">Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly.  Instead...

2. A **wrapper class** defines a standard api that hides the details
   of the underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All wrapper classes define an official ``widget`` ivar, so core or plugin code can gain access to the real Qt widget using wrapper.widget. Searching for wrapper.widget will find all gui-dependent snippets of code in Leo's core.
</t>
<t tx="ekr.20140901062324.18714">def onTextChanged(self):
    """
    Update Leo after the body has been changed.

    tree.tree_select_lockout is True during the entire selection process.
    """
    # Important: usually w.changingText is True.
    # This method very seldom does anything.
    w = self
    c = self.c; p = c.p
    tree = c.frame.tree
    if w.changingText:
        return
    if tree.tree_select_lockout:
        g.trace('*** LOCKOUT', g.callers())
        return
    if not p:
        return
    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText()  # Converts to unicode.
    # Get the previous values from the VNode.
    oldText = p.b
    if oldText == newText:
        # This can happen as the result of undo.
        # g.error('*** unexpected non-change')
        return
    i, j = p.v.selectionStart, p.v.selectionLength
    oldSel = (i, i + j)
    c.undoer.doTyping(p, 'Typing', oldText, newText,
        oldSel=oldSel, oldYview=None, newInsert=newInsert, newSel=newSel)
</t>
<t tx="ekr.20140901062324.18716">def onCursorPositionChanged(self, event=None):
    
    c = self.c
    name = c.widget_name(self)
    # Apparently, this does not cause problems
    # because it generates no events in the body pane.
    if not name.startswith('body'):
        return
    if hasattr(c.frame, 'statusLine'):
        c.frame.statusLine.update()
</t>
<t tx="ekr.20140902032918.18591">@language rest
@wrap

Leo uses a model/view/controller architecture.

- Controller: The Commands class and its helpers in leoCommands.py and leoEditCommands.py.

- Model: The VNode and Position classes in leoNodes.py.

- View: The gui-independent base classes are in the node "Gui Base Classes". The Qt-Specific subclasses are in the node "Qt gui".

**Important**: The general organization of these classes have changed hardly at all in Leo's 20+ year history.  The reason is that what each class does is fairly obvious.  How the gets the job done may have changed drastically, but *that's an internal implementation detail of the class itself*.  This is the crucial design principle that allows Leo's code to remain stable.  *Classes do not know or meddle in the internal details of other classes*.  As a result, nobody, including EKR, needs to remember internal details.

</t>
<t tx="ekr.20140902155015.18674"></t>
<t tx="ekr.20140915062551.19519">def set_icon_bar_orientation(self, c):
    """Set the orientation of the icon bar based on settings."""
    d = {
        'bottom': QtCore.Qt.BottomToolBarArea,
        'left': QtCore.Qt.LeftToolBarArea,
        'right': QtCore.Qt.RightToolBarArea,
        'top': QtCore.Qt.TopToolBarArea,
    }
    where = self.toolbar_orientation
    if not where:
        where = 'top'
    where = d.get(where.lower())
    if where:
        self.addToolBar(where, self.iconBar)
</t>
<t tx="ekr.20140916101314.19538">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20140917154740.19483">def os_path_finalize_join(*args, **keys):
    """
    Join and finalize.
    
    **keys may contain a 'c' kwarg, used by c.os_path_join.
    """
    # Old code
        # path = os.path.normpath(os.path.abspath(g.os_path_join(*args, **keys)))
        # if g.isWindows:
            # path = path.replace('\\','/')
    #
    # #1383: Call both wrappers, to ensure ~ is always expanded.
    #        This is significant change, to undo previous mistakes.
    #        Revs cbbf5e8b and 6e461196 in devel were the likely culprits.
    path = g.os_path_join(*args, **keys)
    path = g.os_path_finalize(path)
    return path
</t>
<t tx="ekr.20140920064112.17946"></t>
<t tx="ekr.20141007223054.18003">def isLeoFile(self, fn, s):
    """Return true if fn (a file name) represents an entire .leo file."""
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
</t>
<t tx="ekr.20141007223054.18004">def createLeoFileTree(self, fn, p):
    """Copy all nodes from fn, a .leo file, to the children of p."""
    c = self.c
    p.h = f"From {g.shortFileName(fn)}"
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(s)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
</t>
<t tx="ekr.20141024170936.7">def get_selection(self):
    """Return the presently selected item's text."""
    return self.currentItem().text()
</t>
<t tx="ekr.20141103061944.31">def getXScrollPosition(self):
    """Get the horizontal scrollbar position."""
    w = self
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setXScrollPosition(self, pos):
    """Set the position of the horizontal scrollbar."""
    if pos is not None:
        w = self
        sb = w.horizontalScrollBar()
        sb.setSliderPosition(pos)
</t>
<t tx="ekr.20141119161908.2">def createMyLeoSettings(c):
    """createMyLeoSettings - Return true if myLeoSettings.leo created ok
    """
    name = "myLeoSettings.leo"
    homeLeoDir = g.app.homeLeoDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir
    # check it doesn't already exist
    for path in homeLeoDir, loadDir, configDir:
        fileName = g.os_path_join(path, name)
        if g.os_path_exists(fileName):
            return None
    ok = g.app.gui.runAskYesNoDialog(c,
        title='Create myLeoSettings.leo?',
        message=f"Create myLeoSettings.leo in {homeLeoDir}?",
    )
    if ok == 'no':
        return None
    # get '@enabled-plugins' from g.app.globalConfigDir
    fileName = g.os_path_join(configDir, "leoSettings.leo")
    leosettings = g.openWithFileName(fileName, old_c=c)
    enabledplugins = g.findNodeAnywhere(leosettings, '@enabled-plugins')
    enabledplugins = enabledplugins.b
    leosettings.close()
    # now create "~/.leo/myLeoSettings.leo"
    fileName = g.os_path_join(homeLeoDir, name)
    c2 = g.openWithFileName(fileName, old_c=c)
    # add content to outline
    nd = c2.rootPosition()
    nd.h = "Settings README"
    nd.b = (
        "myLeoSettings.leo personal settings file created {time}\n\n"
        "Only nodes that are descendants of the @settings node are read.\n\n"
        "Only settings you need to modify should be in this file, do\n"
        "not copy large parts of leoSettings.py here.\n\n"
        "For more information see http://leoeditor.com/customizing.html"
        "".format(time=time.asctime())
    )
    nd = nd.insertAfter()
    nd.h = '@settings'
    nd = nd.insertAsNthChild(0)
    nd.h = '@enabled-plugins'
    nd.b = enabledplugins
    nd = nd.insertAfter()
    nd.h = '@keys'
    nd = nd.insertAsNthChild(0)
    nd.h = '@shortcuts'
    nd.b = (
        "# You can define keyboard shortcuts here of the form:\n"
        "#\n"
        "#    some-command Shift-F5\n"
    )
    c2.redraw()
    return c2
</t>
<t tx="ekr.20150204165040.4">def openAtShadowFileForReading(self, fn):
    """Open an @shadow for reading and return shadow_fn."""
    at = self
    x = at.c.shadowController
    # readOneAtShadowNode should already have checked these.
    shadow_fn = x.shadowPathName(fn)
    shadow_exists = (g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn))
    if not shadow_exists:
        g.trace('can not happen: no private file',
            shadow_fn, g.callers())
        at.error(f"can not happen: private file does not exist: {shadow_fn}")
        return None
    # This method is the gateway to the shadow algorithm.
    x.updatePublicAndPrivateFiles(at.root, fn, shadow_fn)
    return shadow_fn
</t>
<t tx="ekr.20150207044400.12">def op_delete(self, tag, ai, aj, bi, bj):
    """Handle the 'delete' opcode."""
    x = self
    for i in range(ai, aj):
        x.put_sentinels(i)
</t>
<t tx="ekr.20150207044400.13">def op_equal(self, tag, ai, aj, bi, bj):
    """Handle the 'equal' opcode."""
    x = self
    assert aj - ai == bj - bi and x.a[ai:aj] == x.b[bi:bj]
    for i in range(ai, aj):
        x.put_sentinels(i)
        x.put_plain_line(x.a[i])
            # works because x.lines[ai:aj] == x.lines[bi:bj]
</t>
<t tx="ekr.20150207044400.14">def op_insert(self, tag, ai, aj, bi, bj):
    """Handle the 'insert' opcode."""
    x = self
    for i in range(bi, bj):
        x.put_plain_line(x.b[i])
    # Prefer to put sentinels after inserted nodes.
    # Requires a call to x.put_sentinels(0) before the main loop.
</t>
<t tx="ekr.20150207044400.15">def op_replace(self, tag, ai, aj, bi, bj):
    """Handle the 'replace' opcode."""
    x = self
    if 1:
        # Intersperse sentinels and lines.
        b_lines = x.b[bi:bj]
        for i in range(ai, aj):
            x.put_sentinels(i)
            if b_lines:
                x.put_plain_line(b_lines.pop(0))
        # Put any trailing lines.
        while b_lines:
            x.put_plain_line(b_lines.pop(0))
    else:
        # Feasible. Causes the present unit tests to fail.
        for i in range(ai, aj):
            x.put_sentinels(i)
        for i in range(bi, bj):
            x.put_plain_line(x.b[i])
</t>
<t tx="ekr.20150207044400.16">def op_bad(self, tag, ai, aj, bi, bj):
    """Report an unexpected opcode."""
    x = self
    x.error(f"unknown SequenceMatcher opcode: {tag!r}")
</t>
<t tx="ekr.20150207044400.9">"""
The Mulder update algorithm, revised by EKR.

Use the diff between the old and new public lines to insperse sentinels
from old_private_lines into the result.

The algorithm never deletes or rearranges sentinels. However, verbatim
sentinels may be inserted or deleted as needed.
"""
</t>
<t tx="ekr.20150207111757.178">def dump_lines(self, lines, title):
    """Dump the given lines."""
    print(f"\n{title}...\n")
    for i, line in enumerate(lines):
        g.pr(f"{i:4} {line!r}")
</t>
<t tx="ekr.20150207111757.180">def dump_args(self):
    """Dump the argument lines."""
    x = self
    table = (
        (x.old_sent_lines, 'old private lines'),
        (x.a, 'old public lines'),
        (x.b, 'new public lines'),
    )
    for lines, title in table:
        x.dump_lines(lines, title)
    g.pr()
</t>
<t tx="ekr.20150208060128.7">def preprocess(self, lines):
    """
    Preprocess public lines, adding newlines as needed.
    This happens before the diff.
    """
    result = []
    for line in lines:
        if not line.endswith('\n'):
            line = line + '\n'
        result.append(line)
    return result
</t>
<t tx="ekr.20150208223018.4">def put_plain_line(self, line):
    """Put a plain line to x.results, inserting verbatim lines if necessary."""
    x = self
    if x.marker.isSentinel(line):
        x.results.append(x.verbatim_line)
        if x.trace: print(f"put {repr(x.verbatim_line)}")
    x.results.append(line)
    if x.trace: print(f"put {line!r}")
</t>
<t tx="ekr.20150209044257.6">def init_data(self):
    """
    Init x.sentinels and x.trailing_sentinels arrays.
    Return the list of non-sentinel lines in x.old_sent_lines.
    """
    x = self
    lines = x.old_sent_lines
    sentinels = []
        # The sentinels preceding each non-sentinel line,
        # not including @verbatim sentinels.
    new_lines = []
        # A list of all non-sentinel lines found.  Should match x.a.
    x.sentinels = []
        # A list of lists of sentinels preceding each line.
    i = 0
    while i &lt; len(lines):
        line = lines[i]
        i += 1
        if x.marker.isVerbatimSentinel(line):
            # Do *not* include the @verbatim sentinel.
            if i &lt; len(lines):
                line = lines[i]
                i += 1
                x.sentinels.append(sentinels)
                sentinels = []
                new_lines.append(line)
            else:
                x.verbatim_error()
        elif x.marker.isSentinel(line):
            sentinels.append(line)
        else:
            x.sentinels.append(sentinels)
            sentinels = []
            new_lines.append(line)
    x.trailing_sentinels = sentinels
    return new_lines
</t>
<t tx="ekr.20150209044257.8">def put_sentinels(self, i):
    """Put all the sentinels to the results"""
    x = self
    if 0 &lt;= i &lt; len(x.sentinels):
        sentinels = x.sentinels[i]
        if x.trace: g.trace(f"{i:3} {sentinels}")
        x.results.extend(sentinels)
</t>
<t tx="ekr.20150225133846.7">def doDiff(self):
    """Support --diff option after loading Leo."""
    if len(self.old_argv[2:]) == 2:
        pass  # c.editFileCommands.compareAnyTwoFiles gives a message.
    else:
        # This is an unusual situation.
        g.es('--diff mode. sys.argv[2:]...', color='red')
        for z in self.old_argv[2:]:
            g.es(g.shortFileName(z) if z else repr(z), color='blue')
    commanders = g.app.commanders()
    if len(commanders) == 2:
        c = commanders[0]
        c.editFileCommands.compareAnyTwoFiles(event=None)
</t>
<t tx="ekr.20150304125314.4">@tabwidth -2
@killbeautify
@language xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;!--
    &lt;link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/default.min.css"&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"&gt;&lt;/script&gt;
    --&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;!-- &lt;h4&gt;Outline Pane&lt;/h4&gt; --&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;!-- &lt;h4&gt;Body Pane&lt;/h4&gt; --&gt;
      &lt;pre class="body-text"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test ='./v' &gt;
        &lt;xsl:attribute name="has-children"&gt;1&lt;/xsl:attribute&gt;
        &lt;h1&gt;+ &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
        &lt;xsl:apply-templates select = 'v'/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test ='vh' &gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:when&gt;
      &lt;!--
      &lt;xsl:otherwise&gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:otherwise&gt;
      --&gt;
    &lt;/xsl:choose&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.4">@language xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;h1&gt;Body Pane&lt;/h1&gt;
      &lt;pre class="body-text"&gt;body&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;h1&gt;&lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
    &lt;xsl:if test ='./v' &gt;
      &lt;xsl:apply-templates select = 'v'/&gt;
    &lt;/xsl:if&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.5">&lt;style&gt;
    /* pre { background:#FFE7C6; } */
    /* Must use h1 for nodes: see below. */
    h1 {
      font-size: 12pt;
      font-style: normal;
      font-weight: normal;
    }
    div.outlinepane {
      position: absolute;
      background: #ffffec; /* Leo yellow */
      top: 10px;
      height: 300px;
      width: 700px;
      overflow: scroll;
      line-height: 0.8;

    }
    div.bodypane {
      position: absolute;
      top: 310px;
      height: 300px;
      width: 700px;
      overflow: scroll;
    }
    div.tnode {
        visibility: hidden;
        height: 0;
    }
    div.node {
        position: relative;
        left: 20px;
    }
    div.node[has-children] &gt; h1 {
        &lt;!-- works --&gt;
        &lt;!-- background: red; --&gt;
    }
&lt;/style&gt;
</t>
<t tx="ekr.20150304130753.6">@language javascript

&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;script&gt;

  $(document).ready(function(){
    if (true) {
        // Toggle all but top-level nodes.
        // This requires an indication
        $(".node").toggle()
        $(".outlinepane").children(".node").toggle()
    } else {
        // Toggle all second-level nodes.
        // Safer, until we can see which nodes have children.
        $(".outlinepane").children(".node").children(".node").toggle()
    }
    $("h1").click(function(){
      $(this).parent().children("div.node").toggle();
      // The parent div's id is v.x.
      // Find the tnode div whose id is t.x.
      console.clear();
      parent_id=$(this).parent().attr("id");
      if (parent_id) {
        target=$(this).parent().attr("id").substring(2);
          console.log("clicked:"+$(this).text())
          // console.log("parent:"+$(this).parent())
          // console.log("target:"+target)
        $(".tnode").each(function(){
          console.log($(this).attr("id"))
          target2=$(this).attr("id").substring(2);
          if (target === target2) {
            console.log("found:"+target2)
            // $("pre.body-text").text($(this).text());
            $("code").text($(this).text());
          };
        }); // end .each.
      };
    });
  });
@language html
&lt;/script&gt;
</t>
<t tx="ekr.20150326145530.1"># Hand-written Leo colorizer control file for forth mode.
# This file is in the public domain.
@killbeautify
from leo.core import leoGlobals as g
&lt;&lt; define mode rules &gt;&gt;
&lt;&lt; define mode data &gt;&gt;
&lt;&lt; define extendForth class &gt;&gt;
e = extendForth()

def pre_init_mode(c):
    e.c = c
    e.init()
    e.createKeywords()
    e.createBracketRules()
    e.createDefiningWordRules()

</t>
<t tx="ekr.20150326145530.10">def createKeywords(self):
    """
    Create the mode keyword table and
    entries in the rulesDict for the forth_keyword_rule.
    """
    # global forth_main_keywords_dict
    # global forth_keyword_rule
    table = (
        (self.keywords, 'keyword1'),
      # (self.definingwords,    'keyword2'), # Done in createDefiningWordRules.
        (self.boldwords, 'keyword3'),
        (self.bolditalicwords, 'keyword4'),
        (self.italicwords, 'keyword5'),
        (self.stringwords, 'string'),
    )
    d = forth_main_keywords_dict
    for keywordList, kind in table:
        for z in keywordList:
            # Create the entry in the keyword table.
            if kind == 'string':
                func = self.createStringRule(d, z)
            else:
                func = forth_keyword_rule
            # Always make the entry.
            d[z] = kind
            self.extendRulesDict(ch=z[0], func=func)

</t>
<t tx="ekr.20150326145530.11">def createStringRule(self, d, pair):
    """Create an entry in d for a string keyword."""
    aList = pair.split(' ')
    if len(aList) != 2:
        g.trace('can not happen: expecting pair of forth strings:', pair)
        return None
    begin, end = aList

    def forth_string_word_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin=begin.strip(), end=end.strip(),
            at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)  # Don't require ending word.

    return forth_string_word_rule

</t>
<t tx="ekr.20150326145530.12">def extendRulesDict(self, ch, func):
    global rulesDict
    # Extend the rulesDict entry for the first character of z.
    aList = rulesDict.get(ch, [])
    if func not in aList:
        aList.append(func)
        rulesDict[ch] = aList

</t>
<t tx="ekr.20150326145530.2"># Rules for forth_main ruleset.

def forth_block_comment_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="(", end=")",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def forth_comment_rule(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="\\",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word
        delegate="", exclude_match=False)

def forth_keyword_rule(colorer, s, i):
    return colorer.match_keywords(s, i)

def forth_string_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
# ==========================

if 0:

    def forth_rule0(colorer, s, i):
        return colorer.match_eol_span(s, i, kind="comment1", seq="#",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False)

    def forth_rule1(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="\"\"\"", end="\"\"\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule2(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="'''", end="'''",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule3(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule4(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule5(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule6(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="!",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule7(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule8(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule9(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="+",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule10(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="-",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule11(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="/",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule12(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="*",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule13(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule14(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule15(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="%",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule16(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&amp;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule17(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="|",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule18(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="^",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule19(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="~",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule20(colorer, s, i):
        return colorer.match_mark_previous(s, i, kind="function", pattern="(",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

    def forth_rule21(colorer, s, i):
        return colorer.match_keywords(s, i)
</t>
<t tx="ekr.20150326145530.3"># Properties for forth mode.

properties = {
    # "indentNextLines": "\\s*[^#]{3,}:\\s*(#.*)?",
    "lineComment": "\\",
}
# Attributes dict for forth_main ruleset.
forth_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    # "escape": "\\",
    "highlight_digits": "false",
    "ignore_case": "false",
    "no_word_sep": "",
}
# Dictionary of attributes dictionaries for forth mode.
attributesDictDict = {
    "forth_main": forth_main_attributes_dict,
}
# Keywords dict for forth_main ruleset.
forth_main_keywords_dict = {}  # Created by extendForth class.
# Dictionary of keywords dictionaries for forth mode.
keywordsDictDict = {
    "forth_main": forth_main_keywords_dict,
}
# Rules dict for forth_main ruleset.
# This is extended by extendForth.
rulesDict = {
    '(': [forth_block_comment_rule],
    '\\': [forth_comment_rule],
    '"': [forth_string_rule],
}
# x.rulesDictDict for forth mode.
rulesDictDict = {
    "forth_main": rulesDict,
}
# Import dict for forth mode.
importDict = {}


class extendForth:
    """A helper class to extend the mode tables from @data forth-x settings."""

</t>
<t tx="ekr.20150326145530.4">    @others
</t>
<t tx="ekr.20150326145530.5">def __init__(self):
    self.c = None  # set by pre_init_mode function.
    #
    # Default forth keywords: extended by @data forth-words
    # Forth words to be rendered in boldface: extended by @data forth-bold-words
    self.boldwords = []
    #
    # Forth bold-italics words: extended by @data forth-bold-italic-words
    # Note: on some boxen, bold italics may show in plain bold.
    self.bolditalicwords = []
    #
    # Forth words that define brackets: extended by @data forth-delimiter-pairs
    self.brackets = []  # Helper: a list of tuples.
    self.brackets1 = []
    self.brackets2 = []
    #
    # Words which define other words: extended by forth-defwords
    self.definingwords = []
    #
    # Forth words to be rendered in italics: extended by forth-italic-words
    self.italicwords = []
    #
    # Default keywords: extended by @data forth-keywords
    self.keywords = []
        # "variable", "constant", "code", "end-code",
        # "dup", "2dup", "swap", "2swap", "drop", "2drop",
        # "r&gt;", "&gt;r", "2r&gt;", "2&gt;r",
        # "if", "else", "then",
        # "begin", "again", "until", "while", "repeat",
        # "v-for", "v-next", "exit",
        # "meta", "host", "target", "picasm", "macro",
        # "needs", "include",
        # "'", "[']",
        # # ":", # Now a defining word.
        # ";",
        # "@", "!", ",", "1+", "+", "-",
        # "&lt;", "&lt;=", "=", "&gt;=", "&gt;",
        # "invert", "and", "or",
    #
    # Forth words which start strings: extended by @data forth-string-word-pairs
    self.stringwords = []
    self.stringwords1 = []
    self.stringwords2 = []
    self.verbose = False  # True: tell when extending forth words.

</t>
<t tx="ekr.20150326145530.6">def init(self):
    """Set our ivars from settings."""
    c = self.c
    assert(c)
    table = (
        (self.definingwords, "forth-defwords"),
        (self.brackets, "forth-delimiter-pairs"),
        (self.keywords, "forth-words"),
        (self.stringwords, "forth-string-word-pairs"),
        (self.boldwords, "forth-bold-words"),
        (self.bolditalicwords, "forth-bold-italic-words"),
        (self.italicwords, "forth-italic-words"),
    )
    # Add entries from @data nodes (if they exist) to the corresponding lists.
    for (ivarList, setting) in table:
        extras = []
        aList = c.config.getData(setting)
        if aList:
            for s in aList:
                s = s.strip()
                if s and s[0] != '\\':
                    extras.append(s)
            if extras:
                if self.verbose:
                    if not g.app.unitTesting and not g.app.batchMode:
                        g.pr("Found extra forth: %s" % " ".join(extras))
                ivarList.extend(extras)
    # Create brackets1/2 and stringwords1/2 lists.
    table2 = (
        ("brackets", "@data forth-delimiter-pairs"),
        ("stringwords", "@data forth-string-word-pairs"),
    )
    for (ivar, setting) in table2:
        self.splitList(ivar, setting)

</t>
<t tx="ekr.20150326145530.7">def splitList(self, ivar, setting):
    """Process lines containing pairs of entries
    in a list whose *name* is ivar.
    Put the results in ivars whose names are ivar1 and ivar2."""
    result1 = []; result2 = []
    aList = getattr(self, ivar)
    # Look for pairs.  Comments have already been removed.
    for s in aList:
        pair = s.split(' ')
        if len(pair) == 2 and pair[0].strip() and pair[1].strip():
            result1.append(pair[0].strip())
            result2.append(pair[1].strip())
        else:
            g.es_print('%s: ignoring line: %s' % (setting, s))
    # Set the ivars.
    name1 = '%s1' % ivar
    name2 = '%s2' % ivar
    setattr(self, name1, result1)
    setattr(self, name2, result2)

</t>
<t tx="ekr.20150326145530.8">def createBracketRules(self):
    for z in self.brackets1:
        func = self.createBracketRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createBracketRule(self, begin):
    i = self.brackets1.index(begin)
    end = self.brackets2[i]

    def forth_bracket_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="bracketRange", begin=begin, end=end,
            at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=True)  # Require word.

    return forth_bracket_rule

</t>
<t tx="ekr.20150326145530.9">def createDefiningWordRules(self):
    for z in self.definingwords:
        func = self.createDefiningWordRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createDefiningWordRule(self, word):

    def forth_defining_word_rule(colorer, s, i):

        return colorer.match_word_and_regexp(s, i,
            kind1="keyword2",  # defining word
            word=word,
            kind2="keyword3",  # bold
            pattern=r'(\s)*(\S)+',
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            exclude_match=False)

    return forth_defining_word_rule

</t>
<t tx="ekr.20150326180928.1">def open_file(self, root):
    '''Open the the file in vim using c.openWith.'''
    c = self.c
    efc = g.app.externalFilesController
    # Common arguments.
    tab_arg = "-tab" if self.uses_tab else ""
    remote_arg = "--remote" + tab_arg + "-silent"
    args = [self.vim_exe, "--servername", "LEO", remote_arg] # No cursor arg.
    if self.entire_file:
        # vim-open-file
        args.append('+0') # Go to first line of the file. This is an Ex command.
        assert root.isAnyAtFileNode(), root
        dir_ = g.setDefaultDirectory(c, root)
        fn = c.expand_path_expression(root.anyAtFileNodeName()) # #1341.
        fn = c.os_path_finalize_join(dir_, fn)
    else:
        # vim-open-node
        args.append(self.get_cursor_arg())
            # Set the cursor position to the current line in the node.
        ext = 'txt'
        fn = efc.create_temp_file(c, ext, c.p)
    c_arg = '%s %s' % (' '.join(args), fn)
    command = 'subprocess.Popen(%s,shell=True)' % c_arg
    try:
        subprocess.Popen(c_arg, shell=True)
    except OSError:
        g.es_print(command)
        g.es_exception()
</t>
<t tx="ekr.20150330033306.1">on_idle_count = 0

def on_idle(self):
    '''
    Check for changed open-with files and all external files in commanders
    for which @bool check_for_changed_external_file is True.
    '''
    #
    # #1240: Note: The "asking" dialog prevents idle time.
    #
    if not g.app or g.app.killed or g.app.restarting:  # #1240.
        return
    self.on_idle_count += 1
    # New in Leo 5.7: always handle delayed requests.
    if g.app.windowList:
        c = g.app.log and g.app.log.c
        if c:
            c.outerUpdate()
    # Fix #262: Improve performance when @bool check-for-changed-external-files is True.
    if self.unchecked_files:
        # Check all external files.
        for ef in self.unchecked_files:
            self.idle_check_open_with_file(ef)
        self.unchecked_files = []
    elif self.unchecked_commanders:
        # Check the next commander for which
        # @bool check_for_changed_external_file is True.
        c = self.unchecked_commanders.pop()
        self.idle_check_commander(c)
    else:
        # Add all commanders for which
        # @bool check_for_changed_external_file is True.
        self.unchecked_commanders = [
            z for z in g.app.commanders() if self.is_enabled(z)
        ]
        self.unchecked_files = [z for z in self.files if z.exists()]
</t>
<t tx="ekr.20150402111403.1"></t>
<t tx="ekr.20150402111413.1">def addToCommandHistory(self, commandName):
    """Add a name to the command history."""
    k = self
    h = k.commandHistory
    if commandName in h:
        h.remove(commandName)
    h.append(commandName)
    k.commandIndex = None
</t>
<t tx="ekr.20150402111935.1">def sortCommandHistory(self):
    """Sort the command history."""
    k = self
    k.commandHistory.sort()
    k.commandIndex = None
</t>
<t tx="ekr.20150402165918.1">def commandHistoryFwd(self):
    """
    Move down the Command History - fall off the bottom (return empty string)
    if necessary
    """
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        commandName = ''
        if i == len(h) - 1:
            # fall off the bottom
            i = None
        elif i is not None:
            # move to next down in list
            i += 1
            commandName = h[i]
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
</t>
<t tx="ekr.20150402171131.1">def commandHistoryBackwd(self):
    """
    Return the previous entry in the Command History - stay at the top
    if we are there
    """
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        if i is None:
            # first time in - set to last entry
            i = len(h) - 1
        elif i &gt; 0:
            i -= 1
        commandName = h[i]
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
</t>
<t tx="ekr.20150403044823.1">def idle_check_at_file_node(self, c, p):
    '''Check the @&lt;file&gt; node at p for external changes.'''
    path = g.fullPath(c, p)
    if not self.has_changed(path):
        return
    if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
        # Fix #1081: issue a warning.
        self.warn(c, path, p=p)
    elif self.ask(c, path, p=p):
        c.redraw(p=p)
        c.refreshFromDisk(p)
        c.redraw()
    # Always update the path &amp; time to prevent future warnings.
    self.set_time(path)
    self.checksum_d[path] = self.checksum(path)
</t>
<t tx="ekr.20150403045207.1">def has_changed(self, path):
    '''Return True if the file at path has changed outside of Leo.'''
    if not path:
        return False
    if not g.os_path_exists(path):
        return False
    if g.os_path_isdir(path):
        return False
    #
    # First, check the modification times.
    old_time = self.get_time(path)
    new_time = self.get_mtime(path)
    if not old_time:
        # Initialize.
        self.set_time(path, new_time)
        self.checksum_d[path] = self.checksum(path)
        return False
    if old_time == new_time:
        return False
    #
    # Check the checksums *only* if the mod times don't match.
    old_sum = self.checksum_d.get(path)
    new_sum = self.checksum(path)
    if new_sum == old_sum:
        # The modtime changed, but it's contents didn't.
        # Update the time, so we don't keep checking the checksums.
        # Return False so we don't prompt the user for an update.
        self.set_time(path, new_time)
        return False
    # The file has really changed.
    assert old_time, path
    return True
</t>
<t tx="ekr.20150403150655.1">def fullPath(c, p, simulate=False):
    """
    Return the full path (including fileName) in effect at p. Neither the
    path nor the fileName will be created if it does not exist.
    """
    # Search p and p's parents.
    for p in p.self_and_parents(copy=False):
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        fn = p.h if simulate else p.anyAtFileNodeName()
            # Use p.h for unit tests.
        if fn:
            # Fix #102: expand path expressions.
            fn = c.expand_path_expression(fn)  # #1341.
            return g.os_path_finalize_join(path, fn)  # #1341.
    return ''
</t>
<t tx="ekr.20150404045115.1">def idle_check_commander(self, c):
    '''
    Check all external files corresponding to @&lt;file&gt; nodes in c for
    changes.
    '''
    # #1240: Check the .leo file itself.
    self.idle_check_leo_file(c)
    #
    # #1100: always scan the entire file for @&lt;file&gt; nodes.
    # #1134: Nested @&lt;file&gt; nodes are no longer valid, but this will do no harm.
    for p in c.all_unique_positions():
        if p.isAnyAtFileNode():
            self.idle_check_at_file_node(c, p)
</t>
<t tx="ekr.20150404052819.1">def checksum(self, path):
    '''Return the checksum of the file at the given path.'''
    import hashlib
    # #1454: Explicitly close the file.
    with open(path, 'rb') as f:
        s = f.read()
    return hashlib.md5(s).hexdigest()
</t>
<t tx="ekr.20150405200212.1">def ask(self, c, path, p=None):
    '''
    Ask user whether to overwrite an @&lt;file&gt; tree.
    Return True if the user agrees.
    '''
    if g.unitTesting:
        return False
    if c not in g.app.commanders():
        return False
    is_leo = path.endswith(('.leo', '.db'))
    is_external_file = not is_leo
    #
    # Create the message.
    message1 = f"{g.splitLongFileName(path)} has changed outside Leo.\n"
    if is_leo:
        message2 = 'Restart Leo?'
    elif p:
        message2 = f"Reload {p.h}?"
    else:
        for ef in self.files:
            if ef.path == path:
                message2 = f"Reload {ef.p.h}?"
                break
        else:
            message2 = f"Reload {path}?"
    #
    # #1240: Note: This dialog prevents idle time.
    result = g.app.gui.runAskYesNoDialog(c,
        'Overwrite the version in Leo?',
        message1 + message2,
        yes_all=is_external_file,
        no_all=is_external_file,
    )
    return bool(result and 'yes' in result.lower())
        # Careful: may be unit testing.
</t>
<t tx="ekr.20150407124259.1">def idle_check_open_with_file(self, ef):
    '''Update the open-with node given by ef.'''
    assert isinstance(ef, ExternalFile), ef
    if ef.path and os.path.exists(ef.path):
        time = self.get_mtime(ef.path)
        if time and time != ef.time:
            ef.time = time  # inhibit endless dialog loop.
            self.update_open_with_node(ef)
</t>
<t tx="ekr.20150407205631.1">def update_open_with_node(self, ef):
    '''Update the body text of ef.p to the contents of ef.path.'''
    assert isinstance(ef, ExternalFile), ef
    c, p = ef.c, ef.p.copy()
    # Ask the user how to resolve the conflict.
    if self.ask(c, ef.path, p=p):
        g.blue(f"updated {p.h}")
        s, e = g.readFileIntoString(ef.path)
        p.b = s
        if c.config.getBool('open-with-goto-node-on-update'):
            c.selectPosition(p)
        if c.config.getBool('open-with-save-on-update'):
            c.save()
        else:
            p.setDirty()
            c.setChanged()
</t>
<t tx="ekr.20150413091056.1">"""Warn if leoProjects.txt or leoToDo.txt contain any clones."""

clones,nodes,seen = 0,0,set()
table = (
  '@file ../doc/leoProjects.txt',
  '@file ../doc/leoToDo.txt',
)

def check_clone(c,p0,root):
    """Warn if p appears in any @&lt;file&gt; node outside of root's tree."""
    global nodes,seen
    v = p0.v
    for p in c.all_positions():
        nodes += 1
        if p.v == v:
            # Check *all* ancestors, not just the nearest one.
            for parent in p.self_and_parents():
                nodes += 1
                if parent.isAnyAtFileNode() and parent.v != root.v:
                    if parent.v not in seen:
                        seen.add(parent.v)
                        g.es_print('%s and %s contain clone: %s' % (
                            root.h,parent.h,p0.h))

for h in table:
    root = g.findNodeAnywhere(c,h)
    if root:
        for p in root.self_and_subtree():
            nodes += 1
            if p.isCloned():
                clones += 1
                check_clone(c,p,root)
    else:
        g.es_print('not found',h,color='red')
print('done: %s nodes, %s clones' % (nodes,clones))

@tabwidth -4
@language python
</t>
<t tx="ekr.20150425143043.1">def initCommandHistory(self):
    """Init command history from @data command-history nodes."""
    k, c = self, self.c
    aList = c.config.getData('history-list') or []
    for command in reversed(aList):
        k.addToCommandHistory(command)

def resetCommandHistory(self):
    """ reset the command history index to indicate that
        we are pointing 'past' the last entry
    """
    self.commandIndex = None
    #
</t>
<t tx="ekr.20150425145248.1">run-pylint
clone-to-at-spot
beautify-tree
cfa-code
sort-lines
# show-data
# test-ptb
check-clones
expand-log-pane
contract-log-pane</t>
<t tx="ekr.20150502050609.1">c.backup_helper(sub_dir='leoPy')
</t>
<t tx="ekr.20150507170849.1">g.cls()

print('===== Start =====')

class CreateDecorators:
    """
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    """
    def __init__(self,c,make_changes):
        self.c = c
        self.fixups = self.create_fixups()
        self.n = 0
        self.n_fail = 0
        self.make_changes=make_changes
        self.suppress = [
            'c.frame.body and c.frame.body.addEditor',
            'cls','cloneFindParents','cycleTabFocus',
            'k and k.keyboardQuit',
            'menuShortcutPlaceHolder','removeBlankLines',
            'saveBuffersKillLeo',
        ]
    @others

CreateDecorators(c,make_changes=False).run()
</t>
<t tx="ekr.20150507174711.1">def find_next_clone(self,p):
    v = p.v
    p = p.copy()
    p.moveToThreadNext()
    wrapped = False
    while 1:
        # g.trace(p.v,p.h)
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()
    return p
</t>
<t tx="ekr.20150507175246.1">def munge_lines(self,root,publicCommands):
    """Return munged lines of """
    s = publicCommands.b
    i,j = s.find('{'),s.find('}')
    s = s[i+1:j]
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150508062944.1">def run(self):
    """Top-level code."""
    self.n = 0
    found = g.findNodeAnywhere(c,'Found: getPublicCommands')
    assert found
    for child in found.children():
        publicCommands = self.find_next_clone(child)
        root = self.find_class(publicCommands)
        if root:
            lines = self.munge_lines(root,publicCommands)
            d = self.create_d(lines,publicCommands)
            self.create_decorators(d,root)
    print('\n%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150508063412.1">def create_decorators(self,d,root):
    """Create decorators for all items in d in root's tree."""
    # print('***** %s' % root.h)
    if root.h in self.fixups:
        roots = []
        aList = self.fixups.get(root.h)
        for root2_h in aList:
            root2 = g.findNodeAnywhere(self.c,root2_h)
            if root2:
                # g.trace(root.h,'=====&gt;',root2.h)
                roots.append(root2)
            else:
                g.trace('===== not found',root2_h)
    else:
        roots = [root]
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print('===== not found: %30s %s' % (root.h,f_name))
            self.n_fail += 1
</t>
<t tx="ekr.20150508063538.1">def create_d(self,lines,publicCommands):
    """Create a dict. keys are method names; values are command names."""
    trace = False
    if trace:
        g.trace('\n', publicCommands.h)
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150508063926.1">def find_class(self,p):
    """Return the position of the class enclosing p."""
    for p2 in p.parents():
        if p2.h.lower().find('class') &gt; -1 and p2.b.find('class') &gt; -1:
            return p2
    else:
        g.trace('*** no class for p.h')
        return None
</t>
<t tx="ekr.20150508071622.1">def create_decorator(self,c_name,f_name,root):
    """
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    """
    # g.trace('%45s %s' % (c_name,f_name))
    trace = False
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        # if changed and self.make_changes:
            # new_body = ''.join(result)
            # # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150508074623.1">def create_fixups(self):
    """
    Return a fixup dict.
    Keys are headlines for classes.
    Values are new headlines of nodes containing the actual class.
    """
    return {
        'ChapterCommandsClass': ['class ChapterController'],
        'EditCommandsClass': [
            'EditCommandsClass',
            'class Commands',
            'class LeoQtFrame',
            'class LeoBody',
        ],
        'class SearchCommandsClass': ['class LeoFind (LeoFind.py)'],
        'KeyHandlerCommandsClass (add docstrings)': [
            'class KeyHandlerClass',
            'class AutoCompleterClass',
        ]
    }
</t>
<t tx="ekr.20150509035028.1">def cmd(name):
    """Command decorator for the leoKeys class."""
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'k',])
</t>
<t tx="ekr.20150509035140.1">def cmd(name):
    """Command decorator for the AutoCompleter class."""
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'k', 'autoCompleter'])
</t>
<t tx="ekr.20150509183433.1">g.cls()

# Changed files:
# leoApp.py
# leoAtFile.py
# leoCommands.py
# leoFileCommands.py
# leoFrame.py
# leoUndo.py
# qt_frame.py

make_changes = True
    # True, actually make the change

class CreateDecorators:
    """
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    """
    def __init__(self):
        self.n = 0
        self.n_fail = 0
        self.s = self.define_s()
    @others

CreateDecorators().run()
</t>
<t tx="ekr.20150509183433.2">def create_d(self,lines):
    """Create a dict. keys are method names; values are command names."""
    trace = False
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150509183433.3">def create_decorator(self,c_name,f_name,root):
    """
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    """
    trace = True
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        if changed and make_changes:
            new_body = ''.join(result)
            print('%40s %s' % (p.h[:40],decorator.rstrip()))
            # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150509183433.4">def create_decorators(self,d):
    """Create decorators for all items in d in root's tree."""
    table = (
        'class Commands', # c.
        'class LeoQtFrame', # f.
        'class LeoFrame', # f.
        'class LeoApp', # g.app.
        '@file leoAtFile.py', # c.atFileCommands
        '@file leoFileCommands.py', # c.fileCommands
        'class Undoer', # c.undoer
    )
    roots = []
    for h in table:
        root = g.findNodeAnywhere(c,h)
        assert root,h
        roots.append(root)
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print(f"===== not found: {f_name!r}")
            self.n_fail += 1
</t>
<t tx="ekr.20150509183433.8">def munge_lines(self,s):
    """Return munged lines of s. """
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150509183433.9">def run(self):
    """Top-level code."""
    lines = self.munge_lines(self.s)
    d = self.create_d(lines)
    self.create_decorators(d)
    print('%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150514035207.1"></t>
<t tx="ekr.20150514043714.3"></t>
<t tx="ekr.20150514043714.4">def beginCommand(self, w, undoType='Typing'):
    """Do the common processing at the start of each command."""
    c, p, u = self.c, self.c.p, self.c.undoer
    name = c.widget_name(w)
    if name.startswith('body'):
        self.undoData = b = g.Bunch()
        # To keep pylint happy.
        b.ch = ''
        b.name = name
        b.oldSel = w.getSelectionRange()
        b.oldText = p.b
        b.w = w
        b.undoType = undoType
        b.undoer_bunch = u.beforeChangeBody(p)  # #1733.
    else:
        self.undoData = None
    return w
</t>
<t tx="ekr.20150514043714.6">def endCommand(self, label=None, changed=True, setLabel=True):
    """
    Do the common processing at the end of each command.
    Handles undo only if we are in the body pane.
    """
    k, p, u= self.c.k, self.c.p, self.c.undoer
    w = self.editWidget(event=None)
    b = self.undoData
    if b and b.name.startswith('body') and changed:
        newText = w.getAllText()
        if b.undoType.capitalize() == 'Typing':
            u.doTyping(p, 'Typing', oldText=b.oldText, newText=newText, oldSel=b.oldSel)
        else:
            p.v.b = newText  # p.b would cause a redraw.
            u.afterChangeBody(p, b.undoType, b.undoer_bunch)
            
    self.undoData = None
    k.clearState()
    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
</t>
<t tx="ekr.20150514043850.14">def find_place_holder(self, p, do_placeholder):
    """
    Search for the next place-holder.
    If found, select the place-holder (without the delims).
    """
    c = self.c
    # Do #438: Search for placeholder in headline.
    s = p.h
    if do_placeholder or c.abbrev_place_start and c.abbrev_place_start in s:
        new_s, i, j = self.next_place(s, offset=0)
        if i is not None:
            p.h = new_s
            c.redraw(p)
            c.editHeadline()
            w = c.edit_widget(p)
            w.setSelectionRange(i, j, insert=j)
            return True
    s = p.b
    if do_placeholder or c.abbrev_place_start and c.abbrev_place_start in s:
        new_s, i, j = self.next_place(s, offset=0)
        if i is None:
            return False
        w = c.frame.body.wrapper
        switch = p != c.p
        if switch:
            c.selectPosition(p)
        else:
            scroll = w.getYScrollPosition()
        oldSel = w.getSelectionRange()
        w.setAllText(new_s)
        c.frame.body.onBodyChanged(undoType='find-place-holder', oldSel=oldSel)
        c.p.b = new_s
        if switch:
            c.redraw()
        w.setSelectionRange(i, j, insert=j)
        if switch:
            w.seeInsertPoint()
        else:
            # Keep the scroll point if possible.
            w.setYScrollPosition(scroll)
            w.seeInsertPoint()
        c.bodyWantsFocusNow()
        return True
    # #453: do nothing here.
        # c.frame.body.forceFullRecolor()
        # c.bodyWantsFocusNow()
    return False
</t>
<t tx="ekr.20150514043850.15">def make_script_substitutions(self, i, j, val):
    """Make scripting substitutions in node p."""
    c = self.c
    if not c.abbrev_subst_start:
        return val, False
    # Nothing to undo.
    if c.abbrev_subst_start not in val:
        return val, False
    # Perform all scripting substitutions.
    self.save_ins = None
    self.save_sel = None
    while c.abbrev_subst_start in val:
        prefix, rest = val.split(c.abbrev_subst_start, 1)
        content = rest.split(c.abbrev_subst_end, 1)
        if len(content) != 2:
            break
        content, rest = content
        try:
            self.expanding = True
            c.abbrev_subst_env['x'] = ''
            exec(content, c.abbrev_subst_env, c.abbrev_subst_env)
        except Exception:
            g.es_print('exception evaluating', content)
            g.es_exception()
        finally:
            self.expanding = False
        x = c.abbrev_subst_env.get('x')
        if x is None: x = ''
        val = f"{prefix}{x}{rest}"
        # Save the selection range.
        w = c.frame.body.wrapper
        self.save_ins = w.getInsertPoint()
        self.save_sel = w.getSelectionRange()
    if val == "__NEXT_PLACEHOLDER":
        # user explicitly called for next placeholder in an abbrev.
        # inserted previously
        val = ''
        do_placeholder = True
    else:
        do_placeholder = False
        oldSel = i, j
        c.frame.body.onBodyChanged(undoType='make-script-substitution', oldSel=oldSel)
    return val, do_placeholder
</t>
<t tx="ekr.20150514043850.16">def next_place(self, s, offset=0):
    """
    Given string s containing a placeholder like &lt;| block |&gt;,
    return (s2,start,end) where s2 is s without the &lt;| and |&gt;,
    and start, end are the positions of the beginning and end of block.
    """
    c = self.c
    if c.abbrev_place_start is None or c.abbrev_place_end is None:
        return s, None, None  # #1345.
    new_pos = s.find(c.abbrev_place_start, offset)
    new_end = s.find(c.abbrev_place_end, offset)
    if (new_pos &lt; 0 or new_end &lt; 0) and offset:
        new_pos = s.find(c.abbrev_place_start)
        new_end = s.find(c.abbrev_place_end)
        if not (new_pos &lt; 0 or new_end &lt; 0):
            g.es("Found earlier placeholder")
    if new_pos &lt; 0 or new_end &lt; 0:
        return s, None, None
    start = new_pos
    place_holder_delim = s[new_pos : new_end + len(c.abbrev_place_end)]
    place_holder = place_holder_delim[
        len(c.abbrev_place_start) : -len(c.abbrev_place_end)]
    s2 = s[:start] + place_holder + s[start + len(place_holder_delim) :]
    end = start + len(place_holder)
    return s2, start, end
</t>
<t tx="ekr.20150514043850.18">def replace_selection(self, w, i, j, s):
    """Replace w[i:j] by s."""
    w_name = g.app.gui.widget_name(w)
    c = self.c
    if i == j:
        abbrev = ''
    else:
        abbrev = w.get(i, j)
        w.delete(i, j)
    if s is not None:
        w.insert(i, s)
    if w_name.startswith('head'):
        pass  # Don't set p.h here!
    else:
        # Fix part of #438. Don't leave the headline.
        oldSel = j, j
        c.frame.body.onBodyChanged('Abbreviation', oldSel=oldSel)
    # Adjust self.save_sel &amp; self.save_ins
    if s is not None and self.save_sel is not None:
        # pylint: disable=unpacking-non-sequence
        i, j = self.save_sel
        ins = self.save_ins
        delta = len(s) - len(abbrev)
        self.save_sel = i + delta, j + delta
        self.save_ins = ins + delta
</t>
<t tx="ekr.20150514043850.7">def init_env(self):
    """
    Init c.abbrev_subst_env by executing the contents of the
    @data abbreviations-subst-env node.
    """
    c = self.c
    at = c.atFileCommands
    if c.abbrev_place_start and self.enabled:
        aList = self.subst_env
        script = []
        for z in aList:
            # Compatibility with original design.
            if z.startswith('\\:'):
                script.append(z[2:])
            else:
                script.append(z)
        script = ''.join(script)
        # Allow Leo directives in @data abbreviations-subst-env trees.
        # #1674: Avoid unnecessary entries in c.fileCommands.gnxDict.
        root = c.rootPosition()
        if root:
            v = root.v
        else:
            # Defensive programming. Probably will never happen.
            v = leoNodes.VNode(context=c)
            root = leoNodes.Position(v)
        # Similar to g.getScript.
        script = at.stringToString(
            root=root,
            s=script,
            forcePythonSentinels=True,
            sentinels=False)
        script = script.replace("\r\n", "\n")
        try:
            exec(script, c.abbrev_subst_env, c.abbrev_subst_env)
        except Exception:
            g.es('Error exec\'ing @data abbreviations-subst-env')
            g.es_exception()
    else:
        c.abbrev_subst_start = False
</t>
<t tx="ekr.20150514043850.8">def init_settings(self):
    """Called from AbbrevCommands.reload_settings aka reloadSettings."""
    c = self.c
    c.k.abbrevOn = c.config.getBool('enable-abbreviations', default=False)
    c.abbrev_place_end = c.config.getString('abbreviations-place-end')
    c.abbrev_place_start = c.config.getString('abbreviations-place-start')
    c.abbrev_subst_end = c.config.getString('abbreviations-subst-end')
    c.abbrev_subst_env = {'c': c, 'g': g, '_values': {},}
        # The environment for all substitutions.
        # May be augmented in init_env.
    c.abbrev_subst_start = c.config.getString('abbreviations-subst-start')
    # Local settings.
    self.enabled = (
        c.config.getBool('scripting-at-script-nodes') or
        c.config.getBool('scripting-abbreviations'))
    self.globalDynamicAbbrevs = c.config.getBool('globalDynamicAbbrevs')
    # @data abbreviations-subst-env must *only* be defined in leoSettings.leo or myLeoSettings.leo!
    if c.config:
        key = 'abbreviations-subst-env'
        if c.config.isLocalSetting(key, 'data'):
            g.issueSecurityWarning(f"@data {key}")
            self.subst_env = ""
        else:
            self.subst_env = c.config.getData(key, strip_data=False)
</t>
<t tx="ekr.20150514043850.9">def init_tree_abbrev(self):
    """Init tree_abbrevs_d from @data tree-abbreviations nodes."""
    c = self.c
    #
    # Careful. This happens early in startup.
    root = c.rootPosition()
    if not root:
        return
    if not c.p:
        c.selectPosition(root)
    if not c.p:
        return
    data = c.config.getOutlineData('tree-abbreviations')
    if data is None:
        return
    d = {}
    # #904: data may be a string or a list of two strings.
    aList = [data] if isinstance(data, str) else data
    for tree_s in aList:
        #
        # Expand the tree so we can traverse it.
        if not c.canPasteOutline(tree_s):
            return
        c.fileCommands.leo_file_encoding = 'utf-8'
        #
        # As part of #427, disable all redraws.
        try:
            old_disable = g.app.disable_redraw
            g.app.disable_redraw = True
            self.init_tree_abbrev_helper(d, tree_s)
        finally:
            g.app.disable_redraw = old_disable
    self.tree_abbrevs_d = d
</t>
<t tx="ekr.20150514045829.12">def renameBuffer(self, event):
    """Rename a buffer, i.e., change a node's headline."""
    g.es('rename-buffer not ready yet')
    if 0:
        self.c.k.setLabelBlue('Rename buffer from: ')
        self.getBufferName(event, self.renameBufferFinisher1)

def renameBufferFinisher1(self, name):
    self.fromName = name
    self.c.k.setLabelBlue(f"Rename buffer from: {name} to: ")
    event = None
    self.getBufferName(event, self.renameBufferFinisher2)

def renameBufferFinisher2(self, name):
    c = self.c
    p = self.findBuffer(self.fromName)
    if p:
        c.endEditing()
        p.h = name
        c.redraw(p)
</t>
<t tx="ekr.20150514063305.105">def findDebugger(self):
    """Find the debugger using settings."""
    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)
    debuggers = (
        # #1431: only expand path expression in @string debugger-path.
        c.expand_path_expression(c.config.getString('debugger-path')),
        g.os_path_join(pythonDir, 'Lib', 'site-packages', 'winpdb.py'),
            # winpdb 1.1.2 or newer.
        g.os_path_join(pythonDir, 'scripts', '_winpdb.py'),
            # Older version.
    )
    for debugger in debuggers:
        if debugger:
            debugger = c.os_path_finalize(debugger)
            if g.os_path_exists(debugger):
                return debugger
            g.warning('debugger does not exist:', debugger)
    g.es('no debugger found.')
    return None
</t>
<t tx="ekr.20150514063305.237">def deleteIconByName(self, t, name, relPath):  # t not used.
    """for use by the right-click remove icon callback"""
    c, p = self.c, self.c.p
    aList = self.getIconList(p)
    if not aList:
        return
    basePath = g.os_path_finalize_join(g.app.loadDir, "..", "Icons")  # #1341.
    absRelPath = g.os_path_finalize_join(basePath, relPath)  # #1341
    name = g.os_path_finalize(name)  # #1341
    newList = []
    for d in aList:
        name2 = d.get('file')
        name2 = g.os_path_finalize(name2)  # #1341
        name2rel = d.get('relPath')
        if not (name == name2 or absRelPath == name2 or relPath == name2rel):
            newList.append(d)
    if len(newList) != len(aList):
        self.setIconList(p, newList)
        c.setChanged()
        c.redraw_after_icons_changed()
    else:
        g.trace('not found', name)
</t>
<t tx="ekr.20150514063305.244">@cmd('indent-relative')
def indentRelative(self, event):
    """
    The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.

    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.
    """
    c = self.c
    undoType = 'indent-relative'
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    s = w.getAllText()
    ins = w.getInsertPoint()
    oldSel = w.getSelectionRange()
    # Find the previous non-blank line
    i, j = g.getLine(s, ins)
    while 1:
        if i &lt;= 0: return
        i, j = g.getLine(s, i - 1)
        line = s[i:j]
        if line.strip(): break
    self.beginCommand(w, undoType=undoType)
    try:
        k = g.skip_ws(s, i)
        ws = s[i:k]
        i2, j2 = g.getLine(s, ins)
        k = g.skip_ws(s, i2)
        line = ws + s[k:j2]
        w.delete(i2, j2)
        w.insert(i2, line)
        w.setInsertPoint(i2 + len(ws))
        c.frame.body.onBodyChanged(undoType, oldSel=oldSel)
    finally:
        self.endCommand(changed=True, setLabel=True)
</t>
<t tx="ekr.20150514063305.253">@cmd('backward-delete-char')
def backwardDeleteCharacter(self, event=None):
    """Delete the character to the left of the cursor."""
    c = self.c
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i, j = w.getSelectionRange()
    if wname.startswith('body'):
        self.beginCommand(w, undoType='Typing')
        try:
            tab_width = c.getTabWidth(c.p)
            changed = True
            if i != j:
                w.delete(i, j)
                w.setSelectionRange(i, i, insert=i)
            elif i == 0:
                changed = False
            elif tab_width &gt; 0:
                w.delete(ins - 1)
                w.setSelectionRange(ins - 1, ins - 1, insert=ins - 1)
            else:
                &lt;&lt; backspace with negative tab_width &gt;&gt;
        finally:
            self.endCommand(changed=changed, setLabel=False)
                # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        s = w.getAllText()
        # Delete something if we can.
        if i != j:
            j = max(i, min(j, len(s)))
            w.delete(i, j)
            w.setSelectionRange(i, i, insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins - 1)
            ins = ins - 1
            w.setSelectionRange(ins, ins, insert=ins)
</t>
<t tx="ekr.20150514063305.254">s = prev = w.getAllText()
ins = w.getInsertPoint()
i, j = g.getLine(s, ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)
# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n, n2)
count = 0
while n2 &gt; 0:
    n2 -= 1
    ch = prev[n - count - 1]
    if ch != ' ': break
    else: count += 1
# Make sure we actually delete something.
i = ins - (max(1, count))
w.delete(i, ins)
w.setSelectionRange(i, i, insert=i)
</t>
<t tx="ekr.20150514063305.259">@cmd('delete-char')
def deleteNextChar(self, event):
    """Delete the character to the right of the cursor."""
    c, w = self.c, self.editWidget(event)
    if not w:
        return
    wname = c.widget_name(w)
    if wname.startswith('body'):
        s = w.getAllText()
        i, j = w.getSelectionRange()
        self.beginCommand(w, undoType='delete-char')
        changed = True
        if i != j:
            w.delete(i, j)
            w.setInsertPoint(i)
        elif j &lt; len(s):
            w.delete(i)
            w.setInsertPoint(i)
        else:
            changed = False
        self.endCommand(changed=changed, setLabel=False)
    else:
        # No undo in this widget.
        s = w.getAllText()
        i, j = w.getSelectionRange()
        # Delete something if we can.
        if i != j:
            w.delete(i, j)
            w.setInsertPoint(i)
        elif j &lt; len(s):
            w.delete(i)
            w.setInsertPoint(i)
</t>
<t tx="ekr.20150514063305.262">@cmd('insert-newline')
def insertNewLine(self, event):
    """Insert a newline at the cursor."""
    self.insertNewlineBase(event)

insertNewline = insertNewLine

def insertNewlineBase(self, event):
    """A helper that can be monkey-patched by tables.py plugin."""
    # Note: insertNewlineHelper already exists.
    c, k = self.c, self.c.k
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    if not g.isTextWrapper(w):
        return  # pragma: no cover (defensive)
    name = c.widget_name(w)
    if name.startswith('head'):
        return
    oldSel = w.getSelectionRange()
    self.beginCommand(w, undoType='newline')
    self.insertNewlineHelper(w=w, oldSel=oldSel, undoType=None)
    k.setInputState('insert')
    k.showStateAndMode()
    self.endCommand()
</t>
<t tx="ekr.20150514063305.263">@cmd('newline-and-indent')
def insertNewLineAndTab(self, event):
    """Insert a newline and tab at the cursor."""
    trace = 'keys' in g.app.debug
    c, k = self.c, self.c.k
    p = c.p
    w = self.editWidget(event)
    if not w:
        return
    if not g.isTextWrapper(w):
        return
    name = c.widget_name(w)
    if name.startswith('head'):
        return
    if trace: g.trace('(newline-and-indent)')
    self.beginCommand(w, undoType='insert-newline-and-indent')
    oldSel = w.getSelectionRange()
    self.insertNewlineHelper(w=w, oldSel=oldSel, undoType=None)
    self.updateTab(p, w, smartTab=False)
    k.setInputState('insert')
    k.showStateAndMode()
    self.endCommand(changed=True, setLabel=False)
</t>
<t tx="ekr.20150514063305.266">@cmd('remove-blank-lines')
def removeBlankLines(self, event):
    """
    Remove lines containing nothing but whitespace.

    Select all lines if there is no existing selection.
    """
    c, p, u, w = self.c, self.c.p, self.c.undoer, self.editWidget(event)
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Initial data.
    oldYview = w.getYScrollPosition()
    lines = g.splitLines(w.getAllText())
    #
    # Calculate the result.
    changed, result = False, []
    for line in lines:
        if line.strip():
            result.append(line)
        else:
            changed = True
    if not changed:
        return  # pragma: no cover (defensive)
    #
    # Set p.b and w's text first.
    result = ''.join(result)
    p.b = result
    w.setAllText(result)
    i, j = 0, max(0, len(result) - 1)
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    c.undoer.afterChangeBody(p, 'remove-blank-lines', bunch)
</t>
<t tx="ekr.20150514063305.268"># @cmd('self-insert-command')

def selfInsertCommand(self, event, action='insert'):
    """
    Insert a character in the body pane.

    This is the default binding for all keys in the body pane.
    It handles undo, bodykey events, tabs, back-spaces and bracket matching.
    """
    trace = 'keys' in g.app.debug
    c, p, u, w = self.c, self.c.p, self.c.undoer, self.editWidget(event)
    undoType = 'Typing'
    if not w:
        return  # pragma: no cover (defensive)
    &lt;&lt; set local vars &gt;&gt;
    if not ch:
        return
    if trace: g.trace('ch', repr(ch)) # and ch in '\n\r\t'
    assert g.isStrokeOrNone(stroke)
    if g.doHook("bodykey1", c=c, p=p, ch=ch, oldSel=oldSel, undoType=undoType):
        return
    if ch == '\t':
        self.updateTab(p, w, smartTab=True)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key.
        self.backwardDeleteCharacter(event)
    elif ch in ('\r', '\n'):
        ch = '\n'
        self.insertNewlineHelper(w, oldSel, undoType)
    elif ch in '\'"' and c.config.getBool('smart-quotes'):
        self.doSmartQuote(action, ch, oldSel, w)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p, w, ch, oldSel)
    elif ch:
        # Null chars must not delete the selection.
        self.doPlainChar(action, ch, event, inBrackets, oldSel, stroke, w)
    #
    # Common processing.
    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w, spot)
    #
    # Update the text and handle undo.
    newText = w.getAllText()
    if newText != oldText:
        # Call u.doTyping to honor the user's undo granularity.
        newSel = w.getSelectionRange()
        newInsert = w.getInsertPoint()
        newSel = w.getSelectionRange()
        newText = w.getAllText()  # Converts to unicode.
        u.doTyping(p, 'Typing', oldText, newText,
            oldSel=oldSel, oldYview=oldYview, newInsert=newInsert, newSel=newSel)
    g.doHook("bodykey2", c=c, p=p, ch=ch, oldSel=oldSel, undoType=undoType)
</t>
<t tx="ekr.20150514063305.269">stroke = event.stroke if event else None
ch = event.char if event else ''
if ch == 'Return':
    ch = '\n'  # This fixes the MacOS return bug.
if ch == 'Tab':
    ch = '\t'
name = c.widget_name(w)
oldSel = w.getSelectionRange() if name.startswith('body') else (None, None)
oldText = p.b if name.startswith('body') else ''
oldYview = w.getYScrollPosition()
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.checkUnicode(ch) in brackets
</t>
<t tx="ekr.20150514063305.270">def doPlainTab(self, s, i, tab_width, w):
    """
    A helper for selfInsertCommand, called from updateTab.
    
    Insert spaces equivalent to one tab.
    """
    trace = 'keys' in g.app.debug
    start, end = g.getLine(s, i)
    s2 = s[start:i]
    width = g.computeWidth(s2, tab_width)
    if trace: g.trace('width', width)
    if tab_width &gt; 0:
        w.insert(i, '\t')
        ins = i + 1
    else:
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i, ' ' * n)
        ins = i + n
    w.setSelectionRange(ins, ins, insert=ins)
</t>
<t tx="ekr.20150514063305.271">def flashCharacter(self, w, i):
    """Flash the character at position i of widget w."""
    bg = self.bracketsFlashBg or 'DodgerBlue1'
    fg = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 3
    delay = self.bracketsFlashDelay or 75
    w.flashCharacter(i, bg, fg, flashes, delay)
</t>
<t tx="ekr.20150514063305.272">def flashMatchingBracketsHelper(self, c, ch, i, p, w):
    """Flash matching brackets at char ch at position i at widget w."""
    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d[self.openBracketsList[z]] = self.closeBracketsList[z]
        # reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d[self.closeBracketsList[z]] = self.openBracketsList[z]
        # reverse = True # Search backward
    s = w.getAllText()
    # A partial fix for bug 127: Bracket matching is buggy.
    language = g.getLanguageAtPosition(c, p)
    if language == 'perl':
        return
    j = g.MatchBrackets(c, p, language).find_matching_bracket(ch, s, i)
    if j is not None:
        self.flashCharacter(w, j)
</t>
<t tx="ekr.20150514063305.273">def initBracketMatcher(self, c):
    """Init the bracket matching code."""
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList = '([{'
        self.closeBracketsList = ')]}'
</t>
<t tx="ekr.20150514063305.274">def insertNewlineHelper(self, w, oldSel, undoType):

    c, p = self.c, self.c.p
    i, j = oldSel
    ch = '\n'
    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i, j)
        w.insert(i, ch)
        w.setInsertPoint(i + 1)
    else:
        w.insert(i, ch)
        w.setInsertPoint(i + 1)
        if (c.autoindent_in_nocolor or
            (c.frame.body.colorizer.useSyntaxColoring(p) and
            undoType != "Change")
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p, w)
    w.seeInsertPoint()
</t>
<t tx="ekr.20150514063305.275">def updateAutoIndent(self, p, w):
    """Handle auto indentation."""
    c = self.c
    tab_width = c.getTabWidth(p)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s, ins)
    i, j = g.getLine(s, i - 1)
    s = s[i : j - 1]
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s, 0, tab_width)
    if s and s[-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.findLanguageDirectives(c, p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width]
        tabex = 0
        for i, ch in enumerate(s):
            if ch == '\t':
                tabex += tab_width - 1
            if ch in '([{':
                bracketWidths.append(i + tabex + 1)
            elif ch in '}])' and len(bracketWidths) &gt; 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width, tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i, ws)
        w.setInsertPoint(i + len(ws))
        w.seeInsertPoint()
            # 2011/10/02: Fix cursor-movement bug.
</t>
<t tx="ekr.20150514063305.276">def updateAutomatchBracket(self, p, w, ch, oldSel):

    c = self.c
    d = c.scanAllDirectives(p)
    i, j = oldSel
    language = d.get('language')
    s = w.getAllText()
    if ch in ('(', '[', '{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(': ')', '[': ']', '{': '}'}.get(ch)
        if i != j: w.delete(i, j)
        w.insert(i, ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins - 1)
    else:
        ins = w.getInsertPoint()
        ch2 = s[ins] if ins &lt; len(s) else ''
        if ch2 in (')', ']', '}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins + 1)
        else:
            if i != j: w.delete(i, j)
            w.insert(i, ch)
            w.setInsertPoint(i + 1)
</t>
<t tx="ekr.20150514063305.277">def updateTab(self, p, w, smartTab=True):
    """
    A helper for selfInsertCommand.

    Add spaces equivalent to a tab.
    """
    c = self.c
    i, j = w.getSelectionRange()
        # Returns insert point if no selection, with i &lt;= j.
    if i != j:
        c.indentBody()
        return
    tab_width = c.getTabWidth(p)
    # Get the preceeding characters.
    s = w.getAllText()
    start, end = g.getLine(s, i)
    after = s[i:end]
    if after.endswith('\n'):
        after = after[:-1]
    # Only do smart tab at the start of a blank line.
    doSmartTab = (smartTab and c.smart_tab and i == start)
        # Truly at the start of the line.
        # and not after # Nothing *at all* after the cursor.
    if doSmartTab:
        self.updateAutoIndent(p, w)
        # Add a tab if otherwise nothing would happen.
        if s == w.getAllText():
            self.doPlainTab(s, i, tab_width, w)
    else:
        self.doPlainTab(s, i, tab_width, w)
</t>
<t tx="ekr.20150514063305.278">@cmd('insert-file-name')
def insertFileName(self, event=None):
    """
    Prompt for a file name, then insert it at the cursor position.
    This operation is undoable if done in the body pane.

    The initial path is made by concatenating path_for_p() and the selected
    text, if there is any, or any path like text immediately preceding the
    cursor.
    """
    c, u, w = self.c, self.c.undoer, self.editWidget(event)
    if not w:
        return

    def callback(arg, w=w):
        i = w.getSelectionRange()[0]
        p = c.p
        w.deleteTextSelection()
        w.insert(i, arg)
        newText = w.getAllText()
        if g.app.gui.widget_name(w) == 'body' and p.b != newText:
            bunch = u.beforeChangeBody(p)
            p.v.b = newText  # p.b would cause a redraw.
            u.afterChangeBody(p, 'insert-file-name', bunch)

    # see if the widget already contains the start of a path

    start_text = w.getSelectedText()
    if not start_text:  # look at text preceeding insert point
        start_text = w.getAllText()[: w.getInsertPoint()]
        if start_text:
            # make non-path characters whitespace
            start_text = ''.join(i if i not in '\'"`()[]{}&lt;&gt;!|*,@#$&amp;' else ' '
                                 for i in start_text)
            if start_text[-1].isspace():  # use node path if nothing typed
                start_text = ''
            else:
                start_text = start_text.rsplit(None, 1)[-1]
                # set selection range so w.deleteTextSelection() works in the callback
                w.setSelectionRange(
                    w.getInsertPoint() - len(start_text), w.getInsertPoint())

    c.k.functionTail = g.os_path_finalize_join(
        self.path_for_p(c, c.p), start_text or '')
    c.k.getFileName(event, callback=callback)
</t>
<t tx="ekr.20150514063305.285"></t>
<t tx="ekr.20150514063305.286"></t>
<t tx="ekr.20150514063305.287">def extendHelper(self, w, extend, spot, upOrDown=False):
    """
    Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    """
    c, p = self.c, self.c.p
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i, j = w.getSelectionRange()
    # Reset the move spot if needed.
    if self.moveSpot is None or p.v != self.moveSpotNode:
        self.setMoveCol(w, ins if extend else spot)  # sets self.moveSpot.
    elif extend:
        # 2011/05/20: Fix bug 622819
        # Ctrl-Shift movement is incorrect when there is an unexpected selection.
        if i == j:
            self.setMoveCol(w, ins)  # sets self.moveSpot.
        elif self.moveSpot in (i, j) and self.moveSpot != ins:
            # The bug fix, part 1.
            pass
        else:
            # The bug fix, part 2.
            # Set the moveCol to the *not* insert point.
            if ins == i: k = j
            elif ins == j: k = i
            else: k = ins
            self.setMoveCol(w, k)  # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2, j2 = g.getLine(s, spot)
            line = s[i2:j2]
            row, col = g.convertPythonIndexToRowCol(s, spot)
            if True:  # was j2 &lt; len(s)-1:
                n = min(self.moveCol, max(0, len(line) - 1))
            else:
                n = min(self.moveCol, max(0, len(line)))  # A tricky boundary.
            spot = g.convertRowColToPythonIndex(s, row, n)
        else:  # Plain move forward or back.
            self.setMoveCol(w, spot)  # sets self.moveSpot.
    if extend:
        if spot &lt; self.moveSpot:
            w.setSelectionRange(spot, self.moveSpot, insert=spot)
        else:
            w.setSelectionRange(self.moveSpot, spot, insert=spot)
    else:
        w.setSelectionRange(spot, spot, insert=spot)
    w.seeInsertPoint()
    c.frame.updateStatusLine()
</t>
<t tx="ekr.20150514063305.288">def moveToHelper(self, event, spot, extend):
    """
    Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.
    """
    c, k = self.c, self.c.k
    w = self.editWidget(event)
    if not w: return
    c.widgetWantsFocusNow(w)
    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i, j = k.getEditableTextRange()
        if spot &lt; i: spot = i
        elif spot &gt; j: spot = j
    self.extendHelper(w, extend, spot, upOrDown=False)
</t>
<t tx="ekr.20150514063305.289">def setMoveCol(self, w, spot):
    """Set the column to which an up or down arrow will attempt to move."""
    p = self.c.p
    i, row, col = w.toPythonIndexRowCol(spot)
    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v
</t>
<t tx="ekr.20150514063305.290">@cmd('back-to-home')
def backToHome(self, event, extend=False):
    """
    Smart home:
    Position the point at the first non-blank character on the line,
    or the start of the line if already there.
    """
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    if s:
        i, j = g.getLine(s, ins)
        i1 = i
        while i &lt; j and s[i] in (' \t'):
            i += 1
        if i == ins:
            i = i1
        self.moveToHelper(event, i, extend=extend)

@cmd('back-to-home-extend-selection')
def backToHomeExtendSelection(self, event):
    self.backToHome(event, extend=True)
</t>
<t tx="ekr.20150514063305.291">@cmd('back-to-indentation')
def backToIndentation(self, event):
    """Position the point at the first non-blank character on the line."""
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    s = w.getAllText()
    ins = w.getInsertPoint()
    i, j = g.getLine(s, ins)
    while i &lt; j and s[i] in (' \t'):
        i += 1
    self.moveToHelper(event, i, extend=False)
</t>
<t tx="ekr.20150514063305.292">@cmd('next-line')
def nextLine(self, event):
    """Move the cursor down, extending the selection if in extend mode."""
    self.moveUpOrDownHelper(event, 'down', extend=False)

@cmd('next-line-extend-selection')
def nextLineExtendSelection(self, event):
    """Extend the selection by moving the cursor down."""
    self.moveUpOrDownHelper(event, 'down', extend=True)

@cmd('previous-line')
def prevLine(self, event):
    """Move the cursor up, extending the selection if in extend mode."""
    self.moveUpOrDownHelper(event, 'up', extend=False)

@cmd('previous-line-extend-selection')
def prevLineExtendSelection(self, event):
    """Extend the selection by moving the cursor up."""
    self.moveUpOrDownHelper(event, 'up', extend=True)
</t>
<t tx="ekr.20150514063305.293">def moveUpOrDownHelper(self, event, direction, extend):

    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()
    if hasattr(w, 'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=direction, extend=extend)
    else:
        # Find the start of the next/prev line.
        row, col = g.convertPythonIndexToRowCol(s, ins)
        i, j = g.getLine(s, ins)
        if direction == 'down':
            i2, j2 = g.getLine(s, j)
        else:
            i2, j2 = g.getLine(s, i - 1)
        # The spot is the start of the line plus the column index.
        n = max(0, j2 - i2 - 1)  # The length of the new line.
        col2 = min(col, n)
        spot = i2 + col2
        self.extendHelper(w, extend, spot, upOrDown=True)
</t>
<t tx="ekr.20150514063305.294">@cmd('beginning-of-buffer')
def beginningOfBuffer(self, event):
    """Move the cursor to the start of the body text."""
    self.moveToBufferHelper(event, 'home', extend=False)

@cmd('beginning-of-buffer-extend-selection')
def beginningOfBufferExtendSelection(self, event):
    """Extend the text selection by moving the cursor to the start of the body text."""
    self.moveToBufferHelper(event, 'home', extend=True)

@cmd('end-of-buffer')
def endOfBuffer(self, event):
    """Move the cursor to the end of the body text."""
    self.moveToBufferHelper(event, 'end', extend=False)

@cmd('end-of-buffer-extend-selection')
def endOfBufferExtendSelection(self, event):
    """Extend the text selection by moving the cursor to the end of the body text."""
    self.moveToBufferHelper(event, 'end', extend=True)
</t>
<t tx="ekr.20150514063305.295">def moveToBufferHelper(self, event, spot, extend):
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    if hasattr(w, 'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot, extend=extend)
    else:
        if spot == 'home':
            self.moveToHelper(event, 0, extend=extend)
        elif spot == 'end':
            s = w.getAllText()
            self.moveToHelper(event, len(s), extend=extend)
        else:
            g.trace('can not happen: bad spot', spot)  # pragma: no cover (defensive)
</t>
<t tx="ekr.20150514063305.296">@cmd('back-char')
def backCharacter(self, event):
    """Move the cursor back one character, extending the selection if in extend mode."""
    self.moveToCharacterHelper(event, 'left', extend=False)

@cmd('back-char-extend-selection')
def backCharacterExtendSelection(self, event):
    """Extend the selection by moving the cursor back one character."""
    self.moveToCharacterHelper(event, 'left', extend=True)

@cmd('forward-char')
def forwardCharacter(self, event):
    """Move the cursor forward one character, extending the selection if in extend mode."""
    self.moveToCharacterHelper(event, 'right', extend=False)

@cmd('forward-char-extend-selection')
def forwardCharacterExtendSelection(self, event):
    """Extend the selection by moving the cursor forward one character."""
    self.moveToCharacterHelper(event, 'right', extend=True)
</t>
<t tx="ekr.20150514063305.297">def moveToCharacterHelper(self, event, spot, extend):
    w = self.editWidget(event)
    if not w:
        return
    if hasattr(w, 'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot, extend=extend)
    else:
        i = w.getInsertPoint()
        if spot == 'left':
            i = max(0, i - 1)
            self.moveToHelper(event, i, extend=extend)
        elif spot == 'right':
            i = min(i + 1, len(w.getAllText()))
            self.moveToHelper(event, i, extend=extend)
        else:
            g.trace(f"can not happen: bad spot: {spot}")
</t>
<t tx="ekr.20150514063305.298">@cmd('clear-extend-mode')
def clearExtendMode(self, event):
    """Turn off extend mode: cursor movement commands do not extend the selection."""
    self.extendModeHelper(event, False)

@cmd('set-extend-mode')
def setExtendMode(self, event):
    """Turn on extend mode: cursor movement commands do extend the selection."""
    self.extendModeHelper(event, True)

@cmd('toggle-extend-mode')
def toggleExtendMode(self, event):
    """Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections."""
    self.extendModeHelper(event, not self.extendMode)

def extendModeHelper(self, event, val):
    c = self.c
    w = self.editWidget(event)
    if w:
        self.extendMode = val
        if not g.unitTesting:
            # g.red('extend mode','on' if val else 'off'))
            c.k.showStateAndMode()
        c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20150514063305.299">@cmd('exchange-point-mark')
def exchangePointMark(self, event):
    """
    Exchange the point (insert point) with the mark (the other end of the
    selected text).
    """
    c = self.c
    w = self.editWidget(event)
    if not w:
        return
    if hasattr(w, 'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind='exchange', extend=False)
    else:
        c.widgetWantsFocusNow(w)
        i, j = w.getSelectionRange(sort=False)
        if i == j: return
        ins = w.getInsertPoint()
        ins = j if ins == i else i
        w.setInsertPoint(ins)
        w.setSelectionRange(i, j, insert=None)
</t>
<t tx="ekr.20150514063305.300">@cmd('extend-to-line')
def extendToLine(self, event):
    """Select the line at the cursor."""
    w = self.editWidget(event)
    if not w:
        return
    s = w.getAllText()
    n = len(s)
    i = w.getInsertPoint()
    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i -= 1
    i += 1
    i1 = i
    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i += 1
    w.setSelectionRange(i1, i)
</t>
<t tx="ekr.20150514063305.301">@cmd('extend-to-sentence')
def extendToSentence(self, event):
    """Select the line at the cursor."""
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    s = w.getAllText()
    n = len(s)
    i = w.getInsertPoint()
    i2 = 1 + s.find('.', i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.', 0, i2 - 1)
    w.setSelectionRange(i1, i2)
</t>
<t tx="ekr.20150514063305.302">@cmd('extend-to-word')
def extendToWord(self, event, select=True, w=None):
    """Compute the word at the cursor. Select it if select arg is True."""
    if not w:
        w = self.editWidget(event)
    if not w:
        return 0, 0  # pragma: no cover (defensive)
    s = w.getAllText()
    n = len(s)
    i = i1 = w.getInsertPoint()
    # Find a word char on the present line if one isn't at the cursor.
    if not (0 &lt;= i &lt; n and g.isWordChar(s[i])):
        # First, look forward
        while i &lt; n and not g.isWordChar(s[i]) and s[i] != '\n':
            i += 1
        # Next, look backward.
        if not (0 &lt;= i &lt; n and g.isWordChar(s[i])):
            i = i1 - 1 if (i &gt;= n or s[i] == '\n') else i1
            while i &gt;= 0 and not g.isWordChar(s[i]) and s[i] != '\n':
                i -= 1
    # Make sure s[i] is a word char.
    if 0 &lt;= i &lt; n and g.isWordChar(s[i]):
        # Find the start of the word.
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i -= 1
        i += 1
        i1 = i
        # Find the end of the word.
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i += 1
        if select:
            w.setSelectionRange(i1, i)
        return i1, i
    return 0, 0
</t>
<t tx="ekr.20150514063305.303">@cmd('move-past-close')
def movePastClose(self, event):
    """Move the cursor past the closing parenthesis."""
    self.movePastCloseHelper(event, extend=False)

@cmd('move-past-close-extend-selection')
def movePastCloseExtendSelection(self, event):
    """Extend the selection by moving the cursor past the closing parenthesis."""
    self.movePastCloseHelper(event, extend=True)
</t>
<t tx="ekr.20150514063305.304">def movePastCloseHelper(self, event, extend):
    c = self.c
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i &gt;= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j &gt;= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i &lt; j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 &lt; len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 &lt; len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 &gt; j2: return
    self.moveToHelper(event, i2 + 1, extend)
</t>
<t tx="ekr.20150514063305.305">def moveWithinLineHelper(self, event, spot, extend):
    w = self.editWidget(event)
    if not w:
        return
    # Bug fix: 2012/02/28: don't use the Qt end-line logic:
    # it apparently does not work for wrapped lines.
    spots = ('end-line', 'finish-line', 'start-line')
    if hasattr(w, 'leoMoveCursorHelper') and spot not in spots:
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot, extend=extend)
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i, j = g.getLine(s, ins)
        line = s[i:j]
        if spot == 'begin-line':  # was 'start-line'
            self.moveToHelper(event, i, extend=extend)
        elif spot == 'end-line':
            # Bug fix: 2011/11/13: Significant in external tests.
            if g.match(s, j - 1, '\n') and i != j: j -= 1
            self.moveToHelper(event, j, extend=extend)
        elif spot == 'finish-line':
            if not line.isspace():
                if g.match(s, j - 1, '\n'): j -= 1
                while j &gt;= 0 and s[j].isspace():
                    j -= 1
            self.moveToHelper(event, j, extend=extend)
        elif spot == 'start-line':  # new
            if not line.isspace():
                while i &lt; j and s[i].isspace():
                    i += 1
            self.moveToHelper(event, i, extend=extend)
        else:
            g.trace(f"can not happen: bad spot: {spot}")
</t>
<t tx="ekr.20150514063305.306">@cmd('back-page')
def backPage(self, event):
    """Move the cursor back one page,
    extending the selection if in extend mode."""
    self.movePageHelper(event, kind='back', extend=False)

@cmd('back-page-extend-selection')
def backPageExtendSelection(self, event):
    """Extend the selection by moving the cursor back one page."""
    self.movePageHelper(event, kind='back', extend=True)

@cmd('forward-page')
def forwardPage(self, event):
    """Move the cursor forward one page,
    extending the selection if in extend mode."""
    self.movePageHelper(event, kind='forward', extend=False)

@cmd('forward-page-extend-selection')
def forwardPageExtendSelection(self, event):
    """Extend the selection by moving the cursor forward one page."""
    self.movePageHelper(event, kind='forward', extend=True)
</t>
<t tx="ekr.20150514063305.307">def movePageHelper(self, event, kind, extend):  # kind in back/forward.
    """Move the cursor up/down one page, possibly extending the selection."""
    w = self.editWidget(event)
    if not w:
        return
    linesPerPage = 15  # To do.
    if hasattr(w, 'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(
            kind='page-down' if kind == 'forward' else 'page-up',
            extend=extend, linesPerPage=linesPerPage)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        ins = w.getInsertPoint()
        s = w.getAllText()
        lines = g.splitLines(s)
        row, col = g.convertPythonIndexToRowCol(s, ins)
        if kind == 'back':
            row2 = max(0, row - linesPerPage)
        else:
            row2 = min(row + linesPerPage, len(lines) - 1)
        if row == row2: return
        spot = g.convertRowColToPythonIndex(s, row2, col, lines=lines)
        self.extendHelper(w, extend, spot, upOrDown=True)
</t>
<t tx="ekr.20150514063305.308">@cmd('back-paragraph')
def backwardParagraph(self, event):
    """Move the cursor to the previous paragraph."""
    self.backwardParagraphHelper(event, extend=False)

@cmd('back-paragraph-extend-selection')
def backwardParagraphExtendSelection(self, event):
    """Extend the selection by moving the cursor to the previous paragraph."""
    self.backwardParagraphHelper(event, extend=True)

@cmd('forward-paragraph')
def forwardParagraph(self, event):
    """Move the cursor to the next paragraph."""
    self.forwardParagraphHelper(event, extend=False)

@cmd('forward-paragraph-extend-selection')
def forwardParagraphExtendSelection(self, event):
    """Extend the selection by moving the cursor to the next paragraph."""
    self.forwardParagraphHelper(event, extend=True)
</t>
<t tx="ekr.20150514063305.309">def backwardParagraphHelper(self, event, extend):
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    s = w.getAllText()
    i, j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i, j = g.getLine(s, j)
    line = s[i:j]
    if line.strip():
        # Find the start of the present paragraph.
        while i &gt; 0:
            i, j = g.getLine(s, i - 1)
            line = s[i:j]
            if not line.strip(): break
    # Find the end of the previous paragraph.
    while i &gt; 0:
        i, j = g.getLine(s, i - 1)
        line = s[i:j]
        if line.strip():
            i = j - 1
            break
    self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.310">def forwardParagraphHelper(self, event, extend):
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i, j = g.getLine(s, ins)
    line = s[i:j]
    if line.strip():  # Skip past the present paragraph.
        self.selectParagraphHelper(w, i)
        i, j = w.getSelectionRange()
        j += 1
    # Skip to the next non-blank line.
    i = j
    while j &lt; len(s):
        i, j = g.getLine(s, j)
        line = s[i:j]
        if line.strip(): break
    w.setInsertPoint(ins)  # Restore the original insert point.
    self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.311">@cmd('select-all')
def selectAllText(self, event):
    """Select all text."""
    k = self.c.k
    w = self.editWidget(event)
    if not w: return
    # Bug fix 2013/12/13: Special case the minibuffer.
    if w == k.w:
        k.selectAll()
    elif w and g.isTextWrapper(w):
        w.selectAllText()
</t>
<t tx="ekr.20150514063305.312">@cmd('back-sentence')
def backSentence(self, event):
    """Move the cursor to the previous sentence."""
    self.backSentenceHelper(event, extend=False)

@cmd('back-sentence-extend-selection')
def backSentenceExtendSelection(self, event):
    """Extend the selection by moving the cursor to the previous sentence."""
    self.backSentenceHelper(event, extend=True)

@cmd('forward-sentence')
def forwardSentence(self, event):
    """Move the cursor to the next sentence."""
    self.forwardSentenceHelper(event, extend=False)

@cmd('forward-sentence-extend-selection')
def forwardSentenceExtendSelection(self, event):
    """Extend the selection by moving the cursor to the next sentence."""
    self.forwardSentenceHelper(event, extend=True)
</t>
<t tx="ekr.20150514063305.313">def backSentenceHelper(self, event, extend):
    c = self.c
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Find the starting point of the scan.
    i = ins
    i -= 1  # Ensure some progress.
    if i &lt; 0:
        return
    # Tricky.
    if s[i] == '.':
        i -= 1
    while i &gt;= 0 and s[i] in ' \n':
        i -= 1
    if i &gt;= ins:
        i -= 1
    if i &gt;= len(s):
        i -= 1
    if i &lt;= 0:
        return
    if s[i] == '.':
        i -= 1
    # Scan backwards to the end of the paragraph.
    # Stop at empty lines.
    # Skip periods within words.
    # Stop at sentences ending in non-periods.
    end = False
    while not end and i &gt;= 0:
        progress = i
        if s[i] == '.':
            # Skip periods surrounded by letters/numbers
            if i &gt; 0 and s[i - 1].isalnum() and s[i + 1].isalnum():
                i -= 1
            else:
                i += 1
                while i &lt; len(s) and s[i] in ' \n':
                    i += 1
                i -= 1
                break
        elif s[i] == '\n':
            j = i - 1
            while j &gt;= 0:
                if s[j] == '\n':
                    # Don't include first newline.
                    end = True
                    break  # found blank line.
                elif s[j] == ' ':
                    j -= 1
                else:
                    i -= 1
                    break  # no blank line found.
            else:
                # No blank line found.
                i -= 1
        else:
            i -= 1
        assert end or progress &gt; i
    i += 1
    if i &lt; ins:
        self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.314">def forwardSentenceHelper(self, event, extend):
    c = self.c
    w = self.editWidget(event)
    if not w:
        return
    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    if ins &gt;= len(s):
        return
    # Find the starting point of the scan.
    i = ins
    if i + 1 &lt; len(s) and s[i + 1] == '.':
        i += 1
    if s[i] == '.':
        i += 1
    else:
        while i &lt; len(s) and s[i] in ' \n':
            i += 1
        i -= 1
    if i &lt;= ins:
        i += 1
    if i &gt;= len(s):
        return
    # Scan forward to the end of the paragraph.
    # Stop at empty lines.
    # Skip periods within words.
    # Stop at sentences ending in non-periods.
    end = False
    while not end and i &lt; len(s):
        progress = i
        if s[i] == '.':
            # Skip periods surrounded by letters/numbers
            if 0 &lt; i &lt; len(s) and s[i - 1].isalnum() and s[i + 1].isalnum():
                i += 1
            else:
                i += 1
                break  # Include the paragraph.
        elif s[i] == '\n':
            j = i + 1
            while j &lt; len(s):
                if s[j] == '\n':
                    # Don't include first newline.
                    end = True
                    break  # found blank line.
                elif s[j] == ' ':
                    j += 1
                else:
                    i += 1
                    break  # no blank line found.
            else:
                # No blank line found.
                i += 1
        else:
            i += 1
        assert end or progress &lt; i
    i = min(i, len(s))
    if i &gt; ins:
        self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.316">@cmd('back-word')
def backwardWord(self, event):
    """Move the cursor to the previous word."""
    self.moveWordHelper(event, extend=False, forward=False)

@cmd('back-word-extend-selection')
def backwardWordExtendSelection(self, event):
    """Extend the selection by moving the cursor to the previous word."""
    self.moveWordHelper(event, extend=True, forward=False)

@cmd('back-word-smart')
def backwardWordSmart(self, event):
    """Move the cursor to the beginning of the current or the end of the previous word."""
    self.moveWordHelper(event, extend=False, forward=False, smart=True)

@cmd('back-word-smart-extend-selection')
def backwardWordSmartExtendSelection(self, event):
    """Extend the selection by moving the cursor to the beginning of the current
    or the end of the previous word."""
    self.moveWordHelper(event, extend=True, forward=False, smart=True)
</t>
<t tx="ekr.20150514063305.317">def moveWordHelper(self, event, extend, forward, end=False, smart=False):
    """
    Move the cursor to the next/previous word.
    The cursor is placed at the start of the word unless end=True
    """
    c = self.c
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    n = len(s)
    i = w.getInsertPoint()
    alphanumeric_re = re.compile(r"\w")
    whitespace_re = re.compile(r"\s")
    simple_whitespace_re = re.compile(r"[ \t]")
    @others
    if smart:
        if forward:
            if 0 &lt;= i &lt; n:
                if is_alphanumeric(s[i]):
                    i = seek_word_end(i)
                    i = seek_simple_whitespace_end(i)
                elif is_simple_whitespace(s[i]):
                    i = seek_simple_whitespace_end(i)
                elif is_special(s[i]):
                    i = seek_special_end(i)
                    i = seek_simple_whitespace_end(i)
                else:
                    i += 1  # e.g. for newlines
        else:
            i -= 1  # Shift cursor temporarily by -1 to get easy read access to the prev. char
            if 0 &lt;= i &lt; n:
                if is_alphanumeric(s[i]):
                    i = seek_word_start(i)
                    # Do not seek further whitespace here
                elif is_simple_whitespace(s[i]):
                    i = seek_simple_whitespace_start(i)
                elif is_special(s[i]):
                    i = seek_special_start(i)
                    # Do not seek further whitespace here
                else:
                    i -= 1  # e.g. for newlines
            i += 1
    else:
        if forward:
            # Unlike backward-word moves, there are two options...
            if end:
                while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                    i += 1
                while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                    i += 1
            else:
                #1653. Scan for non-words *first*.
                while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                    i += 1
                while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                    i += 1
        else:
            i -= 1
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i -= 1
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i -= 1
            i += 1  # 2015/04/30
    self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.318">def is_alphanumeric(c):
    return alphanumeric_re.match(c) is not None

def is_whitespace(c):
    return whitespace_re.match(c) is not None

def is_simple_whitespace(c):
    return simple_whitespace_re.match(c) is not None

def is_line_break(c):
    return is_whitespace(c) and not is_simple_whitespace(c)

def is_special(c):
    return not is_alphanumeric(c) and not is_whitespace(c)

def seek_until_changed(i, match_function, step):
    while 0 &lt;= i &lt; n and match_function(s[i]):
        i += step
    return i

def seek_word_end(i):
    return seek_until_changed(i, is_alphanumeric, 1)

def seek_word_start(i):
    return seek_until_changed(i, is_alphanumeric, -1)

def seek_simple_whitespace_end(i):
    return seek_until_changed(i, is_simple_whitespace, 1)

def seek_simple_whitespace_start(i):
    return seek_until_changed(i, is_simple_whitespace, -1)

def seek_special_end(i):
    return seek_until_changed(i, is_special, 1)

def seek_special_start(i):
    return seek_until_changed(i, is_special, -1)
</t>
<t tx="ekr.20150514063305.349">@cmd('clear-node-uas')
def clearNodeUas(self, event=None):
    """Clear the uA's in the selected VNode."""
    c = self.c
    p = c and c.p
    if p and p.v.u:
        p.v.u = {}
        # #1276.
        p.setDirty()
        c.setChanged()
        c.redraw()

@cmd('clear-all-uas')
def clearAllUas(self, event=None):
    """Clear all uAs in the entire outline."""
    c = self.c
    # #1276.
    changed = False
    for p in self.c.all_unique_positions():
        if p.v.u:
            p.v.u = {}
            p.setDirty()
            changed = True
    if changed:
        c.setChanged()
        c.redraw()
</t>
<t tx="ekr.20150514063305.504">def change(self, event=None):
    """Make the selected change to the text"""
    if not self.loaded:
        return False
    c = self.c
    w = c.frame.body.wrapper
    selection = self.tab.getSuggestion()
    if selection:
        # Use getattr to keep pylint happy.
        i = getattr(self.tab, 'change_i', None)
        j = getattr(self.tab, 'change_j', None)
        if i is not None:
            start, end = i, j
            oldSel = start, end
        else:
            start, end = oldSel = w.getSelectionRange()
        if start is not None:
            if start &gt; end: start, end = end, start
            w.delete(start, end)
            w.insert(start, selection)
            w.setSelectionRange(start, start + len(selection))
            c.frame.body.onBodyChanged("Change", oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocus()
            return True
    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocus()
    return False
</t>
<t tx="ekr.20150514125218.9">def get_fn(self, p):
    """
    Finalize p's file name.
    Return if p is not an @file node for a python file.
    """
    c = self.c
    if not p.isAnyAtFileNode():
        g.trace(f"not an @&lt;file&gt; node: {p.h!r}")
        return None
    # #67.
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    fn = p.anyAtFileNodeName()
    if not fn.endswith('.py'):
        g.trace(f"not a python file: {p.h!r}")
        return None
    return g.os_path_finalize_join(path, fn)
</t>
<t tx="ekr.20150604130353.1">gnx: ekr.20150604130223.363
</t>
<t tx="ekr.20150604130353.2"></t>
<t tx="ekr.20150621062355.1">def runAlreadyOpenDialog(self, c):
    """Warn about possibly already-open files."""
    if g.app.already_open_files:
        aList = sorted(set(g.app.already_open_files))
        g.app.already_open_files = []
        g.app.gui.dismiss_splash_screen()
        message = (
            'The following files may already be open\n'
            'in another copy of Leo:\n\n' +
            '\n'.join(aList))
        g.app.gui.runAskOkDialog(c,
            title='Already Open Files',
            message=message,
            text="Ok")
</t>
<t tx="ekr.20150629072547.1">def preloadFindPattern(self, w):
    """Preload the find pattern from the selected text of widget w."""
    c, ftm = self.c, self.ftm
    if not c.config.getBool('preload-find-pattern', default=False):
        # Make *sure* we don't preload the find pattern if it is not wanted.
        return
    if not w:
        return
    #
    # #1436: Don't create a selection if there isn't one.
    #        Leave the search pattern alone!
    #
        # if not w.hasSelection():
        #     c.editCommands.extendToWord(event=None, select=True, w=w)
    #
    # #177:  Use selected text as the find string.
    # #1436: Make make sure there is a significant search pattern.
    s = w.getSelectedText()
    if s.strip():
        ftm.setFindText(s)
        ftm.init_focus()
</t>
<t tx="ekr.20150629084611.1">def initFindDef(self, event):
    """Init the find-def command. Return the word to find or None."""
    c = self.c
    w = c.frame.body.wrapper
    # First get the word.
    c.bodyWantsFocusNow()
    w = c.frame.body.wrapper
    if not w.hasSelection():
        c.editCommands.extendToWord(event, select=True)
    word = w.getSelectedText().strip()
    if not word:
        return None
    # Transcrypt does not support Python's keyword module.
    # __pragma__ ('skip')
    if keyword.iskeyword(word):
        return None
    # __pragma__ ('noskip')
    
    # Return word, stripped of preceding class or def.
    for tag in ('class ', 'def '):
        found = word.startswith(tag) and len(word) &gt; len(tag)
        if found:
            return word[len(tag) :].strip()
    return word
</t>
<t tx="ekr.20150629095511.1">def restoreAfterFindDef(self):
    """Restore find settings in effect before a find-def command."""
    # pylint: disable=no-member
        # Bunch has these members
    b = self.find_def_data  # A g.Bunch
    if b:
        self.ignore_case = b.ignore_case
        self.p = b.p
        self.pattern_match = b.pattern_match
        self.reverse = False
        self.search_body = b.search_body
        self.search_headline = b.search_headline
        self.whole_word = b.whole_word
        self.find_def_data = None
</t>
<t tx="ekr.20150629095633.1">def saveBeforeFindDef(self, p):
    """Save the find settings in effect before a find-def command."""
    if not self.find_def_data:
        self.find_def_data = g.Bunch(
            ignore_case=self.ignore_case,
            p=p.copy(),
            pattern_match=self.pattern_match,
            search_body=self.search_body,
            search_headline=self.search_headline,
            whole_word=self.whole_word,
        )
</t>
<t tx="ekr.20150629100600.1">def setFindDefOptions(self, p):
    """Set the find options needed for the find-def command."""
    self.ignore_case = False
    self.p = p.copy()
    self.pattern_match = False
    self.reverse = False
    self.search_body = True
    self.search_headline = False
    self.whole_word = True
</t>
<t tx="ekr.20150629125733.1">def findDefHelper(self, event, defFlag):
    """Find the definition of the class, def or var under the cursor."""
    c, find, ftm = self.c, self, self.ftm
    w = c.frame.body.wrapper
    if not w:
        return
    word = self.initFindDef(event)
    if not word:
        return
    save_sel = w.getSelectionRange()
    ins = w.getInsertPoint()
    # For the command, always start in the root position.
    old_p = c.p
    p = c.rootPosition()
    # Required.
    c.selectPosition(p)
    c.redraw()
    c.bodyWantsFocusNow()
    # Set up the search.
    if defFlag:
        prefix = 'class' if word[0].isupper() else 'def'
        find_pattern = prefix + ' ' + word
    else:
        find_pattern = word + ' ='
    find.find_text = find_pattern
    ftm.setFindText(find_pattern)
    # Save previous settings.
    find.saveBeforeFindDef(p)
    find.setFindDefOptions(p)
    self.find_seen = set()
    use_cff = c.config.getBool('find-def-creates-clones', default=False)
    count = 0
    if use_cff:
        count = find.findAll(clone_find_all=True, clone_find_all_flattened=True)
        found = count &gt; 0
    else:
        # #1592.  Ignore hits under control of @nosearch
        while True:
            found = find.findNext(initFlag=False)
            if not found or not g.inAtNosearch(c.p):
                break
    if not found and defFlag:
        # Leo 5.7.3: Look for an alternative defintion of function/methods.
        word2 = self.switchStyle(word)
        if word2:
            find_pattern = prefix + ' ' + word2
            find.find_text = find_pattern
            ftm.setFindText(find_pattern)
            if use_cff:
                count = find.findAll(
                    clone_find_all=True, clone_find_all_flattened=True)
                found = count &gt; 0
            else:
                # #1592.  Ignore hits under control of @nosearch
                while True:
                    found = find.findNext(initFlag=False)
                    if not found or not g.inAtNosearch(c.p):
                        break
    if found and use_cff:
        last = c.lastTopLevel()
        if count == 1:
            # It's annoying to create a clone in this case.
            # Undo the clone find and just select the proper node.
            last.doDelete()
            find.findNext(initFlag=False)
        else:
            c.selectPosition(last)
    if found:
        self.find_seen.add(c.p.v)
        self.restoreAfterFindDef()
            # Failing to do this causes massive confusion!
    else:
        c.selectPosition(old_p)
        self.restoreAfterFindDef()  # 2016/03/24
        i, j = save_sel
        c.redraw()
        w.setSelectionRange(i, j, insert=ins)
        c.bodyWantsFocusNow()
</t>
<t tx="ekr.20150703061709.1">@language python

"""myLeoSettings.py: save the outline and run the pylint command"""

# print('@button run-pylint: %s' % c.shortFileName())
if c.isChanged():
    c.save()
c.k.simulateCommand('pylint')
</t>
<t tx="ekr.20160119094053.1">@nobeautify

def run(self):
    """The driver for the MatchBrackets class.

    With no selected range: find the nearest bracket and select from
    it to it's match, moving cursor to mathc.
    
    With selected range: the first time, move cursor back to other end of
    range. The second time, select enclosing range.
    """
    #
    # A partial fix for bug 127: Bracket matching is buggy.
    w = self.c.frame.body.wrapper
    s = w.getAllText()
    _mb = self.c.user_dict['_match_brackets']
    sel_range = w.getSelectionRange()
    if not w.hasSelection():
        _mb['count'] = 1
    if _mb['range'] == sel_range and _mb['count'] == 1:
        # haven't been to other end yet
        _mb['count'] += 1
        # move insert point to other end of selection
        insert = 1 if w.getInsertPoint() == sel_range[0] else 0
        w.setSelectionRange(
            sel_range[0], sel_range[1], insert=sel_range[insert])
        return

    # Find the bracket nearest the cursor.
    max_right = len(s) - 1 # insert point can be past last char.
    left = right = min(max_right, w.getInsertPoint())
    left, right, ch, index = self.expand_range(s, left, right, max_right)
    if left is None:
        g.es("Bracket not found")
        return
    index2 = self.find_matching_bracket(ch, s, index)
    if index2 is None:
        g.es("No matching bracket.")  # #1447.
        return

    # If this is the first time we've selected the range index-index2, do
    # nothing extra.  The second time, move cursor to other end (requires
    # no special action here), and the third time, try to expand the range
    # to any enclosing brackets
    minmax = (min(index, index2), max(index, index2)+1)
    # the range, +1 to match w.getSelectionRange()
    if _mb['range'] == minmax:  # count how many times this has been the answer
        _mb['count'] += 1
    else:
        _mb['count'] = 1
        _mb['range'] = minmax
    if _mb['count'] &gt;= 3:  # try to expand range
        left, right, ch, index3 = self.expand_range(
            s,
            max(minmax[0], 0),
            min(minmax[1], max_right),
            max_right, expand=True
        )
        if index3 is not None:  # found nearest bracket outside range
            index4 = self.find_matching_bracket(ch, s, index3)
            if index4 is not None:  # found matching bracket, expand range
                index, index2 = index3, index4
                _mb['count'] = 1
                _mb['range'] = (min(index3, index4), max(index3, index4)+1)

    if index2 is not None:
        if index2 &lt; index:
            w.setSelectionRange(index2, index + 1, insert=index2)
        else:
            w.setSelectionRange(
                index, index2 + 1, insert=min(len(s), index2 + 1))
        w.see(index2)
    else:
        g.es("unmatched", repr(ch))
</t>
<t tx="ekr.20160122104332.1">@language python
</t>
<t tx="ekr.20160123142722.1"># An example configuration file for make_stub_files.py.
# By default, this is ~/stubs/make_stub_files.cfg.
# Can be changed using the --config=path command-line option.

[Global]

files:

    # Files to be used *only* if no files are given on the command line.
    # glob.glob wildcards are supported.

    # c:/leo.repo/leo-editor/leo/core/leoAst.py
    # c:/leo.repo/leo-editor/leo/core/*.py
    # c:/leo.repo/leo-editor/plugins/*.py

output_directory: ~/stubs

prefix_lines:
    # Lines to be inserted at the start of each stub file.
    from typing import TypeVar, Iterable, Tuple
    T = TypeVar('T', int, float, complex)

[Def Name Patterns]

[General Patterns]
</t>
<t tx="ekr.20160129073222.1">def __get_u(self):
    p = self
    return p.v.u

def __set_u(self, val):
    p = self
    p.v.u = val

u = property(
    __get_u, __set_u,
    doc="p.u property")
</t>
<t tx="ekr.20160409035115.1">def searchTree(self, char):
    """Search all visible nodes for a headline starting with stroke."""
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        """Return True if p contains char."""
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) &gt; -1

    # Start at c.p, then retry everywhere.

    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) &gt; -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
</t>
<t tx="ekr.20160412101537.14">def import_file(self, fn, root):
    '''
    Import the given .ipynb file.
    https://nbformat.readthedocs.org/en/latest/format_description.html
    '''
    # #1601:
    if not nbformat:
        g.es_print('import-jupyter-notebook requires nbformat package')
        return
    c = self.c
    self.fn = fn
    self.parent = None
    self.root = root.copy()
    d = self.parse(fn)
    if not d:
        return
    self.do_prefix(d)
    for cell in self.cells:
        self.do_cell(cell)
    self.indent_cells()
    self.add_markup()
    c.selectPosition(self.root)
    c.redraw()
</t>
<t tx="ekr.20160412103110.1">def run(self, s, parent, parse_body=False):
    '''
    @auto entry point. Called by code in leoImport.py.
    '''
    # #1601:
    if not nbformat:
        g.es_print('import-jupyter-notebook requires nbformat package')
        return
    c = self.c
    fn = parent.atAutoNodeName()
    if c and fn:
        self.import_file(fn, parent)
        # Similar to Importer.run.
        parent.b = (
            '@nocolor-node\n\n' +
            'Note: This node\'s body text is ignored when writing this file.\n\n' +
            'The @others directive is not required\n'
        )
        for p in parent.self_and_subtree():
            p.clearDirty()
        # #1451: The caller should be responsible for this.
            # if changed:
                # c.setChanged()
            # else:
                # c.clearChanged()
    elif not c or not fn:
        g.trace('can not happen', c, fn)
</t>
<t tx="ekr.20160420054135.4">gnx: ekr.20160412193816.5
unl: qt_quicksearch declarations
gnx: ekr.20160412193816.6
unl: class Ui_LeoQuickSearchWidget
gnx: ekr.20160412193816.7
unl: class Ui_LeoQuickSearchWidget--&gt;setupUi
gnx: ekr.20160412193816.8
unl: class Ui_LeoQuickSearchWidget--&gt;retranslateUi
</t>
<t tx="ekr.20160420054135.5"></t>
<t tx="ekr.20160425070345.1">gnx: ekr.20160412193816.1
unl: qt_main declarations
gnx: ekr.20160412193816.2
unl: class Ui_MainWindow
gnx: ekr.20160412193816.3
unl: class Ui_MainWindow--&gt;setupUi
gnx: ekr.20160412193816.4
unl: class Ui_MainWindow--&gt;retranslateUi
</t>
<t tx="ekr.20160425070345.2"></t>
<t tx="ekr.20160427062131.1">def is_unusual_focus(self, w):
    """Return True if w is not in an expected place."""
    #
    # #270: Leo's keyboard events doesn't work after "Insert"
    #       on headline and Alt+Tab, Alt+Tab
    #
    # #276: Focus lost...in Nav text input
    from leo.plugins import qt_frame
    return isinstance(w, qt_frame.QtTabBarWrapper)
</t>
<t tx="ekr.20160504092347.1">def run(self, s, parent, parse_body=False):
    '''The common top-level code for all scanners.'''
    c = self.c
    ok = self.scan(s, parent)
    # g.app.unitTestDict['result'] = ok
    if ok:
        for p in parent.self_and_subtree():
            p.clearDirty()
        # #1451: The caller should be responsible for this.
            # if changed:
                # c.setChanged()
            # else:
                # c.clearChanged()
    else:
        parent.setDirty() # setDescendentsDirty=False)
        c.setChanged()
    return ok
</t>
<t tx="ekr.20160504092347.2">def escapeFalseSectionReferences(self, s):
    '''
    Probably a bad idea.  Keep the apparent section references.
    The perfect-import write code no longer attempts to expand references
    when the perfectImportFlag is set.
    '''
    return s
    # result = []
    # for line in g.splitLines(s):
        # r1 = line.find('&lt;&lt;')
        # r2 = line.find('&gt;&gt;')
        # if r1&gt;=0 and r2&gt;=0 and r1&lt;r2:
            # result.append("@verbatim\n")
            # result.append(line)
        # else:
            # result.append(line)
    # return ''.join(result)
</t>
<t tx="ekr.20160504092347.3">def checkBlanksAndTabs(self, s):
    '''Check for intermixed blank &amp; tabs.'''
    # Do a quick check for mixed leading tabs/blanks.
    blanks = tabs = 0
    for line in g.splitLines(s):
        lws = line[0: g.skip_ws(line, 0)]
        blanks += lws.count(' ')
        tabs += lws.count('\t')
    ok = blanks == 0 or tabs == 0
    if not ok:
        self.report('intermixed blanks and tabs')
    return ok
</t>
<t tx="ekr.20160504092347.4">def regularizeWhitespace(self, s):
    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''
    changed = False; lines = g.splitLines(s); result = []; tab_width = self.tab_width
    if tab_width &lt; 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line, 0, tab_width)
            s = g.computeLeadingWhitespace(w, -abs(tab_width)) + line[i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width &gt; 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line, abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)
    if changed:
        action = 'tabs converted to blanks' if self.tab_width &lt; 0 else 'blanks converted to tabs'
        message = 'inconsistent leading whitespace. %s' % action
        self.report(message)
    return ''.join(result)
</t>
<t tx="ekr.20160516072613.6">def check_all(self, log_flag, pyflakes_errors_only, roots):
    """Run pyflakes on all files in paths."""
    try:
        from pyflakes import api, reporter
    except Exception:  # ModuleNotFoundError
        return True  # Pretend all is fine.
    total_errors = 0
    for i, root in enumerate(roots):
        fn = self.finalize(root)
        sfn = g.shortFileName(fn)
        # #1306: nopyflakes
        if any([z.strip().startswith('@nopyflakes') for z in g.splitLines(root.b)]):
            continue
        # Report the file name.
        s = g.readFileIntoEncodedString(fn)
        if s and s.strip():
            if not pyflakes_errors_only:
                g.es(f"Pyflakes: {sfn}")
            # Send all output to the log pane.
            r = reporter.Reporter(
                errorStream=self.LogStream(i, roots),
                warningStream=self.LogStream(i, roots),
            )
            errors = api.check(s, sfn, r)
            total_errors += errors
    return total_errors
</t>
<t tx="ekr.20160718072648.1">def setStdStreams(self):
    """
    Make sure that stdout and stderr exist.
    This is an issue when running Leo with pythonw.exe.
    """
    # pdb requires sys.stdin, which doesn't exist when using pythonw.exe.
    # import pdb ; pdb.set_trace()
    import sys
    from leo.core import leoGlobals as g

    # Define class LeoStdOut
    @others
    if not sys.stdout:
        sys.stdout = sys.__stdout__ = LeoStdOut('stdout')
    if not sys.stderr:
        sys.stderr = sys.__stderr__ = LeoStdOut('stderr')
</t>
<t tx="ekr.20160718091844.1">class LeoStdOut:
    """A class to put stderr &amp; stdout to Leo's log pane."""

    def __init__(self, kind):
        self.kind = kind
        g.es_print = self.write
        g.pr = self.write

    def flush(self, *args, **keys):
        pass
    @others
</t>
<t tx="ekr.20160718102306.1">def write(self, *args, **keys):
    """Put all non-keyword args to the log pane, as in g.es."""
    #
    # Tracing will lead to unbounded recursion unless
    # sys.stderr has been redirected on the command line.
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress':
        return
    if log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color, newline),)
</t>
<t tx="ekr.20160920221324.1">def convert_to_html(self, s):
    '''Convert s to html using docutils.'''
    c, p = self.c, self.c.p
    # Update the current path.
    path = g.scanAllAtPathDirectives(c, p) or c.getNodePath(p)
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    if os.path.isdir(path):
        os.chdir(path)
    try:
        if self.title:
            s = self.underline(self.title) + s
            self.title = None
        # Call docutils to get the string.
        s = publish_string(s, writer_name='html')
        s = g.toUnicode(s)
    except SystemMessage as sm:
        msg = sm.args[0]
        if 'SEVERE' in msg or 'FATAL' in msg:
            s = 'RST error:\n%s\n\n%s' % (msg, s)
    return s

def update_plantuml(self, s, keywords):
    pc = self
    w = pc.ensure_text_widget()
    path = self.c.p.h[9:].strip()
    print("Plantuml output file name: ", path)
    with open("temp.plantuml", "w") as f:
        f.write(s)
    pth_plantuml_jar = "~/.leo"
    os.system("cat temp.plantuml | java -jar %s/plantuml.jar -pipe &gt; %s" % (pth_plantuml_jar, path))
    template = image_template % (path)
    # Only works in Python 3.x.
    template = g.adjustTripleString(template, pc.c.tab_width).strip()
    pc.show()
    w.setReadOnly(False)
    w.setHtml(template)
    w.setReadOnly(True)

</t>
<t tx="ekr.20160921134552.1">def convert_to_markdown(self, s):
    '''Convert s to html using the markdown processor.'''
    pc = self
    c, p = pc.c, pc.c.p
    path = g.scanAllAtPathDirectives(c, p) or c.getNodePath(p)
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    if os.path.isdir(path):
        os.chdir(path)
    try:
        if pc.title:
            s = pc.underline(pc.title) + s
            pc.title = None
        mdext = c.config.getString('view-rendered-md-extensions') or 'extra'
        mdext = [x.strip() for x in mdext.split(',')]
        s = markdown(s, extensions=mdext)
        s = g.toUnicode(s)
    except SystemMessage as sm:
        msg = sm.args[0]
        if 'SEVERE' in msg or 'FATAL' in msg:
            s = 'MD error:\n%s\n\n%s' % (msg, s)
    return s
</t>
<t tx="ekr.20160924135613.1">def doPlainChar(self, action, ch, event, inBrackets, oldSel, stroke, w):
    c, p = self.c, self.c.p
    isPlain = stroke.find('Alt') == -1 and stroke.find('Ctrl') == -1
    i, j = oldSel
    if i &gt; j: i, j = j, i
    # Use raw insert/delete to retain the coloring.
    if i != j: w.delete(i, j)
    elif action == 'overwrite': w.delete(i)
    if isPlain:
        ins = w.getInsertPoint()
        if self.autojustify &gt; 0 and not inBrackets:
            # Support #14: auto-justify body text.
            s = w.getAllText()
            i = g.skip_to_start_of_line(s, ins)
            i, j = g.getLine(s, i)
            # Only insert a newline at the end of a line.
            if j - i &gt;= self.autojustify and (ins &gt;= len(s) or s[ins] == '\n'):
                # Find the start of the word.
                n = 0
                ins -= 1
                while ins - 1 &gt; 0 and g.isWordChar(s[ins - 1]):
                    n += 1
                    ins -= 1
                sins = ins  # start of insert, to collect trailing whitespace
                while sins &gt; 0 and s[sins - 1] in (' \t'):
                    sins -= 1
                oldSel = (sins, ins)
                self.insertNewlineHelper(w, oldSel, undoType=None)
                ins = w.getInsertPoint()
                ins += (n + 1)
        w.insert(ins, ch)
        w.setInsertPoint(ins + 1)
    else:
        g.app.gui.insertKeyEvent(event, i)
    if inBrackets and self.flashMatchingBrackets:
        self.flashMatchingBracketsHelper(c, ch, i, p, w)
</t>
<t tx="ekr.20160928023915.1">def update_pyplot(self, s, keywords):
    '''Get the pyplot script at c.p.b and show it.'''
    c = self.c
    if not self.pyplot_imported:
        self.pyplot_imported = True
        backend = g.os_path_finalize_join(
            g.app.loadDir, '..', 'plugins', 'pyplot_backend.py')
        if g.os_path_exists(backend):
            try:
                # The order of these statements is important...
                import matplotlib
                matplotlib.use('module://leo.plugins.pyplot_backend')
            except ImportError:
                g.trace('===== FAIL: pyplot.backend')
        else:
            g.trace('===== MISSING: pyplot.backend')
    try:
        import matplotlib # Make *sure* this is imported.
        import matplotlib.pyplot as plt
        import numpy as np
        import matplotlib.animation as animation
        plt.ion() # Automatically set interactive mode.
        namespace = {
            'animation': animation,
            'matplotlib': matplotlib,
            'numpy': np, 'np': np,
            'pyplot': plt, 'plt': plt,
        }
    except Exception:
        g.es_print('matplotlib imports failed')
        namespace = {}
    # Embedding already works without this!
        # self.embed_pyplot_widget()
    self.pyplot_active = True
        # pyplot will throw RuntimeError if we close the pane.
    c.executeScript(
        event=None,
        args=None, p=None,
        script=None,
        useSelectedText=False,
        define_g=True,
        define_name='__main__',
        silent=False,
        namespace=namespace,
        raiseFlag=False,
        runPyflakes=False, # Suppress warnings about pre-defined symbols.
    )
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20161020031633.1">"""
k.get1Arg: Handle the next character the user types when accumulating
a user argument from the minibuffer. Ctrl-G will abort this processing
at any time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.

Example 1: get one argument from the user:

    @g.command('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)

    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

Example 2: get two arguments from the user:

    @g.command('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)

    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.extendLabel(' second prompt: ', select=False, protect=True)
        k.getNextArg(handler=self.myCommand2)

    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

k.get1Arg and k.getNextArg are a convenience methods. They simply pass
their arguments to the get_arg method of the singleton GetArg
instance. This docstring describes k.get1arg and k.getNextArg as if
they were the corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n,
handler) though they aren't represented that way. When the state
machine in the GetArg class is active, the kind is 'getArg'. This
constant has special meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    &lt;Return&gt; or (sometimes) &lt;tab&gt;.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.

"""
</t>
<t tx="ekr.20161021084954.1">def runPyflakes(self, root, pyflakes_errors_only):
    """Run pyflakes on the selected node."""
    try:
        from leo.commands import checkerCommands
        if checkerCommands.pyflakes:
            x = checkerCommands.PyflakesCommand(self.c)
            ok = x.run(p=root, pyflakes_errors_only=pyflakes_errors_only)
            return ok
        return True  # Suppress error if pyflakes can not be imported.
    except Exception:
        g.es_exception()
</t>
<t tx="ekr.20161028040054.1">self.already_open_files = []
    # A list of file names that *might* be open in another
    # copy of Leo.
self.dragging = False
    # True: dragging.
self.inBridge = False
    # True: running from leoBridge module.
self.inScript = False
    # True: executing a script.
self.initing = True
    # True: we are initiing the app.
self.initComplete = False
    # True: late bindings are not allowed.
self.killed = False
    # True: we are about to destroy the root window.
self.openingSettingsFile = False
    # True, opening a settings file.
self.preReadFlag = False
    # True: we are pre-reading a settings file.
self.quitting = False
    # True: quitting.  Locks out some events.
self.restarting = False
    # True: restarting all of Leo. #1240.
self.reverting = False
    # True: executing the revert command.
self.syntax_error_files = []
</t>
<t tx="ekr.20161029103615.1">class Py_Importer(Importer):
    '''A class to store and update scanning state.'''

    def __init__(self, importCommands, language='python', **kwargs):
        '''Py_Importer.ctor.'''
        super().__init__(
            importCommands,
            language=language,
            state_class = Python_ScanState,
            strict=True,
        )
        self.put_decorators = self.c.config.getBool('put-python-decorators-in-imported-headlines')

    @others
</t>
<t tx="ekr.20161108131153.10">def run(self, s, parent, parse_body=False):
    '''The common top-level code for all scanners.'''
    c = self.c
    # Fix #449: Cloned @auto nodes duplicates section references.
    if parent.isCloned() and parent.hasChildren():
        return None
    self.root = root = parent.copy()
    self.file_s = s
    # Init the error/status info.
    self.errors = 0
    self.parse_body = parse_body
    # Check for intermixed blanks and tabs.
    self.tab_width = c.getTabWidth(p=root)
    ws_ok = self.check_blanks_and_tabs(s) # Only issues warnings.
    # Regularize leading whitespace
    if not ws_ok:
        s = self.regularize_whitespace(s)
    # Generate the nodes, including directives and section references.
    # Completely generate all nodes.
    self.generate_nodes(s, parent)
    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    if parse_body:
        ok = self.errors == 0 # Work around problems with directives.
    else:
        ok = self.errors == 0 and self.check(s, parent)
    g.app.unitTestDict['result'] = ok
    # Insert an @ignore directive if there were any serious problems.
    if not ok:
        self.insert_ignore_directive(parent)
    # It's always useless for an an import to dirty the outline.
    for p in root.self_and_subtree():
        p.clearDirty()
    # #1451: The caller should be responsible for this.
        # if changed:
            # c.setChanged()
        # else:
            # c.clearChanged()
    return ok
</t>
<t tx="ekr.20161108131153.11">def check_blanks_and_tabs(self, lines):
    '''Check for intermixed blank &amp; tabs.'''
    # Do a quick check for mixed leading tabs/blanks.
    fn = g.shortFileName(self.root.h)
    w = self.tab_width
    blanks = tabs = 0
    for s in g.splitLines(lines):
        lws = self.get_str_lws(s)
        blanks += lws.count(' ')
        tabs += lws.count('\t')
    # Make sure whitespace matches @tabwidth directive.
    if w &lt; 0:
        ok = tabs == 0
        message = 'tabs found with @tabwidth %s in %s' % (w, fn)
    elif w &gt; 0:
        ok = blanks == 0
        message = 'blanks found with @tabwidth %s in %s' % (w, fn)
    if ok:
        ok = (blanks == 0 or tabs == 0)
        message = 'intermixed blanks and tabs in: %s' % (fn)
    if not ok:
        if g.unitTesting:
            self.report(message)
        else:
            g.es(message)
    return ok
</t>
<t tx="ekr.20161108131153.12">def insert_ignore_directive(self, parent):
    c = self.c
    parent.v.b = parent.v.b.rstrip() + '\n@ignore\n'
        # Do *not* update the screen by setting p.b.
    if g.unitTesting:
        g.app.unitTestDict['fail'] = g.callers()
    elif parent.isAnyAtFileNode() and not parent.isAtAutoNode():
        g.warning('inserting @ignore')
        c.import_error_nodes.append(parent.h)
</t>
<t tx="ekr.20161108131153.13">def post_pass(self, parent):
    '''
    Optional Stage 2 of the importer pipeline, consisting of zero or more
    substages. Each substage alters nodes in various ways.

    Subclasses may freely override this method, **provided** that all
    substages use the API for setting body text. Changing p.b directly will
    cause asserts to fail later in i.finish().
    '''
    self.clean_all_headlines(parent)
    if self.add_context:
        self.add_class_names(parent)
    self.clean_all_nodes(parent)
    self.unindent_all_nodes(parent)
    #
    # This sub-pass must follow unindent_all_nodes.
    self.promote_trailing_underindented_lines(parent)
    self.promote_last_lines(parent)
    #
    # This probably should be the last sub-pass.
    self.delete_all_empty_nodes(parent)
</t>
<t tx="ekr.20161108131153.14">def regularize_whitespace(self, s):
    '''
    Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    '''
    kind = 'tabs' if self.tab_width &gt; 0 else 'blanks'
    kind2 = 'blanks' if self.tab_width &gt; 0 else 'tabs'
    fn = g.shortFileName(self.root.h)
    lines = g.splitLines(s)
    count, result, tab_width = 0, [], self.tab_width
    self.ws_error = False # 2016/11/23
    if tab_width &lt; 0: # Convert tabs to blanks.
        for n, line in enumerate(lines):
            i, w = g.skip_leading_ws_with_indent(line, 0, tab_width)
            s = g.computeLeadingWhitespace(w, -abs(tab_width)) + line[i:]
                # Use negative width.
            if s != line:
                count += 1
            result.append(s)
    elif tab_width &gt; 0: # Convert blanks to tabs.
        for n, line in enumerate(lines):
            s = g.optimizeLeadingWhitespace(line, abs(tab_width))
                # Use positive width.
            if s != line:
                count += 1
            result.append(s)
    if count:
        self.ws_error = True # A flag to check.
        if not g.unitTesting:
            # g.es_print('Warning: Intermixed tabs and blanks in', fn)
            # g.es_print('Perfect import test will ignoring leading whitespace.')
            g.es('changed leading %s to %s in %s line%s in %s' % (
                kind2, kind, count, g.plural(count), fn))
        if g.unitTesting: # Sets flag for unit tests.
            self.report('changed %s lines' % count)
    return ''.join(result)
</t>
<t tx="ekr.20161108131153.15"></t>
<t tx="ekr.20161108131153.17">def get_str_lws(self, s):
    '''Return the characters of the lws of s.'''
    m = re.match(r'([ \t]*)', s)
    return m.group(0) if m else ''
</t>
<t tx="ekr.20161108131153.18">def error(self, s):
    '''Issue an error and cause a unit test to fail.'''
    self.errors += 1
    self.importCommands.errors += 1

def report(self, message):
    if self.strict:
        self.error(message)
    else:
        self.warning(message)

def warning(self, s):
    if not g.unitTesting:
        g.warning('Warning:', s)
</t>
<t tx="ekr.20161108131153.19">def undent(self, p):
    '''Remove maximal leading whitespace from the start of all lines.'''
    if self.is_rst:
        return p.b # Never unindent rst code.
    lines = self.get_lines(p)
    ws = self.common_lws(lines)
    result = []
    for s in lines:
        if s.startswith(ws):
            result.append(s[len(ws):])
        elif s.isspace():
            # Never change blank lines.
            result.append(s)
        else:
            # Indicate that the line is underindented.
            result.append("%s%s.%s" % (
                self.c.atFileCommands.underindentEscapeString,
                g.computeWidth(ws, self.tab_width),
                s.lstrip()))
    return result
</t>
<t tx="ekr.20161108131153.20">def common_lws(self, lines):
    '''Return the lws (a string) common to all lines.'''
    if not lines:
        return ''
    lws = self.get_str_lws(lines[0])
    for s in lines:
        if not self.is_ws_line(s):
            lws2 = self.get_str_lws(s)
            if lws2.startswith(lws):
                pass
            elif lws.startswith(lws2):
                lws = lws2
            else:
                lws = '' # Nothing in common.
                break
    return lws
</t>
<t tx="ekr.20161108131153.21">def underindented_comment(self, line):
    if self.at_auto_warns_about_leading_whitespace:
        self.warning(
            'underindented python comments.\n' +
            'Extra leading whitespace will be added\n' + line)

def underindented_line(self, line):
    if self.warn_about_underindented_lines:
        self.error(
            'underindented line.\n'
            'Extra leading whitespace will be added\n' + line)
</t>
<t tx="ekr.20161108131153.3">def check(self, unused_s, parent):
    '''True if perfect import checks pass.'''
    if g.app.suppressImportChecks:
        g.app.suppressImportChecks = False
        return True
    c = self.c
    sfn = g.shortFileName(self.root.h)
    s1 = g.toUnicode(self.file_s, self.encoding)
    s2 = self.trial_write()
    lines1, lines2 = g.splitLines(s1), g.splitLines(s2)
    if 0: # An excellent trace for debugging.
        g.trace(c.shortFileName())
        g.printObj(lines1, tag='lines1')
        g.printObj(lines2, tag='lines2')
    if self.strict:
        # Ignore blank lines only.
        # Adding nodes may add blank lines.
        lines1 = self.strip_blank_lines(lines1)
        lines2 = self.strip_blank_lines(lines2)
    else:
        # Ignore blank lines and leading whitespace.
        # Importing may regularize whitespace, and that's good.
        lines1 = self.strip_all(lines1)
        lines2 = self.strip_all(lines2)
    # Forgive trailing whitespace problems in the last line.
    # This is not the same as clean_last_lines.
    if lines1 and lines2 and lines1 != lines2:
        lines1[-1] = lines1[-1].rstrip()+'\n'
        lines2[-1] = lines2[-1].rstrip()+'\n'
    # self.trace_lines(lines1, lines2, parent)
    ok = lines1 == lines2
    if not ok and not self.strict:
        # Issue an error only if something *other than* lws is amiss.
        lines1, lines2 = self.strip_lws(lines1), self.strip_lws(lines2)
        ok = lines1 == lines2
        if ok and not g.unitTesting:
            print('warning: leading whitespace changed in:', self.root.h)
    if not ok:
        self.show_failure(lines1, lines2, sfn)
        # self.trace_lines(lines1, lines2, parent)
    # Ensure that the unit tests fail when they should.
    # Unit tests do not generate errors unless the mismatch line does not match.
    if g.app.unitTesting:
        d = g.app.unitTestDict
        d['result'] = ok
        if not ok:
            d['fail'] = g.callers()
            # Used in a unit test.
            c.importCommands.errors += 1
    return ok
</t>
<t tx="ekr.20161108131153.4">def clean_blank_lines(self, lines):
    '''Remove all blanks and tabs in all blank lines.'''
    return [self.lstrip_line(z) if z.isspace() else z for z in lines]
</t>
<t tx="ekr.20161108131153.5">def lstrip_line(self, s):
    '''Delete leading whitespace, *without* deleting the trailing newline!'''
    # This fixes a major bug in strip_lws.
    assert s, g.callers()
    return '\n' if s.isspace() else s.lstrip()

def strip_all(self, lines):
    '''Strip blank lines and leading whitespace from all lines of s.'''
    return self.strip_lws(self.strip_blank_lines(lines))

def strip_blank_lines(self, lines):
    '''Strip all blank lines from s.'''
    return [z for z in lines if not z.isspace()]

def strip_lws(self, lines):
    '''Strip leading whitespace from all lines.'''
    return [self.lstrip_line(z) for z in lines]
    # This also works, but I prefer the "extra" call to lstrip().
    # return ['\n' if z.isspace() else z.lstrip() for z in lines].


</t>
<t tx="ekr.20161108131153.6">def trial_write(self):
    '''Return the trial write for self.root.'''
    at = self.c.atFileCommands
    # Leo 5.6: Allow apparent section refs for *all* languages.
    ivar = 'allow_undefined_refs'
    try:
        setattr(at, ivar, True)
        result = at.atAutoToString(self.root)
    finally:
        if hasattr(at, ivar):
            delattr(at, ivar)
    return g.toUnicode(result, self.encoding)
</t>
<t tx="ekr.20161108131153.7"># These can be overridden in subclasses.
</t>
<t tx="ekr.20161108131153.8">def adjust_parent(self, parent, headline):
    '''Return the effective parent.

    This is overridden by the RstScanner class.'''
    return parent
</t>
<t tx="ekr.20161108131153.9">def clean_headline(self, s, p=None):
    '''
    Return the cleaned version headline s.
    Will typically be overridden in subclasses.
    '''
    return s.strip()
</t>
<t tx="ekr.20161108155143.3">def get_int_lws(self, s):
    '''Return the the lws (a number) of line s.'''
    # Important: use self.tab_width, *not* c.tab_width.
    return g.computeLeadingWhitespaceWidth(s, self.tab_width)
</t>
<t tx="ekr.20161108155143.4">def match(self, s, i, pattern):
    '''Return True if the pattern matches at s[i:]'''
    return s[i:i+len(pattern)] == pattern
</t>
<t tx="ekr.20161108155730.1">class Importer:
    '''
    The new, unified, simplified, interface to Leo's importer code.

    Eventually, all importers will create use this class.
    '''

    @others
</t>
<t tx="ekr.20161108155925.1">def __init__(self,
    importCommands,
    gen_refs=False, # True: generate section references,
    language=None, # For @language directive.
    name=None, # The kind of importer, usually the same as language
    state_class=None, # For i.scan_line
    strict=False,
    **kwargs
):
    '''
    Importer.__init__: New in Leo 6.1.1: ic and c may be None for unit tests.
    '''
    # Copies of args...
    self.importCommands = ic = importCommands
    self.c = c = ic and ic.c
    self.encoding = ic and ic.encoding or 'utf-8'
    self.gen_refs = gen_refs
    self.language = language or name
        # For the @language directive.
    self.name = name or language
    language = self.language
    name = self.name
    assert language and name
    assert self.language and self.name
    self.state_class = state_class
    self.strict = strict
        # True: leading whitespace is significant.
    #
    # Set from ivars...
    self.has_decls = name not in ('xml', 'org-mode', 'vimoutliner')
    self.is_rst = name in ('rst',)
    self.tree_type = ic.treeType if c else None # '@root', '@file', etc.
    #
    # Constants...
    if ic:
        data = g.set_delims_from_language(self.name)
        self.single_comment, self.block1, self.block2 = data
    else:
        self.single_comment, self.block1, self.block2 = '//', '/*', '*/' # Javascript.
    if ic:
        self.escape = c.atFileCommands.underindentEscapeString
        self.escape_string = r'%s([0-9]+)\.' % re.escape(self.escape)
        # m.group(1) is the unindent value.
        self.escape_pattern = re.compile(self.escape_string)
    self.ScanState = ScanState
        # Must be set by subclasses that use general_scan_line.
    self.tab_width = 0 # Must be set in run, using self.root.
    self.ws_pattern = re.compile(r'^\s*$|^\s*%s' % (self.single_comment or ''))
    #
    # Settings...
    self.reloadSettings()
    #
    # State vars.
    self.errors = 0
    if ic:
        ic.errors = 0 # Required.
    self.parse_body = False
    self.refs_dict = {}
        # Keys are headlines. Values are disambiguating number.
    self.skip = 0 # A skip count for x.gen_lines &amp; its helpers.
    self.ws_error = False
    self.root = None

def reloadSettings(self):
    c = self.c
    if not c:
        return
    getBool = c.config.getBool
    c.registerReloadSettings(self)
    # self.at_auto_separate_non_def_nodes = False
    self.add_context = getBool("add-context-to-headlines")
    self.add_file_context = getBool("add-file-context-to-headlines")
    self.at_auto_warns_about_leading_whitespace = getBool('at_auto_warns_about_leading_whitespace')
    self.warn_about_underindented_lines = True
   
</t>
<t tx="ekr.20161108160409.1">def gen_lines(self, s, parent):
    '''
    Non-recursively parse all lines of s into parent, creating descendant
    nodes as needed.
    '''
    trace = 'importers' in g.app.debug
    tail_p = None
    prev_state = self.state_class()
    target = Target(parent, prev_state)
    stack = [target, target]
    self.inject_lines_ivar(parent)
    lines = g.splitLines(s)
    self.skip = 0
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        top = stack[-1]
        # g.trace(new_state.level(), f"{new_state.level() &lt; top.state.level():1}", repr(line))
        if trace:
            g.trace('%d %d %s' % (
                self.starts_block(i, lines, new_state, prev_state),
                self.ends_block(line, new_state, prev_state, stack),
                line.rstrip()))
        if self.skip &gt; 0:
            self.skip -= 1
        elif self.is_ws_line(line):
            p = tail_p or top.p
            self.add_line(p, line)
        elif self.starts_block(i, lines, new_state, prev_state):
            tail_p = None
            self.start_new_block(i, lines, new_state, prev_state, stack)
        elif self.ends_block(line, new_state, prev_state, stack):
            tail_p = self.end_block(line, new_state, stack)
        else:
            p = tail_p or top.p
            self.add_line(p, line)
        prev_state = new_state
</t>
<t tx="ekr.20161108160409.3">def end_block(self, line, new_state, stack):
    # The block is ending. Add tail lines until the start of the next block.
    p = stack[-1].p
    self.add_line(p, line)
    self.cut_stack(new_state, stack)
    tail_p = None if self.gen_refs else p
    return tail_p
</t>
<t tx="ekr.20161108160409.5">def add_root_directives(self, parent):
    '''Return the proper directives for the root node p.'''
    table = [
        '@language %s\n' % self.language,
        '@tabwidth %d\n' % self.tab_width,
    ]
    if self.parse_body:
        pass
    elif self.has_lines(parent):
        # Make sure the last line ends with a newline.
        lines = self.get_lines(parent)
        if lines:
            last_line = lines.pop()
            last_line = last_line.rstrip() + '\n'
            self.add_line(parent, last_line)
        self.extend_lines(parent, table)
    else:
        self.set_lines(parent, table)
</t>
<t tx="ekr.20161108160409.6">def start_new_block(self, i, lines, new_state, prev_state, stack):
    '''Create a child node and update the stack.'''
    if hasattr(new_state, 'in_context'):
        assert not new_state.in_context(), ('start_new_block', new_state)
    line = lines[i]
    target=stack[-1]
    # Insert the reference in *this* node.
    h = self.gen_ref(line, target.p, target)
    # Create a new child and associated target.
    child = self.create_child_node(target.p, line, h)
    stack.append(Target(child, new_state))
</t>
<t tx="ekr.20161108160409.7">def create_child_node(self, parent, body, headline):
    '''Create a child node of parent.'''
    child = parent.insertAsLastChild()
    self.inject_lines_ivar(child)
    if body:
        self.add_line(child, body)
    assert isinstance(headline, str), repr(headline)
    child.h = headline.strip()
    return child
</t>
<t tx="ekr.20161108160409.8">def gen_ref(self, line, parent, target):
    '''
    Generate the ref line. Return the headline.
    '''
    indent_ws = self.get_str_lws(line)
    h = self.clean_headline(line, p=None)
    if self.gen_refs:
        # Fix #441: Make sure all section refs are unique.
        d = self.refs_dict
        n = d.get(h, 0)
        d [h] = n + 1
        if n &gt; 0:
            h = '%s: %s' % (n, h)
        headline = g.angleBrackets(' %s ' % h)
        ref = '%s%s\n' % (
            indent_ws,
            g.angleBrackets(' %s ' % h))
    else:
        if target.ref_flag:
            ref = None
        else:
            ref = '%s@others\n' % indent_ws
            target.at_others_flag = True
        target.ref_flag = True
            # Don't generate another @others in this target.
        headline = h
    if ref:
        self.add_line(parent,ref)
    return headline
</t>
<t tx="ekr.20161108165530.1"></t>
<t tx="ekr.20161108170435.1">def scan_line(self, s, prev_state):
    '''
    A generalized scan-line method.

    SCAN STATE PROTOCOL:

    The Importer class should have a state_class ivar that references a
    **state class**. This class probably should *not* be subclass of the
    ScanState class, but it should observe the following protocol:

    1. The state class's ctor must have the following signature:

        def __init__(self, d)

    2. The state class must have an update method.
    '''
    # This dict allows new data to be added without changing ScanState signatures.
    d = {
        'indent': self.get_int_lws(s),
        'is_ws_line': self.is_ws_line(s),
        'prev':prev_state,
        's':s,
    }
    new_state = self.state_class(d)
    i = 0
    while i &lt; len(s):
        progress = i
        context = new_state.context
        table = self.get_table(context)
        data = self.scan_dict(context, i, s, table)
        i = new_state.update(data)
        assert progress &lt; i
    return new_state
</t>
<t tx="ekr.20161108180655.2">def undent_by(self, s, undent_val):
    '''
    Remove leading whitespace equivalent to undent_val from each line.

    Strict languages: prepend the underindent escape for underindented lines.
    '''
    if self.is_rst:
        return s # Never unindent rst code.
    result = []
    for line in g.splitlines(s):
        lws_s = self.get_str_lws(line)
        lws = g.computeWidth(lws_s, self.tab_width)
        # Add underindentEscapeString only for strict languages.
        if self.strict and not line.isspace() and lws &lt; undent_val:
            # End the underindent count with a period to
            # protect against lines that start with a digit!
            result.append("%s%s.%s" % (
                self.escape, undent_val-lws, line.lstrip()))
        else:
            s = g.removeLeadingWhitespace(line, undent_val, self.tab_width)
            result.append(s)
    return ''.join(result)
</t>
<t tx="ekr.20161109045312.1"></t>
<t tx="ekr.20161109045619.1">def print_lines(self, lines):
    '''Print lines for debugging.'''
    print('[')
    for line in lines:
        print(repr(line))
    print(']')

print_list = print_lines
</t>
<t tx="ekr.20161109052011.1">def is_ws_line(self, s):
    '''Return True if s is nothing but whitespace and single-line comments.'''
    return bool(self.ws_pattern.match(s))
</t>
<t tx="ekr.20161109053143.1">def get_leading_indent(self, lines, i, ignoreComments=True):
    '''
    Return the leading whitespace (an int) of the first significant line.
    Ignore blank and comment lines if ignoreComments is True
    '''
    if ignoreComments:
        while i &lt; len(lines):
            if self.is_ws_line(lines[i]):
                i += 1
            else:
                break
    return self.get_int_lws(lines[i]) if i &lt; len(lines) else 0
</t>
<t tx="ekr.20161109072221.1">def undent_body_lines(self, lines, ignoreComments=True):
    '''
    Remove the first line's leading indentation from all lines.
    Return the resulting string.
    '''
    s = ''.join(lines)
    if self.is_rst:
        return s # Never unindent rst code.
    # Calculate the amount to be removed from each line.
    undent_val = self.get_leading_indent(lines, 0, ignoreComments=ignoreComments)
    if undent_val == 0:
        return s
    result = self.undent_by(s, undent_val)
    return result
</t>
<t tx="ekr.20161110042020.1">def finalize_ivars(self, parent):
    '''
    Update the body text of all nodes in parent's tree using the injected
    v._import_lines lists.
    '''
    for p in parent.self_and_subtree():
        v = p.v
        # Make sure that no code in x.post_pass has mistakenly set p.b.
        assert not v._bodyString, repr(v._bodyString)
        lines = v._import_lines
        if lines:
            if not lines[-1].endswith('\n'):
                lines[-1] += '\n'
        v._bodyString = g.toUnicode(''.join(lines), reportErrors=True)
            # Bug fix: 2017/01/24: must convert to unicode!
            # This was the source of the internal error in the p.b getter.
        delattr(v, '_import_lines')
</t>
<t tx="ekr.20161110042512.1"># All code in passes 1 and 2 *must* use this API to change body text.

def add_line(self, p, s):
    '''Append the line s to p.v._import_lines.'''
    assert s and isinstance(s, str), (repr(s), g.callers())
    # *Never* change p unexpectedly!
    assert hasattr(p.v, '_import_lines'), (repr(s), g.callers())
    p.v._import_lines.append(s)

def clear_lines(self, p):
    p.v._import_lines = []

def extend_lines(self, p, lines):
    p.v._import_lines.extend(list(lines))

def get_lines(self, p):
    # *Never* change p unexpectedly!
    assert hasattr(p.v, '_import_lines'), (p and p.h, g.callers())
    return p.v._import_lines

def has_lines(self, p):
    return hasattr(p.v, '_import_lines')

def inject_lines_ivar(self, p):
    '''Inject _import_lines into p.v.'''
    # *Never* change p unexpectedly!
    assert not p.v._bodyString, (p and p.h, g.callers(10))
    p.v._import_lines = []

def prepend_lines(self, p, lines):
    p.v._import_lines = list(lines) + p.v._import_lines

def set_lines(self, p, lines):
    p.v._import_lines = list(lines)
</t>
<t tx="ekr.20161110073751.1">def clean_headline(self, s, p=None):
    '''Return a cleaned up headline s.'''
    if p: # Called from clean_all_headlines:
        return self.get_decorator(p) + p.h
    # Handle defs.
    m = re.match(r'\s*def\s+(\w+)', s)
    if m:
        return m.group(1)
    # Handle classes.
    #913: Show base classes in python importer.
    #978: Better regex handles class C(bar.Bar)
    m = re.match(r'\s*class\s+(\w+)\s*(\([\w.]+\))?', s)
    if m:
        return 'class %s%s' % (m.group(1), m.group(2) or '')
    return s.strip()

def get_decorator(self, p):
    if g.unitTesting or self.put_decorators:
        for s in self.get_lines(p):
            if not s.isspace():
                m = re.match(r'\s*@\s*([\w\.]+)', s)
                if m:
                    s = s.strip()
                    if s.endswith('('):
                        s = s[:-1].strip()
                    return s + ' '
                return ''
    return ''
</t>
<t tx="ekr.20161110125940.1">def clean_all_headlines(self, parent):
    '''
    Clean all headlines in parent's tree by calling the language-specific
    clean_headline method.
    '''
    for p in parent.subtree():
        # Note: i.gen_ref calls clean_headline without knowing p.
        # As a result, the first argument is required.
        h = self.clean_headline(p.h, p=p)
        if h and h != p.h:
            p.h = h
    
</t>
<t tx="ekr.20161110130157.1">def clean_all_nodes(self, parent):
    '''Clean the nodes in parent's tree, in a language-dependent way.'''
    # i.clean_nodes does nothing.
    # Subclasses may override as desired.
    # See perl_i.clean_nodes for an example.
    self.clean_nodes(parent)
</t>
<t tx="ekr.20161110130337.1">def unindent_all_nodes(self, parent):
    '''Unindent all nodes in parent's tree.'''
    for p in parent.subtree():
        lines = self.get_lines(p)
        if all([z.isspace() for z in lines]):
            # Somewhat dubious, but i.check covers for us.
            self.clear_lines(p)
        else:
            self.set_lines(p, self.undent(p))
</t>
<t tx="ekr.20161110130709.1">def delete_all_empty_nodes(self, parent):
    '''
    Delete nodes consisting of nothing but whitespace.
    Move the whitespace to the preceding node.
    '''
    c = self.c
    aList = []
    for p in parent.subtree():
        back = p.threadBack()
        if back and back.v != parent.v and back.v != self.root.v and not p.isCloned():
            lines = self.get_lines(p)
            # Move the whitespace from p to back.
            if all([z.isspace() for z in lines]):
                self.extend_lines(back, lines)
                # New in Leo 5.7: empty nodes may have children.
                if p.hasChildren():
                    # Don't delete p.
                    p.h = 'organizer'
                    self.clear_lines(p)
                else:
                    # Do delete p.
                    aList.append(p.copy())
    if aList:
        c.deletePositionsInList(aList, redraw=False)
            # Suppress redraw.
</t>
<t tx="ekr.20161110131509.1">def promote_trailing_underindented_lines(self, parent):
    '''
    Promote all trailing underindent lines to the node's parent node,
    deleting one tab's worth of indentation. Typically, this will remove
    the underindent escape.
    '''
    pattern = self.escape_pattern # A compiled regex pattern
    for p in parent.subtree():
        lines = self.get_lines(p)
        tail = []
        while lines:
            line = lines[-1]
            m = pattern.match(line)
            if m:
                lines.pop()
                n_str = m.group(1)
                try:
                    n = int(n_str)
                except ValueError:
                    break
                if n == abs(self.tab_width):
                    new_line = line[len(m.group(0)):]
                    tail.append(new_line)
                else:
                    g.trace('unexpected unindent value', n)
                    g.trace(line)
                    # Fix #652 by restoring the line.
                    new_line = line[len(m.group(0)):].lstrip()
                    lines.append(new_line)
                    break
            else:
                break
        if tail:
            parent = p.parent()
            if parent.parent() == self.root:
                parent = parent.parent()
            self.set_lines(p, lines)
            self.extend_lines(parent, reversed(tail))
</t>
<t tx="ekr.20161110173058.1">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an examplle.
    '''
    pass
</t>
<t tx="ekr.20161111023249.1">def finish(self, parent):
    '''
    Stage 3 (the last) stage of the importer pipeline.

    Subclasses should never need to override this method.
    '''
    # Put directives at the end, so as not to interfere with shebang lines, etc.
    self.add_root_directives(parent)
    #
    # Finally, remove all v._import_list temporaries.
    self.finalize_ivars(parent)
</t>
<t tx="ekr.20161111024447.1">def generate_nodes(self, s, parent):
    '''
    A three-stage pipeline to generate all imported nodes.
    '''
    # Stage 1: generate nodes.
    # After this stage, the p.v._import_lines list contains p's future body text.
    self.gen_lines(s, parent)
    #
    # Optional Stage 2, consisting of zero or more sub-stages.
    # Subclasses may freely override this method, **provided**
    # that all substages use the API for setting body text.
    # Changing p.b directly will cause asserts to fail in i.finish().
    self.post_pass(parent)
    #
    # Stage 3: Put directives in the root node and set p.b for all nodes.
    #
    # Subclasses should never need to override this stage.
    self.finish(parent)
</t>
<t tx="ekr.20161113135037.1">@nobeautify
cached_scan_tables = {}

def get_table(self, context):
    '''
    Return the state table for the given context.

    This method handles caching.  x.get_new_table returns the actual table.
    '''
    key = '%s.%s' % (self.name, context)
        # Bug fix: must keep tables separate.
    table = self.cached_scan_tables.get(key)
    if table:
        return table
    table = self.get_new_dict(context)
    self.cached_scan_tables[key] = table
    return table
</t>
<t tx="ekr.20161114012522.1">def all_contexts(self, table):
    '''
    Return a list of all contexts contained in the third column of the given table.

    This is a support method for unit tests.
    '''
    contexts = set()
    d = table
    for key in d:
        aList = d.get(key)
        for data in aList:
            if len(data) == 4:
                # It's an out-of-context entry.
                contexts.add(data[2])
    # Order must not matter, so sorting is ok.
    return sorted(contexts)
</t>
<t tx="ekr.20161114024119.1">def test_scan_state(self, tests, State):
    '''
    Test x.scan_line or i.scan_line.

    `tests` is a list of g.Bunches with 'line' and 'ctx' fields.

    A typical @command test:

        if c.isChanged(): c.save()
        &lt; &lt; imp.reload importers.linescanner and importers.python &gt; &gt;
        importer = py.Py_Importer(c.importCommands)
        importer.test_scan_state(tests, Python_ScanState)
    '''
    assert self.single_comment == '#', self.single_comment
    table = self.get_table(context='')
    contexts = self.all_contexts(table)
    for bunch in tests:
        assert bunch.line is not None
        line = bunch.line
        ctx = getattr(bunch, 'ctx', None)
        if ctx: # Test one transition.
            ctx_in, ctx_out = ctx
            prev_state =  State()
            prev_state.context = ctx_in
            new_state = self.scan_line(line, prev_state)
            new_context = new_state.context
            assert new_context == ctx_out, (
                'FAIL1:\nline: %r\ncontext: %r new_context: %r ctx_out: %r\n%s\n%s' % (
                    line, ctx_in, new_context, ctx_out, prev_state, new_state))
        else: # Test all transitions.
            for context in contexts:
                prev_state =  State()
                prev_state.context = context
                new_state = self.scan_line(line, prev_state)
                assert new_state.context == context, (
                    'FAIL2:\nline: %r\ncontext: %r new_context: %r\n%s\n%s' % (
                        line, context, new_state.context, prev_state, new_state))
</t>
<t tx="ekr.20161116034633.2">def cut_stack(self, new_state, stack, append=False):
    '''Cut back the stack until stack[-1] matches new_state.'''
    # pylint: disable=arguments-differ
    assert len(stack) &gt; 1 # Fail on entry.
    while stack:
        top_state = stack[-1].state
        if new_state.level() &lt; top_state.level():
            assert len(stack) &gt; 1, stack # &lt;
            stack.pop()
        elif top_state.level() == new_state.level():
            assert len(stack) &gt; 1, stack # ==
            if append:
                pass # Append line to the previous node.
            else:
                stack.pop() # Create a new node.
            break
        else:
            # This happens often in valid Python programs.
            break
    # Restore the guard entry if necessary.
    if len(stack) == 1:
        stack.append(stack[-1])
    assert len(stack) &gt; 1 # Fail on exit.
</t>
<t tx="ekr.20161116034633.7">def start_new_block(self, i, lines, new_state, prev_state, stack):
    '''Create a child node and update the stack.'''
    assert not prev_state.in_context(), prev_state
    line = lines[i]
    top = stack[-1]
    # Adjust the stack.
    if new_state.indent &gt; top.state.indent:
        pass
    elif new_state.indent == top.state.indent:
        stack.pop()
    else:
        self.cut_stack(new_state, stack)
    # Create the child.
    top = stack[-1]
    parent = top.p
    self.gen_ref(line, parent, top)
    h = self.clean_headline(line, p=None)
    child = self.create_child_node(parent, line, h)
    self.prepend_lines(child, self.decorator_lines)
    self.decorator_lines = []
    target = PythonTarget(child, new_state)
    target.kind = 'class' if h.startswith('class') else 'def'
    stack.append(target)
</t>
<t tx="ekr.20161116040557.1">starts_pattern = re.compile(r'\s*(class|def)\s+')
    # Matches lines that apparently start a class or def.

def starts_block(self, i, lines, new_state, prev_state, stack):
    '''True if the line startswith class or def outside any context.'''
    # pylint: disable=arguments-differ
    if prev_state.in_context():
        return False
    line = lines[i]
    m = self.starts_pattern.match(line)
    if not m:
        return False
    top = stack[-1]
    prev_indent = top.state.indent
    if top.kind == 'None' and new_state.indent &gt; 0:
        # Underindented top-level class/def.
        return False
    if top.kind == 'def' and new_state.indent &gt; prev_indent:
        # class/def within a def.
        # #1493: Insert decorators.
        p = self.tail_p or top.p
        for line in self.decorator_lines:
            self.add_line(p, line)
        return False
    if top.at_others_flag and new_state.indent &gt; prev_indent:
        return False
    return True
</t>
<t tx="ekr.20161116173901.1">def end_block(self, i, lines, new_state, prev_state, stack):
    '''
    Handle a line that terminates the previous class/def. The line is
    neither a class/def line, and we are not in a multi-line token.

    Skip all lines that are at the same level as the class/def.
    '''
    # pylint: disable=arguments-differ
    top = stack[-1]
    assert new_state.indent &lt; top.state.indent, (
        '\nnew: %s\ntop: %s' % (new_state, top.state))
    assert self.skip == 0, self.skip
    end_indent = new_state.indent
    while i &lt; len(lines):
        progress = i
        self.cut_stack(new_state, stack, append=True)
        top = stack[-1]
        # Add the line.
        line = lines[i]
        self.add_line(top.p, line)
        # Move to the next line.
        i += 1
        if i &gt;= len(lines):
            break
        prev_state = new_state
        new_state = self.scan_line(line, prev_state)
        if self.starts_block(i, lines, new_state, prev_state, stack):
            break
        elif not self.is_ws_line(line) and new_state.indent &lt;= end_indent:
            break
        else:
            self.skip += 1
        assert progress &lt; i, repr(line)
    return top.p
</t>
<t tx="ekr.20161119083054.1">def find_class(self, parent):
    '''
    Find the start and end of a class/def in a node.

    Return (kind, i, j), where kind in (None, 'class', 'def')
    '''
    # Called from Leo's core to implement two minor commands.
    prev_state = Python_ScanState()
    target = Target(parent, prev_state)
    stack = [target, target]
    lines = g.splitlines(parent.b)
    index = 0
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        if self.starts_block(i, lines, new_state, prev_state, stack):
                # Bug fix 2019/06/05: added "stack" arg(!)
            return self.skip_block(i, index, lines, new_state, stack)
        prev_state = new_state
        index += len(line)
    return None, -1, -1
</t>
<t tx="ekr.20161119124217.1">def starts_block(self, i, lines, new_state, prev_state):
    '''True if the new state starts a block.'''
    return new_state.level() &gt; prev_state.level()
</t>
<t tx="ekr.20161119130337.1">def cut_stack(self, new_state, stack):
    '''Cut back the stack until stack[-1] matches new_state.'''
    
    def underflow(n):
        g.trace(n)
        g.trace(new_state)
        g.printList(stack)
        
    # assert len(stack) &gt; 1 # Fail on entry.
    if len(stack) &lt;= 1:
        return underflow(0)
    while stack:
        top_state = stack[-1].state
        if new_state.level() &lt; top_state.level():
            if len(stack) &gt; 1:
                stack.pop()
            else:
                return underflow(1)
        elif top_state.level() == new_state.level():
            # assert len(stack) &gt; 1, stack # ==
            # This is the only difference between i.cut_stack and python/cs.cut_stack
            if len(stack) &lt;= 1:
                return underflow(2)
            break
        else:
            # This happens often in valid Python programs.
            break
    # Restore the guard entry if necessary.
    if len(stack) == 1:
        stack.append(stack[-1])
    elif len(stack) &lt;= 1:
        return underflow(3)
    return None
</t>
<t tx="ekr.20161119161953.1">def gen_lines(self, s, parent):
    '''
    Non-recursively parse all lines of s into parent, creating descendant
    nodes as needed.
    '''
    self.tail_p = None
    prev_state = self.state_class()
    target = PythonTarget(parent, prev_state)
    stack = [target, target]
    self.decorator_lines = []
    self.inject_lines_ivar(parent)
    lines = g.splitLines(s)
    self.skip = 0
    first = True
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        top = stack[-1]
        if self.skip &gt; 0:
            self.skip -= 1
        elif self.starts_decorator(i, lines, new_state):
            pass # Sets self.skip and self.decorator_lines.
        elif self.starts_block(i, lines, new_state, prev_state, stack):
            first = False
            self.tail_p = None
            self.start_new_block(i, lines, new_state, prev_state, stack)
        elif first:
            if self.is_ws_line(line):
                p = self.tail_p or top.p
                self.add_line(p, line)
            else:
                first = False
                h = 'Declarations'
                self.gen_ref(line, parent, target)
                p = self.create_child_node(parent, body=line, headline=h)
                stack.append(PythonTarget(p, new_state))
        elif self.ends_block(line, new_state, prev_state, stack):
            first = False
            self.tail_p = self.end_block(i, lines, new_state, prev_state, stack)
        else:
            p = self.tail_p or top.p
            self.add_line(p, line)
        prev_state = new_state
    if self.skip:
        g.trace('can not happen: self.skip &gt; 0', color='red')
    if self.decorator_lines:
        g.trace('can not happen: unused decorator lines...', color='red')
        g.printObj(self.decorator_lines)

</t>
<t tx="ekr.20161119162451.1">def trace_status(self, line, new_state, prev_state, stack, top):
    '''Print everything important in the i.gen_lines loop.'''
    print('')
    try:
        g.trace('===== %r' % line)
    except Exception:
        g.trace('     top.p: %s' % g.toEncodedString(top.p.h))
    # print('len(stack): %s' % len(stack))
    print(' new_state: %s' % new_state)
    print('prev_state: %s' % prev_state)
    # print(' top.state: %s' % top.state)
    g.printList(stack)
</t>
<t tx="ekr.20161120022121.1"></t>
<t tx="ekr.20161123194634.1">org_pattern = re.compile(r'^(\*+)\s(.*)$')
    # #1037: eat only one space.

def gen_lines(self, s, parent):
    '''Node generator for org mode.'''
    self.inject_lines_ivar(parent)
    self.parents = [parent]
    for line in g.splitLines(s):
        m = self.org_pattern.match(line)
        if m:
            # Cut back the stack, then allocate a new node.
            level = len(m.group(1))
            self.parents = self.parents[:level]
            self.find_parent(
                level = level,
                h = m.group(2))
        else:
            p = self.parents[-1]
            self.add_line(p, line)
</t>
<t tx="ekr.20161123194732.2">def find_parent(self, level, h):
    '''
    Return the parent at the indicated level, allocating
    place-holder nodes as necessary.
    '''
    assert level &gt;= 0
    n = level - len(self.parents)
    while level &gt;= len(self.parents):
        headline = h if n == 0  else 'placeholder'
        # This works, but there is no way perfect import will pass the result.
        n -= 1
        child = self.create_child_node(
            parent = self.parents[-1],
            body = None,
            headline = headline,
        )
        self.parents.append(child)
    return self.parents[level]
</t>
<t tx="ekr.20161123210335.1">def trace_lines(self, lines1, lines2, parent):
    '''Show both s1 and s2.'''
    print('===== s1: %s' % parent.h)
    for i, s in enumerate(lines1):
        g.pr('%3s %r' % (i+1, s))
    print('===== s2')
    for i, s in enumerate(lines2):
        g.pr('%3s %r' % (i+1, s))
</t>
<t tx="ekr.20161123210716.1">def show_failure(self, lines1, lines2, sfn):
    '''Print the failing lines, with surrounding context.'''
    if not g.unitTesting:
        g.es('@auto failed:', sfn, color='red')
    n1, n2 = len(lines1), len(lines2)
    print('\n===== PERFECT IMPORT FAILED =====', sfn)
    print('len(s1): %s len(s2): %s' % (n1, n2))
    for i in range(min(n1, n2)):
        line1, line2 = lines1[i], lines2[i]
        if line1 != line2:
            print('first mismatched line: %s' % (i+1))
            print('s1...')
            print(''.join(self.context_lines(lines1, i)))
            print('s2...')
            print(''.join(self.context_lines(lines2, i)))
            # print(repr(line1))
            # print(repr(line2))
            break
    else:
        print('all common lines match')
</t>
<t tx="ekr.20161124030004.1">def clean_last_lines(self, lines):
    '''Remove blank lines from the end of lines.'''
    while lines and lines[-1].isspace():
        lines.pop()
    return lines
</t>
<t tx="ekr.20161125174423.1">def print_stack(self, stack):
    '''Print a stack of positions.'''
    g.printList([p.h for p in stack])
</t>
<t tx="ekr.20161127102339.1">def ends_block(self, line, new_state, prev_state, stack):
    '''True if line ends the block.'''
    # Comparing new_state against prev_state does not work for python.
    top = stack[-1]
    return new_state.level() &lt; top.state.level()
</t>
<t tx="ekr.20161128025444.1">def scan_dict(self, context, i, s, d):
    '''
    i.scan_dict: Scan at position i of s with the give context and dict.
    Return the 6-tuple: (new_context, i, delta_c, delta_p, delta_s, bs_nl)
    '''
    found = False
    delta_c = delta_p = delta_s = 0
    ch = s[i]
    aList = d.get(ch)
    if aList and context:
        # In context.
        for data in aList:
            kind, pattern, ends = data
            if self.match(s, i, pattern):
                if ends is None:
                    found = True
                    new_context = context
                    break
                elif ends:
                    found = True
                    new_context = ''
                    break
                else:
                    pass # Ignore this match.
    elif aList:
        # Not in context.
        for data in aList:
            kind, pattern, new_context, deltas = data
            if self.match(s, i, pattern):
                found = True
                if deltas:
                    delta_c, delta_p, delta_s = deltas
                break
    if found:
        if kind == 'all':
            i = len(s)
        elif kind == 'len+1':
            i += (len(pattern) + 1)
        else:
            assert kind == 'len', (kind, self.name)
            i += len(pattern)
        bs_nl = pattern == '\\\n'
        return new_context, i, delta_c, delta_p, delta_s, bs_nl
    #
    # No match: stay in present state. All deltas are zero.
    new_context = context
    return new_context, i+1, 0, 0, 0, False
</t>
<t tx="ekr.20161128025508.1">@nobeautify

def get_new_dict(self, context):
    '''
    Return a *general* state dictionary for the given context.
    Subclasses may override...
    '''
    comment, block1, block2 = self.single_comment, self.block1, self.block2

    def add_key(d, pattern, data):
        key = pattern[0]
        aList = d.get(key,[])
        aList.append(data)
        d[key] = aList

    if context:
        d = {
            # key    kind      pattern  ends?
            '\\':   [('len+1', '\\',    None),],
            '"':    [('len',   '"',     context == '"'),],
            "'":    [('len',   "'",     context == "'"),],
        }
        if block1 and block2:
            add_key(d, block2, ('len', block2, True))
    else:
        # Not in any context.
        d = {
            # key    kind pattern new-ctx  deltas
            '\\':[('len+1', '\\', context, None),],
            '"':    [('len', '"', '"',     None),],
            "'":    [('len', "'", "'",     None),],
            '{':    [('len', '{', context, (1,0,0)),],
            '}':    [('len', '}', context, (-1,0,0)),],
            '(':    [('len', '(', context, (0,1,0)),],
            ')':    [('len', ')', context, (0,-1,0)),],
            '[':    [('len', '[', context, (0,0,1)),],
            ']':    [('len', ']', context, (0,0,-1)),],
        }
        if comment:
            add_key(d, comment, ('all', comment, '', None))
        if block1 and block2:
            add_key(d, block1, ('len', block1, block1, None))
    return d
</t>
<t tx="ekr.20161128054630.1">@nobeautify

def get_new_dict(self, context):
    '''
    Return a *general* state dictionary for the given context.
    Subclasses may override...
    '''
    comment, block1, block2 = self.single_comment, self.block1, self.block2

    def add_key(d, key, data):
        aList = d.get(key,[])
        aList.append(data)
        d[key] = aList

    if context:
        d = {
            # key   kind    pattern ends?
            '\\':   [('len+1', '\\',None),],
            '"':[
                    ('len', '"""',  context == '"""'),
                    ('len', '"',    context == '"'),
                ],
            "'":[
                    ('len', "'''",  context == "'''"),
                    ('len', "'",    context == "'"),
                ],
        }
        if block1 and block2:
            add_key(d, block2[0], ('len', block1, True))
    else:
        # Not in any context.
        d = {
            # key    kind pattern new-ctx  deltas
            '\\': [('len+1','\\', context, None),],
            '#':  [('all', '#',   context, None),],
            '"':[
                    # order matters.
                    ('len', '"""',  '"""', None),
                    ('len', '"',    '"',   None),
                ],
            "'":[
                    # order matters.
                    ('len', "'''",  "'''", None),
                    ('len', "'",    "'",   None),
                ],
            '{':    [('len', '{', context, (1,0,0)),],
            '}':    [('len', '}', context, (-1,0,0)),],
            '(':    [('len', '(', context, (0,1,0)),],
            ')':    [('len', ')', context, (0,-1,0)),],
            '[':    [('len', '[', context, (0,0,1)),],
            ']':    [('len', ']', context, (0,0,-1)),],
        }
        if comment:
            add_key(d, comment[0], ('all', comment, '', None))
        if block1 and block2:
            add_key(d, block1[0], ('len', block1, block1, None))
    return d
</t>
<t tx="ekr.20161129213808.1">@nobeautify

def get_new_dict(self, context):
    '''
    Return a *general* state dictionary for the given context.
    Subclasses may override...
    '''
    trace = 'importers' in g.app.debug
    comment, block1, block2 = self.single_comment, self.block1, self.block2

    def add_key(d, key, data):
        aList = d.get(key,[])
        aList.append(data)
        d[key] = aList

    if context:
        d = {
            # key    kind   pattern  ends?
            '\\':   [('len+1', '\\', None),],
            '"':    [('len', '"',    context == '"'),],
            "'":    [('len', "'",    context == "'"),],
            
        }
        if block1 and block2:
            add_key(d, block2[0], ('len', block2, True))  # #1717.
    else:
        # Not in any context.
        d = {
            # key    kind pattern new-ctx  deltas
            '\\':[('len+1', '\\', context, None),],
            '&lt;':    [('&lt;&lt;&lt;', '&lt;&lt;&lt;', '&lt;&lt;&lt;', None),],
            '"':    [('len', '"', '"',     None),],
            "'":    [('len', "'", "'",     None),],
            '{':    [('len', '{', context, (1,0,0)),],
            '}':    [('len', '}', context, (-1,0,0)),],
            '(':    [('len', '(', context, (0,1,0)),],
            ')':    [('len', ')', context, (0,-1,0)),],
            '[':    [('len', '[', context, (0,0,1)),],
            ']':    [('len', ']', context, (0,0,-1)),],
        }
        if comment:
            add_key(d, comment[0], ('all', comment, '', None))
        if block1 and block2:
            add_key(d, block1[0], ('len', block1, block1, None))
    if trace:
        g.trace(f"{comment!r} {block1!r} {block2!r}")
        g.printObj(d, tag=f"scan table for context {context!r}")
    return d
</t>
<t tx="ekr.20161204165700.1"># Define patterns that can start a block
c_extern_pattern = re.compile(r'\s*extern\s+(\"\w+\")')
c_template_pattern = re.compile(r'\s*template\s*&lt;(.*?)&gt;\s*$')
c_typedef_pattern = re.compile(r'\s*(\w+)\s*\*\s*$')

def match_start_patterns(self, line):
    '''
    True if line matches any block-starting pattern.
    If true, set self.headline.
    '''
    m = self.c_extern_pattern.match(line)
    if m:
        self.headline = line.strip()
        return True
    # #1626
    m = self.c_template_pattern.match(line)
    if m:
        self.headline = line.strip()
        return True
    m = self.c_class_pattern.match(line)
    if m:
        prefix = m.group(1).strip() if m.group(1) else ''
        self.headline = '%sclass %s' % (prefix, m.group(3))
        self.headline = self.headline.strip()
        return True
    m = self.c_func_pattern.match(line)
    if m:
        if self.c_types_pattern.match(m.group(3)):
            return True
        prefix = m.group(1).strip() if m.group(1) else ''
        self.headline = '%s %s' % (prefix, m.group(3))
        self.headline = self.headline.strip()
        return True
    m = self.c_typedef_pattern.match(line)
    if m:
        # Does not set self.headline.
        return True
    m = self.c_types_pattern.match(line)
    return bool(m)
</t>
<t tx="ekr.20161205052712.1">def skip_block(self, i, index, lines, prev_state, stack):
    '''
    Find the end of a class/def starting at index
    on line i of lines.

    Return (kind, i, j), where kind in (None, 'class', 'def')
    .'''
    index1 = index
    line = lines[i]
    kind = 'class' if line.strip().startswith('class') else 'def'
    i += 1
    while i &lt; len(lines):
        progress = i
        line = lines[i]
        index += len(line)
        new_state = self.scan_line(line, prev_state)
        if self.ends_block(line, new_state, prev_state, stack):
            return kind, index1, index
        prev_state = new_state
        i += 1
        assert progress &lt; i
    return None, -1, -1
</t>
<t tx="ekr.20161220064822.1">def gen_ref(self, line, parent, target):
    '''
    Generate the at-others and a flag telling this method whether a previous
    @others
    '''
    indent_ws = self.get_str_lws(line)
    h = self.clean_headline(line, p=None)
    if not target.at_others_flag:
        target.at_others_flag = True
        ref = '%s@others\n' % indent_ws
        self.add_line(parent,ref)
    return h
</t>
<t tx="ekr.20161220073836.1">def ends_block(self, line, new_state, prev_state, stack):
    '''True if line ends the block.'''
    # Comparing new_state against prev_state does not work for python.
    if self.is_ws_line(line) or prev_state.in_context():
        return False
    # *Any* underindented non-blank line ends the class/def.
    top = stack[-1]
    return new_state.level() &lt; top.state.level()
</t>
<t tx="ekr.20161220171728.1">def common_lws(self, lines):
    '''Return the lws (a string) common to all lines.'''
    return self.get_str_lws(lines[0]) if lines else ''
        # We must unindent the class/def line fully.
        # It would be wrong to examine the indentation of other lines.
</t>
<t tx="ekr.20161222112801.1">def promote_trailing_underindented_lines(self, parent):
    '''
    Promote all trailing underindent lines to the node's parent node,
    deleting one tab's worth of indentation. Typically, this will remove
    the underindent escape.
    '''
    pattern = self.escape_pattern # A compiled regex pattern
    for p in parent.children(): # 2018/05/24.
        lines = self.get_lines(p)
        tail = []
        while lines:
            line = lines[-1]
            m = pattern.match(line)
            if m:
                lines.pop()
                n_str = m.group(1)
                try:
                    n = int(n_str)
                except ValueError:
                    break
                if n == abs(self.tab_width):
                    new_line = line[len(m.group(0)):]
                    tail.append(new_line)
                else:
                    g.trace('unexpected unindent value', n)
                    break
            else:
                break
        if tail:
            parent = p.parent()
            self.set_lines(p, lines)
            self.extend_lines(parent, reversed(tail))
</t>
<t tx="ekr.20161222122914.1">def promote_last_lines(self, parent):
    '''A placeholder for python_i.promote_last_lines.'''
</t>
<t tx="ekr.20161222123105.1">def promote_last_lines(self, parent):
    '''python_i.promote_last_lines.'''
    last = parent.lastNode()
    if not last or last.h == 'Declarations':
        return
    if last.parent() != parent:
        return # The indentation would be wrong.
    lines = self.get_lines(last)
    prev_state = self.state_class()
    if_pattern = re.compile(r'^\s*if\b')
    # Scan for a top-level if statement.
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        m = if_pattern.match(line)
        if m and not prev_state.context and new_state.indent == 0:
            self.set_lines(last, lines[:i])
            self.extend_lines(parent, lines[i:])
            break
        else:
            prev_state = new_state
</t>
<t tx="ekr.20170105124347.1">update_jupyter_count = 0

def update_jupyter(self, s, keywords):
    '''Update @jupyter node in the vr pane.'''
    pc = self
    c = pc.c
    if pc.must_change_widget(BaseTextWidget):
        w = self.create_base_text_widget()
        pc.embed_widget(w)
        assert(w == pc.w)
    else:
        w = pc.w
    s = self.get_jupyter_source(c)
    if isQt5:
        w.hide() # This forces a proper update.
    w.setHtml(s)
    w.show()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20170126100139.1">def initBlock0(self):
    """
    Init *local* ivars when handling block 0.
    This prevents endless recalculation of the proper default state.
    """
    if self.enabled:
        n = self.setInitialStateNumber()
    else:
        n = self.setRestart(self.restartNoColor)
    return n
</t>
<t tx="ekr.20170126101049.1">def setInitialStateNumber(self):
    """
    Init the initialStateNumber ivar for clearState()
    This saves a lot of work.

    Called from init() and initBlock0.
    """
    state = self.languageTag(self.language)
    n = self.stateNameToStateNumber(None, state)
    self.initialStateNumber = n
    self.blankStateNumber = self.stateNameToStateNumber(None, state + ';blank')
    return n
</t>
<t tx="ekr.20170126103925.1">def languageTag(self, name):
    """
    Return the standardized form of the language name.
    Doing this consistently prevents subtle bugs.
    """
    if name:
        table = (
            ('markdown', 'md'),
            ('python', 'py'),
            ('javascript', 'js'),
        )
        for pattern, s in table:
            name = name.replace(pattern, s)
        return name
    return 'no-language'
</t>
<t tx="ekr.20170220114553.1">def finalize(self, p):
    """Finalize p's path."""
    c = self.c
    aList = g.get_directives_dict_list(p)
    path = self.c.scanAtPathDirectives(aList)
    path = c.expand_path_expression(path)  # #1341.
    fn = p.anyAtFileNodeName()
    fn = c.expand_path_expression(fn)  # #1341.
    return g.os_path_finalize_join(path, fn)
</t>
<t tx="ekr.20170227062001.1">def init_tree_abbrev_helper(self, d, tree_s):
    """Init d from tree_s, the text of a copied outline."""
    c = self.c
    hidden_root = c.fileCommands.getPosFromClipboard(tree_s)
    if not hidden_root:
        g.trace('no pasted node')
        return
    for p in hidden_root.children():
        for s in g.splitLines(p.b):
            if s.strip() and not s.startswith('#'):
                abbrev_name = s.strip()
                # #926: Allow organizer nodes by searching all descendants.
                for child in p.subtree():
                    if child.h.strip() == abbrev_name:
                        abbrev_s = c.fileCommands.putLeoOutline(child)
                        d[abbrev_name] = abbrev_s
                        break
                else:
                    g.trace(f"no definition for {abbrev_name}")
</t>
<t tx="ekr.20170228082641.1">def composeScript(c, p, s, forcePythonSentinels=True, useSentinels=True):
    """Compose a script from p.b."""
    # This causes too many special cases.
        # if not g.unitTesting and forceEncoding:
            # aList = g.get_directives_dict_list(p)
            # encoding = scanAtEncodingDirectives(aList) or 'utf-8'
            # s = g.insertCodingLine(encoding,s)
    if not s.strip():
        return ''
    at = c.atFileCommands
    old_in_script = g.app.inScript
    try:
        # #1297: set inScript flags.
        g.app.inScript = g.inScript = True
        g.app.scriptDict["script1"] = s
        # Important: converts unicode to utf-8 encoded strings.
        script = at.stringToString(p.copy(), s,
            forcePythonSentinels=forcePythonSentinels,
            sentinels=useSentinels)
        script = script.replace("\r\n", "\n")  # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
        g.app.scriptDict["script2"] = script
    finally:
        g.app.inScript = g.inScript = old_in_script
    return script
</t>
<t tx="ekr.20170302093006.1">def createAllImporterData(self):
    """
    New in Leo 5.5:

    Create global data structures describing importers and writers.
    """
    assert g.app.loadDir
        # This is the only data required.
    self.createWritersData()
        # Was an AtFile method.
    self.createImporterData()
        # Was a LeoImportCommands method.
</t>
<t tx="ekr.20170305105047.1">decorator_pattern = re.compile(r'^\s*@\s*(\w+)')

def starts_decorator(self, i, lines, prev_state):
    '''
    True if the line looks like a decorator outside any context.

    Puts the entire decorator into the self.decorator_lines list,
    and sets self.skip so that the next line to be handled is a class/def line.
    '''
    assert self.skip == 0
    if prev_state.context:
        # Only test for docstrings, not [{(.
        return False
    old_skip = self.skip
    old_decorator_lines = self.decorator_lines[:]
    line = lines[i]
    m = self.decorator_pattern.match(line)
    if m and m.group(1) not in g.globalDirectiveList:
        # Fix #360: allow multiline matches
        # Carefully skip all lines until a class/def.
        self.decorator_lines = [line]
        for i, line in enumerate(lines[i+1:]):
            new_state = self.scan_line(line, prev_state)
            m = self.starts_pattern.match(line)
            if m:
                # 2018/05/24: don't check in_context!
                # The class or def could start a context.
                return True
            self.decorator_lines.append(line)
            self.skip += 1
            prev_state = new_state
    # Recover froma a bare decorator, without a class or def.
    self.skip = old_skip
    self.decorator_lines = old_decorator_lines
    return False
</t>
<t tx="ekr.20170324064811.1">def update_latex(self, s, keywords):
    '''Update latex in the vr pane.'''
    import sys
    pc = self
    c = pc.c
    if sys.platform.startswith('win'):
        g.es_print('latex rendering not ready for Python 3')
        w = pc.ensure_text_widget()
        pc.show()
        w.setPlainText(s)
        c.bodyWantsFocusNow()
        return
    if pc.must_change_widget(BaseTextWidget):
        w = self.create_base_text_widget()
        pc.embed_widget(w)
        assert(w == pc.w)
    else:
        w = pc.w
    w.hide() # This forces a proper update.
    s = self.create_latex_html(s)
    w.setHtml(s)
    w.show()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20170324085132.1">def create_latex_html(self, s):
    '''Create an html page embedding the latex code s.'''
    c = self.c
    # pylint: disable=deprecated-method
    try:
        import html
        escape = html.escape
    except AttributeError:
        import cgi
        escape = cgi.escape
    html_s = escape(s)
    template = latex_template % (html_s)
    template = g.adjustTripleString(template, c.tab_width).strip()
    return template
</t>
<t tx="ekr.20170331141933.1">def writeAsisNode(self, p):
    '''Write the p's node to an @asis file.'''
    at = self

    def put(s):
        """Append s to self.output_list."""
        # #1480: Avoid calling at.os().
        s = g.toUnicode(s, at.encoding, reportErrors=True)
        at.outputList.append(s)

    # Write the headline only if it starts with '@@'.

    s = p.h
    if g.match(s, 0, "@@"):
        s = s[2:]
        if s:
            put('\n')  # Experimental.
            put(s)
            put('\n')
    # Write the body.
    s = p.b
    if s:
        put(s)
</t>
<t tx="ekr.20170404035138.1">def context_lines(self, aList, i, n=2):
    '''Return a list containing the n lines of surrounding context of aList[i].'''
    result = []
    aList1 = aList[max(0, i-n):i]
    aList2 = aList[i+1:i+n+1]
    result.extend(['  %4s %r\n' % (i + 1 - len(aList1) + j, g.truncate(s,60))
        for j, s in enumerate(aList1)])
    result.append('* %4s %r\n' % (i + 1, g.truncate(aList[i], 60)))
    result.extend(['  %4s %r\n' % (i + 2 + j, g.truncate(s, 60))
        for j, s in enumerate(aList2)])
    return result
</t>
<t tx="ekr.20170404103953.1">def import_one_file(self, path, parent):
    """Import one file to the last top-level node."""
    c = self.c
    self.n_files += 1
    assert parent and parent.v != self.root.v, g.callers()
    if self.kind == '@edit':
        p = parent.insertAsLastChild()
        p.v.h = path.replace('\\', '/')
        s, e = g.readFileIntoString(path, kind=self.kind)
        p.v.b = s
        return
    # #1484: Use this for @auto as well.
    c.importCommands.importFilesCommand(
        files=[path],
        parent=parent,
        redrawFlag=False,
        shortFn=True,
        treeType='@file',  # '@auto','@clean','@nosent' cause problems.
    )
    p = parent.lastChild()
    p.h = self.kind + p.h[5:]
        # Bug fix 2017/10/27: honor the requested kind.
    if self.safe_at_file:
        p.v.h = '@' + p.v.h
</t>
<t tx="ekr.20170405191106.1">def import_binary_file(self, fileName, parent):

    # Fix bug 1185409 importing binary files puts binary content in body editor.
    # Create an @url node.
    c = self.c
    if parent:
        p = parent.insertAsLastChild()
    else:
        p = c.lastTopLevel().insertAfter()
    p.h = f"@url file://{fileName}"
    return p
</t>
<t tx="ekr.20170414034616.3">def gitInfo(path=None):
    """
    Path may be a directory or file.

    Return the branch and commit number or ('', '').
    """
    branch, commit = '', ''  # Set defaults.
    if path is None:
        # Default to leo/core.
        path = os.path.dirname(__file__)
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    # Does path/../ref exist?
    path = g.gitHeadPath(path)
    if not path:
        return branch, commit
    try:
        with open(path) as f:
            s = f.read()
            if not s.startswith('ref'):
                branch = 'None'
                commit = s[:7]
                return branch, commit
        # On a proper branch
        pointer = s.split()[1]
        dirs = pointer.split('/')
        branch = dirs[-1]
    except IOError:
        g.trace('can not open:', path)
        return branch, commit
    # Try to get a better commit number.
    git_dir = g.os_path_finalize_join(path, '..')
    try:
        path = g.os_path_finalize_join(git_dir, pointer)
        with open(path) as f:
            s = f.read()
        commit = s.strip()[0:12]
        # shorten the hash to a unique shortname
    except IOError:
        try:
            path = g.os_path_finalize_join(git_dir, 'packed-refs')
            with open(path) as f:
                for line in f:
                    if line.strip().endswith(' ' + pointer):
                        commit = line.split()[0][0:12]
                        break
        except IOError:
            pass
    return branch, commit
</t>
<t tx="ekr.20170414034616.6">def gitHeadPath(path):
    """
    Compute the path to .git/HEAD given the path.
    """
    #Transcrypt does not support Python's pathlib module.
    # __pragma__ ('skip')
    from pathlib import Path
    path = Path(path)
    # #1780: Look up the directory tree, looking the .git directory.
    while os.path.exists(path):
        head = os.path.join(path, '.git', 'HEAD')
        if os.path.exists(head):
            return head
        if path == path.parent:
            break
        path = path.parent
    # __pragma__ ('noskip')

    return None
</t>
<t tx="ekr.20170427112302.1">g.cls()
import glob
files = glob.glob(g.os_path_join(g.app.loadDir, '*.py'))
files = [z for z in files if g.os_path_basename(z).startswith('leo')]
if 0:
    g.printList(files)
found = set()
for p in c.all_unique_positions():
    name = p.isAnyAtFileNode()
    if name and name.startswith('leo'):
        path = g.os_path_join(g.app.loadDir, name)
        found.add(path)
if 0:
    print('found')
    g.printList(list(found))
else:
    missing = set(files) - found
    if missing:
        print('not found...')
        g.printList(list(sorted(missing)))
    else:
        print('done')
        </t>
<t tx="ekr.20170427114412.1"></t>
<t tx="ekr.20170428084123.1">"""Recursively import all python files in a directory and clean the result."""
g.cls()
# dir_ = r'C:\leo.repo\leointeg\src'
# dir_ = r'C:\apps\Emacs\share\emacs\26.1\lisp\outline.el'
# dir_ = r'C:\Users\edreamleo\Anaconda3\Lib\site-packages\Pymacs.py'
# dir_ = r'C:\Users\edreamleo\emacs-packages\pymacs.el'
# dir_ = r'C:\leo.repo\pscript'
dir_ = r'C:\Users\edreamleo\Anaconda3\Lib\site-packages\black.py'
c.recursiveImport(
    dir_ = dir_,
    kind = '@clean', # '@clean', #'@nosent','@auto','@file',
    recursive = False,
    safe_at_file = False,
    theTypes = ['.py',] # '.py',],
)
</t>
<t tx="ekr.20170428084208.443">#!/usr/bin/python
# This file generates pyflakes warnings for *all* imported symbols.
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20170428084208.444">from .globals                   import DEBUG, DISABLE_RESIZE_SYSTEM

from .wgwidget                  import TEST_SETTINGS, ExhaustedTestInput, add_test_input_from_iterable, add_test_input_ch

from .npyssafewrapper           import wrapper, wrapper_basic

from   .npysThemeManagers       import ThemeManager, disableColor, enableColor
from   . import npysThemes      as     Themes
from   .apNPSApplication        import NPSApp
from   .apNPSApplicationManaged import NPSAppManaged
from   .proto_fm_screen_area    import setTheme
from   .fmForm                  import FormBaseNew, Form, TitleForm, TitleFooterForm, SplitForm, FormExpanded, FormBaseNewExpanded, blank_terminal
from   .fmActionForm            import ActionForm, ActionFormExpanded
from   .fmActionFormV2          import ActionFormV2, ActionFormExpandedV2, ActionFormMinimal
from   .fmFormWithMenus         import FormWithMenus, ActionFormWithMenus, \
                                       FormBaseNewWithMenus, SplitFormWithMenus, \
                                       ActionFormV2WithMenus
from   .fmPopup                 import Popup, MessagePopup, ActionPopup, PopupWide, ActionPopupWide
from   .fmFormMutt              import FormMutt, FormMuttWithMenus
from   .fmFileSelector          import FileSelector, selectFile

from .fmFormMuttActive          import ActionControllerSimple, TextCommandBox, \
                                       FormMuttActive, FormMuttActiveWithMenus
from .fmFormMuttActive          import FormMuttActiveTraditional, FormMuttActiveTraditionalWithMenus


from .fmFormMultiPage           import FormMultiPage, FormMultiPageAction,\
                                       FormMultiPageActionWithMenus, FormMultiPageWithMenus

from .npysNPSFilteredData       import NPSFilteredDataBase, NPSFilteredDataList

from .wgbutton                  import MiniButton
from .wgbutton                  import MiniButtonPress
from .wgbutton                  import MiniButton      as Button
from .wgbutton                  import MiniButtonPress as ButtonPress

from .wgtextbox                 import Textfield, FixedText
from .wgtitlefield              import TitleText, TitleFixedText
from .wgpassword                import PasswordEntry, TitlePassword
from .wgannotatetextbox         import AnnotateTextboxBase
from .wgannotatetextbox         import AnnotateTextboxBaseRight

from .wgslider                  import Slider, TitleSlider
from .wgslider                  import SliderNoLabel, TitleSliderNoLabel
from .wgslider                  import SliderPercent, TitleSliderPercent

from .wgwidget                  import DummyWidget, NotEnoughSpaceForWidget
from . import wgwidget as widget

from .wgmultiline               import MultiLine, Pager, TitleMultiLine, TitlePager, MultiLineAction, BufferPager, TitleBufferPager
from .wgmultiselect             import MultiSelect, TitleMultiSelect, MultiSelectFixed, \
                                       TitleMultiSelectFixed, MultiSelectAction
from .wgeditmultiline           import MultiLineEdit
from .wgcombobox                import ComboBox, TitleCombo
from .wgcheckbox                import Checkbox, RoundCheckBox, CheckBoxMultiline, RoundCheckBoxMultiline, CheckBox, CheckboxBare
from .wgFormControlCheckbox     import FormControlCheckbox
from .wgautocomplete            import TitleFilename, Filename, Autocomplete
from .muMenu                    import Menu
from .wgselectone               import SelectOne, TitleSelectOne
from .wgdatecombo               import DateCombo, TitleDateCombo

from .npysTree import TreeData
from .wgmultilinetree           import MLTree, MLTreeAnnotated, MLTreeAction, MLTreeAnnotatedAction
from .wgmultilinetreeselectable import MLTreeMultiSelect, TreeLineSelectable
from .wgmultilinetreeselectable import MLTreeMultiSelectAnnotated, TreeLineSelectableAnnotated


# The following are maintained for compatibility with old code only. ##########################################

from .compatibility_code.oldtreeclasses import MultiLineTree, SelectOneTree
from .compatibility_code.oldtreeclasses import MultiLineTreeNew, MultiLineTreeNewAction, TreeLine, TreeLineAnnotated # Experimental
from .compatibility_code.oldtreeclasses import MultiLineTreeNewAnnotatedAction, MultiLineTreeNewAnnotated # Experimental
from .compatibility_code.npysNPSTree import NPSTreeData

# End compatibility. ###########################################################################################

from .wgfilenamecombo           import FilenameCombo, TitleFilenameCombo
from .wgboxwidget               import BoxBasic, BoxTitle
from .wgmultiline               import MultiLineActionWithShortcuts
from .wgmultilineeditable       import MultiLineEditable, MultiLineEditableTitle, MultiLineEditableBoxed

from .wgmonthbox                import MonthBox
from .wggrid                    import SimpleGrid
from .wggridcoltitles           import GridColTitles

from .muNewMenu                 import NewMenu, MenuItem
from .wgNMenuDisplay            import MenuDisplay, MenuDisplayScreen

from .npyspmfuncs               import CallSubShell

from .utilNotify                 import notify, notify_confirm, notify_wait, notify_ok_cancel, notify_yes_no

# Base classes for overriding:

# Standard Forms:
from . import stdfmemail

# Experimental Only
from .wgtextboxunicode import TextfieldUnicode
from .wgtexttokens     import TextTokens, TitleTextTokens

# Very experimental. Don't use for anything serious
from .apOptions import SimpleOptionForm
from .apOptions import OptionListDisplay, OptionChanger, OptionList, OptionLimitedChoices, OptionListDisplayLine
from .apOptions import OptionFreeText, OptionSingleChoice, OptionMultiChoice, OptionMultiFreeList, \
                       OptionBoolean, OptionFilename, OptionDate, OptionMultiFreeText


# This really is about as experimental as it gets
from .apNPSApplicationEvents import StandardApp
from .eveventhandler import Event


</t>
<t tx="ekr.20170428085201.1">@nosearch</t>
<t tx="ekr.20170510100003.1">def h_return (self, ch):
    '''
    Handle the return key in the minibuffer.
    Send the contents to k.masterKeyHandler.
    '''
    c = self.leo_c
    k = c.k
    val = self.value.strip()
    self.value = ''
    self.update()
    # g.trace('===== inState: %r val: %r' % (k.inState(), val))
    commandName = val
    c.frame.tree.set_status_line(c.p)
        # This may be changed by the command.
    if k.inState():
        # Handle the key.
        k.w = self.leo_wrapper
        k.arg = val
        g.app.gui.curses_gui_arg = val
        k.masterKeyHandler(
            event=KeyEvent(c, char='\n', event='', shortcut='\n', w=None))
        g.app.gui.curses_gui_arg = None
        k.clearState()
    elif commandName == 'repeat-complex-command':
        g.app.gui.repeatComplexCommand(c)
    else:
        # All other alt-x command
        event=KeyEvent(c,char='',event='',shortcut='',w=None)
        c.doCommandByName(commandName, event)
        # Support repeat-complex-command.
        c.setComplexCommand(commandName=commandName)
        c.redraw()
    # Do a full redraw, with c.p as the first visible node.
    # g.trace('----- after command')
    g.app.gui.redraw_in_context(c)
</t>
<t tx="ekr.20170522015906.1">@cmd('paste-text')
def pasteText(self, event=None, middleButton=False):
    '''
    Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.
    '''
    trace = False and not g.unitTesting
    c = self.c
    w = event and event.widget
    if not isinstance(w, leoFrame.StringTextWrapper):
        g.trace('not a StringTextWrapper', repr(w))
        return
    wname = c.widget_name(w)
    i, j = oldSel = w.getSelectionRange()
        # Returns insert point if no selection.
    s = g.app.gui.getTextFromClipboard()
    s = g.toUnicode(s)
    if trace: g.trace('wname', wname, 'len(s)', len(s))
    single_line = any([wname.startswith(z) for z in ('head', 'minibuffer')])
    if single_line:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s[-1] in ('\n', '\r'):
            s = s[: -1]
    # Update the widget.
    if i != j:
        w.delete(i, j)
    w.insert(i, s)
    if wname.startswith('body'):
        c.frame.body.onBodyChanged('Paste', oldSel=oldSel)
    elif wname.startswith('head'):
        c.frame.tree.onHeadChanged(c.p, s=w.getAllText(), undoType='Paste')
            # New for Curses gui.

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20170604185028.1">def delete_line_value(self, ch_i=None):

    c = self.leo_c
    if self.values:
        del self.values[self.cursor_line]
        self.display()
        # #1224:
        c.p.b = ''.join(self.values)
</t>
<t tx="ekr.20170606100707.1">def update_body(self, ins, s):
    '''
    Update self.values and p.b and vnode ivars after the present line changes.
    '''
    # pylint: disable=no-member,access-member-before-definition
    trace = False and not g.unitTesting
    c = self.leo_c
    p = c.p
    v = p.v
    undoType = 'update-body'
    i = self.cursor_line
    wrapper = c.frame.body.wrapper
    assert isinstance(wrapper, BodyWrapper), repr(wrapper)
    lines = self.values
    if trace: g.trace(i, len(lines), s.endswith('\n'), repr(s))
    head = lines[:i]
    tail = lines[i+1:]
    if i &lt; len(lines):
        if not s.endswith('\n'):
            s = s + '\n'
        aList = head + [s] + tail
        self.values = aList
        c.p.b = ''.join(aList)
        v.selectionLength = 0
        v.selectionStart = ins
        wrapper.ins = ins
        wrapper.sel = ins, ins
        self.onBodyChanged(undoType=undoType)
    elif i == len(lines):
        aList = head + [s]
        self.values = aList
        c.p.b = ''.join(aList)
        v.selectionLength = 0
        v.selectionStart = ins
        wrapper.ins = ins
        wrapper.sel = ins, ins
        self.onBodyChanged(undoType=undoType)
    else:
        g.trace('Can not happen', i, len(lines), repr(s))
        v.selectionLength = 0
        v.selectionStart = 0
    if g.splitLines(c.p.b) != self.values:
        g.trace('self.values')
        g.printList(self.values)
        g.trace('g.splitLines(c.p.b)')
        g.printList(g.splitLines(c.p.b))
</t>
<t tx="ekr.20170616102324.1">def execGitCommand(command, directory=None):
    """Execute the given git command in the given directory."""
    git_dir = g.os_path_finalize_join(directory, '.git')
    if not g.os_path_exists(git_dir):
        g.trace('not found:', git_dir, g.callers())
        return []
    if '\n' in command:
        g.trace('removing newline from', command)
        command = command.replace('\n', '')
    # #1777: Save/restore os.curdir
    old_dir = os.path.normpath(os.path.abspath(os.curdir))
    if directory:
        os.chdir(directory)
    try:
        p = subprocess.Popen(
            shlex.split(command),
            stdout=subprocess.PIPE,
            stderr=None,  # Shows error traces.
            shell=False,
        )
        out, err = p.communicate()
        lines = [g.toUnicode(z) for z in g.splitLines(out or [])]
    finally:
        os.chdir(old_dir)
    return lines
</t>
<t tx="ekr.20170617125213.1">def clean_all_headlines(self, parent):
    '''
    Clean all headlines in parent's tree by calling the language-specific
    clean_headline method.
    '''
    for p in parent.subtree():
        # Important: i.gen_ref does not know p when it calls
        # self.clean_headline.
        h = self.clean_headline(p.h, p=p)
        if h and h != p.h:
            p.h = h
</t>
<t tx="ekr.20170707072347.1">@cmd('beginning-of-line')
def beginningOfLine(self, event):
    """Move the cursor to the first character of the line."""
    self.moveWithinLineHelper(event, 'begin-line', extend=False)

@cmd('beginning-of-line-extend-selection')
def beginningOfLineExtendSelection(self, event):
    """
    Extend the selection by moving the cursor to the first character of the
    line.
    """
    self.moveWithinLineHelper(event, 'begin-line', extend=True)
</t>
<t tx="ekr.20170707072524.1">@cmd('end-of-line')
def endOfLine(self, event):
    """Move the cursor to the last character of the line."""
    self.moveWithinLineHelper(event, 'end-line', extend=False)

@cmd('end-of-line-extend-selection')
def endOfLineExtendSelection(self, event):
    """Extend the selection by moving the cursor to the last character of the line."""
    self.moveWithinLineHelper(event, 'end-line', extend=True)
</t>
<t tx="ekr.20170707072644.1">@cmd('start-of-line')
def startOfLine(self, event):
    """Move the cursor to first non-blank character of the line."""
    self.moveWithinLineHelper(event, 'start-line', extend=False)

@cmd('start-of-line-extend-selection')
def startOfLineExtendSelection(self, event):
    """
    Extend the selection by moving the cursor to first non-blank character
    of the line.
    """
    self.moveWithinLineHelper(event, 'start-line', extend=True)
</t>
<t tx="ekr.20170707072837.1">@cmd('finish-of-line')
def finishOfLine(self, event):
    """Move the cursor to the last character of the line."""
    self.moveWithinLineHelper(event, 'finish-line', extend=False)

@cmd('finish-of-line-extend-selection')
def finishOfLineExtendSelection(self, event):
    """Extend the selection by moving the cursor to the last character of the line."""
    self.moveWithinLineHelper(event, 'finish-line', extend=True)
</t>
<t tx="ekr.20170707093335.1">@cmd('pop-cursor')
def popCursor(self, event=None):
    """Restore the node, selection range and insert point from the stack."""
    c = self.c
    w = self.editWidget(event)
    if w and self.cursorStack:
        p, i, j, ins = self.cursorStack.pop()
        if c.positionExists(p):
            c.selectPosition(p)
            c.redraw()
            w.setSelectionRange(i, j, insert=ins)
            c.bodyWantsFocus()
        else:
            g.es('invalid position', c.p.h)
    elif not w:
        g.es('no stacked cursor', color='blue')

@cmd('push-cursor')
def pushCursor(self, event=None):
    """Push the selection range and insert point on the stack."""
    c = self.c
    w = self.editWidget(event)
    if w:
        p = c.p.copy()
        i, j = w.getSelectionRange()
        ins = w.getInsertPoint()
        self.cursorStack.append((p, i, j, ins),)
    else:
        g.es('cursor not pushed', color='blue')
</t>
<t tx="ekr.20170707160947.1">@cmd('forward-end-word')
def forwardEndWord(self, event):  # New in Leo 4.4.2
    """Move the cursor to the next word."""
    self.moveWordHelper(event, extend=False, forward=True, end=True)

@cmd('forward-end-word-extend-selection')
def forwardEndWordExtendSelection(self, event):  # New in Leo 4.4.2
    """Extend the selection by moving the cursor to the next word."""
    self.moveWordHelper(event, extend=True, forward=True, end=True)

@cmd('forward-word')
def forwardWord(self, event):
    """Move the cursor to the next word."""
    self.moveWordHelper(event, extend=False, forward=True)

@cmd('forward-word-extend-selection')
def forwardWordExtendSelection(self, event):
    """Extend the selection by moving the cursor to the end of the next word."""
    self.moveWordHelper(event, extend=True, forward=True)

@cmd('forward-word-smart')
def forwardWordSmart(self, event):
    """Move the cursor to the end of the current or the beginning of the next word."""
    self.moveWordHelper(event, extend=False, forward=True, smart=True)

@cmd('forward-word-smart-extend-selection')
def forwardWordSmartExtendSelection(self, event):
    """Extend the selection by moving the cursor to the end of the current
    or the beginning of the next word."""
    self.moveWordHelper(event, extend=True, forward=True, smart=True)
</t>
<t tx="ekr.20170806094320.15">def get_file_from_rev(self, rev, fn):
    """Get the file from the given rev, or the working directory if None."""
    path = g.os_path_finalize_join(self.repo_dir, fn)
    if not g.os_path_exists(path):
        return ''
    if rev:
        # Get the file using git.
        # Use the file name, not the path.
        command = f"git show {rev}:{fn}"
        lines = g.execGitCommand(command, self.repo_dir)
        s = ''.join(lines)
    else:
        try:
            with open(path, 'rb') as f:  # Was 'r'
                s = f.read()
        except Exception:
            g.es_print('Can not read', path)
            g.es_exception()
            s = ''
    return g.toUnicode(s).replace('\r', '')
</t>
<t tx="ekr.20170806094320.6">def diff_file(self, fn, directory=None, rev1='HEAD', rev2=''):
    """
    Create an outline describing the git diffs for fn.
    """
    # Common code.
    c = self.c
    if not self.set_directory(directory):
        return
    path = g.os_path_finalize_join(self.repo_dir, fn)  # #1781: bug fix.
    if not os.path.exists(path):
        g.trace('NOT FOUND', path)
        return
    s1 = self.get_file_from_rev(rev1, fn)
    s2 = self.get_file_from_rev(rev2, fn)
    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    diff_list = list(difflib.unified_diff(
        lines1,
        lines2,
        rev1 or 'uncommitted',
        rev2 or 'uncommitted',
    ))
    diff_list.insert(0, '@ignore\n@nosearch\n@language patch\n')
    self.file_node = self.create_file_node(diff_list, fn)
    # #1777: The file node will contain the entire added/deleted file.
    if not s1:
        self.file_node.h = f"Added: {self.file_node.h}"
        return
    if not s2:
        self.file_node.h = f"Deleted: {self.file_node.h}"
        return
    # Finish.
    c1 = c2 = None
    if fn.endswith('.leo'):
        c1 = self.make_leo_outline(fn, path, s1, rev1)
        c2 = self.make_leo_outline(fn, path, s2, rev2)
    else:
        root = self.find_file(fn)
        if c.looksLikeDerivedFile(path):
            c1 = self.make_at_file_outline(fn, s1, rev1)
            c2 = self.make_at_file_outline(fn, s2, rev2)
        elif root:
            c1 = self.make_at_clean_outline(fn, root, s1, rev1)
            c2 = self.make_at_clean_outline(fn, root, s2, rev2)
    if c1 and c2:
        self.make_diff_outlines(c1, c2, fn, rev1, rev2)
        self.file_node.b = (
            f"{self.file_node.b.rstrip()}\n"
            f"@language {c2.target_language}\n")
</t>
<t tx="ekr.20170806094320.9">def get_files(self, rev1, rev2):
    """Return a list of changed files."""
    command = f"git diff --name-only {(rev1 or '')} {(rev2 or '')}"
    files = [
        z.strip() for z in g.execGitCommand(command, self.repo_dir)
            if not z.strip().endswith(('.db', '.zip'))
                # #1781: Allow diffs of .leo files.
    ]
    return files
</t>
<t tx="ekr.20170811173924.1">@language python
import os
import subprocess
import sys
import time
win = sys.platform.startswith('win')
old_dir = g.os_path_abspath('.')
if win:
    new_dir = r'C:\leo.repo\leo-editor'
    path = r'C:\Users\edreamleo\Backup'
else:
    new_dir = '/home/edward/leo.repo/leo-editor'
    path = '/home/edward/Backup'
assert g.os_path_exists(new_dir), repr(new_dir)
assert g.os_path_exists(path), repr(path)
stamp = time.strftime("%Y%m%d-%H%M%S")
fn = g.os_path_finalize_join(path, f"leo-bundle-all-{stamp}")
bundle_command = 'git bundle create %s --all' % fn
print(bundle_command)
os.chdir(new_dir)
# os.system(bundle_command)
proc = subprocess.Popen(bundle_command, shell=True)
proc.wait()
os.chdir(old_dir)
print('done! wrote %s' % fn)
</t>
<t tx="ekr.20171031111403.1"></t>
<t tx="ekr.20171122055719.1">def declutter_style(arg, cmd):
    """Handle style options."""
    arg = c.styleSheetManager.expand_css_constants(arg).split()[0]
    if cmd == 'ICON':
        new_icons.append(arg)
    elif cmd == 'BG':
        item.setBackground(0, QtGui.QBrush(QtGui.QColor(arg)))
    elif cmd == 'FG':
        item.setForeground(0, QtGui.QBrush(QtGui.QColor(arg)))
    elif cmd == 'FONT':
        item.setFont(0, QtGui.QFont(arg))
    elif cmd == 'ITALIC':
        font = item.font(0)
        font.setItalic(bool(int(arg)))
        item.setFont(0, font)
    elif cmd == 'WEIGHT':
        arg = getattr(QtGui.QFont, arg, 75)
        font = item.font(0)
        font.setWeight(arg)
        item.setFont(0, font)
    elif cmd == 'PX':
        font = item.font(0)
        font.setPixelSize(int(arg))
        item.setFont(0, font)
    elif cmd == 'PT':
        font = item.font(0)
        font.setPointSize(int(arg))
        item.setFont(0, font)
</t>
<t tx="ekr.20171122064635.1">def declutter_replace(arg, cmd):
    """
    Execute cmd and return True if cmd is any replace command.
    """
    # pylint: disable=undefined-loop-variable
    if cmd == 'REPLACE':
        s = pattern.sub(arg, text)
        item.setText(0, s)
        return True
    if cmd == 'REPLACE-HEAD':
        s = text[: m.start()]
        item.setText(0, s.rstrip())
        return True
    if cmd == 'REPLACE-TAIL':
        s = text[m.end() :]
        item.setText(0, s.lstrip())
        return True
    if cmd == 'REPLACE-REST':
        s = text[:m.start] + text[m.end() :]
        item.setText(0, s.strip())
        return True
    return False
</t>
<t tx="ekr.20171123135625.12">@g.commander_command('hide-invisibles')
def hideInvisibles(self, event=None):
    """Hide invisible (whitespace) characters."""
    c = self
    showInvisiblesHelper(c, False)

@g.commander_command('show-invisibles')
def showInvisibles(self, event=None):
    """Show invisible (whitespace) characters."""
    c = self
    showInvisiblesHelper(c, True)

@g.commander_command('toggle-invisibles')
def toggleShowInvisibles(self, event=None):
    """Toggle showing of invisible (whitespace) characters."""
    c = self
    colorizer = c.frame.body.getColorizer()
    showInvisiblesHelper(c, not colorizer.showInvisibles)

def showInvisiblesHelper(c, val):
    frame = c.frame
    colorizer = frame.body.getColorizer()
    colorizer.showInvisibles = val
    colorizer.highlighter.showInvisibles = val
    # It is much easier to change the menu name here than in the menu updater.
    menu = frame.menu.getMenu("Edit")
    index = frame.menu.getMenuLabel(menu,
        'Hide Invisibles' if val else 'Show Invisibles')
    if index is None:
        if val: frame.menu.setMenuLabel(menu, "Show Invisibles", "Hide Invisibles")
        else: frame.menu.setMenuLabel(menu, "Hide Invisibles", "Show Invisibles")
    # #240: Set the status bits here.
    if hasattr(frame.body, 'set_invisibles'):
        frame.body.set_invisibles(c)
    c.frame.body.recolor(c.p)
</t>
<t tx="ekr.20171123135625.18">@g.commander_command('convert-blanks')
def convertBlanks(self, event=None):
    """
    Convert *all* blanks to tabs in the selected node.
    Return True if the the p.b was changed.
    """
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    oldYview = w.getYScrollPosition()
    w.selectAllText()
    head, lines, tail, oldSel, oldYview = c.getBodyLines()
    #
    # Use the relative @tabwidth, not the global one.
    d = c.scanAllDirectives()
    tabWidth = d.get("tabwidth")
    if not tabWidth:
        return False
    #
    # Calculate the result.
    changed, result = False, []
    for line in lines:
        s = g.optimizeLeadingWhitespace(line, abs(tabWidth))  # Use positive width.
        if s != line:
            changed = True
        result.append(s)
    if not changed:
        return False
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    p.b = head + middle + tail  # Sets dirty and changed bits.
    w.setAllText(head + middle + tail)
    #
    # Select all text and set scroll position.
    w.selectAllText()
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Indent Region', bunch)
    return True
</t>
<t tx="ekr.20171123135625.19">@g.commander_command('convert-tabs')
def convertTabs(self, event=None):
    """Convert all tabs to blanks in the selected node."""
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Data...
    w.selectAllText()
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    # Use the relative @tabwidth, not the global one.
    theDict = c.scanAllDirectives()
    tabWidth = theDict.get("tabwidth")
    if not tabWidth:
        return False
    #
    # Calculate the result.
    changed,result = False, []
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line, 0, tabWidth)
        s = g.computeLeadingWhitespace(width, -abs(tabWidth)) + line[i:]
            # use negative width.
        if s != line: changed = True
        result.append(s)
    if not changed:
        return False
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    p.b = head + middle + tail  # Sets dirty and changed bits.
    w.setAllText(head + middle + tail)
    #
    # Calculate the proper selection range (i, j, ins).
    i = len(head)
    j = max(i, len(head) + len(middle) - 1)
    #
    # Set the selection range and scroll position.
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Add Comments', bunch)
    return True
</t>
<t tx="ekr.20171123135625.21">@g.commander_command('unindent-region')
def dedentBody(self, event=None):
    """Remove one tab's worth of indentation from all presently selected lines."""
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # Initial data.
    sel_1, sel_2 = w.getSelectionRange()
    tab_width = c.getTabWidth(c.p)
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    bunch = u.beforeChangeBody(p)
    #
    # Calculate the result.
    changed, result = False, []
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
        s = g.computeLeadingWhitespace(width - abs(tab_width), tab_width) + line[i:]
        if s != line:
            changed = True
        result.append(s)
    if not changed:
        return
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    all = head + middle + tail
    p.b = all # Sets dirty and changed bits.
    w.setAllText(all)
    #
    # Calculate the proper selection range (i, j, ins).
    if sel_1 == sel_2:
        line = result[0]
        ins, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
        i = j = len(head) + ins
    else:
        i = len(head)
        j = len(head) + len(middle)
        if middle.endswith('\n'): # #1742.
            j -= 1
    #
    # Set the selection range and scroll position.
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    u.afterChangeBody(p, 'Unindent Region', bunch)
</t>
<t tx="ekr.20171123135625.29">def getBodyLines(self):
    """
    Return (head, lines, tail, oldSel, oldYview).

    - head: string containg all the lines before the selected text (or the
      text before the insert point if no selection)
    - lines: list of lines containing the selected text
      (or the line containing the insert point if no selection)
    - after: string containing all lines after the selected text
      (or the text after the insert point if no  selection)
    - oldSel: tuple containing the old selection range, or None.
    - oldYview: int containing the old y-scroll value, or None.
    """
    c = self
    body = c.frame.body
    w = body.wrapper
    oldVview = w.getYScrollPosition()
    # Note: lines is the entire line containing the insert point if no selection.
    head, s, tail = body.getSelectionLines()
    lines = g.splitLines(s)  # Retain the newlines of each line.
    # Expand the selection.
    i = len(head)
    j = len(head) + len(s)
    oldSel = i, j
    return head, lines, tail, oldSel, oldVview  # string,list,string,tuple,int.
</t>
<t tx="ekr.20171123135625.30">@g.commander_command('always-indent-region')
def alwaysIndentBody(self, event=None):
    """
    The always-indent-region command indents each line of the selected body
    text. The @tabwidth directive in effect determines amount of
    indentation.
    """
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Initial data.
    sel_1, sel_2 = w.getSelectionRange()
    tab_width = c.getTabWidth(p)
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    #
    # Calculate the result.
    changed, result = False, []
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
        s = g.computeLeadingWhitespace(width + abs(tab_width), tab_width) + line[i:]
        if s != line:
            changed = True
        result.append(s)
    if not changed:
        return
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    all = head + middle + tail
    p.b = all # Sets dirty and changed bits.
    w.setAllText(all)
    #
    # Calculate the proper selection range (i, j, ins).
    if sel_1 == sel_2:
        line = result[0]
        i, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
        i = j = len(head) + i
    else:
        i = len(head)
        j = len(head) + len(middle)
        if middle.endswith('\n'):  # #1742.
            j -= 1
    #
    # Set the selection range and scroll position.
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Indent Region', bunch)

@g.commander_command('indent-region')
def indentBody(self, event=None):
    """
    The indent-region command indents each line of the selected body text.
    Unlike the always-indent-region command, this command inserts a tab
    (soft or hard) when there is no selected text.
    
    The @tabwidth directive in effect determines amount of indentation.
    """
    c, w = self, self.frame.body.wrapper
    # # 1739. Special case for a *plain* tab bound to indent-region.
    sel_1, sel_2 = w.getSelectionRange()
    if sel_1 == sel_2:
        char = getattr(event, 'char', None)
        stroke = getattr(event, 'stroke', None)
        if char == '\t' and stroke and stroke.isPlainKey():
            c.editCommands.selfInsertCommand(event)  # Handles undo.
            return
    c.alwaysIndentBody(event)
</t>
<t tx="ekr.20171123135625.34">@g.commander_command('add-comments')
def addComments(self, event=None):
    &lt;&lt; addComments docstring &gt;&gt;
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Make sure there is a selection.
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    if not lines:
        g.warning('no text selected')
        return
    #
    # The default language in effect at p.
    language = c.frame.body.colorizer.scanLanguageDirectives(p)
    if c.hasAmbiguousLanguage(p):
        language = c.getLanguageAtCursor(p, language)
    d1, d2, d3 = g.set_delims_from_language(language)
    d2 = d2 or ''; d3 = d3 or ''
    if d1:
        openDelim, closeDelim = d1 + ' ', ''
    else:
        openDelim, closeDelim = d2 + ' ', ' ' + d3
    #
    # Calculate the result.
    indent = c.config.getBool('indent-added-comments', default=True)
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line, 0)
            if indent:
                s = line[i:].replace('\n', '')
                result.append(line[0:i] + openDelim + s + closeDelim + '\n')
            else:
                s = line.replace('\n', '')
                result.append(openDelim + s + closeDelim + '\n')
        else:
            result.append(line)
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    p.b = head + middle + tail  # Sets dirty and changed bits.
    w.setAllText(head + middle + tail)
    #
    # Calculate the proper selection range (i, j, ins).
    i = len(head)
    j = max(i, len(head) + len(middle) - 1)
    #
    # Set the selection range and scroll position.
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Add Comments', bunch)
</t>
<t tx="ekr.20171123135625.35">@pagewidth 50
"""
Converts all selected lines to comment lines using
the comment delimiters given by the applicable @language directive.

Inserts single-line comments if possible; inserts
block comments for languages like html that lack
single-line comments.

@bool indent_added_comments

If True (the default), inserts opening comment
delimiters just before the first non-whitespace
character of each line. Otherwise, inserts opening
comment delimiters at the start of each line.

*See also*: delete-comments.
"""
</t>
<t tx="ekr.20171123135625.36">@g.commander_command('delete-comments')
def deleteComments(self, event=None):
    &lt;&lt; deleteComments docstring &gt;&gt;
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Initial data.
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    if not lines:
        g.warning('no text selected')
        return
    # The default language in effect at p.
    language = c.frame.body.colorizer.scanLanguageDirectives(p)
    if c.hasAmbiguousLanguage(p):
        language = c.getLanguageAtCursor(p, language)
    d1, d2, d3 = g.set_delims_from_language(language)
    #
    # Calculate the result.
    changed, result = False, []
    if d1:
        # Remove the single-line comment delim in front of each line
        d1b = d1 + ' '
        n1, n1b = len(d1), len(d1b)
        for s in lines:
            i = g.skip_ws(s, 0)
            if g.match(s, i, d1b):
                result.append(s[:i] + s[i + n1b :])
                changed = True
            elif g.match(s, i, d1):
                result.append(s[:i] + s[i + n1 :])
                changed = True
            else:
                result.append(s)
    else:
        # Remove the block comment delimiters from each line.
        n2, n3 = len(d2), len(d3)
        for s in lines:
            i = g.skip_ws(s, 0)
            j = s.find(d3, i + n2)
            if g.match(s, i, d2) and j &gt; -1:
                first = i + n2
                if g.match(s, first, ' '):
                    first += 1
                last = j
                if g.match(s, last - 1, ' '):
                    last -= 1
                result.append(s[:i] + s[first:last] + s[j + n3 :])
                changed = True
            else:
                result.append(s)
    if not changed:
        return
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    p.b = head + middle + tail  # Sets dirty and changed bits.
    w.setAllText(head + middle + tail)
    #
    # Set the selection range and scroll position.
    i = len(head)
    j = ins = max(i, len(head) + len(middle) - 1)
    w.setSelectionRange(i, j, insert=ins)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Indent Region', bunch)
</t>
<t tx="ekr.20171123135625.37">@pagewidth 50
"""
Removes one level of comment delimiters from all
selected lines.  The applicable @language directive
determines the comment delimiters to be removed.

Removes single-line comments if possible; removes
block comments for languages like html that lack
single-line comments.

*See also*: add-comments.
"""
</t>
<t tx="ekr.20171123135625.38">@g.commander_command('insert-body-time')
def insertBodyTime(self, event=None):
    """Insert a time/date stamp at the cursor."""
    c = self; undoType = 'Insert Body Time'
    w = c.frame.body.wrapper
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    oldSel = w.getSelectionRange()
    w.deleteTextSelection()
    s = self.getTime(body=True)
    i = w.getInsertPoint()
    w.insert(i, s)
    c.frame.body.onBodyChanged(undoType, oldSel=oldSel)
</t>
<t tx="ekr.20171123135625.4">@cmd('execute-script')
def executeScript(self, event=None,
    args=None, p=None, script=None, useSelectedText=True,
    define_g=True, define_name='__main__',
    silent=False, namespace=None, raiseFlag=False,
    runPyflakes=True,
):
    """
    Execute a *Leo* script.
    Keyword args:
    args=None               Not None: set script_args in the execution environment.
    p=None                  Get the script from p.b, unless script is given.
    script=None             None: use script in p.b or c.p.b
    useSelectedText=True    False: use all the text in p.b or c.p.b.
    define_g=True           True: define g for the script.
    define_name='__main__'  Not None: define the name symbol.
    silent=False            No longer used.
    namespace=None          Not None: execute the script in this namespace.
    raiseFlag=False         True: reraise any exceptions.
    runPyflakes=True        True: run pyflakes if allowed by setting.
    """
    c, script1 = self, script
    if runPyflakes:
        run_pyflakes = c.config.getBool('run-pyflakes-on-write', default=False)
    else:
        run_pyflakes = False
    if not script:
        if c.forceExecuteEntireBody:
            useSelectedText = False
        script = g.getScript(c, p or c.p, useSelectedText=useSelectedText)
    script_p = p or c.p
        # Only for error reporting below.
    # #532: check all scripts with pyflakes.
    if run_pyflakes and not g.unitTesting:
        from leo.commands import checkerCommands as cc
        # at = c.atFileCommands
        prefix = ('c,g,p,script_gnx=None,None,None,None;'
                  'assert c and g and p and script_gnx;\n')
        cc.PyflakesCommand(c).check_script(script_p, prefix + script)
    self.redirectScriptOutput()
    try:
        oldLog = g.app.log
        log = c.frame.log
        g.app.log = log
        if script.strip():
            sys.path.insert(0, '.')  # New in Leo 5.0
            sys.path.insert(0, c.frame.openDirectory)  # per SegundoBob
            script += '\n'  # Make sure we end the script properly.
            try:
                if not namespace or namespace.get('script_gnx') is None:
                    namespace = namespace or {}
                    namespace.update(script_gnx=script_p.gnx)
                # We *always* execute the script with p = c.p.
                c.executeScriptHelper(args, define_g, define_name, namespace, script)
            except KeyboardInterrupt:
                g.es('interrupted')
            except Exception:
                if raiseFlag:
                    raise
                g.handleScriptException(c, script_p, script, script1)
            finally:
                del sys.path[0]
                del sys.path[0]
        else:
            tabName = log and hasattr(log, 'tabName') and log.tabName or 'Log'
            g.warning("no script selected", tabName=tabName)
    finally:
        g.app.log = oldLog
        self.unredirectScriptOutput()
</t>
<t tx="ekr.20171123135625.47">def rp_reformat(c, head, oldSel, oldYview, original, result, tail, undoType):
    """Reformat the body and update the selection."""
    p, u, w = c.p, c.undoer, c.frame.body.wrapper
    s = head + result + tail
    changed = original != s
    bunch = u.beforeChangeBody(p)
    if changed:
        w.setAllText(s)  # Destroys coloring.
    #
    # #1748: Always advance to the next paragraph.
    i = len(head)
    j = max(i, len(head) + len(result) - 1)
    ins = j + 1
    while ins &lt; len(s):
        i, j = g.getLine(s, ins)
        line = s[i:j]
        # It's annoying, imo, to treat @ lines differently.
        if line.isspace():
            ins = j + 1
        else:
            ins = i
            break
    ins = min(ins, len(s))
    w.setSelectionRange(ins, ins, insert=ins)
    #
    # Show more lines, if they exist.
    k = g.see_more_lines(s, ins, 4)
    p.v.insertSpot = ins
    w.see(k)  # New in 6.4. w.see works!
    if not changed:
        return
    #
    # Finish.
    p.v.b = s  # p.b would cause a redraw.
    u.afterChangeBody(p, undoType, bunch)
    w.setXScrollPosition(0)  # Never scroll horizontally.
</t>
<t tx="ekr.20171123135625.5">def executeScriptHelper(self, args, define_g, define_name, namespace, script):
    c = self
    if c.p:
        p = c.p.copy()  # *Always* use c.p and pass c.p to script.
        c.setCurrentDirectoryFromContext(p)
    else:
        p = None
    d = {'c': c, 'g': g, 'input': g.input_, 'p': p} if define_g else {}
    if define_name: d['__name__'] = define_name
    d['script_args'] = args or []
    d['script_gnx'] = g.app.scriptDict.get('script_gnx')
    if namespace: d.update(namespace)
    #
    # A kludge: reset c.inCommand here to handle the case where we *never* return.
    # (This can happen when there are multiple event loops.)
    # This does not prevent zombie windows if the script puts up a dialog...
    try:
        c.inCommand = False
        g.inScript = g.app.inScript = True
            # g.inScript is a synonym for g.app.inScript.
        if c.write_script_file:
            scriptFile = self.writeScriptFile(script)
            exec(compile(script, scriptFile, 'exec'), d)
        else:
            exec(script, d)
    finally:
        g.inScript = g.app.inScript = False
</t>
<t tx="ekr.20171123135625.50">def unreformat(c, head, oldSel, oldYview, original, result, tail, undoType):
    """unformat the body and update the selection."""
    body, w = c.frame.body, c.frame.body.wrapper
    s = head + result + tail
    ins = max(len(head), len(head) + len(result) - 1)
    w.setAllText(s)  # Destroys coloring.
    changed = original != s
    if changed:
        body.onBodyChanged(undoType, oldSel=oldSel)
    # Advance to the next paragraph.
    ins += 1  # Move past the selection.
    while ins &lt; len(s):
        i, j = g.getLine(s, ins)
        line = s[i:j]
        if line.isspace():
            ins = j + 1
        else:
            ins = i
            break
    c.recolor()  # Required.
    w.setSelectionRange(ins, ins, insert=ins)
    # More useful than for reformat-paragraph.
    w.see(ins)
    # Make sure we never scroll horizontally.
    w.setXScrollPosition(0)
</t>
<t tx="ekr.20171123135625.55">@g.commander_command('toggle-angle-brackets')
def toggleAngleBrackets(self, event=None):
    """Add or remove double angle brackets from the headline of the selected node."""
    c = self; p = c.p
    if g.app.batchMode:
        c.notValidInBatchMode("Toggle Angle Brackets")
        return
    c.endEditing()
    s = p.h.strip()
    # 2019/09/12: Guard against black.
    lt = "&lt;&lt;"
    rt = "&gt;&gt;"
    if s[0:2] == lt or s[-2:] == rt:
        if s[0:2] == "&lt;&lt;": s = s[2:]
        if s[-2:] == "&gt;&gt;": s = s[:-2]
        s = s.strip()
    else:
        s = g.angleBrackets(' ' + s + ' ')
    p.setHeadString(s)
    p.setDirty()  # #1449.
    c.setChanged()  # #1449.
    c.redrawAndEdit(p, selectAll=True)
</t>
<t tx="ekr.20171123135625.6">def redirectScriptOutput(self):
    c = self
    if c.config.redirect_execute_script_output_to_log_pane:
        g.redirectStdout()  # Redirect stdout
        g.redirectStderr()  # Redirect stderr
</t>
<t tx="ekr.20171123135625.7">def setCurrentDirectoryFromContext(self, p):
    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    curDir = g.os_path_abspath(os.getcwd())
    if path and path != curDir:
        try:
            os.chdir(path)
        except Exception:
            pass
</t>
<t tx="ekr.20171123135625.8">def unredirectScriptOutput(self):
    c = self
    if c.exists and c.config.redirect_execute_script_output_to_log_pane:
        g.restoreStderr()
        g.restoreStdout()
</t>
<t tx="ekr.20171124043747.1">def registerCommandShortcut(self, commandName, func, pane, shortcut):
    """
    Register a shortcut for the a command.
    
    **Important**: Bindings created here from plugins can not be overridden.
    This includes @command and @button bindings created by mod_scripting.py.
    """
    c, k = self.c, self
    is_local = c.shortFileName() not in ('myLeoSettings.leo', 'leoSettings.leo')
    assert not g.isStroke(shortcut)
    if shortcut:
        stroke = g.KeyStroke(binding=shortcut) if shortcut else None
    elif commandName.lower() == 'shortcut':  # Causes problems.
        stroke = None
    elif is_local:
        # 327: Don't get defaults when handling a local file.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk, aList = c.config.getShortcut(commandName)
        for bi in aList:
            if bi.stroke and not bi.pane.endswith('-mode'):
                stroke = bi.stroke
                pane = bi.pane  # 2015/05/11.
                break
    if stroke:
        k.bindKey(pane, stroke, func, commandName, tag='register-command')
            # Must be a stroke.
        k.makeMasterGuiBinding(stroke)  # Must be a stroke.
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict[key] = c.commandsDict.get(commandName)
                    break
</t>
<t tx="ekr.20171228013625.1">def check_script(self, p, script):
    """Call pyflakes to check the given script."""
    try:
        from pyflakes import api, reporter
    except Exception:  # ModuleNotFoundError
        return True  # Pretend all is fine.
    # #1306: nopyflakes
    lines = g.splitLines(p.b)
    for line in lines:
        if line.strip().startswith('@nopyflakes'):
            return True
    r = reporter.Reporter(
        errorStream=self.LogStream(),
        warningStream=self.LogStream(),
    )
    errors = api.check(script, '', r)
    return errors == 0
</t>
<t tx="ekr.20180207071114.5">def create(self, fn):
    """Create the given file with empty contents."""
    # Make the directories as needed.
    theDir = g.os_path_dirname(fn)
    if theDir:
        ok = g.makeAllNonExistentDirectories(theDir)
        # #1453: Don't assume the directory exists.
        if not ok:
            g.error(f"did not create directory: {theDir}")
            return
    # Create the file.
    try:
        f = open(fn, mode='wb')
        f.close()
        g.note(f"created: {fn}")
    except IOError:
        g.error(f"can not create: {fn}")
    except Exception:
        g.error(f"unexpected error creating: {fn}")
        g.es_exception()
</t>
<t tx="ekr.20180207072351.1">def find_user_dict(self):
    """Return the full path to the local dictionary."""
    c = self.c
    join = g.os_path_finalize_join
    table = (
        c.config.getString('enchant-local-dictionary'),
            # Settings first.
        join(g.app.homeDir, '.leo', 'spellpyx.txt'),
            # #108: then the .leo directory.
        join(g.app.loadDir, "..", "plugins", 'spellpyx.txt'),
            # The plugins directory as a last resort.
    )
    for path in table:
        if g.os_path_exists(path):
            return path
    g.es_print('Creating ~/.leo/spellpyx.txt')
    # #1453: Return the default path.
    return join(g.app.homeDir, '.leo', 'spellpyx.txt')
</t>
<t tx="ekr.20180207073815.1">def read_words(self, kind, fn):
    """Return all the words from the dictionary file."""
    words = set()
    try:
        with open(fn, 'rb') as f:
            s = g.toUnicode(f.read())
            # #1688: Do this in place.
            for line in g.splitLines(s):
                line = line.strip()
                if line and not line.startswith('#'):
                    words.add(line)
    except Exception:
        g.es_print(f"can not open {kind} dictionary: {fn}")
    return words
</t>
<t tx="ekr.20180210092235.1">def backup_helper(self,
    base_dir=None,
    env_key='LEO_BACKUP',
    sub_dir=None,
    use_git_prefix=True,
):
    """
    A helper for scripts that back up a .leo file.
    Use os.environ[env_key] as the base_dir only if base_dir is not given.
    Backup to base_dir or join(base_dir, sub_dir).
    """
    c = self
    old_cwd = os.getcwd()
    join = g.os_path_finalize_join
    if not base_dir:
        if env_key:
            try:
                base_dir = os.environ[env_key]
            except KeyError:
                print(f"No environment var: {env_key}")
                base_dir = None
    if base_dir and g.os_path_exists(base_dir):
        if use_git_prefix:
            git_branch, junk = g.gitInfo()
        else:
            git_branch = None
        theDir, fn = g.os_path_split(c.fileName())
        backup_dir = join(base_dir, sub_dir) if sub_dir else base_dir
        path = join(backup_dir, fn)
        if g.os_path_exists(backup_dir):
            written_fn = c.backup(
                path,
                prefix=git_branch,
                silent=True,
                useTimeStamp=True,
            )
            g.es_print(f"wrote: {written_fn}")
        else:
            g.es_print(f"backup_dir not found: {backup_dir!r}")
    else:
        g.es_print(f"base_dir not found: {base_dir!r}")
    os.chdir(old_cwd)
</t>
<t tx="ekr.20180225010644.1">@nobeautify</t>
<t tx="ekr.20180225010707.1"></t>
<t tx="ekr.20180225010743.1">@nosearch</t>
<t tx="ekr.20180225010850.1"></t>
<t tx="ekr.20180225010913.1"></t>
<t tx="ekr.20180307132016.1">def doEnter(self, event):
    '''Handle the &lt;return&gt; key.'''
    #
    # Binding for functions.
    interp = self.interpreter
    
    @others # Helper function
    #
    # Set cursor to end of line to avoid line splitting
    textCursor = self.textCursor()
    position   = len(self.document().toPlainText())
    textCursor.setPosition(position)
    self.setTextCursor(textCursor)
    lines = []
    block = self.document().lastBlock()
    #
    # Scan backward, looking for lines.
    while block:
        line = g.toUnicode(block.text())
        line = line.replace('\t',' '*4)
        block = block.previous()
        if line.startswith('&gt;&gt;&gt; '):
            lines.insert(0, line[4:])
            break
        elif line.startswith('... '):
            lines.insert(0, line[4:])
        else:
            lines.insert(0, line)
    #
    # Always end the log line.
    self.append('')
    #
    # Clean the lines and compute the last line.
    last_line = lines[-1].rstrip() if lines else ''
    lines = [z.rstrip() + '\n' for z in lines if z.strip()]
    if self.customCommands(last_line):
        return
    #
    # Handle the history and set self.indent for insert_marker.
    if last_line.strip():
        self.history.insert(0, last_line)
        self.indent = compute_indent(last_line)
    #
    # Check for a continued line.
    if self.indent &gt; 0 and last_line:
        self.insert_marker()
        return
    #
    # Execute lines in groups, delimited by indentation.
    indent, ok, exec_lines = 0, True, []
    for line in lines:
        indent = compute_indent(line) if exec_lines else 0
        if indent &gt; 0 or not exec_lines:
            exec_lines.append(line)
            continue
        # End of a group.
        ok = compile_and_run_lines(exec_lines)
        exec_lines = [line]
        if not ok:
            break
    # Tail group.
    if ok and exec_lines:
        compile_and_run_lines(exec_lines)
    self.indent = 0
    self.insert_marker()
</t>
<t tx="ekr.20180311090852.1">def get_jupyter_source(self, c):
    '''Return the html for the @jupyer node.'''
    body = c.p.b.lstrip()
    if body.startswith('&lt;'):
        # Assume the body is html.
        return body
    if body.startswith('{'):
        # Leo 5.7.1: Allow raw JSON.
        s = body
    else:
        url = g.getUrlFromNode(c.p)
        if not url:
            return ''
        if not nbformat:
            return 'can not import nbformt to render url: %r' % url
        try:
            s = urlopen(url).read().decode()
        except Exception:
            return 'url not found: %s' % url
    try:
        nb = nbformat.reads(s, as_version=4)
        e = HTMLExporter()
        (s, junk_resources) = e.from_notebook_node(nb)
    except nbformat.reader.NotJSONError:
        pass # Assume the result is html.
    return s
</t>
<t tx="ekr.20180312043352.2">@g.commander_command('open-theme-file')
def open_theme_file(self, event):
    """Open a theme file in a new session and apply the theme."""
    c = event and event.get('c')
    if not c:
        return
    # Get the file name.
    themes_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'themes')
    fn = g.app.gui.runOpenFileDialog(c,
        title="Open Theme File",
        filetypes=[
            ("Leo files", "*.leo *.db"),
            ("All files", "*"),
        ],
        defaultextension=g.defaultLeoFileExtension(c),
        startpath=themes_dir,
    )
    if not fn:
        return
    leo_dir = g.os_path_finalize_join(g.app.loadDir, '..', '..')
    os.chdir(leo_dir)
    #
    # #1425: Open the theme file in a separate process.
    command = f'{g.sys.executable} {g.app.loadDir}/runLeo.py "{fn}"'
    g.execute_shell_commands(command) # #1564.
    os.chdir(leo_dir)
</t>
<t tx="ekr.20180312150559.1">@nobeautify

def addOptionsToParser(self, parser, trace_m):
    
    add = parser.add_option
    
    def add_bool(option, help, dest=None):
        add(option, action='store_true', dest=dest, help=help)

    def add_other(option, help, dest=None, m=None):
        add(option, dest=dest, help=help, metavar=m)

    add_bool('--diff',          'use Leo as an external git diff')
    add_bool('--fullscreen',    'start fullscreen')
    add_bool('--ipython',       'enable ipython support')
    add_bool('--fail-fast',     'stop unit tests after the first failure')
    add_other('--gui',          'gui to use (qt/console/null)')
    add_bool('--listen-to-log', 'start log_listener.py on startup')
    add_other('--load-type',    '@&lt;file&gt; type for non-outlines', m='TYPE')
    add_bool('--maximized',     'start maximized')
    add_bool('--minimized',     'start minimized')
    add_bool('--no-plugins',    'disable all plugins')
    add_bool('--no-splash',     'disable the splash screen')
    add_other('--screen-shot',  'take a screen shot and then exit', m='PATH')
    add_other('--script',       'execute a script and then exit', m="PATH")
    add_bool('--script-window', 'execute script using default gui')
    add_other('--select',       'headline or gnx of node to select', m='ID')
    add_bool('--silent',        'disable all log messages')
    add_other('--theme',        'use the named theme file', m='NAME')
    add_other('--trace',        'add one or more strings to g.app.debug', m=trace_m)
    add_other('--trace-binding', 'trace commands bound to a key', m='KEY')
    add_other('--trace-setting', 'trace where named setting is set', m="NAME")
    add_other('--window-size',  'initial window size (height x width)', m='SIZE')
    add_other('--window-spot',  'initial window position (top x left)', m='SPOT')
    # Multiple bool values.
    add('-v', '--version', action='store_true',
        help='print version number and exit')
</t>
<t tx="ekr.20180312150805.1">def doGuiOption(self, options):
    gui = options.gui
    if gui:
        gui = gui.lower()
        # #1171: retire non-tabbed qt gui.
        if gui in ('qt', 'qttabs'):
            gui = 'qt'  # For compatibilty with g.UiTypeException
        elif gui.startswith('browser'):
            pass
        elif gui in ('console', 'curses', 'text', 'null'):
            pass
        else:
            print(f"scanOptions: unknown gui: {gui}.  Using qt gui")
            gui = 'qt'
    else:
        gui = 'qt'
    assert gui
    assert gui != 'qttabs'  # For compatibilty with g.UiTypeException
    g.app.qt_use_tabs = gui == 'qt'
    g.app.guiArgName = gui
    return gui
</t>
<t tx="ekr.20180312151544.1">def doSimpleOptions(self, options, trace_m):
    """These args just set g.app ivars."""
    # --fail-fast
    g.app.failFast = options.fail_fast
    # --fullscreen
    g.app.start_fullscreen = options.fullscreen
    # --git-diff
    g.app.diff = options.diff
    # --listen-to-log
    g.app.listen_to_log_flag = options.listen_to_log
    # --ipython
    g.app.useIpython = options.ipython
    # --maximized
    g.app.start_maximized = options.maximized
    # --minimized
    g.app.start_minimized = options.minimized
    # --no-plugins
    if options.no_plugins:
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = not options.no_splash and not options.minimized
    # --silent
    g.app.silentMode = options.silent
    # --trace=...
    valid = trace_m.replace(' ', '').replace('\n', '').split(',')
    # g.trace('valid', valid)
    if options.trace:
        values = options.trace.lstrip('(').lstrip('[').rstrip(')').rstrip(']')
        for val in values.split(','):
            if val in valid:
                g.app.debug.append(val)
            else:
                g.es_print(f"unknown --trace value: {val}")
    #
    # These are not bool options.
    # --trace-binding
    g.app.trace_binding = options.trace_binding
        # g.app.config does not exist yet.
    #
    # --trace-setting=setting
    g.app.trace_setting = options.trace_setting
        # g.app.config does not exist yet.
</t>
<t tx="ekr.20180312152329.1">def doLoadTypeOption(self, options):

    s = options.load_type
    s = s.lower() if s else 'edit'
    return '@' + s
</t>
<t tx="ekr.20180312152609.1">def doScreenShotOption(self, options):

    # --screen-shot=fn
    s = options.screen_shot
    if s:
        s = s.strip('"')
    return s
</t>
<t tx="ekr.20180312153008.1">def doScriptOption(self, options, parser):

    # --script
    script = options.script
    if script:
        # #1090: use cwd, not g.app.loadDir, to find scripts.
        fn = g.os_path_finalize_join(os.getcwd(), script)
        script, e = g.readFileIntoString(fn, kind='script:', verbose=False)
        if not script:
            print(f"script not found: {fn}")
            sys.exit(1)
    else:
        script = None
    return script
</t>
<t tx="ekr.20180312154839.1">def doWindowSizeOption(self, options):

    # --window-size
    windowSize = options.window_size
    if windowSize:
        try:
            h, w = windowSize.split('x')
            windowSize = int(h), int(w)
        except ValueError:
            windowSize = None
            print('scanOptions: bad --window-size:', windowSize)
    return windowSize
</t>
<t tx="ekr.20180324065741.1">"""Copy the selected text to the next node."""
w = c.frame.body.wrapper
s = w.getSelectedText()
if s.strip():
    w.deleteTextSelection()
    c.p.b = w.getAllText()
    w.setInsertPoint(0)
    p = c.insertHeadline()
    c.selectPosition(p)
    p.b = s
    c.editHeadline()
else:
    g.es_print('no text selected')
</t>
<t tx="ekr.20180410074238.1">def insert_toc(c, kind):
    """Insert a table of contents at the cursor."""
    undoType = f"Insert {kind.capitalize()} TOC"
    w = c.frame.body.wrapper
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    oldSel = w.getSelectionRange()
    w.deleteTextSelection()
    s = make_toc(c, kind=kind, root=c.p)
    i = w.getInsertPoint()
    w.insert(i, s)
    c.frame.body.onBodyChanged(undoType, oldSel=oldSel)
</t>
<t tx="ekr.20180413180751.2">def doNonKeyEvent(self, event, obj):
    """Handle all non-key event. """
    c = self.c
    ev = QtCore.QEvent
    eventType = event.type()
    if eventType == ev.WindowActivate:
        g.app.gui.onActivateEvent(event, c, obj, self.tag)
    elif eventType == ev.WindowDeactivate:
        g.app.gui.onDeactivateEvent(event, c, obj, self.tag)
    elif eventType == ev.FocusIn:
        if self.tag == 'body':
            c.frame.body.onFocusIn(obj)
        if c.frame and c.frame.top and obj is c.frame.top.lineEdit:
            if c.k.getStateKind() == 'getArg':
                c.frame.top.lineEdit.restore_selection()
    elif eventType == ev.FocusOut and self.tag == 'body':
        c.frame.body.onFocusOut(obj)
    return eventType not in (ev.ShortcutOverride, ev.KeyPress, ev.KeyRelease)
        # Return True unless we have a key event.
</t>
<t tx="ekr.20180413180751.3">def shouldIgnoreKeyEvent(self, event, obj):
    """
    Return True if we should ignore the key event.
    
    Alas, QLineEdit *only* generates ev.KeyRelease on Windows, Ubuntu,
    so the following hack is required.
    """
    c = self.c
    ev = QtCore.QEvent
    t = event.type()
    isEditWidget = (obj == c.frame.tree.edit_widget(c.p))
    if isEditWidget:
        return t != ev.KeyRelease
            # QLineEdit: ignore all key events except keyRelease events.
    if t == ev.KeyPress:
        return False  # Never ignore KeyPress events.
    # This doesn't work. Two shortcut-override events are generated!
        # if t == ev.ShortcutOverride and event.text():
            # return False # Don't ignore shortcut overrides with a real value.
    return True  # Ignore everything else.
</t>
<t tx="ekr.20180415083926.1">def finalize_char(self, s):
    """Perform very-last-minute translations on bindings."""
    #
    # Retain "bigger" spelling for gang-of-four bindings with modifiers.
    shift_d = {
        'bksp': 'BackSpace',
        'backspace': 'BackSpace',
        'backtab': 'Tab',  # The shift mod will convert to 'Shift+Tab',
        'linefeed': 'Return',
        '\r': 'Return',
        'return': 'Return',
        'tab': 'Tab',
    }
    if self.mods and s.lower() in shift_d:
        return shift_d.get(s.lower())
            # Returning '' breaks existing code.
    #
    # Make all other translations...
    #
    # This dict ensures proper capitalization.
    # It also translates legacy Tk binding names to ascii chars.
    translate_d = {
        #
        # The gang of four...
        'bksp': 'BackSpace',
        'backspace': 'BackSpace',
        'backtab': 'Tab',  # The shift mod will convert to 'Shift+Tab',
        'linefeed': '\n',
        '\r': '\n',
        'return': '\n',
        'tab': 'Tab',
        #
        # Special chars...
        'delete': 'Delete',
        'down': 'Down',
        'end': 'End',
        'enter': 'Enter',
        'escape': 'Escape',
        'home': 'Home',
        'insert': 'Insert',
        'left': 'Left',
        'next': 'Next',
        'prior': 'Prior',
        'right': 'Right',
        'up': 'Up',
        #
        # Qt key names...
        'del': 'Delete',
        'dnarrow': 'Down',
        'esc': 'Escape',
        'ins': 'Insert',
        'ltarrow': 'Left',
        'pagedn': 'Next',
        'pageup': 'Prior',
        'pgdown': 'Next',
        'pgup': 'Prior',
        'rtarrow': 'Right',
        'uparrow': 'Up',
        #
        # Legacy Tk binding names...
        "ampersand": "&amp;",
        "asciicircum": "^",
        "asciitilde": "~",
        "asterisk": "*",
        "at": "@",
        "backslash": "\\",
        "bar": "|",
        "braceleft": "{",
        "braceright": "}",
        "bracketleft": "[",
        "bracketright": "]",
        "colon": ":",
        "comma": ",",
        "dollar": "$",
        "equal": "=",
        "exclam": "!",
        "greater": "&gt;",
        "less": "&lt;",
        "minus": "-",
        "numbersign": "#",
        "quotedbl": '"',
        "quoteright": "'",
        "parenleft": "(",
        "parenright": ")",
        "percent": "%",
        "period": ".",
        "plus": "+",
        "question": "?",
        "quoteleft": "`",
        "semicolon": ";",
        "slash": "/",
        "space": " ",
        "underscore": "_",
    }
    #
    # pylint: disable=undefined-loop-variable
        # Looks like a pylint bug.
    if s in (None, 'none', 'None'):
        return 'None'
    if s.lower() in translate_d:
        s = translate_d.get(s.lower())
        return self.strip_shift(s)
    if len(s) &gt; 1 and s.find(' ') &gt; -1:
        # #917: not a pure, but should be ignored.
        return ''
    if s.isalpha():
        if len(s) == 1:
            if 'shift' in self.mods:
                if len(self.mods) == 1:
                    self.mods.remove('shift')
                    s = s.upper()
                else:
                    s = s.lower()
            elif self.mods:
                s = s.lower()
        else:
            # 917: Ignore multi-byte alphas not in the table.
            s = ''
            if 0:
                # Make sure all special chars are in translate_d.
                if g.app.gui:  # It may not exist yet.
                    if s.capitalize() in g.app.gui.specialChars:
                        s = s.capitalize()
        return s
    #
    # Translate shifted keys to their appropriate alternatives.
    return self.strip_shift(s)
</t>
<t tx="ekr.20180417102341.1">def isPlainKey(self):
    """
    Return True if self.s represents a plain key.
    
    A plain key is a key that can be inserted into text.
    
    **Note**: The caller is responsible for handling Alt-Ctrl keys.
    """
    s = self.s
    if s in g.app.gui.ignoreChars:
        # For unit tests.
        return False
    # #868:
    if s.find('Keypad+') &gt; -1:
        # Enable bindings.
        return False
    if self.find_mods(s) or self.isFKey():
        return False
    if s in g.app.gui.specialChars:
        return False
    if s == 'BackSpace':
        return False
    return True
</t>
<t tx="ekr.20180417161548.1">def doLateTweaks(self, binding, ch):
    """Make final tweaks. g.KeyStroke does other tweaks later."""
    #
    # These are needed  because ch is separate from binding.
    if ch == '\r':
        ch = '\n'
    if binding == 'Escape':
        ch = 'Escape'
    #
    # Adjust the case of the binding string (for the minibuffer).
    if len(ch) == 1 and len(binding) == 1 and ch.isalpha() and binding.isalpha():
        if ch != binding:
            binding = ch
    return binding, ch
</t>
<t tx="ekr.20180418023827.1">def doDemo(self, event):
    """
    Support the demo.py plugin.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    stroke = event.stroke
    demo = getattr(g.app, 'demo', None)
    if not demo:
        return False
    #
    # Shortcut everything so that demo-next or demo-prev won't alter of our ivars.
    if k.demoNextKey and stroke == k.demoNextKey:
        if demo.trace:
            g.trace('demo-next', stroke)
        demo.next_command()
        return True
    if k.demoPrevKey and stroke == k.demoPrevKey:
        if demo.trace:
            g.trace('demo-prev', stroke)
        demo.prev_command()
        return True
    return False
</t>
<t tx="ekr.20180418024449.1">def doKeyboardQuit(self, event):
    """
    A helper for k.masterKeyHandler: Handle keyboard-quit logic.
    
    return True if k.masterKeyHandler should return.
    """
    c, k = self.c, self
    stroke = getattr(event, 'stroke', None)
    if k.abortAllModesKey and stroke and stroke == k.abortAllModesKey:
        if getattr(c, 'screenCastController', None):
            c.screenCastController.quit()
        c.doCommandByName('keyboard-quit', event)
        return True
    return False
</t>
<t tx="ekr.20180418025241.1">def doVim(self, event):
    """
    Handle vim mode.
    Return True if k.masterKeyHandler should return.
    """
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    c = self.c
    if c.vim_mode and c.vimCommands:
        # The "acceptance methods" in leoVim.py return True
        # if vim node has completely handled the key.
        # Otherwise, processing in k.masterKeyHandler continues.
        ok = c.vimCommands.do_key(event)
        if trace: g.trace('do_key returns', ok, repr(event and event.stroke))
        return ok
    return False
</t>
<t tx="ekr.20180418031118.1">def isSpecialKey(self, event):
    """Return True if char is a special key."""
    if not event:
        # An empty event is not an error.
        return False
    # Fix #917.
    if len(event.char) &gt; 1 and not event.stroke.s:
        # stroke.s was cleared, but not event.char.
        return True
    return event.char in g.app.gui.ignoreChars
</t>
<t tx="ekr.20180418031417.1">def traceVars(self, event):

    trace = False and not g.unitTesting
    traceGC = False
    verbose = False
    k = self
    if not trace:
        return
    if traceGC:
        g.printNewObjects('masterKey 1')
    if verbose:
        char = event.char
        state = k.state.kind
        stroke = event.stroke
        g.trace(
            f"stroke: {stroke!r}, "
            f"char: {char!r}, "
            f"state: {state}, "
            f"state2: {k.unboundKeyAction}")
</t>
<t tx="ekr.20180418033838.1">def doBinding(self, event):
    """
    Attempt to find a binding for the event's stroke.
    If found, execute the command and return True
    Otherwise, return False
    """
    trace = 'keys' in g.app.debug
    c, k = self.c, self
    #
    # Experimental special case:
    # Inserting a '.' always invokes the auto-completer.
    # The auto-completer just inserts a '.' if it isn't enabled.
    stroke = event.stroke
    if (
        stroke.s == '.'
        and k.isPlainKey(stroke)
        and self.unboundKeyAction in ('insert', 'overwrite')
    ):
        c.doCommandByName('auto-complete', event)
        return True
    #
    # Use getPaneBindings for *all* keys.
    bi = k.getPaneBinding(event)
    #
    # #327: Ignore killed bindings.
    if bi and bi.commandName in k.killedBindings:
        return False  
    #
    # Execute the command if the binding exists.
    if bi:
        # A superb trace. !s gives shorter trace.
        if trace: g.trace(f"{event.stroke!s} {bi.commandName}")
        c.doCommandByName(bi.commandName, event)
        return True
    #
    # No binding exists.
    return False
</t>
<t tx="ekr.20180418034305.1">def setEventWidget(self, event):
    """
    A hack: redirect the event to the text part of the log.
    """
    c = self.c
    w = event.widget
    w_name = c.widget_name(w)
    if w_name.startswith('log'):
        event.widget = c.frame.log.logCtrl
</t>
<t tx="ekr.20180418040158.1">def checkKeyEvent(self, event):
    """Perform sanity checks on the incoming event."""
    # These assert's should be safe, because eventFilter
    # calls k.masterKeyHandler inside a try/except block.
    c = self.c
    assert event is not None
    c.check_event(event)
    assert hasattr(event, 'char')
    assert hasattr(event, 'stroke')
    if not hasattr(event, 'widget'):
        event.widget = None
    assert g.isStrokeOrNone(event.stroke)
    if event:
        assert event.stroke.s not in g.app.gui.ignoreChars, repr(event.stroke.s)
            # A continuous unit test, better than "@test k.isPlainKey".
</t>
<t tx="ekr.20180418105228.1">def getBindingHelper(self, key, name, stroke, w):
    """Find a binding for the widget with the given name."""
    c, k = self.c, self
    # trace = 'keys' in g.app.debug and 'verbose' in g.app.debug
    #
    # Return if the pane's name doesn't match the event's widget.
    state = k.unboundKeyAction
    w_name = c.widget_name(w)
    pane_matches = (
        name and w_name.startswith(name) or
        key in ('command', 'insert', 'overwrite') and state == key or
        key in ('text', 'all') and g.isTextWrapper(w) or
        key in ('button', 'all')
    )
    if not pane_matches:
        return None
    #
    # Return if there is no binding at all.
    d = k.masterBindingsDict.get(key, {})
    if not d:
        return None
    bi = d.get(stroke)
    if not bi:
        return None
    #
    # Ignore previous/next-line commands while editing headlines.
    if (
        key == 'text' and
        name == 'head' and
        bi.commandName in ('previous-line', 'next-line')
    ):
        return None
    #
    # The binding has been found.
    return bi
</t>
<t tx="ekr.20180418114300.1">def handleMinibufferHelper(self, event, pane, state, stroke):
    """
    Execute a pane binding in the minibuffer.
    Return 'continue', 'ignore', 'found'
    """
    c, k = self.c, self
    d = k.masterBindingsDict.get(pane)
    if not d:
        return 'continue'
    bi = d.get(stroke)
    if not bi:
        return 'continue'
    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
    # Ignore the replace-string command in the minibuffer.
    if bi.commandName == 'replace-string' and state == 'getArg':
        return 'ignore'
    # Execute this command.
    if bi.commandName not in k.singleLineCommandList:
        k.keyboardQuit()
    else:
        c.minibufferWantsFocus()
        c.doCommandByName(bi.commandName, event)
    # Careful: the command could exit.
    if c.exists and not k.silentMode:
        # Use the state *after* executing the command.
        if k.state.kind:
            c.minibufferWantsFocus()
        else:
            c.bodyWantsFocus()
    return 'found'
</t>
<t tx="ekr.20180419081404.1"># Keys whose names must never be inserted into text.
self.specialChars = [
    # These are *not* special keys.
        # 'BackSpace', 'Linefeed', 'Return', 'Tab',
    'Left', 'Right', 'Up', 'Down',
        # Arrow keys
    'Next', 'Prior',
        # Page up/down keys.
    'Home', 'End',
        # Home end keys.
    'Delete', 'Escape',
        # Others.
    'Enter', 'Insert', 'Ins',
        # These should only work if bound.
    'Menu',
        # #901.
    'PgUp', 'PgDn',
        # #868.
]
</t>
<t tx="ekr.20180419154543.1">def doAltTweaks(self, actual_ch, keynum, mods, toString):
    """Turn AltGr and some Alt-Ctrl keys into plain keys."""
    qt = QtCore.Qt

    def removeAltCtrl(mods):
        for mod in ('Alt', 'Control'):
            if mod in mods:
                mods.remove(mod)
        return mods

    #
    # Remove Alt, Ctrl for AltGr keys.
    # See https://en.wikipedia.org/wiki/AltGr_key

    if keynum == qt.Key_AltGr:
        return removeAltCtrl(mods)
    #
    # Never alter complex characters.
    if len(actual_ch) != 1:
        return mods
    #
    # #1563: A hack for German keyboards:
    #        Remove *plain* Shift modifier for colon and semicolon.
    #        https://en.m.wikipedia.org/wiki/German_keyboard_layout
    if (
        self.use_german_keyboard
        and actual_ch in ":;" and 'Shift' in mods
        and 'Alt' not in mods and 'Control' not in mods
    ):
        mods.remove('Shift')
        # g.trace('mods', mods, 'ch', repr(actual_ch))
    #
    # Handle Alt-Ctrl modifiers for chars whose that are not ascii.
    # Testing: Alt-Ctrl-E is ''.
    if ord(actual_ch) &gt; 127 and 'Alt' in mods and 'Control' in mods:
        return removeAltCtrl(mods)
    return mods
</t>
<t tx="ekr.20180419160958.1">def doMacTweaks(self, actual_ch, ch, mods):
    """Replace MacOS Alt characters."""
    if not g.isMac:
        return actual_ch, ch, mods
    if ch == 'Backspace':
        # On the Mac, the reported char can be DEL (7F)
        return '\b', ch, mods
    if len(mods) == 1 and mods[0] == 'Alt':
        # Patch provided by resi147.
        # See the thread: special characters in MacOSX, like '@'.
        mac_d = {
            '/': '\\',
            '5': '[',
            '6': ']',
            '7': '|',
            '8': '{',
            '9': '}',
            'e': '',
            'l': '@',
        }
        if ch.lower() in mac_d:
            # Ignore the case.
            actual_ch = ch = g.checkUnicode(mac_d.get(ch.lower()))
            mods = []
    return actual_ch, ch, mods
</t>
<t tx="ekr.20180502104829.1">def strip_shift(self, s):
    """
    Handle supposedly shifted keys.
    
    User settings might specify an already-shifted key, which is not an error.
        
    The legacy Tk binding names have already been translated,
    so we don't have to worry about Shift-ampersand, etc.
    """
    #
    # The second entry in each line handles shifting an already-shifted character.
    # That's ok in user settings: the Shift modifier is just removed.
    shift_d = {
        # Top row of keyboard.
        "`": "~", "~": "~",
        "1": "!", "!": "!",
        "2": "@", "@": "@",
        "3": "#", "#": "#",
        "4": "$", "$": "$",
        "5": "%", "%": "%",
        "6": "^", "^": "^",
        "7": "&amp;", "&amp;": "&amp;",
        "8": "*", "*": "*",
        "9": "(", "(": "(",
        "0": ")", ")": ")",
        "-": "_", "_": "_",
        "=": "+", "+": "+",
        # Second row of keyboard.
        "[": "{", "{": "{",
        "]": "}", "}": "}",
        "\\": '|', "|": "|",
        # Third row of keyboard.
        ";": ":", ":": ":",
        "'": '"', '"': '"',
        # Fourth row of keyboard.
        ".": "&lt;", "&lt;": "&lt;",
        ",": "&gt;", "&gt;": "&gt;",
        "//": "?", "?": "?",
    }
    if 'shift' in self.mods and s in shift_d:
        self.mods.remove('shift')
        s = shift_d.get(s)
    return s
</t>
<t tx="ekr.20180504191650.34"></t>
<t tx="ekr.20180504191650.36"></t>
<t tx="ekr.20180504191650.42"></t>
<t tx="ekr.20180504191650.68"></t>
<t tx="ekr.20180504192522.1"></t>
<t tx="ekr.20180507212821.1">def diff_two_revs(self, directory=None, rev1='HEAD', rev2=''):
    """
    Create an outline describing the git diffs for all files changed
    between rev1 and rev2.
    """
    c = self.c
    if not self.set_directory(directory):
        return
    # Get list of changed files.
    files = self.get_files(rev1, rev2)
    n = len(files)
    message = f"diffing {n} file{g.plural(n)}"
    if n &gt; 5:
        message += ". This may take awhile..."
    g.es_print(message)
    # Create the root node.
    self.root = c.lastTopLevel().insertAfter()
    self.root.h = f"git diff revs: {rev1} {rev2}"
    self.root.b = '@ignore\n@nosearch\n'
    # Create diffs of all files.
    for fn in files:
        self.diff_file(fn=fn, rev1=rev1, rev2=rev2)
    self.finish()
</t>
<t tx="ekr.20180511045458.1">def switchStyle(self, word):
    """
    Switch between camelCase and underscore_style function defintiions.
    Return None if there would be no change.
    """
    s = word
    if s.find('_') &gt; -1:
        if s.startswith('_'):
            # Don't return something that looks like a class.
            return None
        #
        # Convert to CamelCase
        s = s.lower()
        while s:
            i = s.find('_')
            if i == -1:
                break
            s = s[:i] + s[i + 1 :].capitalize()
        return s
    #
    # Convert to underscore_style.
    result = []
    for i, ch in enumerate(s):
        if i &gt; 0 and ch.isupper():
            result.append('_')
        result.append(ch.lower())
    s = ''.join(result)
    return None if s == word else s
</t>
<t tx="ekr.20180519111302.1">def get_jedi_completions(self, prefix):

    c = self.c
    w = c.frame.body.wrapper
    i = w.getInsertPoint()
    p = c.p
    body_s = p.b
    #
    # Get the entire source for jedi.
    t1 = time.process_time()
    goto = gotoCommands.GoToCommands(c)
    root, fileName = goto.find_root(p)
    if root:
        source = goto.get_external_file_with_sentinels(root=root or p)
        n0 = goto.find_node_start(p=p, s=source)
        if n0 is None: n0 = 0
    else:
        source = body_s
        n0 = 0
    t2 = time.process_time()
    #
    # Get local line
    lines = g.splitLines(body_s)
    row, column = g.convertPythonIndexToRowCol(body_s, i)
    if row &gt;= len(lines):  # 2020/11/27
        return []
    line = lines[row]
    #
    # Find the global line, and compute offsets.
    source_lines = g.splitLines(source)
    for jedi_line, g_line in enumerate(source_lines[n0:]):
        if line.lstrip() == g_line.lstrip():
            # Adjust the column.
            indent1 = len(line) - len(line.lstrip())
            indent2 = len(g_line) - len(g_line.lstrip())
            if indent2 &gt;= indent1:
                local_column = column  # For traces.
                column += abs(indent2 - indent1)
                break
    else:
        completions = None
        jedi_line, indent1, indent2 = None, None, None
        g.printObj(source_lines[n0 - 1 : n0 + 30])
        print(f"can not happen: not found: {line!r}")
    #
    # Get the jedi completions.
    if jedi_line is not None:
        import jedi
        try:
            script = jedi.Script(
                source=source,
                line=1 + n0 + jedi_line,
                column=column,
                path=g.shortFileName(fileName),
                # encoding='utf-8',
                # sys_path=None):
            )
            completions = script.completions()
            t3 = time.process_time()
        except ValueError:
            t3 = time.process_time()
            completions = None
            g.printObj(source_lines[n0 - 1 : n0 + 30])
            print('ERROR', p.h)
    if not completions:
        return []
    # May be used in traces below.
    assert t3 &gt;= t2 &gt;= t1
    assert local_column is not None
    completions = [z.name for z in completions]
    completions = [self.add_prefix(prefix, z) for z in completions]
    # Retain these for now...
        # g.printObj(completions[:5])
        # head = line[:local_column]
        # ch = line[local_column:local_column+1]
        # g.trace(len(completions), repr(ch), head.strip())
    return completions
</t>
<t tx="ekr.20180523170649.1">def starts_block(self, i, lines, new_state, prev_state):
    '''True if the new state starts a block.'''
    if new_state.level() &lt;= prev_state.level():
        return False
    line = lines[i].strip()
    for word in ('do', 'else', 'for', 'if', 'switch', 'try', 'while'):
        if line.startswith(word):
            return False
    # #1617: Chained calls look like functions, but aren't.
    for pattern in self.non_function_patterns:
         if pattern.match(line) is not None:
            return False
    for group_n, pattern in self.function_patterns:
        if pattern.match(line) is not None:
            return True
    return False
</t>
<t tx="ekr.20180523172655.1">kinds = r'(async|public|private|static)'
#
# The pattern table. Order matters!
function_patterns = (
    (1, re.compile(r'(interface\s+\w+)')),
        # interface name
    (1, re.compile(r'(class\s+\w+)')),
        # class name
    (1, re.compile(r'export\s+(class\s+\w+)')),
        # export class name
    (1, re.compile(r'export\s+enum\s+(\w+)')),
        # function name
    (1, re.compile(r'export\s+const\s+enum\s+(\w+)')),
        # function name
    (1, re.compile(r'export\s+function\s+(\w+)')),
        # function name
    (1, re.compile(r'export\s+interface\s+(\w+)')),
        # interface name
    (1, re.compile(r'function\s+(\w+)')),
        # function name
    (1, re.compile(r'(constructor).*{')),
        # constructor ... {
    (2, re.compile(r'%s\s*function\s+(\w+)' % kinds)),
        # kind function name
    (3, re.compile(r'%s\s+%s\s+function\s+(\w+)' % (kinds, kinds))),
        # kind kind function name
    #
    # Bare functions last...
    (3, re.compile(r'%s\s+%s\s+(\w+)\s*\(.*\).*{' % (kinds, kinds))),
        # kind kind name (...) {
    (2, re.compile(r'%s\s+(\w+)\s*\(.*\).*{' % kinds)),
        # name (...) {
    # #1619: Don't allow completely bare functions.
    # (1,  re.compile(r'(\w+)\s*\(.*\).*{')),
        # name (...) {
)
</t>
<t tx="ekr.20180524130023.1">file_pattern = re.compile(r'^(([@])+(auto|clean|edit|file|nosent))')
    # Note: this method is never called for @clean trees.

def add_class_names(self, p):
    '''
    Add class names to headlines for all descendant nodes.

    Called only when @bool add-context-to-headlines is True.
    '''
    if g.app.unitTesting:
        return # Don't changes the expected headlines.
    after, fn, class_name = None, None, None
    for p in p.self_and_subtree():
        # Part 1: update the status.
        m = self.file_pattern.match(p.h)
        if m:
            prefix = m.group(1)
            fn = g.shortFileName(p.h[len(prefix):].strip())
            after, class_name = None, None
            continue
        if p.h.startswith('@path '):
            after, fn, class_name = None, None, None
        elif p.h.startswith('class '):
            class_name = p.h[5:].strip()
            if class_name:
                after = p.nodeAfterTree()
                continue
        elif p == after:
            after, class_name = None, None
        # Part 2: update the headline.
        if class_name:
            if not p.h.startswith(class_name):
                p.h = '%s.%s' % (class_name, p.h)
        elif fn and self.add_file_context:
            tag = ' (%s)' % fn
            if not p.h.endswith(tag):
                p.h += tag
</t>
<t tx="ekr.20180524173510.1"></t>
<t tx="ekr.20180525110907.1">def run_code(the_code):
    '''Execute the compiled code. Return True if all went well.'''
    try:
        interp.runcode(the_code)
        return True
    except SyntaxError:
        interp.showsyntaxerror()
    except Exception:
        interp.showtraceback()
    return False
</t>
<t tx="ekr.20180526211127.1">def add_prefix(self, prefix, s):
    """A hack to match the callers expectations."""
    if prefix.find('.') &gt; -1:
        aList = prefix.split('.')
        prefix = '.'.join(aList[:-1]) + '.'
    return s if s.startswith(prefix) else prefix + s
</t>
<t tx="ekr.20180528160744.1">def loadOnePluginHelper(moduleName):
    result = None
    try:
        __import__(moduleName)
        # Look up through sys.modules, __import__ returns toplevel package
        result = sys.modules[moduleName]
    except g.UiTypeException:
        report(f"plugin {moduleName} does not support {g.app.gui.guiName()} gui")
    except ImportError:
        report(f"error importing plugin: {moduleName}")
    # except ModuleNotFoundError:
        # report('module not found: %s' % moduleName)
    except SyntaxError:
        report(f"syntax error importing plugin: {moduleName}")
    except Exception:
        report(f"exception importing plugin: {moduleName}")
        g.es_exception()
    return result
</t>
<t tx="ekr.20180528160855.1">def callInitFunction(result):
    """True to call the top-level init function."""
    try:
        # Indicate success only if init_result is True.
        init_result = result.init()
            # Careful: this may throw an exception.
        if init_result not in (True, False):
            report(f"{moduleName}.init() did not return a bool")
        if init_result:
            self.loadedModules[moduleName] = result
            self.loadedModulesFilesDict[moduleName] = (
                g.app.config.enabledPluginsFileName
            )
        else:
            report(f"{moduleName}.init() returned False")
            result = None
    except Exception:
        report(f"exception loading plugin: {moduleName}")
        g.es_exception()
        result = None
    return result
</t>
<t tx="ekr.20180528162300.1">def reportFailedImport():
    """Report a failed import."""
    if g.app.batchMode or g.app.inBridge or g.unitTesting:
        return
    if (
        self.warn_on_failure and
        tag == 'open0' and
        not g.app.gui.guiName().startswith('curses') and
        moduleName not in optional_modules
    ):
        report(f"can not load enabled plugin: {moduleName}")
</t>
<t tx="ekr.20180528162604.1">def finishImport(result):
    """Handle last-minute checks."""
    if tag == 'unit-test-load':
        return result  # Keep the result, but do no more.
    if hasattr(result, 'init'):
        return callInitFunction(result)
    #
    # No top-level init function.
    if g.app.unitTesting:
        # Do *not* load the module.
        self.loadedModules[moduleName] = None
        return None
    # Guess that the module was loaded correctly.
    report(f"fyi: no top-level init() function in {moduleName}")
    self.loadedModules[moduleName] = result
    return result
</t>
<t tx="ekr.20180602062323.7"># #1510: https://en.wikipedia.org/wiki/Valid_characters_in_XML.
translate_table = {z: None for z in range(20) if chr(z) not in '\t\r\n'}

def readWithElementTree(self, path, s):

    contents = g.toUnicode(s)
    contents = contents.translate(self.translate_table)
        # Fix #1036 and #1046.
    try:
        xroot = ElementTree.fromstring(contents)
    except Exception as e:
        # #970: Just report failure here.
        if path:
            message = f"bad .leo file: {g.shortFileName(path)}"
        else:
            message = 'The clipboard is not a vaild .leo file'
        g.es_print('\n' + message, color='red')
        g.es_print(g.toUnicode(e))
        print('')
        # #1510: Return a tuple.
        return None, None
    g_element = xroot.find('globals')
    v_elements = xroot.find('vnodes')
    t_elements = xroot.find('tnodes')
    gnx2body, gnx2ua = self.scanTnodes(t_elements)
    hidden_v = self.scanVnodes(gnx2body, self.gnx2vnode, gnx2ua, v_elements)
    self.handleBits()
    return hidden_v, g_element
</t>
<t tx="ekr.20180602062323.8">def scanTnodes(self, t_elements):

    gnx2body, gnx2ua = {}, defaultdict(dict)
    for e in t_elements:
        # First, find the gnx.
        gnx = e.attrib['tx']
        gnx2body[gnx] = e.text or ''
        # Next, scan for uA's for this gnx.
        for key, val in e.attrib.items():
            if key != 'tx':
                gnx2ua[gnx][key] = self.resolveUa(key, val)
    return gnx2body, gnx2ua
</t>
<t tx="ekr.20180602062323.9">def scanVnodes(self, gnx2body, gnx2vnode, gnx2ua, v_elements):

    c, fc = self.c, self.c.fileCommands
    &lt;&lt; define v_element_visitor &gt;&gt;
    #
    # Create the hidden root vnode.

    gnx = 'hidden-root-vnode-gnx'
    hidden_v = leoNodes.VNode(context=c, gnx=gnx)
    hidden_v._headString = '&lt;hidden root vnode&gt;'
    gnx2vnode[gnx] = hidden_v
    #
    # Traverse the tree of v elements.
    v_element_visitor(v_elements, hidden_v)
    return hidden_v
</t>
<t tx="ekr.20180602103135.16">if in_doc:
    # When delim_end exists the doc block:
    # - begins with the opening delim, alonw on its own line
    # - ends with the closing delim, alone on its own line.
    # Both of these lines should be skipped
    #
    # #1496: Retire the @doc convention.
    #        An empty line is no longer a sentinel.
    if delim_end and line in doc_skip:
        # doc_skip is (delim_start + '\n', delim_end + '\n')
        continue
    #
    # Check for @c or @code.
    m = code_pat.match(line)
    if m:
        in_doc = False
        body.append('@code\n' if m.group(1) else '@c\n')
        continue
else:
    m = doc_pat.match(line)
    if m:
        # @+at or @+doc?
        doc = '@doc' if m.group(1) == 'doc' else '@'
        doc2 = m.group(2) or ''  # Trailing text.
        if doc2:
            body.append(f"{doc}{doc2}\n")
        else:
            body.append(doc + '\n')
        # Enter @doc mode.
        in_doc = True
        continue
</t>
<t tx="ekr.20180602103135.18">m = ref_pat.match(line)
if m:
    in_doc = False
    if m.group(2) == '+':
        # open sentinel.
        body.append(m.group(1) + g.angleBrackets(m.group(3)) + '\n')
        stack.append((gnx, indent, body))
        indent += m.end(1)
        continue
    if stack:
        # #1232: Only if the stack exists.
        # close sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
        continue
</t>
<t tx="ekr.20180604110143.1">def readFile(self, theFile, path):
    """Read the file, change splitter ratiors, and return its hidden vnode."""
    s = theFile.read()
    v, g_element = self.readWithElementTree(path, s)
    if not v:  # #1510.
        return None
    self.scanGlobals(g_element)
        # Fix #1047: only this method changes splitter sizes.
    #
    # Fix bug #1111: ensure that all outlines have at least one node.
    if not v.children:
        new_vnode = leoNodes.VNode(context=self.c)
        new_vnode.h = 'newHeadline'
        v.children = [new_vnode]
    return v

def readFileFromClipboard(self, s):
    """
    Recreate a file from a string s, and return its hidden vnode.
    
    Unlike readFile above, this does not affect splitter sizes.
    """
    v, g_element = self.readWithElementTree(path=None, s=s)
    if not v:  # #1510.
        return None
    #
    # Fix bug #1111: ensure that all outlines have at least one node.
    if not v.children:
        new_vnode = leoNodes.VNode(context=self.c)
        new_vnode.h = 'newHeadline'
        v.children = [new_vnode]
    return v
</t>
<t tx="ekr.20180605062300.1">def scanGlobals(self, g_element):
    """Get global data from the cache, with reasonable defaults."""
    c = self.c
    d = self.getGlobalData()
    windowSize = g.app.loadManager.options.get('windowSize')
    windowSpot = g.app.loadManager.options.get('windowSpot')
    if windowSize is not None:
        h, w = windowSize  # checked in LM.scanOption.
    else:
        w, h = d.get('width'), d.get('height')
    if windowSpot is None:
        x, y = d.get('left'), d.get('top')
    else:
        y, x = windowSpot  # #1263: (top, left)
    if 'size' in g.app.debug:
        g.trace(w, h, x, y, c.shortFileName())
    # c.frame may be a NullFrame.
    c.frame.setTopGeometry(w, h, x, y)
    r1, r2 = d.get('r1'), d.get('r2')
    c.frame.resizePanesToRatio(r1, r2)
    frameFactory = getattr(g.app.gui, 'frameFactory', None)
    if not frameFactory:
        return
    assert frameFactory is not None
    mf = frameFactory.masterFrame
    if g.app.start_minimized:
        mf.showMinimized()
    elif g.app.start_maximized:
        # #1189: fast.scanGlobals calls showMaximized later.
        mf.showMaximized()
    elif g.app.start_fullscreen:
        mf.showFullScreen()
    else:
        mf.show()
</t>
<t tx="ekr.20180605075042.1">v = leoNodes.VNode(context=c, gnx=gnx)
gnx2vnode[gnx] = v
parent_v.children.append(v)
v.parents.append(parent_v)
body = g.toUnicode(gnx2body.get(gnx) or '')
assert g.isUnicode(body), body.__class__.__name__
v._bodyString = body
v._headString = 'PLACE HOLDER'
</t>
<t tx="ekr.20180605075113.1"># Like fc.handleVnodeSaxAttrutes.
#
# The native attributes of &lt;v&gt; elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnode/VnodeUnknownAttributes.
d = e.attrib
s = d.get('tnodeList', '')
tnodeList = s and s.split(',')
if tnodeList:
    # This tnodeList will be resolved later.
    v.tempTnodeList = tnodeList
s = d.get('descendentTnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentTnodeUaDictList.append(aDict)
s = d.get('descendentVnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentVnodeUaDictList.append((v, aDict),)
#
# Handle vnode uA's
uaDict = gnx2ua[gnx]
    # gnx2ua is a defaultdict(dict)
    # It might already exists because of tnode uA's.
for key, val in d.items():
    if key not in self.nativeVnodeAttributes:
        uaDict[key] = self.resolveUa(key, val)
if uaDict:
    v.unknownAttributes = uaDict
</t>
<t tx="ekr.20180605102822.1">def v_element_visitor(parent_e, parent_v):
    """Visit the given element, creating or updating the parent vnode."""
    for e in parent_e:
        assert e.tag in ('v', 'vh'), e.tag
        if e.tag == 'vh':
            parent_v._headString = g.toUnicode(e.text or '')
            continue
        # #1581: Attempt to handle old Leo outlines.
        try:
            gnx = e.attrib['t']
            v = gnx2vnode.get(gnx)
        except KeyError:
            # g.trace('no "t" attrib')
            gnx = None
            v = None
        if v:
            # A clone
            parent_v.children.append(v)
            v.parents.append(parent_v)
            # The body overrides any previous body text.
            body = g.toUnicode(gnx2body.get(gnx) or '')
            assert g.isUnicode(body), body.__class__.__name__
            v._bodyString = body
        else:
            &lt;&lt; Make a new vnode, linked to the parent &gt;&gt;
            &lt;&lt; handle all other v attributes &gt;&gt;
            # Handle all inner elements.
            v_element_visitor(e, v)

</t>
<t tx="ekr.20180606035619.1"></t>
<t tx="ekr.20180606041211.1">def resolveUa(self, attr, val, kind=None):  # Kind is for unit testing.
    """Parse an unknown attribute in a &lt;v&gt; or &lt;t&gt; element."""
    try:
        val = g.toEncodedString(val)
    except Exception:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()
        return None
    # Leave string attributes starting with 'str_' alone.
    if attr.startswith('str_'):
        if isinstance(val, (str, bytes)):
            return g.toUnicode(val)
    try:
        binString = binascii.unhexlify(val)
            # Throws a TypeError if val is not a hex string.
    except Exception:
        # Assume that Leo 4.1 or above wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw', f"unit test failed: kind={kind}"
        else:
            g.trace(f"can not unhexlify {attr}={val}")
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        return val2
    except Exception:
        try:
            val2 = pickle.loads(binString, encoding='bytes')
            val2 = self.bytesToUnicode(val2)
            return val2
        except Exception:
            g.trace(f"can not unpickle {attr}={val}")
            return val
</t>
<t tx="ekr.20180606044154.1">def bytesToUnicode(self, ob):
    """
    Recursively convert bytes objects in strings / lists / dicts to str
    objects, thanks to TNT
    http://stackoverflow.com/questions/22840092
    Needed for reading Python 2.7 pickles in Python 3.4.
    """
    # This is simpler than using isinstance.
    # pylint: disable=unidiomatic-typecheck
    t = type(ob)
    if t in (list, tuple):
        l = [str(i, 'utf-8') if type(i) is bytes else i for i in ob]
        l = [self.bytesToUnicode(i)
                if type(i) in (list, tuple, dict) else i
                    for i in l]
        ro = tuple(l) if t is tuple else l
    elif t is dict:
        byte_keys = [i for i in ob if type(i) is bytes]
        for bk in byte_keys:
            v = ob[bk]
            del(ob[bk])
            ob[str(bk, 'utf-8')] = v
        for k in ob:
            if type(ob[k]) is bytes:
                ob[k] = str(ob[k], 'utf-8')
            elif type(ob[k]) in (list, tuple, dict):
                ob[k] = self.bytesToUnicode(ob[k])
        ro = ob
    elif t is bytes:  # TNB added this clause
        ro = str(ob, 'utf-8')
    else:
        ro = ob
    return ro
</t>
<t tx="ekr.20180606054325.1">if in_doc:
    if delim_end:
        # doc lines are unchanged.
        body.append(line)
        continue
    # Doc lines start with start_delim + one blank.
    # #1496: Retire the @doc convention:
    tail = line[len(delim_start) + 1 :]
    if tail.strip():
        body.append(tail)
    else:
        body.append('\n')
    continue
</t>
<t tx="ekr.20180624125321.1">def handleBits(self):
    """Restore the expanded and marked bits from c.db."""
    c, fc = self.c, self.c.fileCommands
    expanded = c.db.get('expanded')
    marked = c.db.get('marked')
    expanded = expanded.split(',') if expanded else []
    marked = marked.split(',') if marked else []
    fc.descendentExpandedList = expanded
    fc.descendentMarksList = marked
</t>
<t tx="ekr.20180708060437.1">def getGlobalData(self):
    """Return a dict containing all global data."""
    c = self.c
    try:
        window_pos = c.db.get('window_position')
        r1 = float(c.db.get('body_outline_ratio', '0.5'))
        r2 = float(c.db.get('body_secondary_ratio', '0.5'))
        top, left, height, width = window_pos
        return {
            'top': int(top),
            'left': int(left),
            'height': int(height),
            'width': int(width),
            'r1': r1,
            'r2': r2,
        }
    except Exception:
        pass
    # Use reasonable defaults.
    return {
        'top': 50, 'left': 50,
        'height': 500, 'width': 800,
        'r1': 0.5, 'r2': 0.5,
    }
</t>
<t tx="ekr.20180708145905.1">@language rest
@wrap

This is the theory of operation document for py2cs.py. The most interesting aspect of this script is the TokenSync class. This class provides a reliable way of associating tokenizer tokens with ast nodes.

@others
</t>
<t tx="ekr.20180708145905.6">
### Using the TokenSync class

The present code is driven by ast trees, but each visitor of the CoffeeScriptTraverser class takes care to preserve **otherwise-ignored tokens**. These are tokens that would otherwise be ignored: namely blank lines and comments, both entire-line comments and trailing comments.

The visitor for each statement intersperses otherwise ignored tokens using calls to the TokenSync class.  The simplest cases are like this:

    def do_Break(self, node):
        head = self.leading_string(node)
        tail = self.trailing_comment(node)
        return head + self.indent('break') + tail

The leading_string and trailing_comment methods simply redirect to the corresponding methods in the TokenSync class.  Saves a bit of typing. Compound statements are a bit more bother, but not overly so. For example:

    def do_If(self, node):

        result = self.leading_lines(node)
        tail = self.trailing_comment(node)
        s = 'if %s:%s' % (self.visit(node.test), tail)
        result.append(self.indent(s))
        for z in node.body:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
        if node.orelse:
            tail = self.tail_after_body(node.body, node.orelse, result)
            result.append(self.indent('else:' + tail))
            for z in node.orelse:
                self.level += 1
                result.append(self.visit(z))
                self.level -= 1
        return ''.join(result)

The line:

        tail = self.tail_after_body(node.body, node.orelse, result)

is a hack needed to compensate for the lack of an actual ast.Else node.
</t>
<t tx="ekr.20180708145905.7">
### Summary

The TokenSync class is, a new, elegant, unexpected and happy development. It is a relatively easy-to-use helper that allows parser-based code to preserve data that is not easily accessible in parse trees.

The TokenSync class avoids [problems with the col_offset field](
http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) in ast nodes. The TokenSync class depends only on the ast.lineno field and the tokenize module. We can expect it to be rock solid.

Edward K. Ream
February 20 to 25, 2016



</t>
<t tx="ekr.20180708152000.1">
### The problem

The initial version of py2cs.py (the script) used only tokens. This solved all token-related problems, but made parsing difficult. Alas, it is [difficult](http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) to associate tokens with ast nodes.

The script needs the following token-related data:

- The **ignored lines** (comment lines and blank lines) that precede any statement.

- The **trailing comment** strings that might follow any line.

- Optionally, the **line breaks** occurring within lines. At present, this script does not preserve such breaks, and it's probably not worth doing. Indeed, automatically breaking long lines seems more useful, especially considering that coffeescript lines may be substantially shorter than the corresponding python lines.

- The **exact spelling** of all strings.

The [ast_utils module](
https://bitbucket.org/plas/thonny/src/3b71fda7ac0b66d5c475f7a668ffbdc7ae48c2b5/thonny/ast_utils.py?at=master) purports to solve this problem with convoluted adjustments to the col_offset field. This approach is subject to subtle Python bugs, and subtle differences between Python 2 and Python 3. There is a better way...
</t>
<t tx="ekr.20180708152018.1">
### Design

The main idea is to use *only* the ast.lineno fields and the tokenizer module to recreate token data. The design assumes only that both the ast.lineno field and Python's tokenizer module are solid. This is a much more reasonable assumption than assuming that the col_offset field always tells the truth. In short, this design *ignores* the ast.col_offset field.

At startup, the TokenSync ctor assigns all the incoming tokens to various lists.  These lists are indexed by lineno:

    ts.line_tokens[i]: all the tokens on line i
    ts.string_tokens[i]: all string tokens on line i
    st.ignored_lines: the blank or comment line on line i

It is very easy to create these lists. The code does not depend on any arcane details.

#### Recovering the exact spelling of stings.

ts.synch_string returns the *next* string on the line. Here it is, stripped of defensive code:

    def sync_string(self, node):
        '''Return the spelling of the string at the given node.'''
        tokens = self.string_tokens[node.lineno-1]
        token = tokens.pop(0)
        self.string_tokens[node.lineno-1] = tokens
        return self.token_val(token)

Stripped of defensive code, the do_Str visitor is just:

    def do_Str(self, node):
        '''A string constant, including docstrings.'''
        return self.sync_string(node)

#### Recovering otherwise ignored nodes

**ts.leading_lines(node)** returns a list of otherwise ignored lines that
precede the node's line that have not already been returned.
**ts.leading_string(node)** is a convenience method that returns ''.join(ts.leading_lines(node)). The visitors of the CoffeeScriptTraverser class show how to use these methods.
</t>
<t tx="ekr.20180806045802.1">def doSmartQuote(self, action, ch, oldSel, w):
    """Convert a straight quote to a curly quote, depending on context."""
    i, j = oldSel
    if i &gt; j:
        i, j = j, i
    # Use raw insert/delete to retain the coloring.
    if i != j:
        w.delete(i, j)
    elif action == 'overwrite':
        w.delete(i)
    ins = w.getInsertPoint()
    # Pick the correct curly quote.
    s = w.getAllText() or ""
    i2 = g.skip_to_start_of_line(s, max(0, ins - 1))
    open_curly = ins == i2 or ins &gt; i2 and s[ins - 1] in ' \t'
        # not s[ins-1].isalnum()
    if open_curly:
        ch = '' if ch == "'" else ""
    else:
        ch = '' if ch == "'" else ""
    w.insert(ins, ch)
    w.setInsertPoint(ins + 1)
</t>
<t tx="ekr.20180810052056.2">def yieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    yield p
    while p:
        if p == target_p:
            return
        v = p.v
        if (v.children and (
            # Use slower test for clones:
            len(v.parents) &gt; 1 and p in v.expandedPositions or
            # Use a quick test for non-clones:
            len(v.parents) &lt;= 1 and (v.statusBits &amp; v.expandedBit) != 0
        )):
            # p.moveToFirstChild()
            p.stack.append((v, p._childIndex),)
            p.v = v.children[0]
            p._childIndex = 0
            yield p
            continue
        # if p.hasNext():
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        if p._childIndex + 1 &lt; len(parent_v.children):
            # p.moveToNext()
            p._childIndex += 1
            p.v = parent_v.children[p._childIndex]
            yield p
            continue
        #
        # A fast version of p.moveToThreadNext().
        # We look for a parent with a following sibling.
        while p.stack:
            # p.moveToParent()
            p.v, p._childIndex = p.stack.pop()
            # if p.hasNext():
            parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
            if p._childIndex + 1 &lt; len(parent_v.children):
                # p.moveToNext()
                p._childIndex += 1
                p.v = parent_v.children[p._childIndex]
                break  # Found: moveToThreadNext()
        else:
            break  # Not found.
        # Found moveToThreadNext()
        yield p
        continue
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
</t>
<t tx="ekr.20180816105258.1">import leo.commands.editFileCommands as efc

efc.GitDiffController(c).diff_two_branches(
    branch1='bc24e607a5', # '6bd282f', # 'bc24e607a5', # old branch/rev
    branch2='devel', # new branch/rev
    fn='leo/plugins/nested_splitter.py',
    directory=None,
)
</t>
<t tx="ekr.20180822134952.1">def update_notes(self):
    
    # #940: update self.notes. Ensure note n still exists.
    visible = []
    for (gnx, n) in self.notes.items():
        try:
            if n.isVisible():
                visible.append(gnx)
        except RuntimeError:
            pass
    self.notes = dict (
        (gnx, n) for (gnx, n) in self.notes.items()
            if gnx in visible
    )
</t>
<t tx="ekr.20180824065751.1">print(p.gnx)</t>
<t tx="ekr.20181009072707.1"># -*- coding: utf-8 -*-
import os
import sys
import unittest
from leo.core import leoBridge

load_dir = os.path.abspath(os.path.dirname(__file__))
test_dir = os.path.join(load_dir, 'leo', 'test')
path = os.path.join(test_dir, 'unitTest.leo')
assert os.path.exists(path), repr(path)
controller = leoBridge.controller(gui='nullGui',
    loadPlugins=False, readSettings=True,
    silent=False, verbose=False)
g = controller.globals()
c = controller.openLeoFile(path)
try:
    # Run all unit tests locally.
    root = g.findTopLevelNode(c, 'Active Unit Tests', exact=True)
    assert root, 'Not found: Active Unit Tests'
    c.selectPosition(root)
    tm = c.testManager
    g.unitTesting = g.app.unitTesting = True
    suite = unittest.makeSuite(unittest.TestCase)
    aList = tm.findAllUnitTestNodes(all=False, marked=False)
    setup_script = None
    found = False
    for p in aList:
        if tm.isTestSetupNode(p):
            setup_script = p.b
            test = None
        elif tm.isTestNode(p):
            test = tm.makeTestCase(p, setup_script)
        elif tm.isSuiteNode(p):
            test = tm.makeTestSuite(p, setup_script)
        elif tm.isTestClassNode(p):
            test = tm.makeTestClass(p)
        else:
            test = None
        if test:
            suite.addTest(test)
            found = True
    if not found:
        print('No unit tests')
        sys.exit(1)
    runner = unittest.TextTestRunner(failfast=True, verbosity=1)
    try:
        result = runner.run(suite)
        if result.errors or result.failures:
            print(f"errors: {len(result.errors)}, failures: {len(result.failures)}")
            sys.exit(1)
        else:
            print('Travis unit tests all passed.')
            sys.exit(0)
    except Exception:
        print('Unexpected exception')
        g.es_exception()
        sys.exit(1)
except Exception as e:
    print('Unexpected exception 2', e)
    sys.exit(1)
</t>
<t tx="ekr.20181013081645.1">@path test</t>
<t tx="ekr.20181027133311.1">def issueSecurityWarning(setting):
    g.es('Security warning! Ignoring...', color='red')
    g.es(setting, color='red')
    g.es('This setting can be set only in')
    g.es('leoSettings.leo or myLeoSettings.leo')
</t>
<t tx="ekr.20181027151243.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1006

@language python
</t>
<t tx="ekr.20181030041436.1"></t>
<t tx="ekr.20181102040815.1">files = [
    'test/unittest.leo',
]
for fn in files:
    path = g.os_path_finalize_join(g.app.loadDir, '..', fn)
    assert g.os_path_exists(path), repr(path)
    with open(path, 'r') as f:
        s = f.read()
        for line in g.splitLines(s):
            if len(line) &gt; 150:
                print(line)</t>
<t tx="ekr.20181113042549.1">@flx.action
def redraw (self, p):
    '''
    Send a **redraw list** to the tree.
    
    This is a recusive list lists of items (ap, gnx, headline) describing
    all and *only* the presently visible nodes in the tree.
    
    As a side effect, app.make_redraw_dict updates all internal dicts.
    '''
    trace = 'drawing' in g.app.debug
    tag = 'py.app.redraw'
    c = self.c
    p = p or c.p
    # #1142.
    c.selectPosition(p)
    redrawer = self.fast_redrawer
    w = self.main_window
    #
    # Be careful: c.frame.redraw can be called before app.finish_create.
    if not w or not w.tree:
        if trace: print(tag, 'no w.tree')
        return
    #
    # Profile times when all nodes are expanded.
        # self.test_full_outline(p)
    #
    # Redraw only the visible nodes.
    t1 = time.process_time()
    ap = self.p_to_ap(p)
    w.tree.select_ap(ap)
    redraw_dict = self.make_redraw_dict(p)
        # Needed to compare generations, even if there are no changes.
    new_flattened_outline = redrawer.flatten_outline(c)
    redraw_instructions = redrawer.make_redraw_list(
        self.old_flattened_outline,
        new_flattened_outline,
    )
    w.tree.redraw_with_dict(redraw_dict, redraw_instructions)
        # At present, this does a full redraw using redraw_dict.
        # The redraw instructions are not used.
    #
    # Do not call c.setChanged() here.
    if trace: print('app.redraw: %5.3f sec.' % (time.process_time()-t1))
    #
    # Move to the next redraw generation.
    self.old_flattened_outline = new_flattened_outline
    self.old_redraw_dict = redraw_dict
    self.redraw_generation += 1
</t>
<t tx="ekr.20181113043004.1">@flx.action
def redraw_with_dict(self, redraw_dict, redraw_instructions):
    '''
    Clear the present tree and redraw using the **recursive** redraw_list.
    d has the form:
        {
            'c.p': self.p_to_ap(p),
            'items': [
                self.make_dict_for_position(p)
                    for p in c.rootPosition().self_and_siblings()
            ],
        }
    '''
    # This is called only from app.action.redraw.
    trace = 'drawing' in g.app.debug
    tag = 'redraw_with_dict'
    assert redraw_dict
    self.clear_tree()
    items = redraw_dict ['items']
    if trace:
        print('')
        print('%s: %s direct children' % (tag, len(items)))
    for item in items:
        tree_item = self.create_item_with_parent(item, self.tree)
        if trace: print('  %r %s' % (tree_item, item['headline']))
    #
    # Select c.p.
    self.select_ap(redraw_dict['c.p'])
    redraw_dict = {}
        # #1127: Remove references to deleted items.
</t>
<t tx="ekr.20181115120317.1"># Leo's core doesn't define a NullMinibuffer class.

class LeoBrowserMinibuffer (leoFrame.StringTextWrapper):
    '''Browser wrapper for minibuffer.'''

    def __init__(self, c, frame):
        super().__init__(c, name='minibuffer')
            # Name must be minibuffer, for gui.isTextWrapper().
        assert self.c == c, repr(self.c)
        # assert c.frame == frame, (repr(c.frame), repr(frame))
            # c.frame is a NullFrame.  frame is a LeoBrowserFrame.
        assert self.widget is None, repr(self.widget)
        assert self.getName() == 'minibuffer'
        self.frame = frame
        self.root = get_root()
        self.tag = 'py.mini.wrap'
        self.widget = self
        self.wrapper = self
        # Hook this class up to the key handler.
        c.k.w = self
        c.miniBufferWidget = self # #1146.
        frame.minibufferWidget = self

    # Overrides.
    def setFocus(self):
        self.root.main_window.minibuffer.set_focus()

    @others
</t>
<t tx="ekr.20181118061020.1">@flx.action
def select_p(self, p):
    '''
    Select the position in the tree.
    
    Called from LeoBrowserTree.select, so do *not* call c.frame.tree.select.
    '''
    c = self.c
    w = self.main_window
    ap = self.p_to_ap(p)
    # Be careful during startup.
    if not (w and w.tree):
        return
    if 'select' in g.app.debug:
        tag = 'py.app.select_p'
        print('%30s: %4s %s %s' % (tag, len(p.b), p.gnx, p.h))
    w.tree.set_ap(ap)
    # #1142: This code was not the problem.
    body = c.frame.body.wrapper
    w.body.set_text(body.s)
    w.body.set_insert_point(body.ins, body.sel)
</t>
<t tx="ekr.20181124133513.1">@flx.action
def finish_create(self):
    '''
    Initialize all ivars and widgets.
    
    Called after all flx.Widgets have been fully inited!
    '''
    w = self.main_window
    self.c = c = g.app.log.c
    assert c
    # Init all redraw ivars
    self.create_gnx_to_vnode()
    self.old_flattened_outline = []
    self.old_redraw_dict = {}
    self.redraw_generation = 0
    self.fast_redrawer = leoFastRedraw.FastRedraw()
    self.old_flattened_outline = self.fast_redrawer.flatten_outline(c)
    self.old_redraw_dict = self.make_redraw_dict(c.p)
    # Select the proper position.
    c.selectPosition(c.p or c.rootPosition())
    c.contractAllHeadlines()
        # #1127: This calls c.redraw. Do *not* call it again below.
    #
    # Monkey-patch the FindTabManager
    c.findCommands.minibuffer_mode = True
    c.findCommands.ftm = g.NullObject()
    #
    # Monkey-patch c.request_focus
    self.old_request_focus = c.request_focus
    c.request_focus = self.request_focus
    #
    # #1143: monkey-patch Leo's save commands.
    self.old_save_file = c.fileCommands.save
    c.fileCommands.save = self.save_file
    self.old_save_file_as = c.fileCommands.saveAs
    c.fileCommands.saveAs = self.save_file_as
    self.old_save_file_to = c.fileCommands.saveTo
    c.fileCommands.saveTo = self.save_file_to
    #
    # Init the log, body, status line and tree.
    g.app.gui.writeWaitingLog2()
    self.set_body_text()
    self.set_status()
    #
    # Init the focus. It's debatable...
    if 0:
        self.gui.set_focus(c, c.frame.tree)
        w.tree.set_focus()
    else: # This definitely shows focus in the editor.
        self.gui.set_focus(c, c.frame.body)
        w.body.set_focus()
    # Set the inited flag *last*.
    self.inited = True
</t>
<t tx="ekr.20181124194248.1">def create_item_with_parent(self, item, parent):
    '''Create a tree item for item and all its visible children.'''
    # pylint: disable=no-member
        # set_collapsed is in the base class.
    trace = 'drawing' in g.app.debug
    tag = 'create_item_with_parent'
    ap = item ['ap']
    #
    # Create the node.
    with parent:
        tree_item = LeoFlexxTreeItem(ap, text=ap['headline'], checked=None, collapsed=True)
    tree_item.set_collapsed(not ap['expanded'])
    #
    # Set the data.
    key = self.ap_to_key(ap)
    self.tree_items_dict [key] = tree_item
    #
    # Children are *not* necessarily sent, so set the populated 'bit' only if they are.
    if item['children']:
        if trace: print(tag, '**populated**', ap['headline'])
        self.populated_items_dict[key] = True
    if hasattr(parent, 'leo_children'):
        # print(tag, parent.leo_ap['headline'], ap['headline'])
        parent.leo_children.append(tree_item)
    #
    # Create the children.
    for child in item ['children']:
        self.create_item_with_parent(child, tree_item)
    return tree_item # Debugging
</t>
<t tx="ekr.20181208062449.1"># Override the methods called by k.minibuffer:
    
last_ins = None
last_sel = None
last_s = None
    
def update(self, tag):
    w = self.root.main_window
    i, j = self.sel
    # Do nothing if there will be no changes.
    if self.s == self.last_s and self.last_ins == self.ins and self.sel == self.last_sel:
        return
    # Remember the present values.
    self.last_ins, self.last_s, self.last_sel = self.ins, self.s, self.sel
    if 'select' in g.app.debug:
        tag = 'py.mini.update'
        print('%30s: sel: %3s %3s ins: %3s len(s): %s' % (
            tag, i, j, self.ins, len(self.s)))
    w.minibuffer.set_text(self.s)
    w.minibuffer.set_selection(i, j)
    w.minibuffer.set_insert(self.ins)
        
def delete(self, i, j=None):
    super().delete(i,j)
    self.update('delete')
    
def getAllText(self):
    return self.s

def insert(self, i, s):
    super().insert(i, s)
    self.update('insert')

def setAllText(self, s):
    super().setAllText(s)
    self.update('setAllText')

def setSelectionRange(self, i, j, insert=None):
    super().setSelectionRange(i, j, insert)
    self.update('setSelectionRange')
        
def setStyleClass(self, name):
    w = self.root.main_window
    if not w:
        g.trace('NO MAIN WINDOW')
        return
    # if 'focus' in g.app.debug:
        # tag = 'py.mini.setStyleClass'
        # print('%30s: %r' % (tag, name))
    w.minibuffer.set_style(name)
    self.update('setStyleClass:%r' % name)
</t>
<t tx="ekr.20190108105509.1">def writePathChanged(self, p):
    '''
    raise IOError if p's path has changed *and* user forbids the write.
    '''
    at, c = self, self.c
    #
    # Suppress this message during save-as and save-to commands.
    if c.ignoreChangedPaths:
        return
    oldPath = g.os_path_normcase(at.getPathUa(p))
    newPath = g.os_path_normcase(g.fullPath(c, p))
    try:  # #1367: samefile can throw an exception.
        changed = oldPath and not os.path.samefile(oldPath, newPath)
    except Exception:
        changed = True
    if not changed:
        return
    ok = at.promptForDangerousWrite(
        fileName=None,
        message=(
            f"{g.tr('path changed for %s' % (p.h))}\n"
            f"{g.tr('write this file anyway?')}"
        ),
    )
    if not ok:
        raise IOError
    at.setPathUa(p, newPath)  # Remember that we have changed paths.
</t>
<t tx="ekr.20190108112519.1">def reportEndOfWrite(self, files, all, dirty):

    if g.unitTesting:
        return
    if files:
        g.es('finished')
    elif all:
        g.warning("no @&lt;file&gt; nodes in the selected tree")
    elif dirty:
        g.es("no dirty @&lt;file&gt; nodes in the selected tree")
</t>
<t tx="ekr.20190109142026.1">def atFileToString(self, root, sentinels=True):
    """Write an external file to a string, and return its contents."""
    at, c = self, self.c
    try:
        c.endEditing()
        at.initWriteIvars(root, "&lt;string-file&gt;", sentinels=sentinels)
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        assert root == at.root, 'write'
        result = at.closeOutputStream()
        # Major bug: failure to clear this wipes out headlines!
        #            Sometimes this causes slight problems...
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
            root.v._p_changed = True
        return result
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.exception("exception preprocessing script")
        root.v._p_changed = True
        return ''
</t>
<t tx="ekr.20190109160056.2">def atAutoToString(self, root):
    """Write the root @auto node to a string, and return it."""
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(root, root.atAutoNodeName(), sentinels=False)
        # #1450.
        if not fileName:
            at.addToOrphanList(root)
            return ''
        return at.writeAtAutoContents(fileName, root) or ''
    except Exception:
        at.writeException(fileName, root)
        return ''
</t>
<t tx="ekr.20190109160056.3">def atEditToString(self, root):
    """Write one @edit node."""
    at, c = self, self.c
    try:
        c.endEditing()
        if root.hasChildren():
            g.error('@edit nodes must not have children')
            g.es('To save your work, convert @edit to @auto, @file or @clean')
            return False
        fileName = at.initWriteIvars(
            root, root.atEditNodeName(), atEdit=True, sentinels=False)
        # #1450.
        if not fileName:
            at.addToOrphanList(root)
            return ''
        contents = ''.join([
            s for s in g.splitLines(root.b)
                if at.directiveKind4(s, 0) == at.noDirective])
        return contents
    except Exception:
        at.writeException(fileName, root)
        return ''
</t>
<t tx="ekr.20190109163934.24">def writeAtAutoNodesHelper(self, writeDirtyOnly=True):
    """Write @auto nodes in the selected outline"""
    at = self; c = at.c
    p = c.p; after = p.nodeAfterTree()
    found = False
    while p and p != after:
        if (
            p.isAtAutoNode() and not p.isAtIgnoreNode() and
            (p.isDirty() or not writeDirtyOnly)
        ):
            ok = at.writeOneAtAutoNode(p)
            if ok:
                found = True
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()
    if not g.unitTesting:
        if found:
            g.es("finished")
        elif writeDirtyOnly:
            g.es("no dirty @auto nodes in the selected tree")
        else:
            g.es("no @auto nodes in the selected tree")
</t>
<t tx="ekr.20190111045822.1">def precheck(self, fileName, root):
    """
    Check whether a dirty, potentially dangerous, file should be written.
    
    Return True if so.  Return False *and* issue a warning otherwise.
    """
    at = self
    #
    # #1450: First, check that the directory exists.
    theDir = g.os_path_dirname(fileName)
    if theDir and not g.os_path_exists(theDir):
        at.error(f"Directory not found:\n{theDir}")
        return False
    #
    # Now check the file.
    if not at.shouldPromptForDangerousWrite(fileName, root):
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    #
    # Prompt if the write would overwrite the existing file.
    ok = self.promptForDangerousWrite(fileName)
    if ok:
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    #
    # Fix #1031: do not add @ignore here!
    g.es("not written:", fileName)
    return False
</t>
<t tx="ekr.20190118082047.1">def put_status_line(self, col, fcol, row, words):

    if 1:
        fcol_part = '' if fcol is None else f" fcol: {fcol}"
        # For now, it seems to0 difficult to get alignment *exactly* right.
        self.put1(f"line: {row:d} col: {col:d} {fcol_part} words: {words}")
    else:
        # #283 is not ready yet, and probably will never be.
        fline = self.file_line()
        fline = '' if fline is None else fline + row
        self.put1(
            f"fline: {fline:2} line: {row:2d} col: {col:2} fcol: {fcol:2}")
</t>
<t tx="ekr.20190118082646.1">def compute_columns(self, block, cursor):

    c = self.c
    line = block.text()
    col = cursor.columnNumber()
    offset = c.p.textOffset()
    fcol_offset = 0
    s2 = line[0:col]
    col = g.computeWidth(s2, c.tab_width)
    #
    # #195: fcol when using @first directive is inaccurate
    i = line.find('&lt;&lt;')
    j = line.find('&gt;&gt;')
    if -1 &lt; i &lt; j or g.match_word(line.strip(), 0, '@others'):
        offset = None
    else:
        for tag in ('@first ', '@last '):
            if line.startswith(tag):
                fcol_offset = len(tag)
                break
    #
    # fcol is '' if there is no ancestor @&lt;file&gt; node.
    fcol = None if offset is None else max(0, col + offset - fcol_offset)
    return col, fcol
</t>
<t tx="ekr.20190122185223.1">@language text

Find all kwargs using regex:

^\s*(def\s+\w+\s*\(.*\=.*\))

found 1154 nodes

^\s*(def\s+\w+\s*\(.*\=.*\=.*\))

found 284 nodes
</t>
<t tx="ekr.20190201104956.1">def readOneAtAsisNode(self, fn, p):
    '''Read one @asis node. Used only by refresh-from-disk'''
    at, c = self, self.c
    # #1521 &amp; #1341.
    fn = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fn)
    junk, ext = g.os_path_splitext(fn)
    # Remember the full fileName.
    at.rememberReadPath(fn, p)
    # if not g.unitTesting: g.es("reading: @asis %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None: return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    old_body = p.b
    p.b = g.toUnicode(s, encoding=encoding, reportErrors='True')
    if not c.isChanged() and p.b != old_body:
        c.setChanged()
</t>
<t tx="ekr.20190210091845.1">def create_child_node(self, parent, body, headline):
    '''Create a child node of parent.'''
    child = parent.insertAsLastChild()
    self.inject_lines_ivar(child)
    if body:
        self.add_line(child, body)
    assert isinstance(headline, str), repr(headline)
    child.h = headline
        # #1037: do rstrip, not strip.
        # #1087: do not strip at all!
    return child
</t>
<t tx="ekr.20190306105229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1032

@language python
</t>
<t tx="ekr.20190322082533.1">def get_lexer(self, language):
    """Return the lexer for self.language, creating it if necessary."""
    import pygments.lexers as lexers
    tag = 'get_lexer'
    trace = 'coloring' in g.app.debug
    try:
        # #1520: always define lexer_language.
        lexer_name = 'python3' if language == 'python' else language
        lexer = lexers.get_lexer_by_name(lexer_name)
    except Exception:
        # pylint: disable=no-member
            # One of the lexer's will not exist.
        if trace:
            g.trace(f"{tag}: no lexer for {language!r}")
        lexer = lexers.Python3Lexer()
        if trace and 'python' not in self.lexers_dict:
            g.trace(f"{tag}: default lexer for python: {lexer!r}")
    return lexer
</t>
<t tx="ekr.20190324044744.1">def __init__(self, c, widget=None, wrapper=None):
    """ctor for BaseColorizer class."""
    #
    # Copy args...
    self.c = c
    self.widget = widget
    if widget:
        # #503: widget may be None during unit tests.
        widget.leo_colorizer = self
    self.wrapper = wrapper
        # This assert is not true when using multiple body editors
        # assert(wrapper == self.c.frame.body.wrapper)
    #
    # Common state ivars...
    self.enabled = False
        # Per-node enable/disable flag.
        # Set by updateSyntaxColorer.
    self.highlighter = g.NullObject()
        # May be overridden in subclass...
    self.language = 'python'
        # set by scanLanguageDirectives.
    self.showInvisibles = False
    #
    # Statistics....
    self.count = 0
    self.full_recolor_count = 0
        # For unit tests.
    self.recolorCount = 0
    #
    # For traces...
    self.matcher_name = ''
    self.delegate_name = ''
</t>
<t tx="ekr.20190326034006.1">zoom_dict = {}  # Keys are key::settings_names, values are cumulative font size.

def find_font(self, key, setting_name):
    """
    Return the font for the given setting name.
    """
    trace = 'zoom' in g.app.debug
    c, get = self.c, self.c.config.get
    default_size = c.config.defaultBodyFontSize
    for name in (setting_name, setting_name.rstrip('_font')):
        size_error = False
        family = get(name + '_family', 'family')
        size = get(name + '_size', 'size')
        slant = get(name + '_slant', 'slant')
        weight = get(name + '_weight', 'weight')
        if family or slant or weight or size:
            family = family or g.app.config.defaultFontFamily
            key = f"{key}::{setting_name}"
            if key in self.zoom_dict:
                old_size = self.zoom_dict.get(key)
            else:
                # It's a good idea to set size explicitly.
                old_size = size or default_size
            if isinstance(old_size, str):
                # All settings should be in units of points.
                try:
                    if old_size.endswith(('pt', 'px'),):
                        old_size = int(old_size[:-2])
                    else:
                        old_size = int(old_size)
                except ValueError:
                    size_error = True
            elif not isinstance(old_size, int):
                size_error = True
            if size_error:
                g.trace('bad old_size:', old_size.__class__, old_size)
                size = old_size
            else:
                # #490: Use c.zoom_size if it exists.
                zoom_delta = getattr(c, 'zoom_delta', 0)
                if zoom_delta:
                    size = old_size + zoom_delta
                    self.zoom_dict[key] = size
            slant = slant or 'roman'
            weight = weight or 'normal'
            size = str(size)
            font = g.app.gui.getFontFromParams(family, size, slant, weight)
            # A good trace: the key shows what is happening.
            if font:
                if trace:
                    g.trace(
                        f"key: {key:&gt;35} family: {family or 'None'} "
                        f"size: {size or 'None'} {slant} {weight}")
                return font
    return None
</t>
<t tx="ekr.20190326183005.1">def reloadSettings(self):
    """Complete the initialization of all settings."""
    if 'coloring' in g.app.debug and not g.unitTesting:
        print('jedit.reloadSettings.')
    # Do the basic inits.
    BaseJEditColorizer.reloadSettings(self)
    # Init everything else.
    self.init_style_ivars()
    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
    self.init()
</t>
<t tx="ekr.20190402091335.1">import leo.commands.editFileCommands as efc

efc.GitDiffController(c).diff_two_revs(
    rev1='c8834c6367', # Before: Latest devel commit, before merging ekr-undo into devel.
    rev2='c7879fb', # After: Lastest ekr-undo commit
    directory=None,
)
</t>
<t tx="ekr.20190406154306.1">g.openWithFileName(r'C:\apps\pyzo\pyzo.leo')</t>
<t tx="ekr.20190406193429.1"># Extra plugins, for this file only.

# Essential...
plugins_menu.py
free_layout.py
    # Now loaded automatically.
    # Disabled for testing bug 882824.
mod_scripting.py
viewrendered.py

# Testing only...
# nodetags.py
# python_terminal.py
# multifile.py
# livecode.py

# Others...
# bookmarks.py
# demo.py
# mod_http.py
# richtext.py

# Standard plugins

# backlink.py
# bigdash.py
# contextmenu.py
# line_numbering.py
# nav_qt.py
# nodetags.py
# quicksearch.py
# screen_capture.py
# todo.py
# valuespace.py
# xdb_pane.py
</t>
<t tx="ekr.20190410171646.1">@first # -*- coding: utf-8 -*-
'''
pyzo_support.py: Will probably be deleted.
'''
&lt;&lt; copyright &gt;&gt;
from leo.core import leoGlobals as g
assert g
@others
</t>
<t tx="ekr.20190410171905.1">def init():
    print('pyzo_support.py is not a real plugin')
    return False
</t>
<t tx="ekr.20190412042616.1">@
This file uses code from pyzo. Here is the pyzo copyright notice:

Copyright (C) 2013-2018, the Pyzo development team

Pyzo is distributed under the terms of the (new) BSD License.
The full license can be found in 'license.txt'.

Yoton is distributed under the terms of the (new) BSD License.
The full license can be found in 'license.txt'.
</t>
<t tx="ekr.20190418161712.1">class PyzoInterface:
    '''
    A class representing the singleton running instance of pyzo.
    
    Instantiated in the top-level init() function.
    '''

    @others
</t>
<t tx="ekr.20190424083049.1">def create_base_text_widget(self):
    '''Create a QWebView or a QTextBrowser.'''
    c = self.c
    w = BaseTextWidget()
    n = c.config.getInt('qweb-view-font-size')
    if n:
        try:
            # BaseTextWidget is a QWebView.
            settings = w.settings()
            settings.setFontSize(settings.DefaultFontSize, n)
        except AttributeError:
            # BaseTextWidget is a QTextBrowser.
            pass
    return w
</t>
<t tx="ekr.20190428173354.1">def getGitVersion(directory=None):
    """Return a tuple (author, build, date) from the git log, or None."""
    #
    # -n: Get only the last log.
    trace = 'git' in g.app.debug
    try:
        s = subprocess.check_output(
            'git log -n 1 --date=iso',
            cwd=directory or g.app.loadDir,
            stderr=subprocess.DEVNULL,
            shell=True,
        )
        if trace:
            g.trace(s)
    # #1209.
    except subprocess.CalledProcessError as e:
        s = e.output
        if trace:
            g.trace('return code', e.returncode)
            g.trace('value', repr(s))
            g.es_print('Exception in g.getGitVersion')
            g.es_exception()
        s = g.toUnicode(s)
        if not isinstance(s, str):
            return '', '', ''
    except Exception:
        if trace:
            g.es_print('Exception in g.getGitVersion')
            g.es_exception()
        return '', '', ''

    info = [g.toUnicode(z) for z in s.splitlines()]

    def find(kind):
        """Return the given type of log line."""
        for z in info:
            if z.startswith(kind):
                return z.lstrip(kind).lstrip(':').strip()
        return ''

    return find('Author'), find('commit')[:10], find('Date')
</t>
<t tx="ekr.20190505173053.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1132

@language python
</t>
<t tx="ekr.20190506055928.1">@nosearch

# flattened, word, ignore-case, head, body

# found 5 nodes
</t>
<t tx="ekr.20190506060857.1"></t>
<t tx="ekr.20190506061636.1"></t>
<t tx="ekr.20190522093202.1">def placate_pyflakes(*args):
    """A do-nothing method that suppresses pyflakes warnings."""
</t>
<t tx="ekr.20190602134414.1">def batchSearchAndReplace(self, s):
    """
    Search s for self.find_text and replace with self.change_text.
    
    Return (found, new text)
    """
    if sys.platform.lower().startswith('win'):
        s = s.replace('\r', '')
            # Ignore '\r' characters, which may appear in @edit nodes.
            # Fixes this bug: https://groups.google.com/forum/#!topic/leo-editor/yR8eL5cZpi4
            # This hack would be dangerous on MacOs: it uses '\r' instead of '\n' (!)
    if not s:
        return False, None
    #
    # Order matters: regex matches ignore whole-word.
    if self.pattern_match:
        return self.batchRegexReplace(s)
    if self.whole_word:
        return self.batchWordReplace(s)
    return self.batchPlainReplace(s)
</t>
<t tx="ekr.20190602151043.2">def batchRegexReplace(self, s):
    """
    Perform all regex find/replace on s.
    return (count, new_s)
    """
    count, prev_i, result = 0, 0, []

    flags = re.MULTILINE
    if self.ignore_case:
        flags |= re.IGNORECASE
    for m in re.finditer(self.find_text, s, flags):
        count += 1
        i = m.start()
        result.append(s[prev_i:i])
        # #1748.
        groups = m.groups()
        if groups:
            change_text = self.makeRegexSubs(self.change_text, groups)
        else:
            change_text = self.change_text
        result.append(change_text)
        prev_i = m.end()
    # Compute the result.
    result.append(s[prev_i:])
    s = ''.join(result)
    return count, s
</t>
<t tx="ekr.20190602151043.4">def batchPlainReplace(self, s):
    """
    Perform all plain find/replace on s.\
    return (count, new_s)
    """
    find, change = self.find_text, self.change_text
    # #1166: s0 and find0 aren't affected by ignore-case.
    s0 = s
    find0 = self.replaceBackSlashes(find)
    if self.ignore_case:
        s = s0.lower()
        find = find0.lower()
    count, prev_i, result = 0, 0, []
    while True:
        # #1166: Scan using s and find.
        i = s.find(find, prev_i)
        if i == -1:
            break
        # #1166: Replace using s0 &amp; change.
        count += 1
        result.append(s0[prev_i:i])
        result.append(change)
        prev_i = i + len(find)
    # #1166: Complete the result using s0.
    result.append(s0[prev_i:])
    return count, ''.join(result)
</t>
<t tx="ekr.20190602155933.1">def batchWordReplace(self, s):
    """
    Perform all whole word find/replace on s.
    return (count, new_s)
    """
    find, change = self.find_text, self.change_text
    # #1166: s0 and find0 aren't affected by ignore-case.
    s0 = s
    find0 = self.replaceBackSlashes(find)
    if self.ignore_case:
        s = s0.lower()
        find = find0.lower()
    count, prev_i, result = 0, 0, []
    while True:
        # #1166: Scan using s and find.
        i = s.find(find, prev_i)
        if i == -1:
            break
        # #1166: Replace using s0, change &amp; find0.
        result.append(s0[prev_i:i])
        if g.match_word(s, i, find):
            count += 1
            result.append(change)
        else:
            result.append(find0)
        prev_i = i + len(find)
    # #1166: Complete the result using s0.
    result.append(s0[prev_i:])
    return count, ''.join(result)
</t>
<t tx="ekr.20190603064815.1">def finishCreateTab(self, tabName):
    """Finish creating the given tab. Do not set focus!"""
    c = self.c
    i = self.findTabIndex(tabName)
    if i is None:
        g.trace('Can not happen', tabName)
        self.tabName = None
        return
    # # #1161.
    if tabName == 'Log':
        wrapper = None
        widget = self.contentsDict.get('Log')
            # a qt_text.QTextEditWrapper
        if widget:
            wrapper = getattr(widget, 'leo_log_wrapper', None)
            if wrapper and isinstance(wrapper, qt_text.QTextEditWrapper):
                self.logCtrl = wrapper
        if not wrapper: g.trace('NO LOG WRAPPER')
    if tabName == 'Find':
        # Do *not* set focus here!
        # #1254861: Ctrl-f doesn't ensure find input field visible.
        if c.config.getBool('auto-scroll-find-tab', default=True):
            # This is the cause of unwanted scrolling.
            findbox = c.findCommands.ftm.find_findbox
            if hasattr(widget, 'ensureWidgetVisible'):
                widget.ensureWidgetVisible(findbox)
            else:
                findbox.setFocus()
    if tabName == 'Spell':
        # Set a flag for the spell system.
        widget = self.tabWidget.widget(i)
        self.frameDict['Spell'] = widget
</t>
<t tx="ekr.20190607124533.1"></t>
<t tx="ekr.20190611095758.1"></t>
<t tx="ekr.20190619183908.1">def compile_lines(lines):
    '''Compile one or more lines, returning the compiled code.'''
    source = ''.join(lines)
    try:
        return code.compile_command(source)
    except SyntaxError:
        interp.showsyntaxerror()
    except Exception:
        interp.showtraceback()
    return None
</t>
<t tx="ekr.20190619185252.1">def compute_indent(line):
    '''Return the indentation of a line.'''
    indent = len(line) - len(line.lstrip())
    if line.endswith(':'):
        indent += 4
    return indent
</t>
<t tx="ekr.20190619190805.1">def compile_and_run_lines(lines):
    '''Compile and run code lines.  Return 1 if there are errors.'''
    assert lines
    the_code = compile_lines(lines)
    if the_code:
        return run_code(the_code)
    return None
</t>
<t tx="ekr.20190803175344.1">def patch_pyzo(self):
    '''
    Called at the end of pyzo.start to embed Leo into pyzo.
    '''
</t>
<t tx="ekr.20190805022257.1">@first # -*- coding: utf-8 -*-
"""pyzo_file_browser.py: Experimental plugin that adds pyzo's file browser dock to Leo."""
&lt;&lt; pyzo_file_browser imports &gt;&gt;
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190809093446.1">import sys
from leo.core import leoGlobals as g
from leo.core.leoQt import QtCore
#
# Must patch sys.path here.
plugins_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
sys.path.insert(0, plugins_dir)
#
# Start pyzo, de-fanged.
import pyzo
# pylint: disable=no-member
</t>
<t tx="ekr.20190809093459.1"></t>
<t tx="ekr.20190809093459.3">init_warning_given = False

def init(): # pyzo_file_browser.py
    '''Return True if this plugin can be loaded.'''
    
    def oops(message):
        global init_warning_given
        if not init_warning_given:
            init_warning_given = True
            print('%s %s' % (__name__, message))
        return False
        
    if g.app.gui.guiName() != "qt":
        return oops('requires Qt gui')
     if not getattr(g.app, 'dock'):
        return oops('requires Qt Docks')
    g.plugin_signon(__name__)
    g.registerHandler('after-create-leo-frame', onCreate)
    return True
</t>
<t tx="ekr.20190809093459.4">def onCreate(tag, keys): # pyzo_file_browser.py
    '''Create a pyzo file browser in c's outline.'''
    c = keys.get('c')
    dw = c and c.frame and c.frame.top
    if not dw:
        return
    pyzo.start_pyzo_in_leo(c, pyzo)
    from pyzo.tools.pyzoFileBrowser import PyzoFileBrowser
    make_dock(c,
        name="File Browser",
        widget=PyzoFileBrowser(parent=None),
    )
</t>
<t tx="ekr.20190813161639.1">@first # -*- coding: utf-8 -*-
"""pyzo_in_leo.py: Experimental plugin that adds all of pyzo's features to Leo."""
#
# Easy imports...
import locale
import os
import sys
import threading
from leo.core import leoGlobals as g
from leo.core.leoQt import QtCore, QtGui, QtWidgets

# pylint: disable=import-error
    # pylint doesn't know about the additions to sys.path.
        
# The pyzo global. Set by init()
pyzo = None

# The singleton PyzoController instance.
pyzo_controller = None

@others
@language python
@tabwidth -4
@nobeautify # Indentation of comments is important.
</t>
<t tx="ekr.20190813161639.4">init_warning_given = False

def init(): # pyzo_in_leo.py
    '''Return True if this plugin can be loaded.'''
    global pyzo

    from shutil import which
    
    def oops(message):
        global init_warning_given
        if not init_warning_given:
            init_warning_given = True
            print(f"\npyzo_in_leo not loaded: {message}\n")
            g.es('pyzo_in_leo', message, color='red')
        return False
        
    if g.app.gui.guiName() != "qt":
        return oops('requires Qt gui')
    if not getattr(g.app, 'dock'):
        return oops('requires Qt Docks')
    # #1643: This test will never fail now.
        # if not g.app.use_global_docks:
        #     return oops('requires --global-docks')
    #
    # Fail if can't find pyzo.exe.
    pyzo_exec = which('pyzo')
    if not pyzo_exec:
        return oops('can not find pyzo.exe')
    # Add pyzo/source to sys.path
    pyzo_dir = os.path.dirname(pyzo_exec)
    pyzo_source_dir = os.path.join(pyzo_dir, 'source')
    if pyzo_source_dir not in sys.path:
        sys.path.insert(0, pyzo_source_dir)
    # Fail if still can't import pyzo.
    try:
        import pyzo as local_pyzo
        pyzo = local_pyzo
    except ImportError:
        return oops(f"can not import pyzo from {pyzo_source_dir!r}")
    g.plugin_signon(__name__)
    #
    # This replaces MainWindow.closeEvent.
    g.app.pyzo_close_handler = close_handler
        # LeoApp.finishQuit calls this late in Leo's shutdown logic.
    g.registerHandler('after-create-leo-frame', onCreate) 
    return True
</t>
<t tx="ekr.20190813161921.1">def make_global_dock(self, name, widget):
    """Create a dock with the given name and widget in the global main window."""
    main_window = g.app.gui.main_window
    dock = g.app.gui.create_dock_widget(
        closeable=True,
        moveable=True, # Implies floatable.
        height=100,
        name=name,
    )
    dock.setWidget(widget)
    area = QtCore.Qt.LeftDockWidgetArea
    main_window.addDockWidget(area, dock)
    widget.show()
</t>
<t tx="ekr.20190814050007.1">def make_dock(c, name, widget): # pyzo_file_browser.py
    """Create a dock with the given name and widget in c's main window."""
    dw = c.frame.top
    dock = g.app.gui.create_dock_widget(
        closeable=True,
        moveable=True,
        height=100,
        name=name,
    )
    dw.leo_docks.append(dock)
    dock.setWidget(widget)
    area = QtCore.Qt.LeftDockWidgetArea
    dw.addDockWidget(area, dock)
    widget.show()
</t>
<t tx="ekr.20190814050859.1">def load_all_pyzo_docks(self):
    """
    Load all pyzo docks into the singleton QMainWindow.
    
    This code, included commented-out code, is based on pyzo.
    Copyright (C) 2013-2019 by Almar Klein.
    """
    assert pyzo.main == g.app.gui.main_window
    tm = pyzo.toolManager
    table = (
        'PyzoFileBrowser',
        'PyzoHistoryViewer',
        'PyzoInteractiveHelp',
        'PyzoLogger',
        'PyzoSourceStructure',
        'PyzoWebBrowser',
        'PyzoWorkspace',
    )
    for tool_id in table:
        tm.loadTool(tool_id)
        
    # EKR-change: old code.
        # # Load tools
        # if pyzo.config.state.newUser and not pyzo.config.state.loadedTools:
            # pyzo.toolManager.loadTool('pyzosourcestructure')
            # pyzo.toolManager.loadTool('pyzofilebrowser', 'pyzosourcestructure')
        # elif pyzo.config.state.loadedTools:
            # for toolId in pyzo.config.state.loadedTools:
                # pyzo.toolManager.loadTool(toolId)
</t>
<t tx="ekr.20190816131343.1">def pyzo_start(self):
    """
    A copy of pyzo.start, adapted for Leo.
    
    Called at start2 time.  c is not available.
    
    This code is based on pyzo.
    Copyright (C) 2013-2019 by Almar Klein.
    """
    
    # Do some imports
    from pyzo.core import pyzoLogging  # to start logging asap
        # EKK: All print statements after this will appear in the Logger dock.
        # Unless we change pyzoLogging itself, this import will happen soon anyway.
    assert pyzoLogging

    # print('\nBEGIN pyzo_start\n')
    
    # EKR:change.
    # from pyzo.core.main import MainWindow

    # Apply users' preferences w.r.t. date representation etc
    for x in ('', 'C', 'en_US', 'en_US.utf8', 'en_US.UTF-8'):
        try:
            locale.setlocale(locale.LC_ALL, x)
            break
        except locale.Error:
            pass

    # Set to be aware of the systems native colors, fonts, etc.
    QtWidgets.QApplication.setDesktopSettingsAware(True)

    # EKR-change: the only remaining code from my_app_ctor.
    sys.argv = sys.argv[:1]
        # Instantiate the application.
        # QtWidgets.qApp = MyApp(sys.argv)
        # my_app_ctor(sys.argv)

    # EKR:change.
        # # Choose language, get locale
        # appLocale = setLanguage(config.settings.language)
    # EKR:change.
    # Create main window, using the selected locale
        # MainWindow(None, appLocale)
    self.main_window_ctor()

    # EKR:change.
        # Enter the main loop
        # QtWidgets.qApp.exec_()

    # print('END pyzo_start\n')
</t>
<t tx="ekr.20190816131753.1">def main_window_ctor(self):
    """
    Simulate MainWindow.__init__().
    
    This code, included commented-out code, is based on pyzo.
    Copyright (C) 2013-2019 by Almar Klein.
    """

    # print('\nBEGIN main_window_ctor\n')
    
    # EKR:change. New imports
    import pyzo.core.main as main
    from pyzo.core import commandline
    
    # EKR:change: was self.
    main_window = g.app.gui.main_window
    # EKR:change.
        # QtWidgets.QMainWindow.__init__(self, parent)

    main_window._closeflag = 0  # Used during closing/restarting

    # EKR:change.
        # # Init window title and application icon
        # self.setMainTitle()
    
    # EKR:change.
    main.loadAppIcons()
    pyzo.icon = g.app.gui.appIcon
    # Don't patch this now. It might be a good indicator.
    # pyzo.iconRunning = g.app.gui.appIcon
    
        # loadAppIcons()
    # EKR:change.
        # self.setWindowIcon(pyzo.icon)
    # EKR:change.
        # Restore window geometry.
        # self.resize(800, 600) # default size
        # self.restoreGeometry()
    # EKR:change.
        # Show splash screen (we need to set our color too)
        # w = SplashWidget(self, distro='no distro')
    # EKR:change.
        # self.setCentralWidget(w)
    # EKR:change.
       #  self.setStyleSheet("QMainWindow { background-color: #268bd2;}")

    # Show empty window and disable updates for a while

    # EKR:change.
        # self.show()
        # self.paintNow()
        # self.setUpdatesEnabled(False)
    # EKR:change.
        # Determine timeout for showing splash screen
        # splash_timeout = time.time() + 1.0
    # EKR:change.
        # Set locale of main widget, so that qt strings are translated
        # in the right way
        # if locale:
            # self.setLocale(locale)
  
    # Set pyzo.main.
    pyzo.main = main_window
    
    # EKR:change-Add do-nothing methods.
    pyzo.main.setMainTitle = g.TracingNullObject(tag='pyzo.main.setMainTitle()')
    pyzo.main.restart = g.TracingNullObject(tag='pyzo.main.restart()')

    # Init dockwidget settings
    main_window.setTabPosition(QtCore.Qt.AllDockWidgetAreas,QtWidgets.QTabWidget.South)
    main_window.setDockOptions(
        QtWidgets.QMainWindow.AllowNestedDocks |
        QtWidgets.QMainWindow.AllowTabbedDocks
        #|  QtWidgets.QMainWindow.AnimatedDocks
    )

    # Set window atrributes
    main_window.setAttribute(QtCore.Qt.WA_AlwaysShowToolTips, True)

    # EKR:change.
    # Load icons and fonts
    main.loadIcons()
    main.loadFonts()
        # loadIcons()
        # loadFonts()

    # EKR:change.
        # # Set qt style and test success
        # self.setQtStyle(None) # None means init!
    # EKR:change.
        # # Hold the splash screen if needed
        # while time.time() &lt; splash_timeout:
            # QtWidgets.qApp.flush()
            # QtWidgets.qApp.processEvents()
            # time.sleep(0.05)
    # EKR:change.
    # Populate the window (imports more code)
    self.main_window_populate()
        # self._populate()
        
    # EKR:change: new code.
    self.load_all_pyzo_docks()

    # EKR:change.
    # Revert to normal background, and enable updates
    main_window.setStyleSheet('')
    main_window.setUpdatesEnabled(True)

    # EKR:change. Could this be a problem?
        # # Restore window state, force updating, and restore again
        # self.restoreState()
        # self.paintNow()
        # self.restoreState()

    # EKR:change.
        # Present user with wizard if he/she is new.
        # if pyzo.config.state.newUser:
            # from pyzo.util.pyzowizard import PyzoWizard
            # w = PyzoWizard(self)
            # w.show() # Use show() instead of exec_() so the user can interact with pyzo

    # EKR:change
        # # Create new shell config if there is None
        # if not pyzo.config.shellConfigs2:
            # from pyzo.core.kernelbroker import KernelInfo
            # pyzo.config.shellConfigs2.append( KernelInfo() )
    from pyzo.core.kernelbroker import KernelInfo
        # pyzo.config.shellConfigs2.append( KernelInfo() )
    pyzo.config.shellConfigs2 = [KernelInfo()]

    # EKR:change Set background.
        # bg = getattr(pyzo.config.settings, 'dark_background', '#657b83')
            # # Default: solarized base00
        # try:
            # self.setStyleSheet(f"background: {bg}") 
        # except Exception:
            # g.es_exception()

    # Focus on editor
    e = pyzo.editors.getCurrentEditor()
    if e is not None:
        e.setFocus()

    # Handle any actions
    commandline.handle_cmd_args()
    
    # print('END main_window_ctor\n')
</t>
<t tx="ekr.20190816132847.1">def main_window_populate(self):
    """
    Simulate MainWindow._populate().
    
    This code, included commented-out code, is based on pyzo.
    Copyright (C) 2013-2019 by Almar Klein.
    """
    # EKR:change: replaces self in most places.
    main_window = g.app.gui.main_window

    # print('\nBEGIN main_window_populate\n')
    
    # EKR:change-new imports
    from pyzo.core.main import callLater

    # Delayed imports
    from pyzo.core.editorTabs import EditorTabs
    from pyzo.core.shellStack import ShellStackWidget
    from pyzo.core import codeparser
    from pyzo.core.history import CommandHistory
    from pyzo.tools import ToolManager

    # Instantiate tool manager
    pyzo.toolManager = ToolManager()

    # EKR: Disabled in original.
        # Check to install conda now ...
        # from pyzo.util.bootstrapconda import check_for_conda_env
        # check_for_conda_env()

    # Instantiate and start source-code parser
    if pyzo.parser is None:
        pyzo.parser = codeparser.Parser()
        pyzo.parser.start()

    # Create editor stack and make the central widget
    # EKR:change. Use None, not self.
    pyzo.editors = EditorTabs(None)
    
    # EKR:change. Create an Editors dock.
    self.make_global_dock('Editors', pyzo.editors)
        # self.setCentralWidget(pyzo.editors)

    # Create floater for shell
    # EKR:change: use a global *Leo* dock
    dock = g.app.gui.create_dock_widget(
        closeable=True,
        moveable=True,
        height=50,
        name='Shells',
    )
    # Old code
        # self._shellDock = dock = QtWidgets.QDockWidget(self)
        # if pyzo.config.settings.allowFloatingShell:
            # dock.setFeatures(dock.DockWidgetMovable | dock.DockWidgetFloatable)
        # else:
            # dock.setFeatures(dock.DockWidgetMovable)
    dock.setObjectName('shells')
        # dock.setWindowTitle('Shells')
    
    # EKR:change: Make the dock a *global* dock.
    main_window.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        # self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)

    # Create shell stack
    # EKR:change. Use None, not self.
    
    # A hack: patch _get_interpreters_win
    if 1:
        import pyzo.util.interpreters as interps
        interps._get_interpreters_win = _get_interpreters_win

    pyzo.shells = ShellStackWidget(None)
    dock.setWidget(pyzo.shells)

    # Initialize command history
    pyzo.command_history = CommandHistory('command_history.py')

    # Create the default shell when returning to the event queue
    callLater(pyzo.shells.addShell)

    # EKR:change.
    pyzo.status = None
    # Create statusbar
        # if pyzo.config.view.showStatusbar:
            # pyzo.status = self.statusBar()
        # else:
            # pyzo.status = None
            # self.setStatusBar(None)
            
    from pyzo.core import menu
    pyzo.keyMapper = menu.KeyMapper()
    
    # EKR:change: Monkey-patch pyzo.keyMapper.setShortcut.
    g.funcToMethod(setShortcut, pyzo.keyMapper.__class__)
    
    # EKR-change: init_pyzo_menu does this later.
        # # Add the context menu to the editor
        # pyzo.editors.addContextMenu()
        # pyzo.shells.addContextMenu()
            
    # print('END main_window_populate\n')
</t>
<t tx="ekr.20190816163728.1">def close_handler(): # pyzo_in_leo.py
    """
    Shut down pyzo.
    
    Called by Leo's shutdown logic when *all* outlines have been closed.
    
    This code is based on MainWindow.closeEvent.
    Copyright (C) 2013-2019 by Almar Klein.
    """

    print('\ng.app.pyzo_close_event\n')
    
    if 1: # EKR: change
    
        def do_nothing(*args, **kwargs):
            pass

        # We must zero this out. pyzo.saveConfig calls this.
        pyzo.main.saveWindowState = do_nothing
    
    # EKR:change-new imports
    from pyzo.core import commandline

    # Are we restaring?
    # restarting = time.time() - self._closeflag &lt; 1.0

    # EKR:change.
    if 1: # As in the original.
        # Save settings
        pyzo.saveConfig()
        pyzo.command_history.save()

    # Stop command server
    commandline.stop_our_server()

    # Proceed with closing...
    pyzo.editors.closeAll()
    
    # EKR:change.
        # # Force the close.
        # if not result:
            # self._closeflag = False
            # event.ignore()
            # return
        # self._closeflag = True

    # Proceed with closing shells
    if 1:
        # pylint: disable=no-member
        pyzo.localKernelManager.terminateAll()
    
    for shell in pyzo.shells:
        shell._context.close()

    if 1: # As in original.
        # Close tools
        for toolname in pyzo.toolManager.getLoadedTools():
            tool = pyzo.toolManager.getTool(toolname)
            tool.close()

    # Stop all threads (this should really only be daemon threads)
        # import threading
    for thread in threading.enumerate():
        if hasattr(thread, 'stop'):
            try:
                thread.stop(0.1)
            except Exception:
                pass

    # EKR:change. Not needed.
        # Proceed as normal
        # QtWidgets.QMainWindow.closeEvent(self, event)
    # EKR:change. Don't exit Leo!
        # if sys.version_info &gt;= (3,3,0): # and not restarting:
            # if hasattr(os, '_exit'):
                # os._exit(0)
</t>
<t tx="ekr.20190819072045.1">def make_main_window(self):
    """Make the *singleton* QMainWindow."""
    window = QtWidgets.QMainWindow()
    window.setObjectName('LeoGlobalMainWindow')
    # Calling window.show() here causes flash.
    self.attachLeoIcon(window)
    # Monkey-patch
    window.closeEvent = self.close_event
        # Use self: g.app.gui does not exist yet.
    self.runAtIdle(self.set_main_window_style_sheet)
        # No StyleSheetManager exists yet.
    return window

def set_main_window_style_sheet(self):
    """Style the main window, using the first .leo file."""
    commanders = g.app.commanders()
    if commanders:
        c = commanders[0]
        ssm = c.styleSheetManager
        ssm.set_style_sheets(w=self.main_window)
        self.main_window.setWindowTitle(c.frame.title)  # #1506.
    else:
        g.trace("No open commanders!")
</t>
<t tx="ekr.20190905091614.5">def new_commander(self):
    """Create the new commander, and load all settings files."""
    lm = g.app.loadManager
    old_c = self.c
    # Save any changes so they can be seen.
    if old_c.isChanged():
        old_c.save()
    old_c.outerUpdate()
    # From file-new...
    g.app.disable_redraw = True
    g.app.setLog(None)
    g.app.lockLog()
    # Switch to the new commander. Do *not* use previous settings.
    fileName = f"{old_c.fileName()}-active-settings"
    g.es(fileName, color='red')
    c = g.app.newCommander(fileName=fileName)
    # Restore the layout, if we have ever saved this file.
    if not old_c:
        c.frame.setInitialWindowGeometry()
    # #1340: Don't do this. It is no longer needed.
        # g.app.restoreWindowState(c)
    c.frame.resizePanesToRatio(c.frame.ratio, c.frame.secondary_ratio)
    # From file-new...
    g.app.unlockLog()
    lm.createMenu(c)
    lm.finishOpen(c)
    g.app.writeWaitingLog(c)
    c.setLog()
    c.clearChanged()  # Clears all dirty bits.
    g.app.disable_redraw = False
    return c
</t>
<t tx="ekr.20190921130036.2">replace_errors = []

def replace_path_expression(self, expr):
    """ local function to replace a single path expression."""
    c = self
    d = {
        'c': c,
        'g': g,
        # 'getString': c.config.getString,
        'p': c.p,
        'os': os,
        'sep': os.sep,
        'sys': sys,
    }
    # #1338: Don't report errors when called by g.getUrlFromNode.
    try:
        # pylint: disable=eval-used
        path = eval(expr, d)
        return g.toUnicode(path, encoding='utf-8')
    except Exception as e:
        message = (
            f"{c.shortFileName()}: {c.p.h}\n"
            f"expression: {expr!s}\n"
            f"     error: {e!s}")
        if message not in self.replace_errors:
            self.replace_errors.append(message)
            g.trace(message)
        return expr
</t>
<t tx="ekr.20190923170528.1">def doWindowSpotOption(self, options):

    # --window-spot
    spot = options.window_spot
    if spot:
        try:
            top, left = spot.split('x')
            spot = int(top), int(left)
        except ValueError:
            print('scanOptions: bad --window-spot:', spot)
            spot = None

    return spot
</t>
<t tx="ekr.20190928061911.1">def onCreate(tag, keys): # pyzo_in_leo.py
    """
    Init another commander, and pyzo itself if this is the first commander.
    """
    global pyzo_controller
    c = keys.get('c')
    if not c:
        return
    if not pyzo_controller:
        pyzo_controller = PyzoController()
        pyzo_controller.pyzo_start()
        main_window = g.app.gui.main_window
        main_window.setWindowTitle(c.frame.title)
    pyzo_controller.init_pyzo_menu(c)
</t>
<t tx="ekr.20190929180053.1">def init_pyzo_menu(self, c):
    """
    Add a Pyzo menu to c's menu bar.
    
    This code is based on pyzo.
    Copyright (C) 2013-2019 by Almar Klein.
    """
    dw = c.frame.top
    leo_menu_bar = dw.leo_menubar
        # Create the Pyzo menu in *Leo's* per-commander menu bar.
    menuBar = pyzo.main.menuBar()
        # Use *pyzo's* main menuBar to get data.

    # EKR:change-new imports.
    from pyzo import translate
    from pyzo.core.menu import EditMenu, FileMenu, SettingsMenu
        # Testing.
    from pyzo.core.menu import HelpMenu, RunMenu, ShellMenu, ViewMenu
        # Permanent.

    # EKR:change. Create a top-level Pyzo menu.
    pyzoMenu = leo_menu_bar.addMenu("Pyzo")
    menus = [
        # Testing only...
        FileMenu(menuBar, translate("menu", "File")),
        EditMenu(menuBar, translate("menu", "Edit")),
        SettingsMenu(menuBar, translate("menu", "Settings")),
        # Permanent...
        ViewMenu(menuBar, translate("menu", "View")),
        ShellMenu(menuBar, translate("menu", "Shell")),
        RunMenu(menuBar, translate("menu", "Run")),
        RunMenu(menuBar, translate("menu", "Tools")),
        HelpMenu(menuBar, translate("menu", "Help")),
    ]
    menuBar._menumap = {}
    menuBar._menus = menus
    for menu in menuBar._menus:
        pyzoMenu.addMenu(menu)
            # menuBar.addMenu(menu)
        menuName = menu.__class__.__name__.lower().split('menu')[0]
        menuBar._menumap[menuName] = menu

    # Enable tooltips
    def onHover(action):
        # This ugly bit of code makes sure that the tooltip is refreshed
        # (thus raised above the submenu). This happens only once and after
        # ths submenu has become visible.
        if action.menu():
            if not hasattr(menuBar, '_lastAction'):
                menuBar._lastAction = None
                menuBar._haveRaisedTooltip = False
            if action is menuBar._lastAction:
                if ((not menuBar._haveRaisedTooltip) and
                            action.menu().isVisible()):
                    QtWidgets.QToolTip.hideText()
                    menuBar._haveRaisedTooltip = True
            else:
                menuBar._lastAction = action
                menuBar._haveRaisedTooltip = False
        # Set tooltip
        tt = action.statusTip()
        if hasattr(action, '_shortcutsText'):
            tt = tt + ' ({})'.format(action._shortcutsText) # Add shortcuts text in it
        QtWidgets.QToolTip.showText(QtGui.QCursor.pos(), tt)

    menuBar.hovered.connect(onHover)

    if not self.menus_inited:
        self.menus_inited = True
        pyzo.editors.addContextMenu()
        pyzo.shells.addContextMenu()
</t>
<t tx="ekr.20190930051034.1">class PyzoController:
    
    menus_inited = False
    
    @others
</t>
<t tx="ekr.20190930051422.1"></t>
<t tx="ekr.20191001084612.1">def zoom_helper(event, delta):
    """
    Common helper for zoom commands.
    """
    c = event.get('c')
    if not c:
        return
    wrapper = c.frame.body.wrapper
    #
    # For performance, don't call c.styleSheetManager.reload_style_sheets().
    # Apply to body widget directly
    c._style_deltas['font-size-body'] += delta
    ssm = c.styleSheetManager
    sheet = ssm.expand_css_constants(c.active_stylesheet)
    wrapper.widget.setStyleSheet(sheet)
    #
    # #490: Honor language-specific settings.
    colorizer = getattr(c.frame.body, 'colorizer', None)
    if not colorizer:
        return
    c.zoom_delta = delta
    colorizer.configure_fonts()
    wrapper.setAllText(wrapper.getAllText())
        # Recolor everything.
</t>
<t tx="ekr.20191004143229.1">def update_asciidoc(self, s, keywords):
    '''Update asciidoc in the vr pane.'''
    global asciidoctor_exec, asciidoc3_exec
    pc = self
    # Do this regardless of whether we show the widget or not.
    w = pc.ensure_text_widget()
    assert pc.w
    if s:
        pc.show()
    if asciidoctor_exec or asciidoc3_exec:
        try:
            s2 = self.convert_to_asciidoctor(s)
            self.set_html(s2,w)
            return
        except Exception:
            g.es_exception()
    self.update_rst(s,keywords)
</t>
<t tx="ekr.20191004143805.1">def convert_to_asciidoctor(self, s):
    '''Convert s to html using the asciidoctor or asciidoc processor.'''
    pc = self
    c, p = pc.c, pc.c.p
    path = g.scanAllAtPathDirectives(c, p) or c.getNodePath(p)
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    if os.path.isdir(path):
        os.chdir(path)
    if pc.title:
        s = pc.make_asciidoc_title(pc.title) + s
        pc.title = None
    s = pc.run_asciidoctor(s)
    return g.toUnicode(s)
</t>
<t tx="ekr.20191004144128.1">def run_asciidoctor(self, s):
    """
    Process s with asciidoctor or asciidoc3.
    return the contents of the html file.
    The caller handles all exceptions.
    """
    global asciidoctor_exec, asciidoc3_exec
    assert asciidoctor_exec or asciidoc3_exec, g.callers()
    home = g.os.path.expanduser('~')
    i_path = g.os_path_finalize_join(home, 'vr_input.adoc')
    o_path = g.os_path_finalize_join(home, 'vr_output.html')
    # Write the input file.
    with open(i_path, 'w') as f:
        f.write(s)
    # Call the external program to write the output file.
    prog = 'asciidoctor' if asciidoctor_exec else 'asciidoc3'
    command = f"{prog} {i_path} -b html5 -o {o_path}"
        # The -e option deletes css.
    g.execute_shell_commands(command)
    # Read the output file and return it.
    with open(o_path, 'r') as f:
        return f.read()
  
</t>
<t tx="ekr.20191004144242.1">def make_asciidoc_title(self, s):
    '''Generate an asciiidoc title for s.'''
    line = '#' * (min(4, len(s)))
    return f"{line}\n{s}\n{line}\n\n"
</t>
<t tx="ekr.20191006155748.1">def update_pandoc(self, s, keywords):
    '''
    Update an @pandoc in the vr pane.
    
    There is no such thing as @language pandoc,
    so only @pandoc nodes trigger this code.
    '''
    global pandoc_exec
    pc = self
    w = pc.ensure_text_widget()
    assert pc.w
    if s:
        pc.show()
    if pandoc_exec:
        try:
            s2 = self.convert_to_pandoc(s)
            self.set_html(s2,w)
        except Exception:
            g.es_exception()
        return
    self.update_rst(s,keywords)
</t>
<t tx="ekr.20191006155748.3">def convert_to_pandoc(self, s):
    '''Convert s to html using the asciidoctor or asciidoc processor.'''
    pc = self
    c, p = pc.c, pc.c.p
    path = g.scanAllAtPathDirectives(c, p) or c.getNodePath(p)
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    if os.path.isdir(path):
        os.chdir(path)
    if pc.title:
        s = pc.make_pandoc_title(pc.title) + s
        pc.title = None
    s = pc.run_pandoc(s)
    return g.toUnicode(s)
</t>
<t tx="ekr.20191006155748.4">def run_pandoc(self, s):
    """
    Process s with pandoc.
    return the contents of the html file.
    The caller handles all exceptions.
    """
    global pandoc_exec
    assert pandoc_exec, g.callers()
    home = g.os.path.expanduser('~')
    i_path = g.os_path_finalize_join(home, 'vr_input.pandoc')
    o_path = g.os_path_finalize_join(home, 'vr_output.html')
    # Write the input file.
    with open(i_path, 'w') as f:
        f.write(s)
    # Call pandoc to write the output file.
    command = f"pandoc {i_path} -t html5 -o {o_path}"
        # --quiet does no harm.
    g.execute_shell_commands(command)
    # Read the output file and return it.
    with open(o_path, 'r') as f:
        return f.read()
</t>
<t tx="ekr.20191012093236.1">def _get_interpreters_win():  # pyzo_in_leo.py
    """
    Monkey-patch pyzo/util/interpreters._get_interpreters_win.

    This patched code fixes an apparent pyzo bug.
    
    Unlike shutil.which, this function returns all plausible python executables.

    Copyright (C) 2013-2019 by Almar Klein.
    """

    import pyzo.util.interpreters as interps ### EKR
    
    found = []

    # Query from registry
    for v in interps.get_interpreters_in_reg(): ### EKR
        found.append(v.installPath() )

    # Check common locations
    for rootname in ['C:/', '~/',
                     'C:/program files/', 'C:/program files (x86)/', 'C:/ProgramData/',
                     '~/appdata/local/programs/python/',
                     '~/appdata/local/continuum/', '~/appdata/local/anaconda/',
                     ]:
        rootname = os.path.expanduser(rootname)
        if not os.path.isdir(rootname):
            continue
        for dname in os.listdir(rootname):
            if dname.lower().startswith(('python', 'pypy', 'miniconda', 'anaconda')):
                found.append(os.path.join(rootname, dname))

    # Normalize all paths, and remove trailing backslashes
    
    ### found = [os.path.normcase(os.path.abspath(v)).strip('\\') for v in found]
    found = [
        os.path.normcase(os.path.abspath(v)).strip('\\') for v in found
            if v is not None ### EKR: Add guard.
    ]

    # Append "python.exe" and check if that file exists
    found2 = []
    for dname in found:
        for fname in ('python.exe', 'pypy.exe'):
            exename = os.path.join(dname, fname)
            if os.path.isfile(exename):
                found2.append(exename)
                break

    # Returnas set (remove duplicates)
    return set(found2)
</t>
<t tx="ekr.20191012094334.1">def setShortcut(self, action): # pyzo_in_leo.py
    """A do-nothing, monkey-patched, version of KeyMapper.setShortcut."""
    pass
</t>
<t tx="ekr.20191021002252.1">
(base) c:\leo.repo\leo-editor&gt;mypy leo\core\runLeo.py

leo\external\__init__.py:3: error: Need type annotation for '__all__' (hint: "__all__: List[&lt;type&gt;] = ...")

leo\external\codewise.py:100: error: Cannot find module named '__builtin__'
leo\external\codewise.py:100: error: Name 'builtins' already defined (by an import)

leo\core\leoGlobals.py:34: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoGlobals.py:39: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoGlobals.py:43: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoGlobals.py:309: error: Need type annotation for 'tree_popup_handlers' (hint: "tree_popup_handlers: List[&lt;type&gt;] = ...")
leo\core\leoGlobals.py:310: error: Need type annotation for 'user_dict' (hint: "user_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:2088: error: Need type annotation for 'tracing_signatures' (hint: "tracing_signatures: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:2600: error: No library stub file for module 'PyQt5.QtCore'
leo\core\leoGlobals.py:2600: error: No library stub file for module 'PyQt5'
leo\core\leoGlobals.py:2603: error: No library stub file for module 'PyQt4.QtCore'
leo\core\leoGlobals.py:2603: note: (Stub files are from https://github.com/python/typeshed)
leo\core\leoGlobals.py:2603: error: No library stub file for module 'PyQt4'
leo\core\leoGlobals.py:2702: error: No library stub file for module 'pylint'
leo\core\leoGlobals.py:2770: error: Need type annotation for 'lastObjectsDict' (hint: "lastObjectsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:2771: error: Need type annotation for 'lastTypesDict' (hint: "lastTypesDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:2772: error: Need type annotation for 'lastFunctionsDict' (hint: "lastFunctionsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:5261: error: Need type annotation for 'childrenModifiedSet' (hint: "childrenModifiedSet: Set[&lt;type&gt;] = ...")
leo\core\leoGlobals.py:5262: error: Need type annotation for 'contentModifiedSet' (hint: "contentModifiedSet: Set[&lt;type&gt;] = ...")
leo\core\leoGlobals.py:5767: error: Need type annotation for 'checkUnicode_dict' (hint: "checkUnicode_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:5925: error: Need type annotation for 'unicode_warnings' (hint: "unicode_warnings: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:6814: error: Need type annotation for 'init_zodb_failed' (hint: "init_zodb_failed: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:6815: error: Need type annotation for 'init_zodb_db' (hint: "init_zodb_db: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:6829: error: Cannot find module named 'ZODB'
leo\core\leoGlobals.py:6829: note: See https://mypy.readthedocs.io/en/latest/running_mypy.html#missing-imports
leo\core\leoGlobals.py:6964: error: Need type annotation for 'deprecated_messages' (hint: "deprecated_messages: List[&lt;type&gt;] = ...")

leo\plugins\importers\ipynb.py:7: error: No library stub file for module 'nbformat'

leo\core\leoVim.py:2054: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2058: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2062: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2075: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2080: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2088: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2093: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2097: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2102: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2106: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2110: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2121: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2141: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2147: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2155: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2160: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2167: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"

leo\core\leoUndo.py:1162: error: Argument 1 to "cmd" has incompatible type "str"; expected "Undoer"
leo\core\leoUndo.py:1441: error: Argument 1 to "cmd" has incompatible type "str"; expected "Undoer"

leo\core\leoFind.py:304: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:322: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:327: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:489: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:495: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:505: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:517: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:526: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:587: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:600: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:609: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:624: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:639: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:654: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:669: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:865: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:866: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:867: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:894: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:895: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:896: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:924: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:925: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:926: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:952: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:961: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:972: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:978: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1083: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1090: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1107: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1115: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1133: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1158: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1259: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1266: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1279: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1287: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1292: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1297: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1302: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1307: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1312: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1317: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1322: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1333: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1338: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1343: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1355: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1411: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"

leo\core\leoFind.py:2211: error: Need type annotation for 'debugIndices' (hint: "debugIndices: List[&lt;type&gt;] = ...")

leo\core\leoDebugger.py:75: error: No library stub file for standard library module 'bdb'

leo\commands\checkerCommands.py:12: error: No library stub file for module 'flake8'
leo\commands\checkerCommands.py:16: error: No library stub file for module 'pyflakes'
leo\commands\checkerCommands.py:487: error: No library stub file for module 'pylint'

leo\core\leoChapters.py:94: error: Argument 1 to "cmd" has incompatible type "str"; expected "ChapterController"
leo\core\leoChapters.py:110: error: Argument 1 to "cmd" has incompatible type "str"; expected "ChapterController"
leo\core\leoChapters.py:119: error: Argument 1 to "cmd" has incompatible type "str"; expected "ChapterController"

leo\core\leoBeautify.py:11: error: Cannot find module named 'leoGlobals'
leo\core\leoBeautify.py:11: error: Name 'g' already defined (by an import)
leo\core\leoBeautify.py:18: error: Incompatible types in assignment (expression has type "Callable[[Any], Any]", variable has type "Type[Command]")
leo\core\leoBeautify.py:31: error: Cannot find module named 'black'

leo\core\leoIPython.py:35: error: Cannot find module named 'ipykernel.connect'
leo\core\leoIPython.py:40: error: Cannot find module named 'ipykernel.kernelapp'
leo\core\leoIPython.py:45: error: "None" has no attribute "ipython_inited"

leo\core\leoNodes.py:326: error: Incompatible types in assignment (expression has type "None", base class "object" defined the type as "Callable[[object], int]")

leo\core\leoQt.py:27: error: No library stub file for module 'PyQt5'
leo\core\leoQt.py:31: error: No library stub file for module 'PyQt4'
leo\core\leoQt.py:52: error: Name 'QtCore' already defined on line 44
leo\core\leoQt.py:53: error: Name 'QtGui' already defined on line 44
leo\core\leoQt.py:54: error: Name 'QtWidgets' already defined on line 44
leo\core\leoQt.py:55: error: No library stub file for module 'PyQt5.QtCore'
leo\core\leoQt.py:55: error: Name 'QUrl' already defined on line 44
leo\core\leoQt.py:56: error: Name 'Signal' already defined on line 49
leo\core\leoQt.py:57: error: "None" has no attribute "Qt"
leo\core\leoQt.py:65: error: Name 'QtCore' already defined on line 44
leo\core\leoQt.py:66: error: Name 'QtGui' already defined on line 44
leo\core\leoQt.py:67: error: No library stub file for module 'PyQt4.QtCore'
leo\core\leoQt.py:67: error: Name 'QUrl' already defined on line 44
leo\core\leoQt.py:68: error: Name 'Signal' already defined on line 49
leo\core\leoQt.py:82: error: "None" has no attribute "QT_VERSION_STR"
leo\core\leoQt.py:92: error: "None" has no attribute "QString"
leo\core\leoQt.py:96: error: No library stub file for module 'PyQt5.QtDeclarative'
leo\core\leoQt.py:96: error: Name 'QtDeclarative' already defined on line 45
leo\core\leoQt.py:100: error: No library stub file for module 'PyQt5.phonon'
leo\core\leoQt.py:100: error: Name 'phonon' already defined on line 46
leo\core\leoQt.py:101: error: "None" has no attribute "Phonon"
leo\core\leoQt.py:105: error: Name 'QtMultimedia' already defined on line 45
leo\core\leoQt.py:109: error: Name 'Qsci' already defined on line 45
leo\core\leoQt.py:113: error: No library stub file for module 'PyQt5.QtSvg'
leo\core\leoQt.py:113: error: Name 'QtSvg' already defined on line 45
leo\core\leoQt.py:117: error: Name 'uic' already defined on line 46
leo\core\leoQt.py:121: error: Name 'QtWebKit' already defined on line 45
leo\core\leoQt.py:125: error: Name 'QtWebKit' already defined on line 45
leo\core\leoQt.py:129: error: No library stub file for module 'PyQt5.QtWebKitWidgets'
leo\core\leoQt.py:129: error: Name 'QtWebKitWidgets' already defined on line 45
leo\core\leoQt.py:135: error: No library stub file for module 'PyQt5.QtWebEngineWidgets'
leo\core\leoQt.py:135: error: Name 'QtWebKitWidgets' already defined on line 45
leo\core\leoQt.py:136: error: "None" has no attribute "QWebView"
leo\core\leoQt.py:136: error: "None" has no attribute "QWebEngineView"
leo\core\leoQt.py:137: error: "None" has no attribute "QWebSettings"
leo\core\leoQt.py:137: error: "None" has no attribute "QWebEngineSettings"
leo\core\leoQt.py:138: error: "None" has no attribute "QWebPage"
leo\core\leoQt.py:138: error: "None" has no attribute "QWebEnginePage"
leo\core\leoQt.py:143: error: "None" has no attribute "QString"
leo\core\leoQt.py:147: error: No library stub file for module 'PyQt4.QtDeclarative'
leo\core\leoQt.py:147: error: Name 'QtDeclarative' already defined on line 45
leo\core\leoQt.py:153: error: No library stub file for module 'PyQt4.phonon'
leo\core\leoQt.py:153: error: Name 'phonon' already defined on line 46
leo\core\leoQt.py:154: error: Item "None" of "Optional[Any]" has no attribute "Phonon"
leo\core\leoQt.py:158: error: Name 'Qsci' already defined on line 45
leo\core\leoQt.py:162: error: No library stub file for module 'PyQt4.QtSvg'
leo\core\leoQt.py:162: error: Name 'QtSvg' already defined on line 45
leo\core\leoQt.py:166: error: Name 'uic' already defined on line 46
leo\core\leoQt.py:170: error: Name 'QtWebKit' already defined on line 45
leo\core\leoQt.py:174: error: No library stub file for module 'PyQt4.QtWebKit'
leo\core\leoQt.py:174: error: Name 'QtWebKitWidgets' already defined on line 45

leo\core\leoCheck.py:1457: error: Need type annotation for 'assigns_d' (hint: "assigns_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:1458: error: Need type annotation for 'calls_d' (hint: "calls_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:1459: error: Need type annotation for 'classes_d' (hint: "classes_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:1460: error: Need type annotation for 'defs_d' (hint: "defs_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:1461: error: Need type annotation for 'returns_d' (hint: "returns_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:2047: error: Need type annotation for 'd' (hint: "d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")

leo\plugins\nested_splitter.py:9: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\plugins\nested_splitter.py:26: error: Name 'QtWidgets.QWidget' is not defined
leo\plugins\nested_splitter.py:51: error: Name 'QtWidgets.QWidget' is not defined
leo\plugins\nested_splitter.py:108: error: Name 'QtWidgets.QWidget' is not defined
leo\plugins\nested_splitter.py:130: error: Name 'QtWidgets.QSplitterHandle' is not defined
leo\plugins\nested_splitter.py:391: error: Name 'QtWidgets.QSplitter' is not defined

leo\plugins\editpane\clicky_splitter.py:13: error: Name 'QtWidgets.QSplitterHandle' is not defined
leo\plugins\editpane\clicky_splitter.py:25: error: Name 'QtWidgets.QSplitter' is not defined

leo\plugins\qt_text.py:416: error: Name 'QtWidgets.QFrame' is not defined
leo\plugins\qt_text.py:454: error: Name 'QtWidgets.QTextBrowser' is not defined
leo\plugins\qt_text.py:485: error: Name 'QtWidgets.QListWidget' is not defined
leo\plugins\qt_text.py:744: error: Name 'QtWidgets.QFrame' is not defined

leo\core\leoColorizer.py:23: error: No library stub file for module 'pygments'
leo\core\leoColorizer.py:339: error: Need type annotation for 'zoom_dict' (hint: "zoom_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2325: error: Name 'QtGui.QSyntaxHighlighter' is not defined
leo\core\leoColorizer.py:2457: error: No library stub file for module 'pygments.styles'
leo\core\leoColorizer.py:2492: error: Name 'Qsci.QsciLexerCustom' is not defined
leo\core\leoColorizer.py:2588: error: Need type annotation for 'traced_dict' (hint: "traced_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2618: error: Need type annotation for 'format_dict' (hint: "format_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2620: error: Need type annotation for 'lexers_dict' (hint: "lexers_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2622: error: Need type annotation for 'state_s_dict' (hint: "state_s_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2624: error: Need type annotation for 'state_n_dict' (hint: "state_n_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2690: error: No library stub file for module 'pygments.token'
leo\core\leoColorizer.py:2711: error: No library stub file for module 'pygments.lexers'
leo\core\leoColorizer.py:2730: error: No library stub file for module 'pygments.lexer'
leo\core\leoColorizer.py:3044: error: Name 'QtGui.QTextBlockUserData' is not defined
leo\core\leoColorizer.py:3064: error: Cannot assign to a type
leo\core\leoColorizer.py:3064: error: Incompatible types in assignment (expression has type "Type[NullObject]", variable has type "Type[PygmentsBlockUserData]")

leo\core\leoRst.py:20: error: "None" has no attribute "debug"
leo\core\leoRst.py:25: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:35: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:37: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:40: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:45: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:50: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:54: error: Cannot find module named 'SilverCity'
leo\core\leoRst.py:86: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "arguments"
leo\core\leoRst.py:92: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "options"
leo\core\leoRst.py:97: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "content"
leo\core\leoRst.py:101: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "options"
leo\core\leoRst.py:306: error: Argument 1 to "cmd" has incompatible type "str"; expected "RstCommands"
leo\core\leoRst.py:501: error: Argument 1 to "cmd" has incompatible type "str"; expected "RstCommands"

leo\core\leoPrinting.py:97: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:103: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:112: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:118: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:127: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:134: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:145: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:152: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:159: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:165: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:172: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:182: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:188: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:197: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:203: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:212: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:219: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:230: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:237: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:243: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:249: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:258: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"

leo\core\leoImport.py:16: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoImport.py:22: error: No library stub file for module 'lxml.html'
leo\core\leoImport.py:22: error: No library stub file for module 'lxml'

leo\core\leoFileCommands.py:1802: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"
leo\core\leoFileCommands.py:1810: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"
leo\core\leoFileCommands.py:1822: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"
leo\core\leoFileCommands.py:1829: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"

leo\core\leoKeys.py:196: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:218: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:223: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:229: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:235: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:241: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:247: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:253: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:259: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:274: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:538: error: Cannot find module named 'jedi'
leo\core\leoKeys.py:2335: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2477: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2551: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2581: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2602: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2623: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2632: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2641: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2650: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2797: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:3935: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:3943: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"

leo\commands\spellCommands.py:15: error: Cannot find module named 'enchant'
leo\commands\convertCommands.py:1598: error: No library stub file for module 'nbformat'

leo\core\leoAtFile.py:239: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:971: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:979: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:987: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:996: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:2306: error: No library stub file for standard library module 'parser'

leo\core\leoCommands.py:20: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoCommands.py:736: error: Cannot find module named '_pytest.config'
leo\core\leoCommands.py:737: error: Cannot find module named '_pytest.assertion.rewrite'
leo\core\leoCommands.py:1990: error: Need type annotation for 'deprecated_messages' (hint: "deprecated_messages: List[&lt;type&gt;] = ...")

leo\core\leoApp.py:1036: error: Cannot find module named 'flexx'
leo\core\leoApp.py:1443: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"
leo\core\leoApp.py:1444: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"
leo\core\leoApp.py:1591: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"
leo\core\leoApp.py:1592: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"

leo\plugins\editpane\editpane.py:10: error: Cannot find module named 'OpenGL'
leo\plugins\editpane\editpane.py:66: error: Name 'QtWidgets.QWidget' is not defined

leo\core\leoFrame.py:905: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:926: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:962: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:1030: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:1044: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"

leo\core\runLeo.py:17: error: Argument 1 to "join" has incompatible type "Optional[str]"; expected "Union[str, _PathLike[str]]"
leo\core\runLeo.py:28: error: Incompatible types in assignment (expression has type "LeoApp", variable has type "None")

leo\plugins\mod_scripting.py:459: error: Cannot find module named 'rpdb2'
leo\plugins\mod_scripting.py:504: error: Cannot find module named 'leo.core.leoScriptModule'
leo\plugins\mod_scripting.py:1204: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1240: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1295: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1319: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1338: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"

leo\plugins\qt_events.py:46: error: Name 'QtCore.QObject' is not defined

leo\core\leoTest.py:27: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoTest.py:1711: error: Need type annotation for 'lastObjectsDict' (hint: "lastObjectsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoTest.py:1712: error: Need type annotation for 'lastTypesDict' (hint: "lastTypesDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoTest.py:1713: error: Need type annotation for 'lastFunctionsDict' (hint: "lastFunctionsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")

leo\plugins\cursesGui2.py:39: error: Cannot assign to a type
leo\plugins\cursesGui2.py:39: error: Incompatible types in assignment (expression has type "None", variable has type "Type[Tk]")
leo\plugins\cursesGui2.py:48: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\plugins\cursesGui2.py:58: error: Cannot find module named 'npyscreen.utilNotify'
leo\plugins\cursesGui2.py:58: error: Cannot find module named 'npyscreen'
leo\plugins\cursesGui2.py:60: error: Cannot find module named 'npyscreen.wgwidget'
leo\plugins\cursesGui2.py:73: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:208: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:299: error: Name 'npyscreen.TreeData' is not defined
leo\plugins\cursesGui2.py:479: error: Name 'npyscreen.TreeLine' is not defined
leo\plugins\cursesGui2.py:699: error: Name 'npyscreen.MiniButtonPress' is not defined
leo\plugins\cursesGui2.py:1823: error: Need type annotation for 'set_focus_fail' (hint: "set_focus_fail: List[&lt;type&gt;] = ...")
leo\plugins\cursesGui2.py:2328: error: Argument 1 to "cmd" has incompatible type "str"; expected "CoreFrame"
leo\plugins\cursesGui2.py:2397: error: Argument 1 to "cmd" has incompatible type "str"; expected "CoreLog"
leo\plugins\cursesGui2.py:2724: error: Name 'npyscreen.NPSApp' is not defined
leo\plugins\cursesGui2.py:2741: error: Name 'npyscreen.MultiLineEditable' is not defined
leo\plugins\cursesGui2.py:2955: error: Name 'npyscreen.MultiLineEditable' is not defined
leo\plugins\cursesGui2.py:3103: error: Name 'npyscreen.Form' is not defined
leo\plugins\cursesGui2.py:3117: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:3276: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:3290: error: Name 'npyscreen.MLTree' is not defined
leo\plugins\cursesGui2.py:3952: error: Name 'npyscreen.TreeData' is not defined

leo\plugins\qt_frame.py:27: error: Cannot determine type of 'enabled'
leo\plugins\qt_frame.py:31: error: Cannot assign multiple types to name "splitter_class" without an explicit "Type[...]" annotation
leo\plugins\qt_frame.py:31: error: "None" has no attribute "QSplitter"
leo\plugins\qt_frame.py:38: error: Name 'QtWidgets.QMainWindow' is not defined
leo\plugins\qt_frame.py:1503: error: Name 'QtWidgets.QTabWidget' is not defined
leo\plugins\qt_frame.py:1737: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:1738: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:1793: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:1794: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:2490: error: Need type annotation for 'styleSheetCache' (hint: "styleSheetCache: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\plugins\qt_frame.py:3010: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3022: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3038: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3047: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3063: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3077: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3093: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3321: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtLog"
leo\plugins\qt_frame.py:3923: error: Name 'QtWidgets.QTreeWidget' is not defined
leo\plugins\qt_frame.py:4632: error: Name 'QtWidgets.QTabBar' is not defined
leo\plugins\qt_frame.py:4647: error: Name 'QtWidgets.QMenu' is not defined

leo\core\leoConfig.py:37: error: Need type annotation for 'settingsDict' (hint: "settingsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoConfig.py:2043: error: Need type annotation for 'no_menu_dict' (hint: "no_menu_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")

leo\plugins\leoflexx.py:39: error: Cannot find module named 'flexx'
leo\plugins\leoflexx.py:40: error: Cannot find module named 'pscript'
leo\plugins\leoflexx.py:1186: error: Need type annotation for 'attributes' (hint: "attributes: Set[&lt;type&gt;] = ...")

leo\plugins\qt_gui.py:618: error: Cannot find module named 'pyzo'
leo\plugins\qt_gui.py:619: error: Cannot find module named 'pyzo.core.menu'
leo\plugins\qt_gui.py:619: error: Cannot find module named 'pyzo.core'
leo\plugins\qt_gui.py:622: error: Cannot find module named 'pyzo.tools.pyzoFileBrowser'
leo\plugins\qt_gui.py:622: error: Cannot find module named 'pyzo.tools'
leo\plugins\qt_gui.py:627: error: Cannot find module named 'pyzo.core.main'
leo\plugins\qt_gui.py:989: error: Need type annotation for 'size_warnings' (hint: "size_warnings: List[&lt;type&gt;] = ...")
leo\plugins\qt_gui.py:1349: error: Name 'QtWidgets.QMessageBox' is not defined
leo\plugins\qt_gui.py:1487: error: No library stub file for module 'PyQt5.QtTest'
leo\plugins\qt_gui.py:1491: error: "None" has no attribute "QObject"
leo\plugins\qt_gui.py:1492: error: "None" has no attribute "QObject"
leo\plugins\qt_gui.py:1493: error: "None" has no attribute "QObject"

Found 360 errors in 40 files (checked 1 source file)
</t>
<t tx="ekr.20191029023442.1">@language rest
@wrap

A tutorial: (learn by doing: teacher guides)
    is learning-oriented
    allows the newcomer to get started
    is a lesson
    
A how-to guide: (recipe: users ask questions)
    is goal-oriented
    shows how to solve a specific problem
    is a series of steps

A reference guide:
    is information-oriented
    describes the machinery
    is accurate and complete

An explanation/discussion
    is understanding-oriented
    explains
    provides background and context</t>
<t tx="ekr.20191206073301.1">@language rest
@wrap

@clean and @auto may not always be updated reliably

https://github.com/leo-editor/leo-editor/issues/1451

#1361 may be the culprit
https://github.com/leo-editor/leo-editor/issues/1361

*** --trace=write

@language python
</t>
<t tx="ekr.20191207065251.1"></t>
<t tx="ekr.20200107165250.14">in_doc_part = False

def do_comment(self):
    """Handle a comment token."""
    val = self.val
    #
    # Leo-specific code...
    if self.node_pat.match(val):
        # Clear per-node state.
        self.in_doc_part = False
        self.verbatim = False
        self.decorator_seen = False
        # Do *not clear other state, which may persist across @others.
            # self.curly_brackets_level = 0
            # self.in_arg_list = 0
            # self.level = 0
            # self.lws = ''
            # self.paren_level = 0
            # self.square_brackets_stack = []
            # self.state_stack = []
    else:
        # Keep track of verbatim mode.
        if self.beautify_pat.match(val):
            self.verbatim = False
        elif self.nobeautify_pat.match(val):
            self.verbatim = True
        # Keep trace of @doc parts, to honor the convention for splitting lines.
        if self.start_doc_pat.match(val):
            self.in_doc_part = True
        if self.end_doc_pat.match(val):
            self.in_doc_part = False
    #
    # General code: Generate the comment.
    self.clean('blank')
    entire_line = self.line.lstrip().startswith('#')
    if entire_line:
        self.clean('hard-blank')
        self.clean('line-indent')
        # #1496: No further munging needed.
        val = self.line.rstrip()
    else:
        # Exactly two spaces before trailing comments.
        val = '  ' + self.val.rstrip()
    self.add_token('comment', val)
</t>
<t tx="ekr.20200212095937.1"></t>
<t tx="ekr.20200212095937.2">True:  allow joined lines to contain strings.
False: (Recommended by EKR): Retain alignment of strings.</t>
<t tx="ekr.20200212095937.3">True: Retain indentation of overindented stand-alone comment lines.</t>
<t tx="ekr.20200212095937.5"># At present I am of the opinion that joining lines is usually a bad idea.

Should be &lt;= beautify-max-split-line-length</t>
<t tx="ekr.20200212095937.6"></t>
<t tx="ekr.20200216063929.1">def test_regex_replace(self):
    # #1494.
    x = LeoFind(c=g.NullObject(tag='c'))
    groups = (r"f'", r"line\n")
    change_text = r"""\1 AA \2 BB \3'"""
    expected = r"""f' AA line\\n BB \3'"""
    result = x.makeRegexSubs(change_text, groups)
    assert result == expected, (expected, result)
</t>
<t tx="ekr.20200222083959.1">import logging
rootLogger = logging.getLogger('')
rootLogger.setLevel(logging.DEBUG)
socketHandler = logging.handlers.SocketHandler(
    'localhost',
    logging.handlers.DEFAULT_TCP_LOGGING_PORT,
)
rootLogger.addHandler(socketHandler)
logging.info('-' * 20)
</t>
<t tx="ekr.20200222151754.1">import yoton

# Create another context and a sub channel
ct2 = yoton.Context()
sub = yoton.SubChannel(ct2, 'chat')

# Connect
ct2.connect('publichost:test')

# Receive
while True:
    i = int(sub.recv())
    print(i)
    if i == 10:
        break
</t>
<t tx="ekr.20200304125716.1">def onContextMenu(self, c, w, point):
    """LeoQtGui: Common context menu handling."""
    # #1286.
    handlers = g.tree_popup_handlers
    menu = QtWidgets.QMenu()
    menuPos = w.mapToGlobal(point)
    if not handlers:
        menu.addAction("No popup handlers")
    p = c.p.copy()
    done = set()
    for handler in handlers:
        # every handler has to add it's QActions by itself
        if handler in done:
            # do not run the same handler twice
            continue
        try:
            handler(c, p, menu)
        except Exception:
            g.es_print('Exception executing right-click handler')
            g.es_exception()
    menu.popup(menuPos)
    self._contextmenu = menu
</t>
<t tx="ekr.20200304130514.1">def onContextMenu(self, point):
    """LeoQTextBrowser: Callback for customContextMenuRequested events."""
    # #1286.
    c, w = self.leo_c, self
    g.app.gui.onContextMenu(c, w, point)
</t>
<t tx="ekr.20200304132424.1">def onContextMenu(self, point):
    """LeoQtLog: Callback for customContextMenuRequested events."""
    # #1286.
    c, w = self.c, self
    g.app.gui.onContextMenu(c, w, point)
</t>
<t tx="ekr.20200304133109.1">def onContextMenuCallback(self, point):
    """LeoQtTree: Callback for customContextMenuRequested events."""
    # #1286.
    c = self.c
    w = self
    g.app.gui.onContextMenu(c, w, point)
</t>
<t tx="ekr.20200306043104.1">def import_txt_file(c, fn):
    """Import the .txt file into a new node."""
    u = c.undoer
    g.setGlobalOpenDir(fn)
    undoData = u.beforeInsertNode(c.p)
    last = c.lastTopLevel()
    p = last.insertAfter()
    p.h = f"@edit {fn}"
    s, e = g.readFileIntoString(fn, kind='@edit')
    p.b = s
    u.afterInsertNode(p, 'Import', undoData)
    c.setChanged()
    c.redraw(p)
</t>
<t tx="ekr.20200308193719.1">d = {}  # Keys are gnxs, values is a list of vnodes with that gnx.
for v in c.all_nodes():
    gnx = v.gnx
    aList = d.get(gnx, [])
    if v not in aList:
        aList.append(v)
        d [gnx] = aList
        if len(aList) &gt; 1:
            print(f"gnx clash: {gnx}")
            g.printObj(aList)
print('done')</t>
<t tx="ekr.20200401074555.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1557

Create mypy command?

@language python
</t>
<t tx="ekr.20200422075655.1">@g.commander_command('restart-leo')
def restartLeo(self, event=None):
    """Restart Leo, reloading all presently open outlines."""
    c, lm = self, g.app.loadManager
    trace = 'shutdown' in g.app.debug
    # 1. Write .leoRecentFiles.txt.
    g.app.recentFilesManager.writeRecentFilesFile(c)
    # 2. Abort the restart if the user veto's any close.
    for c in g.app.commanders():
        if c.changed:
            veto = False
            try:
                c.promptingForClose = True
                veto = c.frame.promptForSave()
            finally:
                c.promptingForClose = False
            if veto:
                g.es_print('Cancelling restart-leo command')
                return
    # 3. Officially begin the restart process. A flag for efc.ask.
    g.app.restarting = True  # #1240.
    # 4. Save session data.
    if g.app.sessionManager:
        g.app.sessionManager.save_snapshot()
    # 5. Close all unsaved outlines.
    g.app.setLog(None)  # Kill the log.
    for c in g.app.commanders():
        frame = c.frame
        # This is similar to g.app.closeLeoWindow.
        g.doHook("close-frame", c=c)
        # Save the window state
        g.app.commander_cacher.commit() # store cache, but don't close it.
        # This may remove frame from the window list.
        if frame in g.app.windowList:
            g.app.destroyWindow(frame)
            g.app.windowList.remove(frame)
        else:
            # #69.
            g.app.forgetOpenFile(fn=c.fileName(), force=True)
    # 6. Complete the shutdown.
    g.app.finishQuit()
    # 7. Restart, restoring the original command line.
    args = ['-c'] + [z for z in lm.old_argv]
    if trace: g.trace('restarting with args', args)
    sys.stdout.flush()
    sys.stderr.flush()
    os.execv(sys.executable, args)
</t>
<t tx="ekr.20200522075411.1">def doCommandByName(self, command_name, event):
    """
    Execute one command, given the name of the command.
    
    The caller must do any required keystroke-only tasks.
    
    Return the result, if any, of the command.
    """
    c = self
    # Get the command's function.
    command_func = c.commandsDict.get(command_name.replace('&amp;', ''))
    if not command_func:
        message = f"no command function for {command_name!r}"
        if g.app.unitTesting or g.app.inBridge:
            raise AttributeError(message)
        g.es_print(message, color='red')
        g.trace(g.callers())
        return None
    # Invoke the function.
    val = c.doCommand(command_func, command_name, event)
    if c.exists:
        c.frame.updateStatusLine()
    return val
</t>
<t tx="ekr.20200522082827.1"></t>
<t tx="ekr.20200523135601.1">def insertCharFromEvent(self, event):
    """
    Handle the character given by event, ignoring various special keys:
    - getArg state: k.getArg.
    - Tree: onCanvasKey or onHeadlineKey.
    - Body: ec.selfInsertCommand
    - Log: log_w.insert
    """
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    c, k, w = self, self.k, event.widget
    name = c.widget_name(w)
    stroke = event.stroke
    if trace: g.trace('stroke', stroke, 'plain:', k.isPlainKey(stroke), 'widget', name)
    if not stroke:
        return
    #
    # Part 1: Very late special cases.
    #
    # #1448
    if stroke.isNumPadKey() and k.state.kind == 'getArg':
        stroke.removeNumPadModifier()
        k.getArg(event, stroke=stroke)
        return
    # Handle all unbound characters in command mode.
    if k.unboundKeyAction == 'command':
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return
    #
    # Part 2: Filter out keys that should never be inserted by default.
    #
    # Ignore unbound F-keys.
    if stroke.isFKey():
        return
    # Ignore unbound Alt/Ctrl keys.
    if stroke.isAltCtrl():
        if not k.enable_alt_ctrl_bindings:
            return
        if k.ignore_unbound_non_ascii_keys:
            return
    # #868
    if stroke.isPlainNumPad():
        stroke.removeNumPadModifier()
        event.stroke = stroke
    # #868
    if stroke.isNumPadKey():
        return
    # Ignore unbound non-ascii character.
    if k.ignore_unbound_non_ascii_keys and not stroke.isPlainKey():
        return
    # Never insert escape or insert characters.
    if 'Escape' in stroke.s or 'Insert' in stroke.s:
        return
    #
    # Part 3: Handle the event depending on the pane and state.
    #
    # Handle events in the body pane.
    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
            c.frame.updateStatusLine()
        return
    #
    # Handle events in headlines.
    if name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return
    #
    # Handle events in the background tree (not headlines).
    if name.startswith('canvas'):
        if event.char:
            k.searchTree(event.char)
        # Not exactly right, but it seems to be good enough.
        elif not stroke:
            c.onCanvasKey(event)
        return
    #
    # Ignore all events outside the log pane.
    if not name.startswith('log'):
        return
    #
    # Make sure we can insert into w.
    log_w = event.widget
    if not hasattr(log_w, 'supportsHighLevelInterface'):
        return
    #
    # Send the event to the text widget, not the LeoLog instance.
    i = log_w.getInsertPoint()
    s = stroke.toGuiChar()
    log_w.insert(i, s)
</t>
<t tx="ekr.20200524151214.1"></t>
<t tx="ekr.20200727095246.1"></t>
<t tx="ekr.20200913074639.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1599

@language python
@nosearch
</t>
<t tx="ekr.20200913074701.1"># in appearance.py
# In effect, this is a subclass of QPlainTextEditor!

def paintEvent(self,event):
    """ paintEvent(event)

    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    super(IndentationGuides, self).paintEvent(event)

    if not self.showIndentationGuides():
        return

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    # Get multiplication factor and indent width
    indentWidth = self.indentWidth()
    if self.indentUsingSpaces():
        factor = 1
    else:
        factor = indentWidth

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    format = self.getStyleElementFormat('editor.IndentationGuides')
    pen = QtGui.QPen(format.fore)
    pen.setStyle(format.linestyle)
    painter.setPen(pen)
    offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        bd = cursor.block().userData()
        if bd and hasattr(bd, 'indentation') and bd.indentation:
            for x in range(indentWidth, bd.indentation * factor, indentWidth):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)

    # Done
    painter.end()
</t>
<t tx="ekr.20200913075121.1">def __init__(self,*args, **kwds):
    super(CodeEditorBase, self).__init__(*args)

    # Set font (always monospace)
    self.__zoom = 0
    self.setFont()

    # Create highlighter class
    self.__highlighter = Highlighter(self, self.document())

    # Set some document options
    option = self.document().defaultTextOption()
    option.setFlags(    option.flags() | option.IncludeTrailingSpaces |
                        option.AddSpaceForLineAndParagraphSeparators )
    self.document().setDefaultTextOption(option)

    # When the cursor position changes, invoke an update, so that
    # the hihghlighting etc will work
    self.cursorPositionChanged.connect(self.viewport().update)

    # Init styles to default values
    self.__style = {}
    for element in self.getStyleElementDescriptions():
        self.__style[element.key] = element.defaultFormat

    # Connext style update
    self.styleChanged.connect(self.__afterSetStyle)
    self.__styleChangedPending = False

    # Init margins
    self._leftmargins = []

    # Init options now.
    # NOTE TO PEOPLE DEVELOPING EXTENSIONS:
    # If an extension has an __init__ in which it first calls the
    # super().__init__, this __initOptions() function will be called,
    # while the extension's init is not yet finished.
    self.__initOptions(kwds)

    # Define colors from Solarized theme
    # NOTE TO PEOPLE WANTING CUSTOM COLORS: ignore this and check the
    # commented lines near the bottom of this method.
    base03  = "#002b36"
    base02  = "#073642"
    base01  = "#586e75"
    base00  = "#657b83"
    base0   = "#839496"
    base1   = "#93a1a1"
    base2   = "#eee8d5"
    base3   = "#fdf6e3"
    yellow  = "#b58900"
    orange  = "#cb4b16"
    red     = "#dc322f"  # noqa
    magenta = "#d33682"
    violet  = "#6c71c4"
    blue    = "#268bd2"
    cyan    = "#2aa198"
    green   = "#859900"  # noqa

    if 1: # EKR:patch: use a dark theme.
        back1, back2, back3 = base03, base02, base01
        fore1, fore2, fore3, fore4 = base0, base1, base2, base3  # noqa
    else:
        # Original code.
        #back1, back2, back3 = base3, base2, base1 # real solarised
        back1, back2, back3 = "#fff", base2, base1 # crispier
        fore1, fore2, fore3, fore4 = base00, base01, base02, base03

    # todo: proper testing of syntax style

    # Define style using "Solarized" colors
    S  = {}
    S["Editor.text"] = "back:%s, fore:%s" % (back1, fore1)
    S['Syntax.identifier'] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.nonidentifier"] = "fore:%s, bold:no, italic:no, underline:no" % fore2
    S["Syntax.keyword"] = "fore:%s, bold:yes, italic:no, underline:no" % fore2

    S["Syntax.builtins"] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.instance"] = "fore:%s, bold:no, italic:no, underline:no" % fore1

    S["Syntax.functionname"] = "fore:%s, bold:yes, italic:no, underline:no" % fore3
    S["Syntax.classname"] = "fore:%s, bold:yes, italic:no, underline:no" % orange

    S["Syntax.string"] = "fore:%s, bold:no, italic:no, underline:no" % violet
    S["Syntax.unterminatedstring"] = "fore:%s, bold:no, italic:no, underline:dotted" % violet
    S["Syntax.python.multilinestring"] = "fore:%s, bold:no, italic:no, underline:no" % blue

    S["Syntax.number"] = "fore:%s, bold:no, italic:no, underline:no" % cyan
    S["Syntax.comment"] = "fore:%s, bold:no, italic:no, underline:no" % yellow
    S["Syntax.todocomment"] = "fore:%s, bold:no, italic:yes, underline:no" % magenta
    S["Syntax.python.cellcomment"] = "fore:%s, bold:yes, italic:no, underline:full" % yellow

    S["Editor.Long line indicator"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Highlight current line"] = "back:%s" % back2
    S["Editor.Indentation guides"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Line numbers"] = "back:%s, fore:%s" % (back2, back3)

    # Define style using html color names. All 140 legal HTML colour
    # names can be used (in addition to HEX codes). A full list of
    # recognized colour names is available e.g. here
    # http://www.html-color-names.com/color-chart.php
#         S  = {}
#         S["Editor.text"] = "back: white, fore: black"
#         S['Syntax.identifier'] = "fore: black, bold:no, italic:no, underline:no"
#         S["Syntax.nonidentifier"] = "fore: blue, bold:no, italic:no, underline:no"
#         S["Syntax.keyword"] = "fore: blue, bold:yes, italic:no, underline:no"
#         S["Syntax.functionname"] = "fore: black, bold:yes, italic:no, underline:no"
#         S["Syntax.classname"] = "fore: magenta, bold:yes, italic:no, underline:no"
#         S["Syntax.string"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.unterminatedstring"] = "fore: red, bold:no, italic:no, underline:dotted"
#         S["Syntax.python.multilinestring"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.number"] = "fore: dark orange, bold:no, italic:no, underline:no"
#         S["Syntax.comment"] ="fore: green, bold:no, italic:yes, underline:no"
#         S["Syntax.todocomment"] = "fore: magenta, bold:no, italic:yes, underline:no"
#         S["Syntax.python.cellcomment"] = "fore: green, bold:yes, italic:no, underline:full"
#         S["Editor.Long line indicator"] = "linestyle:solid, fore: dark grey"
#         S["Editor.Highlight current line"] = "back: light grey"
#         S["Editor.Indentation guides"] = "linestyle:solid, fore: light grey"
#         S["Editor.Line numbers"] = "back: light grey, fore: black"

    # Apply style
    self.setStyle(S)
</t>
<t tx="ekr.20200913075250.1">def paintEvent(self, event):
    """
    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    ### super(IndentationGuides, self).paintEvent(event)
    super().paintEvent(event)
    return ###
    c = self.leo_c
    print('===== paintEvent', c.shortFileName())

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    ###
        # # Get multiplication factor and indent width
        # indentWidth = self.indentWidth()
        # if self.indentUsingSpaces():
            # factor = 1
        # else:
            # factor = indentWidth
    if c.tab_width &gt; 1: # Tabs
        ### editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
        ### editor.setIndentUsingSpaces(False)
        factor = 1
    else: # Spaces
        #### editor.setIndentWidth(indentWidth)
        ### editor.setIndentUsingSpaces(True)
        factor = 5 ### self.indentWidth()
    if 0:
        g.trace(factor)

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    if 1:
        pen = QtGui.QPen()
        pen.setWidthF(1)
        # pen.setColor(QtGui.QColor('red'))
        offset = 0 # doc.documentMargin() + self.contentOffset().x()
    else:
        format = self.getStyleElementFormat('editor.IndentationGuides')
        pen = QtGui.QPen(format.fore)
        pen.setStyle(format.linestyle) # QtCore.Qt.PenStyle.SolidLine
        painter.setPen(pen)
        offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        ### bd = cursor.block().userData()
        ### if bd and hasattr(bd, 'indentation') and bd.indentation:
        if True:
            ### for x in range(indentWidth, bd.indentation * factor, indentWidth):
            ### for x in range(5, 5*factor, 5):
            for x in (5, 10):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)
    # Done
    painter.end()
</t>
<t tx="ekr.20200913082124.1">def doForVisibleBlocks(self, function):
    """ doForVisibleBlocks(function)

    Call the given function(cursor) for all blocks that are currently
    visible. This is used by several appearence extensions that
    paint per block.

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    # Start cursor at top line.
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    cursor.movePosition(cursor.StartOfBlock)

    if not self.isVisible():
        return

    while True:
        # Call the function with a copy of the cursor
        function(QtGui.QTextCursor(cursor))

        # Go to the next block (or not if we are done)
        y = self.cursorRect(cursor).bottom()
        if y &gt; self.height():
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text
        cursor.movePosition(cursor.NextBlock)
</t>
<t tx="ekr.20200913082155.1">def doForVisibleBlocks(self, function):
    """ doForVisibleBlocks(function)

    Call the given function(cursor) for all blocks that are currently
    visible. This is used by several appearence extensions that
    paint per block.

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    # Start cursor at top line.
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    cursor.movePosition(cursor.StartOfBlock)

    if not self.isVisible():
        return

    while True:
        # Call the function with a copy of the cursor
        function(QtGui.QTextCursor(cursor))

        # Go to the next block (or not if we are done)
        y = self.cursorRect(cursor).bottom()
        if y &gt; self.height():
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text
        cursor.movePosition(cursor.NextBlock)
</t>
<t tx="ekr.20200914071303.1">def paintEvent(self, event):
    """
    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    ### super(IndentationGuides, self).paintEvent(event)
    super().paintEvent(event)
    return ###
    c = self.leo_c
    print('===== paintEvent', c.shortFileName())

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    ###
        # # Get multiplication factor and indent width
        # indentWidth = self.indentWidth()
        # if self.indentUsingSpaces():
            # factor = 1
        # else:
            # factor = indentWidth
    if c.tab_width &gt; 1: # Tabs
        ### editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
        ### editor.setIndentUsingSpaces(False)
        factor = 1
    else: # Spaces
        #### editor.setIndentWidth(indentWidth)
        ### editor.setIndentUsingSpaces(True)
        factor = 5 ### self.indentWidth()
    if 0:
        g.trace(factor)

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    if 1:
        pen = QtGui.QPen()
        pen.setWidthF(1)
        # pen.setColor(QtGui.QColor('red'))
        offset = 0 # doc.documentMargin() + self.contentOffset().x()
    else:
        format = self.getStyleElementFormat('editor.IndentationGuides')
        pen = QtGui.QPen(format.fore)
        pen.setStyle(format.linestyle) # QtCore.Qt.PenStyle.SolidLine
        painter.setPen(pen)
        offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        ### bd = cursor.block().userData()
        ### if bd and hasattr(bd, 'indentation') and bd.indentation:
        if True:
            ### for x in range(indentWidth, bd.indentation * factor, indentWidth):
            ### for x in range(5, 5*factor, 5):
            for x in (5, 10):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)
    # Done
    painter.end()
</t>
<t tx="ekr.20200918085543.3">def ns_provide(self, id_):
    global controllers, layouts
    # #1678: duplicates in Open Window list
    if id_ == self.ns_provider_id():
        c = self.c
        h = c.hash()
        vr3 = controllers.get(h) or ViewRenderedController3(c)
        controllers[h] = vr3
        if not layouts.get(h):
            layouts[h] = c.db.get(VR3_DEF_LAYOUT, (None, None))
        return vr3
    return None
</t>
<t tx="ekr.20200918085543.5">def ns_provides(self):
    # #1671: Better Window names.
    # #1678: duplicates in Open Window list
    return [('Viewrendered 3', self.ns_provider_id())]
</t>
<t tx="ekr.20201012111545.1">@language python
@tabwidth -4
@pagewidth 80
</t>
<t tx="ekr.20201012111649.1">gnx: ekr.20170925083314.1
</t>
<t tx="ekr.20201012111649.3">gnx: ekr.20170925083853.1
</t>
<t tx="ekr.20201012114516.1">@nosearch</t>
<t tx="ekr.20201012142922.2">gnx: ekr.20201012111338.43
unl: Declarations (leo_cloud_server.py)
</t>
<t tx="ekr.20201013034659.1"></t>
<t tx="ekr.20201013034742.1"></t>
<t tx="ekr.20201013034742.10"># These can be overridden in subclasses.
</t>
<t tx="ekr.20201013034742.11">### Define an override if desired...

if 0: # The base class
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        return s.strip()
        
if 0: # A more complex example, for the C language.
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        import re
        type1 = r'(static|extern)*'
        type2 = r'(void|int|float|double|char)*'
        class_pattern = r'\s*(%s)\s*class\s+(\w+)' % (type1)
        pattern = r'\s*(%s)\s*(%s)\s*(\w+)' % (type1, type2)
        m = re.match(class_pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            return '%sclass %s' % (prefix1, m.group(2))
        m = re.match(pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            prefix2 = '%s ' % (m.group(2)) if m.group(2) else ''
            h = m.group(3) or '&lt;no c function name&gt;'
            return '%s%s%s' % (prefix1, prefix2, h)
        else:
            return s
</t>
<t tx="ekr.20201013034742.12">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an examplle.
    '''
    pass
</t>
<t tx="ekr.20201013034742.13">class {{cap_name}}_ScanState:
    '''A class representing the state of the {{name}} line-oriented scan.'''
    
    def __init__(self, d=None):
        '''{{cap_name}}_ScanState.__init__'''
        if d:
            prev = d.get('prev')
            self.context = prev.context
            ### Adjust these by hand.
            self.curlies = prev.curlies
        else:
            self.context = ''
            ### Adjust these by hand.
            self.curlies = 0

    def __repr__(self):
        '''{{cap_name}}_ScanState.__repr__'''
        ### Adjust these by hand.
        return "{{cap_name}}_ScanState context: %r curlies: %s" % (
            self.context, self.curlies)

    __str__ = __repr__

    @others
</t>
<t tx="ekr.20201013034742.14">def level(self):
    '''{{cap_name}}_ScanState.level.'''
    return {{state_ivar}}

</t>
<t tx="ekr.20201013034742.15">def update(self, data):
    '''
    {{cap_name}}_ScanState.update

    Update the state using the 6-tuple returned by v2_scan_line.
    Return i = data[1]
    '''
    context, i, delta_c, delta_p, delta_s, bs_nl = data
    # All ScanState classes must have a context ivar.
    self.context = context
    self.curlies += delta_c  
    ### Update {{cap_name}}_ScanState ivars
    # self.bs_nl = bs_nl
    # self.parens += delta_p
    # self.squares += delta_s
    return i
</t>
<t tx="ekr.20201013034742.16">'''Converts the word at the cursor to pep8 style throughout a given tree.'''
# aTestExample notFoundExample.
import re
# clear()
table = (
    # 'BLS.new_scan',
    # 'BLS.Code generation',
    # 'class Importer',
)
@others
Pep8(table, change=True).run()
</t>
<t tx="ekr.20201013034742.17">class Pep8:
    '''
    Convert the word under the cursor to pep8 style in all subtrees in
    table.
    '''
    
    def __init__ (self, table, change=False):
        '''Ctor for Pep8 class.'''
        self.change = change
        self.table = table
        
    @others
</t>
<t tx="ekr.20201013034742.18">def change_all(self, name, new_name, root):
    '''Change name to new_name throughout root's tree.'''
    u = c.undoer
    bunch = u.beforeChangeTree(root)
    found = False
    self.pattern = re.compile(r'\b%s\b' % name)
    for p in root.self_and_subtree():
        found = self.change_headline(name, new_name, p) or found
        found = self.change_body(name, new_name, p) or found
    if found:
        u.afterChangeTree(root, 'pep8', bunch)
    return found
</t>
<t tx="ekr.20201013034742.19">def change_body(self, name, new_name, p):
    indices = []
    for m in self.pattern.finditer(p.b):
        indices.append(str(m.start()))
    if indices:
        n = len(indices)
        g.es_print('%s change%s: %s' % (n, g.plural(n), p.h))
        s = p.b
        for i in reversed(indices):
            i = int(i)
            s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.b = s
            p.setDirty()
        else:
            g.es_print(s)
    return bool(indices)</t>
<t tx="ekr.20201013034742.2">g.cls()
# define constants that describe the new language.
name = 'php'
    # The name of the file, and the prefix for classes.
language = 'php'
    # The name of the language, case doesn't matter.
extensions = ['.php',]
    # A list of file extensions supported by this importer.
strict = False
    # True if leading whitespace is particularly significant.
state_ivar = 'self.curlies'
    # 'self.indent' for python, coffeescript.
    # 'self.curlies' for many other languages
    # '(self, curlies, self.parens)' for more complex comparisons
&lt;&lt; define run &amp; helpers &gt;&gt;
run(extensions, language, name, state_ivar)
</t>
<t tx="ekr.20201013034742.20">def change_headline(self, name, new_name, p):
    m = self.pattern.search(p.h)
    if m:
        i = m.start()
        s = p.h
        s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.h = s
            p.setDirty()
            g.es_print('changed headline', s)
        else:
            g.es_print('headline', s)
    return bool(m)
</t>
<t tx="ekr.20201013034742.21">def get_name(self):
    i, j = c.editCommands.extendToWord(event=None, select=False)
    w = c.frame.body.wrapper
    s = w.getAllText()
    name = s[i:j]
    return name
</t>
<t tx="ekr.20201013034742.22">def run(self):
    # self.clear()
    name = self.get_name()
    new_name = self.to_pep8(name)
    if len(name) &lt; 2:
        g.es_print('name too short:', name)
    elif new_name == name:
        g.es_print('already pep8:', name)
    else:
        g.es_print('%s -&gt; %s' % (name, new_name))
        c.findCommands.ftm.setFindText(new_name)
            # Preload the replacement text.
        found = False
        for target in table:
            root = g.findNodeAnywhere(c, target)
            if root:
                found = self.change_all(name, new_name, root) or found
            else:
                g.es_print('not found: %s' % target)
        if found:
            c.redraw()
        else:
            g.es_print('not found:', name)
</t>
<t tx="ekr.20201013034742.23">def to_pep8(self, s):
    
    if len(s) &gt; 1 and s[0].islower() and s.lower() != s:
        result = []
        for ch in s:
            result.append(ch)
            if ch.isupper():
                result.pop()
                result.append('_%s' % (ch.lower()))
        return ''.join(result)
    else:
        return name</t>
<t tx="ekr.20201013034742.24">def clear():
    g.cls()
    c.k.simulateCommand('clear-log')
</t>
<t tx="ekr.20201013034742.25"># g.cls()
import re
import sys
if 1:
    h = 'import-neural-networks.ipynb'
    fn = r'c:\test\export-neural-networds.ipynb'
else:
    h = 'import-Julia.ipynb'
    fn = r'c:\test\export-julia.ipynb'
p = g.findTopLevelNode(c, h)
assert p, h
@others
Export_IPYNB(c).export_outline(p, fn=fn)
</t>
<t tx="ekr.20201013034742.26">'''Imports c:\prog\Julia.ipynb to the node import-Julia.ipynb'''
import nbformat
@others
g.cls()
if 0:
    # fn = r'c:\test\Julia.ipynb'
    fn = r'c:\test\export-neural-networds.ipynb'
    h = 'import-Julia.ipynb'
else:
    h = fn = r'c:\test\04_Neural_Networks.ipynb'
root = g.findTopLevelNode(c, h)
if root:
    while root.hasChildren():
        root.lastChild().doDelete()
else:
    p = c.lastTopLevel()
    root = p.insertAfter()
    root.h = h
x = Import_IPYNB(c)
x.import_file(fn, root)
if not g.unitTesting:
    # These don't work when running unit tests.
    c.selectPosition(root)
    # c.expandAllSubheads()
    c.redraw() 
    g.es_print('done')
</t>
<t tx="ekr.20201013034742.3">@others</t>
<t tx="ekr.20201013034742.4">def copy_tree(source, root, h):
    '''Copy the source tree to the node after p, with headline h.'''
    p2 = root.insertAfter()
    source.copyTreeFromSelfTo(p2)
    p2.h = h
    return p2
 </t>
<t tx="ekr.20201013034742.5">def make_substitutions(destination, patterns):
    '''Make all substitutions in the destination tree.'''
    for p in destination.self_and_subtree():
        h = substitute(p.h, patterns)
        if p.h != h:
            # g.trace('CHANGED:', p.h, '==&gt;', h)
            p.h = h
        b = substitute(p.b, patterns)
        if p.b != b:
            # g.trace('CHANGED:', p.b, '==&gt;', b)
            p.b = b
</t>
<t tx="ekr.20201013034742.6">def run(extensions, language, name, state_ivar):
    '''The driver for this script.'''
    patterns = {
        'cap_name': name.capitalize(),
        'extensions': '[%s]' % ', '.join(["'%s'" % (z) for z in extensions]),
        'language': language.lower(),
        'name': name.lower(),
        'strict': 'True' if strict else 'False',
        'state_ivar': state_ivar,
    }
    h = '@button make-importer'
    root = g.findNodeAnywhere(c, h)
    assert root, h
    h = '@@file importers/{{name}}.py'
    source = g.findNodeInTree(c, root, h)
    assert source, h
    destination = copy_tree(source, root, h)
    make_substitutions(destination, patterns)
    c.contractAllHeadlines()
    c.redraw()</t>
<t tx="ekr.20201013034742.7">def substitute(s, patterns):
    '''Make all substitutions in s.'''
    for pattern in patterns:
        find = '{{%s}}' % pattern
        replace = patterns.get(pattern)
        i = 0
        while i &lt; len(s):
            progress = i
            j = s.find(find, i)
            if j == -1: break
            s = s[:j] + replace + s[j+len(find):]
            i = j+len(replace)
            assert progress &lt; i
    return s
</t>
<t tx="ekr.20201013034742.8">'''The @auto importer for the {{name}} language.'''
import leo.plugins.importers.linescanner as linescanner
Importer = linescanner.Importer
@others
importer_dict = {
    'class': {{cap_name}}_Importer,
    'extensions': {{extensions}},
}
@language python
@tabwidth -4


</t>
<t tx="ekr.20201013034742.9">class {{cap_name}}_Importer(Importer):
    '''The importer for the {{name}} lanuage.'''

    def __init__(self, importCommands, atAuto):
        '''{{cap_name}}_Importer.__init__'''
        # Init the base class.
        Importer.__init__(self,
            importCommands,
            atAuto = atAuto,
            language = '{{language}}',
            state_class = {{cap_name}}_ScanState,
            strict = {{strict}},
        )
        
    @others
</t>
<t tx="ekr.20201015145257.1">import leo.core.leoImport as leoImport
import importlib
importlib.reload(leoImport)
g.cls()
# Change path as necessary.
path = r'c:\users\edreamleo\lsa.py'
assert g.os_path_exists(path)
x = leoImport.LegacyExternalFileImporter(c)
x.import_file(path)
</t>
<t tx="ekr.20201018062305.1">"""Update LeoPyRef.leo from the given list of nodes."""
import os
@others
main(node_list = ['Startup', 'Notes', 'Code'])
</t>
<t tx="ekr.20201018063747.1">def get_content(positions_list):
    """
    Return the desired contents of leoPyRef.leo.
    
    Based on code by  .
    """
    # Make only one copy for all calls.
    fc = c.fileCommands
    fc.currentPosition = c.p
    fc.rootPosition = c.rootPosition()
    fc.vnodesDict = {}
    # Put the file
    fc.outputFile = g.FileLikeObject()
    fc.putProlog()
    fc.putHeader()
    fc.putGlobals()
    fc.putPrefs()
    fc.putFindSettings()
    fc.put("&lt;vnodes&gt;\n")
    for p in positions_list:
        # An optimization: Write the next top-level node.
        fc.putVnode(p, isIgnore=p.isAtIgnoreNode())
    fc.put("&lt;/vnodes&gt;\n")
    fc.putTnodes()
    fc.putPostlog()
    return fc.outputFile.getvalue()
</t>
<t tx="ekr.20201018065757.1">def check_file_names():
    """Return True if leoPyRef exists and we are running from leoPy.leo."""
    if not 'leoPy.leo' in c.shortFileName():
        oops('Run this script only from leoPy.leo')
        return None
    fileName = g.os_path_finalize_join(g.app.loadDir, '..', 'core', 'leoPyRef.leo')
    if not os.path.exists(fileName):
        oops(f"Not found: {fileName}")
        return None
    return fileName</t>
<t tx="ekr.20201018065921.1">def check_nodes(node_list):
    """Return True if all nodes are found."""
    result = []
    for node in node_list:
        p = g.findTopLevelNode(c, node, exact=True)
        if p:
            result.append(p.copy())
        else:
            oops(f"Top-level node {node} not found")
            return []
    return result</t>
<t tx="ekr.20201018070822.1">def main(node_list):
    """The main line."""
    c.endEditing()
    fileName = check_file_names()
    if not fileName:
        return
    positions_list = check_nodes(node_list)
    if not positions_list:
        return
    content = get_content(positions_list)
    with open(fileName, 'w', encoding="utf-8", newline='\n') as f:
        f.write(content)
    print('')
    g.es_print(f"Updated {g.shortFileName(fileName)}")
</t>
<t tx="ekr.20201018072911.1">def oops(message):
    """Print an error message"""
    print('')
    g.es_print(message)
    print('')</t>
<t tx="ekr.20201021075956.1"># Leo colorizer control file for php mode.
# This file is in the public domain.

# **Important**: this file was **not** generated by jEdit2py.
# It contains "by-hand" changes at the end of the file marked with "EKR".

@others
if use_php_hack:
    # EKR: in effect: we replace the php_main state by the php_php state.
    # php_main_keywords_dict = php_php_keywords_dict
    rulesDictDict['php_main'] = rulesDict4 # EKR: was php_rulesDict1
@language python
@tabwidth -4
</t>
<t tx="ekr.20201021093630.1"></t>
<t tx="ekr.20201022053829.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1718

@language python
@nosearch
</t>
<t tx="ekr.20201022053907.1"># Leo colorizer control file for php mode.
# This file is in the public domain.

# **Important**: this file was **not** generated by jEdit2py.
# It contains "by-hand" changes by EKR.
&lt;&lt; Attribute dicts &gt;&gt;
&lt;&lt; Keyword dicts &gt;&gt;
@others
&lt;&lt; rulesDictDict &gt;&gt;
# Import dict for php mode.
importDict = {
    "php_javascript_php": ["javascript::main",],
}
if False:
    # EKR: in effect: we replace the php_main state by the php_php state.
    # php_main_keywords_dict = php_php_keywords_dict
    rulesDictDict['php_main'] = php_php_rulesdict

@language python
@tabwidth -4
</t>
<t tx="ekr.20201022053907.10">def php_php_function_rule(colorer, s, i):
    return colorer.match_mark_previous(s, i, kind="function", pattern="(",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

def php_php_keyword_rule1(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

def php_php_keyword_rule2(colorer, s, i):
    return colorer.match_keywords(s, i)
</t>
<t tx="ekr.20201022053907.11">def php_php_op1(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op2(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op3(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="!",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op4(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op5(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op6(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op7(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="+",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op8(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op9(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op10(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op11(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op12(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op13(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="%",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op14(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&amp;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op15(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="|",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op16(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="^",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op17(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="~",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op18(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=".",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op19(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="}",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op20(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op21(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=",",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op22(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op23(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="]",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op24(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="[",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op25(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="?",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op26(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="@",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op27(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=":",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
</t>
<t tx="ekr.20201022053907.12"># Rules dict for php_php ruleset.
php_php_rulesdict = {
    "!": [php_php_op3],
    "\"": [php_php_literal1],
    "#": [php_php_comment4],
    "$": [php_php_keyword_rule1],
    "%": [php_php_op13],
    "&amp;": [php_php_op14],
    "'": [php_php_literal2],
    "(": [php_php_function_rule],
    "*": [php_php_op10],
    "+": [php_php_op7],
    ",": [php_php_op21],
    "-": [php_php_op2, php_php_op8],
    ".": [php_php_op18],
    "/": [php_php_comment1, php_php_comment2, php_php_comment3, php_php_op9],
    "0": [php_php_keyword_rule2],
    "1": [php_php_keyword_rule2],
    "2": [php_php_keyword_rule2],
    "3": [php_php_keyword_rule2],
    "4": [php_php_keyword_rule2],
    "5": [php_php_keyword_rule2],
    "6": [php_php_keyword_rule2],
    "7": [php_php_keyword_rule2],
    "8": [php_php_keyword_rule2],
    "9": [php_php_keyword_rule2],
    ":": [php_php_op27],
    ";": [php_php_op22],
    "&lt;": [php_php_op5, php_php_op12],
    "&lt; ": [php_php_literal4],
    "=": [php_php_op1, php_php_op6],
    "&gt;": [php_php_op4, php_php_op11],
    "?": [php_php_op25],
    "@": [php_php_op26, php_php_keyword_rule2],
    "A": [php_php_keyword_rule2],
    "B": [php_php_keyword_rule2],
    "C": [php_php_keyword_rule2],
    "D": [php_php_keyword_rule2],
    "E": [php_php_keyword_rule2],
    "F": [php_php_keyword_rule2],
    "G": [php_php_keyword_rule2],
    "H": [php_php_keyword_rule2],
    "I": [php_php_keyword_rule2],
    "J": [php_php_keyword_rule2],
    "K": [php_php_keyword_rule2],
    "L": [php_php_keyword_rule2],
    "M": [php_php_keyword_rule2],
    "N": [php_php_keyword_rule2],
    "O": [php_php_keyword_rule2],
    "P": [php_php_keyword_rule2],
    "Q": [php_php_keyword_rule2],
    "R": [php_php_keyword_rule2],
    "S": [php_php_keyword_rule2],
    "T": [php_php_keyword_rule2],
    "U": [php_php_keyword_rule2],
    "V": [php_php_keyword_rule2],
    "W": [php_php_keyword_rule2],
    "X": [php_php_keyword_rule2],
    "Y": [php_php_keyword_rule2],
    "Z": [php_php_keyword_rule2],
    "[": [php_php_op24],
    "]": [php_php_op23],
    "^": [php_php_op16],
    "_": [php_php_keyword_rule2],
    "`": [php_php_literal3],
    "a": [php_php_keyword_rule2],
    "b": [php_php_keyword_rule2],
    "c": [php_php_keyword_rule2],
    "d": [php_php_keyword_rule2],
    "e": [php_php_keyword_rule2],
    "f": [php_php_keyword_rule2],
    "g": [php_php_keyword_rule2],
    "h": [php_php_keyword_rule2],
    "i": [php_php_keyword_rule2],
    "j": [php_php_keyword_rule2],
    "k": [php_php_keyword_rule2],
    "l": [php_php_keyword_rule2],
    "m": [php_php_keyword_rule2],
    "n": [php_php_keyword_rule2],
    "o": [php_php_keyword_rule2],
    "p": [php_php_keyword_rule2],
    "q": [php_php_keyword_rule2],
    "r": [php_php_keyword_rule2],
    "s": [php_php_keyword_rule2],
    "t": [php_php_keyword_rule2],
    "u": [php_php_keyword_rule2],
    "v": [php_php_keyword_rule2],
    "w": [php_php_keyword_rule2],
    "x": [php_php_keyword_rule2],
    "y": [php_php_keyword_rule2],
    "z": [php_php_keyword_rule2],
    "{": [php_php_op20],
    "|": [php_php_op15],
    "}": [php_php_op19],
    "~": [php_php_op17],
}
</t>
<t tx="ekr.20201022053907.13"># Rules for the php_php_literal ruleset.

def php_php_literal_rule1(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

# Rules dict for php_php_literal ruleset.
php_php_literal_rulesdict = {
    "$": [php_php_literal_rule1],
}
</t>
<t tx="ekr.20201022053907.14"># Rules for the php_javascript_php ruleset...

def php_javascript_php_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_javascript_php_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_javascript_php_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

# Rules dict for php_javascript_php ruleset.
php_javascript_php_rulesdict = {
    "&lt;": [
        php_javascript_php_rule1,
        php_javascript_php_rule2,
        php_javascript_php_rule3],
}
</t>
<t tx="ekr.20201022053907.15"># Rules for the php_javascript ruleset...

def php_rule58(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::javascript+php")

def php_rule59(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="SRC=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::back_to_html")

# Rules dict for php_javascript ruleset.
php_javascript_rulesdict = {
    "&gt;": [php_rule58],
    "S": [php_rule59],
}

</t>
<t tx="ekr.20201022053907.16">def phpdoc_rule1(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def phpdoc_rule2(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def phpdoc_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def phpdoc_rule4(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def phpdoc_rule5(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
        
def phpdoc_rule6(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt; ",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
        
def phpdoc_rule7(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::tags",exclude_match=False,
        no_escape=False, no_line_break=True, no_word_break=False)
        
def phpdoc_rule8(colorer, s, i):
    return colorer.match_keywords(s, i)
    
# Rules dict for php_phpdoc ruleset.
phpdoc_rulesdict = {
    "*": [phpdoc_rule2],
    "0": [phpdoc_rule8],
    "1": [phpdoc_rule8],
    "2": [phpdoc_rule8],
    "3": [phpdoc_rule8],
    "4": [phpdoc_rule8],
    "5": [phpdoc_rule8],
    "6": [phpdoc_rule8],
    "7": [phpdoc_rule8],
    "8": [phpdoc_rule8],
    "9": [phpdoc_rule8],
    "&lt;": [phpdoc_rule3,phpdoc_rule4,phpdoc_rule5,phpdoc_rule6,phpdoc_rule7],
    "@": [phpdoc_rule8],
    "A": [phpdoc_rule8],
    "B": [phpdoc_rule8],
    "C": [phpdoc_rule8],
    "D": [phpdoc_rule8],
    "E": [phpdoc_rule8],
    "F": [phpdoc_rule8],
    "G": [phpdoc_rule8],
    "H": [phpdoc_rule8],
    "I": [phpdoc_rule8],
    "J": [phpdoc_rule8],
    "K": [phpdoc_rule8],
    "L": [phpdoc_rule8],
    "M": [phpdoc_rule8],
    "N": [phpdoc_rule8],
    "O": [phpdoc_rule8],
    "P": [phpdoc_rule8],
    "Q": [phpdoc_rule8],
    "R": [phpdoc_rule8],
    "S": [phpdoc_rule8],
    "T": [phpdoc_rule8],
    "U": [phpdoc_rule8],
    "V": [phpdoc_rule8],
    "W": [phpdoc_rule8],
    "X": [phpdoc_rule8],
    "Y": [phpdoc_rule8],
    "Z": [phpdoc_rule8],
    "_": [phpdoc_rule8],
    "a": [phpdoc_rule8],
    "b": [phpdoc_rule8],
    "c": [phpdoc_rule8],
    "d": [phpdoc_rule8],
    "e": [phpdoc_rule8],
    "f": [phpdoc_rule8],
    "g": [phpdoc_rule8],
    "h": [phpdoc_rule8],
    "i": [phpdoc_rule8],
    "j": [phpdoc_rule8],
    "k": [phpdoc_rule8],
    "l": [phpdoc_rule8],
    "m": [phpdoc_rule8],
    "n": [phpdoc_rule8],
    "o": [phpdoc_rule8],
    "p": [phpdoc_rule8],
    "q": [phpdoc_rule8],
    "r": [phpdoc_rule8],
    "s": [phpdoc_rule8],
    "t": [phpdoc_rule8],
    "u": [phpdoc_rule8],
    "v": [phpdoc_rule8],
    "w": [phpdoc_rule8],
    "x": [phpdoc_rule8],
    "y": [phpdoc_rule8],
    "z": [phpdoc_rule8],
    "{": [phpdoc_rule1],
}
</t>
<t tx="ekr.20201022053907.17"># rulesDictDict for php mode.
rulesDictDict = {
    "php_javascript": php_javascript_rulesdict,
    "php_javascript_php": php_javascript_php_rulesdict,
    "php_main": php_main_rulesdict,
    "php_php": php_php_rulesdict,
    "php_php_literal": php_php_literal_rulesdict,
    "php_phpdoc": phpdoc_rulesdict,
    "php_tags": php_tags_rulesdict,
    "php_tags_literal": php_tags_literal_rulesdict,
}
</t>
<t tx="ekr.20201022053907.2">

# Properties for php mode.
properties = {
    "commentEnd": "--&gt;",
    "commentStart": "&lt;!--",
    "indentCloseBrackets": "}",
    "indentOpenBrackets": "{",
    "lineUpClosingBracket": "true",
}

# Attributes dict for php_main ruleset.
php_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags ruleset.
php_tags_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags_literal ruleset.
php_tags_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php ruleset.
php_php_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php_literal ruleset.
php_php_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript ruleset.
php_javascript_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript_php ruleset.
php_javascript_php_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_phpdoc ruleset.
php_phpdoc_attributes_dict = {
    "default": "COMMENT3",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Dictionary of attributes dictionaries for php mode.
attributesDictDict = {
    "php_javascript": php_javascript_attributes_dict,
    "php_javascript_php": php_javascript_php_attributes_dict,
    "php_main": php_main_attributes_dict,
    "php_php": php_php_attributes_dict,
    "php_php_literal": php_php_literal_attributes_dict,
    "php_phpdoc": php_phpdoc_attributes_dict,
    "php_tags": php_tags_attributes_dict,
    "php_tags_literal": php_tags_literal_attributes_dict,
}
</t>
<t tx="ekr.20201022053907.3"># Keywords dict for php_main ruleset.
php_main_keywords_dict = {}

# Keywords dict for php_tags ruleset.
php_tags_keywords_dict = {}

# Keywords dict for php_tags_literal ruleset.
php_tags_literal_keywords_dict = {}

# Keywords dict for php_php ruleset.
php_php_keywords_dict = {
    "__class__": "keyword3",
    "__file__": "keyword3",
    "__function__": "keyword3",
    "__line__": "keyword3",
    "__method__": "keyword3",
    "abs": "keyword2",
    "abstract": "keyword1",
    "accept_connect": "keyword2",
    "acos": "keyword2",
    "add": "keyword2",
    "add_iovec": "keyword2",
    "addaction": "keyword2",
    "addcolor": "keyword2",
    "addcslashes": "keyword2",
    "addentry": "keyword2",
    "addfill": "keyword2",
    "addshape": "keyword2",
    "addslashes": "keyword2",
    "addstring": "keyword2",
    "align": "keyword2",
    "and": "operator",
    "apache_child_terminate": "keyword2",
    "apache_lookup_uri": "keyword2",
    "apache_note": "keyword2",
    "apache_sub_req": "keyword2",
    "array": "keyword1",
    "array_combine": "keyword2",
    "array_count_values": "keyword2",
    "array_diff": "keyword2",
    "array_diff_assoc": "keyword2",
    "array_diff_uassoc": "keyword2",
    "array_filter": "keyword2",
    "array_flip": "keyword2",
    "array_intersect": "keyword2",
    "array_intersect_assoc": "keyword2",
    "array_keys": "keyword2",
    "array_map": "keyword2",
    "array_merge": "keyword2",
    "array_merge_recursive": "keyword2",
    "array_multisort": "keyword2",
    "array_pad": "keyword2",
    "array_pop": "keyword2",
    "array_push": "keyword2",
    "array_rand": "keyword2",
    "array_reduce": "keyword2",
    "array_reverse": "keyword2",
    "array_search": "keyword2",
    "array_shift": "keyword2",
    "array_slice": "keyword2",
    "array_splice": "keyword2",
    "array_sum": "keyword2",
    "array_udiff": "keyword2",
    "array_udiff_assoc": "keyword2",
    "array_udiff_uassoc": "keyword2",
    "array_unique": "keyword2",
    "array_unshift": "keyword2",
    "array_values": "keyword2",
    "array_walk": "keyword2",
    "array_walk_recursive": "keyword2",
    "arsort": "keyword2",
    "as": "keyword1",
    "asin": "keyword2",
    "asort": "keyword2",
    "aspell_check": "keyword2",
    "aspell_check_raw": "keyword2",
    "aspell_new": "keyword2",
    "aspell_suggest": "keyword2",
    "assert": "keyword2",
    "assert_options": "keyword2",
    "atan": "keyword2",
    "atan2": "keyword2",
    "base64_decode": "keyword2",
    "base64_encode": "keyword2",
    "base_convert": "keyword2",
    "basename": "keyword2",
    "bcadd": "keyword2",
    "bccomp": "keyword2",
    "bcdiv": "keyword2",
    "bcmod": "keyword2",
    "bcmul": "keyword2",
    "bcpow": "keyword2",
    "bcscale": "keyword2",
    "bcsqrt": "keyword2",
    "bcsub": "keyword2",
    "bin2hex": "keyword2",
    "bind": "keyword2",
    "bindec": "keyword2",
    "bindtextdomain": "keyword2",
    "break": "keyword1",
    "build_iovec": "keyword2",
    "bzclose": "keyword2",
    "bzcompress": "keyword2",
    "bzdecompress": "keyword2",
    "bzerrno": "keyword2",
    "bzerror": "keyword2",
    "bzerrstr": "keyword2",
    "bzflush": "keyword2",
    "bzopen": "keyword2",
    "bzread": "keyword2",
    "bzwrite": "keyword2",
    "call_user_func": "keyword2",
    "call_user_func_array": "keyword2",
    "call_user_method": "keyword2",
    "call_user_method_array": "keyword2",
    "case": "keyword1",
    "catch": "keyword1",
    "ccvs_add": "keyword2",
    "ccvs_auth": "keyword2",
    "ccvs_command": "keyword2",
    "ccvs_count": "keyword2",
    "ccvs_delete": "keyword2",
    "ccvs_done": "keyword2",
    "ccvs_init": "keyword2",
    "ccvs_lookup": "keyword2",
    "ccvs_new": "keyword2",
    "ccvs_report": "keyword2",
    "ccvs_return": "keyword2",
    "ccvs_reverse": "keyword2",
    "ccvs_sale": "keyword2",
    "ccvs_status": "keyword2",
    "ccvs_textvalue": "keyword2",
    "ccvs_void": "keyword2",
    "ceil": "keyword2",
    "chdir": "keyword2",
    "checkdate": "keyword2",
    "checkdnsrr": "keyword2",
    "chgrp": "keyword2",
    "chmod": "keyword2",
    "chop": "keyword2",
    "chown": "keyword2",
    "chr": "keyword2",
    "chroot": "keyword2",
    "chunk_split": "keyword2",
    "class": "keyword1",
    "class_exists": "keyword2",
    "clearstatcache": "keyword2",
    "clone": "keyword1",
    "close": "keyword2",
    "closedir": "keyword2",
    "closelog": "keyword2",
    "com_get": "keyword2",
    "com_invoke": "keyword2",
    "com_load": "keyword2",
    "com_propget": "keyword2",
    "com_propput": "keyword2",
    "com_propset": "keyword2",
    "com_set": "keyword2",
    "compact": "keyword2",
    "confirm_cybermut_compiled": "keyword2",
    "confirm_extname_compiled": "keyword2",
    "connect": "keyword2",
    "connection_aborted": "keyword2",
    "connection_status": "keyword2",
    "const": "keyword1",
    "constant": "keyword2",
    "continue": "keyword1",
    "convert_cyr_string": "keyword2",
    "convert_uudecode": "keyword2",
    "convert_uuencode": "keyword2",
    "copy": "keyword2",
    "cos": "keyword2",
    "count": "keyword2",
    "count_chars": "keyword2",
    "cpdf_add_annotation": "keyword2",
    "cpdf_add_outline": "keyword2",
    "cpdf_arc": "keyword2",
    "cpdf_begin_text": "keyword2",
    "cpdf_circle": "keyword2",
    "cpdf_clip": "keyword2",
    "cpdf_close": "keyword2",
    "cpdf_closepath": "keyword2",
    "cpdf_closepath_fill_stroke": "keyword2",
    "cpdf_closepath_stroke": "keyword2",
    "cpdf_continue_text": "keyword2",
    "cpdf_curveto": "keyword2",
    "cpdf_end_text": "keyword2",
    "cpdf_fill": "keyword2",
    "cpdf_fill_stroke": "keyword2",
    "cpdf_finalize": "keyword2",
    "cpdf_finalize_page": "keyword2",
    "cpdf_global_set_document_limits": "keyword2",
    "cpdf_import_jpeg": "keyword2",
    "cpdf_lineto": "keyword2",
    "cpdf_moveto": "keyword2",
    "cpdf_newpath": "keyword2",
    "cpdf_open": "keyword2",
    "cpdf_output_buffer": "keyword2",
    "cpdf_page_init": "keyword2",
    "cpdf_place_inline_image": "keyword2",
    "cpdf_rect": "keyword2",
    "cpdf_restore": "keyword2",
    "cpdf_rlineto": "keyword2",
    "cpdf_rmoveto": "keyword2",
    "cpdf_rotate": "keyword2",
    "cpdf_rotate_text": "keyword2",
    "cpdf_save": "keyword2",
    "cpdf_save_to_file": "keyword2",
    "cpdf_scale": "keyword2",
    "cpdf_set_action_url": "keyword2",
    "cpdf_set_char_spacing": "keyword2",
    "cpdf_set_creator": "keyword2",
    "cpdf_set_current_page": "keyword2",
    "cpdf_set_font": "keyword2",
    "cpdf_set_font_directories": "keyword2",
    "cpdf_set_font_map_file": "keyword2",
    "cpdf_set_horiz_scaling": "keyword2",
    "cpdf_set_keywords": "keyword2",
    "cpdf_set_leading": "keyword2",
    "cpdf_set_page_animation": "keyword2",
    "cpdf_set_subject": "keyword2",
    "cpdf_set_text_matrix": "keyword2",
    "cpdf_set_text_pos": "keyword2",
    "cpdf_set_text_rendering": "keyword2",
    "cpdf_set_text_rise": "keyword2",
    "cpdf_set_title": "keyword2",
    "cpdf_set_viewer_preferences": "keyword2",
    "cpdf_set_word_spacing": "keyword2",
    "cpdf_setdash": "keyword2",
    "cpdf_setflat": "keyword2",
    "cpdf_setgray": "keyword2",
    "cpdf_setgray_fill": "keyword2",
    "cpdf_setgray_stroke": "keyword2",
    "cpdf_setlinecap": "keyword2",
    "cpdf_setlinejoin": "keyword2",
    "cpdf_setlinewidth": "keyword2",
    "cpdf_setmiterlimit": "keyword2",
    "cpdf_setrgbcolor": "keyword2",
    "cpdf_setrgbcolor_fill": "keyword2",
    "cpdf_setrgbcolor_stroke": "keyword2",
    "cpdf_show": "keyword2",
    "cpdf_show_xy": "keyword2",
    "cpdf_stringwidth": "keyword2",
    "cpdf_stroke": "keyword2",
    "cpdf_text": "keyword2",
    "cpdf_translate": "keyword2",
    "crack_check": "keyword2",
    "crack_closedict": "keyword2",
    "crack_getlastmessage": "keyword2",
    "crack_opendict": "keyword2",
    "crash": "keyword2",
    "crc32": "keyword2",
    "create_function": "keyword2",
    "crypt": "keyword2",
    "ctype_alnum": "keyword2",
    "ctype_alpha": "keyword2",
    "ctype_cntrl": "keyword2",
    "ctype_digit": "keyword2",
    "ctype_graph": "keyword2",
    "ctype_lower": "keyword2",
    "ctype_print": "keyword2",
    "ctype_punct": "keyword2",
    "ctype_space": "keyword2",
    "ctype_upper": "keyword2",
    "ctype_xdigit": "keyword2",
    "curl_close": "keyword2",
    "curl_errno": "keyword2",
    "curl_error": "keyword2",
    "curl_exec": "keyword2",
    "curl_getinfo": "keyword2",
    "curl_init": "keyword2",
    "curl_setopt": "keyword2",
    "curl_version": "keyword2",
    "current": "keyword2",
    "cv_add": "keyword2",
    "cv_auth": "keyword2",
    "cv_command": "keyword2",
    "cv_count": "keyword2",
    "cv_delete": "keyword2",
    "cv_done": "keyword2",
    "cv_init": "keyword2",
    "cv_lookup": "keyword2",
    "cv_new": "keyword2",
    "cv_report": "keyword2",
    "cv_return": "keyword2",
    "cv_reverse": "keyword2",
    "cv_sale": "keyword2",
    "cv_status": "keyword2",
    "cv_textvalue": "keyword2",
    "cv_void": "keyword2",
    "cybercash_base64_decode": "keyword2",
    "cybercash_base64_encode": "keyword2",
    "cybercash_decr": "keyword2",
    "cybercash_encr": "keyword2",
    "cybermut_creerformulairecm": "keyword2",
    "cybermut_creerreponsecm": "keyword2",
    "cybermut_testmac": "keyword2",
    "date": "keyword2",
    "dba_close": "keyword2",
    "dba_delete": "keyword2",
    "dba_exists": "keyword2",
    "dba_fetch": "keyword2",
    "dba_firstkey": "keyword2",
    "dba_insert": "keyword2",
    "dba_nextkey": "keyword2",
    "dba_open": "keyword2",
    "dba_optimize": "keyword2",
    "dba_popen": "keyword2",
    "dba_replace": "keyword2",
    "dba_sync": "keyword2",
    "dbase_add_record": "keyword2",
    "dbase_close": "keyword2",
    "dbase_create": "keyword2",
    "dbase_delete_record": "keyword2",
    "dbase_get_record": "keyword2",
    "dbase_get_record_with_names": "keyword2",
    "dbase_numfields": "keyword2",
    "dbase_numrecords": "keyword2",
    "dbase_open": "keyword2",
    "dbase_pack": "keyword2",
    "dbase_replace_record": "keyword2",
    "dblist": "keyword2",
    "dbmclose": "keyword2",
    "dbmdelete": "keyword2",
    "dbmexists": "keyword2",
    "dbmfetch": "keyword2",
    "dbmfirstkey": "keyword2",
    "dbminsert": "keyword2",
    "dbmnextkey": "keyword2",
    "dbmopen": "keyword2",
    "dbmreplace": "keyword2",
    "dbx_close": "keyword2",
    "dbx_cmp_asc": "keyword2",
    "dbx_cmp_desc": "keyword2",
    "dbx_connect": "keyword2",
    "dbx_error": "keyword2",
    "dbx_query": "keyword2",
    "dbx_sort": "keyword2",
    "dcgettext": "keyword2",
    "debug_backtrace": "keyword2",
    "debug_print_backtrace": "keyword2",
    "decbin": "keyword2",
    "dechex": "keyword2",
    "declare": "keyword1",
    "decoct": "keyword2",
    "default": "keyword1",
    "define": "keyword2",
    "define_syslog_variables": "keyword2",
    "defined": "keyword2",
    "deg2rad": "keyword2",
    "delete_iovec": "keyword2",
    "dgettext": "keyword2",
    "die": "keyword2",
    "dir": "keyword2",
    "dirname": "keyword2",
    "diskfreespace": "keyword2",
    "display_disabled_function": "keyword2",
    "dl": "keyword2",
    "do": "keyword1",
    "domxml_add_root": "keyword2",
    "domxml_attributes": "keyword2",
    "domxml_children": "keyword2",
    "domxml_dumpmem": "keyword2",
    "domxml_elem_get_attribute": "keyword2",
    "domxml_elem_set_attribute": "keyword2",
    "domxml_get_attribute": "keyword2",
    "domxml_getattr": "keyword2",
    "domxml_new_child": "keyword2",
    "domxml_new_xmldoc": "keyword2",
    "domxml_node": "keyword2",
    "domxml_node_attributes": "keyword2",
    "domxml_node_children": "keyword2",
    "domxml_node_new_child": "keyword2",
    "domxml_node_set_content": "keyword2",
    "domxml_node_unlink_node": "keyword2",
    "domxml_root": "keyword2",
    "domxml_set_attribute": "keyword2",
    "domxml_setattr": "keyword2",
    "domxml_unlink_node": "keyword2",
    "domxml_version": "keyword2",
    "doubleval": "keyword2",
    "drawarc": "keyword2",
    "drawcircle": "keyword2",
    "drawcubic": "keyword2",
    "drawcubicto": "keyword2",
    "drawcurve": "keyword2",
    "drawcurveto": "keyword2",
    "drawglyph": "keyword2",
    "drawline": "keyword2",
    "drawlineto": "keyword2",
    "each": "keyword2",
    "easter_date": "keyword2",
    "easter_days": "keyword2",
    "echo": "keyword1",
    "else": "keyword1",
    "elseif": "keyword1",
    "empty": "keyword1",
    "end": "keyword2",
    "endfor": "keyword1",
    "endforeach": "keyword1",
    "endif": "keyword1",
    "endswitch": "keyword1",
    "endwhile": "keyword1",
    "ereg": "keyword2",
    "ereg_replace": "keyword2",
    "eregi": "keyword2",
    "eregi_replace": "keyword2",
    "error_log": "keyword2",
    "error_reporting": "keyword2",
    "escapeshellarg": "keyword2",
    "escapeshellcmd": "keyword2",
    "exec": "keyword2",
    "exit": "keyword2",
    "exp": "keyword2",
    "explode": "keyword2",
    "extends": "keyword1",
    "extension_loaded": "keyword2",
    "extract": "keyword2",
    "ezmlm_hash": "keyword2",
    "false": "keyword3",
    "fbsql": "keyword2",
    "fbsql_affected_rows": "keyword2",
    "fbsql_autocommit": "keyword2",
    "fbsql_close": "keyword2",
    "fbsql_commit": "keyword2",
    "fbsql_connect": "keyword2",
    "fbsql_create_db": "keyword2",
    "fbsql_data_seek": "keyword2",
    "fbsql_database": "keyword2",
    "fbsql_database_password": "keyword2",
    "fbsql_db_query": "keyword2",
    "fbsql_drop_db": "keyword2",
    "fbsql_errno": "keyword2",
    "fbsql_error": "keyword2",
    "fbsql_fetch_array": "keyword2",
    "fbsql_fetch_assoc": "keyword2",
    "fbsql_fetch_field": "keyword2",
    "fbsql_fetch_lengths": "keyword2",
    "fbsql_fetch_object": "keyword2",
    "fbsql_fetch_row": "keyword2",
    "fbsql_field_flags": "keyword2",
    "fbsql_field_len": "keyword2",
    "fbsql_field_name": "keyword2",
    "fbsql_field_seek": "keyword2",
    "fbsql_field_table": "keyword2",
    "fbsql_field_type": "keyword2",
    "fbsql_free_result": "keyword2",
    "fbsql_hostname": "keyword2",
    "fbsql_insert_id": "keyword2",
    "fbsql_list_dbs": "keyword2",
    "fbsql_list_fields": "keyword2",
    "fbsql_list_tables": "keyword2",
    "fbsql_next_result": "keyword2",
    "fbsql_num_fields": "keyword2",
    "fbsql_num_rows": "keyword2",
    "fbsql_password": "keyword2",
    "fbsql_pconnect": "keyword2",
    "fbsql_query": "keyword2",
    "fbsql_result": "keyword2",
    "fbsql_rollback": "keyword2",
    "fbsql_select_db": "keyword2",
    "fbsql_start_db": "keyword2",
    "fbsql_stop_db": "keyword2",
    "fbsql_username": "keyword2",
    "fbsql_warnings": "keyword2",
    "fclose": "keyword2",
    "fd_alloc": "keyword2",
    "fd_clear": "keyword2",
    "fd_dealloc": "keyword2",
    "fd_isset": "keyword2",
    "fd_set": "keyword2",
    "fd_zero": "keyword2",
    "fdf_add_template": "keyword2",
    "fdf_close": "keyword2",
    "fdf_create": "keyword2",
    "fdf_get_file": "keyword2",
    "fdf_get_status": "keyword2",
    "fdf_get_value": "keyword2",
    "fdf_next_field_name": "keyword2",
    "fdf_open": "keyword2",
    "fdf_save": "keyword2",
    "fdf_set_ap": "keyword2",
    "fdf_set_file": "keyword2",
    "fdf_set_flags": "keyword2",
    "fdf_set_javascript_action": "keyword2",
    "fdf_set_opt": "keyword2",
    "fdf_set_status": "keyword2",
    "fdf_set_submit_form_action": "keyword2",
    "fdf_set_value": "keyword2",
    "feof": "keyword2",
    "fetch_iovec": "keyword2",
    "fflush": "keyword2",
    "fgetc": "keyword2",
    "fgetcsv": "keyword2",
    "fgets": "keyword2",
    "fgetss": "keyword2",
    "file": "keyword2",
    "file_exists": "keyword2",
    "file_get_contents": "keyword2",
    "file_put_contents": "keyword2",
    "fileatime": "keyword2",
    "filectime": "keyword2",
    "filegroup": "keyword2",
    "fileinode": "keyword2",
    "filemtime": "keyword2",
    "fileowner": "keyword2",
    "fileperms": "keyword2",
    "filepro": "keyword2",
    "filepro_fieldcount": "keyword2",
    "filepro_fieldname": "keyword2",
    "filepro_fieldtype": "keyword2",
    "filepro_fieldwidth": "keyword2",
    "filepro_retrieve": "keyword2",
    "filepro_rowcount": "keyword2",
    "filesize": "keyword2",
    "filetype": "keyword2",
    "final": "keyword1",
    "floatval": "keyword2",
    "flock": "keyword2",
    "floor": "keyword2",
    "flush": "keyword2",
    "fopen": "keyword2",
    "fopenstream": "keyword2",
    "for": "keyword1",
    "foreach": "keyword1",
    "fpassthru": "keyword2",
    "fputs": "keyword2",
    "fread": "keyword2",
    "free_iovec": "keyword2",
    "frenchtojd": "keyword2",
    "fribidi_log2vis": "keyword2",
    "fscanf": "keyword2",
    "fseek": "keyword2",
    "fsockopen": "keyword2",
    "fstat": "keyword2",
    "ftell": "keyword2",
    "ftp_alloc": "keyword2",
    "ftp_cdup": "keyword2",
    "ftp_chdir": "keyword2",
    "ftp_connect": "keyword2",
    "ftp_delete": "keyword2",
    "ftp_exec": "keyword2",
    "ftp_fget": "keyword2",
    "ftp_fput": "keyword2",
    "ftp_get": "keyword2",
    "ftp_login": "keyword2",
    "ftp_mdtm": "keyword2",
    "ftp_mkdir": "keyword2",
    "ftp_nlist": "keyword2",
    "ftp_pasv": "keyword2",
    "ftp_put": "keyword2",
    "ftp_pwd": "keyword2",
    "ftp_quit": "keyword2",
    "ftp_rawlist": "keyword2",
    "ftp_rename": "keyword2",
    "ftp_rmdir": "keyword2",
    "ftp_site": "keyword2",
    "ftp_size": "keyword2",
    "ftp_ssl_connect": "keyword2",
    "ftp_systype": "keyword2",
    "ftruncate": "keyword2",
    "func_get_arg": "keyword2",
    "func_get_args": "keyword2",
    "func_num_args": "keyword2",
    "function": "keyword1",
    "function_exists": "keyword2",
    "fwrite": "keyword2",
    "gd_info": "keyword2",
    "get_all_headers": "keyword2",
    "get_browser": "keyword2",
    "get_cfg_var": "keyword2",
    "get_class": "keyword2",
    "get_class_methods": "keyword2",
    "get_class_vars": "keyword2",
    "get_current_user": "keyword2",
    "get_declared_classes": "keyword2",
    "get_declared_interfaces": "keyword2",
    "get_defined_functions": "keyword2",
    "get_defined_vars": "keyword2",
    "get_extension_funcs": "keyword2",
    "get_headers": "keyword2",
    "get_html_translation_table": "keyword2",
    "get_included_files": "keyword2",
    "get_loaded_extensions": "keyword2",
    "get_magic_quotes_gpc": "keyword2",
    "get_magic_quotes_runtime": "keyword2",
    "get_meta_tags": "keyword2",
    "get_object_vars": "keyword2",
    "get_parent_class": "keyword2",
    "get_required_files": "keyword2",
    "get_resource_type": "keyword2",
    "getallheaders": "keyword2",
    "getascent": "keyword2",
    "getcwd": "keyword2",
    "getdate": "keyword2",
    "getdescent": "keyword2",
    "getenv": "keyword2",
    "getheight": "keyword2",
    "gethostbyaddr": "keyword2",
    "gethostbyname": "keyword2",
    "gethostbynamel": "keyword2",
    "getimagesize": "keyword2",
    "getlastmod": "keyword2",
    "getleading": "keyword2",
    "getmxrr": "keyword2",
    "getmyinode": "keyword2",
    "getmypid": "keyword2",
    "getmyuid": "keyword2",
    "getopt": "keyword2",
    "getpeername": "keyword2",
    "getprotobyname": "keyword2",
    "getprotobynumber": "keyword2",
    "getrandmax": "keyword2",
    "getrusage": "keyword2",
    "getservbyname": "keyword2",
    "getservbyport": "keyword2",
    "getshape1": "keyword2",
    "getshape2": "keyword2",
    "getsockname": "keyword2",
    "getsockopt": "keyword2",
    "gettext": "keyword2",
    "gettimeofday": "keyword2",
    "gettype": "keyword2",
    "getwidth": "keyword2",
    "global": "keyword1",
    "gmdate": "keyword2",
    "gmmktime": "keyword2",
    "gmp_abs": "keyword2",
    "gmp_add": "keyword2",
    "gmp_and": "keyword2",
    "gmp_clrbit": "keyword2",
    "gmp_cmp": "keyword2",
    "gmp_com": "keyword2",
    "gmp_div": "keyword2",
    "gmp_div_q": "keyword2",
    "gmp_div_qr": "keyword2",
    "gmp_div_r": "keyword2",
    "gmp_divexact": "keyword2",
    "gmp_fact": "keyword2",
    "gmp_gcd": "keyword2",
    "gmp_gcdext": "keyword2",
    "gmp_hamdist": "keyword2",
    "gmp_init": "keyword2",
    "gmp_intval": "keyword2",
    "gmp_invert": "keyword2",
    "gmp_jacobi": "keyword2",
    "gmp_legendre": "keyword2",
    "gmp_mod": "keyword2",
    "gmp_mul": "keyword2",
    "gmp_neg": "keyword2",
    "gmp_or": "keyword2",
    "gmp_perfect_square": "keyword2",
    "gmp_popcount": "keyword2",
    "gmp_pow": "keyword2",
    "gmp_powm": "keyword2",
    "gmp_prob_prime": "keyword2",
    "gmp_random": "keyword2",
    "gmp_scan0": "keyword2",
    "gmp_scan1": "keyword2",
    "gmp_setbit": "keyword2",
    "gmp_sign": "keyword2",
    "gmp_sqrt": "keyword2",
    "gmp_sqrtrem": "keyword2",
    "gmp_strval": "keyword2",
    "gmp_sub": "keyword2",
    "gmp_xor": "keyword2",
    "gmstrftime": "keyword2",
    "gregoriantojd": "keyword2",
    "gzclose": "keyword2",
    "gzcompress": "keyword2",
    "gzdeflate": "keyword2",
    "gzencode": "keyword2",
    "gzeof": "keyword2",
    "gzfile": "keyword2",
    "gzgetc": "keyword2",
    "gzgets": "keyword2",
    "gzgetss": "keyword2",
    "gzinflate": "keyword2",
    "gzopen": "keyword2",
    "gzpassthru": "keyword2",
    "gzputs": "keyword2",
    "gzread": "keyword2",
    "gzrewind": "keyword2",
    "gzseek": "keyword2",
    "gztell": "keyword2",
    "gzuncompress": "keyword2",
    "gzwrite": "keyword2",
    "header": "keyword2",
    "headers_list": "keyword2",
    "headers_sent": "keyword2",
    "hebrev": "keyword2",
    "hebrevc": "keyword2",
    "hexdec": "keyword2",
    "highlight_file": "keyword2",
    "highlight_string": "keyword2",
    "htmlentities": "keyword2",
    "htmlspecialchars": "keyword2",
    "http_build_query": "keyword2",
    "hw_array2objrec": "keyword2",
    "hw_changeobject": "keyword2",
    "hw_children": "keyword2",
    "hw_childrenobj": "keyword2",
    "hw_close": "keyword2",
    "hw_connect": "keyword2",
    "hw_connection_info": "keyword2",
    "hw_cp": "keyword2",
    "hw_deleteobject": "keyword2",
    "hw_docbyanchor": "keyword2",
    "hw_docbyanchorobj": "keyword2",
    "hw_document_attributes": "keyword2",
    "hw_document_bodytag": "keyword2",
    "hw_document_content": "keyword2",
    "hw_document_setcontent": "keyword2",
    "hw_document_size": "keyword2",
    "hw_dummy": "keyword2",
    "hw_edittext": "keyword2",
    "hw_error": "keyword2",
    "hw_errormsg": "keyword2",
    "hw_free_document": "keyword2",
    "hw_getanchors": "keyword2",
    "hw_getanchorsobj": "keyword2",
    "hw_getandlock": "keyword2",
    "hw_getcgi": "keyword2",
    "hw_getchildcoll": "keyword2",
    "hw_getchildcollobj": "keyword2",
    "hw_getchilddoccoll": "keyword2",
    "hw_getchilddoccollobj": "keyword2",
    "hw_getobject": "keyword2",
    "hw_getobjectbyftquery": "keyword2",
    "hw_getobjectbyftquerycoll": "keyword2",
    "hw_getobjectbyftquerycollobj": "keyword2",
    "hw_getobjectbyftqueryobj": "keyword2",
    "hw_getobjectbyquery": "keyword2",
    "hw_getobjectbyquerycoll": "keyword2",
    "hw_getobjectbyquerycollobj": "keyword2",
    "hw_getobjectbyqueryobj": "keyword2",
    "hw_getparents": "keyword2",
    "hw_getparentsobj": "keyword2",
    "hw_getrellink": "keyword2",
    "hw_getremote": "keyword2",
    "hw_getremotechildren": "keyword2",
    "hw_getsrcbydestobj": "keyword2",
    "hw_gettext": "keyword2",
    "hw_getusername": "keyword2",
    "hw_identify": "keyword2",
    "hw_incollections": "keyword2",
    "hw_info": "keyword2",
    "hw_inscoll": "keyword2",
    "hw_insdoc": "keyword2",
    "hw_insertanchors": "keyword2",
    "hw_insertdocument": "keyword2",
    "hw_insertobject": "keyword2",
    "hw_mapid": "keyword2",
    "hw_modifyobject": "keyword2",
    "hw_mv": "keyword2",
    "hw_new_document": "keyword2",
    "hw_new_document_from_file": "keyword2",
    "hw_objrec2array": "keyword2",
    "hw_output_document": "keyword2",
    "hw_pconnect": "keyword2",
    "hw_pipecgi": "keyword2",
    "hw_pipedocument": "keyword2",
    "hw_root": "keyword2",
    "hw_setlinkroot": "keyword2",
    "hw_stat": "keyword2",
    "hw_unlock": "keyword2",
    "hw_who": "keyword2",
    "ibase_blob_add": "keyword2",
    "ibase_blob_cancel": "keyword2",
    "ibase_blob_close": "keyword2",
    "ibase_blob_create": "keyword2",
    "ibase_blob_echo": "keyword2",
    "ibase_blob_get": "keyword2",
    "ibase_blob_import": "keyword2",
    "ibase_blob_info": "keyword2",
    "ibase_blob_open": "keyword2",
    "ibase_close": "keyword2",
    "ibase_commit": "keyword2",
    "ibase_connect": "keyword2",
    "ibase_errmsg": "keyword2",
    "ibase_execute": "keyword2",
    "ibase_fetch_object": "keyword2",
    "ibase_fetch_row": "keyword2",
    "ibase_field_info": "keyword2",
    "ibase_free_query": "keyword2",
    "ibase_free_result": "keyword2",
    "ibase_num_fields": "keyword2",
    "ibase_pconnect": "keyword2",
    "ibase_prepare": "keyword2",
    "ibase_query": "keyword2",
    "ibase_rollback": "keyword2",
    "ibase_timefmt": "keyword2",
    "ibase_trans": "keyword2",
    "icap_create_calendar": "keyword2",
    "icap_delete_calendar": "keyword2",
    "icap_delete_event": "keyword2",
    "icap_fetch_event": "keyword2",
    "icap_list_alarms": "keyword2",
    "icap_list_events": "keyword2",
    "icap_open": "keyword2",
    "icap_popen": "keyword2",
    "icap_rename_calendar": "keyword2",
    "icap_reopen": "keyword2",
    "icap_snooze": "keyword2",
    "icap_store_event": "keyword2",
    "iconv": "keyword2",
    "iconv_get_encoding": "keyword2",
    "iconv_set_encoding": "keyword2",
    "idate": "keyword2",
    "if": "keyword1",
    "ifx_affected_rows": "keyword2",
    "ifx_blobinfile_mode": "keyword2",
    "ifx_byteasvarchar": "keyword2",
    "ifx_close": "keyword2",
    "ifx_connect": "keyword2",
    "ifx_copy_blob": "keyword2",
    "ifx_create_blob": "keyword2",
    "ifx_create_char": "keyword2",
    "ifx_do": "keyword2",
    "ifx_error": "keyword2",
    "ifx_errormsg": "keyword2",
    "ifx_fetch_row": "keyword2",
    "ifx_fieldproperties": "keyword2",
    "ifx_fieldtypes": "keyword2",
    "ifx_free_blob": "keyword2",
    "ifx_free_char": "keyword2",
    "ifx_free_result": "keyword2",
    "ifx_get_blob": "keyword2",
    "ifx_get_char": "keyword2",
    "ifx_getsqlca": "keyword2",
    "ifx_htmltbl_result": "keyword2",
    "ifx_nullformat": "keyword2",
    "ifx_num_fields": "keyword2",
    "ifx_num_rows": "keyword2",
    "ifx_pconnect": "keyword2",
    "ifx_prepare": "keyword2",
    "ifx_query": "keyword2",
    "ifx_textasvarchar": "keyword2",
    "ifx_update_blob": "keyword2",
    "ifx_update_char": "keyword2",
    "ifxus_close_slob": "keyword2",
    "ifxus_create_slob": "keyword2",
    "ifxus_free_slob": "keyword2",
    "ifxus_open_slob": "keyword2",
    "ifxus_read_slob": "keyword2",
    "ifxus_seek_slob": "keyword2",
    "ifxus_tell_slob": "keyword2",
    "ifxus_write_slob": "keyword2",
    "ignore_user_abort": "keyword2",
    "iis_addserver": "keyword2",
    "iis_getdirsecurity": "keyword2",
    "iis_getscriptmap": "keyword2",
    "iis_getserverbycomment": "keyword2",
    "iis_getserverbypath": "keyword2",
    "iis_getserverright": "keyword2",
    "iis_getservicestate": "keyword2",
    "iis_removeserver": "keyword2",
    "iis_setappsettings": "keyword2",
    "iis_setdirsecurity": "keyword2",
    "iis_setscriptmap": "keyword2",
    "iis_setserverright": "keyword2",
    "iis_startserver": "keyword2",
    "iis_startservice": "keyword2",
    "iis_stopserver": "keyword2",
    "iis_stopservice": "keyword2",
    "image2wbmp": "keyword2",
    "image_type_to_extension": "keyword2",
    "imagealphablending": "keyword2",
    "imagearc": "keyword2",
    "imagechar": "keyword2",
    "imagecharup": "keyword2",
    "imagecolorallocate": "keyword2",
    "imagecolorat": "keyword2",
    "imagecolorclosest": "keyword2",
    "imagecolorclosestalpha": "keyword2",
    "imagecolorclosesthwb": "keyword2",
    "imagecolordeallocate": "keyword2",
    "imagecolorexact": "keyword2",
    "imagecolorexactalpha": "keyword2",
    "imagecolormatch": "keyword2",
    "imagecolorresolve": "keyword2",
    "imagecolorresolvealpha": "keyword2",
    "imagecolorset": "keyword2",
    "imagecolorsforindex": "keyword2",
    "imagecolorstotal": "keyword2",
    "imagecolortransparent": "keyword2",
    "imagecopy": "keyword2",
    "imagecopymerge": "keyword2",
    "imagecopymergegray": "keyword2",
    "imagecopyresampled": "keyword2",
    "imagecopyresized": "keyword2",
    "imagecreate": "keyword2",
    "imagecreatefromgif": "keyword2",
    "imagecreatefromjpeg": "keyword2",
    "imagecreatefrompng": "keyword2",
    "imagecreatefromstring": "keyword2",
    "imagecreatefromwbmp": "keyword2",
    "imagecreatefromxbm": "keyword2",
    "imagecreatefromxpm": "keyword2",
    "imagecreatetruecolor": "keyword2",
    "imagedashedline": "keyword2",
    "imagedestroy": "keyword2",
    "imageellipse": "keyword2",
    "imagefill": "keyword2",
    "imagefilledarc": "keyword2",
    "imagefilledellipse": "keyword2",
    "imagefilledpolygon": "keyword2",
    "imagefilledrectangle": "keyword2",
    "imagefilltoborder": "keyword2",
    "imagefilter": "keyword2",
    "imagefontheight": "keyword2",
    "imagefontwidth": "keyword2",
    "imagegammacorrect": "keyword2",
    "imagegif": "keyword2",
    "imageinterlace": "keyword2",
    "imagejpeg": "keyword2",
    "imagelayereffect": "keyword2",
    "imageline": "keyword2",
    "imageloadfont": "keyword2",
    "imagepalettecopy": "keyword2",
    "imagepng": "keyword2",
    "imagepolygon": "keyword2",
    "imagepsbbox": "keyword2",
    "imagepscopyfont": "keyword2",
    "imagepsencodefont": "keyword2",
    "imagepsextendfont": "keyword2",
    "imagepsfreefont": "keyword2",
    "imagepsloadfont": "keyword2",
    "imagepsslantfont": "keyword2",
    "imagepstext": "keyword2",
    "imagerectangle": "keyword2",
    "imagerotate": "keyword2",
    "imagesetbrush": "keyword2",
    "imagesetpixel": "keyword2",
    "imagesetstyle": "keyword2",
    "imagesetthickness": "keyword2",
    "imagesettile": "keyword2",
    "imagestring": "keyword2",
    "imagestringup": "keyword2",
    "imagesx": "keyword2",
    "imagesy": "keyword2",
    "imagetruecolortopalette": "keyword2",
    "imagettfbbox": "keyword2",
    "imagettftext": "keyword2",
    "imagetypes": "keyword2",
    "imagewbmp": "keyword2",
    "imap_8bit": "keyword2",
    "imap_alerts": "keyword2",
    "imap_append": "keyword2",
    "imap_base64": "keyword2",
    "imap_binary": "keyword2",
    "imap_body": "keyword2",
    "imap_bodystruct": "keyword2",
    "imap_check": "keyword2",
    "imap_clearflag_full": "keyword2",
    "imap_close": "keyword2",
    "imap_create": "keyword2",
    "imap_createmailbox": "keyword2",
    "imap_delete": "keyword2",
    "imap_deletemailbox": "keyword2",
    "imap_errors": "keyword2",
    "imap_expunge": "keyword2",
    "imap_fetch_overview": "keyword2",
    "imap_fetchbody": "keyword2",
    "imap_fetchheader": "keyword2",
    "imap_fetchstructure": "keyword2",
    "imap_fetchtext": "keyword2",
    "imap_get_quota": "keyword2",
    "imap_getmailboxes": "keyword2",
    "imap_getsubscribed": "keyword2",
    "imap_header": "keyword2",
    "imap_headerinfo": "keyword2",
    "imap_headers": "keyword2",
    "imap_last_error": "keyword2",
    "imap_list": "keyword2",
    "imap_listmailbox": "keyword2",
    "imap_listsubscribed": "keyword2",
    "imap_lsub": "keyword2",
    "imap_mail": "keyword2",
    "imap_mail_compose": "keyword2",
    "imap_mail_copy": "keyword2",
    "imap_mail_move": "keyword2",
    "imap_mailboxmsginfo": "keyword2",
    "imap_mime_header_decode": "keyword2",
    "imap_msgno": "keyword2",
    "imap_num_msg": "keyword2",
    "imap_num_recent": "keyword2",
    "imap_open": "keyword2",
    "imap_ping": "keyword2",
    "imap_popen": "keyword2",
    "imap_qprint": "keyword2",
    "imap_rename": "keyword2",
    "imap_renamemailbox": "keyword2",
    "imap_reopen": "keyword2",
    "imap_rfc822_parse_adrlist": "keyword2",
    "imap_rfc822_parse_headers": "keyword2",
    "imap_rfc822_write_address": "keyword2",
    "imap_scan": "keyword2",
    "imap_scanmailbox": "keyword2",
    "imap_search": "keyword2",
    "imap_set_quota": "keyword2",
    "imap_setflag_full": "keyword2",
    "imap_sort": "keyword2",
    "imap_status": "keyword2",
    "imap_subscribe": "keyword2",
    "imap_uid": "keyword2",
    "imap_undelete": "keyword2",
    "imap_unsubscribe": "keyword2",
    "imap_utf7_decode": "keyword2",
    "imap_utf7_encode": "keyword2",
    "imap_utf8": "keyword2",
    "implements": "keyword1",
    "implode": "keyword2",
    "in_array": "keyword2",
    "include": "keyword1",
    "include_once": "keyword1",
    "ingres_autocommit": "keyword2",
    "ingres_close": "keyword2",
    "ingres_commit": "keyword2",
    "ingres_connect": "keyword2",
    "ingres_fetch_array": "keyword2",
    "ingres_fetch_object": "keyword2",
    "ingres_fetch_row": "keyword2",
    "ingres_field_length": "keyword2",
    "ingres_field_name": "keyword2",
    "ingres_field_nullable": "keyword2",
    "ingres_field_precision": "keyword2",
    "ingres_field_scale": "keyword2",
    "ingres_field_type": "keyword2",
    "ingres_num_fields": "keyword2",
    "ingres_num_rows": "keyword2",
    "ingres_pconnect": "keyword2",
    "ingres_query": "keyword2",
    "ingres_rollback": "keyword2",
    "ini_alter": "keyword2",
    "ini_get": "keyword2",
    "ini_restore": "keyword2",
    "ini_set": "keyword2",
    "instanceof": "operator",
    "interface": "keyword1",
    "intval": "keyword2",
    "ip2long": "keyword2",
    "iptcembed": "keyword2",
    "iptcparse": "keyword2",
    "ircg_channel_mode": "keyword2",
    "ircg_disconnect": "keyword2",
    "ircg_html_encode": "keyword2",
    "ircg_ignore_add": "keyword2",
    "ircg_ignore_del": "keyword2",
    "ircg_is_conn_alive": "keyword2",
    "ircg_join": "keyword2",
    "ircg_kick": "keyword2",
    "ircg_lookup_format_messages": "keyword2",
    "ircg_msg": "keyword2",
    "ircg_nick": "keyword2",
    "ircg_nickname_escape": "keyword2",
    "ircg_nickname_unescape": "keyword2",
    "ircg_notice": "keyword2",
    "ircg_part": "keyword2",
    "ircg_pconnect": "keyword2",
    "ircg_register_format_messages": "keyword2",
    "ircg_set_current": "keyword2",
    "ircg_topic": "keyword2",
    "ircg_whois": "keyword2",
    "is_array": "keyword2",
    "is_bool": "keyword2",
    "is_dir": "keyword2",
    "is_double": "keyword2",
    "is_executable": "keyword2",
    "is_file": "keyword2",
    "is_float": "keyword2",
    "is_int": "keyword2",
    "is_integer": "keyword2",
    "is_link": "keyword2",
    "is_long": "keyword2",
    "is_null": "keyword2",
    "is_numeric": "keyword2",
    "is_object": "keyword2",
    "is_readable": "keyword2",
    "is_real": "keyword2",
    "is_resource": "keyword2",
    "is_scalar": "keyword2",
    "is_string": "keyword2",
    "is_subclass_of": "keyword2",
    "is_uploaded_file": "keyword2",
    "is_writable": "keyword2",
    "is_writeable": "keyword2",
    "isset": "keyword1",
    "java_last_exception_clear": "keyword2",
    "java_last_exception_get": "keyword2",
    "jddayofweek": "keyword2",
    "jdmonthname": "keyword2",
    "jdtofrench": "keyword2",
    "jdtogregorian": "keyword2",
    "jdtojewish": "keyword2",
    "jdtojulian": "keyword2",
    "jdtounix": "keyword2",
    "jewishtojd": "keyword2",
    "join": "keyword2",
    "jpeg2wbmp": "keyword2",
    "juliantojd": "keyword2",
    "key": "keyword2",
    "krsort": "keyword2",
    "ksort": "keyword2",
    "labelframe": "keyword2",
    "lcg_value": "keyword2",
    "ldap_8859_to_t61": "keyword2",
    "ldap_add": "keyword2",
    "ldap_bind": "keyword2",
    "ldap_close": "keyword2",
    "ldap_compare": "keyword2",
    "ldap_connect": "keyword2",
    "ldap_count_entries": "keyword2",
    "ldap_delete": "keyword2",
    "ldap_dn2ufn": "keyword2",
    "ldap_err2str": "keyword2",
    "ldap_errno": "keyword2",
    "ldap_error": "keyword2",
    "ldap_explode_dn": "keyword2",
    "ldap_first_attribute": "keyword2",
    "ldap_first_entry": "keyword2",
    "ldap_first_reference": "keyword2",
    "ldap_free_result": "keyword2",
    "ldap_get_attributes": "keyword2",
    "ldap_get_dn": "keyword2",
    "ldap_get_entries": "keyword2",
    "ldap_get_option": "keyword2",
    "ldap_get_values": "keyword2",
    "ldap_get_values_len": "keyword2",
    "ldap_list": "keyword2",
    "ldap_mod_add": "keyword2",
    "ldap_mod_del": "keyword2",
    "ldap_mod_replace": "keyword2",
    "ldap_modify": "keyword2",
    "ldap_next_attribute": "keyword2",
    "ldap_next_entry": "keyword2",
    "ldap_next_reference": "keyword2",
    "ldap_parse_reference": "keyword2",
    "ldap_parse_result": "keyword2",
    "ldap_read": "keyword2",
    "ldap_rename": "keyword2",
    "ldap_search": "keyword2",
    "ldap_set_option": "keyword2",
    "ldap_t61_to_8859": "keyword2",
    "ldap_unbind": "keyword2",
    "leak": "keyword2",
    "levenshtein": "keyword2",
    "link": "keyword2",
    "linkinfo": "keyword2",
    "list": "keyword1",
    "listen": "keyword2",
    "localeconv": "keyword2",
    "localtime": "keyword2",
    "log": "keyword2",
    "log10": "keyword2",
    "long2ip": "keyword2",
    "lstat": "keyword2",
    "ltrim": "keyword2",
    "magic_quotes_runtime": "keyword2",
    "mail": "keyword2",
    "max": "keyword2",
    "mb_convert_case": "keyword2",
    "mb_strtolower": "keyword2",
    "mb_strtoupper": "keyword2",
    "mcal_append_event": "keyword2",
    "mcal_close": "keyword2",
    "mcal_create_calendar": "keyword2",
    "mcal_date_compare": "keyword2",
    "mcal_date_valid": "keyword2",
    "mcal_day_of_week": "keyword2",
    "mcal_day_of_year": "keyword2",
    "mcal_days_in_month": "keyword2",
    "mcal_delete_calendar": "keyword2",
    "mcal_delete_event": "keyword2",
    "mcal_event_add_attribute": "keyword2",
    "mcal_event_init": "keyword2",
    "mcal_event_set_alarm": "keyword2",
    "mcal_event_set_category": "keyword2",
    "mcal_event_set_class": "keyword2",
    "mcal_event_set_description": "keyword2",
    "mcal_event_set_end": "keyword2",
    "mcal_event_set_recur_daily": "keyword2",
    "mcal_event_set_recur_monthly_mday": "keyword2",
    "mcal_event_set_recur_monthly_wday": "keyword2",
    "mcal_event_set_recur_none": "keyword2",
    "mcal_event_set_recur_weekly": "keyword2",
    "mcal_event_set_recur_yearly": "keyword2",
    "mcal_event_set_start": "keyword2",
    "mcal_event_set_title": "keyword2",
    "mcal_fetch_current_stream_event": "keyword2",
    "mcal_fetch_event": "keyword2",
    "mcal_is_leap_year": "keyword2",
    "mcal_list_alarms": "keyword2",
    "mcal_list_events": "keyword2",
    "mcal_next_recurrence": "keyword2",
    "mcal_open": "keyword2",
    "mcal_popen": "keyword2",
    "mcal_rename_calendar": "keyword2",
    "mcal_reopen": "keyword2",
    "mcal_snooze": "keyword2",
    "mcal_store_event": "keyword2",
    "mcal_time_valid": "keyword2",
    "mcal_week_of_year": "keyword2",
    "mcrypt_cbc": "keyword2",
    "mcrypt_cfb": "keyword2",
    "mcrypt_create_iv": "keyword2",
    "mcrypt_decrypt": "keyword2",
    "mcrypt_ecb": "keyword2",
    "mcrypt_enc_get_algorithms_name": "keyword2",
    "mcrypt_enc_get_block_size": "keyword2",
    "mcrypt_enc_get_iv_size": "keyword2",
    "mcrypt_enc_get_key_size": "keyword2",
    "mcrypt_enc_get_modes_name": "keyword2",
    "mcrypt_enc_get_supported_key_sizes": "keyword2",
    "mcrypt_enc_is_block_algorithm": "keyword2",
    "mcrypt_enc_is_block_algorithm_mode": "keyword2",
    "mcrypt_enc_is_block_mode": "keyword2",
    "mcrypt_enc_self_test": "keyword2",
    "mcrypt_encrypt": "keyword2",
    "mcrypt_generic": "keyword2",
    "mcrypt_generic_deinit": "keyword2",
    "mcrypt_generic_end": "keyword2",
    "mcrypt_generic_init": "keyword2",
    "mcrypt_get_block_size": "keyword2",
    "mcrypt_get_cipher_name": "keyword2",
    "mcrypt_get_iv_size": "keyword2",
    "mcrypt_get_key_size": "keyword2",
    "mcrypt_list_algorithms": "keyword2",
    "mcrypt_list_modes": "keyword2",
    "mcrypt_module_close": "keyword2",
    "mcrypt_module_get_algo_block_size": "keyword2",
    "mcrypt_module_get_algo_key_size": "keyword2",
    "mcrypt_module_get_supported_key_sizes": "keyword2",
    "mcrypt_module_is_block_algorithm": "keyword2",
    "mcrypt_module_is_block_algorithm_mode": "keyword2",
    "mcrypt_module_is_block_mode": "keyword2",
    "mcrypt_module_open": "keyword2",
    "mcrypt_module_self_test": "keyword2",
    "mcrypt_ofb": "keyword2",
    "md5": "keyword2",
    "md5_file": "keyword2",
    "mdecrypt_generic": "keyword2",
    "metaphone": "keyword2",
    "method_exists": "keyword2",
    "mhash": "keyword2",
    "mhash_count": "keyword2",
    "mhash_get_block_size": "keyword2",
    "mhash_get_hash_name": "keyword2",
    "mhash_keygen_s2k": "keyword2",
    "microtime": "keyword2",
    "min": "keyword2",
    "ming_setcubicthreshold": "keyword2",
    "ming_setscale": "keyword2",
    "mkdir": "keyword2",
    "mktime": "keyword2",
    "move": "keyword2",
    "move_uploaded_file": "keyword2",
    "movepen": "keyword2",
    "movepento": "keyword2",
    "moveto": "keyword2",
    "msql": "keyword2",
    "msql_affected_rows": "keyword2",
    "msql_close": "keyword2",
    "msql_connect": "keyword2",
    "msql_create_db": "keyword2",
    "msql_createdb": "keyword2",
    "msql_data_seek": "keyword2",
    "msql_db_query": "keyword2",
    "msql_dbname": "keyword2",
    "msql_drop_db": "keyword2",
    "msql_dropdb": "keyword2",
    "msql_error": "keyword2",
    "msql_fetch_array": "keyword2",
    "msql_fetch_field": "keyword2",
    "msql_fetch_object": "keyword2",
    "msql_fetch_row": "keyword2",
    "msql_field_flags": "keyword2",
    "msql_field_len": "keyword2",
    "msql_field_name": "keyword2",
    "msql_field_seek": "keyword2",
    "msql_field_table": "keyword2",
    "msql_field_type": "keyword2",
    "msql_fieldflags": "keyword2",
    "msql_fieldlen": "keyword2",
    "msql_fieldname": "keyword2",
    "msql_fieldtable": "keyword2",
    "msql_fieldtype": "keyword2",
    "msql_free_result": "keyword2",
    "msql_freeresult": "keyword2",
    "msql_list_dbs": "keyword2",
    "msql_list_fields": "keyword2",
    "msql_list_tables": "keyword2",
    "msql_listdbs": "keyword2",
    "msql_listfields": "keyword2",
    "msql_listtables": "keyword2",
    "msql_num_fields": "keyword2",
    "msql_num_rows": "keyword2",
    "msql_numfields": "keyword2",
    "msql_numrows": "keyword2",
    "msql_pconnect": "keyword2",
    "msql_query": "keyword2",
    "msql_regcase": "keyword2",
    "msql_result": "keyword2",
    "msql_select_db": "keyword2",
    "msql_selectdb": "keyword2",
    "msql_tablename": "keyword2",
    "mssql_affected_rows": "keyword2",
    "mssql_close": "keyword2",
    "mssql_connect": "keyword2",
    "mssql_data_seek": "keyword2",
    "mssql_fetch_array": "keyword2",
    "mssql_fetch_batch": "keyword2",
    "mssql_fetch_field": "keyword2",
    "mssql_fetch_object": "keyword2",
    "mssql_fetch_row": "keyword2",
    "mssql_field_length": "keyword2",
    "mssql_field_name": "keyword2",
    "mssql_field_seek": "keyword2",
    "mssql_field_type": "keyword2",
    "mssql_free_result": "keyword2",
    "mssql_get_last_message": "keyword2",
    "mssql_min_client_severity": "keyword2",
    "mssql_min_error_severity": "keyword2",
    "mssql_min_message_severity": "keyword2",
    "mssql_min_server_severity": "keyword2",
    "mssql_next_result": "keyword2",
    "mssql_num_fields": "keyword2",
    "mssql_num_rows": "keyword2",
    "mssql_pconnect": "keyword2",
    "mssql_query": "keyword2",
    "mssql_result": "keyword2",
    "mssql_rows_affected": "keyword2",
    "mssql_select_db": "keyword2",
    "mt_getrandmax": "keyword2",
    "mt_rand": "keyword2",
    "mt_srand": "keyword2",
    "multcolor": "keyword2",
    "muscat_close": "keyword2",
    "muscat_get": "keyword2",
    "muscat_give": "keyword2",
    "muscat_setup": "keyword2",
    "muscat_setup_net": "keyword2",
    "mysql": "keyword2",
    "mysql_affected_rows": "keyword2",
    "mysql_close": "keyword2",
    "mysql_connect": "keyword2",
    "mysql_create_db": "keyword2",
    "mysql_createdb": "keyword2",
    "mysql_data_seek": "keyword2",
    "mysql_db_name": "keyword2",
    "mysql_db_query": "keyword2",
    "mysql_dbname": "keyword2",
    "mysql_drop_db": "keyword2",
    "mysql_dropdb": "keyword2",
    "mysql_errno": "keyword2",
    "mysql_error": "keyword2",
    "mysql_escape_string": "keyword2",
    "mysql_fetch_array": "keyword2",
    "mysql_fetch_assoc": "keyword2",
    "mysql_fetch_field": "keyword2",
    "mysql_fetch_lengths": "keyword2",
    "mysql_fetch_object": "keyword2",
    "mysql_fetch_row": "keyword2",
    "mysql_field_flags": "keyword2",
    "mysql_field_len": "keyword2",
    "mysql_field_name": "keyword2",
    "mysql_field_seek": "keyword2",
    "mysql_field_table": "keyword2",
    "mysql_field_type": "keyword2",
    "mysql_fieldflags": "keyword2",
    "mysql_fieldlen": "keyword2",
    "mysql_fieldname": "keyword2",
    "mysql_fieldtable": "keyword2",
    "mysql_fieldtype": "keyword2",
    "mysql_free_result": "keyword2",
    "mysql_freeresult": "keyword2",
    "mysql_get_client_info": "keyword2",
    "mysql_get_host_info": "keyword2",
    "mysql_get_proto_info": "keyword2",
    "mysql_get_server_info": "keyword2",
    "mysql_insert_id": "keyword2",
    "mysql_list_dbs": "keyword2",
    "mysql_list_fields": "keyword2",
    "mysql_list_tables": "keyword2",
    "mysql_listdbs": "keyword2",
    "mysql_listfields": "keyword2",
    "mysql_listtables": "keyword2",
    "mysql_num_fields": "keyword2",
    "mysql_num_rows": "keyword2",
    "mysql_numfields": "keyword2",
    "mysql_numrows": "keyword2",
    "mysql_pconnect": "keyword2",
    "mysql_query": "keyword2",
    "mysql_result": "keyword2",
    "mysql_select_db": "keyword2",
    "mysql_selectdb": "keyword2",
    "mysql_tablename": "keyword2",
    "mysql_unbuffered_query": "keyword2",
    "natcasesort": "keyword2",
    "natsort": "keyword2",
    "new": "keyword1",
    "new_xmldoc": "keyword2",
    "next": "keyword2",
    "nextframe": "keyword2",
    "nl2br": "keyword2",
    "notes_body": "keyword2",
    "notes_copy_db": "keyword2",
    "notes_create_db": "keyword2",
    "notes_create_note": "keyword2",
    "notes_drop_db": "keyword2",
    "notes_find_note": "keyword2",
    "notes_header_info": "keyword2",
    "notes_list_msgs": "keyword2",
    "notes_mark_read": "keyword2",
    "notes_mark_unread": "keyword2",
    "notes_nav_create": "keyword2",
    "notes_search": "keyword2",
    "notes_unread": "keyword2",
    "notes_version": "keyword2",
    "null": "keyword3",
    "number_format": "keyword2",
    "ob_end_clean": "keyword2",
    "ob_end_flush": "keyword2",
    "ob_get_clean": "keyword2",
    "ob_get_contents": "keyword2",
    "ob_get_flush": "keyword2",
    "ob_get_length": "keyword2",
    "ob_gzhandler": "keyword2",
    "ob_iconv_handler": "keyword2",
    "ob_implicit_flush": "keyword2",
    "ob_list_handlers": "keyword2",
    "ob_start": "keyword2",
    "ocibindbyname": "keyword2",
    "ocicancel": "keyword2",
    "ocicollappend": "keyword2",
    "ocicollassign": "keyword2",
    "ocicollassignelem": "keyword2",
    "ocicolldateappendelem": "keyword2",
    "ocicolldateassignelem": "keyword2",
    "ocicolldategetelem": "keyword2",
    "ocicollgetelem": "keyword2",
    "ocicollmax": "keyword2",
    "ocicollsize": "keyword2",
    "ocicolltrim": "keyword2",
    "ocicolumnisnull": "keyword2",
    "ocicolumnname": "keyword2",
    "ocicolumnprecision": "keyword2",
    "ocicolumnscale": "keyword2",
    "ocicolumnsize": "keyword2",
    "ocicolumntype": "keyword2",
    "ocicolumntyperaw": "keyword2",
    "ocicommit": "keyword2",
    "ocidefinebyname": "keyword2",
    "ocierror": "keyword2",
    "ociexecute": "keyword2",
    "ocifetch": "keyword2",
    "ocifetchinto": "keyword2",
    "ocifetchstatement": "keyword2",
    "ocifreecoll": "keyword2",
    "ocifreecursor": "keyword2",
    "ocifreedesc": "keyword2",
    "ocifreestatement": "keyword2",
    "ociinternaldebug": "keyword2",
    "ociloadlob": "keyword2",
    "ocilogoff": "keyword2",
    "ocilogon": "keyword2",
    "ocinewcollection": "keyword2",
    "ocinewcursor": "keyword2",
    "ocinewdescriptor": "keyword2",
    "ocinlogon": "keyword2",
    "ocinumcols": "keyword2",
    "ociparse": "keyword2",
    "ociplogon": "keyword2",
    "ociresult": "keyword2",
    "ocirollback": "keyword2",
    "ocirowcount": "keyword2",
    "ocisavelob": "keyword2",
    "ocisavelobfile": "keyword2",
    "ociserverversion": "keyword2",
    "ocisetprefetch": "keyword2",
    "ocistatementtype": "keyword2",
    "ociwritelobtofile": "keyword2",
    "octdec": "keyword2",
    "odbc_autocommit": "keyword2",
    "odbc_binmode": "keyword2",
    "odbc_close": "keyword2",
    "odbc_close_all": "keyword2",
    "odbc_columnprivileges": "keyword2",
    "odbc_columns": "keyword2",
    "odbc_commit": "keyword2",
    "odbc_connect": "keyword2",
    "odbc_cursor": "keyword2",
    "odbc_data_source": "keyword2",
    "odbc_do": "keyword2",
    "odbc_error": "keyword2",
    "odbc_errormsg": "keyword2",
    "odbc_exec": "keyword2",
    "odbc_execute": "keyword2",
    "odbc_fetch_array": "keyword2",
    "odbc_fetch_into": "keyword2",
    "odbc_fetch_object": "keyword2",
    "odbc_fetch_row": "keyword2",
    "odbc_field_len": "keyword2",
    "odbc_field_name": "keyword2",
    "odbc_field_num": "keyword2",
    "odbc_field_precision": "keyword2",
    "odbc_field_scale": "keyword2",
    "odbc_field_type": "keyword2",
    "odbc_foreignkeys": "keyword2",
    "odbc_free_result": "keyword2",
    "odbc_gettypeinfo": "keyword2",
    "odbc_longreadlen": "keyword2",
    "odbc_next_result": "keyword2",
    "odbc_num_fields": "keyword2",
    "odbc_num_rows": "keyword2",
    "odbc_pconnect": "keyword2",
    "odbc_prepare": "keyword2",
    "odbc_primarykeys": "keyword2",
    "odbc_procedurecolumns": "keyword2",
    "odbc_procedures": "keyword2",
    "odbc_result": "keyword2",
    "odbc_result_all": "keyword2",
    "odbc_rollback": "keyword2",
    "odbc_setoption": "keyword2",
    "odbc_specialcolumns": "keyword2",
    "odbc_statistics": "keyword2",
    "odbc_tableprivileges": "keyword2",
    "odbc_tables": "keyword2",
    "old_function": "keyword1",
    "open_listen_sock": "keyword2",
    "opendir": "keyword2",
    "openlog": "keyword2",
    "openssl_error_string": "keyword2",
    "openssl_free_key": "keyword2",
    "openssl_get_privatekey": "keyword2",
    "openssl_get_publickey": "keyword2",
    "openssl_open": "keyword2",
    "openssl_pkcs7_decrypt": "keyword2",
    "openssl_pkcs7_encrypt": "keyword2",
    "openssl_pkcs7_sign": "keyword2",
    "openssl_pkcs7_verify": "keyword2",
    "openssl_seal": "keyword2",
    "openssl_sign": "keyword2",
    "openssl_verify": "keyword2",
    "openssl_x509_checkpurpose": "keyword2",
    "openssl_x509_free": "keyword2",
    "openssl_x509_parse": "keyword2",
    "openssl_x509_read": "keyword2",
    "or": "operator",
    "ora_bind": "keyword2",
    "ora_close": "keyword2",
    "ora_columnname": "keyword2",
    "ora_columnsize": "keyword2",
    "ora_columntype": "keyword2",
    "ora_commit": "keyword2",
    "ora_commitoff": "keyword2",
    "ora_commiton": "keyword2",
    "ora_do": "keyword2",
    "ora_error": "keyword2",
    "ora_errorcode": "keyword2",
    "ora_exec": "keyword2",
    "ora_fetch": "keyword2",
    "ora_fetch_into": "keyword2",
    "ora_getcolumn": "keyword2",
    "ora_logoff": "keyword2",
    "ora_logon": "keyword2",
    "ora_numcols": "keyword2",
    "ora_numrows": "keyword2",
    "ora_open": "keyword2",
    "ora_parse": "keyword2",
    "ora_plogon": "keyword2",
    "ora_rollback": "keyword2",
    "orbit_caught_exception": "keyword2",
    "orbit_exception_id": "keyword2",
    "orbit_exception_value": "keyword2",
    "orbit_get_repository_id": "keyword2",
    "orbit_load_idl": "keyword2",
    "ord": "keyword2",
    "output": "keyword2",
    "ovrimos_close": "keyword2",
    "ovrimos_close_all": "keyword2",
    "ovrimos_commit": "keyword2",
    "ovrimos_connect": "keyword2",
    "ovrimos_cursor": "keyword2",
    "ovrimos_exec": "keyword2",
    "ovrimos_execute": "keyword2",
    "ovrimos_fetch_into": "keyword2",
    "ovrimos_fetch_row": "keyword2",
    "ovrimos_field_len": "keyword2",
    "ovrimos_field_name": "keyword2",
    "ovrimos_field_num": "keyword2",
    "ovrimos_field_type": "keyword2",
    "ovrimos_free_result": "keyword2",
    "ovrimos_longreadlen": "keyword2",
    "ovrimos_num_fields": "keyword2",
    "ovrimos_num_rows": "keyword2",
    "ovrimos_prepare": "keyword2",
    "ovrimos_result": "keyword2",
    "ovrimos_result_all": "keyword2",
    "ovrimos_rollback": "keyword2",
    "pack": "keyword2",
    "parse_ini_file": "keyword2",
    "parse_str": "keyword2",
    "parse_url": "keyword2",
    "passthru": "keyword2",
    "pathinfo": "keyword2",
    "pclose": "keyword2",
    "pdf_add_annotation": "keyword2",
    "pdf_add_bookmark": "keyword2",
    "pdf_add_launchlink": "keyword2",
    "pdf_add_locallink": "keyword2",
    "pdf_add_note": "keyword2",
    "pdf_add_outline": "keyword2",
    "pdf_add_pdflink": "keyword2",
    "pdf_add_thumbnail": "keyword2",
    "pdf_add_weblink": "keyword2",
    "pdf_arc": "keyword2",
    "pdf_arcn": "keyword2",
    "pdf_attach_file": "keyword2",
    "pdf_begin_page": "keyword2",
    "pdf_begin_pattern": "keyword2",
    "pdf_begin_template": "keyword2",
    "pdf_circle": "keyword2",
    "pdf_clip": "keyword2",
    "pdf_close": "keyword2",
    "pdf_close_image": "keyword2",
    "pdf_close_pdi": "keyword2",
    "pdf_close_pdi_page": "keyword2",
    "pdf_closepath": "keyword2",
    "pdf_closepath_fill_stroke": "keyword2",
    "pdf_closepath_stroke": "keyword2",
    "pdf_concat": "keyword2",
    "pdf_continue_text": "keyword2",
    "pdf_curveto": "keyword2",
    "pdf_delete": "keyword2",
    "pdf_end_page": "keyword2",
    "pdf_end_pattern": "keyword2",
    "pdf_end_template": "keyword2",
    "pdf_endpath": "keyword2",
    "pdf_fill": "keyword2",
    "pdf_fill_stroke": "keyword2",
    "pdf_findfont": "keyword2",
    "pdf_get_buffer": "keyword2",
    "pdf_get_font": "keyword2",
    "pdf_get_fontname": "keyword2",
    "pdf_get_fontsize": "keyword2",
    "pdf_get_image_height": "keyword2",
    "pdf_get_image_width": "keyword2",
    "pdf_get_parameter": "keyword2",
    "pdf_get_pdi_parameter": "keyword2",
    "pdf_get_pdi_value": "keyword2",
    "pdf_get_value": "keyword2",
    "pdf_initgraphics": "keyword2",
    "pdf_lineto": "keyword2",
    "pdf_makespotcolor": "keyword2",
    "pdf_moveto": "keyword2",
    "pdf_new": "keyword2",
    "pdf_open": "keyword2",
    "pdf_open_ccitt": "keyword2",
    "pdf_open_file": "keyword2",
    "pdf_open_gif": "keyword2",
    "pdf_open_image": "keyword2",
    "pdf_open_image_file": "keyword2",
    "pdf_open_jpeg": "keyword2",
    "pdf_open_memory_image": "keyword2",
    "pdf_open_pdi": "keyword2",
    "pdf_open_pdi_page": "keyword2",
    "pdf_open_png": "keyword2",
    "pdf_open_tiff": "keyword2",
    "pdf_place_image": "keyword2",
    "pdf_place_pdi_page": "keyword2",
    "pdf_rect": "keyword2",
    "pdf_restore": "keyword2",
    "pdf_rotate": "keyword2",
    "pdf_save": "keyword2",
    "pdf_scale": "keyword2",
    "pdf_set_border_color": "keyword2",
    "pdf_set_border_dash": "keyword2",
    "pdf_set_border_style": "keyword2",
    "pdf_set_char_spacing": "keyword2",
    "pdf_set_duration": "keyword2",
    "pdf_set_font": "keyword2",
    "pdf_set_horiz_scaling": "keyword2",
    "pdf_set_info": "keyword2",
    "pdf_set_info_author": "keyword2",
    "pdf_set_info_creator": "keyword2",
    "pdf_set_info_keywords": "keyword2",
    "pdf_set_info_subject": "keyword2",
    "pdf_set_info_title": "keyword2",
    "pdf_set_leading": "keyword2",
    "pdf_set_parameter": "keyword2",
    "pdf_set_text_pos": "keyword2",
    "pdf_set_text_rendering": "keyword2",
    "pdf_set_text_rise": "keyword2",
    "pdf_set_transition": "keyword2",
    "pdf_set_value": "keyword2",
    "pdf_set_word_spacing": "keyword2",
    "pdf_setcolor": "keyword2",
    "pdf_setdash": "keyword2",
    "pdf_setflat": "keyword2",
    "pdf_setfont": "keyword2",
    "pdf_setgray": "keyword2",
    "pdf_setgray_fill": "keyword2",
    "pdf_setgray_stroke": "keyword2",
    "pdf_setlinecap": "keyword2",
    "pdf_setlinejoin": "keyword2",
    "pdf_setlinewidth": "keyword2",
    "pdf_setmatrix": "keyword2",
    "pdf_setmiterlimit": "keyword2",
    "pdf_setpolydash": "keyword2",
    "pdf_setrgbcolor": "keyword2",
    "pdf_setrgbcolor_fill": "keyword2",
    "pdf_setrgbcolor_stroke": "keyword2",
    "pdf_show": "keyword2",
    "pdf_show_boxed": "keyword2",
    "pdf_show_xy": "keyword2",
    "pdf_skew": "keyword2",
    "pdf_stringwidth": "keyword2",
    "pdf_stroke": "keyword2",
    "pdf_translate": "keyword2",
    "pfpro_cleanup": "keyword2",
    "pfpro_init": "keyword2",
    "pfpro_process": "keyword2",
    "pfpro_process_raw": "keyword2",
    "pfpro_version": "keyword2",
    "pfsockopen": "keyword2",
    "pg_client_encoding": "keyword2",
    "pg_clientencoding": "keyword2",
    "pg_close": "keyword2",
    "pg_cmdtuples": "keyword2",
    "pg_connect": "keyword2",
    "pg_convert": "keyword2",
    "pg_dbname": "keyword2",
    "pg_delete": "keyword2",
    "pg_end_copy": "keyword2",
    "pg_errormessage": "keyword2",
    "pg_exec": "keyword2",
    "pg_fetch_all": "keyword2",
    "pg_fetch_array": "keyword2",
    "pg_fetch_assoc": "keyword2",
    "pg_fetch_object": "keyword2",
    "pg_fetch_row": "keyword2",
    "pg_fieldisnull": "keyword2",
    "pg_fieldname": "keyword2",
    "pg_fieldnum": "keyword2",
    "pg_fieldprtlen": "keyword2",
    "pg_fieldsize": "keyword2",
    "pg_fieldtype": "keyword2",
    "pg_freeresult": "keyword2",
    "pg_get_notify": "keyword2",
    "pg_get_pid": "keyword2",
    "pg_getlastoid": "keyword2",
    "pg_host": "keyword2",
    "pg_insert": "keyword2",
    "pg_loclose": "keyword2",
    "pg_locreate": "keyword2",
    "pg_loexport": "keyword2",
    "pg_loimport": "keyword2",
    "pg_loopen": "keyword2",
    "pg_loread": "keyword2",
    "pg_loreadall": "keyword2",
    "pg_lounlink": "keyword2",
    "pg_lowrite": "keyword2",
    "pg_meta_data": "keyword2",
    "pg_numfields": "keyword2",
    "pg_numrows": "keyword2",
    "pg_options": "keyword2",
    "pg_pconnect": "keyword2",
    "pg_ping": "keyword2",
    "pg_port": "keyword2",
    "pg_put_line": "keyword2",
    "pg_result": "keyword2",
    "pg_result_seek": "keyword2",
    "pg_select": "keyword2",
    "pg_set_client_encoding": "keyword2",
    "pg_setclientencoding": "keyword2",
    "pg_trace": "keyword2",
    "pg_tty": "keyword2",
    "pg_unescape_bytea": "keyword2",
    "pg_untrace": "keyword2",
    "pg_update": "keyword2",
    "php_logo_guid": "keyword2",
    "php_sapi_name": "keyword2",
    "php_uname": "keyword2",
    "phpcredits": "keyword2",
    "phpinfo": "keyword2",
    "phpversion": "keyword2",
    "pi": "keyword2",
    "png2wbmp": "keyword2",
    "popen": "keyword2",
    "pos": "keyword2",
    "posix_ctermid": "keyword2",
    "posix_getcwd": "keyword2",
    "posix_getegid": "keyword2",
    "posix_geteuid": "keyword2",
    "posix_getgid": "keyword2",
    "posix_getgrgid": "keyword2",
    "posix_getgrnam": "keyword2",
    "posix_getgroups": "keyword2",
    "posix_getlogin": "keyword2",
    "posix_getpgid": "keyword2",
    "posix_getpgrp": "keyword2",
    "posix_getpid": "keyword2",
    "posix_getppid": "keyword2",
    "posix_getpwnam": "keyword2",
    "posix_getpwuid": "keyword2",
    "posix_getrlimit": "keyword2",
    "posix_getsid": "keyword2",
    "posix_getuid": "keyword2",
    "posix_isatty": "keyword2",
    "posix_kill": "keyword2",
    "posix_mkfifo": "keyword2",
    "posix_setegid": "keyword2",
    "posix_seteuid": "keyword2",
    "posix_setgid": "keyword2",
    "posix_setpgid": "keyword2",
    "posix_setsid": "keyword2",
    "posix_setuid": "keyword2",
    "posix_times": "keyword2",
    "posix_ttyname": "keyword2",
    "posix_uname": "keyword2",
    "pow": "keyword2",
    "preg_grep": "keyword2",
    "preg_match": "keyword2",
    "preg_match_all": "keyword2",
    "preg_quote": "keyword2",
    "preg_replace": "keyword2",
    "preg_replace_callback": "keyword2",
    "preg_split": "keyword2",
    "prev": "keyword2",
    "print_r": "keyword2",
    "printer_abort": "keyword2",
    "printer_close": "keyword2",
    "printer_create_brush": "keyword2",
    "printer_create_dc": "keyword2",
    "printer_create_font": "keyword2",
    "printer_create_pen": "keyword2",
    "printer_delete_brush": "keyword2",
    "printer_delete_dc": "keyword2",
    "printer_delete_font": "keyword2",
    "printer_delete_pen": "keyword2",
    "printer_draw_bmp": "keyword2",
    "printer_draw_chord": "keyword2",
    "printer_draw_elipse": "keyword2",
    "printer_draw_line": "keyword2",
    "printer_draw_pie": "keyword2",
    "printer_draw_rectangle": "keyword2",
    "printer_draw_roundrect": "keyword2",
    "printer_draw_text": "keyword2",
    "printer_end_doc": "keyword2",
    "printer_end_page": "keyword2",
    "printer_get_option": "keyword2",
    "printer_list": "keyword2",
    "printer_logical_fontheight": "keyword2",
    "printer_open": "keyword2",
    "printer_select_brush": "keyword2",
    "printer_select_font": "keyword2",
    "printer_select_pen": "keyword2",
    "printer_set_option": "keyword2",
    "printer_start_doc": "keyword2",
    "printer_start_page": "keyword2",
    "printer_write": "keyword2",
    "printf": "keyword2",
    "private": "keyword1",
    "protected": "keyword1",
    "pspell_add_to_personal": "keyword2",
    "pspell_add_to_session": "keyword2",
    "pspell_check": "keyword2",
    "pspell_clear_session": "keyword2",
    "pspell_config_create": "keyword2",
    "pspell_config_ignore": "keyword2",
    "pspell_config_mode": "keyword2",
    "pspell_config_personal": "keyword2",
    "pspell_config_repl": "keyword2",
    "pspell_config_runtogether": "keyword2",
    "pspell_config_save_repl": "keyword2",
    "pspell_new": "keyword2",
    "pspell_new_config": "keyword2",
    "pspell_new_personal": "keyword2",
    "pspell_save_wordlist": "keyword2",
    "pspell_store_replacement": "keyword2",
    "pspell_suggest": "keyword2",
    "public": "keyword1",
    "putenv": "keyword2",
    "qdom_error": "keyword2",
    "qdom_tree": "keyword2",
    "quoted_printable_decode": "keyword2",
    "quotemeta": "keyword2",
    "rad2deg": "keyword2",
    "rand": "keyword2",
    "range": "keyword2",
    "rawurldecode": "keyword2",
    "rawurlencode": "keyword2",
    "read": "keyword2",
    "read_exif_data": "keyword2",
    "readdir": "keyword2",
    "readfile": "keyword2",
    "readgzfile": "keyword2",
    "readline": "keyword2",
    "readline_add_history": "keyword2",
    "readline_clear_history": "keyword2",
    "readline_completion_function": "keyword2",
    "readline_info": "keyword2",
    "readline_list_history": "keyword2",
    "readline_read_history": "keyword2",
    "readline_write_history": "keyword2",
    "readlink": "keyword2",
    "readv": "keyword2",
    "realpath": "keyword2",
    "recode": "keyword2",
    "recode_file": "keyword2",
    "recode_string": "keyword2",
    "recv": "keyword2",
    "recvfrom": "keyword2",
    "recvmsg": "keyword2",
    "register_shutdown_function": "keyword2",
    "register_tick_function": "keyword2",
    "remove": "keyword2",
    "rename": "keyword2",
    "require": "keyword1",
    "require_once": "keyword1",
    "reset": "keyword2",
    "restore_error_handler": "keyword2",
    "return": "keyword1",
    "rewind": "keyword2",
    "rewinddir": "keyword2",
    "rmdir": "keyword2",
    "rotate": "keyword2",
    "rotateto": "keyword2",
    "round": "keyword2",
    "rsort": "keyword2",
    "rtrim": "keyword2",
    "satellite_caught_exception": "keyword2",
    "satellite_exception_id": "keyword2",
    "satellite_exception_value": "keyword2",
    "satellite_get_repository_id": "keyword2",
    "satellite_load_idl": "keyword2",
    "save": "keyword2",
    "savetofile": "keyword2",
    "scale": "keyword2",
    "scaleto": "keyword2",
    "scandir": "keyword2",
    "select": "keyword2",
    "sem_acquire": "keyword2",
    "sem_get": "keyword2",
    "sem_release": "keyword2",
    "send": "keyword2",
    "sendmsg": "keyword2",
    "sendto": "keyword2",
    "serialize": "keyword2",
    "session_cache_limiter": "keyword2",
    "session_decode": "keyword2",
    "session_destroy": "keyword2",
    "session_encode": "keyword2",
    "session_get_cookie_params": "keyword2",
    "session_id": "keyword2",
    "session_is_registered": "keyword2",
    "session_module_name": "keyword2",
    "session_name": "keyword2",
    "session_register": "keyword2",
    "session_save_path": "keyword2",
    "session_set_cookie_params": "keyword2",
    "session_set_save_handler": "keyword2",
    "session_start": "keyword2",
    "session_unregister": "keyword2",
    "session_unset": "keyword2",
    "session_write_close": "keyword2",
    "set_content": "keyword2",
    "set_error_handler": "keyword2",
    "set_file_buffer": "keyword2",
    "set_iovec": "keyword2",
    "set_magic_quotes_runtime": "keyword2",
    "set_nonblock": "keyword2",
    "set_socket_blocking": "keyword2",
    "set_time_limit": "keyword2",
    "setaction": "keyword2",
    "setbackground": "keyword2",
    "setbounds": "keyword2",
    "setcolor": "keyword2",
    "setcookie": "keyword2",
    "setdepth": "keyword2",
    "setdimension": "keyword2",
    "setdown": "keyword2",
    "setfont": "keyword2",
    "setframes": "keyword2",
    "setheight": "keyword2",
    "sethit": "keyword2",
    "setindentation": "keyword2",
    "setleftfill": "keyword2",
    "setleftmargin": "keyword2",
    "setline": "keyword2",
    "setlinespacing": "keyword2",
    "setlocale": "keyword2",
    "setmargins": "keyword2",
    "setmatrix": "keyword2",
    "setname": "keyword2",
    "setover": "keyword2",
    "setrate": "keyword2",
    "setratio": "keyword2",
    "setrightfill": "keyword2",
    "setrightmargin": "keyword2",
    "setsockopt": "keyword2",
    "setspacing": "keyword2",
    "settype": "keyword2",
    "setup": "keyword2",
    "sha1": "keyword2",
    "sha1_file": "keyword2",
    "shell_exec": "keyword2",
    "shm_attach": "keyword2",
    "shm_detach": "keyword2",
    "shm_get_var": "keyword2",
    "shm_put_var": "keyword2",
    "shm_remove": "keyword2",
    "shm_remove_var": "keyword2",
    "shmop_close": "keyword2",
    "shmop_delete": "keyword2",
    "shmop_open": "keyword2",
    "shmop_read": "keyword2",
    "shmop_size": "keyword2",
    "shmop_write": "keyword2",
    "show_source": "keyword2",
    "shuffle": "keyword2",
    "shutdown": "keyword2",
    "signal": "keyword2",
    "similar_text": "keyword2",
    "sin": "keyword2",
    "sizeof": "keyword2",
    "skewx": "keyword2",
    "skewxto": "keyword2",
    "skewy": "keyword2",
    "skewyto": "keyword2",
    "sleep": "keyword2",
    "snmp_get_quick_print": "keyword2",
    "snmp_set_quick_print": "keyword2",
    "snmpget": "keyword2",
    "snmprealwalk": "keyword2",
    "snmpset": "keyword2",
    "snmpwalk": "keyword2",
    "snmpwalkoid": "keyword2",
    "socket": "keyword2",
    "socket_get_status": "keyword2",
    "socket_set_blocking": "keyword2",
    "socket_set_timeout": "keyword2",
    "socketpair": "keyword2",
    "sort": "keyword2",
    "soundex": "keyword2",
    "split": "keyword2",
    "spliti": "keyword2",
    "sprintf": "keyword2",
    "sql_regcase": "keyword2",
    "sqrt": "keyword2",
    "srand": "keyword2",
    "sscanf": "keyword2",
    "stat": "keyword2",
    "static": "keyword1",
    "str_pad": "keyword2",
    "str_repeat": "keyword2",
    "str_replace": "keyword2",
    "str_rot13": "keyword2",
    "str_split": "keyword2",
    "str_word_count": "keyword2",
    "strcasecmp": "keyword2",
    "strchr": "keyword2",
    "strcmp": "keyword2",
    "strcoll": "keyword2",
    "strcspn": "keyword2",
    "stream_context_create": "keyword2",
    "stream_context_set_option": "keyword2",
    "stream_context_set_params": "keyword2",
    "stream_filter_append": "keyword2",
    "stream_filter_prepend": "keyword2",
    "stream_get_status": "keyword2",
    "stream_select": "keyword2",
    "stream_set_blocking": "keyword2",
    "stream_set_timeout": "keyword2",
    "streammp3": "keyword2",
    "strerror": "keyword2",
    "strftime": "keyword2",
    "strip_tags": "keyword2",
    "stripcslashes": "keyword2",
    "stripos": "keyword2",
    "stripslashes": "keyword2",
    "stristr": "keyword2",
    "strlen": "keyword2",
    "strnatcasecmp": "keyword2",
    "strnatcmp": "keyword2",
    "strncasecmp": "keyword2",
    "strncmp": "keyword2",
    "strpbrk": "keyword2",
    "strpos": "keyword2",
    "strrchr": "keyword2",
    "strrev": "keyword2",
    "strrpos": "keyword2",
    "strspn": "keyword2",
    "strstr": "keyword2",
    "strtok": "keyword2",
    "strtolower": "keyword2",
    "strtotime": "keyword2",
    "strtoupper": "keyword2",
    "strtr": "keyword2",
    "strval": "keyword2",
    "substr": "keyword2",
    "substr_compare": "keyword2",
    "substr_count": "keyword2",
    "substr_replace": "keyword2",
    "swf_actiongeturl": "keyword2",
    "swf_actiongotoframe": "keyword2",
    "swf_actiongotolabel": "keyword2",
    "swf_actionnextframe": "keyword2",
    "swf_actionplay": "keyword2",
    "swf_actionprevframe": "keyword2",
    "swf_actionsettarget": "keyword2",
    "swf_actionstop": "keyword2",
    "swf_actiontogglequality": "keyword2",
    "swf_actionwaitforframe": "keyword2",
    "swf_addbuttonrecord": "keyword2",
    "swf_addcolor": "keyword2",
    "swf_closefile": "keyword2",
    "swf_definebitmap": "keyword2",
    "swf_definefont": "keyword2",
    "swf_defineline": "keyword2",
    "swf_definepoly": "keyword2",
    "swf_definerect": "keyword2",
    "swf_definetext": "keyword2",
    "swf_endbutton": "keyword2",
    "swf_enddoaction": "keyword2",
    "swf_endshape": "keyword2",
    "swf_endsymbol": "keyword2",
    "swf_fontsize": "keyword2",
    "swf_fontslant": "keyword2",
    "swf_fonttracking": "keyword2",
    "swf_getbitmapinfo": "keyword2",
    "swf_getfontinfo": "keyword2",
    "swf_getframe": "keyword2",
    "swf_labelframe": "keyword2",
    "swf_lookat": "keyword2",
    "swf_modifyobject": "keyword2",
    "swf_mulcolor": "keyword2",
    "swf_nextid": "keyword2",
    "swf_oncondition": "keyword2",
    "swf_openfile": "keyword2",
    "swf_ortho": "keyword2",
    "swf_ortho2": "keyword2",
    "swf_perspective": "keyword2",
    "swf_placeobject": "keyword2",
    "swf_polarview": "keyword2",
    "swf_popmatrix": "keyword2",
    "swf_posround": "keyword2",
    "swf_pushmatrix": "keyword2",
    "swf_removeobject": "keyword2",
    "swf_rotate": "keyword2",
    "swf_scale": "keyword2",
    "swf_setfont": "keyword2",
    "swf_setframe": "keyword2",
    "swf_shapearc": "keyword2",
    "swf_shapecurveto": "keyword2",
    "swf_shapecurveto3": "keyword2",
    "swf_shapefillbitmapclip": "keyword2",
    "swf_shapefillbitmaptile": "keyword2",
    "swf_shapefilloff": "keyword2",
    "swf_shapefillsolid": "keyword2",
    "swf_shapelinesolid": "keyword2",
    "swf_shapelineto": "keyword2",
    "swf_shapemoveto": "keyword2",
    "swf_showframe": "keyword2",
    "swf_startbutton": "keyword2",
    "swf_startdoaction": "keyword2",
    "swf_startshape": "keyword2",
    "swf_startsymbol": "keyword2",
    "swf_textwidth": "keyword2",
    "swf_translate": "keyword2",
    "swf_viewport": "keyword2",
    "swfaction": "keyword2",
    "swfbitmap": "keyword2",
    "swfbutton": "keyword2",
    "swfbutton_keypress": "keyword2",
    "swffill": "keyword2",
    "swffont": "keyword2",
    "swfgradient": "keyword2",
    "swfmorph": "keyword2",
    "swfmovie": "keyword2",
    "swfshape": "keyword2",
    "swfsprite": "keyword2",
    "swftext": "keyword2",
    "swftextfield": "keyword2",
    "switch": "keyword1",
    "sybase_affected_rows": "keyword2",
    "sybase_close": "keyword2",
    "sybase_connect": "keyword2",
    "sybase_data_seek": "keyword2",
    "sybase_fetch_array": "keyword2",
    "sybase_fetch_field": "keyword2",
    "sybase_fetch_object": "keyword2",
    "sybase_fetch_row": "keyword2",
    "sybase_field_seek": "keyword2",
    "sybase_free_result": "keyword2",
    "sybase_get_last_message": "keyword2",
    "sybase_min_client_severity": "keyword2",
    "sybase_min_error_severity": "keyword2",
    "sybase_min_message_severity": "keyword2",
    "sybase_min_server_severity": "keyword2",
    "sybase_num_fields": "keyword2",
    "sybase_num_rows": "keyword2",
    "sybase_pconnect": "keyword2",
    "sybase_query": "keyword2",
    "sybase_result": "keyword2",
    "sybase_select_db": "keyword2",
    "symlink": "keyword2",
    "syslog": "keyword2",
    "system": "keyword2",
    "tan": "keyword2",
    "tempnam": "keyword2",
    "textdomain": "keyword2",
    "throw": "keyword1",
    "time": "keyword2",
    "time_nanosleep": "keyword2",
    "tmpfile": "keyword2",
    "touch": "keyword2",
    "trigger_error": "keyword2",
    "trim": "keyword2",
    "true": "keyword3",
    "try": "keyword1",
    "uasort": "keyword2",
    "ucfirst": "keyword2",
    "ucwords": "keyword2",
    "udm_add_search_limit": "keyword2",
    "udm_alloc_agent": "keyword2",
    "udm_api_version": "keyword2",
    "udm_clear_search_limits": "keyword2",
    "udm_errno": "keyword2",
    "udm_error": "keyword2",
    "udm_find": "keyword2",
    "udm_free_agent": "keyword2",
    "udm_free_ispell_data": "keyword2",
    "udm_free_res": "keyword2",
    "udm_get_doc_count": "keyword2",
    "udm_get_res_field": "keyword2",
    "udm_get_res_param": "keyword2",
    "udm_load_ispell_data": "keyword2",
    "udm_set_agent_param": "keyword2",
    "uksort": "keyword2",
    "umask": "keyword2",
    "uniqid": "keyword2",
    "unixtojd": "keyword2",
    "unlink": "keyword2",
    "unpack": "keyword2",
    "unregister_tick_function": "keyword2",
    "unserialize": "keyword2",
    "unset": "keyword2",
    "urldecode": "keyword2",
    "urlencode": "keyword2",
    "user_error": "keyword2",
    "usleep": "keyword2",
    "usort": "keyword2",
    "utf8_decode": "keyword2",
    "utf8_encode": "keyword2",
    "var": "keyword1",
    "var_dump": "keyword2",
    "velocis_autocommit": "keyword2",
    "velocis_close": "keyword2",
    "velocis_commit": "keyword2",
    "velocis_connect": "keyword2",
    "velocis_exec": "keyword2",
    "velocis_fetch": "keyword2",
    "velocis_fieldname": "keyword2",
    "velocis_fieldnum": "keyword2",
    "velocis_freeresult": "keyword2",
    "velocis_off_autocommit": "keyword2",
    "velocis_result": "keyword2",
    "velocis_rollback": "keyword2",
    "virtual": "keyword2",
    "vpopmail_add_alias_domain": "keyword2",
    "vpopmail_add_alias_domain_ex": "keyword2",
    "vpopmail_add_domain": "keyword2",
    "vpopmail_add_domain_ex": "keyword2",
    "vpopmail_add_user": "keyword2",
    "vpopmail_auth_user": "keyword2",
    "vpopmail_del_domain": "keyword2",
    "vpopmail_del_domain_ex": "keyword2",
    "vpopmail_del_user": "keyword2",
    "vpopmail_error": "keyword2",
    "vpopmail_passwd": "keyword2",
    "vpopmail_set_user_quota": "keyword2",
    "wddx_add_vars": "keyword2",
    "wddx_deserialize": "keyword2",
    "wddx_packet_end": "keyword2",
    "wddx_packet_start": "keyword2",
    "wddx_serialize_value": "keyword2",
    "wddx_serialize_vars": "keyword2",
    "while": "keyword1",
    "wordwrap": "keyword2",
    "write": "keyword2",
    "writev": "keyword2",
    "xml_error_string": "keyword2",
    "xml_get_current_byte_index": "keyword2",
    "xml_get_current_column_number": "keyword2",
    "xml_get_current_line_number": "keyword2",
    "xml_get_error_code": "keyword2",
    "xml_parse": "keyword2",
    "xml_parse_into_struct": "keyword2",
    "xml_parser_create": "keyword2",
    "xml_parser_create_ns": "keyword2",
    "xml_parser_free": "keyword2",
    "xml_parser_get_option": "keyword2",
    "xml_parser_set_option": "keyword2",
    "xml_set_character_data_handler": "keyword2",
    "xml_set_default_handler": "keyword2",
    "xml_set_element_handler": "keyword2",
    "xml_set_end_namespace_decl_handler": "keyword2",
    "xml_set_external_entity_ref_handler": "keyword2",
    "xml_set_notation_decl_handler": "keyword2",
    "xml_set_object": "keyword2",
    "xml_set_processing_instruction_handler": "keyword2",
    "xml_set_start_namespace_decl_handler": "keyword2",
    "xml_set_unparsed_entity_decl_handler": "keyword2",
    "xmldoc": "keyword2",
    "xmldocfile": "keyword2",
    "xmltree": "keyword2",
    "xpath_eval": "keyword2",
    "xpath_eval_expression": "keyword2",
    "xptr_eval": "keyword2",
    "xslt_closelog": "keyword2",
    "xslt_create": "keyword2",
    "xslt_errno": "keyword2",
    "xslt_error": "keyword2",
    "xslt_fetch_result": "keyword2",
    "xslt_free": "keyword2",
    "xslt_openlog": "keyword2",
    "xslt_output_begintransform": "keyword2",
    "xslt_output_endtransform": "keyword2",
    "xslt_process": "keyword2",
    "xslt_run": "keyword2",
    "xslt_set_base": "keyword2",
    "xslt_set_encoding": "keyword2",
    "xslt_set_error_handler": "keyword2",
    "xslt_set_sax_handler": "keyword2",
    "xslt_set_scheme_handler": "keyword2",
    "xslt_transform": "keyword2",
    "yaz_addinfo": "keyword2",
    "yaz_ccl_conf": "keyword2",
    "yaz_ccl_parse": "keyword2",
    "yaz_close": "keyword2",
    "yaz_connect": "keyword2",
    "yaz_database": "keyword2",
    "yaz_element": "keyword2",
    "yaz_errno": "keyword2",
    "yaz_error": "keyword2",
    "yaz_hits": "keyword2",
    "yaz_itemorder": "keyword2",
    "yaz_present": "keyword2",
    "yaz_range": "keyword2",
    "yaz_record": "keyword2",
    "yaz_scan": "keyword2",
    "yaz_scan_result": "keyword2",
    "yaz_search": "keyword2",
    "yaz_syntax": "keyword2",
    "yaz_wait": "keyword2",
    "yp_all": "keyword2",
    "yp_cat": "keyword2",
    "yp_err_string": "keyword2",
    "yp_errno": "keyword2",
    "yp_first": "keyword2",
    "yp_get_default_domain": "keyword2",
    "yp_master": "keyword2",
    "yp_match": "keyword2",
    "yp_next": "keyword2",
    "yp_order": "keyword2",
    "zend_logo_guid": "keyword2",
    "zend_test_func": "keyword2",
    "zend_version": "keyword2",
    "zzip_close": "keyword2",
    "zzip_closedir": "keyword2",
    "zzip_entry_compressedsize": "keyword2",
    "zzip_entry_compressionmethod": "keyword2",
    "zzip_entry_filesize": "keyword2",
    "zzip_entry_name": "keyword2",
    "zzip_open": "keyword2",
    "zzip_opendir": "keyword2",
    "zzip_read": "keyword2",
    "zzip_readdir": "keyword2",
}

# Keywords dict for php_php_literal ruleset.
php_php_literal_keywords_dict = {}

# Keywords dict for php_javascript ruleset.
php_javascript_keywords_dict = {}

# Keywords dict for php_javascript_php ruleset.
php_javascript_php_keywords_dict = {}

# Keywords dict for php_phpdoc ruleset.
php_phpdoc_keywords_dict = {
    "@abstract": "label",
    "@access": "label",
    "@author": "label",
    "@category": "label",
    "@copyright": "label",
    "@deprecated": "label",
    "@example": "label",
    "@filesource": "label",
    "@final": "label",
    "@global": "label",
    "@id": "label",
    "@ignore": "label",
    "@inheritdoc": "label",
    "@internal": "label",
    "@license": "label",
    "@link": "label",
    "@name": "label",
    "@package": "label",
    "@param": "label",
    "@return": "label",
    "@see": "label",
    "@since": "label",
    "@source": "label",
    "@static": "label",
    "@staticvar": "label",
    "@subpackage": "label",
    "@toc": "label",
    "@todo": "label",
    "@tutorial": "label",
    "@uses": "label",
    "@var": "label",
    "@version": "label",
}

# Dictionary of keywords dictionaries for php mode.
keywordsDictDict = {
    "php_javascript": php_javascript_keywords_dict,
    "php_javascript_php": php_javascript_php_keywords_dict,
    "php_main": php_main_keywords_dict,
    "php_php": php_php_keywords_dict,
    "php_php_literal": php_php_literal_keywords_dict,
    "php_phpdoc": php_phpdoc_keywords_dict,
    "php_tags": php_tags_keywords_dict,
    "php_tags_literal": php_tags_literal_keywords_dict,
}
</t>
<t tx="ekr.20201022053907.4"># Rules for php_main ruleset...
# All rules start with '&lt;' or '&amp;'.

def php_rule0(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_rule4(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="markup",
        begin="&lt;SCRIPT\\s+LANGUAGE=\"?PHP\"?&gt;", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_rule5(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;SCRIPT", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::javascript",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule6(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;STYLE", end="&lt;/STYLE&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="html::css",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule7(colorer, s, i):
    return colorer.match_span(s, i, kind="keyword2", begin="&lt;!", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::dtd-tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule8(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule9(colorer, s, i):
    return colorer.match_span(s, i, kind="literal2", begin="&amp;", end=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=True)

# Rules dict for php_main ruleset.
php_main_rulesdict = {
    "&amp;": [php_rule9],
    "&lt;": [php_rule0,php_rule1,php_rule2,php_rule3,php_rule4,php_rule5,php_rule6,php_rule7,php_rule8],
}
</t>
<t tx="ekr.20201022053907.5"># Rules for the php_tags ruleset...

def php_tags_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_tags_rule4(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_rule5(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_tags_rule6(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
        
# Rules dict for php_tags ruleset.
php_tags_rulesdict = {
    "\"": [php_tags_rule4,],
    "'": [php_tags_rule5,],
    "&lt;": [php_tags_rule1, php_tags_rule2, php_tags_rule3,],
    "=": [php_tags_rule6,],
}

</t>
<t tx="ekr.20201022053907.6">def php_tags_literal_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_literal_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_literal_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

# Rules dict for php_tags_literal ruleset.
php_tags_literal_rulesdict = {
    "&lt;": [
        php_tags_literal_rule1,
        php_tags_literal_rule2,
        php_tags_literal_rule3,
    ],
}
</t>
<t tx="ekr.20201022053907.7"># Rules for the php_php ruleset...

</t>
<t tx="ekr.20201022053907.8">def php_php_comment1(colorer, s, i):
    return colorer.match_span(s, i, kind="comment3", begin="/**", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::phpdoc",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_comment2(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="/*", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_comment3(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment2", seq="//",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)

def php_php_comment4(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="#",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)
</t>
<t tx="ekr.20201022053907.9">def php_php_literal1(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_literal2(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_literal3(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="`", end="`",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_literal4(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="literal1",
        begin="&lt;&lt;&lt;[[:space:]'\"]*([[:alnum:]_]+)[[:space:]'\"]*", end="$1",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
</t>
<t tx="ekr.20201022055738.1">use_php_hack = False

# Properties for php mode.
properties = {
    "commentEnd": "--&gt;",
    "commentStart": "&lt;!--",
    "indentCloseBrackets": "}",
    "indentOpenBrackets": "{",
    "lineUpClosingBracket": "true",
}

# Attributes dict for php_main ruleset.
php_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags ruleset.
php_tags_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags_literal ruleset.
php_tags_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php ruleset.
php_php_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php_literal ruleset.
php_php_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript ruleset.
php_javascript_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript_php ruleset.
php_javascript_php_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_phpdoc ruleset.
php_phpdoc_attributes_dict = {
    "default": "COMMENT3",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Dictionary of attributes dictionaries for php mode.
attributesDictDict = {
    "php_javascript": php_javascript_attributes_dict,
    "php_javascript_php": php_javascript_php_attributes_dict,
    "php_main": php_main_attributes_dict,
    "php_php": php_php_attributes_dict,
    "php_php_literal": php_php_literal_attributes_dict,
    "php_phpdoc": php_phpdoc_attributes_dict,
    "php_tags": php_tags_attributes_dict,
    "php_tags_literal": php_tags_literal_attributes_dict,
}

# Keywords dict for php_main ruleset.
php_main_keywords_dict = {}

# Keywords dict for php_tags ruleset.
php_tags_keywords_dict = {}

# Keywords dict for php_tags_literal ruleset.
php_tags_literal_keywords_dict = {}

# Keywords dict for php_php ruleset.
php_php_keywords_dict = {
    "__class__": "keyword3",
    "__file__": "keyword3",
    "__function__": "keyword3",
    "__line__": "keyword3",
    "__method__": "keyword3",
    "abs": "keyword2",
    "abstract": "keyword1",
    "accept_connect": "keyword2",
    "acos": "keyword2",
    "add": "keyword2",
    "add_iovec": "keyword2",
    "addaction": "keyword2",
    "addcolor": "keyword2",
    "addcslashes": "keyword2",
    "addentry": "keyword2",
    "addfill": "keyword2",
    "addshape": "keyword2",
    "addslashes": "keyword2",
    "addstring": "keyword2",
    "align": "keyword2",
    "and": "operator",
    "apache_child_terminate": "keyword2",
    "apache_lookup_uri": "keyword2",
    "apache_note": "keyword2",
    "apache_sub_req": "keyword2",
    "array": "keyword1",
    "array_combine": "keyword2",
    "array_count_values": "keyword2",
    "array_diff": "keyword2",
    "array_diff_assoc": "keyword2",
    "array_diff_uassoc": "keyword2",
    "array_filter": "keyword2",
    "array_flip": "keyword2",
    "array_intersect": "keyword2",
    "array_intersect_assoc": "keyword2",
    "array_keys": "keyword2",
    "array_map": "keyword2",
    "array_merge": "keyword2",
    "array_merge_recursive": "keyword2",
    "array_multisort": "keyword2",
    "array_pad": "keyword2",
    "array_pop": "keyword2",
    "array_push": "keyword2",
    "array_rand": "keyword2",
    "array_reduce": "keyword2",
    "array_reverse": "keyword2",
    "array_search": "keyword2",
    "array_shift": "keyword2",
    "array_slice": "keyword2",
    "array_splice": "keyword2",
    "array_sum": "keyword2",
    "array_udiff": "keyword2",
    "array_udiff_assoc": "keyword2",
    "array_udiff_uassoc": "keyword2",
    "array_unique": "keyword2",
    "array_unshift": "keyword2",
    "array_values": "keyword2",
    "array_walk": "keyword2",
    "array_walk_recursive": "keyword2",
    "arsort": "keyword2",
    "as": "keyword1",
    "asin": "keyword2",
    "asort": "keyword2",
    "aspell_check": "keyword2",
    "aspell_check_raw": "keyword2",
    "aspell_new": "keyword2",
    "aspell_suggest": "keyword2",
    "assert": "keyword2",
    "assert_options": "keyword2",
    "atan": "keyword2",
    "atan2": "keyword2",
    "base64_decode": "keyword2",
    "base64_encode": "keyword2",
    "base_convert": "keyword2",
    "basename": "keyword2",
    "bcadd": "keyword2",
    "bccomp": "keyword2",
    "bcdiv": "keyword2",
    "bcmod": "keyword2",
    "bcmul": "keyword2",
    "bcpow": "keyword2",
    "bcscale": "keyword2",
    "bcsqrt": "keyword2",
    "bcsub": "keyword2",
    "bin2hex": "keyword2",
    "bind": "keyword2",
    "bindec": "keyword2",
    "bindtextdomain": "keyword2",
    "break": "keyword1",
    "build_iovec": "keyword2",
    "bzclose": "keyword2",
    "bzcompress": "keyword2",
    "bzdecompress": "keyword2",
    "bzerrno": "keyword2",
    "bzerror": "keyword2",
    "bzerrstr": "keyword2",
    "bzflush": "keyword2",
    "bzopen": "keyword2",
    "bzread": "keyword2",
    "bzwrite": "keyword2",
    "call_user_func": "keyword2",
    "call_user_func_array": "keyword2",
    "call_user_method": "keyword2",
    "call_user_method_array": "keyword2",
    "case": "keyword1",
    "catch": "keyword1",
    "ccvs_add": "keyword2",
    "ccvs_auth": "keyword2",
    "ccvs_command": "keyword2",
    "ccvs_count": "keyword2",
    "ccvs_delete": "keyword2",
    "ccvs_done": "keyword2",
    "ccvs_init": "keyword2",
    "ccvs_lookup": "keyword2",
    "ccvs_new": "keyword2",
    "ccvs_report": "keyword2",
    "ccvs_return": "keyword2",
    "ccvs_reverse": "keyword2",
    "ccvs_sale": "keyword2",
    "ccvs_status": "keyword2",
    "ccvs_textvalue": "keyword2",
    "ccvs_void": "keyword2",
    "ceil": "keyword2",
    "chdir": "keyword2",
    "checkdate": "keyword2",
    "checkdnsrr": "keyword2",
    "chgrp": "keyword2",
    "chmod": "keyword2",
    "chop": "keyword2",
    "chown": "keyword2",
    "chr": "keyword2",
    "chroot": "keyword2",
    "chunk_split": "keyword2",
    "class": "keyword1",
    "class_exists": "keyword2",
    "clearstatcache": "keyword2",
    "clone": "keyword1",
    "close": "keyword2",
    "closedir": "keyword2",
    "closelog": "keyword2",
    "com_get": "keyword2",
    "com_invoke": "keyword2",
    "com_load": "keyword2",
    "com_propget": "keyword2",
    "com_propput": "keyword2",
    "com_propset": "keyword2",
    "com_set": "keyword2",
    "compact": "keyword2",
    "confirm_cybermut_compiled": "keyword2",
    "confirm_extname_compiled": "keyword2",
    "connect": "keyword2",
    "connection_aborted": "keyword2",
    "connection_status": "keyword2",
    "const": "keyword1",
    "constant": "keyword2",
    "continue": "keyword1",
    "convert_cyr_string": "keyword2",
    "convert_uudecode": "keyword2",
    "convert_uuencode": "keyword2",
    "copy": "keyword2",
    "cos": "keyword2",
    "count": "keyword2",
    "count_chars": "keyword2",
    "cpdf_add_annotation": "keyword2",
    "cpdf_add_outline": "keyword2",
    "cpdf_arc": "keyword2",
    "cpdf_begin_text": "keyword2",
    "cpdf_circle": "keyword2",
    "cpdf_clip": "keyword2",
    "cpdf_close": "keyword2",
    "cpdf_closepath": "keyword2",
    "cpdf_closepath_fill_stroke": "keyword2",
    "cpdf_closepath_stroke": "keyword2",
    "cpdf_continue_text": "keyword2",
    "cpdf_curveto": "keyword2",
    "cpdf_end_text": "keyword2",
    "cpdf_fill": "keyword2",
    "cpdf_fill_stroke": "keyword2",
    "cpdf_finalize": "keyword2",
    "cpdf_finalize_page": "keyword2",
    "cpdf_global_set_document_limits": "keyword2",
    "cpdf_import_jpeg": "keyword2",
    "cpdf_lineto": "keyword2",
    "cpdf_moveto": "keyword2",
    "cpdf_newpath": "keyword2",
    "cpdf_open": "keyword2",
    "cpdf_output_buffer": "keyword2",
    "cpdf_page_init": "keyword2",
    "cpdf_place_inline_image": "keyword2",
    "cpdf_rect": "keyword2",
    "cpdf_restore": "keyword2",
    "cpdf_rlineto": "keyword2",
    "cpdf_rmoveto": "keyword2",
    "cpdf_rotate": "keyword2",
    "cpdf_rotate_text": "keyword2",
    "cpdf_save": "keyword2",
    "cpdf_save_to_file": "keyword2",
    "cpdf_scale": "keyword2",
    "cpdf_set_action_url": "keyword2",
    "cpdf_set_char_spacing": "keyword2",
    "cpdf_set_creator": "keyword2",
    "cpdf_set_current_page": "keyword2",
    "cpdf_set_font": "keyword2",
    "cpdf_set_font_directories": "keyword2",
    "cpdf_set_font_map_file": "keyword2",
    "cpdf_set_horiz_scaling": "keyword2",
    "cpdf_set_keywords": "keyword2",
    "cpdf_set_leading": "keyword2",
    "cpdf_set_page_animation": "keyword2",
    "cpdf_set_subject": "keyword2",
    "cpdf_set_text_matrix": "keyword2",
    "cpdf_set_text_pos": "keyword2",
    "cpdf_set_text_rendering": "keyword2",
    "cpdf_set_text_rise": "keyword2",
    "cpdf_set_title": "keyword2",
    "cpdf_set_viewer_preferences": "keyword2",
    "cpdf_set_word_spacing": "keyword2",
    "cpdf_setdash": "keyword2",
    "cpdf_setflat": "keyword2",
    "cpdf_setgray": "keyword2",
    "cpdf_setgray_fill": "keyword2",
    "cpdf_setgray_stroke": "keyword2",
    "cpdf_setlinecap": "keyword2",
    "cpdf_setlinejoin": "keyword2",
    "cpdf_setlinewidth": "keyword2",
    "cpdf_setmiterlimit": "keyword2",
    "cpdf_setrgbcolor": "keyword2",
    "cpdf_setrgbcolor_fill": "keyword2",
    "cpdf_setrgbcolor_stroke": "keyword2",
    "cpdf_show": "keyword2",
    "cpdf_show_xy": "keyword2",
    "cpdf_stringwidth": "keyword2",
    "cpdf_stroke": "keyword2",
    "cpdf_text": "keyword2",
    "cpdf_translate": "keyword2",
    "crack_check": "keyword2",
    "crack_closedict": "keyword2",
    "crack_getlastmessage": "keyword2",
    "crack_opendict": "keyword2",
    "crash": "keyword2",
    "crc32": "keyword2",
    "create_function": "keyword2",
    "crypt": "keyword2",
    "ctype_alnum": "keyword2",
    "ctype_alpha": "keyword2",
    "ctype_cntrl": "keyword2",
    "ctype_digit": "keyword2",
    "ctype_graph": "keyword2",
    "ctype_lower": "keyword2",
    "ctype_print": "keyword2",
    "ctype_punct": "keyword2",
    "ctype_space": "keyword2",
    "ctype_upper": "keyword2",
    "ctype_xdigit": "keyword2",
    "curl_close": "keyword2",
    "curl_errno": "keyword2",
    "curl_error": "keyword2",
    "curl_exec": "keyword2",
    "curl_getinfo": "keyword2",
    "curl_init": "keyword2",
    "curl_setopt": "keyword2",
    "curl_version": "keyword2",
    "current": "keyword2",
    "cv_add": "keyword2",
    "cv_auth": "keyword2",
    "cv_command": "keyword2",
    "cv_count": "keyword2",
    "cv_delete": "keyword2",
    "cv_done": "keyword2",
    "cv_init": "keyword2",
    "cv_lookup": "keyword2",
    "cv_new": "keyword2",
    "cv_report": "keyword2",
    "cv_return": "keyword2",
    "cv_reverse": "keyword2",
    "cv_sale": "keyword2",
    "cv_status": "keyword2",
    "cv_textvalue": "keyword2",
    "cv_void": "keyword2",
    "cybercash_base64_decode": "keyword2",
    "cybercash_base64_encode": "keyword2",
    "cybercash_decr": "keyword2",
    "cybercash_encr": "keyword2",
    "cybermut_creerformulairecm": "keyword2",
    "cybermut_creerreponsecm": "keyword2",
    "cybermut_testmac": "keyword2",
    "date": "keyword2",
    "dba_close": "keyword2",
    "dba_delete": "keyword2",
    "dba_exists": "keyword2",
    "dba_fetch": "keyword2",
    "dba_firstkey": "keyword2",
    "dba_insert": "keyword2",
    "dba_nextkey": "keyword2",
    "dba_open": "keyword2",
    "dba_optimize": "keyword2",
    "dba_popen": "keyword2",
    "dba_replace": "keyword2",
    "dba_sync": "keyword2",
    "dbase_add_record": "keyword2",
    "dbase_close": "keyword2",
    "dbase_create": "keyword2",
    "dbase_delete_record": "keyword2",
    "dbase_get_record": "keyword2",
    "dbase_get_record_with_names": "keyword2",
    "dbase_numfields": "keyword2",
    "dbase_numrecords": "keyword2",
    "dbase_open": "keyword2",
    "dbase_pack": "keyword2",
    "dbase_replace_record": "keyword2",
    "dblist": "keyword2",
    "dbmclose": "keyword2",
    "dbmdelete": "keyword2",
    "dbmexists": "keyword2",
    "dbmfetch": "keyword2",
    "dbmfirstkey": "keyword2",
    "dbminsert": "keyword2",
    "dbmnextkey": "keyword2",
    "dbmopen": "keyword2",
    "dbmreplace": "keyword2",
    "dbx_close": "keyword2",
    "dbx_cmp_asc": "keyword2",
    "dbx_cmp_desc": "keyword2",
    "dbx_connect": "keyword2",
    "dbx_error": "keyword2",
    "dbx_query": "keyword2",
    "dbx_sort": "keyword2",
    "dcgettext": "keyword2",
    "debug_backtrace": "keyword2",
    "debug_print_backtrace": "keyword2",
    "decbin": "keyword2",
    "dechex": "keyword2",
    "declare": "keyword1",
    "decoct": "keyword2",
    "default": "keyword1",
    "define": "keyword2",
    "define_syslog_variables": "keyword2",
    "defined": "keyword2",
    "deg2rad": "keyword2",
    "delete_iovec": "keyword2",
    "dgettext": "keyword2",
    "die": "keyword2",
    "dir": "keyword2",
    "dirname": "keyword2",
    "diskfreespace": "keyword2",
    "display_disabled_function": "keyword2",
    "dl": "keyword2",
    "do": "keyword1",
    "domxml_add_root": "keyword2",
    "domxml_attributes": "keyword2",
    "domxml_children": "keyword2",
    "domxml_dumpmem": "keyword2",
    "domxml_elem_get_attribute": "keyword2",
    "domxml_elem_set_attribute": "keyword2",
    "domxml_get_attribute": "keyword2",
    "domxml_getattr": "keyword2",
    "domxml_new_child": "keyword2",
    "domxml_new_xmldoc": "keyword2",
    "domxml_node": "keyword2",
    "domxml_node_attributes": "keyword2",
    "domxml_node_children": "keyword2",
    "domxml_node_new_child": "keyword2",
    "domxml_node_set_content": "keyword2",
    "domxml_node_unlink_node": "keyword2",
    "domxml_root": "keyword2",
    "domxml_set_attribute": "keyword2",
    "domxml_setattr": "keyword2",
    "domxml_unlink_node": "keyword2",
    "domxml_version": "keyword2",
    "doubleval": "keyword2",
    "drawarc": "keyword2",
    "drawcircle": "keyword2",
    "drawcubic": "keyword2",
    "drawcubicto": "keyword2",
    "drawcurve": "keyword2",
    "drawcurveto": "keyword2",
    "drawglyph": "keyword2",
    "drawline": "keyword2",
    "drawlineto": "keyword2",
    "each": "keyword2",
    "easter_date": "keyword2",
    "easter_days": "keyword2",
    "echo": "keyword1",
    "else": "keyword1",
    "elseif": "keyword1",
    "empty": "keyword1",
    "end": "keyword2",
    "endfor": "keyword1",
    "endforeach": "keyword1",
    "endif": "keyword1",
    "endswitch": "keyword1",
    "endwhile": "keyword1",
    "ereg": "keyword2",
    "ereg_replace": "keyword2",
    "eregi": "keyword2",
    "eregi_replace": "keyword2",
    "error_log": "keyword2",
    "error_reporting": "keyword2",
    "escapeshellarg": "keyword2",
    "escapeshellcmd": "keyword2",
    "exec": "keyword2",
    "exit": "keyword2",
    "exp": "keyword2",
    "explode": "keyword2",
    "extends": "keyword1",
    "extension_loaded": "keyword2",
    "extract": "keyword2",
    "ezmlm_hash": "keyword2",
    "false": "keyword3",
    "fbsql": "keyword2",
    "fbsql_affected_rows": "keyword2",
    "fbsql_autocommit": "keyword2",
    "fbsql_close": "keyword2",
    "fbsql_commit": "keyword2",
    "fbsql_connect": "keyword2",
    "fbsql_create_db": "keyword2",
    "fbsql_data_seek": "keyword2",
    "fbsql_database": "keyword2",
    "fbsql_database_password": "keyword2",
    "fbsql_db_query": "keyword2",
    "fbsql_drop_db": "keyword2",
    "fbsql_errno": "keyword2",
    "fbsql_error": "keyword2",
    "fbsql_fetch_array": "keyword2",
    "fbsql_fetch_assoc": "keyword2",
    "fbsql_fetch_field": "keyword2",
    "fbsql_fetch_lengths": "keyword2",
    "fbsql_fetch_object": "keyword2",
    "fbsql_fetch_row": "keyword2",
    "fbsql_field_flags": "keyword2",
    "fbsql_field_len": "keyword2",
    "fbsql_field_name": "keyword2",
    "fbsql_field_seek": "keyword2",
    "fbsql_field_table": "keyword2",
    "fbsql_field_type": "keyword2",
    "fbsql_free_result": "keyword2",
    "fbsql_hostname": "keyword2",
    "fbsql_insert_id": "keyword2",
    "fbsql_list_dbs": "keyword2",
    "fbsql_list_fields": "keyword2",
    "fbsql_list_tables": "keyword2",
    "fbsql_next_result": "keyword2",
    "fbsql_num_fields": "keyword2",
    "fbsql_num_rows": "keyword2",
    "fbsql_password": "keyword2",
    "fbsql_pconnect": "keyword2",
    "fbsql_query": "keyword2",
    "fbsql_result": "keyword2",
    "fbsql_rollback": "keyword2",
    "fbsql_select_db": "keyword2",
    "fbsql_start_db": "keyword2",
    "fbsql_stop_db": "keyword2",
    "fbsql_username": "keyword2",
    "fbsql_warnings": "keyword2",
    "fclose": "keyword2",
    "fd_alloc": "keyword2",
    "fd_clear": "keyword2",
    "fd_dealloc": "keyword2",
    "fd_isset": "keyword2",
    "fd_set": "keyword2",
    "fd_zero": "keyword2",
    "fdf_add_template": "keyword2",
    "fdf_close": "keyword2",
    "fdf_create": "keyword2",
    "fdf_get_file": "keyword2",
    "fdf_get_status": "keyword2",
    "fdf_get_value": "keyword2",
    "fdf_next_field_name": "keyword2",
    "fdf_open": "keyword2",
    "fdf_save": "keyword2",
    "fdf_set_ap": "keyword2",
    "fdf_set_file": "keyword2",
    "fdf_set_flags": "keyword2",
    "fdf_set_javascript_action": "keyword2",
    "fdf_set_opt": "keyword2",
    "fdf_set_status": "keyword2",
    "fdf_set_submit_form_action": "keyword2",
    "fdf_set_value": "keyword2",
    "feof": "keyword2",
    "fetch_iovec": "keyword2",
    "fflush": "keyword2",
    "fgetc": "keyword2",
    "fgetcsv": "keyword2",
    "fgets": "keyword2",
    "fgetss": "keyword2",
    "file": "keyword2",
    "file_exists": "keyword2",
    "file_get_contents": "keyword2",
    "file_put_contents": "keyword2",
    "fileatime": "keyword2",
    "filectime": "keyword2",
    "filegroup": "keyword2",
    "fileinode": "keyword2",
    "filemtime": "keyword2",
    "fileowner": "keyword2",
    "fileperms": "keyword2",
    "filepro": "keyword2",
    "filepro_fieldcount": "keyword2",
    "filepro_fieldname": "keyword2",
    "filepro_fieldtype": "keyword2",
    "filepro_fieldwidth": "keyword2",
    "filepro_retrieve": "keyword2",
    "filepro_rowcount": "keyword2",
    "filesize": "keyword2",
    "filetype": "keyword2",
    "final": "keyword1",
    "floatval": "keyword2",
    "flock": "keyword2",
    "floor": "keyword2",
    "flush": "keyword2",
    "fopen": "keyword2",
    "fopenstream": "keyword2",
    "for": "keyword1",
    "foreach": "keyword1",
    "fpassthru": "keyword2",
    "fputs": "keyword2",
    "fread": "keyword2",
    "free_iovec": "keyword2",
    "frenchtojd": "keyword2",
    "fribidi_log2vis": "keyword2",
    "fscanf": "keyword2",
    "fseek": "keyword2",
    "fsockopen": "keyword2",
    "fstat": "keyword2",
    "ftell": "keyword2",
    "ftp_alloc": "keyword2",
    "ftp_cdup": "keyword2",
    "ftp_chdir": "keyword2",
    "ftp_connect": "keyword2",
    "ftp_delete": "keyword2",
    "ftp_exec": "keyword2",
    "ftp_fget": "keyword2",
    "ftp_fput": "keyword2",
    "ftp_get": "keyword2",
    "ftp_login": "keyword2",
    "ftp_mdtm": "keyword2",
    "ftp_mkdir": "keyword2",
    "ftp_nlist": "keyword2",
    "ftp_pasv": "keyword2",
    "ftp_put": "keyword2",
    "ftp_pwd": "keyword2",
    "ftp_quit": "keyword2",
    "ftp_rawlist": "keyword2",
    "ftp_rename": "keyword2",
    "ftp_rmdir": "keyword2",
    "ftp_site": "keyword2",
    "ftp_size": "keyword2",
    "ftp_ssl_connect": "keyword2",
    "ftp_systype": "keyword2",
    "ftruncate": "keyword2",
    "func_get_arg": "keyword2",
    "func_get_args": "keyword2",
    "func_num_args": "keyword2",
    "function": "keyword1",
    "function_exists": "keyword2",
    "fwrite": "keyword2",
    "gd_info": "keyword2",
    "get_all_headers": "keyword2",
    "get_browser": "keyword2",
    "get_cfg_var": "keyword2",
    "get_class": "keyword2",
    "get_class_methods": "keyword2",
    "get_class_vars": "keyword2",
    "get_current_user": "keyword2",
    "get_declared_classes": "keyword2",
    "get_declared_interfaces": "keyword2",
    "get_defined_functions": "keyword2",
    "get_defined_vars": "keyword2",
    "get_extension_funcs": "keyword2",
    "get_headers": "keyword2",
    "get_html_translation_table": "keyword2",
    "get_included_files": "keyword2",
    "get_loaded_extensions": "keyword2",
    "get_magic_quotes_gpc": "keyword2",
    "get_magic_quotes_runtime": "keyword2",
    "get_meta_tags": "keyword2",
    "get_object_vars": "keyword2",
    "get_parent_class": "keyword2",
    "get_required_files": "keyword2",
    "get_resource_type": "keyword2",
    "getallheaders": "keyword2",
    "getascent": "keyword2",
    "getcwd": "keyword2",
    "getdate": "keyword2",
    "getdescent": "keyword2",
    "getenv": "keyword2",
    "getheight": "keyword2",
    "gethostbyaddr": "keyword2",
    "gethostbyname": "keyword2",
    "gethostbynamel": "keyword2",
    "getimagesize": "keyword2",
    "getlastmod": "keyword2",
    "getleading": "keyword2",
    "getmxrr": "keyword2",
    "getmyinode": "keyword2",
    "getmypid": "keyword2",
    "getmyuid": "keyword2",
    "getopt": "keyword2",
    "getpeername": "keyword2",
    "getprotobyname": "keyword2",
    "getprotobynumber": "keyword2",
    "getrandmax": "keyword2",
    "getrusage": "keyword2",
    "getservbyname": "keyword2",
    "getservbyport": "keyword2",
    "getshape1": "keyword2",
    "getshape2": "keyword2",
    "getsockname": "keyword2",
    "getsockopt": "keyword2",
    "gettext": "keyword2",
    "gettimeofday": "keyword2",
    "gettype": "keyword2",
    "getwidth": "keyword2",
    "global": "keyword1",
    "gmdate": "keyword2",
    "gmmktime": "keyword2",
    "gmp_abs": "keyword2",
    "gmp_add": "keyword2",
    "gmp_and": "keyword2",
    "gmp_clrbit": "keyword2",
    "gmp_cmp": "keyword2",
    "gmp_com": "keyword2",
    "gmp_div": "keyword2",
    "gmp_div_q": "keyword2",
    "gmp_div_qr": "keyword2",
    "gmp_div_r": "keyword2",
    "gmp_divexact": "keyword2",
    "gmp_fact": "keyword2",
    "gmp_gcd": "keyword2",
    "gmp_gcdext": "keyword2",
    "gmp_hamdist": "keyword2",
    "gmp_init": "keyword2",
    "gmp_intval": "keyword2",
    "gmp_invert": "keyword2",
    "gmp_jacobi": "keyword2",
    "gmp_legendre": "keyword2",
    "gmp_mod": "keyword2",
    "gmp_mul": "keyword2",
    "gmp_neg": "keyword2",
    "gmp_or": "keyword2",
    "gmp_perfect_square": "keyword2",
    "gmp_popcount": "keyword2",
    "gmp_pow": "keyword2",
    "gmp_powm": "keyword2",
    "gmp_prob_prime": "keyword2",
    "gmp_random": "keyword2",
    "gmp_scan0": "keyword2",
    "gmp_scan1": "keyword2",
    "gmp_setbit": "keyword2",
    "gmp_sign": "keyword2",
    "gmp_sqrt": "keyword2",
    "gmp_sqrtrem": "keyword2",
    "gmp_strval": "keyword2",
    "gmp_sub": "keyword2",
    "gmp_xor": "keyword2",
    "gmstrftime": "keyword2",
    "gregoriantojd": "keyword2",
    "gzclose": "keyword2",
    "gzcompress": "keyword2",
    "gzdeflate": "keyword2",
    "gzencode": "keyword2",
    "gzeof": "keyword2",
    "gzfile": "keyword2",
    "gzgetc": "keyword2",
    "gzgets": "keyword2",
    "gzgetss": "keyword2",
    "gzinflate": "keyword2",
    "gzopen": "keyword2",
    "gzpassthru": "keyword2",
    "gzputs": "keyword2",
    "gzread": "keyword2",
    "gzrewind": "keyword2",
    "gzseek": "keyword2",
    "gztell": "keyword2",
    "gzuncompress": "keyword2",
    "gzwrite": "keyword2",
    "header": "keyword2",
    "headers_list": "keyword2",
    "headers_sent": "keyword2",
    "hebrev": "keyword2",
    "hebrevc": "keyword2",
    "hexdec": "keyword2",
    "highlight_file": "keyword2",
    "highlight_string": "keyword2",
    "htmlentities": "keyword2",
    "htmlspecialchars": "keyword2",
    "http_build_query": "keyword2",
    "hw_array2objrec": "keyword2",
    "hw_changeobject": "keyword2",
    "hw_children": "keyword2",
    "hw_childrenobj": "keyword2",
    "hw_close": "keyword2",
    "hw_connect": "keyword2",
    "hw_connection_info": "keyword2",
    "hw_cp": "keyword2",
    "hw_deleteobject": "keyword2",
    "hw_docbyanchor": "keyword2",
    "hw_docbyanchorobj": "keyword2",
    "hw_document_attributes": "keyword2",
    "hw_document_bodytag": "keyword2",
    "hw_document_content": "keyword2",
    "hw_document_setcontent": "keyword2",
    "hw_document_size": "keyword2",
    "hw_dummy": "keyword2",
    "hw_edittext": "keyword2",
    "hw_error": "keyword2",
    "hw_errormsg": "keyword2",
    "hw_free_document": "keyword2",
    "hw_getanchors": "keyword2",
    "hw_getanchorsobj": "keyword2",
    "hw_getandlock": "keyword2",
    "hw_getcgi": "keyword2",
    "hw_getchildcoll": "keyword2",
    "hw_getchildcollobj": "keyword2",
    "hw_getchilddoccoll": "keyword2",
    "hw_getchilddoccollobj": "keyword2",
    "hw_getobject": "keyword2",
    "hw_getobjectbyftquery": "keyword2",
    "hw_getobjectbyftquerycoll": "keyword2",
    "hw_getobjectbyftquerycollobj": "keyword2",
    "hw_getobjectbyftqueryobj": "keyword2",
    "hw_getobjectbyquery": "keyword2",
    "hw_getobjectbyquerycoll": "keyword2",
    "hw_getobjectbyquerycollobj": "keyword2",
    "hw_getobjectbyqueryobj": "keyword2",
    "hw_getparents": "keyword2",
    "hw_getparentsobj": "keyword2",
    "hw_getrellink": "keyword2",
    "hw_getremote": "keyword2",
    "hw_getremotechildren": "keyword2",
    "hw_getsrcbydestobj": "keyword2",
    "hw_gettext": "keyword2",
    "hw_getusername": "keyword2",
    "hw_identify": "keyword2",
    "hw_incollections": "keyword2",
    "hw_info": "keyword2",
    "hw_inscoll": "keyword2",
    "hw_insdoc": "keyword2",
    "hw_insertanchors": "keyword2",
    "hw_insertdocument": "keyword2",
    "hw_insertobject": "keyword2",
    "hw_mapid": "keyword2",
    "hw_modifyobject": "keyword2",
    "hw_mv": "keyword2",
    "hw_new_document": "keyword2",
    "hw_new_document_from_file": "keyword2",
    "hw_objrec2array": "keyword2",
    "hw_output_document": "keyword2",
    "hw_pconnect": "keyword2",
    "hw_pipecgi": "keyword2",
    "hw_pipedocument": "keyword2",
    "hw_root": "keyword2",
    "hw_setlinkroot": "keyword2",
    "hw_stat": "keyword2",
    "hw_unlock": "keyword2",
    "hw_who": "keyword2",
    "ibase_blob_add": "keyword2",
    "ibase_blob_cancel": "keyword2",
    "ibase_blob_close": "keyword2",
    "ibase_blob_create": "keyword2",
    "ibase_blob_echo": "keyword2",
    "ibase_blob_get": "keyword2",
    "ibase_blob_import": "keyword2",
    "ibase_blob_info": "keyword2",
    "ibase_blob_open": "keyword2",
    "ibase_close": "keyword2",
    "ibase_commit": "keyword2",
    "ibase_connect": "keyword2",
    "ibase_errmsg": "keyword2",
    "ibase_execute": "keyword2",
    "ibase_fetch_object": "keyword2",
    "ibase_fetch_row": "keyword2",
    "ibase_field_info": "keyword2",
    "ibase_free_query": "keyword2",
    "ibase_free_result": "keyword2",
    "ibase_num_fields": "keyword2",
    "ibase_pconnect": "keyword2",
    "ibase_prepare": "keyword2",
    "ibase_query": "keyword2",
    "ibase_rollback": "keyword2",
    "ibase_timefmt": "keyword2",
    "ibase_trans": "keyword2",
    "icap_create_calendar": "keyword2",
    "icap_delete_calendar": "keyword2",
    "icap_delete_event": "keyword2",
    "icap_fetch_event": "keyword2",
    "icap_list_alarms": "keyword2",
    "icap_list_events": "keyword2",
    "icap_open": "keyword2",
    "icap_popen": "keyword2",
    "icap_rename_calendar": "keyword2",
    "icap_reopen": "keyword2",
    "icap_snooze": "keyword2",
    "icap_store_event": "keyword2",
    "iconv": "keyword2",
    "iconv_get_encoding": "keyword2",
    "iconv_set_encoding": "keyword2",
    "idate": "keyword2",
    "if": "keyword1",
    "ifx_affected_rows": "keyword2",
    "ifx_blobinfile_mode": "keyword2",
    "ifx_byteasvarchar": "keyword2",
    "ifx_close": "keyword2",
    "ifx_connect": "keyword2",
    "ifx_copy_blob": "keyword2",
    "ifx_create_blob": "keyword2",
    "ifx_create_char": "keyword2",
    "ifx_do": "keyword2",
    "ifx_error": "keyword2",
    "ifx_errormsg": "keyword2",
    "ifx_fetch_row": "keyword2",
    "ifx_fieldproperties": "keyword2",
    "ifx_fieldtypes": "keyword2",
    "ifx_free_blob": "keyword2",
    "ifx_free_char": "keyword2",
    "ifx_free_result": "keyword2",
    "ifx_get_blob": "keyword2",
    "ifx_get_char": "keyword2",
    "ifx_getsqlca": "keyword2",
    "ifx_htmltbl_result": "keyword2",
    "ifx_nullformat": "keyword2",
    "ifx_num_fields": "keyword2",
    "ifx_num_rows": "keyword2",
    "ifx_pconnect": "keyword2",
    "ifx_prepare": "keyword2",
    "ifx_query": "keyword2",
    "ifx_textasvarchar": "keyword2",
    "ifx_update_blob": "keyword2",
    "ifx_update_char": "keyword2",
    "ifxus_close_slob": "keyword2",
    "ifxus_create_slob": "keyword2",
    "ifxus_free_slob": "keyword2",
    "ifxus_open_slob": "keyword2",
    "ifxus_read_slob": "keyword2",
    "ifxus_seek_slob": "keyword2",
    "ifxus_tell_slob": "keyword2",
    "ifxus_write_slob": "keyword2",
    "ignore_user_abort": "keyword2",
    "iis_addserver": "keyword2",
    "iis_getdirsecurity": "keyword2",
    "iis_getscriptmap": "keyword2",
    "iis_getserverbycomment": "keyword2",
    "iis_getserverbypath": "keyword2",
    "iis_getserverright": "keyword2",
    "iis_getservicestate": "keyword2",
    "iis_removeserver": "keyword2",
    "iis_setappsettings": "keyword2",
    "iis_setdirsecurity": "keyword2",
    "iis_setscriptmap": "keyword2",
    "iis_setserverright": "keyword2",
    "iis_startserver": "keyword2",
    "iis_startservice": "keyword2",
    "iis_stopserver": "keyword2",
    "iis_stopservice": "keyword2",
    "image2wbmp": "keyword2",
    "image_type_to_extension": "keyword2",
    "imagealphablending": "keyword2",
    "imagearc": "keyword2",
    "imagechar": "keyword2",
    "imagecharup": "keyword2",
    "imagecolorallocate": "keyword2",
    "imagecolorat": "keyword2",
    "imagecolorclosest": "keyword2",
    "imagecolorclosestalpha": "keyword2",
    "imagecolorclosesthwb": "keyword2",
    "imagecolordeallocate": "keyword2",
    "imagecolorexact": "keyword2",
    "imagecolorexactalpha": "keyword2",
    "imagecolormatch": "keyword2",
    "imagecolorresolve": "keyword2",
    "imagecolorresolvealpha": "keyword2",
    "imagecolorset": "keyword2",
    "imagecolorsforindex": "keyword2",
    "imagecolorstotal": "keyword2",
    "imagecolortransparent": "keyword2",
    "imagecopy": "keyword2",
    "imagecopymerge": "keyword2",
    "imagecopymergegray": "keyword2",
    "imagecopyresampled": "keyword2",
    "imagecopyresized": "keyword2",
    "imagecreate": "keyword2",
    "imagecreatefromgif": "keyword2",
    "imagecreatefromjpeg": "keyword2",
    "imagecreatefrompng": "keyword2",
    "imagecreatefromstring": "keyword2",
    "imagecreatefromwbmp": "keyword2",
    "imagecreatefromxbm": "keyword2",
    "imagecreatefromxpm": "keyword2",
    "imagecreatetruecolor": "keyword2",
    "imagedashedline": "keyword2",
    "imagedestroy": "keyword2",
    "imageellipse": "keyword2",
    "imagefill": "keyword2",
    "imagefilledarc": "keyword2",
    "imagefilledellipse": "keyword2",
    "imagefilledpolygon": "keyword2",
    "imagefilledrectangle": "keyword2",
    "imagefilltoborder": "keyword2",
    "imagefilter": "keyword2",
    "imagefontheight": "keyword2",
    "imagefontwidth": "keyword2",
    "imagegammacorrect": "keyword2",
    "imagegif": "keyword2",
    "imageinterlace": "keyword2",
    "imagejpeg": "keyword2",
    "imagelayereffect": "keyword2",
    "imageline": "keyword2",
    "imageloadfont": "keyword2",
    "imagepalettecopy": "keyword2",
    "imagepng": "keyword2",
    "imagepolygon": "keyword2",
    "imagepsbbox": "keyword2",
    "imagepscopyfont": "keyword2",
    "imagepsencodefont": "keyword2",
    "imagepsextendfont": "keyword2",
    "imagepsfreefont": "keyword2",
    "imagepsloadfont": "keyword2",
    "imagepsslantfont": "keyword2",
    "imagepstext": "keyword2",
    "imagerectangle": "keyword2",
    "imagerotate": "keyword2",
    "imagesetbrush": "keyword2",
    "imagesetpixel": "keyword2",
    "imagesetstyle": "keyword2",
    "imagesetthickness": "keyword2",
    "imagesettile": "keyword2",
    "imagestring": "keyword2",
    "imagestringup": "keyword2",
    "imagesx": "keyword2",
    "imagesy": "keyword2",
    "imagetruecolortopalette": "keyword2",
    "imagettfbbox": "keyword2",
    "imagettftext": "keyword2",
    "imagetypes": "keyword2",
    "imagewbmp": "keyword2",
    "imap_8bit": "keyword2",
    "imap_alerts": "keyword2",
    "imap_append": "keyword2",
    "imap_base64": "keyword2",
    "imap_binary": "keyword2",
    "imap_body": "keyword2",
    "imap_bodystruct": "keyword2",
    "imap_check": "keyword2",
    "imap_clearflag_full": "keyword2",
    "imap_close": "keyword2",
    "imap_create": "keyword2",
    "imap_createmailbox": "keyword2",
    "imap_delete": "keyword2",
    "imap_deletemailbox": "keyword2",
    "imap_errors": "keyword2",
    "imap_expunge": "keyword2",
    "imap_fetch_overview": "keyword2",
    "imap_fetchbody": "keyword2",
    "imap_fetchheader": "keyword2",
    "imap_fetchstructure": "keyword2",
    "imap_fetchtext": "keyword2",
    "imap_get_quota": "keyword2",
    "imap_getmailboxes": "keyword2",
    "imap_getsubscribed": "keyword2",
    "imap_header": "keyword2",
    "imap_headerinfo": "keyword2",
    "imap_headers": "keyword2",
    "imap_last_error": "keyword2",
    "imap_list": "keyword2",
    "imap_listmailbox": "keyword2",
    "imap_listsubscribed": "keyword2",
    "imap_lsub": "keyword2",
    "imap_mail": "keyword2",
    "imap_mail_compose": "keyword2",
    "imap_mail_copy": "keyword2",
    "imap_mail_move": "keyword2",
    "imap_mailboxmsginfo": "keyword2",
    "imap_mime_header_decode": "keyword2",
    "imap_msgno": "keyword2",
    "imap_num_msg": "keyword2",
    "imap_num_recent": "keyword2",
    "imap_open": "keyword2",
    "imap_ping": "keyword2",
    "imap_popen": "keyword2",
    "imap_qprint": "keyword2",
    "imap_rename": "keyword2",
    "imap_renamemailbox": "keyword2",
    "imap_reopen": "keyword2",
    "imap_rfc822_parse_adrlist": "keyword2",
    "imap_rfc822_parse_headers": "keyword2",
    "imap_rfc822_write_address": "keyword2",
    "imap_scan": "keyword2",
    "imap_scanmailbox": "keyword2",
    "imap_search": "keyword2",
    "imap_set_quota": "keyword2",
    "imap_setflag_full": "keyword2",
    "imap_sort": "keyword2",
    "imap_status": "keyword2",
    "imap_subscribe": "keyword2",
    "imap_uid": "keyword2",
    "imap_undelete": "keyword2",
    "imap_unsubscribe": "keyword2",
    "imap_utf7_decode": "keyword2",
    "imap_utf7_encode": "keyword2",
    "imap_utf8": "keyword2",
    "implements": "keyword1",
    "implode": "keyword2",
    "in_array": "keyword2",
    "include": "keyword1",
    "include_once": "keyword1",
    "ingres_autocommit": "keyword2",
    "ingres_close": "keyword2",
    "ingres_commit": "keyword2",
    "ingres_connect": "keyword2",
    "ingres_fetch_array": "keyword2",
    "ingres_fetch_object": "keyword2",
    "ingres_fetch_row": "keyword2",
    "ingres_field_length": "keyword2",
    "ingres_field_name": "keyword2",
    "ingres_field_nullable": "keyword2",
    "ingres_field_precision": "keyword2",
    "ingres_field_scale": "keyword2",
    "ingres_field_type": "keyword2",
    "ingres_num_fields": "keyword2",
    "ingres_num_rows": "keyword2",
    "ingres_pconnect": "keyword2",
    "ingres_query": "keyword2",
    "ingres_rollback": "keyword2",
    "ini_alter": "keyword2",
    "ini_get": "keyword2",
    "ini_restore": "keyword2",
    "ini_set": "keyword2",
    "instanceof": "operator",
    "interface": "keyword1",
    "intval": "keyword2",
    "ip2long": "keyword2",
    "iptcembed": "keyword2",
    "iptcparse": "keyword2",
    "ircg_channel_mode": "keyword2",
    "ircg_disconnect": "keyword2",
    "ircg_html_encode": "keyword2",
    "ircg_ignore_add": "keyword2",
    "ircg_ignore_del": "keyword2",
    "ircg_is_conn_alive": "keyword2",
    "ircg_join": "keyword2",
    "ircg_kick": "keyword2",
    "ircg_lookup_format_messages": "keyword2",
    "ircg_msg": "keyword2",
    "ircg_nick": "keyword2",
    "ircg_nickname_escape": "keyword2",
    "ircg_nickname_unescape": "keyword2",
    "ircg_notice": "keyword2",
    "ircg_part": "keyword2",
    "ircg_pconnect": "keyword2",
    "ircg_register_format_messages": "keyword2",
    "ircg_set_current": "keyword2",
    "ircg_topic": "keyword2",
    "ircg_whois": "keyword2",
    "is_array": "keyword2",
    "is_bool": "keyword2",
    "is_dir": "keyword2",
    "is_double": "keyword2",
    "is_executable": "keyword2",
    "is_file": "keyword2",
    "is_float": "keyword2",
    "is_int": "keyword2",
    "is_integer": "keyword2",
    "is_link": "keyword2",
    "is_long": "keyword2",
    "is_null": "keyword2",
    "is_numeric": "keyword2",
    "is_object": "keyword2",
    "is_readable": "keyword2",
    "is_real": "keyword2",
    "is_resource": "keyword2",
    "is_scalar": "keyword2",
    "is_string": "keyword2",
    "is_subclass_of": "keyword2",
    "is_uploaded_file": "keyword2",
    "is_writable": "keyword2",
    "is_writeable": "keyword2",
    "isset": "keyword1",
    "java_last_exception_clear": "keyword2",
    "java_last_exception_get": "keyword2",
    "jddayofweek": "keyword2",
    "jdmonthname": "keyword2",
    "jdtofrench": "keyword2",
    "jdtogregorian": "keyword2",
    "jdtojewish": "keyword2",
    "jdtojulian": "keyword2",
    "jdtounix": "keyword2",
    "jewishtojd": "keyword2",
    "join": "keyword2",
    "jpeg2wbmp": "keyword2",
    "juliantojd": "keyword2",
    "key": "keyword2",
    "krsort": "keyword2",
    "ksort": "keyword2",
    "labelframe": "keyword2",
    "lcg_value": "keyword2",
    "ldap_8859_to_t61": "keyword2",
    "ldap_add": "keyword2",
    "ldap_bind": "keyword2",
    "ldap_close": "keyword2",
    "ldap_compare": "keyword2",
    "ldap_connect": "keyword2",
    "ldap_count_entries": "keyword2",
    "ldap_delete": "keyword2",
    "ldap_dn2ufn": "keyword2",
    "ldap_err2str": "keyword2",
    "ldap_errno": "keyword2",
    "ldap_error": "keyword2",
    "ldap_explode_dn": "keyword2",
    "ldap_first_attribute": "keyword2",
    "ldap_first_entry": "keyword2",
    "ldap_first_reference": "keyword2",
    "ldap_free_result": "keyword2",
    "ldap_get_attributes": "keyword2",
    "ldap_get_dn": "keyword2",
    "ldap_get_entries": "keyword2",
    "ldap_get_option": "keyword2",
    "ldap_get_values": "keyword2",
    "ldap_get_values_len": "keyword2",
    "ldap_list": "keyword2",
    "ldap_mod_add": "keyword2",
    "ldap_mod_del": "keyword2",
    "ldap_mod_replace": "keyword2",
    "ldap_modify": "keyword2",
    "ldap_next_attribute": "keyword2",
    "ldap_next_entry": "keyword2",
    "ldap_next_reference": "keyword2",
    "ldap_parse_reference": "keyword2",
    "ldap_parse_result": "keyword2",
    "ldap_read": "keyword2",
    "ldap_rename": "keyword2",
    "ldap_search": "keyword2",
    "ldap_set_option": "keyword2",
    "ldap_t61_to_8859": "keyword2",
    "ldap_unbind": "keyword2",
    "leak": "keyword2",
    "levenshtein": "keyword2",
    "link": "keyword2",
    "linkinfo": "keyword2",
    "list": "keyword1",
    "listen": "keyword2",
    "localeconv": "keyword2",
    "localtime": "keyword2",
    "log": "keyword2",
    "log10": "keyword2",
    "long2ip": "keyword2",
    "lstat": "keyword2",
    "ltrim": "keyword2",
    "magic_quotes_runtime": "keyword2",
    "mail": "keyword2",
    "max": "keyword2",
    "mb_convert_case": "keyword2",
    "mb_strtolower": "keyword2",
    "mb_strtoupper": "keyword2",
    "mcal_append_event": "keyword2",
    "mcal_close": "keyword2",
    "mcal_create_calendar": "keyword2",
    "mcal_date_compare": "keyword2",
    "mcal_date_valid": "keyword2",
    "mcal_day_of_week": "keyword2",
    "mcal_day_of_year": "keyword2",
    "mcal_days_in_month": "keyword2",
    "mcal_delete_calendar": "keyword2",
    "mcal_delete_event": "keyword2",
    "mcal_event_add_attribute": "keyword2",
    "mcal_event_init": "keyword2",
    "mcal_event_set_alarm": "keyword2",
    "mcal_event_set_category": "keyword2",
    "mcal_event_set_class": "keyword2",
    "mcal_event_set_description": "keyword2",
    "mcal_event_set_end": "keyword2",
    "mcal_event_set_recur_daily": "keyword2",
    "mcal_event_set_recur_monthly_mday": "keyword2",
    "mcal_event_set_recur_monthly_wday": "keyword2",
    "mcal_event_set_recur_none": "keyword2",
    "mcal_event_set_recur_weekly": "keyword2",
    "mcal_event_set_recur_yearly": "keyword2",
    "mcal_event_set_start": "keyword2",
    "mcal_event_set_title": "keyword2",
    "mcal_fetch_current_stream_event": "keyword2",
    "mcal_fetch_event": "keyword2",
    "mcal_is_leap_year": "keyword2",
    "mcal_list_alarms": "keyword2",
    "mcal_list_events": "keyword2",
    "mcal_next_recurrence": "keyword2",
    "mcal_open": "keyword2",
    "mcal_popen": "keyword2",
    "mcal_rename_calendar": "keyword2",
    "mcal_reopen": "keyword2",
    "mcal_snooze": "keyword2",
    "mcal_store_event": "keyword2",
    "mcal_time_valid": "keyword2",
    "mcal_week_of_year": "keyword2",
    "mcrypt_cbc": "keyword2",
    "mcrypt_cfb": "keyword2",
    "mcrypt_create_iv": "keyword2",
    "mcrypt_decrypt": "keyword2",
    "mcrypt_ecb": "keyword2",
    "mcrypt_enc_get_algorithms_name": "keyword2",
    "mcrypt_enc_get_block_size": "keyword2",
    "mcrypt_enc_get_iv_size": "keyword2",
    "mcrypt_enc_get_key_size": "keyword2",
    "mcrypt_enc_get_modes_name": "keyword2",
    "mcrypt_enc_get_supported_key_sizes": "keyword2",
    "mcrypt_enc_is_block_algorithm": "keyword2",
    "mcrypt_enc_is_block_algorithm_mode": "keyword2",
    "mcrypt_enc_is_block_mode": "keyword2",
    "mcrypt_enc_self_test": "keyword2",
    "mcrypt_encrypt": "keyword2",
    "mcrypt_generic": "keyword2",
    "mcrypt_generic_deinit": "keyword2",
    "mcrypt_generic_end": "keyword2",
    "mcrypt_generic_init": "keyword2",
    "mcrypt_get_block_size": "keyword2",
    "mcrypt_get_cipher_name": "keyword2",
    "mcrypt_get_iv_size": "keyword2",
    "mcrypt_get_key_size": "keyword2",
    "mcrypt_list_algorithms": "keyword2",
    "mcrypt_list_modes": "keyword2",
    "mcrypt_module_close": "keyword2",
    "mcrypt_module_get_algo_block_size": "keyword2",
    "mcrypt_module_get_algo_key_size": "keyword2",
    "mcrypt_module_get_supported_key_sizes": "keyword2",
    "mcrypt_module_is_block_algorithm": "keyword2",
    "mcrypt_module_is_block_algorithm_mode": "keyword2",
    "mcrypt_module_is_block_mode": "keyword2",
    "mcrypt_module_open": "keyword2",
    "mcrypt_module_self_test": "keyword2",
    "mcrypt_ofb": "keyword2",
    "md5": "keyword2",
    "md5_file": "keyword2",
    "mdecrypt_generic": "keyword2",
    "metaphone": "keyword2",
    "method_exists": "keyword2",
    "mhash": "keyword2",
    "mhash_count": "keyword2",
    "mhash_get_block_size": "keyword2",
    "mhash_get_hash_name": "keyword2",
    "mhash_keygen_s2k": "keyword2",
    "microtime": "keyword2",
    "min": "keyword2",
    "ming_setcubicthreshold": "keyword2",
    "ming_setscale": "keyword2",
    "mkdir": "keyword2",
    "mktime": "keyword2",
    "move": "keyword2",
    "move_uploaded_file": "keyword2",
    "movepen": "keyword2",
    "movepento": "keyword2",
    "moveto": "keyword2",
    "msql": "keyword2",
    "msql_affected_rows": "keyword2",
    "msql_close": "keyword2",
    "msql_connect": "keyword2",
    "msql_create_db": "keyword2",
    "msql_createdb": "keyword2",
    "msql_data_seek": "keyword2",
    "msql_db_query": "keyword2",
    "msql_dbname": "keyword2",
    "msql_drop_db": "keyword2",
    "msql_dropdb": "keyword2",
    "msql_error": "keyword2",
    "msql_fetch_array": "keyword2",
    "msql_fetch_field": "keyword2",
    "msql_fetch_object": "keyword2",
    "msql_fetch_row": "keyword2",
    "msql_field_flags": "keyword2",
    "msql_field_len": "keyword2",
    "msql_field_name": "keyword2",
    "msql_field_seek": "keyword2",
    "msql_field_table": "keyword2",
    "msql_field_type": "keyword2",
    "msql_fieldflags": "keyword2",
    "msql_fieldlen": "keyword2",
    "msql_fieldname": "keyword2",
    "msql_fieldtable": "keyword2",
    "msql_fieldtype": "keyword2",
    "msql_free_result": "keyword2",
    "msql_freeresult": "keyword2",
    "msql_list_dbs": "keyword2",
    "msql_list_fields": "keyword2",
    "msql_list_tables": "keyword2",
    "msql_listdbs": "keyword2",
    "msql_listfields": "keyword2",
    "msql_listtables": "keyword2",
    "msql_num_fields": "keyword2",
    "msql_num_rows": "keyword2",
    "msql_numfields": "keyword2",
    "msql_numrows": "keyword2",
    "msql_pconnect": "keyword2",
    "msql_query": "keyword2",
    "msql_regcase": "keyword2",
    "msql_result": "keyword2",
    "msql_select_db": "keyword2",
    "msql_selectdb": "keyword2",
    "msql_tablename": "keyword2",
    "mssql_affected_rows": "keyword2",
    "mssql_close": "keyword2",
    "mssql_connect": "keyword2",
    "mssql_data_seek": "keyword2",
    "mssql_fetch_array": "keyword2",
    "mssql_fetch_batch": "keyword2",
    "mssql_fetch_field": "keyword2",
    "mssql_fetch_object": "keyword2",
    "mssql_fetch_row": "keyword2",
    "mssql_field_length": "keyword2",
    "mssql_field_name": "keyword2",
    "mssql_field_seek": "keyword2",
    "mssql_field_type": "keyword2",
    "mssql_free_result": "keyword2",
    "mssql_get_last_message": "keyword2",
    "mssql_min_client_severity": "keyword2",
    "mssql_min_error_severity": "keyword2",
    "mssql_min_message_severity": "keyword2",
    "mssql_min_server_severity": "keyword2",
    "mssql_next_result": "keyword2",
    "mssql_num_fields": "keyword2",
    "mssql_num_rows": "keyword2",
    "mssql_pconnect": "keyword2",
    "mssql_query": "keyword2",
    "mssql_result": "keyword2",
    "mssql_rows_affected": "keyword2",
    "mssql_select_db": "keyword2",
    "mt_getrandmax": "keyword2",
    "mt_rand": "keyword2",
    "mt_srand": "keyword2",
    "multcolor": "keyword2",
    "muscat_close": "keyword2",
    "muscat_get": "keyword2",
    "muscat_give": "keyword2",
    "muscat_setup": "keyword2",
    "muscat_setup_net": "keyword2",
    "mysql": "keyword2",
    "mysql_affected_rows": "keyword2",
    "mysql_close": "keyword2",
    "mysql_connect": "keyword2",
    "mysql_create_db": "keyword2",
    "mysql_createdb": "keyword2",
    "mysql_data_seek": "keyword2",
    "mysql_db_name": "keyword2",
    "mysql_db_query": "keyword2",
    "mysql_dbname": "keyword2",
    "mysql_drop_db": "keyword2",
    "mysql_dropdb": "keyword2",
    "mysql_errno": "keyword2",
    "mysql_error": "keyword2",
    "mysql_escape_string": "keyword2",
    "mysql_fetch_array": "keyword2",
    "mysql_fetch_assoc": "keyword2",
    "mysql_fetch_field": "keyword2",
    "mysql_fetch_lengths": "keyword2",
    "mysql_fetch_object": "keyword2",
    "mysql_fetch_row": "keyword2",
    "mysql_field_flags": "keyword2",
    "mysql_field_len": "keyword2",
    "mysql_field_name": "keyword2",
    "mysql_field_seek": "keyword2",
    "mysql_field_table": "keyword2",
    "mysql_field_type": "keyword2",
    "mysql_fieldflags": "keyword2",
    "mysql_fieldlen": "keyword2",
    "mysql_fieldname": "keyword2",
    "mysql_fieldtable": "keyword2",
    "mysql_fieldtype": "keyword2",
    "mysql_free_result": "keyword2",
    "mysql_freeresult": "keyword2",
    "mysql_get_client_info": "keyword2",
    "mysql_get_host_info": "keyword2",
    "mysql_get_proto_info": "keyword2",
    "mysql_get_server_info": "keyword2",
    "mysql_insert_id": "keyword2",
    "mysql_list_dbs": "keyword2",
    "mysql_list_fields": "keyword2",
    "mysql_list_tables": "keyword2",
    "mysql_listdbs": "keyword2",
    "mysql_listfields": "keyword2",
    "mysql_listtables": "keyword2",
    "mysql_num_fields": "keyword2",
    "mysql_num_rows": "keyword2",
    "mysql_numfields": "keyword2",
    "mysql_numrows": "keyword2",
    "mysql_pconnect": "keyword2",
    "mysql_query": "keyword2",
    "mysql_result": "keyword2",
    "mysql_select_db": "keyword2",
    "mysql_selectdb": "keyword2",
    "mysql_tablename": "keyword2",
    "mysql_unbuffered_query": "keyword2",
    "natcasesort": "keyword2",
    "natsort": "keyword2",
    "new": "keyword1",
    "new_xmldoc": "keyword2",
    "next": "keyword2",
    "nextframe": "keyword2",
    "nl2br": "keyword2",
    "notes_body": "keyword2",
    "notes_copy_db": "keyword2",
    "notes_create_db": "keyword2",
    "notes_create_note": "keyword2",
    "notes_drop_db": "keyword2",
    "notes_find_note": "keyword2",
    "notes_header_info": "keyword2",
    "notes_list_msgs": "keyword2",
    "notes_mark_read": "keyword2",
    "notes_mark_unread": "keyword2",
    "notes_nav_create": "keyword2",
    "notes_search": "keyword2",
    "notes_unread": "keyword2",
    "notes_version": "keyword2",
    "null": "keyword3",
    "number_format": "keyword2",
    "ob_end_clean": "keyword2",
    "ob_end_flush": "keyword2",
    "ob_get_clean": "keyword2",
    "ob_get_contents": "keyword2",
    "ob_get_flush": "keyword2",
    "ob_get_length": "keyword2",
    "ob_gzhandler": "keyword2",
    "ob_iconv_handler": "keyword2",
    "ob_implicit_flush": "keyword2",
    "ob_list_handlers": "keyword2",
    "ob_start": "keyword2",
    "ocibindbyname": "keyword2",
    "ocicancel": "keyword2",
    "ocicollappend": "keyword2",
    "ocicollassign": "keyword2",
    "ocicollassignelem": "keyword2",
    "ocicolldateappendelem": "keyword2",
    "ocicolldateassignelem": "keyword2",
    "ocicolldategetelem": "keyword2",
    "ocicollgetelem": "keyword2",
    "ocicollmax": "keyword2",
    "ocicollsize": "keyword2",
    "ocicolltrim": "keyword2",
    "ocicolumnisnull": "keyword2",
    "ocicolumnname": "keyword2",
    "ocicolumnprecision": "keyword2",
    "ocicolumnscale": "keyword2",
    "ocicolumnsize": "keyword2",
    "ocicolumntype": "keyword2",
    "ocicolumntyperaw": "keyword2",
    "ocicommit": "keyword2",
    "ocidefinebyname": "keyword2",
    "ocierror": "keyword2",
    "ociexecute": "keyword2",
    "ocifetch": "keyword2",
    "ocifetchinto": "keyword2",
    "ocifetchstatement": "keyword2",
    "ocifreecoll": "keyword2",
    "ocifreecursor": "keyword2",
    "ocifreedesc": "keyword2",
    "ocifreestatement": "keyword2",
    "ociinternaldebug": "keyword2",
    "ociloadlob": "keyword2",
    "ocilogoff": "keyword2",
    "ocilogon": "keyword2",
    "ocinewcollection": "keyword2",
    "ocinewcursor": "keyword2",
    "ocinewdescriptor": "keyword2",
    "ocinlogon": "keyword2",
    "ocinumcols": "keyword2",
    "ociparse": "keyword2",
    "ociplogon": "keyword2",
    "ociresult": "keyword2",
    "ocirollback": "keyword2",
    "ocirowcount": "keyword2",
    "ocisavelob": "keyword2",
    "ocisavelobfile": "keyword2",
    "ociserverversion": "keyword2",
    "ocisetprefetch": "keyword2",
    "ocistatementtype": "keyword2",
    "ociwritelobtofile": "keyword2",
    "octdec": "keyword2",
    "odbc_autocommit": "keyword2",
    "odbc_binmode": "keyword2",
    "odbc_close": "keyword2",
    "odbc_close_all": "keyword2",
    "odbc_columnprivileges": "keyword2",
    "odbc_columns": "keyword2",
    "odbc_commit": "keyword2",
    "odbc_connect": "keyword2",
    "odbc_cursor": "keyword2",
    "odbc_data_source": "keyword2",
    "odbc_do": "keyword2",
    "odbc_error": "keyword2",
    "odbc_errormsg": "keyword2",
    "odbc_exec": "keyword2",
    "odbc_execute": "keyword2",
    "odbc_fetch_array": "keyword2",
    "odbc_fetch_into": "keyword2",
    "odbc_fetch_object": "keyword2",
    "odbc_fetch_row": "keyword2",
    "odbc_field_len": "keyword2",
    "odbc_field_name": "keyword2",
    "odbc_field_num": "keyword2",
    "odbc_field_precision": "keyword2",
    "odbc_field_scale": "keyword2",
    "odbc_field_type": "keyword2",
    "odbc_foreignkeys": "keyword2",
    "odbc_free_result": "keyword2",
    "odbc_gettypeinfo": "keyword2",
    "odbc_longreadlen": "keyword2",
    "odbc_next_result": "keyword2",
    "odbc_num_fields": "keyword2",
    "odbc_num_rows": "keyword2",
    "odbc_pconnect": "keyword2",
    "odbc_prepare": "keyword2",
    "odbc_primarykeys": "keyword2",
    "odbc_procedurecolumns": "keyword2",
    "odbc_procedures": "keyword2",
    "odbc_result": "keyword2",
    "odbc_result_all": "keyword2",
    "odbc_rollback": "keyword2",
    "odbc_setoption": "keyword2",
    "odbc_specialcolumns": "keyword2",
    "odbc_statistics": "keyword2",
    "odbc_tableprivileges": "keyword2",
    "odbc_tables": "keyword2",
    "old_function": "keyword1",
    "open_listen_sock": "keyword2",
    "opendir": "keyword2",
    "openlog": "keyword2",
    "openssl_error_string": "keyword2",
    "openssl_free_key": "keyword2",
    "openssl_get_privatekey": "keyword2",
    "openssl_get_publickey": "keyword2",
    "openssl_open": "keyword2",
    "openssl_pkcs7_decrypt": "keyword2",
    "openssl_pkcs7_encrypt": "keyword2",
    "openssl_pkcs7_sign": "keyword2",
    "openssl_pkcs7_verify": "keyword2",
    "openssl_seal": "keyword2",
    "openssl_sign": "keyword2",
    "openssl_verify": "keyword2",
    "openssl_x509_checkpurpose": "keyword2",
    "openssl_x509_free": "keyword2",
    "openssl_x509_parse": "keyword2",
    "openssl_x509_read": "keyword2",
    "or": "operator",
    "ora_bind": "keyword2",
    "ora_close": "keyword2",
    "ora_columnname": "keyword2",
    "ora_columnsize": "keyword2",
    "ora_columntype": "keyword2",
    "ora_commit": "keyword2",
    "ora_commitoff": "keyword2",
    "ora_commiton": "keyword2",
    "ora_do": "keyword2",
    "ora_error": "keyword2",
    "ora_errorcode": "keyword2",
    "ora_exec": "keyword2",
    "ora_fetch": "keyword2",
    "ora_fetch_into": "keyword2",
    "ora_getcolumn": "keyword2",
    "ora_logoff": "keyword2",
    "ora_logon": "keyword2",
    "ora_numcols": "keyword2",
    "ora_numrows": "keyword2",
    "ora_open": "keyword2",
    "ora_parse": "keyword2",
    "ora_plogon": "keyword2",
    "ora_rollback": "keyword2",
    "orbit_caught_exception": "keyword2",
    "orbit_exception_id": "keyword2",
    "orbit_exception_value": "keyword2",
    "orbit_get_repository_id": "keyword2",
    "orbit_load_idl": "keyword2",
    "ord": "keyword2",
    "output": "keyword2",
    "ovrimos_close": "keyword2",
    "ovrimos_close_all": "keyword2",
    "ovrimos_commit": "keyword2",
    "ovrimos_connect": "keyword2",
    "ovrimos_cursor": "keyword2",
    "ovrimos_exec": "keyword2",
    "ovrimos_execute": "keyword2",
    "ovrimos_fetch_into": "keyword2",
    "ovrimos_fetch_row": "keyword2",
    "ovrimos_field_len": "keyword2",
    "ovrimos_field_name": "keyword2",
    "ovrimos_field_num": "keyword2",
    "ovrimos_field_type": "keyword2",
    "ovrimos_free_result": "keyword2",
    "ovrimos_longreadlen": "keyword2",
    "ovrimos_num_fields": "keyword2",
    "ovrimos_num_rows": "keyword2",
    "ovrimos_prepare": "keyword2",
    "ovrimos_result": "keyword2",
    "ovrimos_result_all": "keyword2",
    "ovrimos_rollback": "keyword2",
    "pack": "keyword2",
    "parse_ini_file": "keyword2",
    "parse_str": "keyword2",
    "parse_url": "keyword2",
    "passthru": "keyword2",
    "pathinfo": "keyword2",
    "pclose": "keyword2",
    "pdf_add_annotation": "keyword2",
    "pdf_add_bookmark": "keyword2",
    "pdf_add_launchlink": "keyword2",
    "pdf_add_locallink": "keyword2",
    "pdf_add_note": "keyword2",
    "pdf_add_outline": "keyword2",
    "pdf_add_pdflink": "keyword2",
    "pdf_add_thumbnail": "keyword2",
    "pdf_add_weblink": "keyword2",
    "pdf_arc": "keyword2",
    "pdf_arcn": "keyword2",
    "pdf_attach_file": "keyword2",
    "pdf_begin_page": "keyword2",
    "pdf_begin_pattern": "keyword2",
    "pdf_begin_template": "keyword2",
    "pdf_circle": "keyword2",
    "pdf_clip": "keyword2",
    "pdf_close": "keyword2",
    "pdf_close_image": "keyword2",
    "pdf_close_pdi": "keyword2",
    "pdf_close_pdi_page": "keyword2",
    "pdf_closepath": "keyword2",
    "pdf_closepath_fill_stroke": "keyword2",
    "pdf_closepath_stroke": "keyword2",
    "pdf_concat": "keyword2",
    "pdf_continue_text": "keyword2",
    "pdf_curveto": "keyword2",
    "pdf_delete": "keyword2",
    "pdf_end_page": "keyword2",
    "pdf_end_pattern": "keyword2",
    "pdf_end_template": "keyword2",
    "pdf_endpath": "keyword2",
    "pdf_fill": "keyword2",
    "pdf_fill_stroke": "keyword2",
    "pdf_findfont": "keyword2",
    "pdf_get_buffer": "keyword2",
    "pdf_get_font": "keyword2",
    "pdf_get_fontname": "keyword2",
    "pdf_get_fontsize": "keyword2",
    "pdf_get_image_height": "keyword2",
    "pdf_get_image_width": "keyword2",
    "pdf_get_parameter": "keyword2",
    "pdf_get_pdi_parameter": "keyword2",
    "pdf_get_pdi_value": "keyword2",
    "pdf_get_value": "keyword2",
    "pdf_initgraphics": "keyword2",
    "pdf_lineto": "keyword2",
    "pdf_makespotcolor": "keyword2",
    "pdf_moveto": "keyword2",
    "pdf_new": "keyword2",
    "pdf_open": "keyword2",
    "pdf_open_ccitt": "keyword2",
    "pdf_open_file": "keyword2",
    "pdf_open_gif": "keyword2",
    "pdf_open_image": "keyword2",
    "pdf_open_image_file": "keyword2",
    "pdf_open_jpeg": "keyword2",
    "pdf_open_memory_image": "keyword2",
    "pdf_open_pdi": "keyword2",
    "pdf_open_pdi_page": "keyword2",
    "pdf_open_png": "keyword2",
    "pdf_open_tiff": "keyword2",
    "pdf_place_image": "keyword2",
    "pdf_place_pdi_page": "keyword2",
    "pdf_rect": "keyword2",
    "pdf_restore": "keyword2",
    "pdf_rotate": "keyword2",
    "pdf_save": "keyword2",
    "pdf_scale": "keyword2",
    "pdf_set_border_color": "keyword2",
    "pdf_set_border_dash": "keyword2",
    "pdf_set_border_style": "keyword2",
    "pdf_set_char_spacing": "keyword2",
    "pdf_set_duration": "keyword2",
    "pdf_set_font": "keyword2",
    "pdf_set_horiz_scaling": "keyword2",
    "pdf_set_info": "keyword2",
    "pdf_set_info_author": "keyword2",
    "pdf_set_info_creator": "keyword2",
    "pdf_set_info_keywords": "keyword2",
    "pdf_set_info_subject": "keyword2",
    "pdf_set_info_title": "keyword2",
    "pdf_set_leading": "keyword2",
    "pdf_set_parameter": "keyword2",
    "pdf_set_text_pos": "keyword2",
    "pdf_set_text_rendering": "keyword2",
    "pdf_set_text_rise": "keyword2",
    "pdf_set_transition": "keyword2",
    "pdf_set_value": "keyword2",
    "pdf_set_word_spacing": "keyword2",
    "pdf_setcolor": "keyword2",
    "pdf_setdash": "keyword2",
    "pdf_setflat": "keyword2",
    "pdf_setfont": "keyword2",
    "pdf_setgray": "keyword2",
    "pdf_setgray_fill": "keyword2",
    "pdf_setgray_stroke": "keyword2",
    "pdf_setlinecap": "keyword2",
    "pdf_setlinejoin": "keyword2",
    "pdf_setlinewidth": "keyword2",
    "pdf_setmatrix": "keyword2",
    "pdf_setmiterlimit": "keyword2",
    "pdf_setpolydash": "keyword2",
    "pdf_setrgbcolor": "keyword2",
    "pdf_setrgbcolor_fill": "keyword2",
    "pdf_setrgbcolor_stroke": "keyword2",
    "pdf_show": "keyword2",
    "pdf_show_boxed": "keyword2",
    "pdf_show_xy": "keyword2",
    "pdf_skew": "keyword2",
    "pdf_stringwidth": "keyword2",
    "pdf_stroke": "keyword2",
    "pdf_translate": "keyword2",
    "pfpro_cleanup": "keyword2",
    "pfpro_init": "keyword2",
    "pfpro_process": "keyword2",
    "pfpro_process_raw": "keyword2",
    "pfpro_version": "keyword2",
    "pfsockopen": "keyword2",
    "pg_client_encoding": "keyword2",
    "pg_clientencoding": "keyword2",
    "pg_close": "keyword2",
    "pg_cmdtuples": "keyword2",
    "pg_connect": "keyword2",
    "pg_convert": "keyword2",
    "pg_dbname": "keyword2",
    "pg_delete": "keyword2",
    "pg_end_copy": "keyword2",
    "pg_errormessage": "keyword2",
    "pg_exec": "keyword2",
    "pg_fetch_all": "keyword2",
    "pg_fetch_array": "keyword2",
    "pg_fetch_assoc": "keyword2",
    "pg_fetch_object": "keyword2",
    "pg_fetch_row": "keyword2",
    "pg_fieldisnull": "keyword2",
    "pg_fieldname": "keyword2",
    "pg_fieldnum": "keyword2",
    "pg_fieldprtlen": "keyword2",
    "pg_fieldsize": "keyword2",
    "pg_fieldtype": "keyword2",
    "pg_freeresult": "keyword2",
    "pg_get_notify": "keyword2",
    "pg_get_pid": "keyword2",
    "pg_getlastoid": "keyword2",
    "pg_host": "keyword2",
    "pg_insert": "keyword2",
    "pg_loclose": "keyword2",
    "pg_locreate": "keyword2",
    "pg_loexport": "keyword2",
    "pg_loimport": "keyword2",
    "pg_loopen": "keyword2",
    "pg_loread": "keyword2",
    "pg_loreadall": "keyword2",
    "pg_lounlink": "keyword2",
    "pg_lowrite": "keyword2",
    "pg_meta_data": "keyword2",
    "pg_numfields": "keyword2",
    "pg_numrows": "keyword2",
    "pg_options": "keyword2",
    "pg_pconnect": "keyword2",
    "pg_ping": "keyword2",
    "pg_port": "keyword2",
    "pg_put_line": "keyword2",
    "pg_result": "keyword2",
    "pg_result_seek": "keyword2",
    "pg_select": "keyword2",
    "pg_set_client_encoding": "keyword2",
    "pg_setclientencoding": "keyword2",
    "pg_trace": "keyword2",
    "pg_tty": "keyword2",
    "pg_unescape_bytea": "keyword2",
    "pg_untrace": "keyword2",
    "pg_update": "keyword2",
    "php_logo_guid": "keyword2",
    "php_sapi_name": "keyword2",
    "php_uname": "keyword2",
    "phpcredits": "keyword2",
    "phpinfo": "keyword2",
    "phpversion": "keyword2",
    "pi": "keyword2",
    "png2wbmp": "keyword2",
    "popen": "keyword2",
    "pos": "keyword2",
    "posix_ctermid": "keyword2",
    "posix_getcwd": "keyword2",
    "posix_getegid": "keyword2",
    "posix_geteuid": "keyword2",
    "posix_getgid": "keyword2",
    "posix_getgrgid": "keyword2",
    "posix_getgrnam": "keyword2",
    "posix_getgroups": "keyword2",
    "posix_getlogin": "keyword2",
    "posix_getpgid": "keyword2",
    "posix_getpgrp": "keyword2",
    "posix_getpid": "keyword2",
    "posix_getppid": "keyword2",
    "posix_getpwnam": "keyword2",
    "posix_getpwuid": "keyword2",
    "posix_getrlimit": "keyword2",
    "posix_getsid": "keyword2",
    "posix_getuid": "keyword2",
    "posix_isatty": "keyword2",
    "posix_kill": "keyword2",
    "posix_mkfifo": "keyword2",
    "posix_setegid": "keyword2",
    "posix_seteuid": "keyword2",
    "posix_setgid": "keyword2",
    "posix_setpgid": "keyword2",
    "posix_setsid": "keyword2",
    "posix_setuid": "keyword2",
    "posix_times": "keyword2",
    "posix_ttyname": "keyword2",
    "posix_uname": "keyword2",
    "pow": "keyword2",
    "preg_grep": "keyword2",
    "preg_match": "keyword2",
    "preg_match_all": "keyword2",
    "preg_quote": "keyword2",
    "preg_replace": "keyword2",
    "preg_replace_callback": "keyword2",
    "preg_split": "keyword2",
    "prev": "keyword2",
    "print_r": "keyword2",
    "printer_abort": "keyword2",
    "printer_close": "keyword2",
    "printer_create_brush": "keyword2",
    "printer_create_dc": "keyword2",
    "printer_create_font": "keyword2",
    "printer_create_pen": "keyword2",
    "printer_delete_brush": "keyword2",
    "printer_delete_dc": "keyword2",
    "printer_delete_font": "keyword2",
    "printer_delete_pen": "keyword2",
    "printer_draw_bmp": "keyword2",
    "printer_draw_chord": "keyword2",
    "printer_draw_elipse": "keyword2",
    "printer_draw_line": "keyword2",
    "printer_draw_pie": "keyword2",
    "printer_draw_rectangle": "keyword2",
    "printer_draw_roundrect": "keyword2",
    "printer_draw_text": "keyword2",
    "printer_end_doc": "keyword2",
    "printer_end_page": "keyword2",
    "printer_get_option": "keyword2",
    "printer_list": "keyword2",
    "printer_logical_fontheight": "keyword2",
    "printer_open": "keyword2",
    "printer_select_brush": "keyword2",
    "printer_select_font": "keyword2",
    "printer_select_pen": "keyword2",
    "printer_set_option": "keyword2",
    "printer_start_doc": "keyword2",
    "printer_start_page": "keyword2",
    "printer_write": "keyword2",
    "printf": "keyword2",
    "private": "keyword1",
    "protected": "keyword1",
    "pspell_add_to_personal": "keyword2",
    "pspell_add_to_session": "keyword2",
    "pspell_check": "keyword2",
    "pspell_clear_session": "keyword2",
    "pspell_config_create": "keyword2",
    "pspell_config_ignore": "keyword2",
    "pspell_config_mode": "keyword2",
    "pspell_config_personal": "keyword2",
    "pspell_config_repl": "keyword2",
    "pspell_config_runtogether": "keyword2",
    "pspell_config_save_repl": "keyword2",
    "pspell_new": "keyword2",
    "pspell_new_config": "keyword2",
    "pspell_new_personal": "keyword2",
    "pspell_save_wordlist": "keyword2",
    "pspell_store_replacement": "keyword2",
    "pspell_suggest": "keyword2",
    "public": "keyword1",
    "putenv": "keyword2",
    "qdom_error": "keyword2",
    "qdom_tree": "keyword2",
    "quoted_printable_decode": "keyword2",
    "quotemeta": "keyword2",
    "rad2deg": "keyword2",
    "rand": "keyword2",
    "range": "keyword2",
    "rawurldecode": "keyword2",
    "rawurlencode": "keyword2",
    "read": "keyword2",
    "read_exif_data": "keyword2",
    "readdir": "keyword2",
    "readfile": "keyword2",
    "readgzfile": "keyword2",
    "readline": "keyword2",
    "readline_add_history": "keyword2",
    "readline_clear_history": "keyword2",
    "readline_completion_function": "keyword2",
    "readline_info": "keyword2",
    "readline_list_history": "keyword2",
    "readline_read_history": "keyword2",
    "readline_write_history": "keyword2",
    "readlink": "keyword2",
    "readv": "keyword2",
    "realpath": "keyword2",
    "recode": "keyword2",
    "recode_file": "keyword2",
    "recode_string": "keyword2",
    "recv": "keyword2",
    "recvfrom": "keyword2",
    "recvmsg": "keyword2",
    "register_shutdown_function": "keyword2",
    "register_tick_function": "keyword2",
    "remove": "keyword2",
    "rename": "keyword2",
    "require": "keyword1",
    "require_once": "keyword1",
    "reset": "keyword2",
    "restore_error_handler": "keyword2",
    "return": "keyword1",
    "rewind": "keyword2",
    "rewinddir": "keyword2",
    "rmdir": "keyword2",
    "rotate": "keyword2",
    "rotateto": "keyword2",
    "round": "keyword2",
    "rsort": "keyword2",
    "rtrim": "keyword2",
    "satellite_caught_exception": "keyword2",
    "satellite_exception_id": "keyword2",
    "satellite_exception_value": "keyword2",
    "satellite_get_repository_id": "keyword2",
    "satellite_load_idl": "keyword2",
    "save": "keyword2",
    "savetofile": "keyword2",
    "scale": "keyword2",
    "scaleto": "keyword2",
    "scandir": "keyword2",
    "select": "keyword2",
    "sem_acquire": "keyword2",
    "sem_get": "keyword2",
    "sem_release": "keyword2",
    "send": "keyword2",
    "sendmsg": "keyword2",
    "sendto": "keyword2",
    "serialize": "keyword2",
    "session_cache_limiter": "keyword2",
    "session_decode": "keyword2",
    "session_destroy": "keyword2",
    "session_encode": "keyword2",
    "session_get_cookie_params": "keyword2",
    "session_id": "keyword2",
    "session_is_registered": "keyword2",
    "session_module_name": "keyword2",
    "session_name": "keyword2",
    "session_register": "keyword2",
    "session_save_path": "keyword2",
    "session_set_cookie_params": "keyword2",
    "session_set_save_handler": "keyword2",
    "session_start": "keyword2",
    "session_unregister": "keyword2",
    "session_unset": "keyword2",
    "session_write_close": "keyword2",
    "set_content": "keyword2",
    "set_error_handler": "keyword2",
    "set_file_buffer": "keyword2",
    "set_iovec": "keyword2",
    "set_magic_quotes_runtime": "keyword2",
    "set_nonblock": "keyword2",
    "set_socket_blocking": "keyword2",
    "set_time_limit": "keyword2",
    "setaction": "keyword2",
    "setbackground": "keyword2",
    "setbounds": "keyword2",
    "setcolor": "keyword2",
    "setcookie": "keyword2",
    "setdepth": "keyword2",
    "setdimension": "keyword2",
    "setdown": "keyword2",
    "setfont": "keyword2",
    "setframes": "keyword2",
    "setheight": "keyword2",
    "sethit": "keyword2",
    "setindentation": "keyword2",
    "setleftfill": "keyword2",
    "setleftmargin": "keyword2",
    "setline": "keyword2",
    "setlinespacing": "keyword2",
    "setlocale": "keyword2",
    "setmargins": "keyword2",
    "setmatrix": "keyword2",
    "setname": "keyword2",
    "setover": "keyword2",
    "setrate": "keyword2",
    "setratio": "keyword2",
    "setrightfill": "keyword2",
    "setrightmargin": "keyword2",
    "setsockopt": "keyword2",
    "setspacing": "keyword2",
    "settype": "keyword2",
    "setup": "keyword2",
    "sha1": "keyword2",
    "sha1_file": "keyword2",
    "shell_exec": "keyword2",
    "shm_attach": "keyword2",
    "shm_detach": "keyword2",
    "shm_get_var": "keyword2",
    "shm_put_var": "keyword2",
    "shm_remove": "keyword2",
    "shm_remove_var": "keyword2",
    "shmop_close": "keyword2",
    "shmop_delete": "keyword2",
    "shmop_open": "keyword2",
    "shmop_read": "keyword2",
    "shmop_size": "keyword2",
    "shmop_write": "keyword2",
    "show_source": "keyword2",
    "shuffle": "keyword2",
    "shutdown": "keyword2",
    "signal": "keyword2",
    "similar_text": "keyword2",
    "sin": "keyword2",
    "sizeof": "keyword2",
    "skewx": "keyword2",
    "skewxto": "keyword2",
    "skewy": "keyword2",
    "skewyto": "keyword2",
    "sleep": "keyword2",
    "snmp_get_quick_print": "keyword2",
    "snmp_set_quick_print": "keyword2",
    "snmpget": "keyword2",
    "snmprealwalk": "keyword2",
    "snmpset": "keyword2",
    "snmpwalk": "keyword2",
    "snmpwalkoid": "keyword2",
    "socket": "keyword2",
    "socket_get_status": "keyword2",
    "socket_set_blocking": "keyword2",
    "socket_set_timeout": "keyword2",
    "socketpair": "keyword2",
    "sort": "keyword2",
    "soundex": "keyword2",
    "split": "keyword2",
    "spliti": "keyword2",
    "sprintf": "keyword2",
    "sql_regcase": "keyword2",
    "sqrt": "keyword2",
    "srand": "keyword2",
    "sscanf": "keyword2",
    "stat": "keyword2",
    "static": "keyword1",
    "str_pad": "keyword2",
    "str_repeat": "keyword2",
    "str_replace": "keyword2",
    "str_rot13": "keyword2",
    "str_split": "keyword2",
    "str_word_count": "keyword2",
    "strcasecmp": "keyword2",
    "strchr": "keyword2",
    "strcmp": "keyword2",
    "strcoll": "keyword2",
    "strcspn": "keyword2",
    "stream_context_create": "keyword2",
    "stream_context_set_option": "keyword2",
    "stream_context_set_params": "keyword2",
    "stream_filter_append": "keyword2",
    "stream_filter_prepend": "keyword2",
    "stream_get_status": "keyword2",
    "stream_select": "keyword2",
    "stream_set_blocking": "keyword2",
    "stream_set_timeout": "keyword2",
    "streammp3": "keyword2",
    "strerror": "keyword2",
    "strftime": "keyword2",
    "strip_tags": "keyword2",
    "stripcslashes": "keyword2",
    "stripos": "keyword2",
    "stripslashes": "keyword2",
    "stristr": "keyword2",
    "strlen": "keyword2",
    "strnatcasecmp": "keyword2",
    "strnatcmp": "keyword2",
    "strncasecmp": "keyword2",
    "strncmp": "keyword2",
    "strpbrk": "keyword2",
    "strpos": "keyword2",
    "strrchr": "keyword2",
    "strrev": "keyword2",
    "strrpos": "keyword2",
    "strspn": "keyword2",
    "strstr": "keyword2",
    "strtok": "keyword2",
    "strtolower": "keyword2",
    "strtotime": "keyword2",
    "strtoupper": "keyword2",
    "strtr": "keyword2",
    "strval": "keyword2",
    "substr": "keyword2",
    "substr_compare": "keyword2",
    "substr_count": "keyword2",
    "substr_replace": "keyword2",
    "swf_actiongeturl": "keyword2",
    "swf_actiongotoframe": "keyword2",
    "swf_actiongotolabel": "keyword2",
    "swf_actionnextframe": "keyword2",
    "swf_actionplay": "keyword2",
    "swf_actionprevframe": "keyword2",
    "swf_actionsettarget": "keyword2",
    "swf_actionstop": "keyword2",
    "swf_actiontogglequality": "keyword2",
    "swf_actionwaitforframe": "keyword2",
    "swf_addbuttonrecord": "keyword2",
    "swf_addcolor": "keyword2",
    "swf_closefile": "keyword2",
    "swf_definebitmap": "keyword2",
    "swf_definefont": "keyword2",
    "swf_defineline": "keyword2",
    "swf_definepoly": "keyword2",
    "swf_definerect": "keyword2",
    "swf_definetext": "keyword2",
    "swf_endbutton": "keyword2",
    "swf_enddoaction": "keyword2",
    "swf_endshape": "keyword2",
    "swf_endsymbol": "keyword2",
    "swf_fontsize": "keyword2",
    "swf_fontslant": "keyword2",
    "swf_fonttracking": "keyword2",
    "swf_getbitmapinfo": "keyword2",
    "swf_getfontinfo": "keyword2",
    "swf_getframe": "keyword2",
    "swf_labelframe": "keyword2",
    "swf_lookat": "keyword2",
    "swf_modifyobject": "keyword2",
    "swf_mulcolor": "keyword2",
    "swf_nextid": "keyword2",
    "swf_oncondition": "keyword2",
    "swf_openfile": "keyword2",
    "swf_ortho": "keyword2",
    "swf_ortho2": "keyword2",
    "swf_perspective": "keyword2",
    "swf_placeobject": "keyword2",
    "swf_polarview": "keyword2",
    "swf_popmatrix": "keyword2",
    "swf_posround": "keyword2",
    "swf_pushmatrix": "keyword2",
    "swf_removeobject": "keyword2",
    "swf_rotate": "keyword2",
    "swf_scale": "keyword2",
    "swf_setfont": "keyword2",
    "swf_setframe": "keyword2",
    "swf_shapearc": "keyword2",
    "swf_shapecurveto": "keyword2",
    "swf_shapecurveto3": "keyword2",
    "swf_shapefillbitmapclip": "keyword2",
    "swf_shapefillbitmaptile": "keyword2",
    "swf_shapefilloff": "keyword2",
    "swf_shapefillsolid": "keyword2",
    "swf_shapelinesolid": "keyword2",
    "swf_shapelineto": "keyword2",
    "swf_shapemoveto": "keyword2",
    "swf_showframe": "keyword2",
    "swf_startbutton": "keyword2",
    "swf_startdoaction": "keyword2",
    "swf_startshape": "keyword2",
    "swf_startsymbol": "keyword2",
    "swf_textwidth": "keyword2",
    "swf_translate": "keyword2",
    "swf_viewport": "keyword2",
    "swfaction": "keyword2",
    "swfbitmap": "keyword2",
    "swfbutton": "keyword2",
    "swfbutton_keypress": "keyword2",
    "swffill": "keyword2",
    "swffont": "keyword2",
    "swfgradient": "keyword2",
    "swfmorph": "keyword2",
    "swfmovie": "keyword2",
    "swfshape": "keyword2",
    "swfsprite": "keyword2",
    "swftext": "keyword2",
    "swftextfield": "keyword2",
    "switch": "keyword1",
    "sybase_affected_rows": "keyword2",
    "sybase_close": "keyword2",
    "sybase_connect": "keyword2",
    "sybase_data_seek": "keyword2",
    "sybase_fetch_array": "keyword2",
    "sybase_fetch_field": "keyword2",
    "sybase_fetch_object": "keyword2",
    "sybase_fetch_row": "keyword2",
    "sybase_field_seek": "keyword2",
    "sybase_free_result": "keyword2",
    "sybase_get_last_message": "keyword2",
    "sybase_min_client_severity": "keyword2",
    "sybase_min_error_severity": "keyword2",
    "sybase_min_message_severity": "keyword2",
    "sybase_min_server_severity": "keyword2",
    "sybase_num_fields": "keyword2",
    "sybase_num_rows": "keyword2",
    "sybase_pconnect": "keyword2",
    "sybase_query": "keyword2",
    "sybase_result": "keyword2",
    "sybase_select_db": "keyword2",
    "symlink": "keyword2",
    "syslog": "keyword2",
    "system": "keyword2",
    "tan": "keyword2",
    "tempnam": "keyword2",
    "textdomain": "keyword2",
    "throw": "keyword1",
    "time": "keyword2",
    "time_nanosleep": "keyword2",
    "tmpfile": "keyword2",
    "touch": "keyword2",
    "trigger_error": "keyword2",
    "trim": "keyword2",
    "true": "keyword3",
    "try": "keyword1",
    "uasort": "keyword2",
    "ucfirst": "keyword2",
    "ucwords": "keyword2",
    "udm_add_search_limit": "keyword2",
    "udm_alloc_agent": "keyword2",
    "udm_api_version": "keyword2",
    "udm_clear_search_limits": "keyword2",
    "udm_errno": "keyword2",
    "udm_error": "keyword2",
    "udm_find": "keyword2",
    "udm_free_agent": "keyword2",
    "udm_free_ispell_data": "keyword2",
    "udm_free_res": "keyword2",
    "udm_get_doc_count": "keyword2",
    "udm_get_res_field": "keyword2",
    "udm_get_res_param": "keyword2",
    "udm_load_ispell_data": "keyword2",
    "udm_set_agent_param": "keyword2",
    "uksort": "keyword2",
    "umask": "keyword2",
    "uniqid": "keyword2",
    "unixtojd": "keyword2",
    "unlink": "keyword2",
    "unpack": "keyword2",
    "unregister_tick_function": "keyword2",
    "unserialize": "keyword2",
    "unset": "keyword2",
    "urldecode": "keyword2",
    "urlencode": "keyword2",
    "user_error": "keyword2",
    "usleep": "keyword2",
    "usort": "keyword2",
    "utf8_decode": "keyword2",
    "utf8_encode": "keyword2",
    "var": "keyword1",
    "var_dump": "keyword2",
    "velocis_autocommit": "keyword2",
    "velocis_close": "keyword2",
    "velocis_commit": "keyword2",
    "velocis_connect": "keyword2",
    "velocis_exec": "keyword2",
    "velocis_fetch": "keyword2",
    "velocis_fieldname": "keyword2",
    "velocis_fieldnum": "keyword2",
    "velocis_freeresult": "keyword2",
    "velocis_off_autocommit": "keyword2",
    "velocis_result": "keyword2",
    "velocis_rollback": "keyword2",
    "virtual": "keyword2",
    "vpopmail_add_alias_domain": "keyword2",
    "vpopmail_add_alias_domain_ex": "keyword2",
    "vpopmail_add_domain": "keyword2",
    "vpopmail_add_domain_ex": "keyword2",
    "vpopmail_add_user": "keyword2",
    "vpopmail_auth_user": "keyword2",
    "vpopmail_del_domain": "keyword2",
    "vpopmail_del_domain_ex": "keyword2",
    "vpopmail_del_user": "keyword2",
    "vpopmail_error": "keyword2",
    "vpopmail_passwd": "keyword2",
    "vpopmail_set_user_quota": "keyword2",
    "wddx_add_vars": "keyword2",
    "wddx_deserialize": "keyword2",
    "wddx_packet_end": "keyword2",
    "wddx_packet_start": "keyword2",
    "wddx_serialize_value": "keyword2",
    "wddx_serialize_vars": "keyword2",
    "while": "keyword1",
    "wordwrap": "keyword2",
    "write": "keyword2",
    "writev": "keyword2",
    "xml_error_string": "keyword2",
    "xml_get_current_byte_index": "keyword2",
    "xml_get_current_column_number": "keyword2",
    "xml_get_current_line_number": "keyword2",
    "xml_get_error_code": "keyword2",
    "xml_parse": "keyword2",
    "xml_parse_into_struct": "keyword2",
    "xml_parser_create": "keyword2",
    "xml_parser_create_ns": "keyword2",
    "xml_parser_free": "keyword2",
    "xml_parser_get_option": "keyword2",
    "xml_parser_set_option": "keyword2",
    "xml_set_character_data_handler": "keyword2",
    "xml_set_default_handler": "keyword2",
    "xml_set_element_handler": "keyword2",
    "xml_set_end_namespace_decl_handler": "keyword2",
    "xml_set_external_entity_ref_handler": "keyword2",
    "xml_set_notation_decl_handler": "keyword2",
    "xml_set_object": "keyword2",
    "xml_set_processing_instruction_handler": "keyword2",
    "xml_set_start_namespace_decl_handler": "keyword2",
    "xml_set_unparsed_entity_decl_handler": "keyword2",
    "xmldoc": "keyword2",
    "xmldocfile": "keyword2",
    "xmltree": "keyword2",
    "xpath_eval": "keyword2",
    "xpath_eval_expression": "keyword2",
    "xptr_eval": "keyword2",
    "xslt_closelog": "keyword2",
    "xslt_create": "keyword2",
    "xslt_errno": "keyword2",
    "xslt_error": "keyword2",
    "xslt_fetch_result": "keyword2",
    "xslt_free": "keyword2",
    "xslt_openlog": "keyword2",
    "xslt_output_begintransform": "keyword2",
    "xslt_output_endtransform": "keyword2",
    "xslt_process": "keyword2",
    "xslt_run": "keyword2",
    "xslt_set_base": "keyword2",
    "xslt_set_encoding": "keyword2",
    "xslt_set_error_handler": "keyword2",
    "xslt_set_sax_handler": "keyword2",
    "xslt_set_scheme_handler": "keyword2",
    "xslt_transform": "keyword2",
    "yaz_addinfo": "keyword2",
    "yaz_ccl_conf": "keyword2",
    "yaz_ccl_parse": "keyword2",
    "yaz_close": "keyword2",
    "yaz_connect": "keyword2",
    "yaz_database": "keyword2",
    "yaz_element": "keyword2",
    "yaz_errno": "keyword2",
    "yaz_error": "keyword2",
    "yaz_hits": "keyword2",
    "yaz_itemorder": "keyword2",
    "yaz_present": "keyword2",
    "yaz_range": "keyword2",
    "yaz_record": "keyword2",
    "yaz_scan": "keyword2",
    "yaz_scan_result": "keyword2",
    "yaz_search": "keyword2",
    "yaz_syntax": "keyword2",
    "yaz_wait": "keyword2",
    "yp_all": "keyword2",
    "yp_cat": "keyword2",
    "yp_err_string": "keyword2",
    "yp_errno": "keyword2",
    "yp_first": "keyword2",
    "yp_get_default_domain": "keyword2",
    "yp_master": "keyword2",
    "yp_match": "keyword2",
    "yp_next": "keyword2",
    "yp_order": "keyword2",
    "zend_logo_guid": "keyword2",
    "zend_test_func": "keyword2",
    "zend_version": "keyword2",
    "zzip_close": "keyword2",
    "zzip_closedir": "keyword2",
    "zzip_entry_compressedsize": "keyword2",
    "zzip_entry_compressionmethod": "keyword2",
    "zzip_entry_filesize": "keyword2",
    "zzip_entry_name": "keyword2",
    "zzip_open": "keyword2",
    "zzip_opendir": "keyword2",
    "zzip_read": "keyword2",
    "zzip_readdir": "keyword2",
}

# Keywords dict for php_php_literal ruleset.
php_php_literal_keywords_dict = {}

# Keywords dict for php_javascript ruleset.
php_javascript_keywords_dict = {}

# Keywords dict for php_javascript_php ruleset.
php_javascript_php_keywords_dict = {}

# Keywords dict for php_phpdoc ruleset.
php_phpdoc_keywords_dict = {
    "@abstract": "label",
    "@access": "label",
    "@author": "label",
    "@category": "label",
    "@copyright": "label",
    "@deprecated": "label",
    "@example": "label",
    "@filesource": "label",
    "@final": "label",
    "@global": "label",
    "@id": "label",
    "@ignore": "label",
    "@inheritdoc": "label",
    "@internal": "label",
    "@license": "label",
    "@link": "label",
    "@name": "label",
    "@package": "label",
    "@param": "label",
    "@return": "label",
    "@see": "label",
    "@since": "label",
    "@source": "label",
    "@static": "label",
    "@staticvar": "label",
    "@subpackage": "label",
    "@toc": "label",
    "@todo": "label",
    "@tutorial": "label",
    "@uses": "label",
    "@var": "label",
    "@version": "label",
}

# Dictionary of keywords dictionaries for php mode.
keywordsDictDict = {
    "php_javascript": php_javascript_keywords_dict,
    "php_javascript_php": php_javascript_php_keywords_dict,
    "php_main": php_main_keywords_dict,
    "php_php": php_php_keywords_dict,
    "php_php_literal": php_php_literal_keywords_dict,
    "php_phpdoc": php_phpdoc_keywords_dict,
    "php_tags": php_tags_keywords_dict,
    "php_tags_literal": php_tags_literal_keywords_dict,
}

# Rules for php_main ruleset.

</t>
<t tx="ekr.20201022055738.10">def php_rule8(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.11">def php_rule9(colorer, s, i):
    return colorer.match_span(s, i, kind="literal2", begin="&amp;", end=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=True)

# Rules dict for php_main ruleset.
rulesDict1 = {
    "&amp;": [php_rule9,],
    "&lt;": [php_rule0,php_rule1,php_rule2,php_rule3,php_rule5,php_rule6,php_rule7,php_rule8,],
    "&lt; ": [php_rule4,],
}

# Rules for php_tags ruleset.

</t>
<t tx="ekr.20201022055738.12">def php_rule10(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.13">def php_rule11(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.14">def php_rule12(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.15">def php_rule13(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.16">def php_rule14(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.17">def php_rule15(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

# Rules dict for php_tags ruleset.
rulesDict2 = {
    "\"": [php_rule13,],
    "'": [php_rule14,],
    "&lt;": [php_rule10,php_rule11,php_rule12,],
    "=": [php_rule15,],
}

# Rules for php_tags_literal ruleset.

</t>
<t tx="ekr.20201022055738.18">def php_rule16(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.19">def php_rule17(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.2">def php_rule0(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.20">def php_rule18(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

# Rules dict for php_tags_literal ruleset.
rulesDict3 = {
    "&lt;": [php_rule16,php_rule17,php_rule18,],
}

# Rules for php_php ruleset.

</t>
<t tx="ekr.20201022055738.21">def php_rule19(colorer, s, i):
    return colorer.match_span(s, i, kind="comment3", begin="/**", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::phpdoc",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.22">def php_rule20(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="/*", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.23">def php_rule21(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.24">def php_rule22(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.25">def php_rule23(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="`", end="`",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.26">def php_rule24(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment2", seq="//",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)

</t>
<t tx="ekr.20201022055738.27">def php_rule25(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="#",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)

</t>
<t tx="ekr.20201022055738.28">def php_rule26(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="literal1", begin="&lt;&lt;&lt;[[:space:]'\"]*([[:alnum:]_]+)[[:space:]'\"]*", end="$1",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.29">def php_rule27(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

</t>
<t tx="ekr.20201022055738.3">def php_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.30">def php_rule28(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.31">def php_rule29(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.32">def php_rule30(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="!",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.33">def php_rule31(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.34">def php_rule32(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.35">def php_rule33(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.36">def php_rule34(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="+",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.37">def php_rule35(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.38">def php_rule36(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.39">def php_rule37(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.4">def php_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.40">def php_rule38(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.41">def php_rule39(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.42">def php_rule40(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="%",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.43">def php_rule41(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&amp;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.44">def php_rule42(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="|",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.45">def php_rule43(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="^",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.46">def php_rule44(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="~",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.47">def php_rule45(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=".",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.48">def php_rule46(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="}",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.49">def php_rule47(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.5">def php_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.50">def php_rule48(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=",",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.51">def php_rule49(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.52">def php_rule50(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="]",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.53">def php_rule51(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="[",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.54">def php_rule52(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="?",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.55">def php_rule53(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="@",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.56">def php_rule54(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=":",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.57">def php_rule55(colorer, s, i):
    return colorer.match_mark_previous(s, i, kind="function", pattern="(",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

</t>
<t tx="ekr.20201022055738.58">def php_rule56(colorer, s, i):
    return colorer.match_keywords(s, i)

# Rules dict for php_php ruleset.
rulesDict4 = {
    "!": [php_rule30,],
    "\"": [php_rule21,],
    "#": [php_rule25,],
    "$": [php_rule27,],
    "%": [php_rule40,],
    "&amp;": [php_rule41,],
    "'": [php_rule22,],
    "(": [php_rule55,],
    "*": [php_rule37,],
    "+": [php_rule34,],
    ",": [php_rule48,],
    "-": [php_rule29,php_rule35,],
    ".": [php_rule45,],
    "/": [php_rule19,php_rule20,php_rule24,php_rule36,],
    "0": [php_rule56,],
    "1": [php_rule56,],
    "2": [php_rule56,],
    "3": [php_rule56,],
    "4": [php_rule56,],
    "5": [php_rule56,],
    "6": [php_rule56,],
    "7": [php_rule56,],
    "8": [php_rule56,],
    "9": [php_rule56,],
    ":": [php_rule54,],
    ";": [php_rule49,],
    "&lt;": [php_rule32,php_rule39,],
    "&lt; ": [php_rule26,],
    "=": [php_rule28,php_rule33,],
    "&gt;": [php_rule31,php_rule38,],
    "?": [php_rule52,],
    "@": [php_rule53,php_rule56,],
    "A": [php_rule56,],
    "B": [php_rule56,],
    "C": [php_rule56,],
    "D": [php_rule56,],
    "E": [php_rule56,],
    "F": [php_rule56,],
    "G": [php_rule56,],
    "H": [php_rule56,],
    "I": [php_rule56,],
    "J": [php_rule56,],
    "K": [php_rule56,],
    "L": [php_rule56,],
    "M": [php_rule56,],
    "N": [php_rule56,],
    "O": [php_rule56,],
    "P": [php_rule56,],
    "Q": [php_rule56,],
    "R": [php_rule56,],
    "S": [php_rule56,],
    "T": [php_rule56,],
    "U": [php_rule56,],
    "V": [php_rule56,],
    "W": [php_rule56,],
    "X": [php_rule56,],
    "Y": [php_rule56,],
    "Z": [php_rule56,],
    "[": [php_rule51,],
    "]": [php_rule50,],
    "^": [php_rule43,],
    "_": [php_rule56,],
    "`": [php_rule23,],
    "a": [php_rule56,],
    "b": [php_rule56,],
    "c": [php_rule56,],
    "d": [php_rule56,],
    "e": [php_rule56,],
    "f": [php_rule56,],
    "g": [php_rule56,],
    "h": [php_rule56,],
    "i": [php_rule56,],
    "j": [php_rule56,],
    "k": [php_rule56,],
    "l": [php_rule56,],
    "m": [php_rule56,],
    "n": [php_rule56,],
    "o": [php_rule56,],
    "p": [php_rule56,],
    "q": [php_rule56,],
    "r": [php_rule56,],
    "s": [php_rule56,],
    "t": [php_rule56,],
    "u": [php_rule56,],
    "v": [php_rule56,],
    "w": [php_rule56,],
    "x": [php_rule56,],
    "y": [php_rule56,],
    "z": [php_rule56,],
    "{": [php_rule47,],
    "|": [php_rule42,],
    "}": [php_rule46,],
    "~": [php_rule44,],
}

# Rules for php_php_literal ruleset.

</t>
<t tx="ekr.20201022055738.59">def php_rule57(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

# Rules dict for php_php_literal ruleset.
rulesDict5 = {
    "$": [php_rule57,],
}

# Rules for php_javascript ruleset.

</t>
<t tx="ekr.20201022055738.6">def php_rule4(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="markup", begin="&lt;SCRIPT\\s+LANGUAGE=\"?PHP\"?&gt;", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.60">def php_rule58(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::javascript+php")

</t>
<t tx="ekr.20201022055738.61">def php_rule59(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="SRC=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::back_to_html")

# Rules dict for php_javascript ruleset.
rulesDict6 = {
    "&gt;": [php_rule58,],
    "S": [php_rule59,],
}

# Rules for php_javascript_php ruleset.

</t>
<t tx="ekr.20201022055738.62">def php_rule60(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.63">def php_rule61(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.64">def php_rule62(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)


# Rules dict for php_javascript_php ruleset.
rulesDict7 = {
    "&lt;": [php_rule60,php_rule61,php_rule62,],
}

# Rules for php_phpdoc ruleset.

</t>
<t tx="ekr.20201022055738.65">def php_rule63(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.66">def php_rule64(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.67">def php_rule65(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.68">def php_rule66(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.69">def php_rule67(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.7">def php_rule5(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;SCRIPT", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::javascript",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.70">def php_rule68(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt; ",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.71">def php_rule69(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::tags",exclude_match=False,
        no_escape=False, no_line_break=True, no_word_break=False)

</t>
<t tx="ekr.20201022055738.72">def php_rule70(colorer, s, i):
    return colorer.match_keywords(s, i)

# Rules dict for php_phpdoc ruleset.
rulesDict8 = {
    "*": [php_rule64,],
    "0": [php_rule70,],
    "1": [php_rule70,],
    "2": [php_rule70,],
    "3": [php_rule70,],
    "4": [php_rule70,],
    "5": [php_rule70,],
    "6": [php_rule70,],
    "7": [php_rule70,],
    "8": [php_rule70,],
    "9": [php_rule70,],
    "&lt;": [php_rule65,php_rule66,php_rule67,php_rule68,php_rule69,],
    "@": [php_rule70,],
    "A": [php_rule70,],
    "B": [php_rule70,],
    "C": [php_rule70,],
    "D": [php_rule70,],
    "E": [php_rule70,],
    "F": [php_rule70,],
    "G": [php_rule70,],
    "H": [php_rule70,],
    "I": [php_rule70,],
    "J": [php_rule70,],
    "K": [php_rule70,],
    "L": [php_rule70,],
    "M": [php_rule70,],
    "N": [php_rule70,],
    "O": [php_rule70,],
    "P": [php_rule70,],
    "Q": [php_rule70,],
    "R": [php_rule70,],
    "S": [php_rule70,],
    "T": [php_rule70,],
    "U": [php_rule70,],
    "V": [php_rule70,],
    "W": [php_rule70,],
    "X": [php_rule70,],
    "Y": [php_rule70,],
    "Z": [php_rule70,],
    "_": [php_rule70,],
    "a": [php_rule70,],
    "b": [php_rule70,],
    "c": [php_rule70,],
    "d": [php_rule70,],
    "e": [php_rule70,],
    "f": [php_rule70,],
    "g": [php_rule70,],
    "h": [php_rule70,],
    "i": [php_rule70,],
    "j": [php_rule70,],
    "k": [php_rule70,],
    "l": [php_rule70,],
    "m": [php_rule70,],
    "n": [php_rule70,],
    "o": [php_rule70,],
    "p": [php_rule70,],
    "q": [php_rule70,],
    "r": [php_rule70,],
    "s": [php_rule70,],
    "t": [php_rule70,],
    "u": [php_rule70,],
    "v": [php_rule70,],
    "w": [php_rule70,],
    "x": [php_rule70,],
    "y": [php_rule70,],
    "z": [php_rule70,],
    "{": [php_rule63,],
}

# x.rulesDictDict for php mode.
rulesDictDict = {
    "php_javascript": rulesDict6,
    "php_javascript_php": rulesDict7,
    "php_main": rulesDict1,
    "php_php": rulesDict4,
    "php_php_literal": rulesDict5,
    "php_phpdoc": rulesDict8,
    "php_tags": rulesDict2,
    "php_tags_literal": rulesDict3,
}

# Import dict for php mode.
importDict = {
    "php_javascript_php": ["javascript::main",],
}

# EKR
</t>
<t tx="ekr.20201022055738.8">def php_rule6(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;STYLE", end="&lt;/STYLE&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="html::css",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.9">def php_rule7(colorer, s, i):
    return colorer.match_span(s, i, kind="keyword2", begin="&lt;!", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::dtd-tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201030052407.1">@nosearch

# flattened, ignore-case, regex, head, body

# found 243 nodes</t>
<t tx="ekr.20201030052707.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1720

@language python
</t>
<t tx="ekr.20201030053803.1"></t>
<t tx="ekr.20201030065903.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1721

@language python
@nosearch</t>
<t tx="ekr.20201030084949.1"></t>
<t tx="ekr.20201030085148.1">@nosearch

# flattened, word, ignore-case, head, body

 search: c\.setBodyString\((\w+)\s*,\s*(\w+)\)
replace: \1.b = \2

# found 17 nodes</t>
<t tx="ekr.20201030085515.1"></t>
<t tx="ekr.20201030095215.1">@g.command('show-all-tags')
def show_all_tags(event):
    """Simulate a control-click at the cursor."""
    c = event.get('c')
    if not c:
        return
    tc = c.theTagController
    if tc:
        tc.show_all_tags()
    else:
        print('nodetags plugin not enabled')
</t>
<t tx="ekr.20201030095446.1">def show_all_tags(self):
    """Show all tags, organized by node."""
    c, tc = self.c, self
    d = {}
    for p in c.all_unique_positions():
        u = p.v.u
        tags = set(u.get(tc.TAG_LIST_KEY, set([])))
        for tag in tags:
            aList = d.get(tag, [])
            aList.append(p.h)
            d [tag] = aList
    # Print all tags.
    for key in sorted(d):
        aList = d.get(key)
        for h in sorted(aList):
            print(f"{key:&gt;8} {h}")
 
</t>
<t tx="ekr.20201031083701.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1413

@language python
@nosearch
</t>
<t tx="ekr.20201107145642.1">def afterChangeHeadline(self, p, command, bunch):
    """Create an undo node using d created by beforeChangeHeadline."""
    u = self
    if u.redoing or u.undoing:
        return
    # Set the type &amp; helpers.
    bunch.kind = 'headline'
    bunch.undoType = command
    bunch.undoHelper = u.undoChangeHeadline
    bunch.redoHelper = u.redoChangeHeadline
    bunch.newHead = p.h
    u.pushBead(bunch)

afterChangeHead = afterChangeHeadline
</t>
<t tx="ekr.20201107145859.1">def beforeChangeHeadline(self, p):
    """
    Return data that gets passed to afterChangeNode.
    
    The oldHead kwarg works around a Qt difficulty when changing headlines.
    """
    u = self
    bunch = u.createCommonBunch(p)
    bunch.oldHead = p.h
    return bunch

beforeChangeHead = beforeChangeHeadline
</t>
<t tx="ekr.20201107150041.1">def undoChangeHeadline(self):
    """Undo a change to a node's headline."""
    c, u = self.c, self
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    c.frame.body.recolor(u.p)
    u.p.initHeadString(u.oldHead)
    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.oldHead)
</t>
<t tx="ekr.20201107150619.1">def redoChangeHeadline(self):
    c, u = self.c, self
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    c.frame.body.recolor(u.p)
    # Restore the headline.
    u.p.initHeadString(u.newHead)
    # This is required so.  Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.newHead)
</t>
<t tx="ekr.20201108061811.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1726

@language python
</t>
<t tx="ekr.20201108064325.1"></t>
<t tx="ekr.20201108064358.1">@language rest
@wrap

Use leo-c to test cursesGui2.
Use f to test flexx.

How the headline was reverted:
- Ctrl-I: New headline
- type abc
- *click* (not return) another node: the headline appears to stick.
- Double click abc node: the headline reverts to newHeadline
- Does *not* happen after Ctrl-h.

@language python
</t>
<t tx="ekr.20201108144604.1"># QAbstractItemModel::headerDataChanged(Qt::Orientation orientation, int first, int last)</t>
<t tx="ekr.20201109043641.1">def editingFinished_callback():
    """Called when Qt emits the editingFinished signal."""
    s = e.text()
    i = s.find('\n')
    # Truncate to one line.
    if i &gt; -1:
        s = s[:i]
    # #1310: update the tooltip.
    if p.h != s:
        # Update p.h and handle undo.
        item.setToolTip(0, s)
        undoData = u.beforeChangeHeadline(p)
        p.v.setHeadString(s)  # Set v.h *after* calling the undoer's before method.
        if not c.changed:
            c.setChanged()
        # We must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p)
        p.setDirty()
        u.afterChangeHeadline(p, 'Edit Headline', undoData)
    self.redraw_after_head_changed()
    c.outerUpdate()
</t>
<t tx="ekr.20201109074740.1">def beforeChangeBody(self, p):
    """Return data that gets passed to afterChangeBody."""
    w = self.c.frame.body.wrapper
    bunch = self.createCommonBunch(p)
        # Sets u.oldMarked, u.oldSel, u.p
    bunch.oldBody = p.b
    bunch.oldHead = p.h
    bunch.oldIns = w.getInsertPoint()
    bunch.oldYScroll = w.getYScrollPosition()
    return bunch
</t>
<t tx="ekr.20201109075104.1">def afterChangeBody(self, p, command, bunch):
    """
    Create an undo node using d created by beforeChangeNode.
    
    *Important*: Before calling this method, caller must:
    - Set p.v.b. (Setting p.b would cause a redraw).
    - Set the desired selection range and insert point.
    - Set the y-scroll position, if desired.
    """
    c = self.c
    u, w = self, c.frame.body.wrapper
    if u.redoing or u.undoing:
        return
    # Set the type &amp; helpers.
    bunch.kind = 'body'
    bunch.undoType = command
    bunch.undoHelper = u.undoChangeBody
    bunch.redoHelper = u.redoChangeBody
    bunch.newBody = p.b
    bunch.newHead = p.h
    bunch.newIns = w.getInsertPoint()
    bunch.newMarked = p.isMarked()
    # Careful: don't use ternary operator.
    if w:
        bunch.newSel = w.getSelectionRange()
    else:
        bunch.newSel = 0, 0
    bunch.newYScroll = w.getYScrollPosition() if w else 0
    u.pushBead(bunch)
    # 
    if g.unitTesting:
        assert command.lower() != 'typing', g.callers()
    elif command.lower() == 'typing':
        g.trace(
            'Error: undoType should not be "Typing"\n'
            'Call u.doTyping instead')
    u.updateAfterTyping(p, w)
</t>
<t tx="ekr.20201109080631.1">def undoChangeBody(self):
    """
    Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    """
    c, u, w = self.c, self, self.c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:
        c.selectPosition(u.p)
    u.p.setDirty()
    u.p.b = u.oldBody
    u.p.h = u.oldHead
    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.oldHead)
    if u.oldMarked:
        u.p.setMarked()
    else:
        u.p.clearMarked()
    if u.groupCount == 0:
        w.setAllText(u.oldBody)
        i, j = u.oldSel
        w.setSelectionRange(i, j, insert=u.oldIns)
        w.setYScrollPosition(u.oldYScroll)
        c.frame.body.recolor(u.p)
    u.updateMarks('old')
</t>
<t tx="ekr.20201109080732.1">def redoChangeBody(self):
    c, u, w = self.c, self, self.c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    u.p.b = u.newBody
    u.p.h = u.newHead
    # This is required so. Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.newHead)
    if u.newMarked:
        u.p.setMarked()
    else:
        u.p.clearMarked()
    if u.groupCount == 0:
        w.setAllText(u.newBody)
        i, j = u.newSel
        w.setSelectionRange(i, j, insert=u.newIns)
        w.setYScrollPosition(u.newYScroll)
        c.frame.body.recolor(u.p)
    u.updateMarks('new')
    u.p.setDirty()
</t>
<t tx="ekr.20201109082007.1"></t>
<t tx="ekr.20201109104158.1">@nosearch

# flattened, word, ignore-case, head, body

# found 21 nodes</t>
<t tx="ekr.20201109104329.1"> search: c\.setBodyString\((\w+)\s*,\s*(\w+)\)
replace: \1.b = \2
</t>
<t tx="ekr.20201109104353.1"> search: c\.setHeadString\((\w+)\s*,\s*(\w+)\)
replace: \1.h = \2
</t>
<t tx="ekr.20201109104837.1"></t>
<t tx="ekr.20201109105836.1"></t>
<t tx="ekr.20201109110403.1"></t>
<t tx="ekr.20201110015336.1">g.cls()
import os
import re
path = os.path.join(g.app.loadDir, '..', 'modes', 'php.py')
with open(path, 'r') as f:
    contents = f.read()
def_pat = r'^def\s*(php_rule[0-9]+)'
for line in g.splitLines(contents):
    m = re.match(def_pat, line)
    if m:
        print(m.group(1))</t>
<t tx="ekr.20201110092953.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1591

In ekr-1591 branch.

@language python
@nosearch
</t>
<t tx="ekr.20201110094832.1"></t>
<t tx="ekr.20201111052557.1">def patch_1591(self):
    """
    A workaround for #1591.
    
    Add labels and tooltips for all buttons.
    """
    # Patch the buttons only if the pyqt version is greater than 5.12.
    from leo.core.leoQt import isQt5, qt_version
    if not isQt5:
        return
    qt_version = [int(z) for z in qt_version.split('.')]
    if qt_version[1] &lt;= 12:
        return
    ui = self.ui.UI
    # Add text and tooltips to all numeric priority buttons.
    for i in range(10):
        button = getattr(ui, f"butPri{i}")
        button.setText(f"{i}")
        button.setToolTip(f"Priority {i}")
    # Add text and tooltips to other buttons...
    table = (
        # Alternate priorities...
        ('butPriChk', 'Check', 'Check Mark'),
        ('butPriToDo', 'Box', 'Box Mark'),
        ('butPriX', 'X', 'Black X'),
        ('butPriXgry', 'X', 'Gray X'),
        ('butPriBang', '!', 'Exclamation Point'),
        ('butPriQuery', '?', 'Question Mark'),
        ('butPriBullet', '', 'Bullet'),
        ('butPriClr', 'Clear', 'Clear Priority'),
        # Other labels...
        ('butDetails', 'Details', 'Toggle Details'),
        ('butNext', 'Next Node', 'Next Node'),
        ('butNextTodo', 'Next Todo', 'Next To Do'),
        ('butClrTime', 'Clear Time', 'Clear Required Time'),
        ('butClrProg', 'Clear Progress', 'Clear Progress')
    )
    for attr, text, tooltip in table:
        button = getattr(ui, attr)
        button.setText(text)
        button.setToolTip(tooltip)
        
        
</t>
<t tx="ekr.20201111182127.1">indent-region       !text = Tab
newline-and-indent  = Ctrl-j
focus-to-body       !tree = Tab
unindent-region     = ctrl-less # Ctrl-Shift-&lt;
unindent-region     = Shift-tab</t>
<t tx="ekr.20201112060726.1">@language rest
@wrap

Issue: https://github.com/leo-editor/leo-editor/issues/1731
PR: https://github.com/leo-editor/leo-editor/pull/1732

in ekr-tabs branch.

@language python
@nosearch
</t>
<t tx="ekr.20201112095019.1"></t>
<t tx="ekr.20201113190926.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1734

@language python
@nosearch
</t>
<t tx="ekr.20201114110737.1">def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    """
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    
    Return the value returned by the command, or None if no command is executed.
    """
    c, k = self.c, self
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke  # Set this global for general use.
    ch = event.char if event else ''
    #
    # Ignore all special keys.
    if k.isSpecialKey(event):
        return None
    #
    # Compute func if not given.
    # It is *not* an error for func to be None.
    if commandName and not func:
        func = c.commandsDict.get(commandName.replace('&amp;', ''))
        if not func:
            g.es_print(f"no command for @item {commandName!r}", color='red')
            return None
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    if 'keys' in g.app.debug:
        # A very important trace.
        g.trace(commandName, 'stroke', stroke)
    #
    # Remember the key.
    k.setLossage(ch, stroke)
    #
    # Handle keyboard-quit.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        k.keyboardQuit()
        return None
    #
    # Ignore abbreviations.
    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, stroke):
        return None
    #
    # Invoke the command, if given.
    if func:
        return_value = c.doCommand(func, commandName, event=event)
        if c.exists:
            c.frame.updateStatusLine()
        return return_value
    #
    # Ignore unbound keys in a state.
    if k.inState():
        return None
    #
    # Finally, call k.handleDefaultChar.
    k.handleDefaultChar(event, stroke)
    if c.exists:
        c.frame.updateStatusLine()
    return None
</t>
<t tx="ekr.20201114160816.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032302d31312d31307103752e">**Move More.  Focus on balance in my life..**

Post: Transcrypt is very cool :-)

rrhandwovens:
- Create products using csv.
- Add new products.

Promises:
- Complete values in Phil's portrait.
- Keep Rebecca's web site up to date each day.
- Exercise/stretch each day.

@language rest
@wrap
@nosearch</t>
<t tx="ekr.20201114160816.10">+-- node-inspect@2.0.0</t>
<t tx="ekr.20201114160816.11">+-- npm@6.14.8
| +-- abbrev@1.1.1
| +-- ansicolors@0.3.2
| +-- ansistyles@0.1.3
| +-- aproba@2.0.0
| +-- archy@1.0.0
| +-- bin-links@1.1.8
| | +-- bluebird@3.5.5 deduped
| | +-- cmd-shim@3.0.3 deduped
| | +-- gentle-fs@2.3.1 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- npm-normalize-package-bin@1.0.1
| | `-- write-file-atomic@2.4.3 deduped
| +-- bluebird@3.5.5
| +-- byte-size@5.0.1
| +-- cacache@12.0.3
| | +-- bluebird@3.5.5 deduped
| | +-- chownr@1.1.4 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- glob@7.1.6 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- infer-owner@1.0.4 deduped
| | +-- lru-cache@5.1.1 deduped
| | +-- mississippi@3.0.0 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- move-concurrently@1.0.1 deduped
| | +-- promise-inflight@1.0.1 deduped
| | +-- rimraf@2.7.1 deduped
| | +-- ssri@6.0.1 deduped
| | +-- unique-filename@1.1.1 deduped
| | `-- y18n@4.0.0
| +-- call-limit@1.1.1
| +-- chownr@1.1.4
| +-- ci-info@2.0.0
| +-- cli-columns@3.1.2
| | +-- string-width@2.1.1
| | | +-- is-fullwidth-code-point@2.0.0
| | | `-- strip-ansi@4.0.0
| | |   `-- ansi-regex@3.0.0
| | `-- strip-ansi@3.0.1
| |   `-- ansi-regex@2.1.1
| +-- cli-table3@0.5.1
| | +-- colors@1.3.3
| | +-- object-assign@4.1.1
| | `-- string-width@2.1.1 deduped
| +-- cmd-shim@3.0.3
| | +-- graceful-fs@4.2.4 deduped
| | `-- mkdirp@0.5.5 deduped
| +-- columnify@1.5.4
| | +-- strip-ansi@3.0.1 deduped
| | `-- wcwidth@1.0.1
| |   `-- defaults@1.0.3
| |     `-- clone@1.0.4
| +-- config-chain@1.1.12
| | +-- ini@1.3.5 deduped
| | `-- proto-list@1.2.4
| +-- debuglog@1.0.1
| +-- detect-indent@5.0.0
| +-- detect-newline@2.1.0
| +-- dezalgo@1.0.3
| | +-- asap@2.0.6
| | `-- wrappy@1.0.2
| +-- editor@1.0.0
| +-- figgy-pudding@3.5.1
| +-- find-npm-prefix@1.0.2
| +-- fs-vacuum@1.2.10
| | +-- graceful-fs@4.2.4 deduped
| | +-- path-is-inside@1.0.2 deduped
| | `-- rimraf@2.7.1 deduped
| +-- fs-write-stream-atomic@1.0.10
| | +-- graceful-fs@4.2.4 deduped
| | +-- iferr@0.1.5
| | +-- imurmurhash@0.1.4 deduped
| | `-- readable-stream@2.3.6
| |   +-- core-util-is@1.0.2
| |   +-- inherits@2.0.4 deduped
| |   +-- isarray@1.0.0
| |   +-- process-nextick-args@2.0.0
| |   +-- safe-buffer@5.1.2 deduped
| |   +-- string_decoder@1.1.1
| |   | `-- safe-buffer@5.1.2 deduped
| |   `-- util-deprecate@1.0.2 deduped
| +-- gentle-fs@2.3.1
| | +-- aproba@1.2.0
| | +-- chownr@1.1.4 deduped
| | +-- cmd-shim@3.0.3 deduped
| | +-- fs-vacuum@1.2.10 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- iferr@0.1.5
| | +-- infer-owner@1.0.4 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- path-is-inside@1.0.2 deduped
| | +-- read-cmd-shim@1.0.5 deduped
| | `-- slide@1.1.6 deduped
| +-- glob@7.1.6
| | +-- fs.realpath@1.0.0
| | +-- inflight@1.0.6 deduped
| | +-- inherits@2.0.4 deduped
| | +-- minimatch@3.0.4
| | | `-- brace-expansion@1.1.11
| | |   +-- balanced-match@1.0.0
| | |   `-- concat-map@0.0.1
| | +-- once@1.4.0 deduped
| | `-- path-is-absolute@1.0.1
| +-- graceful-fs@4.2.4
| +-- has-unicode@2.0.1
| +-- hosted-git-info@2.8.8
| +-- iferr@1.0.2
| +-- imurmurhash@0.1.4
| +-- infer-owner@1.0.4
| +-- inflight@1.0.6
| | +-- once@1.4.0 deduped
| | `-- wrappy@1.0.2 deduped
| +-- inherits@2.0.4
| +-- ini@1.3.5
| +-- init-package-json@1.10.3
| | +-- glob@7.1.6 deduped
| | +-- npm-package-arg@6.1.1 deduped
| | +-- promzard@0.3.0
| | | `-- read@1.0.7 deduped
| | +-- read@1.0.7 deduped
| | +-- read-package-json@2.1.1 deduped
| | +-- semver@5.7.1 deduped
| | +-- validate-npm-package-license@3.0.4 deduped
| | `-- validate-npm-package-name@3.0.0 deduped
| +-- is-cidr@3.0.0
| | `-- cidr-regex@2.0.10
| |   `-- ip-regex@2.1.0
| +-- json-parse-better-errors@1.0.2
| +-- JSONStream@1.3.5
| | +-- jsonparse@1.3.1
| | `-- through@2.3.8
| +-- lazy-property@1.0.0
| +-- libcipm@4.0.8
| | +-- bin-links@1.1.8 deduped
| | +-- bluebird@3.5.5 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- find-npm-prefix@1.0.2 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- ini@1.3.5 deduped
| | +-- lock-verify@2.1.0 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- npm-lifecycle@3.1.5 deduped
| | +-- npm-logical-tree@1.2.1
| | +-- npm-package-arg@6.1.1 deduped
| | +-- pacote@9.5.12 deduped
| | +-- read-package-json@2.1.1 deduped
| | +-- rimraf@2.7.1 deduped
| | `-- worker-farm@1.7.0 deduped
| +-- libnpm@3.0.1
| | +-- bin-links@1.1.8 deduped
| | +-- bluebird@3.5.5 deduped
| | +-- find-npm-prefix@1.0.2 deduped
| | +-- libnpmaccess@3.0.2 deduped
| | +-- libnpmconfig@1.2.1
| | | +-- figgy-pudding@3.5.1 deduped
| | | +-- find-up@3.0.0
| | | | `-- locate-path@3.0.0
| | | |   +-- p-locate@3.0.0
| | | |   | `-- p-limit@2.2.0
| | | |   |   `-- p-try@2.2.0
| | | |   `-- path-exists@3.0.0
| | | `-- ini@1.3.5 deduped
| | +-- libnpmhook@5.0.3 deduped
| | +-- libnpmorg@1.0.1 deduped
| | +-- libnpmpublish@1.1.2
| | | +-- aproba@2.0.0 deduped
| | | +-- figgy-pudding@3.5.1 deduped
| | | +-- get-stream@4.1.0 deduped
| | | +-- lodash.clonedeep@4.5.0 deduped
| | | +-- normalize-package-data@2.5.0 deduped
| | | +-- npm-package-arg@6.1.1 deduped
| | | +-- npm-registry-fetch@4.0.7 deduped
| | | +-- semver@5.7.1 deduped
| | | `-- ssri@6.0.1 deduped
| | +-- libnpmsearch@2.0.2 deduped
| | +-- libnpmteam@1.0.2 deduped
| | +-- lock-verify@2.1.0 deduped
| | +-- npm-lifecycle@3.1.5 deduped
| | +-- npm-logical-tree@1.2.1 deduped
| | +-- npm-package-arg@6.1.1 deduped
| | +-- npm-profile@4.0.4 deduped
| | +-- npm-registry-fetch@4.0.7 deduped
| | +-- npmlog@4.1.2 deduped
| | +-- pacote@9.5.12 deduped
| | +-- read-package-json@2.1.1 deduped
| | `-- stringify-package@1.0.1 deduped
| +-- libnpmaccess@3.0.2
| | +-- aproba@2.0.0 deduped
| | +-- get-stream@4.1.0
| | | `-- pump@3.0.0 deduped
| | +-- npm-package-arg@6.1.1 deduped
| | `-- npm-registry-fetch@4.0.7 deduped
| +-- libnpmhook@5.0.3
| | +-- aproba@2.0.0 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- get-stream@4.1.0 deduped
| | `-- npm-registry-fetch@4.0.7 deduped
| +-- libnpmorg@1.0.1
| | +-- aproba@2.0.0 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- get-stream@4.1.0 deduped
| | `-- npm-registry-fetch@4.0.7 deduped
| +-- libnpmsearch@2.0.2
| | +-- figgy-pudding@3.5.1 deduped
| | +-- get-stream@4.1.0 deduped
| | `-- npm-registry-fetch@4.0.7 deduped
| +-- libnpmteam@1.0.2
| | +-- aproba@2.0.0 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- get-stream@4.1.0 deduped
| | `-- npm-registry-fetch@4.0.7 deduped
| +-- libnpx@10.2.4
| | +-- dotenv@5.0.1
| | +-- npm-package-arg@6.1.1 deduped
| | +-- rimraf@2.7.1 deduped
| | +-- safe-buffer@5.1.2 deduped
| | +-- update-notifier@2.5.0 deduped
| | +-- which@1.3.1 deduped
| | +-- y18n@4.0.0 deduped
| | `-- yargs@14.2.3
| |   +-- cliui@5.0.0
| |   | +-- string-width@3.1.0
| |   | | +-- emoji-regex@7.0.3 deduped
| |   | | +-- is-fullwidth-code-point@2.0.0
| |   | | `-- strip-ansi@5.2.0 deduped
| |   | +-- strip-ansi@5.2.0
| |   | | `-- ansi-regex@4.1.0
| |   | `-- wrap-ansi@5.1.0
| |   |   +-- ansi-styles@3.2.1 deduped
| |   |   +-- string-width@3.1.0
| |   |   | +-- emoji-regex@7.0.3 deduped
| |   |   | +-- is-fullwidth-code-point@2.0.0
| |   |   | `-- strip-ansi@5.2.0 deduped
| |   |   `-- strip-ansi@5.2.0
| |   |     `-- ansi-regex@4.1.0
| |   +-- decamelize@1.2.0
| |   +-- find-up@3.0.0
| |   | `-- locate-path@3.0.0
| |   |   +-- p-locate@3.0.0
| |   |   | `-- p-limit@2.3.0
| |   |   |   `-- p-try@2.2.0
| |   |   `-- path-exists@3.0.0 deduped
| |   +-- get-caller-file@2.0.5
| |   +-- require-directory@2.1.1
| |   +-- require-main-filename@2.0.0
| |   +-- set-blocking@2.0.0 deduped
| |   +-- string-width@3.1.0
| |   | +-- emoji-regex@7.0.3
| |   | +-- is-fullwidth-code-point@2.0.0
| |   | `-- strip-ansi@5.2.0
| |   |   `-- ansi-regex@4.1.0
| |   +-- which-module@2.0.0
| |   +-- y18n@4.0.0 deduped
| |   `-- yargs-parser@15.0.1
| |     +-- camelcase@5.3.1
| |     `-- decamelize@1.2.0 deduped
| +-- lock-verify@2.1.0
| | +-- npm-package-arg@6.1.1 deduped
| | `-- semver@5.7.1 deduped
| +-- lockfile@1.0.4
| | `-- signal-exit@3.0.2
| +-- lodash._baseindexof@3.1.0
| +-- lodash._baseuniq@4.6.0
| | +-- lodash._createset@4.0.3
| | `-- lodash._root@3.0.1
| +-- lodash._bindcallback@3.0.1
| +-- lodash._cacheindexof@3.0.2
| +-- lodash._createcache@3.1.2
| | `-- lodash._getnative@3.9.1 deduped
| +-- lodash._getnative@3.9.1
| +-- lodash.clonedeep@4.5.0
| +-- lodash.restparam@3.6.1
| +-- lodash.union@4.6.0
| +-- lodash.uniq@4.5.0
| +-- lodash.without@4.4.0
| +-- lru-cache@5.1.1
| | `-- yallist@3.0.3
| +-- meant@1.0.2
| +-- mississippi@3.0.0
| | +-- concat-stream@1.6.2
| | | +-- buffer-from@1.0.0
| | | +-- inherits@2.0.4 deduped
| | | +-- readable-stream@2.3.6
| | | | +-- core-util-is@1.0.2 deduped
| | | | +-- inherits@2.0.4 deduped
| | | | +-- isarray@1.0.0 deduped
| | | | +-- process-nextick-args@2.0.0 deduped
| | | | +-- safe-buffer@5.1.2 deduped
| | | | +-- string_decoder@1.1.1
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | `-- util-deprecate@1.0.2 deduped
| | | `-- typedarray@0.0.6
| | +-- duplexify@3.6.0
| | | +-- end-of-stream@1.4.1 deduped
| | | +-- inherits@2.0.4 deduped
| | | +-- readable-stream@2.3.6
| | | | +-- core-util-is@1.0.2 deduped
| | | | +-- inherits@2.0.4 deduped
| | | | +-- isarray@1.0.0 deduped
| | | | +-- process-nextick-args@2.0.0 deduped
| | | | +-- safe-buffer@5.1.2 deduped
| | | | +-- string_decoder@1.1.1
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | `-- util-deprecate@1.0.2 deduped
| | | `-- stream-shift@1.0.0
| | +-- end-of-stream@1.4.1
| | | `-- once@1.4.0 deduped
| | +-- flush-write-stream@1.0.3
| | | +-- inherits@2.0.4 deduped
| | | `-- readable-stream@2.3.6
| | |   +-- core-util-is@1.0.2 deduped
| | |   +-- inherits@2.0.4 deduped
| | |   +-- isarray@1.0.0 deduped
| | |   +-- process-nextick-args@2.0.0 deduped
| | |   +-- safe-buffer@5.1.2 deduped
| | |   +-- string_decoder@1.1.1
| | |   | `-- safe-buffer@5.1.2 deduped
| | |   `-- util-deprecate@1.0.2 deduped
| | +-- from2@2.3.0
| | | +-- inherits@2.0.4 deduped
| | | `-- readable-stream@2.3.6
| | |   +-- core-util-is@1.0.2 deduped
| | |   +-- inherits@2.0.4 deduped
| | |   +-- isarray@1.0.0 deduped
| | |   +-- process-nextick-args@2.0.0 deduped
| | |   +-- safe-buffer@5.1.2 deduped
| | |   +-- string_decoder@1.1.1
| | |   | `-- safe-buffer@5.1.2 deduped
| | |   `-- util-deprecate@1.0.2 deduped
| | +-- parallel-transform@1.1.0
| | | +-- cyclist@0.2.2
| | | +-- inherits@2.0.4 deduped
| | | `-- readable-stream@2.3.6
| | |   +-- core-util-is@1.0.2 deduped
| | |   +-- inherits@2.0.4 deduped
| | |   +-- isarray@1.0.0 deduped
| | |   +-- process-nextick-args@2.0.0 deduped
| | |   +-- safe-buffer@5.1.2 deduped
| | |   +-- string_decoder@1.1.1
| | |   | `-- safe-buffer@5.1.2 deduped
| | |   `-- util-deprecate@1.0.2 deduped
| | +-- pump@3.0.0
| | | +-- end-of-stream@1.4.1 deduped
| | | `-- once@1.4.0 deduped
| | +-- pumpify@1.5.1
| | | +-- duplexify@3.6.0 deduped
| | | +-- inherits@2.0.4 deduped
| | | `-- pump@2.0.1
| | |   +-- end-of-stream@1.4.1 deduped
| | |   `-- once@1.4.0 deduped
| | +-- stream-each@1.2.2
| | | +-- end-of-stream@1.4.1 deduped
| | | `-- stream-shift@1.0.0 deduped
| | `-- through2@2.0.3
| |   +-- readable-stream@2.3.6
| |   | +-- core-util-is@1.0.2 deduped
| |   | +-- inherits@2.0.4 deduped
| |   | +-- isarray@1.0.0 deduped
| |   | +-- process-nextick-args@2.0.0 deduped
| |   | +-- safe-buffer@5.1.2 deduped
| |   | +-- string_decoder@1.1.1
| |   | | `-- safe-buffer@5.1.2 deduped
| |   | `-- util-deprecate@1.0.2 deduped
| |   `-- xtend@4.0.1
| +-- mkdirp@0.5.5
| | `-- minimist@1.2.5
| +-- move-concurrently@1.0.1
| | +-- aproba@1.2.0
| | +-- copy-concurrently@1.0.5
| | | +-- aproba@1.2.0
| | | +-- fs-write-stream-atomic@1.0.10 deduped
| | | +-- iferr@0.1.5
| | | +-- mkdirp@0.5.5 deduped
| | | +-- rimraf@2.7.1 deduped
| | | `-- run-queue@1.0.3 deduped
| | +-- fs-write-stream-atomic@1.0.10 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- rimraf@2.7.1 deduped
| | `-- run-queue@1.0.3
| |   `-- aproba@1.2.0
| +-- node-gyp@5.1.0
| | +-- env-paths@2.2.0
| | +-- glob@7.1.6 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- nopt@4.0.3 deduped
| | +-- npmlog@4.1.2 deduped
| | +-- request@2.88.0 deduped
| | +-- rimraf@2.7.1 deduped
| | +-- semver@5.7.1 deduped
| | +-- tar@4.4.13 deduped
| | `-- which@1.3.1 deduped
| +-- nopt@4.0.3
| | +-- abbrev@1.1.1 deduped
| | `-- osenv@0.1.5 deduped
| +-- normalize-package-data@2.5.0
| | +-- hosted-git-info@2.8.8 deduped
| | +-- resolve@1.10.0
| | | `-- path-parse@1.0.6
| | +-- semver@5.7.1 deduped
| | `-- validate-npm-package-license@3.0.4 deduped
| +-- npm-audit-report@1.3.3
| | +-- cli-table3@0.5.1 deduped
| | `-- console-control-strings@1.1.0
| +-- npm-cache-filename@1.0.2
| +-- npm-install-checks@3.0.2
| | `-- semver@5.7.1 deduped
| +-- npm-lifecycle@3.1.5
| | +-- byline@5.0.0
| | +-- graceful-fs@4.2.4 deduped
| | +-- node-gyp@5.1.0 deduped
| | +-- resolve-from@4.0.0
| | +-- slide@1.1.6 deduped
| | +-- uid-number@0.0.6 deduped
| | +-- umask@1.1.0 deduped
| | `-- which@1.3.1 deduped
| +-- npm-package-arg@6.1.1
| | +-- hosted-git-info@2.8.8 deduped
| | +-- osenv@0.1.5 deduped
| | +-- semver@5.7.1 deduped
| | `-- validate-npm-package-name@3.0.0 deduped
| +-- npm-packlist@1.4.8
| | +-- ignore-walk@3.0.3
| | | `-- minimatch@3.0.4 deduped
| | +-- npm-bundled@1.1.1
| | | `-- npm-normalize-package-bin@1.0.1 deduped
| | `-- npm-normalize-package-bin@1.0.1 deduped
| +-- npm-pick-manifest@3.0.2
| | +-- figgy-pudding@3.5.1 deduped
| | +-- npm-package-arg@6.1.1 deduped
| | `-- semver@5.7.1 deduped
| +-- npm-profile@4.0.4
| | +-- aproba@2.0.0 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | `-- npm-registry-fetch@4.0.7 deduped
| +-- npm-registry-fetch@4.0.7
| | +-- bluebird@3.5.5 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- JSONStream@1.3.5 deduped
| | +-- lru-cache@5.1.1 deduped
| | +-- make-fetch-happen@5.0.2
| | | +-- agentkeepalive@3.5.2
| | | | `-- humanize-ms@1.2.1
| | | |   `-- ms@2.1.1
| | | +-- cacache@12.0.3 deduped
| | | +-- http-cache-semantics@3.8.1
| | | +-- http-proxy-agent@2.1.0
| | | | +-- agent-base@4.3.0
| | | | | `-- es6-promisify@5.0.0
| | | | |   `-- es6-promise@4.2.8
| | | | `-- debug@3.1.0
| | | |   `-- ms@2.0.0
| | | +-- https-proxy-agent@2.2.4
| | | | +-- agent-base@4.3.0 deduped
| | | | `-- debug@3.1.0 deduped
| | | +-- lru-cache@5.1.1 deduped
| | | +-- mississippi@3.0.0 deduped
| | | +-- node-fetch-npm@2.0.2
| | | | +-- encoding@0.1.12
| | | | | `-- iconv-lite@0.4.23
| | | | |   `-- safer-buffer@2.1.2 deduped
| | | | +-- json-parse-better-errors@1.0.2 deduped
| | | | `-- safe-buffer@5.1.2 deduped
| | | +-- promise-retry@1.1.1 deduped
| | | +-- socks-proxy-agent@4.0.2
| | | | +-- agent-base@4.2.1
| | | | | `-- es6-promisify@5.0.0 deduped
| | | | `-- socks@2.3.3
| | | |   +-- ip@1.1.5
| | | |   `-- smart-buffer@4.1.0
| | | `-- ssri@6.0.1 deduped
| | +-- npm-package-arg@6.1.1 deduped
| | `-- safe-buffer@5.2.1
| +-- npm-user-validate@1.0.0
| +-- npmlog@4.1.2
| | +-- are-we-there-yet@1.1.4
| | | +-- delegates@1.0.0
| | | `-- readable-stream@2.3.6
| | |   +-- core-util-is@1.0.2 deduped
| | |   +-- inherits@2.0.4 deduped
| | |   +-- isarray@1.0.0 deduped
| | |   +-- process-nextick-args@2.0.0 deduped
| | |   +-- safe-buffer@5.1.2 deduped
| | |   +-- string_decoder@1.1.1
| | |   | `-- safe-buffer@5.1.2 deduped
| | |   `-- util-deprecate@1.0.2 deduped
| | +-- console-control-strings@1.1.0 deduped
| | +-- gauge@2.7.4
| | | +-- aproba@1.2.0
| | | +-- console-control-strings@1.1.0 deduped
| | | +-- has-unicode@2.0.1 deduped
| | | +-- object-assign@4.1.1 deduped
| | | +-- signal-exit@3.0.2 deduped
| | | +-- string-width@1.0.2
| | | | +-- code-point-at@1.1.0
| | | | +-- is-fullwidth-code-point@1.0.0
| | | | | `-- number-is-nan@1.0.1
| | | | `-- strip-ansi@3.0.1 deduped
| | | +-- strip-ansi@3.0.1 deduped
| | | `-- wide-align@1.1.2
| | |   `-- string-width@1.0.2
| | |     +-- code-point-at@1.1.0 deduped
| | |     +-- is-fullwidth-code-point@1.0.0 deduped
| | |     `-- strip-ansi@3.0.1 deduped
| | `-- set-blocking@2.0.0
| +-- once@1.4.0
| | `-- wrappy@1.0.2 deduped
| +-- opener@1.5.1
| +-- osenv@0.1.5
| | +-- os-homedir@1.0.2
| | `-- os-tmpdir@1.0.2
| +-- pacote@9.5.12
| | +-- bluebird@3.5.5 deduped
| | +-- cacache@12.0.3 deduped
| | +-- chownr@1.1.4 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- get-stream@4.1.0 deduped
| | +-- glob@7.1.6 deduped
| | +-- infer-owner@1.0.4 deduped
| | +-- lru-cache@5.1.1 deduped
| | +-- make-fetch-happen@5.0.2 deduped
| | +-- minimatch@3.0.4 deduped
| | +-- minipass@2.9.0
| | | +-- safe-buffer@5.1.2 deduped
| | | `-- yallist@3.0.3 deduped
| | +-- mississippi@3.0.0 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- normalize-package-data@2.5.0 deduped
| | +-- npm-normalize-package-bin@1.0.1 deduped
| | +-- npm-package-arg@6.1.1 deduped
| | +-- npm-packlist@1.4.8 deduped
| | +-- npm-pick-manifest@3.0.2 deduped
| | +-- npm-registry-fetch@4.0.7 deduped
| | +-- osenv@0.1.5 deduped
| | +-- promise-inflight@1.0.1 deduped
| | +-- promise-retry@1.1.1
| | | +-- err-code@1.1.2
| | | `-- retry@0.10.1
| | +-- protoduck@5.0.1
| | | `-- genfun@5.0.0
| | +-- rimraf@2.7.1 deduped
| | +-- safe-buffer@5.1.2 deduped
| | +-- semver@5.7.1 deduped
| | +-- ssri@6.0.1 deduped
| | +-- tar@4.4.13 deduped
| | +-- unique-filename@1.1.1 deduped
| | `-- which@1.3.1 deduped
| +-- path-is-inside@1.0.2
| +-- promise-inflight@1.0.1
| +-- qrcode-terminal@0.12.0
| +-- query-string@6.8.2
| | +-- decode-uri-component@0.2.0
| | +-- split-on-first@1.1.0
| | `-- strict-uri-encode@2.0.0
| +-- qw@1.0.1
| +-- read@1.0.7
| | `-- mute-stream@0.0.7
| +-- read-cmd-shim@1.0.5
| | `-- graceful-fs@4.2.4 deduped
| +-- read-installed@4.0.3
| | +-- debuglog@1.0.1 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- read-package-json@2.1.1 deduped
| | +-- readdir-scoped-modules@1.1.0 deduped
| | +-- semver@5.7.1 deduped
| | +-- slide@1.1.6 deduped
| | `-- util-extend@1.0.3
| +-- read-package-json@2.1.1
| | +-- glob@7.1.6 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- json-parse-better-errors@1.0.2 deduped
| | +-- normalize-package-data@2.5.0 deduped
| | `-- npm-normalize-package-bin@1.0.1 deduped
| +-- read-package-tree@5.3.1
| | +-- read-package-json@2.1.1 deduped
| | +-- readdir-scoped-modules@1.1.0 deduped
| | `-- util-promisify@2.1.0
| |   `-- object.getownpropertydescriptors@2.0.3
| |     +-- define-properties@1.1.3
| |     | `-- object-keys@1.0.12
| |     `-- es-abstract@1.12.0
| |       +-- es-to-primitive@1.2.0
| |       | +-- is-callable@1.1.4 deduped
| |       | +-- is-date-object@1.0.1
| |       | `-- is-symbol@1.0.2
| |       |   `-- has-symbols@1.0.0
| |       +-- function-bind@1.1.1
| |       +-- has@1.0.3
| |       | `-- function-bind@1.1.1 deduped
| |       +-- is-callable@1.1.4
| |       `-- is-regex@1.0.4
| |         `-- has@1.0.3 deduped
| +-- readable-stream@3.6.0
| | +-- inherits@2.0.4 deduped
| | +-- string_decoder@1.3.0
| | | `-- safe-buffer@5.2.0
| | `-- util-deprecate@1.0.2
| +-- readdir-scoped-modules@1.1.0
| | +-- debuglog@1.0.1 deduped
| | +-- dezalgo@1.0.3 deduped
| | +-- graceful-fs@4.2.4 deduped
| | `-- once@1.4.0 deduped
| +-- request@2.88.0
| | +-- aws-sign2@0.7.0
| | +-- aws4@1.8.0
| | +-- caseless@0.12.0
| | +-- combined-stream@1.0.6
| | | `-- delayed-stream@1.0.0
| | +-- extend@3.0.2
| | +-- forever-agent@0.6.1
| | +-- form-data@2.3.2
| | | +-- asynckit@0.4.0
| | | +-- combined-stream@1.0.6 deduped
| | | `-- mime-types@2.1.19 deduped
| | +-- har-validator@5.1.0
| | | +-- ajv@5.5.2
| | | | +-- co@4.6.0
| | | | +-- fast-deep-equal@1.1.0
| | | | +-- fast-json-stable-stringify@2.0.0
| | | | `-- json-schema-traverse@0.3.1
| | | `-- har-schema@2.0.0
| | +-- http-signature@1.2.0
| | | +-- assert-plus@1.0.0
| | | +-- jsprim@1.4.1
| | | | +-- assert-plus@1.0.0 deduped
| | | | +-- extsprintf@1.3.0
| | | | +-- json-schema@0.2.3
| | | | `-- verror@1.10.0
| | | |   +-- assert-plus@1.0.0 deduped
| | | |   +-- core-util-is@1.0.2 deduped
| | | |   `-- extsprintf@1.3.0 deduped
| | | `-- sshpk@1.14.2
| | |   +-- asn1@0.2.4
| | |   | `-- safer-buffer@2.1.2 deduped
| | |   +-- assert-plus@1.0.0 deduped
| | |   +-- bcrypt-pbkdf@1.0.2
| | |   | `-- tweetnacl@0.14.5 deduped
| | |   +-- dashdash@1.14.1
| | |   | `-- assert-plus@1.0.0 deduped
| | |   +-- ecc-jsbn@0.1.2
| | |   | +-- jsbn@0.1.1 deduped
| | |   | `-- safer-buffer@2.1.2 deduped
| | |   +-- getpass@0.1.7
| | |   | `-- assert-plus@1.0.0 deduped
| | |   +-- jsbn@0.1.1
| | |   +-- safer-buffer@2.1.2
| | |   `-- tweetnacl@0.14.5
| | +-- is-typedarray@1.0.0
| | +-- isstream@0.1.2
| | +-- json-stringify-safe@5.0.1
| | +-- mime-types@2.1.19
| | | `-- mime-db@1.35.0
| | +-- oauth-sign@0.9.0
| | +-- performance-now@2.1.0
| | +-- qs@6.5.2
| | +-- safe-buffer@5.1.2 deduped
| | +-- tough-cookie@2.4.3
| | | +-- psl@1.1.29
| | | `-- punycode@1.4.1
| | +-- tunnel-agent@0.6.0
| | | `-- safe-buffer@5.1.2 deduped
| | `-- uuid@3.3.3 deduped
| +-- retry@0.12.0
| +-- rimraf@2.7.1
| | `-- glob@7.1.6 deduped
| +-- safe-buffer@5.1.2
| +-- semver@5.7.1
| +-- sha@3.0.0
| | `-- graceful-fs@4.2.4 deduped
| +-- slide@1.1.6
| +-- sorted-object@2.0.1
| +-- sorted-union-stream@2.1.3
| | +-- from2@1.3.0
| | | +-- inherits@2.0.4 deduped
| | | `-- readable-stream@1.1.14
| | |   +-- core-util-is@1.0.2 deduped
| | |   +-- inherits@2.0.4 deduped
| | |   +-- isarray@0.0.1
| | |   `-- string_decoder@0.10.31
| | `-- stream-iterate@1.2.0
| |   +-- readable-stream@2.3.6
| |   | +-- core-util-is@1.0.2 deduped
| |   | +-- inherits@2.0.4 deduped
| |   | +-- isarray@1.0.0 deduped
| |   | +-- process-nextick-args@2.0.0 deduped
| |   | +-- safe-buffer@5.1.2 deduped
| |   | +-- string_decoder@1.1.1
| |   | | `-- safe-buffer@5.1.2 deduped
| |   | `-- util-deprecate@1.0.2 deduped
| |   `-- stream-shift@1.0.0 deduped
| +-- ssri@6.0.1
| | `-- figgy-pudding@3.5.1 deduped
| +-- stringify-package@1.0.1
| +-- tar@4.4.13
| | +-- chownr@1.1.4 deduped
| | +-- fs-minipass@1.2.7
| | | `-- minipass@2.9.0
| | |   +-- safe-buffer@5.1.2 deduped
| | |   `-- yallist@3.0.3 deduped
| | +-- minipass@2.9.0
| | | +-- safe-buffer@5.1.2 deduped
| | | `-- yallist@3.0.3 deduped
| | +-- minizlib@1.3.3
| | | `-- minipass@2.9.0
| | |   +-- safe-buffer@5.1.2 deduped
| | |   `-- yallist@3.0.3 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- safe-buffer@5.1.2 deduped
| | `-- yallist@3.0.3 deduped
| +-- text-table@0.2.0
| +-- tiny-relative-date@1.3.0
| +-- uid-number@0.0.6
| +-- umask@1.1.0
| +-- unique-filename@1.1.1
| | `-- unique-slug@2.0.0
| |   `-- imurmurhash@0.1.4 deduped
| +-- unpipe@1.0.0
| +-- update-notifier@2.5.0
| | +-- boxen@1.3.0
| | | +-- ansi-align@2.0.0
| | | | `-- string-width@2.1.1 deduped
| | | +-- camelcase@4.1.0
| | | +-- chalk@2.4.1 deduped
| | | +-- cli-boxes@1.0.0
| | | +-- string-width@2.1.1 deduped
| | | +-- term-size@1.2.0
| | | | `-- execa@0.7.0
| | | |   +-- cross-spawn@5.1.0
| | | |   | +-- lru-cache@4.1.5
| | | |   | | +-- pseudomap@1.0.2
| | | |   | | `-- yallist@2.1.2
| | | |   | +-- shebang-command@1.2.0
| | | |   | | `-- shebang-regex@1.0.0
| | | |   | `-- which@1.3.1 deduped
| | | |   +-- get-stream@3.0.0
| | | |   +-- is-stream@1.1.0
| | | |   +-- npm-run-path@2.0.2
| | | |   | `-- path-key@2.0.1
| | | |   +-- p-finally@1.0.0
| | | |   +-- signal-exit@3.0.2 deduped
| | | |   `-- strip-eof@1.0.0
| | | `-- widest-line@2.0.1
| | |   `-- string-width@2.1.1 deduped
| | +-- chalk@2.4.1
| | | +-- ansi-styles@3.2.1
| | | | `-- color-convert@1.9.1
| | | |   `-- color-name@1.1.3
| | | +-- escape-string-regexp@1.0.5
| | | `-- supports-color@5.4.0
| | |   `-- has-flag@3.0.0
| | +-- configstore@3.1.5
| | | +-- dot-prop@4.2.1
| | | | `-- is-obj@1.0.1
| | | +-- graceful-fs@4.2.4 deduped
| | | +-- make-dir@1.3.0
| | | | `-- pify@3.0.0
| | | +-- unique-string@1.0.0
| | | | `-- crypto-random-string@1.0.0
| | | +-- write-file-atomic@2.4.3 deduped
| | | `-- xdg-basedir@3.0.0 deduped
| | +-- import-lazy@2.1.0
| | +-- is-ci@1.2.1
| | | `-- ci-info@1.6.0
| | +-- is-installed-globally@0.1.0
| | | +-- global-dirs@0.1.1
| | | | `-- ini@1.3.5 deduped
| | | `-- is-path-inside@1.0.1
| | |   `-- path-is-inside@1.0.2 deduped
| | +-- is-npm@1.0.0
| | +-- latest-version@3.1.0
| | | `-- package-json@4.0.1
| | |   +-- got@6.7.1
| | |   | +-- create-error-class@3.0.2
| | |   | | `-- capture-stack-trace@1.0.0
| | |   | +-- duplexer3@0.1.4
| | |   | +-- get-stream@3.0.0
| | |   | +-- is-redirect@1.0.0
| | |   | +-- is-retry-allowed@1.2.0
| | |   | +-- is-stream@1.1.0 deduped
| | |   | +-- lowercase-keys@1.0.1
| | |   | +-- safe-buffer@5.1.2 deduped
| | |   | +-- timed-out@4.0.1
| | |   | +-- unzip-response@2.0.1
| | |   | `-- url-parse-lax@1.0.0
| | |   |   `-- prepend-http@1.0.4
| | |   +-- registry-auth-token@3.4.0
| | |   | +-- rc@1.2.8
| | |   | | +-- deep-extend@0.6.0
| | |   | | +-- ini@1.3.5 deduped
| | |   | | +-- minimist@1.2.5
| | |   | | `-- strip-json-comments@2.0.1
| | |   | `-- safe-buffer@5.1.2 deduped
| | |   +-- registry-url@3.1.0
| | |   | `-- rc@1.2.8 deduped
| | |   `-- semver@5.7.1 deduped
| | +-- semver-diff@2.1.0
| | | `-- semver@5.7.1 deduped
| | `-- xdg-basedir@3.0.0
| +-- uuid@3.3.3
| +-- validate-npm-package-license@3.0.4
| | +-- spdx-correct@3.0.0
| | | +-- spdx-expression-parse@3.0.0 deduped
| | | `-- spdx-license-ids@3.0.5
| | `-- spdx-expression-parse@3.0.0
| |   +-- spdx-exceptions@2.1.0
| |   `-- spdx-license-ids@3.0.5 deduped
| +-- validate-npm-package-name@3.0.0
| | `-- builtins@1.0.3
| +-- which@1.3.1
| | `-- isexe@2.0.0
| +-- worker-farm@1.7.0
| | `-- errno@0.1.7
| |   `-- prr@1.0.1
| `-- write-file-atomic@2.4.3
|   +-- graceful-fs@4.2.4 deduped
|   +-- imurmurhash@0.1.4 deduped
|   `-- signal-exit@3.0.2 deduped
</t>
<t tx="ekr.20201114160816.12">+-- typescript@3.9.5
`-- wasm-opt@1.1.1
  +-- node-fetch@2.6.1
  +-- ora@4.1.1
  | +-- chalk@3.0.0
  | | +-- ansi-styles@4.2.1
  | | | +-- @types/color-name@1.1.1
  | | | `-- color-convert@2.0.1
  | | |   `-- color-name@1.1.4
  | | `-- supports-color@7.2.0
  | |   `-- has-flag@4.0.0
  | +-- cli-cursor@3.1.0
  | | `-- restore-cursor@3.1.0
  | |   +-- onetime@5.1.2
  | |   | `-- mimic-fn@2.1.0
  | |   `-- signal-exit@3.0.3
  | +-- cli-spinners@2.4.0
  | +-- is-interactive@1.0.0
  | +-- log-symbols@3.0.0
  | | `-- chalk@2.4.2
  | |   +-- ansi-styles@3.2.1
  | |   | `-- color-convert@1.9.3
  | |   |   `-- color-name@1.1.3
  | |   +-- escape-string-regexp@1.0.5
  | |   `-- supports-color@5.5.0
  | |     `-- has-flag@3.0.0
  | +-- mute-stream@0.0.8
  | +-- strip-ansi@6.0.0
  | | `-- ansi-regex@5.0.0
  | `-- wcwidth@1.0.1
  |   `-- defaults@1.0.3
  |     `-- clone@1.0.4
  `-- tar@5.0.5
    +-- chownr@1.1.4
    +-- fs-minipass@2.1.0
    | `-- minipass@3.1.3 deduped
    +-- minipass@3.1.3
    | `-- yallist@4.0.0 deduped
    +-- minizlib@2.1.2
    | +-- minipass@3.1.3 deduped
    | `-- yallist@4.0.0 deduped
    +-- mkdirp@0.5.5
    | `-- minimist@1.2.5
    `-- yallist@4.0.0
</t>
<t tx="ekr.20201114160816.13">pip install jupyter_contrib_nbextensions

pip install jupyterlab

jupyterlab extensions are npm packages.

npm list -g</t>
<t tx="ekr.20201114160816.14">C:\Users\edreamleo\Python\Python37\share\jupyter\lab\staging\node_modules&gt;npm list

@jupyterlab/application-top@2.2.9 C:\Users\edreamleo\Python\Python37\share\jupyter\lab\staging

+-- @jupyterlab/docmanager-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/docmanager@2.2.4 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/documentsearch-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/documentsearch@2.2.7 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/extensionmanager-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/extensionmanager@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/settingregistry@2.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- react@16.9.0 deduped
| | +-- react-paginate@6.5.0
| | | `-- prop-types@15.7.2 deduped
| | `-- semver@6.3.0 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| `-- @jupyterlab/ui-components@2.2.4 deduped

+-- @jupyterlab/filebrowser-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/docmanager@2.2.4 deduped
| +-- @jupyterlab/filebrowser@2.2.5 deduped
| +-- @jupyterlab/launcher@2.2.6 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statedb@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/commands@1.11.3 deduped
| +-- @lumino/messaging@1.4.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/fileeditor-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/codeeditor@2.2.5 deduped
| +-- @jupyterlab/codemirror@2.2.4 deduped
| +-- @jupyterlab/console@2.2.7 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/filebrowser@2.2.5 deduped
| +-- @jupyterlab/fileeditor@2.2.4 deduped
| +-- @jupyterlab/launcher@2.2.6 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/commands@1.11.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/help-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/inspector@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/widgets@1.14.0 deduped
| `-- react@16.9.0 deduped

+-- @jupyterlab/htmlviewer-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/htmlviewer@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- react@16.9.0 deduped
| `-- @jupyterlab/ui-components@2.2.4 deduped

+-- @jupyterlab/hub-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| `-- @jupyterlab/services@5.2.5 deduped

+-- @jupyterlab/imageviewer-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| `-- @jupyterlab/imageviewer@2.2.4
|   +-- @jupyterlab/apputils@2.2.6 deduped
|   +-- @jupyterlab/coreutils@4.2.5 deduped
|   +-- @jupyterlab/docregistry@2.2.4 deduped
|   +-- @lumino/coreutils@1.5.3 deduped
|   +-- @lumino/messaging@1.4.3 deduped
|   `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/inspector-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/console@2.2.7 deduped
| +-- @jupyterlab/inspector@2.2.4 deduped
| +-- @jupyterlab/launcher@2.2.6 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| `-- @jupyterlab/ui-components@2.2.4 deduped

+-- @jupyterlab/javascript-extension@2.2.4
| +-- @jupyterlab/rendermime@2.2.4 deduped
| `-- @jupyterlab/rendermime-interfaces@2.2.1 deduped

+-- @jupyterlab/json-extension@2.2.6
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/messaging@1.4.3 deduped
| +-- @lumino/widgets@1.14.0 deduped
| +-- react@16.9.0 deduped
| +-- react-dom@16.9.0 deduped
| +-- react-highlighter@0.4.3
| | +-- blacklist@1.1.4
| | +-- create-react-class@15.7.0
| | | +-- loose-envify@1.4.0 deduped
| | | `-- object-assign@4.1.1 deduped
| | +-- escape-string-regexp@1.0.5
| | `-- prop-types@15.7.2 deduped
| `-- react-json-tree@0.11.2
|   +-- babel-runtime@6.26.0
|   | +-- core-js@2.6.11
|   | `-- regenerator-runtime@0.11.1
|   +-- prop-types@15.7.2 deduped
|   `-- react-base16-styling@0.5.3
|     +-- base16@1.0.0
|     +-- lodash.curry@4.1.1
|     +-- lodash.flow@3.5.0
|     `-- pure-color@1.3.0

+-- @jupyterlab/launcher-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/launcher@2.2.6 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/logconsole-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/logconsole@2.2.4
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/outputarea@2.2.4 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/nbformat@2.2.5
| | `-- @lumino/coreutils@1.5.3 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/signaling@1.4.3 deduped
| +-- @lumino/widgets@1.14.0 deduped
| `-- react@16.9.0 deduped

+-- @jupyterlab/mainmenu-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/markdownviewer-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/markdownviewer@2.2.6 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| `-- @jupyterlab/settingregistry@2.2.5 deduped

+-- @jupyterlab/mathjax2-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/mathjax2@2.2.1
| | +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| | `-- @lumino/coreutils@1.5.3 deduped
| `-- @jupyterlab/rendermime@2.2.4 deduped

+-- @jupyterlab/notebook-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/cells@2.2.7 deduped
| +-- @jupyterlab/codeeditor@2.2.5 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/docmanager@2.2.4 deduped
| +-- @jupyterlab/filebrowser@2.2.5 deduped
| +-- @jupyterlab/launcher@2.2.6 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/nbformat@2.2.5 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| +-- @jupyterlab/property-inspector@2.2.6 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statedb@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/commands@1.11.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| +-- @lumino/messaging@1.4.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/pdf-extension@2.2.1
| +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/rendermime-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/docmanager@2.2.4 deduped
| `-- @jupyterlab/rendermime@2.2.4 deduped

+-- @jupyterlab/running-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/running@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| `-- @lumino/algorithm@1.3.3 deduped

+-- @jupyterlab/settingeditor-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/codeeditor@2.2.5 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/settingeditor@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/inspector@2.2.4 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/settingregistry@2.2.5 deduped
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- react@16.9.0 deduped
| | `-- react-dom@16.9.0 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statedb@2.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| `-- @lumino/disposable@1.4.3 deduped

+-- @jupyterlab/shortcuts-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @lumino/commands@1.11.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| `-- @lumino/disposable@1.4.3 deduped

+-- @jupyterlab/statusbar-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/cells@2.2.7 deduped
| +-- @jupyterlab/console@2.2.7 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/fileeditor@2.2.4 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/tabmanager-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/terminal-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/launcher@2.2.6 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/running@2.2.6 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/terminal@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- xterm@4.2.0
| | `-- xterm-addon-fit@0.3.0
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/theme-dark-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| `-- @jupyterlab/apputils@2.2.6 deduped

+-- @jupyterlab/theme-light-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| `-- @jupyterlab/apputils@2.2.6 deduped

+-- @jupyterlab/toc@4.0.0 invalid
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/settingregistry@2.2.5 deduped
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/domutils@1.2.3
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/properties@1.2.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/virtualdom@1.7.3
| | | `-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- @types/react@16.9.53
| | | +-- @types/prop-types@15.7.3
| | | `-- csstype@3.0.4
| | +-- react@16.9.0 deduped
| | +-- react-dom@16.9.0 deduped
| | `-- sanitize-html@1.20.1
| |   +-- chalk@2.4.2 deduped
| |   +-- htmlparser2@3.10.1
| |   | +-- domelementtype@1.3.1
| |   | +-- domhandler@2.4.2
| |   | | `-- domelementtype@1.3.1 deduped
| |   | +-- domutils@1.5.1
| |   | | +-- dom-serializer@0.2.2
| |   | | | +-- domelementtype@2.0.2
| |   | | | `-- entities@2.1.0
| |   | | `-- domelementtype@1.3.1 deduped
| |   | +-- entities@1.1.2
| |   | +-- inherits@2.0.4 deduped
| |   | `-- readable-stream@3.6.0
| |   |   +-- inherits@2.0.4 deduped
| |   |   +-- string_decoder@1.1.1 deduped
| |   |   `-- util-deprecate@1.0.2 deduped
| |   +-- lodash.clonedeep@4.5.0
| |   +-- lodash.escaperegexp@4.1.2
| |   +-- lodash.isplainobject@4.0.6
| |   +-- lodash.isstring@4.0.1
| |   +-- lodash.mergewith@4.6.2
| |   +-- postcss@7.0.35 deduped
| |   +-- srcset@1.0.0
| |   | +-- array-uniq@1.0.3
| |   | `-- number-is-nan@1.0.1
| |   `-- xtend@4.0.2
| +-- @jupyterlab/cells@2.2.7
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/attachments@2.2.4
| | | +-- @jupyterlab/nbformat@2.2.5 deduped
| | | +-- @jupyterlab/observables@3.2.5 deduped
| | | +-- @jupyterlab/rendermime@2.2.4 deduped
| | | +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| | | +-- @lumino/disposable@1.4.3 deduped
| | | `-- @lumino/signaling@1.4.3 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/codemirror@2.2.4 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/filebrowser@2.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5
| | | +-- @lumino/algorithm@1.3.3 deduped
| | | +-- @lumino/coreutils@1.5.3 deduped
| | | +-- @lumino/disposable@1.4.3 deduped
| | | +-- @lumino/messaging@1.4.3 deduped
| | | `-- @lumino/signaling@1.4.3 deduped
| | +-- @jupyterlab/outputarea@2.2.4
| | | +-- @jupyterlab/apputils@2.2.6 deduped
| | | +-- @jupyterlab/nbformat@2.2.5 deduped
| | | +-- @jupyterlab/observables@3.2.5 deduped
| | | +-- @jupyterlab/rendermime@2.2.4 deduped
| | | +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| | | +-- @jupyterlab/services@5.2.5 deduped
| | | +-- @lumino/algorithm@1.3.3 deduped
| | | +-- @lumino/coreutils@1.5.3 deduped
| | | +-- @lumino/disposable@1.4.3 deduped
| | | +-- @lumino/messaging@1.4.3 deduped
| | | +-- @lumino/properties@1.2.3 deduped
| | | +-- @lumino/signaling@1.4.3 deduped
| | | `-- @lumino/widgets@1.14.0 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/dragdrop@1.6.4
| | | +-- @lumino/coreutils@1.5.3 deduped
| | | `-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/virtualdom@1.7.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/docmanager@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/statusbar@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/properties@1.2.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/docregistry@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/codemirror@2.2.4 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/fileeditor@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @jupyterlab/statusbar@2.2.4 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/markdownviewer@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/notebook@2.2.7
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/cells@2.2.7 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/statusbar@2.2.4 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/dragdrop@1.6.4 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/properties@1.2.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/virtualdom@1.7.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/rendermime@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codemirror@2.2.4 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- lodash.escape@4.0.1
| | `-- marked@0.8.2
| +-- @lumino/algorithm@1.3.3
| +-- @lumino/coreutils@1.5.3
| +-- @lumino/messaging@1.4.3
| | +-- @lumino/algorithm@1.3.3 deduped
| | `-- @lumino/collections@1.3.3
| |   `-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/widgets@1.14.0
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/dragdrop@1.6.4 deduped
| | +-- @lumino/keyboard@1.2.3
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/properties@1.2.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/virtualdom@1.7.3 deduped
| +-- react@16.9.0
| | +-- loose-envify@1.4.0
| | | `-- js-tokens@4.0.0
| | +-- object-assign@4.1.1 deduped
| | `-- prop-types@15.7.2
| |   +-- loose-envify@1.4.0 deduped
| |   +-- object-assign@4.1.1 deduped
| |   `-- react-is@16.13.1
| `-- react-dom@16.9.0
|   +-- loose-envify@1.4.0 deduped
|   +-- object-assign@4.1.1 deduped
|   +-- prop-types@15.7.2 deduped
|   `-- scheduler@0.15.0
|     +-- loose-envify@1.4.0 deduped
|     `-- object-assign@4.1.1 deduped

+-- @jupyterlab/tooltip-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/codeeditor@2.2.5 deduped
| +-- @jupyterlab/console@2.2.7 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/fileeditor@2.2.4 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/tooltip@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/ui-components-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| `-- @jupyterlab/ui-components@2.2.4 deduped

+-- @jupyterlab/vdom-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| `-- @jupyterlab/vdom@2.2.6
|   +-- @jupyterlab/apputils@2.2.6 deduped
|   +-- @jupyterlab/docregistry@2.2.4 deduped
|   +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
|   +-- @jupyterlab/services@5.2.5 deduped
|   +-- @lumino/coreutils@1.5.3 deduped
|   +-- @lumino/messaging@1.4.3 deduped
|   +-- @lumino/widgets@1.14.0 deduped
|   +-- @nteract/transform-vdom@4.0.15
|   | `-- lodash.clonedeep@4.5.0 deduped
|   +-- react@16.9.0 deduped
|   `-- react-dom@16.9.0 deduped

+-- @jupyterlab/vega5-extension@2.2.1
| +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/widgets@1.14.0 deduped
| +-- vega@5.17.0
| | +-- vega-crossfilter@4.0.5
| | | +-- d3-array@2.8.0
| | | +-- vega-dataflow@5.7.3 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-dataflow@5.7.3
| | | +-- vega-format@1.0.4 deduped
| | | +-- vega-loader@4.4.0 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-encode@4.8.3
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-interpolate@2.0.1
| | | | `-- d3-color@2.0.0 deduped
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-scale@7.1.1 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-event-selector@2.0.6
| | +-- vega-expression@3.0.0
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-force@4.0.7
| | | +-- d3-force@2.1.1
| | | | +-- d3-dispatch@2.0.0
| | | | +-- d3-quadtree@2.0.0
| | | | `-- d3-timer@2.0.0 deduped
| | | +-- vega-dataflow@5.7.3 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-format@1.0.4
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-format@2.0.0
| | | +-- d3-time-format@3.0.0
| | | | `-- d3-time@2.0.0 deduped
| | | +-- vega-time@2.0.4 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-functions@5.8.0
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-color@2.0.0
| | | +-- d3-geo@2.0.1
| | | | `-- d3-array@2.8.0 deduped
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-expression@3.0.0 deduped
| | | +-- vega-scale@7.1.1 deduped
| | | +-- vega-scenegraph@4.9.2 deduped
| | | +-- vega-selections@5.1.4
| | | | +-- vega-expression@3.0.0 deduped
| | | | `-- vega-util@1.16.0 deduped
| | | +-- vega-statistics@1.7.9 deduped
| | | +-- vega-time@2.0.4 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-geo@4.3.7
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-color@2.0.0 deduped
| | | +-- d3-geo@2.0.1 deduped
| | | +-- vega-canvas@1.2.6
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-projection@1.4.5 deduped
| | | +-- vega-statistics@1.7.9 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-hierarchy@4.0.9
| | | +-- d3-hierarchy@2.0.0
| | | +-- vega-dataflow@5.7.3 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-label@1.0.0
| | | +-- vega-canvas@1.2.6 deduped
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-scenegraph@4.9.2 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-loader@4.4.0
| | | +-- d3-dsv@2.0.0
| | | | +-- commander@2.20.3 deduped
| | | | +-- iconv-lite@0.4.24 deduped
| | | | `-- rw@1.3.3
| | | +-- node-fetch@2.6.1 deduped
| | | +-- topojson-client@3.1.0
| | | | `-- commander@2.20.3 deduped
| | | +-- vega-format@1.0.4 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-parser@6.1.0
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-event-selector@2.0.6 deduped
| | | +-- vega-functions@5.8.0 deduped
| | | +-- vega-scale@7.1.1 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-projection@1.4.5
| | | +-- d3-geo@2.0.1 deduped
| | | `-- d3-geo-projection@3.0.0
| | |   +-- commander@2.20.3 deduped
| | |   +-- d3-array@2.8.0 deduped
| | |   +-- d3-geo@2.0.1 deduped
| | |   `-- resolve@1.18.1
| | |     +-- is-core-module@2.0.0
| | |     | `-- has@1.0.3 deduped
| | |     `-- path-parse@1.0.6
| | +-- vega-regression@1.0.9
| | | +-- d3-array@2.8.0 deduped
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-statistics@1.7.9 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-runtime@6.1.3
| | | +-- vega-dataflow@5.7.3 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-scale@7.1.1
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-interpolate@2.0.1 deduped
| | | +-- d3-scale@3.2.3
| | | | +-- d3-array@2.8.0 deduped
| | | | +-- d3-format@2.0.0 deduped
| | | | +-- d3-interpolate@2.0.1 deduped
| | | | +-- d3-time@2.0.0 deduped
| | | | `-- d3-time-format@3.0.0 deduped
| | | +-- vega-time@2.0.4 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-scenegraph@4.9.2
| | | +-- d3-path@2.0.0
| | | +-- d3-shape@2.0.0
| | | | `-- d3-path@2.0.0 deduped
| | | +-- vega-canvas@1.2.6 deduped
| | | +-- vega-loader@4.4.0 deduped
| | | +-- vega-scale@7.1.1 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-statistics@1.7.9
| | | `-- d3-array@2.8.0 deduped
| | +-- vega-time@2.0.4
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-time@2.0.0
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-transforms@4.9.3
| | | +-- d3-array@2.8.0 deduped
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-statistics@1.7.9 deduped
| | | +-- vega-time@2.0.4 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-typings@0.19.1
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-util@1.16.0
| | +-- vega-view@5.9.0
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-timer@2.0.0
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-format@1.0.4 deduped
| | | +-- vega-functions@5.8.0 deduped
| | | +-- vega-runtime@6.1.3 deduped
| | | +-- vega-scenegraph@4.9.2 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-view-transforms@4.5.8
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-scenegraph@4.9.2 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-voronoi@4.1.5
| | | +-- d3-delaunay@5.3.0
| | | | `-- delaunator@4.0.1
| | | +-- vega-dataflow@5.7.3 deduped
| | | `-- vega-util@1.16.0 deduped
| | `-- vega-wordcloud@4.1.3
| |   +-- vega-canvas@1.2.6 deduped
| |   +-- vega-dataflow@5.7.3 deduped
| |   +-- vega-scale@7.1.1 deduped
| |   +-- vega-statistics@1.7.9 deduped
| |   `-- vega-util@1.16.0 deduped
| +-- vega-embed@6.12.2
| | +-- fast-json-patch@3.0.0-1
| | +-- json-stringify-pretty-compact@2.0.0
| | +-- semver@7.3.2
| | +-- vega-schema-url-parser@2.1.0
| | +-- vega-themes@2.9.1
| | `-- vega-tooltip@0.24.2
| |   `-- vega-util@1.16.0 deduped
| `-- vega-lite@4.17.0
|   +-- @types/clone@2.1.0
|   +-- @types/fast-json-stable-stringify@2.0.0
|   +-- array-flat-polyfill@1.0.1
|   +-- clone@2.1.2
|   +-- fast-deep-equal@3.1.3
|   +-- fast-json-stable-stringify@2.1.0
|   +-- json-stringify-pretty-compact@2.0.0 deduped
|   +-- tslib@2.0.3
|   +-- vega-event-selector@2.0.6 deduped
|   +-- vega-expression@3.0.0 deduped
|   +-- vega-util@1.16.0 deduped
|   `-- yargs@16.0.3
|     +-- cliui@7.0.3
|     | +-- string-width@4.2.0 deduped
|     | +-- strip-ansi@6.0.0 deduped
|     | `-- wrap-ansi@7.0.0
|     |   +-- ansi-styles@4.3.0
|     |   | `-- color-convert@2.0.1
|     |   |   `-- color-name@1.1.4
|     |   +-- string-width@4.2.0 deduped
|     |   `-- strip-ansi@6.0.0 deduped
|     +-- escalade@3.1.1
|     +-- get-caller-file@2.0.5 deduped
|     +-- require-directory@2.1.1 deduped
|     +-- string-width@4.2.0 deduped
|     +-- y18n@5.0.4
|     `-- yargs-parser@20.2.3

+-- chokidar@3.4.3
| +-- anymatch@3.1.1
| | +-- normalize-path@3.0.0 deduped
| | `-- picomatch@2.2.2
| +-- braces@3.0.2
| | `-- fill-range@7.0.1
| |   `-- to-regex-range@5.0.1
| |     `-- is-number@7.0.0
| +-- UNMET OPTIONAL DEPENDENCY fsevents@~2.1.2
| +-- glob-parent@5.1.1
| | `-- is-glob@4.0.1 deduped
| +-- is-binary-path@2.1.0
| | `-- binary-extensions@2.1.0
| +-- is-glob@4.0.1
| | `-- is-extglob@2.1.1
| +-- normalize-path@3.0.0
| `-- readdirp@3.5.0
|   `-- picomatch@2.2.2 deduped

+-- css-loader@3.2.1
| +-- camelcase@5.3.1
| +-- cssesc@3.0.0
| +-- icss-utils@4.1.1
| | `-- postcss@7.0.35 deduped
| +-- loader-utils@1.4.0
| | +-- big.js@5.2.2
| | +-- emojis-list@3.0.0
| | `-- json5@1.0.1
| |   `-- minimist@1.2.5 deduped
| +-- normalize-path@3.0.0 deduped
| +-- postcss@7.0.35
| | +-- chalk@2.4.2 deduped
| | +-- source-map@0.6.1 deduped
| | `-- supports-color@6.1.0 deduped
| +-- postcss-modules-extract-imports@2.0.0
| | `-- postcss@7.0.35 deduped
| +-- postcss-modules-local-by-default@3.0.3
| | +-- icss-utils@4.1.1 deduped
| | +-- postcss@7.0.35 deduped
| | +-- postcss-selector-parser@6.0.4
| | | +-- cssesc@3.0.0 deduped
| | | +-- indexes-of@1.0.1
| | | +-- uniq@1.0.1
| | | `-- util-deprecate@1.0.2
| | `-- postcss-value-parser@4.1.0 deduped
| +-- postcss-modules-scope@2.2.0
| | +-- postcss@7.0.35 deduped
| | `-- postcss-selector-parser@6.0.4 deduped
| +-- postcss-modules-values@3.0.0
| | +-- icss-utils@4.1.1 deduped
| | `-- postcss@7.0.35 deduped
| +-- postcss-value-parser@4.1.0
| `-- schema-utils@2.7.1
|   +-- @types/json-schema@7.0.6
|   +-- ajv@6.12.6 deduped
|   `-- ajv-keywords@3.5.2 deduped

+-- duplicate-package-checker-webpack-plugin@3.0.0
| +-- chalk@2.4.2
| | +-- ansi-styles@3.2.1
| | | `-- color-convert@1.9.3
| | |   `-- color-name@1.1.3
| | +-- escape-string-regexp@1.0.5 deduped
| | `-- supports-color@5.5.0
| |   `-- has-flag@3.0.0 deduped
| +-- find-root@1.1.0
| +-- lodash@4.17.20
| `-- semver@5.7.1

+-- file-loader@5.0.2
| +-- loader-utils@1.4.0 deduped
| `-- schema-utils@2.7.1 deduped

+-- fs-extra@8.1.0
| +-- graceful-fs@4.2.4
| +-- jsonfile@4.0.0
| | `-- graceful-fs@4.2.4 deduped
| `-- universalify@0.1.2

+-- glob@7.1.6
| +-- fs.realpath@1.0.0
| +-- inflight@1.0.6
| | +-- once@1.4.0 deduped
| | `-- wrappy@1.0.2
| +-- inherits@2.0.4
| +-- minimatch@3.0.4
| | `-- brace-expansion@1.1.11
| |   +-- balanced-match@1.0.0
| |   `-- concat-map@0.0.1
| +-- once@1.4.0
| | `-- wrappy@1.0.2 deduped
| `-- path-is-absolute@1.0.1

+-- handlebars@4.7.6
| +-- minimist@1.2.5 deduped
| +-- neo-async@2.6.2
| +-- source-map@0.6.1
| +-- uglify-js@3.4.10
| | +-- commander@2.19.0
| | `-- source-map@0.6.1 deduped
| `-- wordwrap@1.0.0

+-- html-loader@0.5.5
| +-- es6-templates@0.2.3
| | +-- recast@0.11.23
| | | +-- ast-types@0.9.6
| | | +-- esprima@3.1.3
| | | +-- private@0.1.8
| | | `-- source-map@0.5.7
| | `-- through@2.3.8 deduped
| +-- fastparse@1.1.2
| +-- html-minifier@3.5.21
| | +-- camel-case@3.0.0
| | | +-- no-case@2.3.2
| | | | `-- lower-case@1.1.4
| | | `-- upper-case@1.1.3
| | +-- clean-css@4.2.3
| | | `-- source-map@0.6.1 deduped
| | +-- commander@2.17.1
| | +-- he@1.2.0
| | +-- param-case@2.1.1
| | | `-- no-case@2.3.2 deduped
| | +-- relateurl@0.2.7
| | `-- uglify-js@3.4.10 deduped
| +-- loader-utils@1.4.0 deduped
| `-- object-assign@4.1.1

+-- html-webpack-plugin@3.2.0
| +-- html-minifier@3.5.21 deduped
| +-- loader-utils@0.2.17
| | +-- big.js@3.2.0
| | +-- emojis-list@2.1.0
| | +-- json5@0.5.1
| | `-- object-assign@4.1.1 deduped
| +-- lodash@4.17.20 deduped
| +-- pretty-error@2.1.2
| | +-- lodash@4.17.20 deduped
| | `-- renderkid@2.0.4
| |   +-- css-select@1.2.0
| |   | +-- boolbase@1.0.0
| |   | +-- css-what@2.1.3
| |   | +-- domutils@1.5.1 deduped
| |   | `-- nth-check@1.0.2
| |   |   `-- boolbase@1.0.0 deduped
| |   +-- dom-converter@0.2.0
| |   | `-- utila@0.4.0
| |   +-- htmlparser2@3.10.1 deduped
| |   +-- lodash@4.17.20 deduped
| |   `-- strip-ansi@3.0.1
| |     `-- ansi-regex@2.1.1
| +-- tapable@1.1.3
| +-- toposort@1.0.7
| `-- util.promisify@1.0.0
|   +-- define-properties@1.1.3
|   | `-- object-keys@1.1.1
|   `-- object.getownpropertydescriptors@2.1.0
|     +-- define-properties@1.1.3 deduped
|     `-- es-abstract@1.17.7
|       +-- es-to-primitive@1.2.1
|       | +-- is-callable@1.2.2 deduped
|       | +-- is-date-object@1.0.2 deduped
|       | `-- is-symbol@1.0.3
|       |   `-- has-symbols@1.0.1 deduped
|       +-- function-bind@1.1.1
|       +-- has@1.0.3
|       | `-- function-bind@1.1.1 deduped
|       +-- has-symbols@1.0.1
|       +-- is-callable@1.2.2
|       +-- is-regex@1.1.1
|       | `-- has-symbols@1.0.1 deduped
|       +-- object-inspect@1.8.0
|       +-- object-keys@1.1.1 deduped
|       +-- object.assign@4.1.1
|       | +-- define-properties@1.1.3 deduped
|       | +-- es-abstract@1.18.0-next.1
|       | | +-- es-to-primitive@1.2.1 deduped
|       | | +-- function-bind@1.1.1 deduped
|       | | +-- has@1.0.3 deduped
|       | | +-- has-symbols@1.0.1 deduped
|       | | +-- is-callable@1.2.2 deduped
|       | | +-- is-negative-zero@2.0.0
|       | | +-- is-regex@1.1.1 deduped
|       | | +-- object-inspect@1.8.0 deduped
|       | | +-- object-keys@1.1.1 deduped
|       | | +-- object.assign@4.1.1 deduped
|       | | +-- string.prototype.trimend@1.0.2 deduped
|       | | `-- string.prototype.trimstart@1.0.2 deduped
|       | +-- has-symbols@1.0.1 deduped
|       | `-- object-keys@1.1.1 deduped
|       +-- string.prototype.trimend@1.0.2
|       | +-- define-properties@1.1.3 deduped
|       | `-- es-abstract@1.18.0-next.1
|       |   +-- es-to-primitive@1.2.1 deduped
|       |   +-- function-bind@1.1.1 deduped
|       |   +-- has@1.0.3 deduped
|       |   +-- has-symbols@1.0.1 deduped
|       |   +-- is-callable@1.2.2 deduped
|       |   +-- is-negative-zero@2.0.0 deduped
|       |   +-- is-regex@1.1.1 deduped
|       |   +-- object-inspect@1.8.0 deduped
|       |   +-- object-keys@1.1.1 deduped
|       |   +-- object.assign@4.1.1 deduped
|       |   +-- string.prototype.trimend@1.0.2 deduped
|       |   `-- string.prototype.trimstart@1.0.2 deduped
|       `-- string.prototype.trimstart@1.0.2
|         +-- define-properties@1.1.3 deduped
|         `-- es-abstract@1.18.0-next.1
|           +-- es-to-primitive@1.2.1 deduped
|           +-- function-bind@1.1.1 deduped
|           +-- has@1.0.3 deduped
|           +-- has-symbols@1.0.1 deduped
|           +-- is-callable@1.2.2 deduped
|           +-- is-negative-zero@2.0.0 deduped
|           +-- is-regex@1.1.1 deduped
|           +-- object-inspect@1.8.0 deduped
|           +-- object-keys@1.1.1 deduped
|           +-- object.assign@4.1.1 deduped
|           +-- string.prototype.trimend@1.0.2 deduped
|           `-- string.prototype.trimstart@1.0.2 deduped

+-- mini-css-extract-plugin@0.8.2
| +-- loader-utils@1.4.0 deduped
| +-- normalize-url@1.9.1
| | +-- object-assign@4.1.1 deduped
| | +-- prepend-http@1.0.4
| | +-- query-string@4.3.4
| | | +-- object-assign@4.1.1 deduped
| | | `-- strict-uri-encode@1.1.0
| | `-- sort-keys@1.1.2
| |   `-- is-plain-obj@1.1.0
| +-- schema-utils@1.0.0
| | +-- ajv@6.12.6 deduped
| | +-- ajv-errors@1.0.1
| | `-- ajv-keywords@3.5.2 deduped
| `-- webpack-sources@1.4.3
|   +-- source-list-map@2.0.1
|   `-- source-map@0.6.1 deduped

+-- raw-loader@4.0.2
| +-- loader-utils@2.0.0
| | +-- big.js@5.2.2 deduped
| | +-- emojis-list@3.0.0
| | `-- json5@2.1.3
| |   `-- minimist@1.2.5 deduped
| `-- schema-utils@3.0.0
|   +-- @types/json-schema@7.0.6 deduped
|   +-- ajv@6.12.6 deduped
|   `-- ajv-keywords@3.5.2 deduped

+-- rimraf@3.0.2
| `-- glob@7.1.6 deduped

+-- sort-package-json@1.31.0
| +-- detect-indent@6.0.0
| +-- detect-newline@3.1.0
| +-- glob@7.1.6 deduped
| `-- sort-object-keys@1.1.3

+-- source-map-loader@0.2.4
| +-- async@2.6.3
| | `-- lodash@4.17.20 deduped
| `-- loader-utils@1.4.0 deduped

+-- style-loader@1.0.2
| +-- loader-utils@1.4.0 deduped
| `-- schema-utils@2.7.1 deduped

+-- svg-url-loader@3.0.3
| +-- file-loader@4.3.0
| | +-- loader-utils@1.4.0
| | | +-- big.js@5.2.2 deduped
| | | +-- emojis-list@3.0.0
| | | `-- json5@1.0.1 deduped
| | `-- schema-utils@2.7.1 deduped
| `-- loader-utils@1.2.3
|   +-- big.js@5.2.2 deduped
|   +-- emojis-list@2.1.0 deduped
|   `-- json5@1.0.1 deduped

+-- terser-webpack-plugin@2.3.8
| +-- cacache@13.0.1
| | +-- chownr@1.1.4
| | +-- figgy-pudding@3.5.2
| | +-- fs-minipass@2.1.0
| | | `-- minipass@3.1.3 deduped
| | +-- glob@7.1.6 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- infer-owner@1.0.4
| | +-- lru-cache@5.1.1
| | | `-- yallist@3.1.1
| | +-- minipass@3.1.3
| | | `-- yallist@4.0.0
| | +-- minipass-collect@1.0.2
| | | `-- minipass@3.1.3 deduped
| | +-- minipass-flush@1.0.5
| | | `-- minipass@3.1.3 deduped
| | +-- minipass-pipeline@1.2.4
| | | `-- minipass@3.1.3 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- move-concurrently@1.0.1
| | | +-- aproba@1.2.0
| | | +-- copy-concurrently@1.0.5
| | | | +-- aproba@1.2.0 deduped
| | | | +-- fs-write-stream-atomic@1.0.10 deduped
| | | | +-- iferr@0.1.5
| | | | +-- mkdirp@0.5.5 deduped
| | | | +-- rimraf@2.7.1
| | | | | `-- glob@7.1.6 deduped
| | | | `-- run-queue@1.0.3 deduped
| | | +-- fs-write-stream-atomic@1.0.10
| | | | +-- graceful-fs@4.2.4 deduped
| | | | +-- iferr@0.1.5 deduped
| | | | +-- imurmurhash@0.1.4
| | | | `-- readable-stream@2.3.7 deduped
| | | +-- mkdirp@0.5.5 deduped
| | | +-- rimraf@2.7.1
| | | | `-- glob@7.1.6 deduped
| | | `-- run-queue@1.0.3
| | |   `-- aproba@1.2.0 deduped
| | +-- p-map@3.0.0
| | | `-- aggregate-error@3.1.0
| | |   +-- clean-stack@2.2.0
| | |   `-- indent-string@4.0.0
| | +-- promise-inflight@1.0.1
| | +-- rimraf@2.7.1
| | | `-- glob@7.1.6 deduped
| | +-- ssri@7.1.0
| | | +-- figgy-pudding@3.5.2 deduped
| | | `-- minipass@3.1.3 deduped
| | `-- unique-filename@1.1.1
| |   `-- unique-slug@2.0.2
| |     `-- imurmurhash@0.1.4 deduped
| +-- find-cache-dir@3.3.1
| | +-- commondir@1.0.1
| | +-- make-dir@3.1.0
| | | `-- semver@6.3.0 deduped
| | `-- pkg-dir@4.2.0
| |   `-- find-up@4.1.0
| |     +-- locate-path@5.0.0
| |     | `-- p-locate@4.1.0
| |     |   `-- p-limit@2.3.0 deduped
| |     `-- path-exists@4.0.0
| +-- jest-worker@25.5.0
| | +-- merge-stream@2.0.0
| | `-- supports-color@7.2.0
| |   `-- has-flag@4.0.0
| +-- p-limit@2.3.0
| | `-- p-try@2.2.0
| +-- schema-utils@2.7.1 deduped
| +-- serialize-javascript@4.0.0
| | `-- randombytes@2.1.0
| |   `-- safe-buffer@5.1.2 deduped
| +-- source-map@0.6.1 deduped
| +-- terser@4.8.0
| | +-- commander@2.20.3 deduped
| | +-- source-map@0.6.1 deduped
| | `-- source-map-support@0.5.19
| |   +-- buffer-from@1.1.1
| |   `-- source-map@0.6.1 deduped
| `-- webpack-sources@1.4.3 deduped

+-- url-loader@3.0.0
| +-- loader-utils@1.4.0 deduped
| +-- mime@2.4.6
| `-- schema-utils@2.7.1 deduped

+-- webpack@4.44.2
| +-- @webassemblyjs/ast@1.9.0
| | +-- @webassemblyjs/helper-module-context@1.9.0 deduped
| | +-- @webassemblyjs/helper-wasm-bytecode@1.9.0
| | `-- @webassemblyjs/wast-parser@1.9.0
| |   +-- @webassemblyjs/ast@1.9.0 deduped
| |   +-- @webassemblyjs/floating-point-hex-parser@1.9.0
| |   +-- @webassemblyjs/helper-api-error@1.9.0 deduped
| |   +-- @webassemblyjs/helper-code-frame@1.9.0
| |   | `-- @webassemblyjs/wast-printer@1.9.0 deduped
| |   +-- @webassemblyjs/helper-fsm@1.9.0
| |   `-- @xtuc/long@4.2.2
| +-- @webassemblyjs/helper-module-context@1.9.0
| | `-- @webassemblyjs/ast@1.9.0 deduped
| +-- @webassemblyjs/wasm-edit@1.9.0
| | +-- @webassemblyjs/ast@1.9.0 deduped
| | +-- @webassemblyjs/helper-buffer@1.9.0
| | +-- @webassemblyjs/helper-wasm-bytecode@1.9.0 deduped
| | +-- @webassemblyjs/helper-wasm-section@1.9.0
| | | +-- @webassemblyjs/ast@1.9.0 deduped
| | | +-- @webassemblyjs/helper-buffer@1.9.0 deduped
| | | +-- @webassemblyjs/helper-wasm-bytecode@1.9.0 deduped
| | | `-- @webassemblyjs/wasm-gen@1.9.0 deduped
| | +-- @webassemblyjs/wasm-gen@1.9.0
| | | +-- @webassemblyjs/ast@1.9.0 deduped
| | | +-- @webassemblyjs/helper-wasm-bytecode@1.9.0 deduped
| | | +-- @webassemblyjs/ieee754@1.9.0 deduped
| | | +-- @webassemblyjs/leb128@1.9.0 deduped
| | | `-- @webassemblyjs/utf8@1.9.0 deduped
| | +-- @webassemblyjs/wasm-opt@1.9.0
| | | +-- @webassemblyjs/ast@1.9.0 deduped
| | | +-- @webassemblyjs/helper-buffer@1.9.0 deduped
| | | +-- @webassemblyjs/wasm-gen@1.9.0 deduped
| | | `-- @webassemblyjs/wasm-parser@1.9.0 deduped
| | +-- @webassemblyjs/wasm-parser@1.9.0 deduped
| | `-- @webassemblyjs/wast-printer@1.9.0
| |   +-- @webassemblyjs/ast@1.9.0 deduped
| |   +-- @webassemblyjs/wast-parser@1.9.0 deduped
| |   `-- @xtuc/long@4.2.2 deduped
| +-- @webassemblyjs/wasm-parser@1.9.0
| | +-- @webassemblyjs/ast@1.9.0 deduped
| | +-- @webassemblyjs/helper-api-error@1.9.0
| | +-- @webassemblyjs/helper-wasm-bytecode@1.9.0 deduped
| | +-- @webassemblyjs/ieee754@1.9.0
| | | `-- @xtuc/ieee754@1.2.0
| | +-- @webassemblyjs/leb128@1.9.0
| | | `-- @xtuc/long@4.2.2 deduped
| | `-- @webassemblyjs/utf8@1.9.0
| +-- acorn@6.4.2
| +-- ajv@6.12.6
| | +-- fast-deep-equal@3.1.3 deduped
| | +-- fast-json-stable-stringify@2.1.0 deduped
| | +-- json-schema-traverse@0.4.1
| | `-- uri-js@4.4.0
| |   `-- punycode@2.1.1
| +-- ajv-keywords@3.5.2
| +-- chrome-trace-event@1.0.2
| | `-- tslib@1.13.0
| +-- enhanced-resolve@4.3.0
| | +-- graceful-fs@4.2.4 deduped
| | +-- memory-fs@0.5.0
| | | +-- errno@0.1.7 deduped
| | | `-- readable-stream@2.3.7 deduped
| | `-- tapable@1.1.3 deduped
| +-- eslint-scope@4.0.3
| | +-- esrecurse@4.3.0
| | | `-- estraverse@5.2.0
| | `-- estraverse@4.3.0
| +-- json-parse-better-errors@1.0.2
| +-- loader-runner@2.4.0
| +-- loader-utils@1.4.0 deduped
| +-- memory-fs@0.4.1
| | +-- errno@0.1.7
| | | `-- prr@1.0.1
| | `-- readable-stream@2.3.7
| |   +-- core-util-is@1.0.2
| |   +-- inherits@2.0.4 deduped
| |   +-- isarray@1.0.0
| |   +-- process-nextick-args@2.0.1
| |   +-- safe-buffer@5.1.2 deduped
| |   +-- string_decoder@1.1.1 deduped
| |   `-- util-deprecate@1.0.2 deduped
| +-- micromatch@3.1.10
| | +-- arr-diff@4.0.0
| | +-- array-unique@0.3.2
| | +-- braces@2.3.2
| | | +-- arr-flatten@1.1.0
| | | +-- array-unique@0.3.2 deduped
| | | +-- extend-shallow@2.0.1
| | | | `-- is-extendable@0.1.1
| | | +-- fill-range@4.0.0
| | | | +-- extend-shallow@2.0.1 deduped
| | | | +-- is-number@3.0.0
| | | | | `-- kind-of@3.2.2
| | | | |   `-- is-buffer@1.1.6
| | | | +-- repeat-string@1.6.1
| | | | `-- to-regex-range@2.1.1
| | | |   +-- is-number@3.0.0 deduped
| | | |   `-- repeat-string@1.6.1 deduped
| | | +-- isobject@3.0.1
| | | +-- repeat-element@1.1.3
| | | +-- snapdragon@0.8.2 deduped
| | | +-- snapdragon-node@2.1.1
| | | | +-- define-property@1.0.0
| | | | | `-- is-descriptor@1.0.2 deduped
| | | | +-- isobject@3.0.1 deduped
| | | | `-- snapdragon-util@3.0.1
| | | |   `-- kind-of@3.2.2 deduped
| | | +-- split-string@3.1.0
| | | | `-- extend-shallow@3.0.2
| | | |   +-- assign-symbols@1.0.0 deduped
| | | |   `-- is-extendable@1.0.1
| | | |     `-- is-plain-object@2.0.4 deduped
| | | `-- to-regex@3.0.2 deduped
| | +-- define-property@2.0.2
| | | +-- is-descriptor@1.0.2
| | | | +-- is-accessor-descriptor@1.0.0
| | | | | `-- kind-of@6.0.3
| | | | +-- is-data-descriptor@1.0.0
| | | | | `-- kind-of@6.0.3
| | | | `-- kind-of@6.0.3
| | | `-- isobject@3.0.1 deduped
| | +-- extend-shallow@3.0.2
| | | +-- assign-symbols@1.0.0
| | | `-- is-extendable@1.0.1
| | |   `-- is-plain-object@2.0.4
| | |     `-- isobject@3.0.1 deduped
| | +-- extglob@2.0.4
| | | +-- array-unique@0.3.2 deduped
| | | +-- define-property@1.0.0
| | | | `-- is-descriptor@1.0.2 deduped
| | | +-- expand-brackets@2.1.4
| | | | +-- debug@2.6.9 deduped
| | | | +-- define-property@0.2.5 deduped
| | | | +-- extend-shallow@2.0.1 deduped
| | | | +-- posix-character-classes@0.1.1
| | | | +-- regex-not@1.0.2 deduped
| | | | +-- snapdragon@0.8.2 deduped
| | | | `-- to-regex@3.0.2 deduped
| | | +-- extend-shallow@2.0.1 deduped
| | | +-- fragment-cache@0.2.1 deduped
| | | +-- regex-not@1.0.2 deduped
| | | +-- snapdragon@0.8.2 deduped
| | | `-- to-regex@3.0.2 deduped
| | +-- fragment-cache@0.2.1
| | | `-- map-cache@0.2.2
| | +-- kind-of@6.0.3
| | +-- nanomatch@1.2.13
| | | +-- arr-diff@4.0.0 deduped
| | | +-- array-unique@0.3.2 deduped
| | | +-- define-property@2.0.2
| | | | +-- is-descriptor@1.0.2 deduped
| | | | `-- isobject@3.0.1 deduped
| | | +-- extend-shallow@3.0.2
| | | | +-- assign-symbols@1.0.0 deduped
| | | | `-- is-extendable@1.0.1
| | | |   `-- is-plain-object@2.0.4 deduped
| | | +-- fragment-cache@0.2.1 deduped
| | | +-- is-windows@1.0.2
| | | +-- kind-of@6.0.3
| | | +-- object.pick@1.3.0 deduped
| | | +-- regex-not@1.0.2 deduped
| | | +-- snapdragon@0.8.2 deduped
| | | `-- to-regex@3.0.2 deduped
| | +-- object.pick@1.3.0
| | | `-- isobject@3.0.1 deduped
| | +-- regex-not@1.0.2
| | | +-- extend-shallow@3.0.2
| | | | +-- assign-symbols@1.0.0 deduped
| | | | `-- is-extendable@1.0.1
| | | |   `-- is-plain-object@2.0.4 deduped
| | | `-- safe-regex@1.1.0
| | |   `-- ret@0.1.15
| | +-- snapdragon@0.8.2
| | | +-- base@0.11.2
| | | | +-- cache-base@1.0.1
| | | | | +-- collection-visit@1.0.0
| | | | | | +-- map-visit@1.0.0
| | | | | | | `-- object-visit@1.0.1 deduped
| | | | | | `-- object-visit@1.0.1
| | | | | |   `-- isobject@3.0.1 deduped
| | | | | +-- component-emitter@1.3.0 deduped
| | | | | +-- get-value@2.0.6
| | | | | +-- has-value@1.0.0
| | | | | | +-- get-value@2.0.6 deduped
| | | | | | +-- has-values@1.0.0
| | | | | | | +-- is-number@3.0.0 deduped
| | | | | | | `-- kind-of@4.0.0
| | | | | | |   `-- is-buffer@1.1.6 deduped
| | | | | | `-- isobject@3.0.1 deduped
| | | | | +-- isobject@3.0.1 deduped
| | | | | +-- set-value@2.0.1
| | | | | | +-- extend-shallow@2.0.1 deduped
| | | | | | +-- is-extendable@0.1.1 deduped
| | | | | | +-- is-plain-object@2.0.4 deduped
| | | | | | `-- split-string@3.1.0 deduped
| | | | | +-- to-object-path@0.3.0
| | | | | | `-- kind-of@3.2.2 deduped
| | | | | +-- union-value@1.0.1
| | | | | | +-- arr-union@3.1.0 deduped
| | | | | | +-- get-value@2.0.6 deduped
| | | | | | +-- is-extendable@0.1.1 deduped
| | | | | | `-- set-value@2.0.1 deduped
| | | | | `-- unset-value@1.0.0
| | | | |   +-- has-value@0.3.1
| | | | |   | +-- get-value@2.0.6 deduped
| | | | |   | +-- has-values@0.1.4
| | | | |   | `-- isobject@2.1.0
| | | | |   |   `-- isarray@1.0.0 deduped
| | | | |   `-- isobject@3.0.1 deduped
| | | | +-- class-utils@0.3.6
| | | | | +-- arr-union@3.1.0
| | | | | +-- define-property@0.2.5 deduped
| | | | | +-- isobject@3.0.1 deduped
| | | | | `-- static-extend@0.1.2
| | | | |   +-- define-property@0.2.5 deduped
| | | | |   `-- object-copy@0.1.0
| | | | |     +-- copy-descriptor@0.1.1
| | | | |     +-- define-property@0.2.5 deduped
| | | | |     `-- kind-of@3.2.2 deduped
| | | | +-- component-emitter@1.3.0
| | | | +-- define-property@1.0.0
| | | | | `-- is-descriptor@1.0.2 deduped
| | | | +-- isobject@3.0.1 deduped
| | | | +-- mixin-deep@1.3.2
| | | | | +-- for-in@1.0.2
| | | | | `-- is-extendable@1.0.1
| | | | |   `-- is-plain-object@2.0.4 deduped
| | | | `-- pascalcase@0.1.1
| | | +-- debug@2.6.9 deduped
| | | +-- define-property@0.2.5
| | | | `-- is-descriptor@0.1.6
| | | |   +-- is-accessor-descriptor@0.1.6
| | | |   | `-- kind-of@3.2.2
| | | |   |   `-- is-buffer@1.1.6 deduped
| | | |   +-- is-data-descriptor@0.1.4
| | | |   | `-- kind-of@3.2.2
| | | |   |   `-- is-buffer@1.1.6 deduped
| | | |   `-- kind-of@5.1.0
| | | +-- extend-shallow@2.0.1 deduped
| | | +-- map-cache@0.2.2 deduped
| | | +-- source-map@0.5.7
| | | +-- source-map-resolve@0.5.3
| | | | +-- atob@2.1.2
| | | | +-- decode-uri-component@0.2.0
| | | | +-- resolve-url@0.2.1
| | | | +-- source-map-url@0.4.0
| | | | `-- urix@0.1.0
| | | `-- use@3.1.1
| | `-- to-regex@3.0.2
| |   +-- define-property@2.0.2
| |   | +-- is-descriptor@1.0.2 deduped
| |   | `-- isobject@3.0.1 deduped
| |   +-- extend-shallow@3.0.2
| |   | +-- assign-symbols@1.0.0 deduped
| |   | `-- is-extendable@1.0.1
| |   |   `-- is-plain-object@2.0.4 deduped
| |   +-- regex-not@1.0.2 deduped
| |   `-- safe-regex@1.1.0 deduped
| +-- mkdirp@0.5.5
| | `-- minimist@1.2.5 deduped
| +-- neo-async@2.6.2 deduped
| +-- node-libs-browser@2.2.1
| | +-- assert@1.5.0
| | | +-- object-assign@4.1.1 deduped
| | | `-- util@0.10.3 deduped
| | +-- browserify-zlib@0.2.0
| | | `-- pako@1.0.11
| | +-- buffer@4.9.2
| | | +-- base64-js@1.3.1
| | | +-- ieee754@1.1.13
| | | `-- isarray@1.0.0 deduped
| | +-- console-browserify@1.2.0
| | +-- constants-browserify@1.0.0
| | +-- crypto-browserify@3.12.0
| | | +-- browserify-cipher@1.0.1
| | | | +-- browserify-aes@1.2.0
| | | | | +-- buffer-xor@1.0.3
| | | | | +-- cipher-base@1.0.4 deduped
| | | | | +-- create-hash@1.2.0 deduped
| | | | | +-- evp_bytestokey@1.0.3 deduped
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | +-- browserify-des@1.0.2
| | | | | +-- cipher-base@1.0.4 deduped
| | | | | +-- des.js@1.0.1
| | | | | | +-- inherits@2.0.4 deduped
| | | | | | `-- minimalistic-assert@1.0.1 deduped
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | `-- evp_bytestokey@1.0.3
| | | |   +-- md5.js@1.3.5 deduped
| | | |   `-- safe-buffer@5.1.2 deduped
| | | +-- browserify-sign@4.2.1
| | | | +-- bn.js@5.1.3
| | | | +-- browserify-rsa@4.0.1
| | | | | +-- bn.js@4.11.9 deduped
| | | | | `-- randombytes@2.1.0 deduped
| | | | +-- create-hash@1.2.0 deduped
| | | | +-- create-hmac@1.1.7 deduped
| | | | +-- elliptic@6.5.3
| | | | | +-- bn.js@4.11.9 deduped
| | | | | +-- brorand@1.1.0
| | | | | +-- hash.js@1.1.7
| | | | | | +-- inherits@2.0.4 deduped
| | | | | | `-- minimalistic-assert@1.0.1 deduped
| | | | | +-- hmac-drbg@1.0.1
| | | | | | +-- hash.js@1.1.7 deduped
| | | | | | +-- minimalistic-assert@1.0.1 deduped
| | | | | | `-- minimalistic-crypto-utils@1.0.1 deduped
| | | | | +-- inherits@2.0.4 deduped
| | | | | +-- minimalistic-assert@1.0.1
| | | | | `-- minimalistic-crypto-utils@1.0.1
| | | | +-- inherits@2.0.4 deduped
| | | | +-- parse-asn1@5.1.6
| | | | | +-- asn1.js@5.4.1
| | | | | | +-- bn.js@4.11.9 deduped
| | | | | | +-- inherits@2.0.4 deduped
| | | | | | +-- minimalistic-assert@1.0.1 deduped
| | | | | | `-- safer-buffer@2.1.2 deduped
| | | | | +-- browserify-aes@1.2.0 deduped
| | | | | +-- evp_bytestokey@1.0.3 deduped
| | | | | +-- pbkdf2@3.1.1 deduped
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | +-- readable-stream@3.6.0
| | | | | +-- inherits@2.0.4 deduped
| | | | | +-- string_decoder@1.1.1 deduped
| | | | | `-- util-deprecate@1.0.2 deduped
| | | | `-- safe-buffer@5.2.1
| | | +-- create-ecdh@4.0.4
| | | | +-- bn.js@4.11.9
| | | | `-- elliptic@6.5.3 deduped
| | | +-- create-hash@1.2.0
| | | | +-- cipher-base@1.0.4
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | +-- inherits@2.0.4 deduped
| | | | +-- md5.js@1.3.5
| | | | | +-- hash-base@3.1.0
| | | | | | +-- inherits@2.0.4 deduped
| | | | | | +-- readable-stream@3.6.0
| | | | | | | +-- inherits@2.0.4 deduped
| | | | | | | +-- string_decoder@1.1.1 deduped
| | | | | | | `-- util-deprecate@1.0.2 deduped
| | | | | | `-- safe-buffer@5.2.1
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | +-- ripemd160@2.0.2
| | | | | +-- hash-base@3.1.0 deduped
| | | | | `-- inherits@2.0.4 deduped
| | | | `-- sha.js@2.4.11
| | | |   +-- inherits@2.0.4 deduped
| | | |   `-- safe-buffer@5.1.2 deduped
| | | +-- create-hmac@1.1.7
| | | | +-- cipher-base@1.0.4 deduped
| | | | +-- create-hash@1.2.0 deduped
| | | | +-- inherits@2.0.4 deduped
| | | | +-- ripemd160@2.0.2 deduped
| | | | +-- safe-buffer@5.1.2 deduped
| | | | `-- sha.js@2.4.11 deduped
| | | +-- diffie-hellman@5.0.3
| | | | +-- bn.js@4.11.9 deduped
| | | | +-- miller-rabin@4.0.1
| | | | | +-- bn.js@4.11.9 deduped
| | | | | `-- brorand@1.1.0 deduped
| | | | `-- randombytes@2.1.0 deduped
| | | +-- inherits@2.0.4 deduped
| | | +-- pbkdf2@3.1.1
| | | | +-- create-hash@1.2.0 deduped
| | | | +-- create-hmac@1.1.7 deduped
| | | | +-- ripemd160@2.0.2 deduped
| | | | +-- safe-buffer@5.1.2 deduped
| | | | `-- sha.js@2.4.11 deduped
| | | +-- public-encrypt@4.0.3
| | | | +-- bn.js@4.11.9 deduped
| | | | +-- browserify-rsa@4.0.1 deduped
| | | | +-- create-hash@1.2.0 deduped
| | | | +-- parse-asn1@5.1.6 deduped
| | | | +-- randombytes@2.1.0 deduped
| | | | `-- safe-buffer@5.1.2 deduped
| | | +-- randombytes@2.1.0 deduped
| | | `-- randomfill@1.0.4
| | |   +-- randombytes@2.1.0 deduped
| | |   `-- safe-buffer@5.1.2 deduped
| | +-- domain-browser@1.2.0
| | +-- events@3.2.0
| | +-- https-browserify@1.0.0
| | +-- os-browserify@0.3.0
| | +-- path-browserify@0.0.1
| | +-- process@0.11.10 deduped
| | +-- punycode@1.3.2
| | +-- querystring-es3@0.2.1
| | +-- readable-stream@2.3.7 deduped
| | +-- stream-browserify@2.0.2
| | | +-- inherits@2.0.4 deduped
| | | `-- readable-stream@2.3.7 deduped
| | +-- stream-http@2.8.3
| | | +-- builtin-status-codes@3.0.0
| | | +-- inherits@2.0.4 deduped
| | | +-- readable-stream@2.3.7 deduped
| | | +-- to-arraybuffer@1.0.1
| | | `-- xtend@4.0.2 deduped
| | +-- string_decoder@1.1.1
| | | `-- safe-buffer@5.1.2 deduped
| | +-- timers-browserify@2.0.11
| | | `-- setimmediate@1.0.5
| | +-- tty-browserify@0.0.0
| | +-- url@0.11.0
| | | +-- punycode@1.3.2 deduped
| | | `-- querystring@0.2.0
| | +-- util@0.11.1
| | | `-- inherits@2.0.3
| | `-- vm-browserify@1.1.2
| +-- schema-utils@1.0.0
| | +-- ajv@6.12.6 deduped
| | +-- ajv-errors@1.0.1 deduped
| | `-- ajv-keywords@3.5.2 deduped
| +-- tapable@1.1.3 deduped
| +-- terser-webpack-plugin@1.4.5
| | +-- cacache@12.0.4
| | | +-- bluebird@3.7.2 deduped
| | | +-- chownr@1.1.4 deduped
| | | +-- figgy-pudding@3.5.2 deduped
| | | +-- glob@7.1.6 deduped
| | | +-- graceful-fs@4.2.4 deduped
| | | +-- infer-owner@1.0.4 deduped
| | | +-- lru-cache@5.1.1 deduped
| | | +-- mississippi@3.0.0
| | | | +-- concat-stream@1.6.2
| | | | | +-- buffer-from@1.1.1 deduped
| | | | | +-- inherits@2.0.4 deduped
| | | | | +-- readable-stream@2.3.7 deduped
| | | | | `-- typedarray@0.0.6
| | | | +-- duplexify@3.7.1
| | | | | +-- end-of-stream@1.4.4 deduped
| | | | | +-- inherits@2.0.4 deduped
| | | | | +-- readable-stream@2.3.7 deduped
| | | | | `-- stream-shift@1.0.1
| | | | +-- end-of-stream@1.4.4
| | | | | `-- once@1.4.0 deduped
| | | | +-- flush-write-stream@1.1.1
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- readable-stream@2.3.7 deduped
| | | | +-- from2@2.3.0
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- readable-stream@2.3.7 deduped
| | | | +-- parallel-transform@1.2.0
| | | | | +-- cyclist@1.0.1
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- readable-stream@2.3.7 deduped
| | | | +-- pump@3.0.0 deduped
| | | | +-- pumpify@1.5.1
| | | | | +-- duplexify@3.7.1 deduped
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- pump@2.0.1
| | | | |   +-- end-of-stream@1.4.4 deduped
| | | | |   `-- once@1.4.0 deduped
| | | | +-- stream-each@1.2.3
| | | | | +-- end-of-stream@1.4.4 deduped
| | | | | `-- stream-shift@1.0.1 deduped
| | | | `-- through2@2.0.5
| | | |   +-- readable-stream@2.3.7 deduped
| | | |   `-- xtend@4.0.2 deduped
| | | +-- mkdirp@0.5.5 deduped
| | | +-- move-concurrently@1.0.1 deduped
| | | +-- promise-inflight@1.0.1 deduped
| | | +-- rimraf@2.7.1
| | | | `-- glob@7.1.6 deduped
| | | +-- ssri@6.0.1
| | | | `-- figgy-pudding@3.5.2 deduped
| | | +-- unique-filename@1.1.1 deduped
| | | `-- y18n@4.0.0 deduped
| | +-- find-cache-dir@2.1.0
| | | +-- commondir@1.0.1 deduped
| | | +-- make-dir@2.1.0
| | | | +-- pify@4.0.1 deduped
| | | | `-- semver@5.7.1
| | | `-- pkg-dir@3.0.0 deduped
| | +-- is-wsl@1.1.0
| | +-- schema-utils@1.0.0 deduped
| | +-- serialize-javascript@4.0.0 deduped
| | +-- source-map@0.6.1 deduped
| | +-- terser@4.8.0 deduped
| | +-- webpack-sources@1.4.3 deduped
| | `-- worker-farm@1.7.0
| |   `-- errno@0.1.7 deduped
| +-- watchpack@1.7.4
| | +-- chokidar@3.4.3 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- neo-async@2.6.2 deduped
| | `-- UNMET OPTIONAL DEPENDENCY watchpack-chokidar2@^2.0.0
| `-- webpack-sources@1.4.3 deduped

+-- webpack-bundle-analyzer@3.9.0
| +-- acorn@7.4.1
| +-- acorn-walk@7.2.0
| +-- bfj@6.1.2
| | +-- bluebird@3.7.2
| | +-- check-types@8.0.3
| | +-- hoopy@0.1.4
| | `-- tryer@1.0.1
| +-- chalk@2.4.2 deduped
| +-- commander@2.20.3
| +-- ejs@2.7.4
| +-- express@4.17.1
| | +-- accepts@1.3.7
| | | +-- mime-types@2.1.27
| | | | `-- mime-db@1.44.0
| | | `-- negotiator@0.6.2
| | +-- array-flatten@1.1.1
| | +-- body-parser@1.19.0
| | | +-- bytes@3.1.0
| | | +-- content-type@1.0.4 deduped
| | | +-- debug@2.6.9 deduped
| | | +-- depd@1.1.2 deduped
| | | +-- http-errors@1.7.2
| | | | +-- depd@1.1.2 deduped
| | | | +-- inherits@2.0.3
| | | | +-- setprototypeof@1.1.1 deduped
| | | | +-- statuses@1.5.0 deduped
| | | | `-- toidentifier@1.0.0
| | | +-- iconv-lite@0.4.24 deduped
| | | +-- on-finished@2.3.0 deduped
| | | +-- qs@6.7.0 deduped
| | | +-- raw-body@2.4.0
| | | | +-- bytes@3.1.0 deduped
| | | | +-- http-errors@1.7.2 deduped
| | | | +-- iconv-lite@0.4.24 deduped
| | | | `-- unpipe@1.0.0 deduped
| | | `-- type-is@1.6.18 deduped
| | +-- content-disposition@0.5.3
| | | `-- safe-buffer@5.1.2 deduped
| | +-- content-type@1.0.4
| | +-- cookie@0.4.0
| | +-- cookie-signature@1.0.6
| | +-- debug@2.6.9
| | | `-- ms@2.0.0
| | +-- depd@1.1.2
| | +-- encodeurl@1.0.2
| | +-- escape-html@1.0.3
| | +-- etag@1.8.1
| | +-- finalhandler@1.1.2
| | | +-- debug@2.6.9 deduped
| | | +-- encodeurl@1.0.2 deduped
| | | +-- escape-html@1.0.3 deduped
| | | +-- on-finished@2.3.0 deduped
| | | +-- parseurl@1.3.3 deduped
| | | +-- statuses@1.5.0 deduped
| | | `-- unpipe@1.0.0
| | +-- fresh@0.5.2
| | +-- merge-descriptors@1.0.1
| | +-- methods@1.1.2
| | +-- on-finished@2.3.0
| | | `-- ee-first@1.1.1
| | +-- parseurl@1.3.3
| | +-- path-to-regexp@0.1.7
| | +-- proxy-addr@2.0.6
| | | +-- forwarded@0.1.2
| | | `-- ipaddr.js@1.9.1
| | +-- qs@6.7.0
| | +-- range-parser@1.2.1
| | +-- safe-buffer@5.1.2
| | +-- send@0.17.1
| | | +-- debug@2.6.9 deduped
| | | +-- depd@1.1.2 deduped
| | | +-- destroy@1.0.4
| | | +-- encodeurl@1.0.2 deduped
| | | +-- escape-html@1.0.3 deduped
| | | +-- etag@1.8.1 deduped
| | | +-- fresh@0.5.2 deduped
| | | +-- http-errors@1.7.2 deduped
| | | +-- mime@1.6.0
| | | +-- ms@2.1.1
| | | +-- on-finished@2.3.0 deduped
| | | +-- range-parser@1.2.1 deduped
| | | `-- statuses@1.5.0 deduped
| | +-- serve-static@1.14.1
| | | +-- encodeurl@1.0.2 deduped
| | | +-- escape-html@1.0.3 deduped
| | | +-- parseurl@1.3.3 deduped
| | | `-- send@0.17.1 deduped
| | +-- setprototypeof@1.1.1
| | +-- statuses@1.5.0
| | +-- type-is@1.6.18
| | | +-- media-typer@0.3.0
| | | `-- mime-types@2.1.27 deduped
| | +-- utils-merge@1.0.1
| | `-- vary@1.1.2
| +-- filesize@3.6.1
| +-- gzip-size@5.1.1
| | +-- duplexer@0.1.2
| | `-- pify@4.0.1
| +-- lodash@4.17.20 deduped
| +-- mkdirp@0.5.5 deduped
| +-- opener@1.5.2
| `-- ws@6.2.1
|   `-- async-limiter@1.0.1

+-- webpack-cli@3.3.12
| +-- chalk@2.4.2 deduped
| +-- cross-spawn@6.0.5
| | +-- nice-try@1.0.5
| | +-- path-key@2.0.1
| | +-- semver@5.7.1
| | +-- shebang-command@1.2.0
| | | `-- shebang-regex@1.0.0
| | `-- which@1.3.1
| |   `-- isexe@2.0.0 deduped
| +-- enhanced-resolve@4.3.0 deduped
| +-- findup-sync@3.0.0
| | +-- detect-file@1.0.0
| | +-- is-glob@4.0.1 deduped
| | +-- micromatch@3.1.10 deduped
| | `-- resolve-dir@1.0.1
| |   +-- expand-tilde@2.0.2
| |   | `-- homedir-polyfill@1.0.3
| |   |   `-- parse-passwd@1.0.0
| |   `-- global-modules@1.0.0
| |     +-- global-prefix@1.0.2
| |     | +-- expand-tilde@2.0.2 deduped
| |     | +-- homedir-polyfill@1.0.3 deduped
| |     | +-- ini@1.3.5 deduped
| |     | +-- is-windows@1.0.2 deduped
| |     | `-- which@1.3.1 deduped
| |     +-- is-windows@1.0.2 deduped
| |     `-- resolve-dir@1.0.1 deduped
| +-- global-modules@2.0.0
| | `-- global-prefix@3.0.0
| |   +-- ini@1.3.5
| |   +-- kind-of@6.0.3
| |   `-- which@1.3.1 deduped
| +-- import-local@2.0.0
| | +-- pkg-dir@3.0.0
| | | `-- find-up@3.0.0 deduped
| | `-- resolve-cwd@2.0.0
| |   `-- resolve-from@3.0.0
| +-- interpret@1.4.0
| +-- loader-utils@1.4.0 deduped
| +-- supports-color@6.1.0
| | `-- has-flag@3.0.0
| +-- v8-compile-cache@2.1.1
| `-- yargs@13.3.2
|   +-- cliui@5.0.0
|   | +-- string-width@3.1.0
|   | | +-- emoji-regex@7.0.3
|   | | +-- is-fullwidth-code-point@2.0.0
|   | | `-- strip-ansi@5.2.0 deduped
|   | +-- strip-ansi@5.2.0
|   | | `-- ansi-regex@4.1.0
|   | `-- wrap-ansi@5.1.0
|   |   +-- ansi-styles@3.2.1 deduped
|   |   +-- string-width@3.1.0
|   |   | +-- emoji-regex@7.0.3
|   |   | +-- is-fullwidth-code-point@2.0.0
|   |   | `-- strip-ansi@5.2.0 deduped
|   |   `-- strip-ansi@5.2.0
|   |     `-- ansi-regex@4.1.0
|   +-- find-up@3.0.0
|   | `-- locate-path@3.0.0
|   |   +-- p-locate@3.0.0
|   |   | `-- p-limit@2.3.0 deduped
|   |   `-- path-exists@3.0.0
|   +-- get-caller-file@2.0.5
|   +-- require-directory@2.1.1
|   +-- require-main-filename@2.0.0
|   +-- set-blocking@2.0.0
|   +-- string-width@3.1.0
|   | +-- emoji-regex@7.0.3
|   | +-- is-fullwidth-code-point@2.0.0
|   | `-- strip-ansi@5.2.0
|   |   `-- ansi-regex@4.1.0
|   +-- which-module@2.0.0
|   +-- y18n@4.0.0
|   `-- yargs-parser@13.1.2
|     +-- camelcase@5.3.1 deduped
|     `-- decamelize@1.2.0

+-- webpack-merge@4.2.2
| `-- lodash@4.17.20 deduped

+-- whatwg-fetch@3.4.1

+-- worker-loader@2.0.0
| +-- loader-utils@1.4.0 deduped
| `-- schema-utils@0.4.7
|   +-- ajv@6.12.6 deduped
|   `-- ajv-keywords@3.5.2 deduped
`-- yarn-deduplicate@1.2.0
  +-- @yarnpkg/lockfile@1.1.0 deduped
  +-- commander@4.1.1
  `-- semver@7.1.3

npm ERR! invalid: @jupyterlab/toc@4.0.0 C:\Users\edreamleo\Python\Python37\share\jupyter\lab\staging\node_modules\@jupyterlab\toc</t>
<t tx="ekr.20201114160816.15">+-- @jupyterlab/application@2.2.6
| +-- @fortawesome/fontawesome-free@5.15.1
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/rendermime-interfaces@2.2.1
| | +-- @lumino/coreutils@1.5.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/services@5.2.5
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/settingregistry@2.2.5 deduped
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- node-fetch@2.6.1
| | `-- ws@7.3.1
| +-- @jupyterlab/statedb@2.2.5
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/properties@1.2.3 deduped
| | `-- @lumino/signaling@1.4.3 deduped
| +-- @jupyterlab/ui-components@2.2.4
| | +-- @blueprintjs/core@3.35.0
| | | +-- @blueprintjs/icons@3.22.0
| | | | +-- classnames@2.2.6 deduped
| | | | `-- tslib@1.13.0 deduped
| | | +-- @types/dom4@2.0.1
| | | +-- classnames@2.2.6
| | | +-- dom4@2.1.5
| | | +-- normalize.css@8.0.1
| | | +-- popper.js@1.16.1
| | | +-- react-lifecycles-compat@3.0.4
| | | +-- react-popper@1.3.7
| | | | +-- @babel/runtime@7.12.1
| | | | | `-- regenerator-runtime@0.13.7
| | | | +-- create-react-context@0.3.0
| | | | | +-- gud@1.0.0
| | | | | `-- warning@4.0.3 deduped
| | | | +-- deep-equal@1.1.1
| | | | | +-- is-arguments@1.0.4
| | | | | +-- is-date-object@1.0.2
| | | | | +-- is-regex@1.1.1 deduped
| | | | | +-- object-is@1.1.3
| | | | | | +-- define-properties@1.1.3 deduped
| | | | | | `-- es-abstract@1.18.0-next.1
| | | | | |   +-- es-to-primitive@1.2.1 deduped
| | | | | |   +-- function-bind@1.1.1 deduped
| | | | | |   +-- has@1.0.3 deduped
| | | | | |   +-- has-symbols@1.0.1 deduped
| | | | | |   +-- is-callable@1.2.2 deduped
| | | | | |   +-- is-negative-zero@2.0.0 deduped
| | | | | |   +-- is-regex@1.1.1 deduped
| | | | | |   +-- object-inspect@1.8.0 deduped
| | | | | |   +-- object-keys@1.1.1 deduped
| | | | | |   +-- object.assign@4.1.1 deduped
| | | | | |   +-- string.prototype.trimend@1.0.2 deduped
| | | | | |   `-- string.prototype.trimstart@1.0.2 deduped
| | | | | +-- object-keys@1.1.1 deduped
| | | | | `-- regexp.prototype.flags@1.3.0
| | | | |   +-- define-properties@1.1.3 deduped
| | | | |   `-- es-abstract@1.17.7 deduped
| | | | +-- popper.js@1.16.1 deduped
| | | | +-- prop-types@15.7.2 deduped
| | | | +-- typed-styles@0.0.7
| | | | `-- warning@4.0.3
| | | |   `-- loose-envify@1.4.0 deduped
| | | +-- react-transition-group@2.9.0
| | | | +-- dom-helpers@3.4.0
| | | | | `-- @babel/runtime@7.12.1 deduped
| | | | +-- loose-envify@1.4.0 deduped
| | | | +-- prop-types@15.7.2 deduped
| | | | `-- react-lifecycles-compat@3.0.4 deduped
| | | +-- resize-observer-polyfill@1.5.1
| | | `-- tslib@1.13.0 deduped
| | +-- @blueprintjs/select@3.14.3
| | | +-- @blueprintjs/core@3.35.0 deduped
| | | +-- classnames@2.2.6 deduped
| | | `-- tslib@1.13.0 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/virtualdom@1.7.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- react@16.9.0 deduped
| | +-- react-dom@16.9.0 deduped
| | `-- typestyle@2.1.0
| |   +-- csstype@2.6.9 deduped
| |   `-- free-style@3.1.0
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/application@1.11.0
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @lumino/commands@1.11.3
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/keyboard@1.2.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/virtualdom@1.7.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3
| | +-- @lumino/algorithm@1.3.3 deduped
| | `-- @lumino/signaling@1.4.3 deduped
| +-- @lumino/messaging@1.4.3 deduped
| +-- @lumino/polling@1.3.3
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | `-- @lumino/signaling@1.4.3 deduped
| +-- @lumino/properties@1.2.3
| +-- @lumino/signaling@1.4.3
| | `-- @lumino/algorithm@1.3.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/application-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/property-inspector@2.2.6
| | +-- @jupyterlab/application@2.2.6 deduped
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/settingregistry@2.2.5
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- ajv@6.12.6 deduped
| | `-- json5@2.1.3
| |   `-- minimist@1.2.5 deduped
| +-- @jupyterlab/statedb@2.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| +-- @lumino/widgets@1.14.0 deduped
| `-- react@16.9.0 deduped

+-- @jupyterlab/apputils-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/mainmenu@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statedb@2.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/commands@1.11.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| +-- @lumino/polling@1.3.3 deduped
| +-- @lumino/widgets@1.14.0 deduped
| `-- es6-promise@4.2.8

+-- @jupyterlab/buildutils@2.2.3
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @yarnpkg/lockfile@1.1.0
| +-- child_process@1.0.2
| +-- commander@4.0.1
| +-- crypto@1.0.1
| +-- dependency-graph@0.8.1
| +-- duplicate-package-checker-webpack-plugin@3.0.0 deduped
| +-- fs-extra@8.1.0 deduped
| +-- glob@7.1.6 deduped
| +-- inquirer@7.3.3
| | +-- ansi-escapes@4.3.1
| | | `-- type-fest@0.11.0
| | +-- chalk@4.1.0
| | | +-- ansi-styles@4.3.0
| | | | `-- color-convert@2.0.1
| | | |   `-- color-name@1.1.4
| | | `-- supports-color@7.2.0
| | |   `-- has-flag@4.0.0
| | +-- cli-cursor@3.1.0
| | | `-- restore-cursor@3.1.0
| | |   +-- onetime@5.1.2
| | |   | `-- mimic-fn@2.1.0
| | |   `-- signal-exit@3.0.3
| | +-- cli-width@3.0.0
| | +-- external-editor@3.1.0
| | | +-- chardet@0.7.0
| | | +-- iconv-lite@0.4.24
| | | | `-- safer-buffer@2.1.2
| | | `-- tmp@0.0.33
| | |   `-- os-tmpdir@1.0.2
| | +-- figures@3.2.0
| | | `-- escape-string-regexp@1.0.5 deduped
| | +-- lodash@4.17.20 deduped
| | +-- mute-stream@0.0.8
| | +-- run-async@2.4.1
| | +-- rxjs@6.6.3
| | | `-- tslib@1.13.0 deduped
| | +-- string-width@4.2.0
| | | +-- emoji-regex@8.0.0
| | | +-- is-fullwidth-code-point@3.0.0
| | | `-- strip-ansi@6.0.0 deduped
| | +-- strip-ansi@6.0.0
| | | `-- ansi-regex@5.0.0
| | `-- through@2.3.8
| +-- mini-css-extract-plugin@0.8.2 deduped
| +-- package-json@6.5.0
| | +-- got@9.6.0
| | | +-- @sindresorhus/is@0.14.0
| | | +-- @szmarczak/http-timer@1.1.2
| | | | `-- defer-to-connect@1.1.3
| | | +-- cacheable-request@6.1.0
| | | | +-- clone-response@1.0.2
| | | | | `-- mimic-response@1.0.1 deduped
| | | | +-- get-stream@5.2.0
| | | | | `-- pump@3.0.0 deduped
| | | | +-- http-cache-semantics@4.1.0
| | | | +-- keyv@3.1.0
| | | | | `-- json-buffer@3.0.0
| | | | +-- lowercase-keys@2.0.0
| | | | +-- normalize-url@4.5.0
| | | | `-- responselike@1.0.2
| | | |   `-- lowercase-keys@1.0.1 deduped
| | | +-- decompress-response@3.3.0
| | | | `-- mimic-response@1.0.1 deduped
| | | +-- duplexer3@0.1.4
| | | +-- get-stream@4.1.0
| | | | `-- pump@3.0.0
| | | |   +-- end-of-stream@1.4.4 deduped
| | | |   `-- once@1.4.0 deduped
| | | +-- lowercase-keys@1.0.1
| | | +-- mimic-response@1.0.1
| | | +-- p-cancelable@1.1.0
| | | +-- to-readable-stream@1.0.0
| | | `-- url-parse-lax@3.0.0
| | |   `-- prepend-http@2.0.0
| | +-- registry-auth-token@4.2.0
| | | `-- rc@1.2.8
| | |   +-- deep-extend@0.6.0
| | |   +-- ini@1.3.5 deduped
| | |   +-- minimist@1.2.5 deduped
| | |   `-- strip-json-comments@2.0.1
| | +-- registry-url@5.1.0
| | | `-- rc@1.2.8 deduped
| | `-- semver@6.3.0 deduped
| +-- path@0.12.7
| | +-- process@0.11.10
| | `-- util@0.10.3
| |   `-- inherits@2.0.1
| +-- prettier@1.19.1
| +-- semver@6.3.0
| +-- sort-package-json@1.31.0 deduped
| +-- typescript@3.7.5
| +-- webpack@4.44.2 deduped
| `-- which@2.0.2
|   `-- isexe@2.0.0</t>
<t tx="ekr.20201114160816.16">+-- @jupyterlab/celltags-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/celltags@2.2.7
| | +-- @jupyterlab/application@2.2.6 deduped
| | +-- @jupyterlab/cells@2.2.7 deduped
| | +-- @jupyterlab/notebook@2.2.7 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| `-- @jupyterlab/notebook@2.2.7 deduped</t>
<t tx="ekr.20201114160816.17">+-- @jupyterlab/codemirror-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/codeeditor@2.2.5
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/dragdrop@1.6.4 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/codemirror@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/statusbar@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- codemirror@5.53.2 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/fileeditor@2.2.4 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- csstype@2.6.9
| | +-- react@16.9.0 deduped
| | `-- typestyle@2.1.0 deduped
| +-- @lumino/widgets@1.14.0 deduped
| `-- codemirror@5.53.2</t>
<t tx="ekr.20201114160816.18">+-- @jupyterlab/completer-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/completer@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/console@2.2.7
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/cells@2.2.7 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/dragdrop@1.6.4 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/fileeditor@2.2.4 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| `-- @lumino/widgets@1.14.0 deduped</t>
<t tx="ekr.20201114160816.19">+-- @jupyterlab/console-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/codeeditor@2.2.5 deduped
| +-- @jupyterlab/console@2.2.7 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/filebrowser@2.2.5
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/docmanager@2.2.4 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @jupyterlab/statusbar@2.2.4 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/dragdrop@1.6.4 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/launcher@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/properties@1.2.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| +-- @lumino/properties@1.2.3 deduped
| `-- @lumino/widgets@1.14.0 deduped</t>
<t tx="ekr.20201114160816.20">+-- @jupyterlab/coreutils@4.2.5
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| +-- @lumino/signaling@1.4.3 deduped
| +-- minimist@1.2.5
| +-- moment@2.29.1
| +-- path-posix@1.0.0
| `-- url-parse@1.4.7
|   +-- querystringify@2.2.0
|   `-- requires-port@1.0.0</t>
<t tx="ekr.20201114160816.21">+-- @jupyterlab/csvviewer-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/csvviewer@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/datagrid@0.6.0 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/documentsearch@2.2.7
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/cells@2.2.7 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/codemirror@2.2.4 deduped
| | +-- @jupyterlab/fileeditor@2.2.4 deduped
| | +-- @jupyterlab/notebook@2.2.7 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- codemirror@5.53.2 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @lumino/datagrid@0.6.0
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/dragdrop@1.6.4 deduped
| | +-- @lumino/keyboard@1.2.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @lumino/signaling@1.4.3 deduped
| `-- @lumino/widgets@1.14.0 deduped</t>
<t tx="ekr.20201114160816.5">- Colorize and import .tsx like .ts.

- Read the Jupyter docs! Good first issue.

- Location of jupyterlab toc packages:
    C:\leo.repo\jupyterlab-toc (study version)
    ~/AppData/local/yarn/cache/v6 (two places)
        @jupyterlab\toc
    
  - Search for the keyword jupyterlab-extension on the npm registry to find extensions
  - Search for markdownViewerTracker.
  
- Script to parse npm list into children.
  Search:  ^(\+\-\-)
  Replace: \n\1
</t>
<t tx="ekr.20201114160816.6">@language rest
@wrap

c:\leo.repo\leo-editor&gt;npm list -g

C:\Users\edreamleo\AppData\Roaming\npm




</t>
<t tx="ekr.20201114160816.7">+-- http-server@0.11.1
| +-- colors@1.0.3
| +-- corser@2.0.1
| +-- ecstatic@3.2.1
| | +-- he@1.1.1
| | +-- mime@1.6.0
| | +-- minimist@1.2.0
| | `-- url-join@2.0.5
| +-- http-proxy@1.17.0
| | +-- eventemitter3@3.1.0
| | +-- follow-redirects@1.5.7
| | | `-- debug@3.1.0
| | |   `-- ms@2.0.0 deduped
| | `-- requires-port@1.0.0
| +-- opener@1.4.3
| +-- optimist@0.6.1
| | +-- minimist@0.0.10
| | `-- wordwrap@0.0.3
| +-- portfinder@1.0.17
| | +-- async@1.5.2
| | +-- debug@2.6.9
| | | `-- ms@2.0.0
| | `-- mkdirp@0.5.1
| |   `-- minimist@0.0.8
| `-- union@0.4.6
|   `-- qs@2.3.3</t>
<t tx="ekr.20201114160816.8">+-- inspect-brk@0.1.2
| `-- find-up@2.1.0
|   `-- locate-path@2.0.0
|     +-- p-locate@2.0.0
|     | `-- p-limit@1.3.0
|     |   `-- p-try@1.0.0
|     `-- path-exists@3.0.0
</t>
<t tx="ekr.20201114160816.9">+-- node-gyp@3.6.2
| +-- fstream@1.0.11
| | +-- graceful-fs@4.1.11 deduped
| | +-- inherits@2.0.3
| | +-- mkdirp@0.5.1 deduped
| | `-- rimraf@2.6.2 deduped
| +-- glob@7.1.2
| | +-- fs.realpath@1.0.0
| | +-- inflight@1.0.6
| | | +-- once@1.4.0 deduped
| | | `-- wrappy@1.0.2
| | +-- inherits@2.0.3 deduped
| | +-- minimatch@3.0.4 deduped
| | +-- once@1.4.0
| | | `-- wrappy@1.0.2 deduped
| | `-- path-is-absolute@1.0.1
| +-- graceful-fs@4.1.11
| +-- minimatch@3.0.4
| | `-- brace-expansion@1.1.11
| |   +-- balanced-match@1.0.0
| |   `-- concat-map@0.0.1
| +-- mkdirp@0.5.1
| | `-- minimist@0.0.8
| +-- nopt@3.0.6
| | `-- abbrev@1.1.1
| +-- npmlog@4.1.2
| | +-- are-we-there-yet@1.1.5
| | | +-- delegates@1.0.0
| | | `-- readable-stream@2.3.6
| | |   +-- core-util-is@1.0.2
| | |   +-- inherits@2.0.3 deduped
| | |   +-- isarray@1.0.0
| | |   +-- process-nextick-args@2.0.0
| | |   +-- safe-buffer@5.1.2 deduped
| | |   +-- string_decoder@1.1.1
| | |   | `-- safe-buffer@5.1.2 deduped
| | |   `-- util-deprecate@1.0.2
| | +-- console-control-strings@1.1.0
| | +-- gauge@2.7.4
| | | +-- aproba@1.2.0
| | | +-- console-control-strings@1.1.0 deduped
| | | +-- has-unicode@2.0.1
| | | +-- object-assign@4.1.1
| | | +-- signal-exit@3.0.2
| | | +-- string-width@1.0.2
| | | | +-- code-point-at@1.1.0
| | | | +-- is-fullwidth-code-point@1.0.0
| | | | | `-- number-is-nan@1.0.1
| | | | `-- strip-ansi@3.0.1 deduped
| | | +-- strip-ansi@3.0.1
| | | | `-- ansi-regex@2.1.1
| | | `-- wide-align@1.1.3
| | |   `-- string-width@1.0.2 deduped
| | `-- set-blocking@2.0.0
| +-- osenv@0.1.5
| | +-- os-homedir@1.0.2
| | `-- os-tmpdir@1.0.2
| +-- request@2.88.0
| | +-- aws-sign2@0.7.0
| | +-- aws4@1.8.0
| | +-- caseless@0.12.0
| | +-- combined-stream@1.0.6
| | | `-- delayed-stream@1.0.0
| | +-- extend@3.0.2
| | +-- forever-agent@0.6.1
| | +-- form-data@2.3.2
| | | +-- asynckit@0.4.0
| | | +-- combined-stream@1.0.6 deduped
| | | `-- mime-types@2.1.19 deduped
| | +-- har-validator@5.1.0
| | | +-- ajv@5.5.2
| | | | +-- co@4.6.0
| | | | +-- fast-deep-equal@1.1.0
| | | | +-- fast-json-stable-stringify@2.0.0
| | | | `-- json-schema-traverse@0.3.1
| | | `-- har-schema@2.0.0
| | +-- http-signature@1.2.0
| | | +-- assert-plus@1.0.0
| | | +-- jsprim@1.4.1
| | | | +-- assert-plus@1.0.0 deduped
| | | | +-- extsprintf@1.3.0
| | | | +-- json-schema@0.2.3
| | | | `-- verror@1.10.0
| | | |   +-- assert-plus@1.0.0 deduped
| | | |   +-- core-util-is@1.0.2 deduped
| | | |   `-- extsprintf@1.3.0 deduped
| | | `-- sshpk@1.14.2
| | |   +-- asn1@0.2.4
| | |   | `-- safer-buffer@2.1.2 deduped
| | |   +-- assert-plus@1.0.0 deduped
| | |   +-- bcrypt-pbkdf@1.0.2
| | |   | `-- tweetnacl@0.14.5 deduped
| | |   +-- dashdash@1.14.1
| | |   | `-- assert-plus@1.0.0 deduped
| | |   +-- ecc-jsbn@0.1.2
| | |   | +-- jsbn@0.1.1 deduped
| | |   | `-- safer-buffer@2.1.2 deduped
| | |   +-- getpass@0.1.7
| | |   | `-- assert-plus@1.0.0 deduped
| | |   +-- jsbn@0.1.1
| | |   +-- safer-buffer@2.1.2
| | |   `-- tweetnacl@0.14.5
| | +-- is-typedarray@1.0.0
| | +-- isstream@0.1.2
| | +-- json-stringify-safe@5.0.1
| | +-- mime-types@2.1.19
| | | `-- mime-db@1.35.0
| | +-- oauth-sign@0.9.0
| | +-- performance-now@2.1.0
| | +-- qs@6.5.2
| | +-- safe-buffer@5.1.2
| | +-- tough-cookie@2.4.3
| | | +-- psl@1.1.29
| | | `-- punycode@1.4.1
| | +-- tunnel-agent@0.6.0
| | | `-- safe-buffer@5.1.2 deduped
| | `-- uuid@3.3.2
| +-- rimraf@2.6.2
| | `-- glob@7.1.2 deduped
| +-- semver@5.3.0
| +-- tar@2.2.1
| | +-- block-stream@0.0.9
| | | `-- inherits@2.0.3 deduped
| | +-- fstream@1.0.11 deduped
| | `-- inherits@2.0.3 deduped
| `-- which@1.3.1
|   `-- isexe@2.0.0</t>
<t tx="ekr.20201117043352.1">- Create new items for uploaded videos.
- Take pictures of RR at her loom, and of yarns.
- New picture and email addresses on front page.

- Second test purchase.
- Sign in to stripe.
- Batch upload products to Wordpress.

- Group purchases.
- Add contact page.
- Customize my-account page.
- Set tax and payment methods.
- Make Rebecca an admin.
</t>
<t tx="ekr.20201118031649.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1739

PR: https://github.com/leo-editor/leo-editor/issues/1740

@language python
@nosearch
</t>
<t tx="ekr.20201118080056.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1743

@language python
@nosearch
</t>
<t tx="ekr.20201118090108.1">@language rest
@wrap


How to create your own Leo/Leo Vue site:

Create a folder
Create a leo file in the folder (See Leo Vue for more info about Leo).
Download index.html from this repo (https://github.com/kaleguy/leo-examples) to the folder
Edit settings in index.html
Upload your folder to github pages or other server.

Installed docker for desktop.
Installed kernel update.

Run with Docker

docker build -t leovue .
docker run -p 8080:8080 leovue
</t>
<t tx="ekr.20201118194139.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1742

@language python
@nosearch
</t>
<t tx="ekr.20201118195915.1"></t>
<t tx="ekr.20201119104633.1"></t>
<t tx="ekr.20201119113415.1">************* Module leo.commands.killBufferCommands
killBufferCommands.py:297:16: E1102: self.kbiterator.next is not callable (not-callable)

************* Module leo.core.leoKeys
leoKeys.py:3135:12: E1102: handler is not callable (not-callable)

************* Module leo.core.leoRst
leoRst.py:1804:8: E1121: Too many positional arguments for method call (too-many-function-args)
leoRst.py:1991:8: E1120: No value for argument 'p' in method call (no-value-for-parameter)

************* Module leo.plugins.active_path
active_path.py:284:16: E1120: No value for argument 'a' in function call (no-value-for-parameter)

************* Module leo.plugins.bookmarks
bookmarks.py:489:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
bookmarks.py:544:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.cursesGui2
cursesGui2.py:481:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:2740:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:2974:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3122:4: W0222: Signature differs from overridden 'display' method (signature-differs)
cursesGui2.py:3128:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3134:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3298:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3756:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3976:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.demo
demo.py:31:8: E1101: Instance of 'LeoApp' has no 'next' member (no-member)
demo.py:39:8: E1101: Instance of 'LeoApp' has no 'prev' member (no-member)
demo.py:47:8: E1101: Instance of 'LeoApp' has no 'end' member (no-member)
demo.py:274:28: E1102: self.next is not callable (not-callable)
demo.py:276:24: E1102: self.next is not callable (not-callable)
demo.py:727:17: E1101: Instance of 'LeoApp' has no 'pane_widget' member (no-member)
demo.py:732:8: E1101: Instance of 'LeoApp' has no 'widgets' member (no-member)
demo.py:745:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:766:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:787:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:795:17: E1101: Instance of 'LeoApp' has no 'pane_widget' member (no-member)
demo.py:799:8: E1101: Instance of 'LeoApp' has no 'widgets' member (no-member)
demo.py:806:13: E1101: Instance of 'LeoApp' has no 'get_icon_fn' member (no-member)
demo.py:824:20: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:825:20: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:833:12: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:844:17: E1101: Instance of 'LeoApp' has no 'pane_widget' member (no-member)
demo.py:848:8: E1101: Instance of 'LeoApp' has no 'widgets' member (no-member)
demo.py:855:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:859:25: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:860:24: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:893:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:902:12: E1101: Instance of 'LeoApp' has no 'find_node' member (no-member)
demo.py:904:25: E1101: Instance of 'LeoApp' has no 'headline_geometry' member (no-member)

************* Module leo.plugins.importers.javascript
importers/javascript.py:520:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.notebook
notebook.py:74:12: E0611: No name 'QtQuick' in module 'PyQt5' (no-name-in-module)

************* Module leo.plugins.python_terminal
python_terminal.py:76:12: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
python_terminal.py:294:16: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.quicksearch
quicksearch.py:249:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.read_only_nodes
read_only_nodes.py:167:12: W0707: Consider explicitly re-raising using the 'from' keyword (raise-missing-from)
read_only_nodes.py:200:12: W0707: Consider explicitly re-raising using the 'from' keyword (raise-missing-from)
read_only_nodes.py:221:12: W0707: Consider explicitly re-raising using the 'from' keyword (raise-missing-from)

************* Module leo.plugins.screencast
screencast.py:622:16: E1102: m.next is not callable (not-callable)
screencast.py:683:12: E1102: m.next is not callable (not-callable)
screencast.py:689:12: E1102: m.next is not callable (not-callable)
screencast.py:691:12: E1102: m.next is not callable (not-callable)
screencast.py:693:12: E1102: m.prev is not callable (not-callable)

************* Module leo.plugins.stickynotes_plus
stickynotes_plus.py:184:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
</t>
<t tx="ekr.20201119114229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1746

@language python
@nosearch
</t>
<t tx="ekr.20201119120953.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1747

@language python
@nosearch
</t>
<t tx="ekr.20201120061256.1">c:\leo.repo&gt;cd leovue

c:\leo.repo\leovue&gt;docker build -t leovue .
[+] Building 134.7s (14/14) FINISHED
 =&gt; [internal] load .dockerignore                                                                                  0.1s
 =&gt; =&gt; transferring context: 180B                                                                                  0.0s
 =&gt; [internal] load build definition from Dockerfile                                                               0.1s
 =&gt; =&gt; transferring dockerfile: 411B                                                                               0.0s
 =&gt; [internal] load metadata for docker.io/library/node:8                                                          2.9s
 =&gt; [1/9] FROM docker.io/library/node:8@sha256:a681bf74805b80d03eb21a6c0ef168a976108a287a74167ab593fc953aac34df   30.6s
 =&gt; =&gt; resolve docker.io/library/node:8@sha256:a681bf74805b80d03eb21a6c0ef168a976108a287a74167ab593fc953aac34df    0.0s
 =&gt; =&gt; sha256:a681bf74805b80d03eb21a6c0ef168a976108a287a74167ab593fc953aac34df 1.42kB / 1.42kB                     0.0s
 =&gt; =&gt; sha256:ee25271e00572cb09d095f6b35880a284eac570c17452644bc67fd1d8dc7f9f7 2.21kB / 2.21kB                     0.0s
 =&gt; =&gt; sha256:146bd6a886182fde06fbf747470b1c89814bc8ab1c96fdf1aef6107171959fe6 45.38MB / 45.38MB                  10.3s
 =&gt; =&gt; sha256:db0efb86e80601b5bbdbb7c406426982c4202d339687c14c3941b364527e2249 4.34MB / 4.34MB                     2.3s
 =&gt; =&gt; sha256:8eeadf3757f41ffbde6fbb4bbbe14f9f5b9ce33cc1aa88bb5c0b4d6e9467509d 7.76kB / 7.76kB                     0.0s
 =&gt; =&gt; sha256:9935d0c62ace92b388be202275e222007d6cac10b9c1f2c1ea63af38c09ea7ab 10.80MB / 10.80MB                   3.1s
 =&gt; =&gt; sha256:e705a4c4fd310b96bfb3d7928428e65f0d3f5bad0cd0bda1434aee1d89418468 50.07MB / 50.07MB                  12.3s
 =&gt; =&gt; sha256:c877b722db6f4d4297c21f07162d21fa6ac6f51d03360f75e24cfa3bcaefe57d 214.84MB / 214.84MB                24.0s
 =&gt; =&gt; sha256:645c20ec82147f2bdc182280ac02b60687cfac33c4231059051bbdcf60e31035 4.16kB / 4.16kB                    11.0s
 =&gt; =&gt; extracting sha256:146bd6a886182fde06fbf747470b1c89814bc8ab1c96fdf1aef6107171959fe6                          4.1s
 =&gt; =&gt; sha256:db8fbd9db2fe6382804432552a60f85b0e292cdb34b8a5c751c4a3061f68df29 19.40MB / 19.40MB                  14.3s
 =&gt; =&gt; sha256:1c151cd1b3eabced84742529489b3c8c344181b4cbcdcfccdb1f4a7c7d0239ec 1.40MB / 1.40MB                    13.0s
 =&gt; =&gt; sha256:fbd993995f407f3681fc8399ae67c04bba8e15c7f754b1af8b37f50b35f4a11e 292B / 292B                        13.7s
 =&gt; =&gt; extracting sha256:9935d0c62ace92b388be202275e222007d6cac10b9c1f2c1ea63af38c09ea7ab                          0.8s
 =&gt; =&gt; extracting sha256:db0efb86e80601b5bbdbb7c406426982c4202d339687c14c3941b364527e2249                          0.3s
 =&gt; =&gt; extracting sha256:e705a4c4fd310b96bfb3d7928428e65f0d3f5bad0cd0bda1434aee1d89418468                          5.5s
 =&gt; =&gt; extracting sha256:c877b722db6f4d4297c21f07162d21fa6ac6f51d03360f75e24cfa3bcaefe57d                          4.9s
 =&gt; =&gt; extracting sha256:645c20ec82147f2bdc182280ac02b60687cfac33c4231059051bbdcf60e31035                          0.0s
 =&gt; =&gt; extracting sha256:db8fbd9db2fe6382804432552a60f85b0e292cdb34b8a5c751c4a3061f68df29                          0.8s
 =&gt; =&gt; extracting sha256:1c151cd1b3eabced84742529489b3c8c344181b4cbcdcfccdb1f4a7c7d0239ec                          0.1s
 =&gt; =&gt; extracting sha256:fbd993995f407f3681fc8399ae67c04bba8e15c7f754b1af8b37f50b35f4a11e                          0.0s
 =&gt; [internal] load build context                                                                                  3.4s
 =&gt; =&gt; transferring context: 98.65MB                                                                               3.3s
 =&gt; [2/9] RUN node --version                                                                                       2.8s
 =&gt; [3/9] RUN npm --version                                                                                        0.6s
 =&gt; [4/9] RUN apt-get update &amp;&amp; apt-get install -y build-essential &amp;&amp; apt-get -y install sudo                      6.0s
 =&gt; [5/9] RUN mkdir -p /usr/src/app                                                                                0.5s
 =&gt; [6/9] WORKDIR /usr/src/app                                                                                     0.0s
 =&gt; [7/9] COPY package.json /usr/src/app/                                                                          0.0s
 =&gt; [8/9] COPY . /usr/src/app                                                                                      0.5s
 =&gt; [9/9] RUN npm install                                                                                         83.2s
 =&gt; exporting to image                                                                                             7.4s
 =&gt; =&gt; exporting layers                                                                                            7.3s
 =&gt; =&gt; writing image sha256:9669cb5783882380c8ac61361b4f4d0a80645646a4b95467eca67fe95fed2359                       0.0s
 =&gt; =&gt; naming to docker.io/library/leovue                                                                          0.1s

c:\leo.repo\leovue&gt;</t>
<t tx="ekr.20201120061449.1">c:\leo.repo\leovue&gt;docker run -p 8080:8080 leovue

&gt; leo-vue@2.0.2 dev /usr/src/app
&gt; node build/dev-server.js

 wdm: wait until bundle finished:
[BABEL] Note: The code generator has deoptimised the styling of "/usr/src/app/node_modules/bootstrap-vue/esm/icons/icons.js" as it exceeds the max of "500KB".
 DONE  Compiled successfully in 36240ms12:14:37

 wdm: Hash: bceb58d1acc6117a234f
Version: webpack 3.12.0
Time: 47240ms
     Asset     Size  Chunks                    Chunk Names
    app.js  30.5 MB       0  [emitted]  [big]  app
index.html  11.3 kB          [emitted]
   [0] ./node_modules/vue-awesome/components/Icon.vue 1.65 kB {0} [built]
 [810] multi ./build/dev-client ./src/main.js 40 bytes {0} [built]
 [811] ./build/dev-client.js 254 bytes {0} [built]
 [827] ./src/main.js 6.87 kB {0} [built]
[3250] ./src/components/MathJax.vue 2.08 kB {0} [built]
[3253] ./src/components/layout/ImageLeft.vue 2.11 kB {0} [built]
[3256] ./src/components/LVTimeline.vue 2.09 kB {0} [built]
[3260] ./src/components/WordCloud.vue 2.09 kB {0} [built]
[3298] ./src/components/Kanban.vue 2.42 kB {0} [built]
[3302] ./src/components/MermaidBoard.vue 2.1 kB {0} [built]
[3306] ./src/components/D3Board.vue 2.08 kB {0} [built]
[3309] ./node_modules/vue-table-component/dist/index.js 160 kB {0} [built]
[3311] ./src/components/SummaryTable.vue 2.1 kB {0} [built]
[3314] ./src/components/TagSearch.vue 2.09 kB {0} [built]
[3318] ./node_modules/vuewordcloud/index.js 13.3 kB {0} [built]
    + 3312 hidden modules
Child html-webpack-plugin for "index.html":
         Asset     Size  Chunks  Chunk Names
    index.html  1.48 MB       0
       [0] ./node_modules/html-webpack-plugin/lib/loader.js!./index.html 12.3 kB {0} [built]
       [1] ./node_modules/lodash/lodash.js 543 kB {0} [built]
       [2] (webpack)/buildin/global.js 509 bytes {0} [built]
       [3] (webpack)/buildin/module.js 517 bytes {0} [built]
 wdm: Compiled successfully.
&gt; Listening at http://localhost:8080
</t>
<t tx="ekr.20201120061944.1">@language rest
@wrap

git clone https://github.com/kaleguy/leovue.git leovue

- Study app.js in original form.
- Compare before/after build for index.html.
- Use plain build, not docker.

- Check bit defender permissions.
- Change title to LeoVue2 and see what happens.

Download MathJax, Revealjs, Mermaid.

build-leovue:
cd c:\leo.repo\leovue
docker build -t leovue .

run-leovue:
cd c:\leo.repo\leovue
docker run -p 8080:8080 leovue

moz localhost:8080

Docker Commands:

    docker ps -a
    docker system prune
    docker kill &lt;id&gt;
    
See the main.js file in the LeoVue source for how other components are included with LeoVue.</t>
<t tx="ekr.20201121062544.1">@language rest
@wrap

From https://kaleguy.github.io/leo-examples/

How to create your own Leo/Leo Vue site:

- Create a folder
- Create a leo file in the folder (See Leo Vue for more info about Leo).
- Download index.html from this repo to the folder
- Edit settings in index.html
  The default filename is docs (docs.leo)
- Upload your folder to github pages or other server.

Note that if your Leo file contains diagrams, youll need to include Onsen and Mermaid (see the Diagram Example)</t>
<t tx="ekr.20201121085817.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1748

regex fails with replace-all

@language python
@nosearch
</t>
<t tx="ekr.20201122121724.1">@language rest
@wrap

- Fix more icons. When done, send url for ekr.com to Linda.
- Use local .js files.
- Use https instead of http for EKR.com
- Study powershell.</t>
<t tx="ekr.20201122134617.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1749

@language python
@nosearch
</t>
<t tx="ekr.20201122165543.1"></t>
<t tx="ekr.20201122165606.1"></t>
<t tx="ekr.20201123163439.1">@language rest
@wrap

This kind of error suggests that the script your browser loads is intended for nodejs scripting environment not for the browser.  In order to be used in the webpage this scripts must be transformed or repackaged.

IIRC leo-vue uses webpack as build tool. The build tool (whatever it might be) bundles all separate javascript files in one big javascript file. That file should be loaded in the webpage. It means that the script tag in your index.html needs a src attribute to be correctly set to load this big javascript which contains all separate files bundled together.

Look in the webpack configuration file to find out where the result of build process should be and then adjust `&lt;scirpt src=""&gt;` inside your index.html to the correct path.</t>
<t tx="ekr.20201123183452.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1754

w.see works for the first time ever!

@language python
@nosearch
</t>
<t tx="ekr.20201124105426.1">c:\leo.repo\leovue&gt;docker build -t leovue .
[+] Building 93.9s (14/14) FINISHED
 =&gt; [internal] load .dockerignore                                                                                  0.1s
 =&gt; =&gt; transferring context: 170B                                                                                  0.0s
 =&gt; [internal] load build definition from Dockerfile                                                               0.0s
 =&gt; =&gt; transferring dockerfile: 391B                                                                               0.0s
 =&gt; [internal] load metadata for docker.io/library/node:8                                                          1.6s
 =&gt; [1/9] FROM docker.io/library/node:8@sha256:a681bf74805b80d03eb21a6c0ef168a976108a287a74167ab593fc953aac34df    0.0s
 =&gt; [internal] load build context                                                                                  1.4s
 =&gt; =&gt; transferring context: 97.09MB                                                                               1.3s
 =&gt; CACHED [2/9] RUN node --version                                                                                0.0s
 =&gt; CACHED [3/9] RUN npm --version                                                                                 0.0s
 =&gt; CACHED [4/9] RUN apt-get update &amp;&amp; apt-get install -y build-essential &amp;&amp; apt-get -y install sudo               0.0s
 =&gt; CACHED [5/9] RUN mkdir -p /usr/src/app                                                                         0.0s
 =&gt; CACHED [6/9] WORKDIR /usr/src/app                                                                              0.0s
 =&gt; CACHED [7/9] COPY package.json /usr/src/app/                                                                   0.0s
 =&gt; [8/9] COPY . /usr/src/app                                                                                      0.5s
 =&gt; [9/9] RUN npm install                                                                                         83.3s
 =&gt; exporting to image                                                                                             6.9s
 =&gt; =&gt; exporting layers                                                                                            6.9s
 =&gt; =&gt; writing image sha256:97a641aaedb86bbdfcb0a4e20b00181cec74625f4a31dd16518211a101c74c91                       0.0s
 =&gt; =&gt; naming to docker.io/library/leovue                                                                          0.0s
</t>
<t tx="ekr.20201124191844.1">@g.commander_command('reformat-selection')
def reformatSelection(self, event=None, undoType='Reformat Paragraph'):
    """
    Reformat the selected text, as in reformat-paragraph, but without
    expanding the selection past the selected lines.
    """
    c, undoType = self, 'reformat-selection'
    p, u, w = c.p, c.undoer, c.frame.body.wrapper
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    bunch = u.beforeChangeBody(p)
    oldSel, oldYview, original, pageWidth, tabWidth = rp_get_args(c)
    head, middle, tail = c.frame.body.getSelectionLines()
    lines = g.splitLines(middle)
    if not lines:
        return
    indents, leading_ws = rp_get_leading_ws(c, lines, tabWidth)
    result = rp_wrap_all_lines(c, indents, leading_ws, lines, pageWidth)
    s = head + result + tail
    if s == original:
        return
    #
    # Update the text and the selection.
    w.setAllText(s)  # Destroys coloring.
    i = len(head)
    j = max(i, len(head) + len(result) - 1)
    j = min(j, len(s))
    w.setSelectionRange(i, j, insert=j)
    #
    # Finish.
    p.v.b = s  # p.b would cause a redraw.
    u.afterChangeBody(p, undoType, bunch)
    w.setXScrollPosition(0)  # Never scroll horizontally.
</t>
<t tx="ekr.20201125041840.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1751

File "C:\Programs\Leo\leo\plugins\quicksearch.py", line 733, in onSelectItem
    indent = len(cur.text()) - len(str(cur.text()).lstrip())
AttributeError: 'NoneType' object has no attribute 'text'

@language python
@nosearch
</t>
<t tx="ekr.20201127035748.1">def updateAfterTyping(self, p, w):
    """
    Perform all update tasks after changing body text.
    
    This is ugly, ad-hoc code, but should be done uniformly.
    """
    c = self.c
    if g.isTextWrapper(w):
        # An important, ever-present unit test.
        all = w.getAllText()
        if g.unitTesting:
            assert p.b == all, g.callers()
        elif p.b != all:
            g.trace(f"\nError:p.b != w.getAllText() p:{p.h} {g.callers()}\n")
            # g.printObj(g.splitLines(p.b), tag='p.b')
            # g.printObj(g.splitLines(all), tag='getAllText')
        p.v.insertSpot = ins = w.getInsertPoint()
        # From u.doTyping.
        newSel = w.getSelectionRange()
        if newSel is None:
            p.v.selectionStart, p.v.selectionLength = (ins, 0)
        else:
            i, j = newSel
            p.v.selectionStart, p.v.selectionLength = (i, j - i)
    else:
        if g.unitTesting:
            assert False, f"Not a text wrapper: {g.callers()}"
        g.trace('Not a text wrapper')
        p.v.insertSpot = 0
        p.v.selectionStart, p.v.selectionLength = (0, 0)
    #
    # #1749.
    if p.isDirty():
        redraw_flag = False
    else:
        p.setDirty() # Do not call p.v.setDirty!
        redraw_flag = True
    if not c.isChanged():
        c.setChanged()
    # Update editors.
    c.frame.body.updateEditors()
    # Update icons.
    val = p.computeIcon()
    if not hasattr(p.v, "iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
    #
    # Recolor the body.
    c.frame.scanForTabWidth(p)  # Calls frame.setTabWidth()
    c.recolor()
    if g.app.unitTesting:
        g.app.unitTestDict['colorized'] = True
    if redraw_flag:
        c.redraw_after_icons_changed()
    w.setFocus()
</t>
<t tx="ekr.20201127072229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1759

@language python
@nosearch
</t>
<t tx="ekr.20201127072238.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1757

k.doBinding and k.getPaneBinding fix the primary issue.

vc.vim_dot fixes a secondary issue, described in #1757.

@language python
@nosearch
</t>
<t tx="ekr.20201127143342.1">def see_more_lines(s, ins, n=4):
    """
    Extend index i within string s to include n more lines.
    """
    # Show more lines, if they exist.
    if n &gt; 0:
        for z in range(n):
            if ins &gt;= len(s):
                break
            i, j = g.getLine(s, ins)
            ins = j
    return max(0, min(ins, len(s)))
</t>
<t tx="ekr.20201128042351.1"></t>
<t tx="ekr.20201128042437.1"></t>
<t tx="ekr.20201128043237.1"></t>
<t tx="ekr.20201128045435.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1760

These seem harmless, but they are mysterious.

@language python
@nosearch


</t>
<t tx="ekr.20201128050540.1">c:\leo.repo\leo-editor&gt;python c:\leo.repo\leo-editor\launchLeo.py --no-splash --gui=qttabs leo\core\leoPy.leo

Leo 6.4-devel, ekr-undo branch, build d1ba6bc993

2020-11-27 15:02:52 -0600
wrote recent file: C:/Users/edreamleo/.leo/.leoRecentFiles.txt
pylint: leoKeys.py
pylint finished
Starting log_listener.py
About to start TCP server...
--------------------
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-line-number-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-line-number-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-md-line-number-test.md
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-md-line-number-test.md
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-section-ref-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-section-ref-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-unit-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-unit-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-org-line-number-test.org
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-org-line-number-test.org
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-otl-line-number-test.otl
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-otl-line-number-test.otl
   pr: wrote recent file: C:/Users/edreamleo/.leo/.leoRecentFiles.txt
   pr: Saving: c:/leo.repo/leo-editor/leo/test/unitTest.leo
listener suspended
killed log listener.

c:\leo.repo\leo-editor&gt;</t>
<t tx="ekr.20201128051459.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1733

@language python
@nosearch
</t>
<t tx="ekr.20201128052211.1">@nosearch

# flattened, word, ignore-case, body

# found 22 nodes</t>
<t tx="ekr.20201128125708.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1758

**After** the sabbatical:

- Enable tests of selection range.
- Enable tests of undo/redo.
- Rename 'directives' kwarg to 'parent_b'.
- Remove tempNode.
- (Maybe): run-all-tests command.

@language python
@nosearch
</t>
<t tx="ekr.20201128132124.1"></t>
<t tx="ekr.20201128132228.1"></t>
<t tx="ekr.20201128132310.1"></t>
<t tx="ekr.20201128132526.1"></t>
<t tx="ekr.20201128133405.1"></t>
<t tx="ekr.20201128133541.1"></t>
<t tx="ekr.20201128164717.1"></t>
<t tx="ekr.20201128164717.10">first line
    line 1
        line a
            line b
    line c
last line
</t>
<t tx="ekr.20201128164717.100">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.101">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.102">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.103">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.104">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.105">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.106">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.107">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.108">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.109"></t>
<t tx="ekr.20201128164717.11">vr = c.helpCommands.helpForBindings()
if not vr:
    self.skipTest('no vr plugin')
</t>
<t tx="ekr.20201128164717.110">from leo.core import leoBeautify
from leo.commands import convertCommands
cpp = leoBeautify.CPrettyPrinter(c)
# c2p = convertCommands.C_To_Python(c)
fn = 'c tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)
aList = cpp.tokenize(p2.b)
assert aList
# c2p.convertCodeList(aList)
# s = ''.join(aList)
</t>
<t tx="ekr.20201128164717.111">@language c

static exit_values_ty indent_main_loop(void)
{
    codes_ty         hd_type         = code_eof;
    char           * t_ptr           = NULL;
    codes_ty         type_code       = start_token;
    exit_values_ty   file_exit_value = total_success;
    int              dec_ind         = 0; /* current indentation for declarations */

    BOOLEAN          scase           = false; /* true when we've just see a "case";
                                               * determines what to do with the
                                               * following colon */
    BOOLEAN          flushed_nl;              /* Used when buffering up comments to remember that
                                               * a newline was passed over */
    BOOLEAN          sp_sw           = false; /* true when in the expression part of if(...),
                                               * while(...), etc. */
    BOOLEAN          force_nl        = false;

    /* last_token_ends_sp: True if we have just encountered the end of an if (...),
     * etc. (i.e. the ')' of the if (...) was the last token).  The variable is
     * set to 2 in the middle of the main token reading loop and is decremented
     * at the beginning of the loop, so it will reach zero when the second token
     * after the ')' is read.
     */

    BOOLEAN          last_token_ends_sp = false;

    BOOLEAN          last_else = false; /* true if last keyword was an else */

    for (;;)
    {
        /* this is the main loop.  it will go until
         * we reach eof */

        BOOLEAN is_procname_definition;
        bb_code_ty can_break;

        if (type_code != newline)
        {
            can_break = parser_state_tos-&gt;can_break;
        }

        parser_state_tos-&gt;last_saw_nl = false;
        parser_state_tos-&gt;can_break = bb_none;

        type_code = lexi ();    /* lexi reads one token.  "token" points to
                                 * the actual characters. lexi returns a code
                                 * indicating the type of token */

        /* If the last time around we output an identifier or
         * a paren, then consider breaking the line here if it's
         * too long.
         *
         * A similar check is performed at the end of the loop, after
         * we've put the token on the line. */

        if ((settings.max_col &gt; 0) &amp;&amp;
            (buf_break != NULL) &amp;&amp;
            ( ( (parser_state_tos-&gt;last_token == ident) &amp;&amp;
                (type_code != comma) &amp;&amp;
                (type_code != semicolon) &amp;&amp;
                (type_code != newline) &amp;&amp;
                (type_code != form_feed) &amp;&amp;
                (type_code != rparen) &amp;&amp;
                (type_code != struct_delim)) ||
              ( (parser_state_tos-&gt;last_token == rparen) &amp;&amp;
                (type_code != comma) &amp;&amp;
                (type_code != rparen) ) ) &amp;&amp;
            (output_line_length () &gt; settings.max_col))
        {
            break_line = 1;
        }

        if (last_token_ends_sp &gt; 0)
        {
            last_token_ends_sp--;
        }

        is_procname_definition =
                (((parser_state_tos-&gt;procname[0] != '\0') &amp;&amp;
                  parser_state_tos-&gt;in_parameter_declaration) ||
                 (parser_state_tos-&gt;classname[0] != '\0'));

        /* The following code moves everything following an if (), while (),
         * else, etc. up to the start of the following stmt to a buffer. This
         * allows proper handling of both kinds of brace placement.
         */

        flushed_nl = false;

        if (!search_brace(&amp;type_code, &amp;force_nl, &amp;flushed_nl, &amp;last_else, &amp;is_procname_definition))
        {
            /* Hit EOF unexpectedly in comment. */
            return indent_punt;
        }
        
        if (type_code == code_eof)
        {
            /* we got eof */
            if (s_lab != e_lab || s_code != e_code || s_com != e_com)   /* must dump end of line */
            {
                dump_line(true, &amp;paren_target);
            }

            if (parser_state_tos-&gt;tos &gt; 1)      /* check for balanced braces */
            {
                ERROR (_("Unexpected end of file"), 0, 0);
                file_exit_value = indent_error;
            }

            if (settings.verbose)
            {
                printf (_("There were %d non-blank output lines and %d comments\n"),
                        (int) out_lines, (int) com_lines);
                if (com_lines &gt; 0 &amp;&amp; code_lines &gt; 0)
                {
                    printf (_("(Lines with comments)/(Lines with code): %6.3f\n"),
                            (1.0 * com_lines) / code_lines);
                }
            }
            flush_output ();

            return file_exit_value;                                              /* RETURN */
        }

        if ((type_code != comment) &amp;&amp;
            (type_code != cplus_comment) &amp;&amp;
            (type_code != newline) &amp;&amp;
            (type_code != preesc) &amp;&amp;
            (type_code != form_feed))
        {
            if (force_nl &amp;&amp;
                (type_code != semicolon) &amp;&amp;
                ( (type_code != lbrace) ||
                  (!parser_state_tos-&gt;in_decl &amp;&amp; !settings.btype_2) ||
                  (parser_state_tos-&gt;in_decl &amp;&amp; !settings.braces_on_struct_decl_line) ||
                  (parser_state_tos-&gt;last_token == rbrace)))
            {
                if (settings.verbose &amp;&amp; !flushed_nl)
                {
                    WARNING (_("Line broken 2"), 0, 0);
                }

                flushed_nl = false;
                dump_line(true, &amp;paren_target);
                parser_state_tos-&gt;want_blank = false;
                force_nl = false;
            }

            parser_state_tos-&gt;in_stmt = true;   /* turn on flag which causes
                                                 * an extra level of
                                                 * indentation. this is
                                                 * turned off by a ; or } */
            if (s_com != e_com)
            {
                /* the code has an embedded comment in the
                 * line. Move it from the com buffer to the
                 * code buffer.
                 *
                 * Do not add a space before the comment if it is the first
                 * thing on the line.
                 */

                if (e_code != s_code)
                {
                    set_buf_break (bb_embedded_comment_start, paren_target);
                    *e_code++ = ' ';
                    embedded_comment_on_line = 2;
                }
                else
                {
                    embedded_comment_on_line = 1;
                }

                for (t_ptr = s_com; *t_ptr; ++t_ptr)
                {
                    check_code_size();
                    *e_code++ = *t_ptr;
                }

                set_buf_break (bb_embedded_comment_end, paren_target);
                *e_code++ = ' ';
                *e_code = '\0'; /* null terminate code sect */
                parser_state_tos-&gt;want_blank = false;
                e_com = s_com;
            }
        }
        else if ((type_code != comment) &amp;&amp;
                 (type_code != cplus_comment) &amp;&amp;
                 !(settings.break_function_decl_args &amp;&amp;
                   (parser_state_tos-&gt;last_token == comma)) &amp;&amp;
                 !( (parser_state_tos-&gt;last_token == comma) &amp;&amp;
                    !settings.leave_comma))
        {
            /* preserve force_nl thru a comment but
             * cancel forced newline after newline, form feed, etc.
             * however, don't cancel if last thing seen was comma-newline
             * and -bc flag is on. */

            force_nl = false;
        }

        /* Main switch on type of token scanned */

        check_code_size();
        
        /* now, decide what to do with the token */

        handle_the_token(type_code, &amp;scase, &amp;force_nl, &amp;sp_sw, &amp;flushed_nl,
                         &amp;hd_type, &amp;dec_ind, &amp;last_token_ends_sp, &amp;file_exit_value,
                         can_break, &amp;last_else, is_procname_definition);
        
        *e_code = '\0';         /* make sure code section is null terminated */

        if ((type_code != comment) &amp;&amp;
            (type_code != cplus_comment) &amp;&amp;
            (type_code != newline) &amp;&amp;
            (type_code != preesc) &amp;&amp;
            (type_code != form_feed))
        {
            parser_state_tos-&gt;last_token = type_code;
        }

        /* Now that we've put the token on the line (in most cases),
         * consider breaking the line because it's too long.
         *
         * Don't consider the cases of `unary_op', newlines,
         * declaration types (int, etc.), if, while, for,
         * identifiers (handled at the beginning of the loop),
         * periods, or preprocessor commands. */

        if ((settings.max_col &gt; 0) &amp;&amp; (buf_break != NULL))
        {
            if ( ( (type_code == binary_op) ||
                   (type_code == postop) ||
                   (type_code == question) ||
                   ((type_code == colon) &amp;&amp; (scase || (squest &lt;= 0))) ||
                   (type_code == semicolon) ||
                   (type_code == sp_nparen) ||
                   (type_code == sp_else) ||
                   ((type_code == ident) &amp;&amp; (*token == '\"')) ||
                   (type_code == struct_delim) ||
                   (type_code == comma)) &amp;&amp;
                 (output_line_length () &gt; settings.max_col))
            {
                break_line = 1;
            }
        }
    }                           /* end of main infinite loop */
}
</t>
<t tx="ekr.20201128164717.112">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.113">first line
line 1
    Line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.114">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.115">first line
line 1
    Line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.116">@pagewidth 70 # Required for unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.117">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.118">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.119">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.12">vr = c.helpCommands.helpForFindCommands()
if not vr:
    self.skipTest('no vr plugin')
</t>
<t tx="ekr.20201128164717.120">@pagewidth 70 # Required for unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.121">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20201128164717.122">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20201128164717.123">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20201128164717.124">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.125"># Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
</t>
<t tx="ekr.20201128164717.126"># Should remove all trailing whitespace.

a = 2   
    
    b = 3
    c  = 4  
d = 5
e = 6  
x
</t>
<t tx="ekr.20201128164717.127"># Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
</t>
<t tx="ekr.20201128164717.128">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.129">first line
line    line b
line c
last line
</t>
<t tx="ekr.20201128164717.13">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.130">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.131">first line
line    line b
line c
last line
</t>
<t tx="ekr.20201128164717.132">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    exec(g.findTestScript(c,'@common x-marked-nodes test code'))
    
    def test(p):
        target = p.copy()
        setup_test(p)
        c.cloneMarked()
        h = 'Clones of marked nodes'
        assert c.p.h == h,c.p.h
        c.undoer.undo()
        assert not g.findNodeAnywhere(c,h)
        c.undoer.redo()
        assert c.p.h == h, c.p.h
    try:
        test(p)
    finally:
        tear_down(p,'Clones of marked nodes')
</t>
<t tx="ekr.20201128164717.133"></t>
<t tx="ekr.20201128164717.136"></t>
<t tx="ekr.20201128164717.137"></t>
<t tx="ekr.20201128164717.138"></t>
<t tx="ekr.20201128164717.139"></t>
<t tx="ekr.20201128164717.14">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.140"></t>
<t tx="ekr.20201128164717.141">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.142">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.143">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.144">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.145"># main after
# mainto

ac = c.abbrevCommands
w = c.frame.body.wrapper
s = w.getAllText()
w.setInsertPoint(4)
# i,j = g.getWord(s,4)
# word = s[i:j]
event = g.bunch(widget=w)
ac.dynamicCompletion(event)
try:
    i = s.find('main')
    assert i == 2,i
finally:
    if 1:
        c.undoer.undo(event=event)

</t>
<t tx="ekr.20201128164717.146"># main after
# mainto

ac = c.abbrevCommands
w = c.frame.body.wrapper
s = w.getAllText()
w.setInsertPoint(4)
i,j = g.getWord(s,4)
word = s[i:j]
aList = ac.getDynamicList(w,word)
c.k.arg = aList[1]
event = g.bunch(char=None, stroke=None, widget=w)
ac.dynamicExpandHelper(event)
    # This *does* support undo.
s = w.getAllText()
try:
    i = s.find('main')
    assert i == 2,i
finally:
    if 0:
        c.undoer.undo()
</t>
<t tx="ekr.20201128164717.147">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.148">firstline
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.149">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.15">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.150">firstline
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.151">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.152">first line
line 1
last line
</t>
<t tx="ekr.20201128164717.153">first line
    line 1
last line
</t>
<t tx="ekr.20201128164717.154">first line
line 1
last line
</t>
<t tx="ekr.20201128164717.155">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    exec(g.findTestScript(c,'@common x-marked-nodes test code'))
    
    def test(p):
        setup_test(p)
        c.deleteMarked()
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
        c.undoer.undo()
        n = p.numberOfChildren()
        assert n == 4,'undo: children: %s' % (n)
        c.undoer.redo()
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
    try:
        test(p)
    finally:
        tear_down(p)
</t>
<t tx="ekr.20201128164717.156">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.157">first line
line 1
line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.158">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.159">first line
line 1
line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.16">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.160">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.161">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.162">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.163">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.164">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.165">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.166">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.167">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.168">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.169">xyzzy line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.17">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.170">XYZZY line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.171">xyzzy line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.172">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.173">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.174">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.175">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.176">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.177">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.178">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.179">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.18">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.180">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.181">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.182">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.183">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.184">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.185">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.186">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.187">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.188">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.189">first line

line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.19">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.190">first line

line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.191">first line

line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.192">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.193">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.194">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.195">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.196">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.197">first line
line 1
    line a
        line b
line c
last non-blank line
 
</t>
<t tx="ekr.20201128164717.198">first line
line 1
    line a
        line b
line c
last non-blank line
 
</t>
<t tx="ekr.20201128164717.199">first line
line 1
    line a
        line b
line c
last non-blank line
 
</t>
<t tx="ekr.20201128164717.2"></t>
<t tx="ekr.20201128164717.20">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.200">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.201">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.202">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.203">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.204">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.205">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.206">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.207">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.208">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.209">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.21">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.210">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.211">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.212"># Test of bug 930726: expandNodeAndGoToFirstChild only expands or only goes to first child .

p.contract()
c.expandNodeAndGoToFirstChild()
assert c.p == p.firstChild()
</t>
<t tx="ekr.20201128164717.213"></t>
<t tx="ekr.20201128164717.214">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.215">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.216">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.217">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.218">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.219">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.22">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.220">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.221">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.222">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.223">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.224">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.225">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.226">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.227">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.228">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.229">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.23">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.230">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.231">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.232">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.233">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.234">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.235">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.236">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.237">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.238">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.239">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.24">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.240">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.241">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.242"></t>
<t tx="ekr.20201128164717.245"></t>
<t tx="ekr.20201128164717.246"></t>
<t tx="ekr.20201128164717.247"></t>
<t tx="ekr.20201128164717.248"></t>
<t tx="ekr.20201128164717.249"></t>
<t tx="ekr.20201128164717.25">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.250"></t>
<t tx="ekr.20201128164717.251">@pagewidth 80
    # Required for external unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.252">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.253">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially
declared disasters are weather related,
leading to around 500 deaths per year
and nearly $14 billion in damage.
StormReady, a program
started in 1999 in Tulsa, OK,
helps arm America's
communities with the communication and
safety skills needed to save lives and
property--before and during the event.
StormReady helps community leaders and
emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.254">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.255">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.256">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.257">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.258">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.259">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.26">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.260">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.261">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.262">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.263">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.264">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.265">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.266">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.267">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.268">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.269">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.27">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.270">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.271">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.272">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.273">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.274">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.275">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.276">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.277">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.278">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.279">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.28">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.280">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.281">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.282">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.283">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.284">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.285">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.286">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.287">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.288">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.289">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.29">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.290">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.291">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.292">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.293">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.294">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.295">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.296">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.297">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.298">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.299">p = c.p.copy()
c.selectPosition(p.threadBack())
p1 = c.p
c.goPrevVisitedNode()
p2 = c.p
c.goNextVisitedNode()
p3 = c.p
</t>
<t tx="ekr.20201128164717.3">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.30">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.300">result = c.helpCommands.getBindingsForCommand('help')
if not result:
    self.skipTest('no settings')
assert result.strip().lower()=='f1', repr(result)
</t>
<t tx="ekr.20201128164717.301">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.302">first line
line 1
    line a
        line b
        line c
last line
</t>
<t tx="ekr.20201128164717.303">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.304">first line
line 1
    line a
        line b
        line c
last line
</t>
<t tx="ekr.20201128164717.305">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.306">first line
	line 1
	    line a
	        line b
	line c
last line
</t>
<t tx="ekr.20201128164717.307">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.308">first line
	line 1
	    line a
	        line b
	line c
last line
</t>
<t tx="ekr.20201128164717.309">c.editCommands.ccolumn = 4 # Set the comment column
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.31">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.310">first line
    line b
last line
</t>
<t tx="ekr.20201128164717.311">first line
line b
last line
</t>
<t tx="ekr.20201128164717.312">first line
    line b
last line
</t>
<t tx="ekr.20201128164717.313">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.314">first li
ne
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.315">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.316">first li
ne
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.317">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.318">first() line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.319">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.32">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.320">first() line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.321">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.322">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.323">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.324">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.325">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.326">This is the first sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.327">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.328">This is the first sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.329">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.33">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.330">This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.331">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.332">This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.333"># To do: use tables as in the clean-c test.
</t>
<t tx="ekr.20201128164717.334">child = g.findNodeInChildren(c, p, 'syntax-error')
assert child, 'no child'
try:
    c.goToScriptLineNumber(1, child)
finally:
    p.contract()
    c.selectPosition(p)
    c.redraw()
</t>
<t tx="ekr.20201128164717.335">@language python
def spam:
    pass
</t>
<t tx="ekr.20201128164717.336">import sys
# Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
if not sys.platform.startswith('win'):
    self.skipTest('Requires Windows')
trace = False
h = '@auto unittest/at-auto-md-line-number-test.md'
root = g.findNodeAnywhere(c, h)
assert root
s = c.gotoCommands.get_external_file_with_sentinels(root)
if trace:
    print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
for n in range(20):
    p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
    if found:
        if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
    else:
        if trace: print('not found: %s' % (n+1))
        assert n == 8, n
        break
</t>
<t tx="ekr.20201128164717.337"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-org unittest/at-auto-org-line-number-test.org'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20201128164717.338"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-otl unittest/at-auto-otl-line-number-test.otl'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % n)
            assert n == 5, n
            break
</t>
<t tx="ekr.20201128164717.339">import sys
# Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
elif sys.platform.startswith('win'):
    trace = False
    root = p.parent().parent()
    # h = '@auto unittest/at-auto-line-number-test.py'
    h = '@auto unittest/at-auto-unit-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(25):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 12, n
            if trace: print('not found: %s' % (n+1))
            break
else:
    self.skipTest('Skip on Linux')
</t>
<t tx="ekr.20201128164717.34">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.340"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.c'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    lines = g.splitLines(s)
    stripped_lines = [z for z in lines if not z.startswith('//@')]
    if trace:
        # g.printList(stripped_lines)
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(lines)]))
    table = (
        # n is the 1-based offset of the *stripped* lines.
        # Directives do not appear in @clean files.
        # (1,     '@language c'),
        # (2,     '@tabwidth -4'),
        (3,     '// before @others // line 1'),
        # (4,     '@others'),
        # spam node.
        (1,     'def spam(): // line 2'),
        (2,     '    pass'),
        # eggs node.
        (1,    'def eggs(): // line 4'),
        (2,    '    pass'),
        # resume top node.
        (5,    '// last line: line 6'),
    )
    for n, data in enumerate(table):
        offset, line = data
        p, offset2, found = c.gotoCommands.find_file_line(n+1, p=target)
        assert offset == offset2, 'expected offset %s, got %s %r' % (
            offset, offset2, p and p.h)
    p, offset, found = c.gotoCommands.find_file_line(15, p=target)
    assert not found
</t>
<t tx="ekr.20201128164717.341"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20201128164717.342"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.c'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 10, n
            if trace: print('not found: %s' % n+1)
            break
</t>
<t tx="ekr.20201128164717.343"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 10, n
            if trace: print('not found: %s' % n+1)
            break
</t>
<t tx="ekr.20201128164717.344"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@nosent unittest/at-nosent-line-number-test.py'
    root = g.findNodeAnywhere(c, h)
    assert root
    assert root.isAtNoSentFileNode(), root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20201128164717.345"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    gnx = target.v.fileIndex
    assert gnx
    found = c.gotoCommands.find_gnx(root, gnx, h)
    assert found, 'not found'
</t>
<t tx="ekr.20201128164717.346">c.gotoCommands.success(lines=['a', 'b'], n=3, n2=3, p=p)
c.gotoCommands.fail(lines=['a', 'b'], n=3, root=p)

</t>
<t tx="ekr.20201128164717.347"></t>
<t tx="ekr.20201128164717.348"># First, we must remove the trailing newline from the 'after' line.
h = 'after sel=3.6,3.6'
p2 = g.findNodeInTree(c,p,h)
assert p2,h
s = p2.b
if s.endswith('\n'):
    p2.b = p2.b[:-1]
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.349">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.35">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.350">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.351">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.352">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.353">line 1
line 2

</t>
<t tx="ekr.20201128164717.354">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.355">line 1
line 2

</t>
<t tx="ekr.20201128164717.356">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.357">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.358">line 1
line 2
line 3
line 4
</t>
<t tx="ekr.20201128164717.359">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.36">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.360">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.361">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.362">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.363">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.364"></t>
<t tx="ekr.20201128164717.365"># First, we must remove the trailing newline from the 'after' line.
h = 'after sel=3.6,3.6'
p2 = g.findNodeInTree(c,p,h)
assert p2,h
s = p2.b
if s.endswith('\n'):
    p2.b = p2.b[:-1]
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.366">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.367">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.368">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.369">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.37">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.370">line 1
line 2line 3
</t>
<t tx="ekr.20201128164717.371">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.372">line 1
line 2line 3
</t>
<t tx="ekr.20201128164717.373">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.374">line 1
# The next line contains two trailing blanks.
line 3line 4
</t>
<t tx="ekr.20201128164717.375">line 1
# The next line contains two trailing blanks.
line 3  
line 4
</t>
<t tx="ekr.20201128164717.376">line 1
# The next line contains two trailing blanks.
line 3line 4
</t>
<t tx="ekr.20201128164717.377">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.378">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.379">line 1
line 2
line 3
line 4
</t>
<t tx="ekr.20201128164717.38">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.380">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.381">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.382">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.383">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.384">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.385">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.386">line 1
li
line 3
</t>
<t tx="ekr.20201128164717.387">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.388">line 1
li
line 3
</t>
<t tx="ekr.20201128164717.389"></t>
<t tx="ekr.20201128164717.39">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.390">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.391">first line
line 1
line c
    line a
        line b
last line
</t>
<t tx="ekr.20201128164717.392">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.393">first line
line 1
line c
    line a
        line b
last line
</t>
<t tx="ekr.20201128164717.394">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.395">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.396">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.397">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.398"># Test of bug 799695: colorizer bug after move-lines-up into a docstring

# import os ; os.system('cls')

n = c.frame.body.colorizer.full_recolor_count

c.testManager.runEditCommandTest(p)

# Not an effective test, even though the bug fix was to call
# c.recolor_now(incremental=False)

# g.trace(n,c.frame.body.colorizer.full_recolor_count)

# assert c.frame.body.colorizer.full_recolor_count &gt; n
</t>
<t tx="ekr.20201128164717.399">@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
</t>
<t tx="ekr.20201128164717.4">first line
 line 1
     line a
 line b
last line
</t>
<t tx="ekr.20201128164717.40">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.400">@language python
def test():
    """ a
    b
    c
    """
    print 1
    
    print 2
</t>
<t tx="ekr.20201128164717.401">@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
</t>
<t tx="ekr.20201128164717.402">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.403">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.404">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.405">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.406">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.407">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.408">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.409">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.41">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.410">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.411">first line
line 1
    
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.412">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.413">first line
line 1
    
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.414">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.415">a

b
</t>
<t tx="ekr.20201128164717.416">a

b
</t>
<t tx="ekr.20201128164717.417">a

b
</t>
<t tx="ekr.20201128164717.418">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.419">a

b
</t>
<t tx="ekr.20201128164717.42">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.420">a

b
</t>
<t tx="ekr.20201128164717.421">a

b
</t>
<t tx="ekr.20201128164717.422">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.423">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20201128164717.424">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.425">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20201128164717.426">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.427">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.428">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20201128164717.429">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.43">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.430">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.431">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.432">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.433">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.434">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.435">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.436">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.437">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.438">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.439">before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
</t>
<t tx="ekr.20201128164717.44">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.440">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.441">before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
</t>
<t tx="ekr.20201128164717.442">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.443">before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
</t>
<t tx="ekr.20201128164717.444">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.445">before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
</t>
<t tx="ekr.20201128164717.446">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.447">before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
</t>
<t tx="ekr.20201128164717.448">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.449">before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
</t>
<t tx="ekr.20201128164717.45">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.450">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.451">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.452">first line

line 1
    line a
        line b

line c
last line
</t>
<t tx="ekr.20201128164717.453">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.454">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.455">first line

line 1
   line a
       line b

line c
last line
</t>
<t tx="ekr.20201128164717.456">first line

line 1
    line a
        line b

line c
last line
</t>
<t tx="ekr.20201128164717.457">first line

line 1
   line a
       line b

line c
last line
</t>
<t tx="ekr.20201128164717.458">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.459">first line
line 1
line a
    line b
line c
last line
</t>
<t tx="ekr.20201128164717.46">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.460">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.461">first line
line 1
line a
    line b
line c
last line
</t>
<t tx="ekr.20201128164717.462">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.463">
last line
line c
        line b
    line a
line 1
first line
</t>
<t tx="ekr.20201128164717.464">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.465">
last line
line c
        line b
    line a
line 1
first line
</t>
<t tx="ekr.20201128164717.466">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.467">z
x
e
d
a
</t>
<t tx="ekr.20201128164717.468">a
d
e
z
x
</t>
<t tx="ekr.20201128164717.469">z
x
e
d
a
</t>
<t tx="ekr.20201128164717.47">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.470">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.471">z
Y
X
c
b
A
</t>
<t tx="ekr.20201128164717.472">c
A
z
X
Y
b
</t>
<t tx="ekr.20201128164717.473">z
Y
X
c
b
A
</t>
<t tx="ekr.20201128164717.474">@first # -*- coding: utf-8 -*-
@language python

try:
    ec = c.editCommands ; w = c.frame.body.wrapper
    s = w.getAllText()

    # This strings tests unicode, paren matching, and auto-indentation.
    u = '(a\u00c9\u03a9B\u3045\u4e7cz):\n' # '(aBE|cz):\n'
    u = '(pdq):\n'
    w.setInsertPoint(len(s))
    for char in u:
        binding = 'Return' if char == '\n' else char
        event = g.app.gui.create_key_event(c,char=char,binding=binding,w=w)
        ec.selfInsertCommand(event)
    result = w.getAllText()
    assert result.endswith('    '),'result:\n%s' % result
    # Test of autocompleter.
finally:
    if 1:
        w.setAllText(s)
        p.setBodyString(s)
        # g.trace(repr(s))
        c.recolor()

# end:
</t>
<t tx="ekr.20201128164717.475">@language python
@tabwidth -4

try:
    ec = c.editCommands ; w = c.frame.body.wrapper
    s = w.getAllText()
    w.setSelectionRange(len(s)-9,len(s)-6)
    event = g.app.gui.create_key_event(c, binding='Tab', char='\t', w=w)
    ec.selfInsertCommand(event)
    result = w.getAllText()
    assert result.endswith('\n    ###abcdef\n'),'result\n%s' % (repr(result))
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor_now()
    
###abcdef
</t>
<t tx="ekr.20201128164717.476"># xxxx.yyyy

s = p.b
w = c.frame.body.wrapper
w.setSelectionRange(2,11)
c.editCommands.setFillPrefix(event=None)
prefix = c.editCommands.fillPrefix
assert prefix == 'xxxx.yyyy',repr(prefix)
</t>
<t tx="ekr.20201128164717.477">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.478">        line b
    line a
first line
last line
line 1
line c
</t>
<t tx="ekr.20201128164717.479">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.48">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.480">        line b
    line a
first line
last line
line 1
line c
</t>
<t tx="ekr.20201128164717.481">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.482">first line
        line b
    line a
line 1
line c
last line
</t>
<t tx="ekr.20201128164717.483">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.484">first line
        line b
    line a
line 1
line c
last line
</t>
<t tx="ekr.20201128164717.485">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.486">A
B
c
x
z
</t>
<t tx="ekr.20201128164717.487">x
z
A
c
B
</t>
<t tx="ekr.20201128164717.488">A
B
c
x
z
</t>
<t tx="ekr.20201128164717.489">c.sortRecentFiles()
</t>
<t tx="ekr.20201128164717.49">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.490">child = p.firstChild()
assert child.h == 'b','fail 1'
try:
    c.selectPosition(child)
    c.sortSiblings()
    c.redraw_now()
    child = p.firstChild()
    assert child.h == 'a'
    child = child.next()
    assert child.h == 'b'
    child = child.next()
    assert child.h == 'c'
    assert not child.next()
finally:
    c.undoer.undo()
    p.contract()
    c.redraw(p)
</t>
<t tx="ekr.20201128164717.491"></t>
<t tx="ekr.20201128164717.492"></t>
<t tx="ekr.20201128164717.493"></t>
<t tx="ekr.20201128164717.494">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.495">first
 line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.496">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.497">first
 line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.498">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.499">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.5">first line
line 1
    line a
line b
last line
</t>
<t tx="ekr.20201128164717.50">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.500">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.501">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.502">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.503">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.504">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.505">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.506">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.507">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.508">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.509">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.51">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.510">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.511">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.512">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.513">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.514">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.515">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20201128164717.516">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.517">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20201128164717.518">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.519">frist line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.52">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.520">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.521">frist line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.522">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.523">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.524">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.525">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.526">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.527">first line
before foo += bar2 after
last line
</t>
<t tx="ekr.20201128164717.528">first line
before bar2 += foo after
last line
</t>
<t tx="ekr.20201128164717.529">first line
before foo += bar2 after
last line
</t>
<t tx="ekr.20201128164717.53">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.530">from leo.core import leoBeautify
cpp = leoBeautify.CPrettyPrinter(c)
# ts2p = c.convertCommands.TS_To_Python(c)
fn = 'typescript tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)
aList = cpp.tokenize(p2.b)
assert aList
# bts2p.convertCodeList(aList)
# s = ''.join(aList)
</t>
<t tx="ekr.20201128164717.531">@language javascript

public attemptIncrementalUpdateUnit(previousScript: Script,scriptId: string,newSourceText: ISourceText,editRange: ScriptEditRange): UpdateUnitResult
    self.logger.log("attemptIncrementalUpdateUnit(\"" + scriptId + "\")")
    if editRange === None:
        throw Error("editRange should be valid")
    var scope1 = self.getEnclosingScopeContextIfSingleScopeEdit(previousScript,scriptId,newSourceText,editRange)
    if scope1 === None:
        return None
    var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta
    # Heuristic: if the range to reparse is too big,bail out.
    # This is because a full parse will be faster than an incremental parse followed by all the necessary fix-ups
    if newScopeLength &gt;= newSourceText.getLength()/ 2:
        self.logger.log("  Bailing out because range of scope to reparse(" + newScopeLength + " characters)is greater than half the size of the source text")
        return None
    # Capture parsing errors so that they are part of "updateResult"
    var parseErrors: TypeScript.ErrorEntry:[] = []
    var errorCapture = function(minChar: number,charLen: number,message: string,unitIndex: number): void
        parseErrors.push(TypeScript.ErrorEntry:(unitIndex,minChar,minChar + charLen,message))
    var quickParseResult = TypeScript.quickParse(self.logger,scope1.scopeStartAST,newSourceText,scope1.scopeStartAST.minChar,scope1.scopeStartAST.minChar + newScopeLength,errorCapture)
    if quickParseResult.endLexState != TypeScript.LexState.Start:
        self.logger.log("  Bailing out because scope contains unterminated comment")
        return None
    var scriptFragment = quickParseResult.Script
    if scriptFragment.vars.members.length !== 0:
        self.logger.log("  Bailing out because new source text defines variables")
        return None
    #if(scriptFragment.scopes.members.length !== 1)
    #    logger.log("  Bailing out because new source text defines more than one scope(or none)");
    #    return null;
    #
    # This detects adding close curlies,since they have the side effect of having the parser
    # parse more members in the scope range.
    if scriptFragment.bod.members.length !== 1:
        self.logger.log("  Bailing out because new source text defines more than one scope(or none)")
        return None
    var oldScope = scope1.scopeStartAST
    var newScope = scriptFragment.bod.members[0]
    if oldScope.nodeType != newScope.nodeType:
        self.logger.log("  Bailing out because new source text does not define the same scope type as the existing scope")
        return None
    if not (&lt;any&gt;oldScope).leftCurlyCount or not (&lt;any&gt;oldScope).rightCurlyCount:
        self.logger.log("  Bailing out because sopce doesn't have left/right curly count")
        return None
    if(&lt;any&gt;oldScope).leftCurlyCount !==(&lt;any&gt;newScope).leftCurlyCount:
        self.logger.log("  Bailing out because new source text contains more(or fewer)left curly braces")
        return None
    if(&lt;any&gt;oldScope).rightCurlyCount !==(&lt;any&gt;newScope).rightCurlyCount:
        self.logger.log("  Bailing out because new source text contains more(or fewer)right curly braces")
        return None
    if newScope.minChar !== 0:
        self.logger.log("  Bailing out because new function declaration does not start at position 0")
        return None
    if newScope.limChar !== newScopeLength:
        self.logger.log("  Bailing out because new function declaration does not end at the new end position")
        return None
    return TypeScript.UpdateUnitResult.singleScopeEdits(previousScript,scriptFragment,oldScope,newScope,editRange,parseErrors)
</t>
<t tx="ekr.20201128164717.532">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.533">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.534">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20201128164717.535">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.536">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.537">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.538">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.539">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.54">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.540">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.541">first line
line 1
    LINE a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.542">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.543">first line
line 1
    LINE a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.544"></t>
<t tx="ekr.20201128164717.545"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.546">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.547">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.548">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.549"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.55">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.550">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.551">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.552">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.553"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.554">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.555">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.556">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.557"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.558">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.559">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.56">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.560">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.561"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.562">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
</t>
<t tx="ekr.20201128164717.563">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.564">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
</t>
<t tx="ekr.20201128164717.565"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.566">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.567">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.568">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.569"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.57">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.570">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.571">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.572">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.573"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.574">@pagewidth 40
'''
docstring. more docstring.
'''
</t>
<t tx="ekr.20201128164717.575">@pagewidth 40
'''
docstring.
more docstring.
'''
</t>
<t tx="ekr.20201128164717.576">@pagewidth 40
'''
docstring. more docstring.
'''
</t>
<t tx="ekr.20201128164717.577"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.578">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.579">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.58">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.580">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.581"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.582">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.583">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.584">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.585"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.586">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.587">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.588">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.589"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.59">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.590">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.591">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.592">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.593"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.594">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.595">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.596">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.597"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.598">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.599">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.6">first line
 line 1
     line a
 line b
last line
</t>
<t tx="ekr.20201128164717.60">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.600">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.601"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.602">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.603">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.604">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.605"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.606">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.607">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.608">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.609"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.61">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.610">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.611">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.612">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.613"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.614">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.615">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.616">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.617"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.618">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
</t>
<t tx="ekr.20201128164717.619">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.

Next Paragraph.
</t>
<t tx="ekr.20201128164717.62">first lie
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.620">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
</t>
<t tx="ekr.20201128164717.621"></t>
<t tx="ekr.20201128164717.622">ac = c.abbrevCommands
assert ac
if c.abbrev_place_start is None or c.abbrev_place_end is None:
    self.skipTest('no abbreviation settings') # #1345.
child = g.findNodeInTree(c,p,'child')
assert child
old_b = child.b
try:
    i,j,val = 0,0,child.b
    # ac.make_script_substitutions(i,j,val)
    # ac.find_place_holder(child,True)
    new_s,i,j = ac.next_place(child.b,offset=0)
    assert i == 34 and j == 40,(i,j)
    new_s2,i,j = ac.next_place(new_s,offset=40)
    assert i == 54 and j == 58,(i,j)
finally:
    child.b = old_b
</t>
<t tx="ekr.20201128164717.623">def spam ():
    """None - Return &lt;|return|&gt;
    """

    &lt;|code|&gt;
</t>
<t tx="ekr.20201128164717.624">f = c.abbrevCommands.addAbbrevHelper
d = c.abbrevCommands.abbrevs

# New in Leo 4.10: whitespace (blank,tab,newline) *is* significant in definitions.
table = (
    ('ut1','ut1=aa','aa'),
    # ('ut2','ut2 =bb','bb'),
    ('ut3','ut3=cc=dd','cc=dd'),
    ('ut4','ut4= ee',' ee'),
    ('ut5','ut5= ff = gg',' ff = gg'),
    ('ut6','ut6= hh==ii',' hh==ii'),
    ('ut7','ut7=j=k','j=k'),
    ('ut8','ut8=l==m','l==m'),
    ('@ut1','@ut1=@a','@a'),
)

for name,s,expected in table:
    for s2,kind in ((s,'(no nl)'),(s+'\n','(nl)')):
        f(s2,tag='unit-test')
        result,tag = d.get(name,(None,None),)
        assert result==expected, '%s &lt;%s&gt; expected &lt;%s&gt;, got &lt;%s&gt;' % (
            kind,s,expected,result)
</t>
<t tx="ekr.20201128164717.625"># TARGETWORD

w = c.frame.body.wrapper

for (which,result) in (('cap','Targetword'),('low','targetword'),('up','TARGETWORD')):
    w.setInsertPoint(5)
    c.editCommands.capitalizeHelper(event=None,which=which,undoType='X')
    s = w.getAllText()
    word = s[2:12]
    assert word == result, 'Expected %s, got: %s' % (result,repr(word))
    i = w.getInsertPoint()
    assert i == 5, 'Expected 5, got: %d' % i
</t>
<t tx="ekr.20201128164717.626"># A totally wimpy test.
# And it somehow prints a newline to the console.
if 0:
    c.abbrevCommands.dynamicExpandHelper(event=None,prefix='',aList=[],w=None)
</t>
<t tx="ekr.20201128164717.627">ec = c.editCommands ; w = c.frame.body.wrapper

for i,j,python in (
    # ('1.0','4.5',False),
    (5,50,True),
):
    extend = True
    ec.moveSpot = None # It's hard to init this properly.
    ec.extendHelper(w,extend,j)
    i2,j2 = w.getSelectionRange()
    #assert 0==i2, 'Expected i=%s, got %s' % (repr(i),repr(i2))
    #assert j==j2, 'Expected j=%s, got %s' % (repr(j),repr(j2))
</t>
<t tx="ekr.20201128164717.628"># start
# targetWord

e = c.editCommands
k = c.k
w = c.frame.body.wrapper
w.setInsertPoint(0)
k.arg = 't' # 'targetWord'
e.w = w
e.oneLineFlag = False
e.findWord1(event=None)
i,j = w.getSelectionRange()
assert i == 10, 'expected 10, got %s' % (i)
</t>
<t tx="ekr.20201128164717.629"># targetWord
e = c.editCommands
k = c.k
w = c.frame.body.wrapper
for val in (True,False):
    k.arg = 't' # 'targetWord'
    w.setInsertPoint(0)
    e.w = w
    e.oneLineFlag = val
    f = e.findWord1(event=None)
    i,j = w.getSelectionRange()
    assert i == 2, 'expected 2, got %s' % (i)
    # s = w.getAllText()
    # ch = s[i]
    # assert word == 'targetWord', 'got: %s' % word

</t>
<t tx="ekr.20201128164717.63">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.630">vr = c.helpCommands.helpForMinibuffer()
if not vr:
    self.skipTest('no vr plugin')
</t>
<t tx="ekr.20201128164717.631">ec = c.editCommands ; w = c.frame.body.wrapper

for i,j,python in (
    #('1.0','4.5',False),
    (5,50,True),
):
    event = None ; extend = True ; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveToHelper (event,j,extend)
    i2,j2 = w.getSelectionRange()
    assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
    assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
    w.setSelectionRange(0,0,insert=None)
</t>
<t tx="ekr.20201128164717.632">ec = c.editCommands ; w = c.frame.body.wrapper

for i,result,direction in (('5.8','4.8','up'),('5.8','6.8','down')):
    event = None ; extend = False; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveUpOrDownHelper (event,direction,extend)
    i2,j2 = w.getSelectionRange()
    if 1:
        break
    else:
        assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
        assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
        w.setSelectionRange(0,0,insert=None)
</t>
<t tx="ekr.20201128164717.633">ec = c.editCommands
w = c.frame.body.wrapper

for direction in ('up','down'):
    for distance in ('line','page','half-page'):
        event = g.app.gui.create_key_event(c,w=w)
        ec.scrollHelper(event,direction,distance)
</t>
<t tx="ekr.20201128164717.634">w = c.frame.body.wrapper
ec = c.editCommands

for spot,result in (('1.0',0),(5,5)):
    ec.setMoveCol(w,spot)
    assert ec.moveSpot == result
    assert ec.moveCol == result
</t>
<t tx="ekr.20201128164717.635"># These tests will be important when revising config code.
</t>
<t tx="ekr.20201128164717.636"># backward-find-character and find-character
# can't be tested this way because they require k.getarg.
# They pass hand tests.

&lt;&lt; define table &gt;&gt;

w = c.frame.body.wrapper
child = g.findNodeInChildren(c,p,'work')
assert child
c.selectPosition(child)

for commandName in table:
    # Put the cursor in the middle of the middle line
    # so all cursor moves will actually do something.
    w.setInsertPoint(15) # for move-past-close
    try:
        c.editCommands.extendMode = True
        c.keyHandler.simulateCommand(commandName)
        i,j = w.getSelectionRange()
        assert i != j,'i == j: %s %s' % (i,commandName)
    finally:
        c.editCommands.extendMode = False

</t>
<t tx="ekr.20201128164717.637"># Cursor movement commands affected by extend mode.
# The x-extend-selection commands are not so affected.
table = (
    'back-to-indentation',
    'back-to-home',
    'back-char',
    'back-page',
    'back-paragraph',
    'back-sentence',
    'back-word',
    'beginning-of-buffer',
    'beginning-of-line',
    'end-of-buffer',
    'end-of-line',
    'forward-char',
    'forward-page',
    'forward-paragraph',
    'forward-sentence',
    'forward-end-word',
    'forward-word',
    'move-past-close',
    'next-line',
    'previous-line',
)
</t>
<t tx="ekr.20201128164717.638">line 1.
line 2(xxx).
line 3.
</t>
<t tx="ekr.20201128164717.639">if g.app.inBridge:
    self.skipTest('in bridge')
k = c.k
colorizer = c.frame.body.getColorizer()
ed = c.editCommands
# These don't set ivars
    # 'toggle-active-pane'),
    # 'toggle-angle-brackets',
    # 'toggle-input-state'),
    # 'toggle-mini-buffer'),
    # 'toggle-split-direction'),
table = [
    (k,'abbrevOn','toggle-abbrev-mode'),
    (ed,'extendMode','toggle-extend-mode'),
]
# Not valid for external tests.
table2 = [
    (k,'enable_autocompleter','toggle-autocompleter'),
    (k,'enable_calltips','toggle-calltips'),
    (c,'sparse_find','toggle-find-collapses-nodes'),
    (colorizer,'showInvisibles','toggle-invisibles'),
    (c,'sparse_move','toggle-sparse-move'),
]
if not g.app.isExternalUnitTest:
    table.extend(table2)
for obj,ivar,command in table:
    val1 = getattr(obj,ivar)
    try:
        k.simulateCommand(command)
        val2 = getattr(obj,ivar)
        assert val2 == (not val1),'failed 1 %s' % command
        k.simulateCommand(command)
        val3 = getattr(obj,ivar)
        assert val3 == val1,'failed 2 %s' % command
    finally:
        setattr(obj,ivar,val1)
</t>
<t tx="ekr.20201128164717.64">first lie
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.640"># These are mysteriously fragile tests, so they go first
</t>
<t tx="ekr.20201128164717.641">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
s = 'ABC'
c.setBodyString(p,s)
try:
    c.bodyWantsFocus()
    w = c.frame.body.wrapper
    w.setInsertPoint(2)
    c.outerUpdate() # This fixed the problem.
    if 1:
        c.k.simulateCommand('delete-char')
    else:
        # This fails unless Delete is bound to delete-char
        g.app.gui.event_generate(c,'Delete','Delete',w) # Calls c.outerUpdate()
    assert p.b == s[:-1],'oops1: expected "AB", got %s' % p.b
    c.selectPosition(p.threadBack())
    c.selectPosition(p)
    assert p.b == s[:-1],'oops2: expected "AB", got %s' % p.b
finally:
    if 0:
        c.setBodyString(p,'')
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.642">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w
    w.setSelectionRange('end','end')
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.643">u = c.undoer
assert u
c.insertHeadline()
assert u.undoMenuLabel == 'Undo Insert Node',repr(u.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node',repr(u.undoMenuLabel)
</t>
<t tx="ekr.20201128164717.644">u = c.undoer
assert u
c.insertHeadlineBefore()
assert u.undoMenuLabel == 'Undo Insert Node Before',repr(u.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node Before',repr(u.undoMenuLabel)
</t>
<t tx="ekr.20201128164717.645">n = c.frame.tree.redrawCount
c.insertHeadline()
c.outerUpdate() # Not actually needed, but should not matter.
try:
    n2 = c.frame.tree.redrawCount
    if g.app.isExternalUnitTest:
        self.skipTest('Can not be run externally')
    else:
        assert n2 == n + 1,'redraws: %d' % (n2 - n)
finally:
    c.undoer.undo()
</t>
<t tx="ekr.20201128164717.646">import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
frame = c.frame
tree = frame.tree
canvas = tree.canvas
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        stroke = k.getStrokeForCommandName('paste-text')
        if stroke is None:
            self.skipTest('no binding for paste-text') # #1345
        k.manufactureKeyPressForCommandName(w, 'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + paste, 'oops2 got: %s' % p.h
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h, f"oops3 expected {h} got: {p.h}"
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.647">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
else:
    k = c.keyHandler
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w, 'Null w'
        paste = 'ABC'
        g.app.gui.replaceClipboardWith(paste)
        w.setSelectionRange('1.1','1.2')
        if g.app.gui.guiName() == 'curses':
            c.frame.pasteText(event=g.Bunch(widget=w))
        else:
            stroke = k.getStrokeForCommandName('paste-text')
            if stroke is None:
                self.skipTest('no binding for paste-text') # #1345
            k.manufactureKeyPressForCommandName(w,'paste-text')
            g.app.gui.event_generate(c,'\n','Return',w)
        assert p.h == h[0] + paste + h[2:]
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h, 'head mismatch'
    finally:
        if 1:
            c.setHeadString(p,h) # Essential
            c.redraw(p)
</t>
<t tx="ekr.20201128164717.648">import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
g.app.gui.set_focus(c,w)
w2 = g.app.gui.get_focus(c)
try:
    assert w
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        stroke = k.getStrokeForCommandName('paste-text')
        if stroke is None:
            self.skipTest('no binding for paste-text') # #1345
        k.manufactureKeyPressForCommandName(w,'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + paste,'Expected: %s, got %s' % (
        h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.649">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
w.setSelectionRange('end','end',insert='end')
paste = 'ABC'
g.app.gui.replaceClipboardWith(paste)
event = g.app.gui.create_key_event(c,w=w)
c.frame.pasteText(event)
# Move around and and make sure it doesn't change.
try:
    # g.trace('before select',w,w.getAllText())
    c.selectPosition(p.threadBack())
    assert p.h == h + paste,'oops1: expected: %s, got %s' % (h + paste,p.h)
    c.selectPosition(p)
    assert p.h == h + paste,'oops2: expected: %s, got %s' % (h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.65">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.650">h = '@test return ends editing of headline'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
guiName = g.app.gui.guiName()
wName = g.app.gui.widget_name(w)
assert wName.startswith('head'),'w.name:%s' % wName
g.app.gui.event_generate(c,'\n','Return',w)
c.outerUpdate()
assert w != c.get_focus(),'oops2: focus in headline'
</t>
<t tx="ekr.20201128164717.651">if g.in_bridge:
    self.skipTest('Not for TravisCI')
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        k.manufactureKeyPressForCommandName(w,'paste-text')
    c.selectPosition(p.visBack(c))
    assert p.h == h + paste
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h,'expected: %s, got: %s' % (
        h,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.652">if g.in_bridge:
    self.skipTest('Not for TravisCI')
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')
if g.app.gui.guiName() == 'curses':
    self.skipTest('Not for curses gui')

k = c.k
if k.defaultUnboundKeyAction == 'insert':
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w
        w.setSelectionRange('end','end')
        # char, shortcut.
        g.app.gui.event_generate(c,'X','Shift+X',w)
        g.app.gui.event_generate(c,'Y','Shift+Y',w)
        g.app.gui.event_generate(c,'Z','Shift+Z',w)
        g.app.gui.event_generate(c,'\n','Return',w)
        expected = h + 'XYZ'
        assert p.h == expected, f"oops 1: expected {expected!r} got {p.h!r}"
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h, f"oops 2: expected {h!r} got {p.h!r}"
    finally:
        if 1:
            c.setHeadString(p, h) # Essential
            c.redraw(p)
</t>
<t tx="ekr.20201128164717.653">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
if g.app.gui.guiName() == 'curses':
    # This could be adapted, but not now.
    self.skipTest('Not for curses gui')
k = c.k
if k.defaultUnboundKeyAction != 'insert':
    self.skipTest('defaultUnboundKeyAction != insert')
if not k.getStrokeForCommandName('undo'):
    self.skipTest('no settings')

frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make the node visible.
w = c.edit_widget(p)
try:
    assert w, 'oops1'
    wName = g.app.gui.widget_name(w)
    assert wName.startswith('head'),'w.name:%s' % wName
    w.setSelectionRange('end','end')
    g.app.gui.event_generate(c,'X','Shift+X',w)
    g.app.gui.event_generate(c,'Y','Shift+Y',w)
    g.app.gui.event_generate(c,'Z','Shift+Z',w)
    g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + 'XYZ',(
        'oops2: expected: %s, got: %s' % (
            h + 'XYZ',p.h))
    if g.app.gui.guiName() != 'nullGui':
        assert c.undoer.undoMenuLabel == 'Undo Typing','oops3: %s' % (
            c.undoer.undoMenuLabel)
    k.manufactureKeyPressForCommandName(w,'undo')
    if g.app.gui.guiName() != 'nullGui':
        assert c.undoer.redoMenuLabel == 'Redo Typing','oops4'
    assert p.h == h,'oops5 got: %s, expected: %s' % (
        p.h,h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.654">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.setBodyString(p,'a')
c.redraw(p) # To make node visible
c.bodyWantsFocus()
n = c.frame.tree.redrawCount
try:
    w = c.frame.body.wrapper
    g.app.gui.event_generate(c,'a','a',w)
    n2 = c.frame.tree.redrawCount
    assert n2 == n,'too many redraws: %d' % (n2-n)
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.655">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
body = 'This is a test'
c.setBodyString(p,body)

try:
    assert p.b == body
    c.insertHeadline()
    c.undoer.undo()
    assert p.b == body
finally:
    c.setBodyString(p,'')
</t>
<t tx="ekr.20201128164717.656"># Print does not work: it is redirected.
g.pr('\nEnd of typing tests')
</t>
<t tx="ekr.20201128164717.657"># Print does not work: it is redirected.
g.pr('\nEnd of leoEditCommands tests.')
</t>
<t tx="ekr.20201128164717.66">firstline
last line
</t>
<t tx="ekr.20201128164717.67">first line
last line
</t>
<t tx="ekr.20201128164717.68">firstline
last line
</t>
<t tx="ekr.20201128164717.69">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.7">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.70">first line
last lin
</t>
<t tx="ekr.20201128164717.71">first line
last line
</t>
<t tx="ekr.20201128164717.72">first line
last lin
</t>
<t tx="ekr.20201128164717.73">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.74">aaaa cccc dddd
</t>
<t tx="ekr.20201128164717.75">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20201128164717.76">aaaa cccc dddd
</t>
<t tx="ekr.20201128164717.77">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.78">aaaa bbcc dddd
</t>
<t tx="ekr.20201128164717.79">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20201128164717.8">first line
    line 1
        line a
            line b
    line c
last line
</t>
<t tx="ekr.20201128164717.80">aaaa bbcc dddd
</t>
<t tx="ekr.20201128164717.81">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.82">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.83">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.84">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.85">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.86">This is the first sentence.  This
is the second sentence.
</t>
<t tx="ekr.20201128164717.87">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.88">This is the first sentence.  This
is the second sentence.
</t>
<t tx="ekr.20201128164717.89">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.9">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.90">This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
</t>
<t tx="ekr.20201128164717.91">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.92">This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
</t>
<t tx="ekr.20201128164717.93">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.94">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.95">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.96">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.97">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.98">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.99">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128165500.1">"""Convert old-style tests to new-style tests"""
g.cls()
import importlib
from leo.core import leoTest2
importlib.reload(leoTest2)

root = g.findTopLevelNode(c, 'unit-tests: leoEditCommands')
target = g.findTopLevelNode(c, 'new-tests')
if root and target:
    leoTest2.convert_leoEditCommands_tests(c, root, target)
else:
    print('Error: root and target nodes must be top-level nodes.')</t>
<t tx="ekr.20201128171127.1"></t>
<t tx="ekr.20201129092548.1">- Find out why noscript is interfering with leoflexx.py.

- Figure out how to build Leovue.
</t>
<t tx="ekr.20201129132149.1"></t>
<t tx="ekr.20201130074836.1">def convert_leoEditCommands_tests(c, root, target):
    """
    Convert @test nodes to new-style tests.
    
    root:   A node containing (a copy of) tests from unitTest.leo.
    target: A node whose children will be the resulting tests.
            These nodes can then be copied to be children of a test class.
    """
    if not root or not target:
        print('Error: root and target nodes must be top-level nodes.', color='red')
        return
    # Be safe.
    if target.hasChildren():
        print('Please delete children of ', target.h, color='red')
        return
    converter = ConvertEditCommandsTests()
    count = 0
    for p in root.subtree():
        if p.h.startswith('@test') and 'runEditCommandTest' in p.b:
            converter.convert(p, target)
            count += 1
    c.redraw()
    print(f"converted {count} @test nodes", color='blue')
</t>
<t tx="ekr.20201202085332.1">def test_add_space_to_lines(self):
    """Test case for add-space-to-lines"""
    before_b = """\
first line
line 1
    line a
line b
last line
"""
    after_b = """\
first line
 line 1
     line a
 line b
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "4.6"),
        after_sel=("2.0", "4.7"),
        command_name="add-space-to-lines",
    )
</t>
<t tx="ekr.20201202085332.10">def test_back_to_home_at_start_of_line(self):
    """Test case for back-to-home (at start of line)"""
    before_b = """\
if a:
    b = 'xyz'
"""
    after_b = """\
if a:
    b = 'xyz'
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("2.4", "2.4"),
        command_name="back-to-home",
    )
</t>
<t tx="ekr.20201202085332.100">def test_rectangle_yank(self):
    """Test case for rectangle-yank"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.6"),
        command_name="rectangle-yank",
    )
</t>
<t tx="ekr.20201202085332.101">def test_remove_blank_lines(self):
    """Test case for remove-blank-lines"""
    before_b = """\
first line

line 1
    line a
        line b

line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "9.0"),
        after_sel=("1.0", "6.9"),
        command_name="remove-blank-lines",
    )
</t>
<t tx="ekr.20201202085332.102">def test_remove_space_from_lines(self):
    """Test case for remove-space-from-lines"""
    before_b = """\
first line

line 1
    line a
        line b

line c
last line
"""
    after_b = """\
first line

line 1
   line a
       line b

line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "9.0"),
        after_sel=("1.0", "9.0"),
        command_name="remove-space-from-lines",
    )
</t>
<t tx="ekr.20201202085332.103">def test_remove_tab_from_lines(self):
    """Test case for remove-tab-from-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
line a
    line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("1.0", "7.0"),
        command_name="remove-tab-from-lines",
    )
</t>
<t tx="ekr.20201202085332.104">def test_reverse_region(self):
    """Test case for reverse-region"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\

last line
line c
        line b
    line a
line 1
first line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("7.10", "7.10"),
        command_name="reverse-region",
    )
</t>
<t tx="ekr.20201202085332.105">def test_reverse_sort_lines(self):
    """Test case for reverse-sort-lines"""
    before_b = """\
a
d
e
z
x
"""
    after_b = """\
z
x
e
d
a
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "5.1"),
        after_sel=("1.0", "5.1"),
        command_name="reverse-sort-lines",
    )
</t>
<t tx="ekr.20201202085332.106">def test_reverse_sort_lines_ignoring_case(self):
    """Test case for reverse-sort-lines-ignoring-case"""
    before_b = """\
c
A
z
X
Y
b
"""
    after_b = """\
z
Y
X
c
b
A
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "6.1"),
        after_sel=("1.0", "6.1"),
        command_name="reverse-sort-lines-ignoring-case",
    )
</t>
<t tx="ekr.20201202085332.107">def test_sort_columns(self):
    """Test case for sort-columns"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
        line b
    line a
first line
last line
line 1
line c
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "6.2"),
        after_sel=("1.0", "7.0"),
        command_name="sort-columns",
    )
</t>
<t tx="ekr.20201202085332.108">def test_sort_lines(self):
    """Test case for sort-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
        line b
    line a
line 1
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "5.6"),
        after_sel=("2.0", "5.6"),
        command_name="sort-lines",
    )
</t>
<t tx="ekr.20201202085332.109">def test_sort_lines_ignoring_case(self):
    """Test case for sort-lines-ignoring-case"""
    before_b = """\
x
z
A
c
B
"""
    after_b = """\
A
B
c
x
z
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "5.1"),
        after_sel=("1.0", "5.1"),
        command_name="sort-lines-ignoring-case",
    )
</t>
<t tx="ekr.20201202085332.11">def test_back_to_home_at_indentation(self):
    """Test case for back-to-home (at indentation"""
    before_b = """\
if a:
    b = 'xyz'
"""
    after_b = """\
if a:
    b = 'xyz'
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.4", "2.4"),
        after_sel=("2.0", "2.0"),
        command_name="back-to-home",
    )
</t>
<t tx="ekr.20201202085332.110">def test_split_line(self):
    """Test case for split-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first
 line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.5", "1.5"),
        after_sel=("2.0", "2.0"),
        command_name="split-line",
    )
</t>
<t tx="ekr.20201202085332.111">def test_start_of_line(self):
    """Test case for start-of-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.4", "3.4"),
        command_name="start-of-line",
    )
</t>
<t tx="ekr.20201202085332.112">def test_start_of_line_2(self):
    """Test case for start-of-line (2)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.4", "3.4"),
        command_name="start-of-line",
    )
</t>
<t tx="ekr.20201202085332.113">def test_start_of_line_extend_selection(self):
    """Test case for start-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.4", "3.10"),
        command_name="start-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.114">def test_start_of_line_extend_selection_2(self):
    """Test case for start-of-line-extend-selection (2)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.1", "3.4"),
        command_name="start-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.115">def test_tabify(self):
    """Test case for tabify"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
	line a
		line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="tabify",
    )
</t>
<t tx="ekr.20201202085332.116">def test_transpose_chars(self):
    """Test case for transpose-chars"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
frist line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.2", "1.2"),
        after_sel=("1.2", "1.2"),
        command_name="transpose-chars",
    )
</t>
<t tx="ekr.20201202085332.117">def test_transpose_lines(self):
    """Test case for transpose-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
line 1
first line
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("2.10", "2.10"),
        command_name="transpose-lines",
    )
</t>
<t tx="ekr.20201202085332.118">def test_transpose_words(self):
    """Test case for transpose-words"""
    before_b = """\
first line
before bar2 += foo after
last line
"""
    after_b = """\
first line
before foo += bar2 after
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.9", "2.9"),
        after_sel=("2.11", "2.11"),
        command_name="transpose-words",
    )
</t>
<t tx="ekr.20201202085332.119">def test_untabify(self):
    """Test case for untabify"""
    before_b = """\
first line
line 1
	line a
		line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="untabify",
    )
</t>
<t tx="ekr.20201202085332.12">def test_back_to_home_at_end_of_line(self):
    """Test case for back-to-home (at end of line)"""
    before_b = """\
if a:
    b = 'xyz'
"""
    after_b = """\
if a:
    b = 'xyz'
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.12", "2.12"),
        after_sel=("2.4", "2.4"),
        command_name="back-to-home",
    )
</t>
<t tx="ekr.20201202085332.120">def test_upcase_region(self):
    """Test case for upcase-region"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "4.0"),
        after_sel=("3.0", "4.0"),
        command_name="upcase-region",
    )
</t>
<t tx="ekr.20201202085332.121">def test_upcase_word(self):
    """Test case for upcase-word"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    LINE a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.7", "3.7"),
        after_sel=("3.7", "3.7"),
        command_name="upcase-word",
    )
</t>
<t tx="ekr.20201202085332.122">def test_reformat_paragraph_list_1_of_5(self):
    """Test case for reformat-paragraph list 1 of 5"""
    before_b = """\
This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("4.0", "4.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.123">def test_reformat_paragraph_list_2_of_5(self):
    """Test case for reformat-paragraph list 2 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.0", "4.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.124">def test_reformat_paragraph_list_3_of_5(self):
    """Test case for reformat-paragraph list 3 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("10.0", "10.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.125">def test_reformat_paragraph_list_4_of_5(self):
    """Test case for reformat-paragraph list 4 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("10.0", "10.0"),
        after_sel=("13.0", "13.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.126">def test_reformat_paragraph_list_5_of_5(self):
    """Test case for reformat-paragraph list 5 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("13.0", "13.0"),
        after_sel=("15.1", "15.1"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.127">def test_reformat_paragraph_new_code_1_of_8(self):
    """Test case for reformat-paragraph new code 1 of 8"""
    before_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    after_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("2.0", "2.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.128">def test_reformat_paragraph_new_code_2_of_8(self):
    """Test case for reformat-paragraph new code 2 of 8"""
    before_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    after_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.129">def test_reformat_paragraph_new_code_3_of_8(self):
    """Test case for reformat-paragraph new code 3 of 8"""
    before_b = """\
@pagewidth 40
'''
docstring.
more docstring.
'''
"""
    after_b = """\
@pagewidth 40
'''
docstring. more docstring.
'''
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "4.1"),
        after_sel=("4.0", "4.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.13">def test_back_word(self):
    """Test case for back-word"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.183", "1.183"),
        after_sel=("1.178", "1.178"),
        command_name="back-word",
    )
</t>
<t tx="ekr.20201202085332.130">def test_reformat_paragraph_new_code_4_of_8(self):
    """Test case for reformat-paragraph new code 4 of 8"""
    before_b = """\
- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    after_b = """\
- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.131">def test_reformat_paragraph_new_code_5_of_8(self):
    """Test case for reformat-paragraph new code 5 of 8"""
    before_b = """\
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    after_b = """\
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "2.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.132">def test_reformat_paragraph_new_code_6_of_8(self):
    """Test case for reformat-paragraph new code 6 of 8"""
    before_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    after_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("4.0", "4.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.133">def test_reformat_paragraph_new_code_7_of_8(self):
    """Test case for reformat-paragraph new code 7 of 8"""
    before_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    after_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.11", "2.11"),
        after_sel=("3.1", "3.1"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.134">def test_reformat_paragraph_new_code_8_of_8(self):
    """Test case for reformat-paragraph new code 8 of 8"""
    before_b = """\
2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    after_b = """\
2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.135">def test_reformat_paragraph_paragraph_1_of_3(self):
    """Test case for reformat-paragraph paragraph 1 of 3"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    after_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("13.0", "13.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.136">def test_reformat_paragraph_paragraph_2_of_3(self):
    """Test case for reformat-paragraph paragraph 2 of 3"""
    before_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    after_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("13.0", "13.0"),
        after_sel=("25.0", "25.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.137">def test_reformat_paragraph_paragraph_3_of_3(self):
    """Test case for reformat-paragraph paragraph 3 of 3"""
    before_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    after_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("25.10", "25.10"),
        after_sel=("34.0", "34.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.138">def test_reformat_paragraph_simple_hanging_indent(self):
    """Test case for reformat-paragraph simple hanging indent"""
    before_b = """\
Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
"""
    after_b = """\
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.139">def test_reformat_paragraph_simple_hanging_indent_2(self):
    """Test case for reformat-paragraph simple hanging indent 2"""
    before_b = """\
Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
"""
    after_b = """\
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.14">def test_back_word_extend_selection(self):
    """Test case for back-word-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.342", "3.342"),
        after_sel=("3.332", "3.342"),
        command_name="back-word-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.140">def test_reformat_paragraph_simple_hanging_indent_3(self):
    """Test case for reformat-paragraph simple hanging indent 3"""
    before_b = """\
Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.

Next Paragraph.
"""
    after_b = """\
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.15">def test_backward_delete_char(self):
    """Test case for backward-delete-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first lie
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.9", "1.9"),
        after_sel=("1.8", "1.8"),
        command_name="backward-delete-char",
    )
</t>
<t tx="ekr.20201202085332.16">def test_backward_delete_char__middle_of_line(self):
    """Test case for backward-delete-char  (middle of line)"""
    before_b = """\
first line
last line
"""
    after_b = """\
firstline
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.6", "1.6"),
        after_sel=("1.5", "1.5"),
        command_name="backward-delete-char",
    )
</t>
<t tx="ekr.20201202085332.17">def test_backward_delete_char_last_char(self):
    """Test case for backward-delete-char (last char)"""
    before_b = """\
first line
last line
"""
    after_b = """\
first line
last lin
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.9", "2.9"),
        after_sel=("2.8", "2.8"),
        command_name="backward-delete-char",
    )
</t>
<t tx="ekr.20201202085332.18">def test_backward_delete_word_no_selection(self):
    """Test case for backward-delete-word (no selection)"""
    before_b = """\
aaaa bbbb cccc dddd
"""
    after_b = """\
aaaa cccc dddd
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.10", "1.10"),
        after_sel=("1.5", "1.5"),
        command_name="backward-delete-word",
    )
</t>
<t tx="ekr.20201202085332.19">def test_backward_delete_word_selection(self):
    """Test case for backward-delete-word (selection)"""
    before_b = """\
aaaa bbbb cccc dddd
"""
    after_b = """\
aaaa bbcc dddd
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.7", "1.12"),
        after_sel=("1.7", "1.7"),
        command_name="backward-delete-word",
    )
</t>
<t tx="ekr.20201202085332.2">def test_add_tab_to_lines(self):
    """Test case for add-tab-to-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
    line 1
        line a
            line b
    line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "5.6"),
        after_sel=("2.0", "5.10"),
        command_name="add-tab-to-lines",
    )
</t>
<t tx="ekr.20201202085332.20">def test_backward_kill_paragraph(self):
    """Test case for backward-kill-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("7.0", "7.0"),
        command_name="backward-kill-paragraph",
    )
</t>
<t tx="ekr.20201202085332.21">def test_backward_kill_sentence(self):
    """Test case for backward-kill-sentence"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  This
is the second sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.2", "3.2"),
        after_sel=("2.23", "2.23"),
        command_name="backward-kill-sentence",
    )
</t>
<t tx="ekr.20201202085332.22">def test_backward_kill_word(self):
    """Test case for backward-kill-word"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.7", "3.7"),
        after_sel=("3.5", "3.5"),
        command_name="backward-kill-word",
    )
</t>
<t tx="ekr.20201202085332.23">def test_beginning_of_buffer(self):
    """Test case for beginning-of-buffer"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("5.56", "5.56"),
        after_sel=("1.0", "1.0"),
        command_name="beginning-of-buffer",
    )
</t>
<t tx="ekr.20201202085332.24">def test_beginning_of_buffer_extend_selection(self):
    """Test case for beginning-of-buffer-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.423", "3.423"),
        after_sel=("1.0", "3.423"),
        command_name="beginning-of-buffer-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.25">def test_beginning_of_line(self):
    """Test case for beginning-of-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.0", "3.0"),
        command_name="beginning-of-line",
    )
</t>
<t tx="ekr.20201202085332.26">def test_beginning_of_line_extend_selection(self):
    """Test case for beginning-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.10", "4.10"),
        after_sel=("4.0", "4.10"),
        command_name="beginning-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.27">def test_capitalize_word(self):
    """Test case for capitalize-word"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    Line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.6", "3.6"),
        after_sel=("3.6", "3.6"),
        command_name="capitalize-word",
    )
</t>
<t tx="ekr.20201202085332.28">def test_center_line(self):
    """Test case for center-line"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "9.0"),
        after_sel=("3.0", "9.0"),
        command_name="center-line",
    )
</t>
<t tx="ekr.20201202085332.29">def test_center_region(self):
    """Test case for center-region"""
    before_b = """\
Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
"""
    after_b = """\
Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("1.0", "7.0"),
        command_name="center-region",
    )
</t>
<t tx="ekr.20201202085332.3">def test_back_char(self):
    """Test case for back-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.8", "3.8"),
        after_sel=("3.7", "3.7"),
        command_name="back-char",
    )
</t>
<t tx="ekr.20201202085332.30">def test_clean_lines(self):
    """Test case for clean-lines"""
    before_b = """\
# Should remove all trailing whitespace.

a = 2   
    
    b = 3
    c  = 4  
d = 5
e = 6  
x
"""
    after_b = """\
# Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.0", "1.0"),
        command_name="clean-lines",
    )
</t>
<t tx="ekr.20201202085332.31">def test_clear_selected_text(self):
    """Test case for clear-selected-text"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line    line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.4", "4.4"),
        after_sel=("2.4", "2.4"),
        command_name="clear-selected-text",
    )
</t>
<t tx="ekr.20201202085332.32">def test_count_region(self):
    """Test case for count-region"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.4", "4.8"),
        after_sel=("2.4", "4.8"),
        command_name="count-region",
    )
</t>
<t tx="ekr.20201202085332.33">def test_delete_char(self):
    """Test case for delete-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
firstline
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.5", "1.5"),
        after_sel=("1.5", "1.5"),
        command_name="delete-char",
    )
</t>
<t tx="ekr.20201202085332.34">def test_delete_indentation(self):
    """Test case for delete-indentation"""
    before_b = """\
first line
    line 1
last line
"""
    after_b = """\
first line
line 1
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.8", "2.8"),
        after_sel=("2.4", "2.4"),
        command_name="delete-indentation",
    )
</t>
<t tx="ekr.20201202085332.35">def test_delete_spaces(self):
    """Test case for delete-spaces"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.2", "3.2"),
        after_sel=("3.0", "3.0"),
        command_name="delete-spaces",
    )
</t>
<t tx="ekr.20201202085332.36">def test_do_nothing(self):
    """Test case for do-nothing"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.0", "1.0"),
        command_name="do-nothing",
    )
</t>
<t tx="ekr.20201202085332.37">def test_downcase_region(self):
    """Test case for downcase-region"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "4.0"),
        after_sel=("3.0", "4.0"),
        command_name="downcase-region",
    )
</t>
<t tx="ekr.20201202085332.38">def test_downcase_word(self):
    """Test case for downcase-word"""
    before_b = """\
XYZZY line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
xyzzy line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.4", "1.4"),
        after_sel=("1.4", "1.4"),
        command_name="downcase-word",
    )
</t>
<t tx="ekr.20201202085332.39">def test_end_of_buffer(self):
    """Test case for end-of-buffer"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.3", "1.3"),
        after_sel=("7.0", "7.0"),
        command_name="end-of-buffer",
    )
</t>
<t tx="ekr.20201202085332.4">def test_back_char_extend_selection(self):
    """Test case for back-char-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.12", "4.12"),
        after_sel=("4.11", "4.12"),
        command_name="back-char-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.40">def test_end_of_buffer_extend_selection(self):
    """Test case for end-of-buffer-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.0", "7.0"),
        command_name="end-of-buffer-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.41">def test_end_of_line(self):
    """Test case for end-of-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.10", "1.10"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.42">def test_end_of_line_2(self):
    """Test case for end-of-line 2"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("6.0", "6.0"),
        after_sel=("6.9", "6.9"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.43">def test_end_of_line_internal_blank_line(self):
    """Test case for end-of-line (internal blank line)"""
    before_b = """\
first line

line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line

line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("2.0", "2.0"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.44">def test_end_of_line_blank_last_line(self):
    """Test case for end-of-line (blank last line)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.45">def test_end_of_line_single_char_last_line(self):
    """Test case for end-of-line (single char last line)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
 
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
 
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("7.1", "7.1"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.46">def test_end_of_line_extend_selection(self):
    """Test case for end-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.10"),
        command_name="end-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.47">def test_end_of_line_extend_selection_blank_last_line(self):
    """Test case for end-of-line-extend-selection (blank last line)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="end-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.48">def test_exchange_point_mark(self):
    """Test case for exchange-point-mark"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.10"),
        after_sel=("1.0", "1.10"),
        command_name="exchange-point-mark",
    )
</t>
<t tx="ekr.20201202085332.49">def test_extend_to_line(self):
    """Test case for extend-to-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.3", "3.3"),
        after_sel=("3.0", "3.10"),
        command_name="extend-to-line",
    )
</t>
<t tx="ekr.20201202085332.5">def test_back_paragraph(self):
    """Test case for back-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("6.7", "6.7"),
        command_name="back-paragraph",
    )
</t>
<t tx="ekr.20201202085332.50">def test_extend_to_paragraph(self):
    """Test case for extend-to-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("8.0", "13.33"),
        command_name="extend-to-paragraph",
    )
</t>
<t tx="ekr.20201202085332.51">def test_extend_to_sentence(self):
    """Test case for extend-to-sentence"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.5", "3.5"),
        after_sel=("1.395", "3.142"),
        command_name="extend-to-sentence",
    )
</t>
<t tx="ekr.20201202085332.52">def test_extend_to_word(self):
    """Test case for extend-to-word"""
    before_b = """\
first line
line 1
    line_24a a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line_24a a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.4", "3.12"),
        command_name="extend-to-word",
    )
</t>
<t tx="ekr.20201202085332.53">def test_finish_of_line(self):
    """Test case for finish-of-line"""
    before_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.12", "3.12"),
        after_sel=("3.9", "3.9"),
        command_name="finish-of-line",
    )
</t>
<t tx="ekr.20201202085332.54">def test_finish_of_line_2(self):
    """Test case for finish-of-line (2)"""
    before_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.9", "3.9"),
        command_name="finish-of-line",
    )
</t>
<t tx="ekr.20201202085332.55">def test_finish_of_line_extend_selection(self):
    """Test case for finish-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.1", "3.9"),
        command_name="finish-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.56">def test_fill_paragraph(self):
    """Test case for fill-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially
declared disasters are weather related,
leading to around 500 deaths per year
and nearly $14 billion in damage.
StormReady, a program
started in 1999 in Tulsa, OK,
helps arm America's
communities with the communication and
safety skills needed to save lives and
property--before and during the event.
StormReady helps community leaders and
emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.7"),
        after_sel=("10.0", " 10.0"),
        command_name="fill-paragraph",
    )
</t>
<t tx="ekr.20201202085332.57">def test_forward_char(self):
    """Test case for forward-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.2", "1.2"),
        after_sel=("1.3", "1.3"),
        command_name="forward-char",
    )
</t>
<t tx="ekr.20201202085332.58">def test_forward_char_extend_selection(self):
    """Test case for forward-char-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.1", "1.1"),
        after_sel=("1.1", "1.2"),
        command_name="forward-char-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.59">def test_forward_end_word_end_of_line(self):
    """Test case for forward-end-word (end of line)"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.395", "1.395"),
        after_sel=("3.4", "3.4"),
        command_name="forward-end-word",
    )
</t>
<t tx="ekr.20201202085332.6">def test_back_paragraph_extend_selection(self):
    """Test case for back-paragraph-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.5"),
        after_sel=("6.7", "9.5"),
        command_name="back-paragraph-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.60">def test_forward_end_word_start_of_word(self):
    """Test case for forward-end-word (start of word)"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.310", "1.310"),
        after_sel=("1.317", "1.317"),
        command_name="forward-end-word",
    )
</t>
<t tx="ekr.20201202085332.61">def test_forward_end_word_extend_selection(self):
    """Test case for forward-end-word-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.20", "3.20"),
        after_sel=("3.20", "3.30"),
        command_name="forward-end-word-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.62">def test_forward_paragraph(self):
    """Test case for forward-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("15.0", "15.0"),
        command_name="forward-paragraph",
    )
</t>
<t tx="ekr.20201202085332.63">def test_forward_paragraph_extend_selection(self):
    """Test case for forward-paragraph-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("10.0", "10.0"),
        after_sel=("10.0", "15.0"),
        command_name="forward-paragraph-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.64">def test_forward_sentence(self):
    """Test case for forward-sentence"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.17", "3.17"),
        after_sel=("3.142", "3.142"),
        command_name="forward-sentence",
    )
</t>
<t tx="ekr.20201202085332.65">def test_forward_sentence_extend_selection(self):
    """Test case for forward-sentence-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.264", "1.264"),
        after_sel=("1.264", "1.395"),
        command_name="forward-sentence-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.66">def test_forward_word(self):
    """Test case for forward-word"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.261", "1.261"),
        after_sel=("1.272", "1.272"),
        command_name="forward-word",
    )
</t>
<t tx="ekr.20201202085332.67">def test_forward_word_extend_selection(self):
    """Test case for forward-word-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.395", "1.395"),
        after_sel=("1.395", "3.4"),
        command_name="forward-word-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.68">def test_indent_relative(self):
    """Test case for indent-relative"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
        line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("5.0", "5.0"),
        after_sel=("5.8", "5.8"),
        command_name="indent-relative",
    )
</t>
<t tx="ekr.20201202085332.69">def test_indent_rigidly(self):
    """Test case for indent-rigidly"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
	line 1
	    line a
	        line b
	line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "5.0"),
        after_sel=("2.0", "5.1"),
        command_name="indent-rigidly",
    )
</t>
<t tx="ekr.20201202085332.7">def test_back_sentence(self):
    """Test case for back-sentence"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.169", "3.169"),
        after_sel=("3.143", "3.143"),
        command_name="back-sentence",
    )
</t>
<t tx="ekr.20201202085332.70">def test_indent_to_comment_column(self):
    """Test case for indent-to-comment-column"""
    before_b = """\
first line
line b
last line
"""
    after_b = """\
first line
    line b
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("2.4", "2.4"),
        command_name="indent-to-comment-column",
    )
</t>
<t tx="ekr.20201202085332.71">def test_insert_newline(self):
    """Test case for insert-newline"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first li
ne
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.8", "1.8"),
        after_sel=("2.0", "2.0"),
        command_name="insert-newline",
    )
</t>
<t tx="ekr.20201202085332.72">def test_insert_parentheses(self):
    """Test case for insert-parentheses"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first() line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.5", "1.5"),
        after_sel=("1.6", "1.6"),
        command_name="insert-parentheses",
    )
</t>
<t tx="ekr.20201202085332.73">def test_kill_paragraph(self):
    """Test case for kill-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("8.0", "8.0"),
        command_name="kill-paragraph",
    )
</t>
<t tx="ekr.20201202085332.74">def test_kill_sentence(self):
    """Test case for kill-sentence"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  And
this is the last sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("1.27", "1.27"),
        command_name="kill-sentence",
    )
</t>
<t tx="ekr.20201202085332.75">def test_kill_word(self):
    """Test case for kill-word"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.6", "2.6"),
        after_sel=("2.7", "2.7"),
        command_name="kill-word",
    )
</t>
<t tx="ekr.20201202085332.76">def test_kill_line_end_body_text(self):
    """Test case for kill-line end-body-text"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2
line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.1", "4.1"),
        after_sel=("3.6", "3.6"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.77">def test_kill_line_end_line_text(self):
    """Test case for kill-line end-line-text"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2

"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.5", "3.5"),
        after_sel=("3.0", "3.0"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.78">def test_kill_line_start_line(self):
    """Test case for kill-line start-line"""
    before_b = """\
line 1
line 2
line 3
line 4
"""
    after_b = """\
line 1
line 2

line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.79">def test_kill_line_start_blank_line(self):
    """Test case for kill-line start-blank-line"""
    before_b = """\
line 1
line 2

line 4
"""
    after_b = """\
line 1
line 2
line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.8">def test_back_sentence_extend_selection(self):
    """Test case for back-sentence-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.208", "3.208"),
        after_sel=("3.143", "3.208"),
        command_name="back-sentence-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.80">def test_kill_to_end_of_line_end_body_text(self):
    """Test case for kill-to-end-of-line end-body-text"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2
line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.1", "4.1"),
        after_sel=("3.6", "3.6"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.81">def test_kill_to_end_of_line_end_line(self):
    """Test case for kill-to-end-of-line end-line"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.6", "2.6"),
        after_sel=("2.6", "2.6"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.82">def test_kill_to_end_of_line_after_last_visible_char(self):
    """Test case for kill-to-end-of-line after last visible char"""
    before_b = """\
line 1
# The next line contains two trailing blanks.
line 3  
line 4
"""
    after_b = """\
line 1
# The next line contains two trailing blanks.
line 3line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.6", "3.6"),
        after_sel=("3.6", "3.6"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.83">def test_kill_to_end_of_line_start_line(self):
    """Test case for kill-to-end-of-line start-line"""
    before_b = """\
line 1
line 2
line 3
line 4
"""
    after_b = """\
line 1
line 2

line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.84">def test_kill_to_end_of_line_start_blank_line(self):
    """Test case for kill-to-end-of-line start-blank-line"""
    before_b = """\
line 1
line 2

line 4
"""
    after_b = """\
line 1
line 2
line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.85">def test_kill_to_end_of_line_middle_line(self):
    """Test case for kill-to-end-of-line middle-line"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
li
line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("2.2", "2.2"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.86">def test_move_lines_down(self):
    """Test case for move-lines-down"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
line c
    line a
        line b
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.3", "4.3"),
        after_sel=("4.3", "5.3"),
        command_name="move-lines-down",
    )
</t>
<t tx="ekr.20201202085332.87">def test_move_lines_up(self):
    """Test case for move-lines-up"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
line 1
first line
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("1.2", "1.2"),
        command_name="move-lines-up",
    )
</t>
<t tx="ekr.20201202085332.88">def test_move_lines_up_into_docstring(self):
    """Test case for move-lines-up (into docstring)"""
    before_b = '''\
@language python
def test():
    """ a
    b
    c
    """
    print 1
    
    print 2
'''
    after_b = '''\
@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
'''
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.1", "7.1"),
        after_sel=("6.1", "6.1"),
        command_name="move-lines-up",
    )
</t>
<t tx="ekr.20201202085332.89">def test_move_past_close(self):
    """Test case for move-past-close"""
    before_b = """\
first (line)
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first (line)
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.10", "1.10"),
        after_sel=("1.12", "1.12"),
        command_name="move-past-close",
    )
</t>
<t tx="ekr.20201202085332.9">def test_back_to_indentation(self):
    """Test case for back-to-indentation"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.13", "4.13"),
        after_sel=("4.8", "4.8"),
        command_name="back-to-indentation",
    )
</t>
<t tx="ekr.20201202085332.90">def test_move_past_close_extend_selection(self):
    """Test case for move-past-close-extend-selection"""
    before_b = """\
first line
line 1
    (line )a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    (line )a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.7", "3.7"),
        after_sel=("3.7", "3.11"),
        command_name="move-past-close-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.91">def test_newline_and_indent(self):
    """Test case for newline-and-indent"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.6", "2.6"),
        after_sel=("3.4", "3.4"),
        command_name="newline-and-indent",
    )
</t>
<t tx="ekr.20201202085332.92">def test_next_line(self):
    """Test case for next-line"""
    before_b = """\
a

b
"""
    after_b = """\
a

b
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.1", "1.1"),
        after_sel=("2.0", "2.0"),
        command_name="next-line",
    )
</t>
<t tx="ekr.20201202085332.93">def test_previous_line(self):
    """Test case for previous-line"""
    before_b = """\
a

b
"""
    after_b = """\
a

b
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("2.0", "2.0"),
        command_name="previous-line",
    )
</t>
<t tx="ekr.20201202085332.94">def test_rectangle_clear(self):
    """Test case for rectangle-clear"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.6"),
        command_name="rectangle-clear",
    )
</t>
<t tx="ekr.20201202085332.95">def test_rectangle_close(self):
    """Test case for rectangle-close"""
    before_b = """\
before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
"""
    after_b = """\
before
aaabbb
aaabbb
aaabbb
aaabbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.3"),
        command_name="rectangle-close",
    )
</t>
<t tx="ekr.20201202085332.96">def test_rectangle_delete(self):
    """Test case for rectangle-delete"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaabbb
aaabbb
aaabbb
aaabbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.3"),
        command_name="rectangle-delete",
    )
</t>
<t tx="ekr.20201202085332.97">def test_rectangle_kill(self):
    """Test case for rectangle-kill"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaabbb
aaabbb
aaabbb
aaabbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("5.3", "5.3"),
        command_name="rectangle-kill",
    )
</t>
<t tx="ekr.20201202085332.98">def test_rectangle_open(self):
    """Test case for rectangle-open"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.6"),
        command_name="rectangle-open",
    )
</t>
<t tx="ekr.20201202085332.99">def test_rectangle_string(self):
    """Test case for rectangle-string"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.8"),
        command_name="rectangle-string",
    )
</t>
<t tx="ekr.20201202112206.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1763

@language python
@nosearch
</t>
<t tx="ekr.20201202144529.1"></t>
<t tx="ekr.20201203045146.1">import os
g.cls()
cwd = os.getcwd()
os.system('leo-unittest')
os.chdir(cwd)</t>
<t tx="ekr.20201203081649.1"></t>
<t tx="ekr.20201203114411.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1766

@language python
@nosearch
</t>
<t tx="ekr.20201204104619.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1768

@language python
@nosearch

</t>
<t tx="ekr.20201204172235.1">leo_cursor_width = 0

leo_vim_mode = None

def paintEvent(self, event):
    """
    LeoQTextBrowser.paintEvent.
    
    New in Leo 6.4: Draw a box around the cursor in command mode.
                    This is as close as possible to vim's look.
    """
    c, vc, w = self.leo_c, self.leo_c.vimCommands, self
    #
    # First, call the base class paintEvent.
    QtWidgets.QTextBrowser.paintEvent(self, event)
    
    def set_cursor_width(width):
        """Set the cursor width, but only if necessary."""
        if self.leo_cursor_width != width:
            self.leo_cursor_width = width
            w.setCursorWidth(width)
    
    #
    # Are we in vim mode?
    if self.leo_vim_mode is None:
        self.leo_vim_mode = c.config.getBool('vim-mode', default=False)
    #
    # Are we in command mode?
    if self.leo_vim_mode:
        in_command = vc and vc.state == 'normal'  # vim mode.
    else:
        in_command = c.k.unboundKeyAction == 'command'  # vim emulation.
    #
    # Draw the box only in command mode, when w is the body pane, with focus.
    if (
        not in_command
        or w != c.frame.body.widget
        or w != g.app.gui.get_focus()
    ):
        set_cursor_width(c.config.getInt('qt-cursor-width') or 1)
        return
    #
    # Set the width of the cursor.
    font = w.currentFont()
    cursor_width = QtGui.QFontMetrics(font).averageCharWidth()
    set_cursor_width(cursor_width)
    #
    # Draw a box around the cursor.
    qp = QtGui.QPainter()
    qp.begin(self.viewport())
    qp.drawRect(w.cursorRect())
    qp.end()
</t>
<t tx="ekr.20201205113000.1">- Fix Tea Pot.
- Find fill light.
- Fix lamp: watch YouTube vids.

- Buy Sou Vide machine, with accessories?
- Get Obama on audible.


</t>
<t tx="ekr.20201205182226.1"></t>
<t tx="ekr.20201205203155.1"></t>
<t tx="ekr.20201207055200.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1240

@language python
@nosearch
</t>
<t tx="ekr.20201207055713.1">def idle_check_leo_file(self, c):
    """Check c's .leo file for external changes."""
    path = c.fileName()
    if not self.has_changed(path):
        return
    #
    # Always update the path &amp; time to prevent future warnings.
    self.set_time(path)
    self.checksum_d[path] = self.checksum(path)
    if self.ask(c, path):
        # Do a complete restart of Leo.
        g.es_print('restarting Leo...')
        c.restartLeo()
</t>
<t tx="ekr.20201207084531.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1772

Added gdc.diff_pull_request.

@language python
@nosearch
</t>
<t tx="ekr.20201208114431.1">def diff_pull_request(self, branch_name, base_branch_name='devel', directory=None):
    """
    Create a Leonine version of the diffs that would be
    produced by a pull request between two branches.
    """
    if not directory:
        directory = os.path.join(g.app.loadDir, '..', '..')
    aList = g.execGitCommand(f"git rev-parse devel", directory)
    if aList:
        devel_rev = aList[0]
        devel_rev = devel_rev[:8]
        self.diff_two_revs(
            rev1=devel_rev,  # Before: Latest devel commit.
            rev2='HEAD',     # After: Lastest branch commit
            directory=directory,
        )
    else:
        g.es_print('FAIL: git rev-parse devel')
</t>
<t tx="ekr.20201208114843.1"># No longer needed. Use the git-diff-pr command.
import leo.commands.editFileCommands as efc
x = efc.GitDiffController(c)
x.diff_pull_request()
</t>
<t tx="ekr.20201210081319.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1775

Just remove the branch_name arg to gdc.diff_pull_request

@language python
@nosearch
</t>
<t tx="ekr.20201210120346.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1777

@language python
@nosearch
</t>
<t tx="ekr.20201210123153.1"></t>
<t tx="ekr.20201211164320.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1780

@language python
@nosearch
</t>
<t tx="ekr.20201211182659.1">def standard_timestamp():
    """Return a reasonable timestamp."""
    return time.strftime("%Y%m%d-%H%M%S")
</t>
<t tx="ekr.20201211182722.1"></t>
<t tx="ekr.20201211183100.1">def get_backup_path(sub_directory):
    """
    Return the full path to the subdirectory of the main backup directory.
    
    The main backup directory is computed as follows:
        
    1. os.environ['LEO_BACKUP']
    2. ~/Backup
    """
    # Transcrypt does not support Python's pathlib module.
    # __pragma__ ('skip')

    from pathlib import Path
    # Compute the main backup directory.
    # First, try the LEO_BACKUP directory.
    backup = None
    try:
        backup = os.environ['LEO_BACKUP']
        if not os.path.exists(backup):
            backup = None
    except KeyError:
        pass
    except Exception:
        g.es_exception()
    # Second, try ~/Backup.
    if not backup:
        backup = os.path.join(str(Path.home()), 'Backup')
        if not os.path.exists(backup):
            backup = None
    if not backup:
        return None
    # Compute the path to backup/sub_directory
    directory = os.path.join(backup, sub_directory)
    return directory if os.path.exists(directory) else None
</t>
<t tx="ekr.20201212090129.1"></t>
<t tx="ekr.20201212091359.1">@language rest
@wrap

Leonine diffs of .leo files
https://github.com/leo-editor/leo-editor/issues/1781

@language python
@nosearch
</t>
<t tx="ekr.20201212175532.1"></t>
<t tx="ekr.20201213055506.1">@nosearch

# flattened, word, ignore-case, head, body

# found 5 nodes</t>
<t tx="ekr.20201213172138.1">@language rest
@wrap

https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging

Stage 1 is the common ancestor,
stage 2 is your version 
stage 3 is from the MERGE_HEAD, the version youre merging in (theirs).

You can extract a copy of each of these versions of the conflicted file with the git show command:

$ git show :1:hello.rb &gt; hello.common.rb
$ git show :2:hello.rb &gt; hello.ours.rb
$ git show :3:hello.rb &gt; hello.theirs.rb

</t>
<t tx="ekr.20201214173524.1"></t>
<t tx="ekr.20201214185152.1"># https://github.com/leo-editor/leo-editor/issues/1781
# g.cls()
from leo.commands import editFileCommands
import importlib
importlib.reload(efc)
fn = 'git_diff_test.leo'
rev1, rev2 = '1ae08a66', 'HEAD'  # 'HEAD@{1}', 'HEAD@{0}'
x = efc.GitDiffController(c)
x.set_directory(None)
x.root = x.create_root(rev1, rev2)
x.diff_file(fn, rev1=rev1, rev2=rev2)
c.redraw()
</t>
<t tx="ekr.20201215050832.1">def make_leo_outline(self, fn, path, s, rev):
    """Create a hidden temp outline for the .leo file in s."""
    hidden_c = leoCommands.Commands(fn, gui=g.app.nullGui)
    hidden_c.frame.createFirstTreeNode()
    root = hidden_c.rootPosition()
    root.h = fn + ':' + rev if rev else fn
    hidden_c.fileCommands.getLeoFile(
        theFile=g.FileLikeObject(fromString=s),
        fileName=path,
        readAtFileNodesFlag=False,
        silent=False,
        checkOpenFiles=False,
    )
    return hidden_c
</t>
<t tx="ekr.20201215093414.1">@cmd('git-diff-pull-request')
@cmd('git-diff-pr')
def gitDiffPullRequest(self, event=None):
    """
    Produce a Leonine diff of pull request in the current branch.
    """
    GitDiffController(c=self.c).diff_pull_request()
</t>
<t tx="ekr.20201215145115.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1783

@font-size-tree

@language python
@nosearch
</t>
<t tx="ekr.20201216061006.1">@nosearch

# flattened, ignore-case, head, body

# found 4 nodes</t>
<t tx="ekr.20201216061211.1"></t>
<t tx="ekr.20201216080221.1">- Finish documentation for vim changes.
  https://github.com/leo-editor/leo-editor/issues/1757</t>
<t tx="ekr.20201216114709.1">@language rest
@wrap

FAIL: javaScripthon: (pj -h)
- Created ekr-no-fstrings branch for this.
- Doesn't handle f-strings.
- Assertion fails in leoNodes.py without explanation.

rapydscript: npm package. Command-line shell.

transcrypt:  (note spelling) pip install transcript.
- -a annotated code.
- -m Source maps.
- -n Suppresses minimization.
- Fails on Python's copy module. There are workarounds.
- Produces good error messages.

@language python

# Transcrypt does not support Python's copy module.
# __pragma__ ('skip')


# __pragma__ ('noskip')
</t>
<t tx="ekr.20201217144708.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1788

@language python
@nosearch
</t>
<t tx="ekr.20201217195428.1">from leo\.(\w+)\. import (\w+) as \w+

import leo\.(\w+)\.(\w+) as \w+
from leo.\1 import \2</t>
<t tx="ekr.20201217205859.1">gnx: ekr.20201012111338.2
unl: Declarations (leo_cloud.py)
gnx: ekr.20201012111338.3
unl: init (leo_cloud.py)
gnx: ekr.20201012111338.4
unl: onCreate (leo_cloud.py)
gnx: ekr.20201012111338.5
unl: onSave (leo_cloud.py)
gnx: ekr.20201012111338.6
unl: lc_read_current (leo_cloud.py)
gnx: ekr.20201012111338.7
unl: lc_write_current (leo_cloud.py)
gnx: ekr.20201012111338.8
unl: class LeoCloudIOBase
gnx: ekr.20201012111338.9
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.__init__
gnx: ekr.20201012111338.10
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.get_subtree
gnx: ekr.20201012111338.11
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.put_subtree
gnx: ekr.20201012111338.12
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)
gnx: ekr.20201012111338.13
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).__init__
gnx: ekr.20201012111338.14
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).get_data
gnx: ekr.20201012111338.15
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).put_data
gnx: ekr.20201012111338.16
unl: class LeoCloudIOGit(LeoCloudIOBase)
gnx: ekr.20201012111338.17
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).__init__
gnx: ekr.20201012111338.18
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase)._run_git
gnx: ekr.20201012111338.19
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).get_data
gnx: ekr.20201012111338.20
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).put_data
gnx: ekr.20201012111338.21
unl: class LeoCloud
gnx: ekr.20201012111338.22
unl: class LeoCloud--&gt;LeoCloud.__init__
gnx: ekr.20201012111338.23
unl: class LeoCloud--&gt;LeoCloud.bg_check
gnx: ekr.20201012111338.24
unl: class LeoCloud--&gt;LeoCloud.bg_post_process
gnx: ekr.20201012111338.25
unl: class LeoCloud--&gt;LeoCloud.find_at_leo_cloud
gnx: ekr.20201012111338.26
unl: class LeoCloud--&gt;LeoCloud._find_clouds_recursive
gnx: ekr.20201012111338.27
unl: class LeoCloud--&gt;LeoCloud.find_clouds
gnx: ekr.20201012111338.28
unl: class LeoCloud--&gt;LeoCloud._from_dict_recursive
gnx: ekr.20201012111338.29
unl: class LeoCloud--&gt;LeoCloud.from_dict
gnx: ekr.20201012111338.30
unl: class LeoCloud--&gt;LeoCloud.io_from_node
gnx: ekr.20201012111338.31
unl: class LeoCloud--&gt;LeoCloud.kw_from_node
gnx: ekr.20201012111338.32
unl: class LeoCloud--&gt;LeoCloud.load_clouds
gnx: ekr.20201012111338.33
unl: class LeoCloud--&gt;LeoCloud.read_current
gnx: ekr.20201012111338.34
unl: class LeoCloud--&gt;LeoCloud.recursive_hash
gnx: ekr.20201012111338.35
unl: class LeoCloud--&gt;LeoCloud.save_clouds
gnx: ekr.20201012111338.36
unl: class LeoCloud--&gt;LeoCloud.subtree_changed
gnx: ekr.20201012111338.37
unl: class LeoCloud--&gt;LeoCloud._to_json_serial
gnx: ekr.20201012111338.38
unl: class LeoCloud--&gt;LeoCloud.to_json
gnx: ekr.20201012111338.39
unl: class LeoCloud--&gt;LeoCloud._to_dict_recursive
gnx: ekr.20201012111338.40
unl: class LeoCloud--&gt;LeoCloud.to_dict
gnx: ekr.20201012111338.41
unl: class LeoCloud--&gt;LeoCloud._ua_clean
gnx: ekr.20201012111338.42
unl: class LeoCloud--&gt;LeoCloud.write_current
</t>
<t tx="ktenney.20041211072654.14">def processDirectory(self, path, node):

    """
    create child nodes for each member of the directory

    @path is a path object for a directory
    @node is the node to work with
    """
    # delete all nodes before creating, to avoid duplicates
    while node.firstChild():
        node.firstChild().doDelete(node)

    for file in path.files():
        child = node.insertAsLastChild()
        child.h = '@view %s' % file.name

    for file in path.dirs():
        child = node.insertAsLastChild()
        child.h = '@view %s' % file.name
</t>
<t tx="maphew.20171120133429.1">user_requires = [
    'PyQt5 &gt;= 5.12',  # v5.12+ to close #1217
    'PyQtWebEngine',  # #1202 QtWebKit needs to be installed separately starting Qt 5.6
    'asttokens',  # abstract syntax tree text parsing
    'docutils',  # used by Sphinx, rST plugin
    'flexx',  # for LeoWapp browser gui
    'meta',  # for livecode.py plugin, which is enabled by default
    'nbformat',  # for Jupyter notebook integration
    'pylint', 'pyflakes', 'black',  # coding syntax standards
    'pyshortcuts &gt;= 1.7',  # desktop integration (#1243)
    'sphinx',  # rST plugin
    'windows-curses; platform_system=="Windows"',  # for console mode on Windows
    ]
</t>
<t tx="peckj.20130207132858.3671">def update_md(self, s, keywords):
    '''Update markdown text in the vr pane.'''
    pc = self; c = pc.c; p = c.p
    s = s.strip().strip('"""').strip("'''").strip()
    isHtml = s.startswith('&lt;') and not s.startswith('&lt;&lt;')
    # Do this regardless of whether we show the widget or not.
    w = pc.ensure_text_widget()
    assert pc.w
    if s:
        pc.show()
    if got_markdown:
        force = keywords.get('force')
        colorizer = c.frame.body.colorizer
        language = colorizer.scanLanguageDirectives(p)
        if force or language in ('rst', 'rest', 'markdown', 'md'):
            if not isHtml:
                s = self.convert_to_markdown(s)
        self.set_html(s,w)
    else:
        # g.trace('markdown not available: using rst')
        self.update_rst(s,keywords)
</t>
<t tx="peckj.20140804103733.9246">class TagController:
    
    TAG_LIST_KEY = '__node_tags'

    @others
</t>
<t tx="peckj.20140804103733.9258">def get_tagged_nodes(self, tag):
    ''' return a list of *positions* of nodes containing the tag, with * as a wildcard '''
    nodelist = []
    # replace * with .* for regex compatibility
    tag = tag.replace('*', '.*')
    regex = re.compile(tag)
    for p in self.c.all_unique_positions():
        for tag in self.get_tags(p):
            if regex.match(tag):
                nodelist.append(p.copy())
                break
    return nodelist
</t>
<t tx="peckj.20140804103733.9259">def get_tags(self, p):
    ''' returns a list of tags applied to position p.'''
    if p:
        tags = p.v.u.get(self.TAG_LIST_KEY, set([]))
        return list(tags)
    return []
</t>
<t tx="peckj.20140804103733.9260">def add_tag(self, p, tag):
    ''' adds 'tag' to the taglist of v '''
    # cast to set() incase JSON storage (leo_cloud plugin) converted to list
    tags = set(p.v.u.get(self.TAG_LIST_KEY, set([])))
    tags.add(tag)
    p.v.u[self.TAG_LIST_KEY] = tags
    self.c.setChanged()
    self.update_taglist(tag)
</t>
<t tx="peckj.20140804103733.9261">def remove_tag(self, p, tag):
    ''' removes 'tag' from the taglist of position p. '''
    v = p.v
    tags = set(v.u.get(self.TAG_LIST_KEY, set([])))
        # in case JSON storage (leo_cloud plugin) converted to list.
    if tag in tags:
        tags.remove(tag)
    if tags:
        v.u[self.TAG_LIST_KEY] = tags
    else:
        del v.u[self.TAG_LIST_KEY]
        # prevent a few corner cases, and conserve disk space
    self.c.setChanged()
    self.update_taglist(tag)
</t>
<t tx="peckj.20140804103733.9262">def __init__(self, c):
    
    self.c = c
    self.taglist = []
    self.initialize_taglist()
    c.theTagController = self
    self.ui = LeoTagWidget(c)
    c.frame.log.createTab('Tags', widget=self.ui)
    self.ui.update_all()
</t>
<t tx="peckj.20140804103733.9263">def initialize_taglist(self):
    taglist = []
    for p in self.c.all_unique_positions():
        for tag in self.get_tags(p):
            if tag not in taglist:
                taglist.append(tag)
    self.taglist = taglist

</t>
<t tx="peckj.20140804103733.9264"></t>
<t tx="peckj.20140804103733.9265"></t>
<t tx="peckj.20140804103733.9267">def update_taglist(self, tag):
    ''' ensures the outline's taglist is consistent with the state of the nodes in the outline '''
    if tag not in self.taglist:
        self.taglist.append(tag)
    nodelist = self.get_tagged_nodes(tag)
    if not nodelist:
        self.taglist.remove(tag)
    self.ui.update_all()
</t>
<t tx="peckj.20140804103733.9268">def get_all_tags(self):
    ''' return a list of all tags in the outline '''
    return self.taglist
</t>
<t tx="peckj.20150428142729.19">def keyPressEvent(self, event):
    qt = QtCore.Qt
    try:
        # #1212: Disable this by default.
        if use_rlcompleter and event.key() == qt.Key_Tab:
            line = str(self.document().lastBlock().text())[4:]
            completer = Completer(self.interpreter.locals)
            suggestion = completer.complete(line, 0)
            if suggestion is not None:
                self.insertPlainText(suggestion[len(line):])
            return
        if event.key() == qt.Key_Down:
            if self.historyIndex == len(self.history):
                self.historyIndex -= 1
            try:
                if self.historyIndex &gt; -1:
                    self.historyIndex -= 1
                    self.recallHistory()
                else:
                    self.clearCurrentBlock()
            except Exception:
                pass
            return
        if event.key() == qt.Key_Up:
            try:
                if len(self.history) - 1 &gt; self.historyIndex:
                    self.historyIndex += 1
                    self.recallHistory()
                else:
                    self.historyIndex = len(self.history)
            except Exception:
                pass
            return
        if event.key() == qt.Key_Home:
            # set cursor to position 4 in current block. 4 because that's where
            # the marker stops
            blockLength = len(self.document().lastBlock().text()[4:])
            lineLength  = len(self.document().toPlainText())
            position = lineLength - blockLength
            textCursor  = self.textCursor()
            textCursor.setPosition(position)
            self.setTextCursor(textCursor)
            return
        if event.key() in [qt.Key_Left, qt.Key_Backspace]:
            # don't allow deletion of marker
            if self.textCursor().positionInBlock() == 4:
                return
        if event.key() in [qt.Key_Return, qt.Key_Enter]:
            self.doEnter(event)
            return
        # allow all other key events
        super(PyInterp, self).keyPressEvent(event)
    except Exception:
        g.es_exception()

    
</t>
<t tx="tbrown.20080514112857.124">def doMenuat(self, p, kind, name, val):
    """Handle @menuat setting."""
    if g.app.config.menusList:
        # get the patch fragment
        patch = []
        if p.hasChildren():
            # self.doMenus(p.copy().firstChild(),kind,name,val,storeIn=patch)
            self.doItems(p.copy(), patch)
        # setup
        parts = name.split()
        if len(parts) != 3:
            parts.append('subtree')
        targetPath, mode, source = parts
        if not targetPath.startswith('/'):
            targetPath = '/' + targetPath
        ans = self.patchMenuTree(g.app.config.menusList, targetPath)
        if ans:
            # pylint: disable=unpacking-non-sequence
            list_, idx = ans
            if mode not in ('copy', 'cut'):
                if source != 'clipboard':
                    use = patch  # [0][1]
                else:
                    if isinstance(self.clipBoard, list):
                        use = self.clipBoard
                    else:
                        use = [self.clipBoard]
            if mode == 'replace':
                list_[idx] = use.pop(0)
                while use:
                    idx += 1
                    list_.insert(idx, use.pop(0))
            elif mode == 'before':
                while use:
                    list_.insert(idx, use.pop())
            elif mode == 'after':
                while use:
                    list_.insert(idx + 1, use.pop())
            elif mode == 'cut':
                self.clipBoard = list_[idx]
                del list_[idx]
            elif mode == 'copy':
                self.clipBoard = list_[idx]
            else:  # append
                list_.extend(use)
        else:
            g.es_print("ERROR: didn't find menu path " + targetPath)
    elif g.app.inBridge:
        pass  # #48: Not an error.
    else:
        g.es_print("ERROR: @menuat found but no menu tree to patch")
</t>
<t tx="tbrown.20080514180046.2">def dumpMenuTree(self, aList, level=0, path=''):
    for z in aList:
        kind, val, val2 = z
        pad = '    ' * level
        if kind == '@item':
            name = self.getName(val, val2)
            g.es_print(f"{pad} {val} ({val2}) [{path + '/' + name}]")
        else:
            name = self.getName(kind.replace('@menu ', ''))
            g.es_print(f"{pad} {kind}... [{path + '/' + name}]")
            self.dumpMenuTree(val, level + 1, path=path + '/' + name)
</t>
<t tx="tbrown.20080514180046.8">def patchMenuTree(self, orig, targetPath, path=''):

    for n, z in enumerate(orig):
        kind, val, val2 = z
        if kind == '@item':
            name = self.getName(val, val2)
            curPath = path + '/' + name
            if curPath == targetPath:
                return orig, n
        else:
            name = self.getName(kind.replace('@menu ', ''))
            curPath = path + '/' + name
            if curPath == targetPath:
                return orig, n
            ans = self.patchMenuTree(val, targetPath, path=path + '/' + name)
            if ans:
                return ans
    return None
</t>
<t tx="tbrown.20080514180046.9">def getName(self, val, val2=None):
    if val2 and val2.strip(): val = val2
    val = val.split('\n', 1)[0]
    for i in "*.-&amp; \t\n":
        val = val.replace(i, '')
    return val.lower()
</t>
<t tx="tbrown.20080613095157.10">def openDir(c,parent,d):
    """
    Expand / refresh an existing folder

    Note: With the addition of per folder inclusion/exclusion a check is done
    against both the current list of nodes and against the files/folders as
    they exist on the system. This check must be done in both places to keep
    the node list in sync with the file system while respecting the inc/exc
    lists - John Lunzer
    """

    # compare folder content to children
    try:
        path, dirs, files = next(os.walk(d))
    except StopIteration:
        # directory deleted?
        c.setHeadString(parent,'*'+parent.h.strip('*')+'*')
        return

    # parent.expand()  # why?

    oldlist = set()
    toRemove = set()
    newlist = []

    bodySplit = parent.b.splitlines()

    excdirs = False
    excfiles = False
    regEx = False
    if re.search('^excdirs', parent.b, flags=re.MULTILINE):
        excdirs = True
    if re.search('^excfiles', parent.b, flags=re.MULTILINE):
        excfiles = True
    if re.search('^re', parent.b, flags=re.MULTILINE):
        regEx = True

    inc = [line.replace('inc=','') for line in bodySplit if line.startswith('inc=')]
    exc = [line.replace('exc=','') for line in bodySplit if line.startswith('exc=')]

    #flatten lists if using comma separations
    inc = [item for line in inc for item in line.strip(' ').split(',')]
    exc = [item for line in exc for item in line.strip(' ').split(',')]

    # get children info
    for p in flattenOrganizers(parent):
        entry = p.h.strip('/*')
        if entry.startswith('@'):  # remove only the @part
            directive = entry.split(None,1)
            if len(directive) &gt; 1:
                entry = entry[len(directive[0]):].strip()
        #find existing inc/exc nodes to remove
        #using p.h allows for example exc=/ to remove all directories
        if not checkIncExc(p.h,inc,exc, regEx) or \
               (excdirs and entry in dirs) or \
               (excfiles and entry in files):
            toRemove.add(p.h) #must not strip '/', so nodes can be removed
        else:
            oldlist.add(entry)

    # remove existing found inc/exc nodes
    for headline in toRemove:
        found = g.findNodeInChildren(c,parent,headline)
        if found:
            found.doDelete()

    # dirs trimmed by toRemove to remove redundant checks
    for d2 in set(dirs)-set([h.strip('/') for h in toRemove]):
        if d2 in oldlist:
            oldlist.discard(d2)
        else:
            if checkIncExc(d2,
                           [i.strip('/') for i in inc],
                           [e.strip('/') for e in exc],
                           regEx) and not excdirs:
                newlist.append('/'+d2+'/')

    # files trimmed by toRemove, retains original functionality of plugin
    for f in set(files)-toRemove:
        if f in oldlist:
            oldlist.discard(f)
        else:
            if checkIncExc(f, inc, exc, regEx) and not excfiles:
                newlist.append(f)

    # insert newlist
    newlist.sort()
    ignored = 0
    newlist.reverse()  # un-reversed by the following loop
    for name in newlist:
        if inReList(name, c.__active_path['ignore']):
            ignored += 1
            continue

        p = parent.insertAsNthChild(0)
        c.setChanged()
        p.h = name
        if name.startswith('/'):
            # sufficient test of dirness as we created newlist
            p.b = '@path '+name.strip('/')
        elif (c.__active_path['do_autoload'] and
              inReList(name, c.__active_path['autoload'])):
            openFile(c, p, os.path.join(d, p.h), autoload=True)
        elif (c.__active_path['do_autoload'] and
              c.__active_path['load_docstring'] and
              name.lower().endswith(".py")):
            # do_autoload suppresses doc string loading because turning
            # autoload off is supposed to address situations where autoloading
            # causes problems, so don't still do some form of autoloading
            p.b = c.__active_path['DS_SENTINEL']+"\n\n"+loadDocstring(os.path.join(d, p.h))
        p.setMarked()
        p.contract()

    if ignored:
        g.es('Ignored %d files in directory' % ignored)

    # warn / mark for orphan oldlist
    for p in flattenOrganizers(parent):
        h = p.h.strip('/*')  # strip / and *
        if (h not in oldlist or
            (p.hasChildren() and not isDirNode(p))
        ):  # clears bogus '*' marks
            nh = p.h.strip('*')  # strip only *
        else:
            nh = '*'+p.h.strip('*')+'*'
            if isDirNode(p):
                for orphan in p.subtree():
                    c.setHeadString(orphan, '*'+orphan.h.strip('*')+'*')
        if p.h != nh:  # don't dirty node unless we must
            p.h = nh

    c.selectPosition(parent)
</t>
<t tx="tbrown.20080613095157.8">def createFile(c,parent,d):
    """Ask if we should create a new file"""
    directory = os.path.dirname(d)
    if not os.path.isdir(directory):
        g.error('Create parent directories first')
        return False

    d = os.path.basename(d)
    atType = c.config.getString('active-path-attype') or 'auto'
    ok = g.app.gui.runAskYesNoDialog(c, 'Create / load file?',
        'Create file @'+atType+' '+d+'?')
    if ok == 'no':
        return False
    parent.h = '@'+atType+' '+d
    c.bodyWantsFocus()
    return True
</t>
<t tx="tbrown.20090119215428.11">def __init__ (self,c):
    '''ctor for todoController class.'''
    self.c = c
    c.cleo = self
    self.donePriority = 100
    self.menuicons = {}  # menu icon cache
    self.recentIcons = []
    #X self.smiley = None
    self.redrawLevels = 0
    self._widget_to_style = None  # see updateStyle()
    self.reloadSettings()
    self.handlers = [
       ("close-frame",self.close),
       ('select3', self.updateUI),
       ('save2', self.loadAllIcons),
       ('idle', self.updateStyle),
    ]
    # chdir so the Icons can be located, needed for uic resources
    owd = os.getcwd()
    os.chdir(g.os_path_join(g.app.loadDir, '..', 'plugins'))
    self.ui = todoQtUI(self)
    os.chdir(owd)
    for i in self.handlers:
        g.registerHandler(i[0], i[1])
    self.loadAllIcons()
    # correct spinTime suffix:
    self.ui.UI.spinTime.setSuffix(" " + self.time_name)
    # #1591: patch labels if necessary.
    self.patch_1591()
</t>
<t tx="tbrown.20090119215428.12">def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    self.time_name = c.config.getString('todo-time-name') or 'days'
    self.icon_location = c.config.getString('todo-icon-location') or 'beforeHeadline'
    self.prog_location = c.config.getString('todo-prog-location') or 'beforeHeadline'
    self.icon_order = c.config.getString('todo-icon-order') or 'pri-first'
</t>
<t tx="tbrown.20090119215428.34">@redrawer
def show_times(self, p=None, show=False):

    def rnd(x):
        return re.sub('.0$', '', '%.1f' % x)

    if p is None:
        p = self.c.currentPosition()

    for nd in p.self_and_subtree():
        p.h = re.sub(' &lt;[^&gt;]*&gt;$', '', nd.headString())
        tr = self.getat(nd.v, 'time_req')
        pr = self.getat(nd.v, 'progress')
        try: pr = float(pr)
        except Exception: pr = ''
        if tr != '' or pr != '':
            ans = ' &lt;'
            if tr != '':
                if pr == '' or pr == 0 or pr == 100:
                    ans += rnd(tr) + ' ' + self.time_name
                else:
                    ans += '%s+%s=%s %s' % (rnd(pr/100.*tr), rnd((1-pr/100.)*tr), rnd(tr), self.time_name)
                if pr != '': ans += ', '
            if pr != '':
                ans += rnd(pr) + '%'  # pr may be non-integer if set by recalc_time
            ans += '&gt;'

            if show:
                nd.h = nd.h+ans
            self.loadIcons(nd)  # update progress icon

</t>
<t tx="tbrown.20090119215428.49">def updateUI(self,tag=None,k=None):

    if k and k['c'] != self.c:
        return  # wrong number

    v = self.c.currentPosition().v

    # check work date &lt; due date and do stylesheet re-evaluation stuff
    nwd = self.getat(v, 'nextworkdate')
    due = self.getat(v, 'duedate')
    w = self.ui.UI.frmDates
    if nwd and due and str(nwd) &gt; str(due):
        w.setProperty('style_class', 'tododate_error')
    else:
        w.setProperty('style_class', '')
    # update style on this widget on idle, see updateStyle()
    self._widget_to_style = (w, time.time())

    self.ui.setProgress(int(self.getat(v, 'progress') or 0 ))
    self.ui.setTime(float(self.getat(v, 'time_req') or 0 ))

    self.ui.setDueDate(self.getat(v, 'duedate'))
    # default is "", which is understood by setDueDate()
    self.ui.setDueTime(self.getat(v, 'duetime'))
    # ditto

    self.ui.setDueDate(self.getat(v, 'duedate'))
    self.ui.setDueTime(self.getat(v, 'duetime'))
    self.ui.setNextWorkDate(self.getat(v, 'nextworkdate'))
    self.ui.setNextWorkTime(self.getat(v, 'nextworktime'))
    # pylint: disable=maybe-no-member
    created = self.getat(v,'created')
    if created and isinstance(created, datetime.datetime) and created.year &gt;= 1900:
        self.ui.UI.createdTxt.setText(created.strftime("%d %b %y"))
        self.ui.UI.createdTxt.setToolTip(created.strftime("Created %H:%M %d %b %Y"))
    else:
        # .strftime doesn't work here! This has has happened...
        try:
            gdate = self.c.p.v.gnx.split('.')[1][:12]
            created = datetime.datetime.strptime(gdate, '%Y%m%d%H%M')
            if created.year &lt; 1900:
                created = None
        except Exception:
            created = None
        if created:
            self.ui.UI.createdTxt.setText(created.strftime("Created %d %b %Y"))
            self.ui.UI.createdTxt.setToolTip(created.strftime("gnx created %H:%M %d %b %Y"))
        else:
            self.ui.UI.createdTxt.setText("")

    # Update the label.
    h = self.c and self.c.p and self.c.p.h
    due = self.getat(v, 'duedate')
    ago = (datetime.date.today()-created.date()).days if created else 0
    if due:
        days = (due - datetime.date.today()).days
        txt = f"{h}\nCreated {ago} days ago, due in {days}"
    else:
        txt = f"{h}\nCreated {ago} days ago"
    self.ui.UI.txtDetails.setText(txt)
    prisetdate = self.getat(v, 'prisetdate')
    self.ui.UI.txtDetails.setToolTip("Priority set %s" %
        (str(prisetdate).strip() or '?')
    )
</t>
<t tx="tbrown.20100120100336.7830">if encOK:

    def get_AES():
        if hasattr(AES, 'MODE_EAX'):
            # pylint: disable=no-member
            return AES.new(__ENCKEY[0], AES.MODE_EAX)
                # #1265: When in doubt, use MODE_EAX.
                # https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html
        # pylint: disable=no-value-for-parameter
        return AES.new(__ENCKEY[0])

    def sn_decode(s):
        try:
            s1 = base64.b64decode(s)
            return get_AES().decrypt(s1).decode('utf8').strip()
        except Exception:
            g.es("encryption failed")
            __ENCKEY[0] = None
            return None

    def sn_encode(s):
        s1 = s.encode('utf8')
        pad = b' '*(16-len(s1)%16)
        txta = get_AES().encrypt(s1 + pad)
        txt = base64.b64encode(txta)
        txt = str(txt, 'utf-8')
        wrapped = textwrap.wrap(txt, break_long_words=True)
        return '\n'.join(wrapped)

    @g.command('stickynoteenckey')
    def sn_getenckey(dummy=None):
        txt,ok = QInputDialog.getText(None,
            'Enter key',
            'Enter key.\nData lost if key is lost.\nSee docs. for key upgrade notes.',
        )
        if not ok:
            return
        if str(txt).startswith('v0:'):
            txt = QString(txt[3:])
        else:
            txt = g.toUnicode(txt)
        # arbitrary kludge to convert string to 256 bits - don't change
        sha = SHA.new()
        md5 = MD5.new()
        sha.update(txt.encode('utf-8'))
        md5.update(txt.encode('utf-8'))
        __ENCKEY[0] = sha.digest()[:16] + md5.digest()[:16]
        if len(__ENCKEY[0]) != 32:
            raise Exception("sn_getenckey failed to build key")
</t>
<t tx="tbrown.20100318101414.5995">def init():
    '''Return True if the plugin has loaded successfully.'''
    global got_docutils
    if g.app.gui.guiName() != 'qt':
        return False
            # #1248.
    # if g.app.gui.guiName()
    if not QtWidgets or not g.app.gui.guiName().startswith('qt'):
        if (
            not g.unitTesting and
            not g.app.batchMode and
            g.app.gui.guiName() not in ('browser', 'curses')
        ):
            g.es_print('viewrendered requires Qt')
        return False
    if not got_docutils:
        g.es_print('Warning: viewrendered.py running without docutils.')
    # Always enable this plugin, even if imports fail.
    g.plugin_signon(__name__)
    g.registerHandler('after-create-leo-frame', onCreate)
    g.registerHandler('close-frame', onClose)
    g.registerHandler('scrolledMessage', show_scrolled_message)
    return True
</t>
<t tx="tbrown.20110629084915.35150">def ns_provides(self):
    # #1671: Better Window names.
    # #1678: duplicates in Open Window list
    return [('Viewrendered', self.ns_provider_id())]
</t>
<t tx="tbrown.20110629084915.35151">def ns_provide(self, id_):
    global controllers, layouts
    # #1678: duplicates in Open Window list
    if id_ == self.ns_provider_id():
        c = self.c
        vr = controllers.get(c.hash()) or ViewRenderedController(c)
        h = c.hash()
        controllers[h] = vr
        if not layouts.get(h):
            layouts[h] = c.db.get('viewrendered_default_layouts', (None, None))
        # return ViewRenderedController(self.c)
        return vr
    return None
</t>
<t tx="tbrown.20110629132207.8984">def show_scrolled_message(tag, kw):
    if g.unitTesting:
        return None # This just slows the unit tests.
    c = kw.get('c')
    flags = kw.get('flags') or 'rst'
    vr = viewrendered(event=kw)
    title = kw.get('short_title', '').strip()
    vr.setWindowTitle(title)
    s = '\n'.join([
        title,
        '=' * len(title),
        '',
        kw.get('msg')
    ])
    vr.show_dock_or_pane() # #1332.
    vr.update(
        tag='show-scrolled-message',
        keywords={'c': c, 'force': True, 's': s, 'flags': flags},
    )
    return True
</t>
<t tx="tbrown.20111011094944.27031">def tab_callback(self):
    """Called when user hits tab on an item in the QListWidget."""
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper  # 2014/09/19
    if w is None: return
    # Replace the tail of the prefix with the completion.
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &lt; 2:
        return
    i = j = w.getInsertPoint()
    s = w.getAllText()
    while (0 &lt;= i &lt; len(s) and s[i] != '.'):
        i -= 1
    i += 1
    if j &gt; i:
        w.delete(i, j)
    w.setInsertPoint(i)
    c.k.autoCompleter.compute_completion_list()
</t>
<t tx="tbrown.20130411145310.18855">def wheelEvent(self, event):
    """Handle a wheel event."""
    if QtCore.Qt.ControlModifier &amp; event.modifiers():
        d = {'c': self.leo_c}
        if isQt5:
            point = event.angleDelta()
            delta = point.y() or point.x()
        else:
            delta = event.delta()
        if delta &lt; 0:
            zoom_out(d)
        else:
            zoom_in(d)
        event.accept()
        return
    QtWidgets.QTextBrowser.wheelEvent(self, event)
</t>
<t tx="tbrown.20140801105909.47553">def run(self, s, parent, parse_body=False):
    '''Override Importer.run()'''
    # c = self.c
    root = parent.copy()
    cchar = '#'
    if self.fileType.lower() == '.tex':
        cchar = '%'
    if self.fileType.lower() == '.sql':
        cchar = '-'
    if self.fileType.lower() == '.js':
        cchar = '/'
    level = -1
    nd = parent.copy()
    lines = []
    for line in s.split('\n'):
        if line.startswith(cchar * 3):
            word = line.split()
            if word[0].strip(cchar) == '':
                self.write_lines(nd, lines)
                new_level = len(word[0]) - 3
                if new_level &gt; level:
                    # go down one level
                    level = new_level
                    nd = nd.insertAsLastChild()
                    nd.h = ' '.join(word[1:]).strip(cchar + ' ')
                else:
                    # go up zero or more levels
                    while level &gt; new_level and level &gt; 0:
                        level -= 1
                        nd = nd.parent()
                    nd = nd.insertAfter()
                    nd.h = ' '.join(word[1:]).strip(cchar + ' ')
        else:
            lines.append(line)
    self.write_lines(nd, lines)
    # It's always useless for an an import to dirty the outline.
    for p in root.self_and_subtree():
        p.clearDirty()
    # #1451: The caller should be responsible for this.
        # if changed:
            # c.setChanged()
        # else:
            # c.clearChanged()
    return True
</t>
<t tx="tbrown.20150807090639.1">def declutter_node(self, c, p, item):
    """declutter_node - change the appearance of a node

    :param commander c: commander containing node
    :param position p: position of node
    :param QWidgetItem item: tree node widget item
    
    returns composite icon for this node
    """
    dd = self.declutter_data
    iconVal = p.v.computeIcon()
    iconName = f'box{iconVal:02d}.png'
    loaded_images = self.loaded_images
    @others
    if (p.h, iconVal) in dd:
        text, new_icons = dd[(p.h, iconVal)]
        item.setText(0, text)
        new_icons = sorted_icons(p) + new_icons
    else:
        text = p.h
        new_icons = []
        for pattern, cmds in self.get_declutter_patterns():
            m = pattern.match(text) or pattern.search(text)
            if m:
                apply_declutter_rules(cmds)
        dd[(p.h, iconVal)] = item.text(0), new_icons
        new_icons = sorted_icons(p) + new_icons
        preload_images()
    self.nodeIconsDict[p.gnx] = new_icons
    h = ':'.join(new_icons)
    icon = g.app.gui.iconimages.get(h)
    if not icon:
        preload_images()
        images = [loaded_images.get(x) for x in new_icons]
        icon = self.make_composite_icon(images)
        g.app.gui.iconimages[h] = icon
    return icon
</t>
<t tx="tbrown.20150818161651.4">def build_menu(self):
    """build_menu - build the menu of settings, called from handleSpecialMenus()
    """
    menu = self.c.frame.menu
    # Create the Edit Settings menu at the end of the Settings menu.
    settings_menu = menu.getMenu('Settings')
    menu.add_separator(settings_menu)
    menu.createNewMenu('Edit Settings', 'Settings')
    finder_menu = self._outline_data_to_python(
        self.c.config.getOutlineData("settings-finder-menu"))
    aList = []
    self.tree_to_menulist(aList, finder_menu)
    menu.createMenuFromConfigList("Edit Settings", aList[0][1])
        # #1144: Case must match.
        # aList is [['@outline-data settings-finder-menu', &lt;list of submenus&gt;, None]]
        # so aList[0][1] is the list of submenus
    return aList
</t>
<t tx="ville.20090614224528.8141">def auto_walk(c, directory, parent=None, isroot=True):
    """
    source: http://leo.zwiki.org/CreateShadows

    (create @auto files instead)
    """
    from os import listdir
    from os.path import join, abspath, basename, normpath, isfile
    from fnmatch import fnmatch
    # import os

    RELATIVE_PATHS = False
    patterns_to_ignore = ['*.pyc', '*.leo', '*.gif', '*.png', '*.jpg', '*.json']
    patterns_to_import = ['*.py','*.c', '*.cpp']
    match = lambda s: any(fnmatch(s, p) for p in patterns_to_ignore)

    is_ignorable = lambda s: any([ s.startswith('.'), match(s) ])

    p = c.currentPosition()

    if not RELATIVE_PATHS: directory = abspath(directory)
    if isroot:
        p.h = "@path %s" % normpath(directory)
    for name in listdir(directory):

        if is_ignorable(name):
            continue

        path = join(directory, name)

        if isfile(path) and not any(fnmatch(name, p) for p in patterns_to_import):
            continue

        if isfile(path):
            g.es('file:', path)
            headline = '@auto %s' % basename(path)
            if parent:
                node = parent
            else:
                node = p
            child = node.insertAsLastChild()
            child.initHeadString(headline)
        else:
            g.es('dir:', path)
            headline = basename(path)
            body = "@path %s" % normpath(path)
            if parent:
                node = parent
            else:
                node = p
            child = node.insertAsLastChild()
            child.initHeadString(headline)
            child.initBodyString(body)
            auto_walk(c,path, parent=child, isroot=False)

@g.command('project-wizard')
def project_wizard(event):
    """ Launch project wizard """
    import os
    c = event['c']
    table = [("All files","*"),
        ("Python files","*.py"),]

    fname = g.app.gui.runOpenFileDialog(c,
        title = "Open",filetypes = table,defaultextension = ".leo")

    pth = os.path.dirname(os.path.abspath(fname))

    g.es(pth)
    tgt = c.currentPosition().insertAsLastChild()
    c.selectPosition(tgt)
    auto_walk(c, pth, tgt)
    g.es('Import ok. Do read-at-auto-nodes to parse')
    c.redraw()


#project_wizard()
</t>
<t tx="vitalije.20170708161511.1">def handleInputShortcut(self, event, stroke):
    c, k, p, u = self.c, self, self.c.p, self.c.undoer
    k.clearState()
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body.wrapper
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        assert m  # edit-shortcut was invoked on a malformed body line
        sel = f"{m.group(0)} {stroke.s}"
        udata = u.beforeChangeNodeContents(p)
        pos = w.getYScrollPosition()
        i = len(before)
        j = max(i, len(before) + len(sel) - 1)
        w.setAllText(before + sel + after)
        w.setSelectionRange(i, j, insert=j)
        w.setYScrollPosition(pos)
        u.afterChangeNodeContents(p, 'change shortcut', udata)
        cmdname = m.group(0).rstrip('= ')
        k.editShortcut_do_bind_helper(stroke, cmdname)
        return
    if p.h.startswith(('@command', '@button')):
        udata = u.beforeChangeNodeContents(p)
        cmd = p.h.split('@key', 1)[0]
        p.h = f"{cmd} @key={stroke.s}"
        u.afterChangeNodeContents(p, 'change shortcut', udata)
        try:
            cmdname = cmd.split(' ', 1)[1].strip()
            k.editShortcut_do_bind_helper(stroke, cmdname)
        except IndexError:
            pass
        return
    # this should never happen
    g.error('not in settings node shortcut')
</t>
<t tx="vitalije.20170709151653.1">_cmd_handle_input_pattern = re.compile(r'[A-Za-z0-9_\-]+\s*=')

def isInShortcutBodyLine(self):
    k = self; c = k.c; p = c.p
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        return bool(m)
    return p.h.startswith(('@command', '@button'))
</t>
<t tx="vitalije.20170709151658.1">def isEditShortcutSensible(self):
    k = self; c = k.c; p = c.p
    return p.h.startswith(('@command', '@button')) or k.isInShortcutBodyLine()
</t>
<t tx="vitalije.20170709202924.1">def editShortcut_do_bind_helper(self, stroke, cmdname):
    k = self; c = k.c
    cmdfunc = c.commandsDict.get(cmdname)
    if cmdfunc:
        k.bindKey('all', stroke, cmdfunc, cmdname)
        g.es('bound', stroke, 'to command', cmdname)
</t>
<t tx="vitalije.20170716201700.16">def get(self, key, default=None):

    if not self.has_key(key):
        return default
    try:
        val = self[key]
        return val
    except Exception:  # #1444: Was KeyError.
        return default
</t>
<t tx="vitalije.20170811150914.1">def get_tagged_gnxes(self, tag):
    c = self.c
    tag = tag.replace('*', '.*')
    regex = re.compile(tag)
    for p in c.all_unique_positions():
        for t in self.get_tags(p):
            if regex.match(t):
                yield p.v.gnx
</t>
<t tx="vitalije.20200327163522.1">def apply_declutter_rules(cmds):
    """Applies all commands for the matched rule."""
    for cmd, arg in cmds:
        if not declutter_replace(arg, cmd):
            declutter_style(arg, cmd)
</t>
<t tx="vitalije.20200329153148.1">def icon_filenames_for_node(self, p, val):
    '''Prepares and returns a list of icon filenames
       related to this node.
    '''
    nicon = f'box{val:02d}.png'
    fnames = self.nodeIconsDict.get(p.gnx)
    if not fnames:
        icons = self.c.editCommands.getIconList(p)
        fnames = [x['file'] for x in icons if x['where'] == 'beforeIcon']
        fnames.append(nicon)
        fnames.extend(x['file'] for x in icons if x['where'] == 'beforeHeadline')
        self.nodeIconsDict[p.gnx] = fnames
    pat = re.compile(r'^box\d\d\.png$')
    loaded_images = self.loaded_images
    for i, f in enumerate(fnames):
        if pat.match(f):
            fnames[i] = nicon
            self.nodeIconsDict[p.gnx] = fnames
            f = nicon
        if f not in loaded_images:
            loaded_images[f] = g.app.gui.getImageImage(f)
    return fnames
</t>
<t tx="vitalije.20200329153154.1">def make_composite_icon(self, images):
    hsep = self.c.config.getInt('tree-icon-separation') or 0
    images = [x for x in images if x]
    height = max([i.height() for i in images])
    images = [i.scaledToHeight(height) for i in images]
    width = sum([i.width() for i in images]) + hsep * (len(images) - 1)
    pix = QtGui.QImage(width, height, QtGui.QImage.Format_ARGB32_Premultiplied)
    pix.fill(QtGui.QColor(0, 0, 0, 0).rgba())  # transparent fill, rgbA
    # .rgba() call required for Qt4.7, later versions work with straight color
    painter = QtGui.QPainter()
    if not painter.begin(pix):
        print("Failed to init. painter for icon")
        # don't return, the code still makes an icon for the cache
        # which stops this being called again and again
    x = 0
    for i in images:
        painter.drawPixmap(x, 0, i)
        x += i.width() + hsep
    painter.end()
    return QtGui.QIcon(QtGui.QPixmap.fromImage(pix))
</t>
<t tx="vitalije.20200329153544.1">def sorted_icons(p):
    '''
    Returns a list of icon filenames for this node.
    The list is sorted to owner the 'where' key of image dicts.
    '''
    icons = c.editCommands.getIconList(p)
    a = [x['file'] for x in icons if x['where'] == 'beforeIcon']
    a.append(iconName)
    a.extend(x['file'] for x in icons if x['where'] == 'beforeHeadline')
    return a
</t>
<t tx="vitalije.20200329162015.1">def preload_images():
    for f in new_icons:
        if f not in loaded_images:
            loaded_images[f] = g.app.gui.getImageImage(f)
</t>
</tnodes>
</leo_file>
