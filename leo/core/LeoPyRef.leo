<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20140902155015.18674"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20150425145248.1"><vh>@data history-list</vh></v>
<v t="ekr.20190406193429.1"><vh>@@enabled-plugins</vh></v>
<v t="ekr.20140920064112.17946"><vh>@int fts_max_hits = 100</vh></v>
<v t="ekr.20131111060930.18010"><vh>@shortcuts</vh></v>
<v t="ekr.20140916101314.19538"><vh>@string target_language = python</vh></v>
<v t="ekr.20160122104332.1"><vh>Buttons</vh>
<v t="ekr.20201013034659.1"><vh>Unused buttons</vh>
<v t="ekr.20180324065741.1"><vh>@@button copy-to-next</vh></v>
<v t="ekr.20150507170849.1"><vh>@@button create decorators</vh>
<v t="ekr.20150508063538.1"><vh>create_d</vh></v>
<v t="ekr.20150508071622.1"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150508063412.1"><vh>create_decorators</vh></v>
<v t="ekr.20150508074623.1"><vh>create_fixups</vh></v>
<v t="ekr.20150508063926.1"><vh>find_class</vh></v>
<v t="ekr.20150507174711.1"><vh>find_next_clone</vh></v>
<v t="ekr.20150507175246.1"><vh>munge_lines</vh></v>
<v t="ekr.20150508062944.1"><vh>run</vh></v>
</v>
<v t="ekr.20150509183433.1"><vh>@@button make-decorators2</vh>
<v t="ekr.20150509183433.2"><vh>create_d</vh></v>
<v t="ekr.20150509183433.3"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150509183433.4"><vh>create_decorators V2</vh></v>
<v t="ekr.20150509183433.8"><vh>munge_lines</vh></v>
<v t="ekr.20150509183433.9"><vh>run V2</vh></v>
</v>
<v t="ekr.20190406154306.1"><vh>@@button open-pyzo</vh></v>
<v t="ekr.20150703061709.1"><vh>@@button run-pylint</vh></v>
<v t="ekr.20180824065751.1"><vh>@@button show-gnx</vh></v>
<v t="ekr.20131121084830.16362"><vh>@@button toggle-debug</vh></v>
</v>
<v t="ekr.20201013034742.1"><vh>Unused buttons re plugins</vh>
<v t="ekr.20201013034742.2"><vh>@@button make-importer</vh>
<v t="ekr.20201013034742.3"><vh>&lt;&lt; define run &amp; helpers &gt;&gt;</vh>
<v t="ekr.20201013034742.4"><vh>copy_tree</vh></v>
<v t="ekr.20201013034742.5"><vh>make_substitutions</vh></v>
<v t="ekr.20201013034742.6"><vh>run</vh></v>
<v t="ekr.20201013034742.7"><vh>substitue</vh></v>
</v>
<v t="ekr.20201013034742.8"><vh>@@file importers/{{name}}.py</vh>
<v t="ekr.20201013034742.9"><vh>class {{cap_name}}_Importer</vh>
<v t="ekr.20201013034742.10"><vh>{{name}}.Overrides</vh>
<v t="ekr.20201013034742.11"><vh>{{name}}.clean_headline</vh></v>
<v t="ekr.20201013034742.12"><vh>{{name}}.clean_nodes</vh></v>
</v>
</v>
<v t="ekr.20201013034742.13"><vh>class {{cap_name}}_ScanState</vh>
<v t="ekr.20201013034742.14"><vh>{{name}}_state.level</vh></v>
<v t="ekr.20201013034742.15"><vh>{{name}}_state.update</vh></v>
</v>
</v>
</v>
<v t="ekr.20201013034742.16"><vh>@@button pep8 @key=Ctrl-5</vh>
<v t="ekr.20201013034742.17"><vh>class Pep8</vh>
<v t="ekr.20201013034742.18"><vh>change_all &amp; helpers</vh>
<v t="ekr.20201013034742.19"><vh>change_body</vh></v>
<v t="ekr.20201013034742.20"><vh>change_headline</vh></v>
</v>
<v t="ekr.20201013034742.21"><vh>get_name</vh></v>
<v t="ekr.20201013034742.22"><vh>run</vh></v>
<v t="ekr.20201013034742.23"><vh>to_pep8</vh></v>
</v>
<v t="ekr.20201013034742.24"><vh>clear</vh></v>
</v>
<v t="ekr.20201013034742.25"><vh>@@button test-jup-export</vh></v>
<v t="ekr.20201013034742.26"><vh>@@button test-jup-import</vh></v>
</v>
<v t="ekr.20150502050609.1"><vh>@button backup</vh></v>
<v t="ekr.20170811173924.1"><vh>@button backup-repo</vh></v>
<v t="ekr.20150413091056.1"><vh>@button check-clones</vh></v>
<v t="ekr.20201018062305.1"><vh>@button write-leoPyRef</vh>
<v t="ekr.20201018065757.1"><vh>check_file_names</vh></v>
<v t="ekr.20201018065921.1"><vh>check_nodes</vh></v>
<v t="ekr.20201018063747.1"><vh>get_content</vh></v>
<v t="ekr.20201018070822.1"><vh>main</vh></v>
<v t="ekr.20201018072911.1"><vh>oops</vh></v>
</v>
</v>
<v t="ekr.20200212095937.1"><vh>Beautify command settings</vh>
<v t="ekr.20200212095937.2"><vh>@bool beautify-allow-joined-strings = False</vh></v>
<v t="ekr.20200212095937.3"><vh>@bool beautify-keep-comment-indentation = True</vh></v>
<v t="ekr.20200212095937.5"><vh>@int beautify-max-join-line-length = 0</vh></v>
<v t="ekr.20200212095937.6"><vh>@int beautify-max-split-line-length = 90</vh></v>
</v>
</v>
<v t="ekr.20140103105930.16446"><vh>@views</vh>
<v t="ekr.20140102162014.16438"><vh>@view added strip_comments keyword arg to two config.getData methods</vh></v>
</v>
<v t="ekr.20140808103117.18035"><vh>@persistence</vh>
<v t="ekr.20140808103117.18038"><vh>@data:@auto ../plugins/qt_main.py</vh>
<v t="ekr.20160425070345.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18040"><vh>@data:@auto ../plugins/qt_main.ui</vh>
<v t="ekr.20160425070345.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18042"><vh>@data:@auto ../plugins/qt_quicksearch.py</vh>
<v t="ekr.20160420054135.4"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18044"><vh>@data:@auto ../plugins/qt_quicksearch.ui</vh>
<v t="ekr.20160420054135.5"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150604130353.1"><vh>@data:@auto test/unit_tests.py</vh>
<v t="ekr.20150604130353.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20201012111649.1"><vh>@data:@auto leo_cloud.py</vh>
<v t="ekr.20201221065401.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20201012111649.3"><vh>@data:@auto leo_cloud_server.py</vh>
<v t="ekr.20201012142922.2"><vh>@gnxs</vh></v>
</v>
</v>
<v t="ekr.20170427114412.1"><vh>scripts</vh>
<v t="ekr.20170427112302.1"><vh>check leoPy.leo</vh></v>
<v t="ekr.20170428084123.1"><vh>Recursive import script</vh></v>
<v t="ekr.20201222095250.1"><vh>script: check for duplicate settings in theme files</vh></v>
<v t="ekr.20200308193719.1"><vh>script: check gnx's</vh></v>
<v t="ekr.20180816105258.1"><vh>script: diff-branches/revs (one file)</vh></v>
<v t="ekr.20201208114843.1"><vh>script: diff-pr</vh></v>
<v t="ekr.20190402091335.1"><vh>script: diff-revs</vh></v>
<v t="ekr.20201015145257.1"><vh>script: import legacy file</vh></v>
<v t="ekr.20200222083959.1"><vh>script: start loggin</vh></v>
<v t="ekr.20181102040815.1"><vh>script: warn about long lines</vh></v>
<v t="ekr.20200222151754.1"><vh>script: yoton "other end"</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20191029023442.1"><vh> 4 kinds of documentation</vh></v>
<v t="ekr.20170302123956.1"><vh>@file ../doc/leoAttic.txt</vh></v>
<v t="ekr.20031218072017.329"><vh>@file ../doc/leoNotes.txt</vh></v>
<v t="ekr.20200522082827.1"><vh>From leoMenu.py</vh>
<v t="ekr.20051022044950"><vh>LeoMenu.computeOldStyleShortcutKey</vh></v>
<v t="ekr.20031218072017.4117"><vh>LeoMenu.defineMenuCallback</vh></v>
</v>
<v t="ekr.20100120072650.6089"><vh>@file ../doc/leoProjects.txt</vh></v>
<v t="ekr.20100119205347.6015"><vh>@file ../doc/leoToDo.txt</vh></v>
<v t="ekr.20190122185223.1"><vh>regex: find all kwargs</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20140902032918.18591"><vh> About this file</vh>
<v t="ekr.20140831085423.18639"><vh>About widgets and wrappers</vh></v>
<v t="ekr.20140831085423.18630"><vh>Terminology</vh></v>
<v t="ekr.20140831085423.18631"><vh>Official ivars</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20141012064706.18389"><vh>@file leoAst.py</vh></v>
<v t="ekr.20150323150718.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20161026193447.1"><vh>@file leoBackground.py</vh></v>
<v t="ekr.20150521115018.1"><vh>@file leoBeautify.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20140827092102.18574"><vh>@file leoColorizer.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20180212072657.2"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20130925160837.11429"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20130302121602.10208"><vh>@file leoDebugger.py</vh></v>
<v t="ekr.20160306114544.1"><vh>@file leoExternalFiles.py</vh></v>
<v t="ekr.20181202062518.1"><vh>@file leoFastRedraw.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d7100285806000000302e31362e3071017d71025808000000616e6e6f7461746571037d7104735806000000302e31372e3071057d71065808000000616e6e6f7461746571077d7108735806000000302e31392e3171097d710a5808000000616e6e6f74617465710b7d710c735806000000302e32302e31710d7d710e5808000000616e6e6f74617465710f7d711073752e"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20150514154159.1"><vh>@file leoHistory.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20120401063816.10072"><vh>@file leoIPython.py</vh></v>
<v t="ekr.20190515070742.1"><vh>@file leoMarkup.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
<v t="ekr.20140821055201.18331"><vh>@file leoPersistence.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20150419124739.1"><vh>@file leoPrinting.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20140810053602.18074"><vh>@file leoQt.py</vh></v>
<v t="ekr.20140526082700.18440"><vh>@file leoRope.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20120420054855.14241" descendentVnodeUnknownAttributes="7d7100285805000000302e332e3071017d71022858090000007374725f6374696d657103580c000000313331393439313330362e30710458090000007374725f6d74696d657105580d000000313331393439323330312e3532710658090000007374725f6174696d657107580d000000313331393534393339302e38397108755805000000302e332e3171097d710a2858090000007374725f6374696d65710b580c000000313331393436303438332e30710c58090000007374725f6d74696d65710d580d000000313331393436373033382e3235710e58090000007374725f6174696d65710f580c000000313332303432323637302e397110755805000000302e332e3271117d71122858090000007374725f6374696d657113580c000000313331393436303438332e30711458090000007374725f6d74696d657115580d000000313331393436373035302e3438711658090000007374725f6174696d657117580d000000313331393436373035302e34387118755805000000302e332e3371197d711a2858090000007374725f6374696d65711b580c000000313331393436303438332e30711c58090000007374725f6d74696d65711d580d000000313332303432323639302e3534711e58090000007374725f6174696d65711f580d000000313332303433343235372e33367120755805000000302e332e3471217d71222858090000007374725f6374696d657123580c000000313331393633383634382e30712458090000007374725f6d74696d657125580d000000313331393634313038352e3038712658090000007374725f6174696d657127580c000000313331393634353330362e327128755805000000302e332e3571297d712a2858090000007374725f6374696d65712b580c000000313331393633383634382e30712c58090000007374725f6d74696d65712d580c000000313331393634313131372e39712e58090000007374725f6174696d65712f580d000000313331393634313435352e3937713075752e"><vh>@file leoSessions.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@file leoTangle.py</vh></v>
<v t="ekr.20180121041003.1"><vh>@file leoTips.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
<v t="ekr.20131109170017.16504"><vh>@file leoVim.py</vh></v>
</v>
<v t="ekr.20150514035207.1"><vh>Command classes</vh>
<v t="ekr.20150514035236.1"><vh>@file ../commands/abbrevCommands.py</vh></v>
<v t="ekr.20150514035943.1"><vh>@file ../commands/baseCommands.py</vh></v>
<v t="ekr.20150514035559.1"><vh>@file ../commands/bufferCommands.py</vh></v>
<v t="ekr.20161021090740.1"><vh>@file ../commands/checkerCommands.py</vh></v>
<v t="ekr.20171123135539.1"><vh>@file ../commands/commanderEditCommands.py</vh></v>
<v t="ekr.20171123095353.1"><vh>@file ../commands/commanderFileCommands.py</vh></v>
<v t="ekr.20171124072110.1"><vh>@file ../commands/commanderFindCommands.py</vh></v>
<v t="ekr.20171124073126.1"><vh>@file ../commands/commanderHelpCommands.py</vh></v>
<v t="ekr.20171124080430.1"><vh>@file ../commands/commanderOutlineCommands.py</vh></v>
<v t="ekr.20150514040100.1"><vh>@file ../commands/controlCommands.py</vh></v>
<v t="ekr.20160316095222.1"><vh>@file ../commands/convertCommands.py</vh></v>
<v t="ekr.20150514040118.1"><vh>@file ../commands/debugCommands.py</vh></v>
<v t="ekr.20150514035813.1"><vh>@file ../commands/editCommands.py</vh></v>
<v t="ekr.20150514041209.1"><vh>@file ../commands/editFileCommands.py</vh></v>
<v t="ekr.20150624112334.1"><vh>@file ../commands/gotoCommands.py</vh></v>
<v t="ekr.20150514040138.1"><vh>@file ../commands/helpCommands.py</vh></v>
<v t="ekr.20150514040140.1"><vh>@file ../commands/keyCommands.py</vh></v>
<v t="ekr.20150514040142.1"><vh>@file ../commands/killBufferCommands.py</vh></v>
<v t="ekr.20150514040146.1"><vh>@file ../commands/rectangleCommands.py</vh></v>
<v t="ekr.20150514040236.1"><vh>@file ../commands/searchCommands.py</vh></v>
<v t="ekr.20150514040239.1"><vh>@file ../commands/spellCommands.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20201012111545.1"><vh>Plugins</vh>
<v t="ekr.20090430075506.3"><vh>@file ../plugins/leoPluginNotes.txt</vh></v>
<v t="EKR.20040517090508"><vh>  Enable plugins using @enabled-plugins nodes</vh></v>
<v t="ekr.20050303051035"><vh>  Templates</vh>
<v t="ekr.20041114102139"><vh>Notes for plugin writers</vh></v>
<v t="ekr.20050306071629"><vh>Template for plugins that override commander methods</vh>
<v t="ekr.20050306071629.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050306071629.3"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050306071629.4"><vh>init</vh></v>
<v t="ekr.20050306071540"><vh>onStart2</vh></v>
</v>
<v t="ekr.20050303051035.2"><vh>Template for plugins with per-commander controller class</vh>
<v t="ekr.20050303051035.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050303051101"><vh>init</vh></v>
<v t="ekr.20050303051150"><vh>onCreate</vh></v>
<v t="ekr.20050303051222"><vh>class pluginController</vh>
<v t="ekr.20050303051222.1"><vh>__init__</vh></v>
</v>
</v>
</v>
<v t="ekr.20100103093121.5365"><vh>Auto completion</vh>
<v t="ekr.20091118065749.5261"><vh>@file ../plugins/ctagscompleter.py</vh></v>
</v>
<v t="edream.110203113231.667"><vh>Commands &amp; directives</vh>
<v t="edream.110203113231.741"><vh>@file ../plugins/add_directives.py</vh></v>
<v t="ekr.20101110084839.5682"><vh>@file ../plugins/bzr_qcommands.py</vh></v>
<v t="EKR.20040517080049.1"><vh>@file ../plugins/empty_leo_file.py</vh></v>
<v t="edream.110203113231.669"><vh>@file ../plugins/import_cisco_config.py</vh></v>
<v t="ekr.20101110092851.5812"><vh>@file ../plugins/initinclass.py</vh></v>
<v t="ekr.20101110091234.5700"><vh>@file ../plugins/leo_interface.py</vh></v>
<v t="ekr.20040419105219"><vh>@file ../plugins/lineNumbers.py</vh></v>
<v t="ekr.20040916084945"><vh>@file ../plugins/macros.py</vh></v>
<v t="edream.110203113231.724"><vh>@file ../plugins/mod_autosave.py</vh></v>
<v t="ekr.20050301083306"><vh>@file ../plugins/mod_read_dir_outline.py</vh></v>
<v t="edream.110203113231.727"><vh>@file ../plugins/mod_timestamp.py</vh></v>
<v t="TL.20090225102340.32"><vh>@file ../plugins/nodeActions.py</vh></v>
<v t="edream.110203113231.720"><vh>@file ../plugins/outline_export.py</vh></v>
<v t="danr7.20060912105041.1"><vh>@file ../plugins/paste_as_headlines.py</vh></v>
<v t="tbrown.20070117104409"><vh>@file ../plugins/quickMove.py</vh></v>
<v t="ekr.20081214160729.1"><vh>@file ../plugins/setHomeDirectory.py</vh></v>
<v t="danr7.20061010105952.1"><vh>@file ../plugins/word_count.py</vh></v>
</v>
<v t="edream.110203113231.729"><vh>Debugging</vh>
<v t="ekr.20101110091234.5689"><vh>@file ../plugins/debugger_pudb.py</vh></v>
<v t="edream.110203113231.730"><vh>@file ../plugins/dump_globals.py</vh></v>
<v t="edream.110203113231.732"><vh>@file ../plugins/enable_gc.py</vh></v>
<v t="edream.110203113231.734"><vh>@file ../plugins/quit_leo.py</vh></v>
<v t="edream.110203113231.735"><vh>@file ../plugins/trace_gc_plugin.py</vh></v>
<v t="edream.110203113231.736"><vh>@file ../plugins/trace_keys.py</vh></v>
<v t="edream.110203113231.738"><vh>@file ../plugins/trace_tags.py</vh></v>
</v>
<v t="ekr.20041030092101"><vh>Dyna plugins by e</vh></v>
<v t="ekr.20040722141148"><vh>Examples</vh>
<v t="ekr.20040828105233"><vh>@file ../plugins/examples/chinese_menu.py</vh></v>
<v t="EKR.20040517080202.3"><vh>@file ../plugins/examples/french_fm.py</vh></v>
<v t="edream.110203113231.916"><vh>@file ../plugins/examples/override_classes.py</vh></v>
<v t="edream.110203113231.919"><vh>@file ../plugins/examples/override_commands.py</vh></v>
<v t="ekr.20060621123339"><vh>@file ../plugins/examples/print_cp.py</vh></v>
<v t="edream.110203113231.921"><vh>@file ../plugins/examples/redefine_put.py</vh></v>
<v t="ekr.20180119164431.1"><vh>@file ../plugins/patch_python_colorizer.py</vh></v>
</v>
<v t="ekr.20101110150056.9457"><vh>Experimental</vh>
<v t="ekr.20090704103932.5160"><vh>@file ../plugins/leo_pdf.py</vh></v>
<v t="danr7.20060902083957"><vh>@file ../plugins/leo_to_rtf.py</vh></v>
<v t="ekr.20040205071616"><vh>@file ../plugins/mnplugins.py</vh></v>
<v t="ekr.20101110094759.5843"><vh>@file ../plugins/mod_speedups.py</vh></v>
<v t="ekr.20040910070811.1"><vh>@file ../plugins/run_nodes.py</vh></v>
<v t="ekr.20170313020320.1"><vh>@file ../plugins/settings_finder.py</vh></v>
<v t="ekr.20100103093121.5339"><vh>@file ../plugins/stickynotes_plus.py</vh></v>
<v t="ekr.20140225222704.16748"><vh>@file ../plugins/viewrendered2.py</vh></v>
<v t="ekr.20040331071919"><vh>Leo to AsciiDoc</vh>
<v t="ekr.20101110093449.5822"><vh>@file ../plugins/mod_leo2ascd.py</vh></v>
<v t="ekr.20101110150056.9445"><vh>@file ../plugins/mod_leo2ascd.txt</vh></v>
</v>
</v>
<v t="EKR.20040517075715"><vh>External programs</vh>
<v t="ekr.20110125103904.12504"><vh>@file ../plugins/gitarchive.py</vh></v>
<v t="EKR.20040517080049.4"><vh>@file ../plugins/open_shell.py</vh></v>
<v t="ville.20090503124249.1"><vh>@file ../plugins/tomboy_import.py</vh></v>
<v t="EKR.20040517075715.10"><vh>@file ../plugins/vim.py</vh></v>
<v t="EKR.20040517075715.12"><vh>@file ../plugins/xemacs.py</vh></v>
<v t="EKR.20040517075715.13"><vh>Word export</vh>
<v t="EKR.20040517075715.14"><vh>@file ../plugins/word_export.py</vh></v>
<v t="EKR.20040517075715.20"><vh>@file-nosent ../plugins/word_export.ini</vh></v>
</v>
</v>
<v t="edream.110203113231.872"><vh>Files and nodes</vh>
<v t="tbrown.20080613095157.2"><vh>@file ../plugins/active_path.py</vh></v>
<v t="edream.110203113231.873"><vh>@file ../plugins/at_folder.py</vh></v>
<v t="ekr.20040915085351"><vh>@file ../plugins/at_produce.py</vh></v>
<v t="ktenney.20041211072654.1"><vh>@file ../plugins/at_view.py</vh></v>
<v t="ekr.20170619151859.2"><vh>@file ../plugins/auto_colorize2_0.py</vh></v>
<v t="tbrown.20081223111325.3"><vh>@file ../plugins/backlink.py</vh></v>
<v t="tbrown.20070322113635"><vh>@file ../plugins/bookmarks.py</vh></v>
<v t="ekr.20060807103814.1"><vh>@file ../plugins/datenodes.py</vh></v>
<v t="ajones.20070122153625"><vh>@file ../plugins/expfolder.py</vh></v>
<v t="ekr.20040915105758.13"><vh>@file ../plugins/FileActions.py</vh></v>
<v t="ekr.20110110105526.5463"><vh>@file ../plugins/ftp.py</vh></v>
<v t="tbrown.20091214233510.5347"><vh>@file ../plugins/geotag.py</vh></v>
<v t="tbrown.20100228141752.5691"><vh>@file ../plugins/leocursor.py</vh></v>
<v t="ville.20120503224623.3574"><vh>@file ../plugins/leomylyn.py</vh></v>
<v t="ekr.20101110092851.5742"><vh>@file ../plugins/leoOPML.py</vh></v>
<v t="dan.20090217132953.1"><vh>@file ../plugins/mime.py</vh></v>
<v t="mork.20041018204908.1"><vh>@file ../plugins/multifile.py</vh></v>
<v t="ekr.20040331151007"><vh>@file ../plugins/niceNosent.py</vh></v>
<v t="edream.110203113231.876"><vh>@file ../plugins/read_only_nodes.py</vh></v>
<v t="ekr.20040828103325"><vh>@file ../plugins/startfile.py</vh></v>
<v t="ekr.20130808211520.15893"><vh>@file ../plugins/timestamp.py</vh></v>
<v t="tbrown.20110428144124.29061"><vh>@file ../plugins/xml_edit.py</vh></v>
<v t="mork.20041010095009"><vh>@file ../plugins/xsltWithNodes.py</vh></v>
</v>
<v t="ekr.20181030041436.1"><vh>Gui</vh>
<v t="ekr.20150107090324.1"><vh>@file ../plugins/cursesGui.py</vh></v>
<v t="ekr.20170419092835.1"><vh>@file ../plugins/cursesGui2.py</vh></v>
<v t="ekr.20181103094900.1"><vh>@file ../plugins/leoflexx.py</vh></v>
<v t="ekr.201811100000000.1"><vh>@file ../plugins/leoflexx_js.py</vh></v>
<v t="peckj.20150428142633.1"><vh>@file ../plugins/python_terminal.py</vh></v>
</v>
<v t="ekr.20140723122936.17925"><vh>Importer plugins</vh>
<v t="ekr.20140723122936.18139"><vh>@file ../plugins/importers/__init__.py</vh></v>
<v t="ekr.20140723122936.17926"><vh>@file ../plugins/importers/c.py</vh></v>
<v t="ekr.20160505094722.1"><vh>@file ../plugins/importers/coffeescript.py</vh></v>
<v t="ekr.20140723122936.18140"><vh>@file ../plugins/importers/csharp.py</vh></v>
<v t="tbrown.20140801105909.47549"><vh>@file ../plugins/importers/ctext.py</vh></v>
<v t="ekr.20200619141135.1"><vh>@file ../plugins/importers/cython.py</vh></v>
<v t="ekr.20141116100154.1"><vh>@file ../plugins/importers/dart.py</vh></v>
<v t="ekr.20140723122936.18141"><vh>@file ../plugins/importers/elisp.py</vh></v>
<v t="ekr.20140723122936.18138"><vh>@file ../plugins/importers/html.py</vh></v>
<v t="ekr.20140723122936.18142"><vh>@file ../plugins/importers/ini.py</vh></v>
<v t="ekr.20160412101008.1"><vh>@file ../plugins/importers/ipynb.py</vh></v>
<v t="ekr.20140723122936.18143"><vh>@file ../plugins/importers/java.py</vh></v>
<v t="ekr.20140723122936.18144"><vh>@file ../plugins/importers/javascript.py</vh></v>
<v t="ekr.20160504080826.1"><vh>@file ../plugins/importers/leo_json.py</vh></v>
<v t="ekr.20140723122936.18151"><vh>@file ../plugins/importers/leo_rst.py</vh></v>
<v t="ekr.20161108125620.1"><vh>@file ../plugins/importers/linescanner.py</vh></v>
<v t="ekr.20170530024520.2"><vh>@file ../plugins/importers/lua.py</vh></v>
<v t="ekr.20140725190808.18066"><vh>@file ../plugins/importers/markdown.py</vh></v>
<v t="ekr.20140723122936.18146"><vh>@file ../plugins/importers/org.py</vh></v>
<v t="ekr.20140723122936.18150"><vh>@file ../plugins/importers/otl.py</vh></v>
<v t="ekr.20140723122936.18147"><vh>@file ../plugins/importers/pascal.py</vh></v>
<v t="ekr.20161027100313.1"><vh>@file ../plugins/importers/perl.py</vh></v>
<v t="ekr.20140723122936.18148"><vh>@file ../plugins/importers/php.py</vh></v>
<v t="ekr.20140723122936.18149"><vh>@file ../plugins/importers/python.py</vh></v>
<v t="ekr.20200316100818.1"><vh>@file ../plugins/importers/rust.py</vh></v>
<v t="ekr.20170615153639.2"><vh>@file ../plugins/importers/tcl.py</vh></v>
<v t="ekr.20180201203240.2"><vh>@file ../plugins/importers/treepad.py</vh></v>
<v t="ekr.20140723122936.18152"><vh>@file ../plugins/importers/typescript.py</vh></v>
<v t="ekr.20140723122936.18137"><vh>@file ../plugins/importers/xml.py</vh></v>
</v>
<v t="ekr.20180504192522.1"><vh>leo_babel</vh>
<v t="ekr.20180504191650.34"><vh>@clean ../plugins/leo_babel/__init__.py</vh></v>
<v t="ekr.20180504191650.36"><vh>examples</vh>
<v t="bob.20170716135108.2"><vh>@file ../plugins/leo_babel/examples/slowOut.py</vh></v>
<v t="bob.20170716135108.3"><vh>@file ../plugins/leo_babel/examples/slowOutNoFlush.py</vh></v>
</v>
<v t="ekr.20180504191650.42"><vh>tests</vh>
<v t="ekr.20180504191650.68"><vh>@clean ../plugins/leo_babel/tests/__init__.py</vh></v>
<v t="bob.20180206123613.1"><vh>@file ../plugins/leo_babel/tests/idle_time.py</vh></v>
<v t="bob.20180205135005.1"><vh>@file ../plugins/leo_babel/tests/lib_test.py</vh></v>
<v t="bob.20180125160225.1"><vh>@file ../plugins/leo_babel/tests/tests.py</vh></v>
</v>
</v>
<v t="ekr.20130927050813.13031"><vh>Obsolete</vh>
<v t="ajones.20070122160142"><vh>@file ../plugins/textnode.py</vh></v>
<v t="ekr.20050817132814"><vh>rst3</vh>
<v t="ekr.20050805162550"><vh>@@file ../plugins/rst3.py</vh>
<v t="ekr.20050805162550.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050805162550.2"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050806162146"><vh>&lt;&lt; to do &gt;&gt;</vh>
<v t="ekr.20050804081215"><vh>More options</vh></v>
</v>
<v t="ekr.20050805162550.4"><vh>Module level</vh>
<v t="ekr.20050805162550.5"><vh> init</vh></v>
<v t="ekr.20050805162550.6"><vh>onCreate</vh></v>
<v t="ekr.20050806101253"><vh>code_block</vh></v>
<v t="ekr.20090429055156.63"><vh>runUnitTests</vh></v>
</v>
<v t="ekr.20050805162550.39"><vh>html parser classes</vh>
<v t="ekr.20050805162550.40"><vh> &lt;&lt; class linkAnchorParserClass &gt;&gt; (subclass of HTMLParser.HTMLParser)</vh>
<v t="ekr.20050805162550.41"><vh>__init__</vh></v>
<v t="ekr.20050805162550.42"><vh>is_anchor</vh></v>
<v t="ekr.20050805162550.43"><vh>is_link</vh></v>
<v t="ekr.20050815164715"><vh>is_node_marker</vh></v>
</v>
<v t="ekr.20050805162550.44"><vh>class htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.45"><vh>__init__</vh></v>
<v t="ekr.20050805162550.46"><vh>handle_starttag</vh>
<v t="ekr.20050815164715.1"><vh>&lt;&lt; trace the unknownAttribute &gt;&gt;</vh></v>
</v>
<v t="ekr.20050805162550.47"><vh>handle_endtag</vh></v>
<v t="ekr.20050805162550.49"><vh>feed</vh></v>
</v>
<v t="ekr.20050805162550.50"><vh>class anchor_htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.51"><vh> __init__</vh></v>
<v t="ekr.20050805162550.52"><vh>handle_starttag</vh></v>
</v>
<v t="ekr.20050805162550.53"><vh>class link_htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.54"><vh>__init__</vh></v>
<v t="ekr.20050805162550.55"><vh>handle_starttag</vh></v>
<v t="ekr.20050805162550.56"><vh>get_replacements</vh></v>
</v>
</v>
<v t="ekr.20050805162550.8"><vh>class rstClass</vh>
<v t="ekr.20050805162550.9"><vh> Birth &amp; init</vh>
<v t="ekr.20050805162550.10"><vh> ctor (rstClass)</vh>
<v t="ekr.20050805162550.11"><vh>&lt;&lt; init ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050805162550.12"><vh>addMenu (rstClass, rst3.py) (obsolete)</vh></v>
<v t="ekr.20050813083007"><vh>initHeadlineCommands</vh></v>
<v t="ekr.20050813085236"><vh>initSingleNodeOptions</vh></v>
<v t="ekr.20050808072943"><vh>munge</vh></v>
</v>
<v t="ekr.20050812122236"><vh>options...</vh>
<v t="ekr.20050808064245"><vh>createDefaultOptionsDict</vh></v>
<v t="ekr.20050812120933"><vh>dumpSettings (debugging)</vh></v>
<v t="ekr.20050814134351"><vh>getOption</vh></v>
<v t="ekr.20071015110830"><vh>initCodeBlockString</vh></v>
<v t="ekr.20050807120331.1"><vh>preprocessTree &amp; helpers</vh>
<v t="ekr.20051204070141"><vh>preprocessNode</vh></v>
<v t="ekr.20050808072943.1"><vh>parseOptionLine</vh></v>
<v t="ekr.20050808070018.2"><vh>scanForOptionDocParts</vh></v>
<v t="ekr.20050811173750"><vh>scanHeadlineForOptions</vh></v>
<v t="ekr.20050807120331.2"><vh>scanNodeForOptions</vh></v>
<v t="ekr.20050808070018"><vh>scanOption</vh></v>
<v t="ekr.20050808070018.1"><vh>scanOptions</vh></v>
</v>
<v t="ekr.20050808142313.28"><vh>scanAllOptions &amp; helpers</vh>
<v t="ekr.20050805162550.13"><vh>initOptionsFromSettings</vh></v>
<v t="ekr.20050810103731"><vh>handleSingleNodeOptions</vh></v>
</v>
<v t="ekr.20050811135526"><vh>setOption</vh></v>
</v>
<v t="ekr.20050809074827"><vh>write methods</vh>
<v t="ekr.20050809082854"><vh> Top-level write code</vh>
<v t="ekr.20050809075309"><vh>initWrite</vh></v>
<v t="ekr.20050809080925"><vh>writeNormalTree</vh></v>
<v t="ekr.20051121102358"><vh>processTopTree</vh></v>
<v t="ekr.20050805162550.17"><vh>processTree</vh></v>
<v t="ekr.20050805162550.21"><vh>writeSpecialTree</vh></v>
<v t="ekr.20050809082854.1"><vh>writeToDocutils (sets argv) &amp; helper</vh>
<v t="ekr.20090428082801.64"><vh>handleMissingStyleSheetArgs</vh></v>
</v>
<v t="ekr.20060525102337"><vh>writeNodeToString (New in 4.4.1)</vh></v>
</v>
<v t="ekr.20050811154552"><vh>getDocPart</vh>
<v t="ekr.20060610104435"><vh>&lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;</vh></v>
</v>
<v t="ekr.20050811102607"><vh>skip_literal_block</vh></v>
<v t="ekr.20050811101550.1"><vh>writeBody &amp; helpers</vh>
<v t="ekr.20050811150541"><vh>handleCodeMode &amp; helper</vh>
<v t="ekr.20050811152104"><vh>formatCodeModeLine</vh></v>
<v t="ekr.20050813155021"><vh>rstripList</vh></v>
<v t="ekr.20050813160208"><vh>finishCodePart</vh></v>
</v>
<v t="ekr.20060608094815"><vh>handleDocOnlyMode</vh></v>
<v t="ekr.20060608094815.1"><vh>isAnyDocPart</vh></v>
<v t="ekr.20050811153208"><vh>isSpecialDocPart</vh></v>
<v t="ekr.20050811163802"><vh>isAnySpecialDocPart</vh></v>
<v t="ekr.20050811105438"><vh>removeLeoDirectives</vh></v>
<v t="ekr.20050811105438.1"><vh>handleSpecialDocParts</vh></v>
<v t="ekr.20050805162550.30"><vh>replaceCodeBlockDirectives</vh></v>
</v>
<v t="ekr.20050805162550.26"><vh>writeHeadline &amp; helper</vh>
<v t="ekr.20060608102001"><vh>writeHeadlineHelper</vh></v>
</v>
<v t="ekr.20050810083057"><vh>writeNode</vh></v>
<v t="ekr.20071115061253"><vh>writePreformat</vh></v>
<v t="ekr.20050805162550.23"><vh>writeTree</vh></v>
</v>
<v t="ekr.20050810083314"><vh>Utils</vh>
<v t="ekr.20051202070028"><vh>computeOutputFileName</vh></v>
<v t="ekr.20050805162550.16"><vh>encode</vh></v>
<v t="ekr.20050805162550.20"><vh>report</vh></v>
<v t="ekr.20050810083856"><vh>rstComment</vh></v>
<v t="ekr.20050805162550.19"><vh>underline</vh></v>
<v t="ekr.20050809080031"><vh>write</vh></v>
</v>
<v t="ekr.20050805162550.33"><vh>Support for http plugin</vh>
<v t="ekr.20050815091008.1"><vh>http_addNodeMarker</vh></v>
<v t="ekr.20050805162550.34"><vh>http_endTree &amp; helpers</vh>
<v t="ekr.20050805162550.36"><vh>set_initial_http_attributes</vh></v>
<v t="ekr.20050805162550.38"><vh>find_anchors</vh></v>
<v t="ekr.20050805162550.37"><vh>relocate_references</vh></v>
<v t="ekr.20050805162550.35"><vh>http_attribute_iter</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20181028052650.1"><vh>@file ../plugins/leowapp.py</vh></v>
<v t="ekr.20190410171646.1"><vh>Unused: pyzo_support.py</vh>
<v t="ekr.20190412042616.1"><vh>&lt;&lt; copyright &gt;&gt;</vh></v>
<v t="ekr.20190410171905.1"><vh>init (pyzo_support.py)</vh></v>
<v t="ekr.20190418161712.1"><vh>class PyzoInterface</vh>
<v t="ekr.20190803175344.1"><vh>pyzo_x.patch_pyzo</vh></v>
</v>
</v>
<v t="ekr.20190805022257.1"><vh>Unused: @file ../plugins/file pyzo_file_browser.py</vh>
<v t="ekr.20190809093446.1"><vh> &lt;&lt; pyzo_file_browser imports &gt;&gt;</vh></v>
<v t="ekr.20190809093459.1"><vh> top-level Leo functions</vh>
<v t="ekr.20190809093459.3"><vh>init (pyzo_file_browser)</vh></v>
<v t="ekr.20190809093459.4"><vh>onCreate</vh></v>
<v t="ekr.20190814050007.1"><vh>make_dock</vh></v>
</v>
</v>
</v>
<v t="ekr.20041001210557"><vh>Scripting</vh>
<v t="tbrown.20100226095909.12777"><vh>@file ../plugins/leoscreen.py</vh></v>
<v t="tbrown.20140806084727.30174"><vh>@file ../plugins/livecode.py</vh></v>
<v t="ekr.20060328125248"><vh>@file ../plugins/mod_scripting.py</vh></v>
<v t="edream.110203113231.925"><vh>@file ../plugins/script_io_to_body.py</vh></v>
</v>
<v t="ekr.20120309073937.9878"><vh>Searching</vh>
<v t="ekr.20120309073748.9872"><vh>@file ../plugins/bigdash.py</vh></v>
<v t="peckj.20140804114520.9427"><vh>@file ../plugins/nodetags.py</vh></v>
<v t="peckj.20131130132659.5964"><vh>@file ../plugins/nodewatch.py</vh></v>
</v>
<v t="ekr.20050111122605"><vh>Servers &amp; web stuff</vh>
<v t="ekr.20170925083314.1"><vh>@auto ../plugins/leo_cloud.py</vh></v>
<v t="ekr.20170925083853.1"><vh>@auto ../plugins/leo_cloud_server.py</vh></v>
<v t="ville.20110206142055.10640"><vh>@file ../plugins/leofeeds.py</vh></v>
<v t="ville.20110125222411.10536"><vh>@file ../plugins/leomail.py</vh></v>
<v t="ville.20091009202416.10040"><vh>@file ../plugins/leoremote.py</vh></v>
<v t="EKR.20040517080250.1"><vh>@file ../plugins/mod_http.py</vh></v>
<v t="ekr.20131004162848.11444"><vh>@file ../plugins/rss.py</vh></v>
<v t="peckj.20140811080604.9496"><vh>@file ../plugins/sftp.py</vh></v>
</v>
<v t="ekr.20101004082701.5674"><vh>Slideshows, screencasts &amp; screenshots</vh>
<v t="ekr.20170128213103.1"><vh>@file ../plugins/demo.py</vh></v>
<v t="ekr.20120913110135.10579"><vh>@file ../plugins/screencast.py</vh></v>
<v t="ekr.20101121031443.5330"><vh>@file ../plugins/screenshots.py</vh></v>
<v t="ekr.20060831165821"><vh>@file ../plugins/slideshow.py</vh></v>
</v>
<v t="ekr.20071113084440"><vh>Testing</vh>
<v t="ekr.20080214092357"><vh>@file ../plugins/test/ekr_test.py</vh></v>
<v t="ekr.20050130120433"><vh>@@file ../plugins/test/failed_import.py</vh></v>
<v t="ekr.20071113085315"><vh>@file ../plugins/test/failed_to_load_plugin.py</vh></v>
<v t="ekr.20051016160700"><vh>@file ../plugins/testRegisterCommand.py</vh></v>
</v>
<v t="ekr.20050306081349"><vh>Text formatting</vh>
<v t="timo.20050213160555"><vh>@file ../plugins/bibtex.py</vh></v>
<v t="ekr.20070119094733.1"><vh>@file ../plugins/dtest.py</vh></v>
<v t="ville.20110409151021.5699"><vh>@file ../plugins/jinjarender.py</vh></v>
<v t="danr7.20060902215215.1"><vh>@file ../plugins/leo_to_html.py</vh></v>
<v t="tbrown.20130930160706.23451"><vh>@file ../plugins/markup_inline.py</vh></v>
<v t="vitalije.20180804172140.1"><vh>@file ../plugins/md_docer.py</vh></v>
<v t="peckj.20140113150237.7083"><vh>@file ../plugins/nodediff.py</vh></v>
<v t="tbrown.20130813134319.11942"><vh>@file ../plugins/richtext.py</vh></v>
<v t="ekr.20170217164004.1"><vh>@file ../plugins/tables.py</vh></v>
</v>
<v t="ekr.20121126102050.10134"><vh>Threading</vh>
<v t="ekr.20121126095734.12418"><vh>@file ../plugins/threadutil.py</vh></v>
</v>
<v t="ekr.20040915073259"><vh>User interface</vh>
<v t="ekr.20101110150056.9453"><vh> Qt only plugins</vh>
<v t="tbrown.20091029123555.5319"><vh>@file ../plugins/attrib_edit.py</vh></v>
<v t="ville.20090310191936.10"><vh>@file ../plugins/colorize_headlines.py</vh></v>
<v t="ekr.20090701111504.5294"><vh>@file ../plugins/contextmenu.py</vh></v>
<v t="tbrown.20090206153748.1"><vh>@file ../plugins/graphcanvas.py</vh></v>
<v t="ville.20090518182905.5419"><vh>@file ../plugins/nav_qt.py</vh></v>
<v t="ville.20120604212857.4215"><vh>@file ../plugins/notebook.py</vh></v>
<v t="ekr.20090622063842.5264"><vh>@file ../plugins/projectwizard.py</vh></v>
<v t="ekr.20160928073518.1"><vh>@file ../plugins/pyplot_backend.py</vh></v>
<v t="ville.20090314215508.4"><vh>@file ../plugins/quicksearch.py</vh></v>
<v t="tbrown.20130420091241.44181"><vh>@file ../plugins/screen_capture.py</vh></v>
<v t="ville.20090815203828.5235"><vh>@file ../plugins/spydershell.py</vh></v>
<v t="ekr.20100103093121.5329"><vh>@file ../plugins/stickynotes.py</vh></v>
<v t="tbrown.20090119215428.2" descendentVnodeUnknownAttributes="7d71005808000000302e362e31332e3071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323031382d30382d313871077573732e"><vh>@file ../plugins/todo.py</vh></v>
<v t="ville.20110403115003.10348"><vh>@file ../plugins/valuespace.py</vh></v>
<v t="tbrown.20100318101414.5990"><vh>@file ../plugins/viewrendered.py</vh></v>
<v t="TomP.20191215195433.1"><vh>@file ../plugins/viewrendered3.py</vh></v>
</v>
<v t="ekr.20160519123329.1"><vh>@edit ../plugins/QNCalendarWidget.py</vh></v>
<v t="ekr.20060328125925"><vh>@file ../plugins/chapter_hoist.py</vh></v>
<v t="ville.20110115234843.8742"><vh>@file ../plugins/dragdropgoodies.py</vh></v>
<v t="vitalije.20190928154420.1"><vh>@file ../plugins/history_tracer.py</vh></v>
<v t="tbrown.20090513125417.5244"><vh>@file ../plugins/interact.py</vh></v>
<v t="vitalije.20170727201534.1"><vh>@file ../plugins/line_numbering.py</vh></v>
<v t="ekr.20040915073259.1"><vh>@file ../plugins/maximizeNewWindows.py</vh></v>
<v t="ekr.20101110093301.5818"><vh>@file ../plugins/mod_framesize.py</vh></v>
<v t="EKR.20040517080555.2"><vh>@file ../plugins/plugins_menu.py</vh></v>
<v t="edream.110203113231.924"><vh>@file ../plugins/redirect_to_log.py</vh></v>
<v t="ville.20110304230157.6513"><vh>@file ../plugins/systray.py</vh></v>
<v t="tbrown.20141101114322.1"><vh>@file ../plugins/wikiview.py</vh></v>
<v t="ekr.20181004143535.1"><vh>@file ../plugins/xdb_pane.py</vh></v>
<v t="ekr.20101110095202.5882"><vh>@file ../plugins/zenity_file_dialogs.py</vh></v>
</v>
<v t="ekr.20140726091031.18071"><vh>Writer plugins</vh>
<v t="ekr.20140726091031.18152"><vh>@file ../plugins/writers/__init__.py</vh></v>
<v t="ekr.20140726091031.18143"><vh>@file ../plugins/writers/basewriter.py</vh></v>
<v t="tbrown.20140804103545.29975"><vh>@file ../plugins/writers/ctext.py</vh></v>
<v t="ekr.20141116100154.2"><vh>@file ../plugins/writers/dart.py</vh></v>
<v t="ekr.20160412101901.1"><vh>@file ../plugins/writers/ipynb.py</vh></v>
<v t="ekr.20160504083330.1"><vh>@file ../plugins/writers/leo_json.py</vh></v>
<v t="ekr.20180202053206.1"><vh>@file ../plugins/writers/treepad.py</vh></v>
<v t="ekr.20140726091031.18080"><vh>@file ../plugins/writers/leo_rst.py</vh></v>
<v t="ekr.20140726091031.18073"><vh>@file ../plugins/writers/markdown.py</vh></v>
<v t="ekr.20140726091031.18079"><vh>@file ../plugins/writers/org.py</vh></v>
<v t="ekr.20140726091031.18078"><vh>@file ../plugins/writers/otl.py</vh></v>
</v>
</v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20171031111403.1"><vh>Leo Edit Pane</vh>
<v t="tbrown.20171029210211.1"><vh>@file ../plugins/editpane/clicky_splitter.py</vh></v>
<v t="tbrown.20171028115144.6"><vh>@file ../plugins/editpane/editpane.py</vh></v>
<v t="tbrown.20171028115144.5"><vh>@file ../plugins/editpane/leotextedit.py</vh></v>
<v t="tbrown.20171028115144.4"><vh>@file ../plugins/editpane/markdownview.py</vh></v>
<v t="tbrown.20171028115144.3"><vh>@file ../plugins/editpane/pandownview.py</vh></v>
<v t="tbrown.20171028115144.2"><vh>@file ../plugins/editpane/plaintextedit.py</vh></v>
<v t="tbrown.20171028115144.1"><vh>@file ../plugins/editpane/plaintextview.py</vh></v>
<v t="tbrown.20171028115143.3"><vh>@file ../plugins/editpane/vanillascintilla.py</vh></v>
<v t="tbrown.20171028115143.2"><vh>@file ../plugins/editpane/webengineview.py</vh></v>
<v t="tbrown.20171028115143.1"><vh>@file ../plugins/editpane/webkitview.py</vh></v>
<v t="tbrown.20171028115144.8"><vh>@file ../plugins/editpane/__init__.py</vh></v>
<v t="tbrown.20171028115541.1"><vh>@file signal_manager.py</vh></v>
</v>
<v t="ekr.20120419093256.10048"><vh>@file ../plugins/free_layout.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qt_commands.py</vh></v>
<v t="ekr.20140907103315.18766"><vh>@file ../plugins/qt_events.py</vh></v>
<v t="ekr.20140907123524.18774"><vh>@file ../plugins/qt_frame.py</vh></v>
<v t="ekr.20140907085654.18699"><vh>@file ../plugins/qt_gui.py</vh></v>
<v t="ekr.20140907103315.18777"><vh>@file ../plugins/qt_idle_time.py</vh></v>
<v t="ekr.20140907123524.18777"><vh>@file ../plugins/qt_quickheadlines.py</vh></v>
<v t="ekr.20140831085423.18598"><vh>@file ../plugins/qt_text.py</vh></v>
<v t="ekr.20140907131341.18707"><vh>@file ../plugins/qt_tree.py</vh></v>
<v t="ekr.20110605121601.18002"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20161223152017.1"><vh>@edit ../plugins/qt_quicksearch.py</vh></v>
<v t="ekr.20161223152353.1"><vh>@edit ../plugins/qt_quicksearch_sub.py</vh></v>
</v>
<v t="ekr.20180225010644.1"><vh>Other files</vh>
<v t="ekr.20180225010707.1"><vh>In leo-editor directory</vh>
<v t="maphew.20180224170853.1"><vh>@file ../../setup.py</vh></v>
<v t="ekr.20150304125314.4"><vh>@clean ../../leo_to_html.xsl</vh>
<v t="ekr.20150304130753.5"><vh>&lt;&lt;style&gt;&gt;</vh></v>
<v t="ekr.20150304130753.6"><vh>&lt;&lt;scripts&gt;&gt;</vh></v>
</v>
<v t="ekr.20181009072707.1"><vh>@clean ../../run_travis_unit_tests.py</vh></v>
<v t="ekr.20181014073705.1"><vh>@file ../../run_pytest_tests.py</vh></v>
<v t="ekr.20150304130753.4"><vh>leo-viewer/leo_to_html.xsl</vh></v>
</v>
<v t="ekr.20180225010913.1"><vh>In leo/core</vh>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py</vh></v>
</v>
<v t="ekr.20180225010743.1"><vh>In leo/external</vh>
<v t="ekr.20190607124533.1"><vh>@nopylint</vh>
<v t="ekr.20160123142722.1"><vh>@clean ../external/make_stub_files.cfg</vh></v>
<v t="ekr.20180708145905.1"><vh>@clean ../external/py2cs_theory.md</vh>
<v t="ekr.20180708152000.1"><vh>The problem</vh></v>
<v t="ekr.20180708152018.1"><vh>Design</vh></v>
<v t="ekr.20180708145905.6"><vh>Using TokenSync class</vh></v>
<v t="ekr.20180708145905.7"><vh>Summary</vh></v>
</v>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ekr.20130805134749.12436"><vh>@file ../external/edb.py</vh></v>
<v t="ekr.20120519121124.9919"><vh>@file ../external/leosax.py</vh></v>
<v t="ekr.20170429161422.1"><vh>@file ../external/log_broadcast.py</vh></v>
<v t="ekr.20170429153135.1"><vh>@file ../external/log_listener.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20160317054700.1"><vh>@file ../external/make_stub_files.py</vh></v>
<v t="ekr.20160316091132.1"><vh>@file ../external/py2cs.py</vh></v>
<v t="ekr.20170428085201.1"><vh>npyscreen</vh>
<v t="ekr.20170428084207.3"><vh>@file ../external/npyscreen/apNPSApplication.py</vh></v>
<v t="ekr.20170428084207.11"><vh>@file ../external/npyscreen/apNPSApplicationAdvanced.py</vh></v>
<v t="ekr.20170428084207.15"><vh>@file ../external/npyscreen/apNPSApplicationEvents.py</vh></v>
<v t="ekr.20170428084207.29"><vh>@file ../external/npyscreen/apNPSApplicationManaged.py</vh></v>
<v t="ekr.20170428084207.50"><vh>@file ../external/npyscreen/apOptions.py</vh></v>
<v t="ekr.20170428084207.111"><vh>@file ../external/npyscreen/eveventhandler.py</vh></v>
<v t="ekr.20170428084207.121"><vh>@file ../external/npyscreen/fmActionForm.py</vh></v>
<v t="ekr.20170428084207.131"><vh>@file ../external/npyscreen/fmActionFormV2.py</vh></v>
<v t="ekr.20170428084207.153"><vh>@file ../external/npyscreen/fmFileSelector.py</vh></v>
<v t="ekr.20170428084207.174"><vh>@file ../external/npyscreen/fmForm.py</vh></v>
<v t="ekr.20170428084207.223"><vh>@file ../external/npyscreen/fmFormMultiPage.py</vh></v>
<v t="ekr.20170428084207.248"><vh>@file ../external/npyscreen/fmFormMutt.py</vh></v>
<v t="ekr.20170428084207.258"><vh>@file ../external/npyscreen/fmFormMuttActive.py</vh></v>
<v t="ekr.20170428084207.285"><vh>@file ../external/npyscreen/fmFormWithMenus.py</vh></v>
<v t="ekr.20170428084207.303"><vh>@file ../external/npyscreen/fmPopup.py</vh></v>
<v t="ekr.20170428084207.311"><vh>@file ../external/npyscreen/fm_form_edit_loop.py</vh></v>
<v t="ekr.20170428084207.322"><vh>@file ../external/npyscreen/globals.py</vh></v>
<v t="ekr.20170428084207.324"><vh>@file ../external/npyscreen/muMenu.py</vh></v>
<v t="ekr.20170428084207.332"><vh>@file ../external/npyscreen/muNewMenu.py</vh></v>
<v t="ekr.20170428084207.351"><vh>@file ../external/npyscreen/npysGlobalOptions.py</vh></v>
<v t="ekr.20170428084207.353"><vh>@file ../external/npyscreen/npysNPSFilteredData.py</vh></v>
<v t="ekr.20170428084207.364"><vh>@file ../external/npyscreen/npyspmfuncs.py</vh></v>
<v t="ekr.20170428084207.370"><vh>@file ../external/npyscreen/npyssafewrapper.py</vh></v>
<v t="ekr.20170428084207.377"><vh>@file ../external/npyscreen/npysThemeManagers.py</vh></v>
<v t="ekr.20170428084207.390"><vh>@file ../external/npyscreen/npysThemes.py</vh></v>
<v t="ekr.20170428084207.399"><vh>@file ../external/npyscreen/npysTree.py</vh></v>
<v t="ekr.20170428084207.422"><vh>@file ../external/npyscreen/proto_fm_screen_area.py</vh></v>
<v t="ekr.20170428084207.434"><vh>@file ../external/npyscreen/stdfmemail.py</vh></v>
<v t="ekr.20170428084207.464"><vh>@file ../external/npyscreen/utilNotify.py</vh></v>
<v t="ekr.20170428084207.477"><vh>@file ../external/npyscreen/util_viewhelp.py</vh></v>
<v t="ekr.20170428084207.480"><vh>@file ../external/npyscreen/wgannotatetextbox.py</vh></v>
<v t="ekr.20170428084207.494"><vh>@file ../external/npyscreen/wgautocomplete.py</vh></v>
<v t="ekr.20170428084207.503"><vh>@file ../external/npyscreen/wgboxwidget.py</vh></v>
<v t="ekr.20170428084207.524"><vh>@file ../external/npyscreen/wgbutton.py</vh></v>
<v t="ekr.20170428084207.536"><vh>@file ../external/npyscreen/wgcheckbox.py</vh></v>
<v t="ekr.20170428084207.561"><vh>@file ../external/npyscreen/wgcombobox.py</vh></v>
<v t="ekr.20170428084207.575"><vh>@file ../external/npyscreen/wgdatecombo.py</vh></v>
<v t="ekr.20170428084207.586"><vh>@file ../external/npyscreen/wgeditmultiline.py</vh></v>
<v t="ekr.20170428084207.611"><vh>@file ../external/npyscreen/wgfilenamecombo.py</vh></v>
<v t="ekr.20170428084207.618"><vh>@file ../external/npyscreen/wgFormControlCheckbox.py</vh></v>
<v t="ekr.20170428084208.1"><vh>@file ../external/npyscreen/wggrid.py</vh></v>
<v t="ekr.20170428084208.36"><vh>@file ../external/npyscreen/wggridcoltitles.py</vh></v>
<v t="ekr.20170428084208.43"><vh>@file ../external/npyscreen/wgmonthbox.py</vh></v>
<v t="ekr.20170428084208.68"><vh>@file ../external/npyscreen/wgmultiline.py</vh></v>
<v t="ekr.20170428084208.157"><vh>@file ../external/npyscreen/wgmultilineeditable.py</vh></v>
<v t="ekr.20170428084208.173"><vh>@file ../external/npyscreen/wgmultilinetree.py</vh></v>
<v t="ekr.20170428084208.213"><vh>@file ../external/npyscreen/wgmultilinetreeselectable.py</vh></v>
<v t="ekr.20170428084208.225"><vh>@file ../external/npyscreen/wgmultiselect.py</vh></v>
<v t="ekr.20170428084208.245"><vh>@file ../external/npyscreen/wgmultiselecttree.py</vh></v>
<v t="ekr.20170428084208.253"><vh>@file ../external/npyscreen/wgNMenuDisplay.py</vh></v>
<v t="ekr.20170428084208.285"><vh>@file ../external/npyscreen/wgpassword.py</vh></v>
<v t="ekr.20170428084208.290"><vh>@file ../external/npyscreen/wgselectone.py</vh></v>
<v t="ekr.20170428084208.297"><vh>@file ../external/npyscreen/wgslider.py</vh></v>
<v t="ekr.20170428084208.318"><vh>@file ../external/npyscreen/wgtextbox.py</vh></v>
<v t="ekr.20170428084208.354"><vh>@file ../external/npyscreen/wgtextboxunicode.py</vh></v>
<v t="ekr.20170428084208.359"><vh>@file ../external/npyscreen/wgtextbox_controlchrs.py</vh></v>
<v t="ekr.20170428084208.366"><vh>@file ../external/npyscreen/wgtexttokens.py</vh></v>
<v t="ekr.20170428084208.381"><vh>@file ../external/npyscreen/wgtitlefield.py</vh></v>
<v t="ekr.20170428084208.398"><vh>@file ../external/npyscreen/wgwidget.py</vh></v>
<v t="ekr.20170428084208.436"><vh>@file ../external/npyscreen/wgwidget_proto.py</vh></v>
<v t="ekr.20170428084208.443"><vh>@@file ../external/npyscreen/__init__.py</vh>
<v t="ekr.20170428084208.444"><vh>Declarations</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20180225010850.1"><vh>In leo/modes</vh>
<v t="ekr.20150326145530.1"><vh>@clean ../modes/forth.py</vh>
<v t="ekr.20150326145530.2"><vh>&lt;&lt; define mode rules &gt;&gt;</vh></v>
<v t="ekr.20150326145530.3"><vh>&lt;&lt; define mode data &gt;&gt;</vh></v>
<v t="ekr.20150326145530.4"><vh>&lt;&lt; define extendForth class &gt;&gt;</vh>
<v t="ekr.20150326145530.5"><vh>ctor</vh></v>
<v t="ekr.20150326145530.6"><vh>init &amp; helper</vh>
<v t="ekr.20150326145530.7"><vh>splitList</vh></v>
</v>
<v t="ekr.20150326145530.8"><vh>createBracketRules &amp; helper</vh></v>
<v t="ekr.20150326145530.9"><vh>createDefiningWordRules &amp; helper</vh></v>
<v t="ekr.20150326145530.10"><vh>createKeywords</vh></v>
<v t="ekr.20150326145530.11"><vh>createStringRule</vh></v>
<v t="ekr.20150326145530.12"><vh>extendRulesDict</vh></v>
</v>
</v>
</v>
<v t="ekr.20181013081645.1"><vh>In leo/core/test</vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20160517182239.1"><vh>@file ../../flake8-leo.py</vh></v>
<v t="ekr.20160518000549.1"><vh>@file ../../pyflakes-leo.py</vh></v>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh></v>
<v t="ekr.20170805060844.1"><vh>@file ../test/leo-bridge-test.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904"><vh>@file leoTest.py</vh></v>
<v t="ekr.20201129023817.1"><vh>@file leoTest2.py</vh></v>
<v t="ekr.20201202144529.1"><vh>leo/unittests</vh>
<v t="ekr.20201202144422.1"><vh>@file ../unittests/commands/test_editCommands.py</vh></v>
<v t="ekr.20201203042030.1"><vh>@file ../unittests/core/test_leoNodes.py</vh></v>
</v>
</v>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943">@nosearch
</t>
<t tx="EKR.20040517075715"></t>
<t tx="EKR.20040517075715.13"></t>
<t tx="EKR.20040517075715.20">[Main]
use_styles = Yes
use_section_numbers = Yes
use_current_document = Yes
max_headings = 6
header_style = Heading
</t>
<t tx="EKR.20040517090508">@nocolor-node

Enable plugins by creating@enabled-plugins nodes in leoSettings files,
typically myLeoSettings.leo.See the node

Users Guide-- &gt; Chapter 8: Customizing Leo-- &gt;@rst
html\customizing.html-- &gt; Specifying settings-- &gt; Complex settings nodes

in LeoDocs.leo for full details.

**Important**: Leo no longer uses pluginsManager.txt to enable or disable plugins.
</t>
<t tx="ajones.20070122153625.2">def on_icondclick(tag, keywords):
    c = keywords.get("c")
    p = keywords.get("p")
    h = p.h
    if g.match_word(h,0,"@expfolder"):
        if p.hasChildren():
            result = g.app.gui.runAskYesNoDialog(c, "Reread?", "Reread contents of folder "+h[11:]+"?")
            if result == "no":
                return
            kids = []
            for cp in p.subtree():
                if cp.isDirty() and g.match_word(cp.h, 0, "@text"):
                    kids.append(cp.copy())
            if kids != []:
                result = g.app.gui.runAskYesNoDialog(c, "Reread?", "Save changed @text nodes?")
                if result == "yes":
                    for kid in kids:
                        savetextnode(c, kid)

            # delete children
            while p.firstChild():
                p.firstChild().doDelete()

        #changed = c.isChanged()
        dir = h[11:]
        dirs = []
        files = []
        for file in os.listdir(dir):
            path = os.path.join(dir, file)
            if os.path.isdir(path):
                dirs.append(path)
            else:
                files.append(path)

        #g.es('dirs: '+str(dirs))
        #g.es('files: '+str(files))

        dirs.sort()
        files.sort()
        for f in files:
            pn = p.insertAsNthChild(0)
            if os.path.splitext(f)[1] in textexts:
                c.setHeadString(pn, "@text "+f)
                pn.clearDirty()
            else:
                pn.h = f
        for d in dirs:
            pn = p.insertAsNthChild(0)
            c.setHeadString(pn, "@expfolder "+d)
        c.expandSubtree(p)
</t>
<t tx="ajones.20070122161942">def on_save(tag,keywords):
    c = keywords.get("c")
    if not c: return

    for p in c.all_positions():
        h = p.h
        if g.match_word(h,0,"@text") and p.isDirty():
            savetextnode(c, p)
            p.b = ""
</t>
<t tx="ajones.20070122181914.1">def readtextnode(c, p):

    name = getPath(c,p)
    try:
        file = open(name,"rU")
        g.es("..." + name)
        p.b = file.read()
        p.clearDirty()
        file.close()
    except IOError as msg:
        g.es("error reading %s: %s" % (name, msg))
        g.es("...not found: " + name)
        p.b = ''
        p.setDirty()
</t>
<t tx="btheado.20120129145543.8180">def pageUpDown(self, op, moveMode):
    """
    The QTextEdit PageUp/PageDown functionality seems to be "baked-in"
    and not externally accessible. Since Leo has its own keyhandling
    functionality, this code emulates the QTextEdit paging. This is a
    straight port of the C++ code found in the pageUpDown method of
    gui/widgets/qtextedit.cpp.
    """
    control = self.widget
    cursor = control.textCursor()
    moved = False
    lastY = control.cursorRect(cursor).top()
    distance = 0
    # move using movePosition to keep the cursor's x
    while True:
        y = control.cursorRect(cursor).top()
        distance += abs(y - lastY)
        lastY = y
        moved = cursor.movePosition(op, moveMode)
        if (not moved or distance &gt;= control.height()):
            break
    tc = QtGui.QTextCursor
    sb = control.verticalScrollBar()
    if moved:
        if (op == tc.Up):
            cursor.movePosition(tc.Down, moveMode)
            sb.triggerAction(QtWidgets.QAbstractSlider.SliderPageStepSub)
        else:
            cursor.movePosition(tc.Up, moveMode)
            sb.triggerAction(QtWidgets.QAbstractSlider.SliderPageStepAdd)
    control.setTextCursor(cursor)
</t>
<t tx="danr7.20060912105041.6">def paste_as_headlines(c):
    # g.es("Starting...")
    currentPos = c.p
    clipText = g.app.gui.getTextFromClipboard()
    # Split clipboard text elements into a list
    clipList = clipText.split("\n")
    init_indent = len(clipList[0]) - len(clipList[0].lstrip())
    cur_pos = currentPos.copy()
    ancestors = [(init_indent,cur_pos)]
    for tempHead in clipList:
        indent = len(tempHead) - len(tempHead.lstrip())
        tempHead = tempHead.strip()
        # Make sure list item has some content
        if tempHead:
            if indent &gt; ancestors[-1][0]:
                ancestors.append((indent,cur_pos))
            else:
                while init_indent &lt;= indent &lt; ancestors[-1][0]:
                    ancestors.pop()
            # cur_indent = indent
            insertNode = ancestors[-1][1].insertAsLastChild()
            cur_pos = insertNode.copy()
            if len(tempHead)&gt;50:
                c.setHeadString(insertNode,tempHead[:50])
                insertNode.b = tempHead
            else:
                insertNode.h = tempHead
    currentPos.expand()
    c.redraw()
</t>
<t tx="edream.110203113231.667"></t>
<t tx="edream.110203113231.673"># name = tkFileDialog.askopenfilename(
    # title="Import Cisco Configuration File",
    # filetypes=[("All files", "*")]
    # )

name = g.app.gui.runOpenFileDialog (c,
    title="Import Cisco Configuration File",
    filetypes=[("All files", "*")],
    defaultextension='ini',
)

if not name:
    return

p = current.insertAsNthChild(0)
p.h = "cisco config: %s" % name
c.redraw()

try:
    fh = open(name)
    g.es("importing: %s" % name)
    linelist = fh.read().splitlines()
    fh.close()
except IOError as msg:
    g.es("error reading %s: %s" % (name, msg))
    return
</t>
<t tx="edream.110203113231.674">if customLine not in blocks:
    blocks[customLine] = []
    out.append(g.angleBrackets(customLine))
    # create first-level child
    child = p.insertAsNthChild(0)
    child.h = g.angleBrackets(customLine)
    children.append(child)

blocks[customLine].append(linelist[i])
</t>
<t tx="edream.110203113231.675">space = linelist[i].find(' ')
if space == -1:
    space = len(linelist[i])
key = linelist[i][:space]
if key in blocks:
    blocks[key] = []
    out.append(g.angleBrackets(key))
    # create first-level child
    child = p.insertAsNthChild(0)
    child.h = g.angleBrackets(key)
    children.append(child)

value = [linelist[i]]
# loop through the indented lines
i = i+1
try:
    while linelist[i].startswith(' '):
        value.append(linelist[i])
        i = i+1
except Exception:
    # EOF
    pass
i = i-1 # restore index
# now add the value to the dictionary
blocks[key].append(value)
</t>
<t tx="edream.110203113231.676"># first print the level-0 text
outClean = []
prev = ''
for line in out:
    if line=='!' and prev=='!':
        pass # skip repeated comment lines
    else:
        outClean.append(line)
    prev = line
p.b = '\n'.join(outClean)

# scan through the created outline and add children
for child in children:
    # extract the key from the headline. Uhm... :)
    key = child.h.split('&lt;&lt;'
        )[1].split('&gt;&gt;')[0].strip()
    if key in blocks:
        # if type(blocks[key][0]) == type(''):
        if g.isString(blocks[key][0]):
            # it's a string, no sub-children, so just print the text
            child.b = '\n'.join(blocks[key])
        else:
            # it's a multi-level node
            for value in blocks[key]:
                # each value is a list containing the headline and then the text
                subchild = child.insertAsNthChild(0)
                subchild.h = value[0]
                subchild.b = '\n'.join(value)
        # child.sortChildren()
    else:
        # this should never happen
        g.es("Unknown key: %s" % key)
# p.sortChildren()
current.expand()
c.redraw()
</t>
<t tx="edream.110203113231.729"></t>
<t tx="edream.110203113231.872">@nocolor-node

These plugins create new kinds of nodes, some of which affect the file system.</t>
<t tx="edream.110203113231.875">def sync_node_to_folder(c,parent,d):

    oldlist = {}
    newlist = []
    #get children info
    v = parent
    after_v = parent.nodeAfterTree()
    while v != after_v:
        if not v.hasChildren():
            oldlist[v.h] = v.b
        v = v.threadNext()
    #compare folder content to children
    for name in os.listdir(d):
        if name in oldlist:
            del oldlist[name]
        else:
            newlist.append(name)
    #insert newlist
    newlist.sort()
    newlist.reverse()
    for name in newlist:
        v = parent.insertAsNthChild(0)
        v.h = name
        v.setMarked()
    #warn for orphan oldlist
    if oldlist:
        g.es('missing: '+','.join(oldlist.keys()))
</t>
<t tx="edream.110203113231.894"># Sets p's body text from the file with the given name.
# Returns True if the body text changed.
def insert_read_only_node (c,p,name):
    if name=="":
        name = g.app.gui.runOpenFileDialog(c,
            title="Open",
            filetypes=[("All files", "*")],
        )
        p.h = "@read-only %s" % name
        c.redraw()
    parse = urlparse(name)
    try:
        if parse[0] == 'ftp':
            f = FTPurl(name)  # FTP URL
        elif parse[0] == 'http':
            f = urlopen(name)  # HTTP URL
        else:
            f = open(name,"r")  # local file
        g.es("..." + name)
        new = f.read()
        f.close()
    except IOError: # as msg:
        p.b = "" # Clear the body text.
        return True # Mark the node as changed.
    else:
        ext = os.path.splitext(parse[2])[1]
        if ext.lower() in ['.htm', '.html']:
            &lt;&lt; convert HTML to text &gt;&gt;
        previous = p.b
        p.b = new
        changed = (g.toUnicode(new) != g.toUnicode(previous))
        if changed and previous != "":
            g.es("changed: %s" % name) # A real change.
        return changed
</t>
<t tx="edream.110203113231.895">fh = StringIO()
fmt = AbstractFormatter(DumbWriter(fh))
# the parser stores parsed data into fh (file-like handle)
parser = HTMLParser(fmt)

# send the HTML text to the parser
parser.feed(new)
parser.close()

# now replace the old string with the parsed text
new = fh.getvalue()
fh.close()

# finally, get the list of hyperlinks and append to the end of the text
hyperlinks = parser.anchorlist
numlinks = len(hyperlinks)
if numlinks &gt; 0:
    hyperlist = ['\n\n--Hyperlink list follows--']
    for i in range(numlinks):
        hyperlist.append("\n[%d]: %s" % (i+1,hyperlinks[i])) # 3/26/03: was i.
    new = new + ''.join(hyperlist)
</t>
<t tx="edream.110203113231.928"># Same as frame.put except sends output to the end of the body text.
def newPut (self,s,*args,**keys):

    body = self.frame.body
    w = body.wrapper
    if w:
        w.insert("end",s)
        body.onBodyChanged('put-to-body-text')
    # else: g.pr(s,newline=False)

# Same as frame.putnl except sends output to the end of the body text.
def newPutNl (self,s,*args,**keys):

    newPut (self,'\n')
</t>
<t tx="ekr.20031218072017.1329">def onBodyChanged(self, undoType, oldSel=None):
    """
    Update Leo after the body has been changed.
    
    This method is deprecated. New Leo commands and scripts should
    call u.before/afterChangeBody instead.
    """
    p, u, w = self.c.p, self.c.undoer, self.wrapper
    #
    # Shortcut.
    newText = w.getAllText()
    if p.b == newText:
        return
    #
    # Init data.
    newSel = w.getSelectionRange()
    newInsert = w.getInsertPoint()
    #
    # The "Before" snapshot.
    #
    # #1743: Restore oldSel for u.beforeChangeBody
    if oldSel and newSel and oldSel != newSel:
        i, j = oldSel
        w.setSelectionRange(i, j, insert=j)
    bunch = u.beforeChangeBody(p)
    #
    # #1743: Restore newSel if necessary.
    if oldSel and newSel and oldSel != newSel:
        i, j = newSel
        w.setSelectionRange(i, j, insert=newInsert)
    #
    # Careful. Don't redraw unless necessary.
    p.v.b = newText  # p.b would cause a redraw.
    #
    # "after" snapshot.
    u.afterChangeBody(p, undoType, bunch)
</t>
<t tx="ekr.20031218072017.1490">def doTyping(self, p, undo_type, oldText, newText,
    newInsert=None, oldSel=None, newSel=None, oldYview=None,
):
    """
    Save enough information to undo or redo a typing operation efficiently,
    that is, with the proper granularity.
    
    Do nothing when called from the undo/redo logic because the Undo
    and Redo commands merely reset the bead pointer.
    
    **Important**: Code should call this method *only* when the user has
    actually typed something. Commands should use u.beforeChangeBody and
    u.afterChangeBody.
    
    Only qtm.onTextChanged and ec.selfInsertCommand now call this method.
    """
    c, u, w = self.c, self, self.c.frame.body.wrapper
    # Leo 6.4: undo_type must be 'Typing'.
    undo_type = undo_type.capitalize()
    assert undo_type == 'Typing', (repr(undo_type), g.callers())
    &lt;&lt; return if there is nothing to do &gt;&gt;
    &lt;&lt; init the undo params &gt;&gt;
    &lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
    &lt;&lt; save undo text info &gt;&gt;
    &lt;&lt; save the selection and scrolling position &gt;&gt;
    &lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;
    if 'undo' in g.app.debug and 'verbose' in g.app.debug:
        print(f"u.doTyping: {len(oldText)} =&gt; {len(newText)}")
    if u.per_node_undo:
        u.putIvarsToVnode(p)
    #
    # Finish updating the text.
    p.v.setBodyString(newText)
    u.updateAfterTyping(p, w)
        
# Compatibility

setUndoTypingParams = doTyping
</t>
<t tx="ekr.20031218072017.1491">@ Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c
old_lines = oldText.split('\n')
new_lines = newText.split('\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len, new_len)
i = 0
while i &lt; min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i
if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i &lt; min_len - leading:
        if old_lines[old_len - i - 1] != new_lines[new_len - i - 1]:
            break
        i += 1
    trailing = i
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading : -trailing]
    new_middle_lines = new_lines[leading : -trailing]
# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1; old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1
i = len(newText) - 1; new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1
</t>
<t tx="ekr.20031218072017.1492">u.oldText = None
u.newText = None
u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
</t>
<t tx="ekr.20031218072017.1553">def getLeoFile(self,
    theFile,
    fileName,
    readAtFileNodesFlag=True,
    silent=False,
    checkOpenFiles=True,
):
    """
        Read a .leo file.
        The caller should follow this with a call to c.redraw().
    """
    fc, c = self, self.c
    t1 = time.time()
    c.clearChanged()  # May be set when reading @file nodes.
    fc.warnOnReadOnlyFiles(fileName)
    fc.checking = False
    fc.mFileName = c.mFileName
    fc.initReadIvars()
    recoveryNode = None
    try:
        c.loading = True  # disable c.changed
        if not silent and checkOpenFiles:
            # Don't check for open file when reverting.
            g.app.checkForOpenFile(c, fileName)
        #
        # Read the .leo file and create the outline.
        if fileName.endswith('.db'):
            v = fc.retrieveVnodesFromDb(theFile) or fc.initNewDb(theFile)
        else:
            v = FastRead(c, self.gnxDict).readFile(theFile, fileName)
            if v:
                c.hiddenRootNode = v
        if v:
            fc.resolveTnodeLists()
                # Do this before reading external files.
            c.setFileTimeStamp(fileName)
            if readAtFileNodesFlag:
                # c.redraw()
                    # Does not work.
                    # Redraw before reading the @file nodes so the screen isn't blank.
                    # This is important for big files like LeoPy.leo.
                recoveryNode = fc.readExternalFiles(fileName)
    finally:
        p = recoveryNode or c.p or c.lastTopLevel()
            # lastTopLevel is a better fallback, imo.
        c.selectPosition(p)
        c.redraw_later()
            # Delay the second redraw until idle time.
            # This causes a slight flash, but corrects a hangnail.
        c.checkOutline()
            # Must be called *after* ni.end_holding.
        c.loading = False
            # reenable c.changed
        if not isinstance(theFile, sqlite3.Connection):
            theFile.close()
            # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1208942
            # Leo holding directory/file handles after file close?
    if c.changed:
        fc.propegateDirtyNodes()
    fc.initReadIvars()
    t2 = time.time()
    g.es(f"read outline in {t2 - t1:2.2f} seconds")
    return v, c.frame.ratio
</t>
<t tx="ekr.20031218072017.1554">def warnOnReadOnlyFiles(self, fileName):
    # os.access may not exist on all platforms.
    try:
        self.read_only = not os.access(fileName, os.W_OK)
    except AttributeError:
        self.read_only = False
    except UnicodeError:
        self.read_only = False
    if self.read_only and not g.unitTesting:
        g.error("read only:", fileName)
</t>
<t tx="ekr.20031218072017.2377">def getSelectionLines(self):
    """
    Return before,sel,after where:

    before is the all lines before the selected text
    (or the text before the insert point if no selection)
    sel is the selected text (or "" if no selection)
    after is all lines after the selected text
    (or the text after the insert point if no selection)
    """
    if g.app.batchMode:
        return '', '', ''
    # At present, called only by c.getBodyLines.
    body = self
    w = body.wrapper
    s = w.getAllText()
    i, j = w.getSelectionRange()
    if i == j:
        i, j = g.getLine(s, i)
    else:
        # #1742: Move j back if it is at the start of a line.
        if j &gt; i and j &gt; 0 and s[j-1] == '\n':
            j -= 1
        i, junk = g.getLine(s, i)
        junk, j = g.getLine(s, j)
    before = g.checkUnicode(s[0:i])
    sel = g.checkUnicode(s[i:j])
    after = g.checkUnicode(s[j : len(s)])
    return before, sel, after  # 3 strings.
</t>
<t tx="ekr.20031218072017.2406" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e"># This file contains almost all of Leo's sources.

# See the "About this file" node for important notes.
</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.3029">def readAtFileNodes(self):
    
    c, p = self.c, self.c.p
    c.endEditing()
    c.atFileCommands.readAll(p, force=True)
    c.redraw()
    # Force an update of the body pane.
    c.setBodyString(p, p.b)  # Not a do-nothing!
    
</t>
<t tx="ekr.20031218072017.3070"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):
    c = self.c
    p = self.p or c.p  # 2015/06/22
    wrapper = c.frame.body and c.frame.body.wrapper
    w = c.edit_widget(p) if self.in_headline else wrapper
    if not w:
        self.in_headline = False
        w = wrapper
    if not w: return False
    oldSel = sel = w.getSelectionRange()
    start, end = sel
    if start &gt; end: start, end = end, start
    if start == end:
        g.es("no text selected"); return False
    # Replace the selection in _both_ controls.
    start, end = oldSel
    change_text = self.change_text
    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text, groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)
    for w2 in (w, self.s_ctrl):
        if start != end: w2.delete(start, end)
        w2.insert(start, change_text)
        w2.setInsertPoint(start if self.reverse else start + len(change_text))
    # Update the selection for the next match.
    w.setSelectionRange(start, start + len(change_text))
    c.widgetWantsFocus(w)
    # No redraws here: they would destroy the headline selection.
    if self.mark_changes:
        p.setMarked()
        p.setDirty()
    if self.in_headline:
        pass
    else:
        c.frame.body.onBodyChanged('Change', oldSel=oldSel)
    c.frame.tree.updateIcon(p)  # redraw only the icon.
    return True
</t>
<t tx="ekr.20031218072017.3210">def createOutline(self,
    fileName,
    parent,
    atShadow=False,  # For error messages only.
    ext=None,
    s=None,
    # force_at_others=False,  # tag:no-longer-used
):
    """
    Create an outline by importing a file, reading the file with the
    given encoding if string s is None.

    ext,        The file extension to be used, or None.
    fileName:   A string or None. The name of the file to be read.
    parent:     The parent position of the created outline.
    s:          A string or None. The file's contents.
    """
    c = self.c
    p = parent.copy()
    self.treeType = '@file'
        # Fix #352.
    fn = self.get_import_filename(fileName, parent)
    if g.is_binary_external_file(fileName):
        return self.import_binary_file(fn, parent)
    # Init ivars.
    self.setEncoding(
        p=parent,
        default=c.config.default_at_auto_file_encoding,
    )
    ext, s = self.init_import(atShadow, ext, fileName, s)
    if s is None:
        return None
    # Get the so-called scanning func.
    func = self.dispatch(ext, p)
        # Func is a callback. It must have a c argument.
    # Call the scanning function.
    if g.unitTesting:
        assert func or ext in ('.txt', '.w', '.xxx'), (repr(func), ext, p.h)
    if func and not c.config.getBool('suppress-import-parsing', default=False):
        s = g.toUnicode(s, encoding=self.encoding)
        s = s.replace('\r', '')
        # func is actually a factory: it instantiates the importer class.
        func(c=c, parent=p, s=s)
            # force_at_others=force_at_others #tag:no-longer-used
    else:
        # Just copy the file to the parent node.
        s = g.toUnicode(s, encoding=self.encoding)
        s = s.replace('\r', '')
        self.scanUnknownFileType(s, p, ext)
    # Fix bug 488894: unsettling dialog when saving Leo file
    # Fix bug 889175: Remember the full fileName.
    c.atFileCommands.rememberReadPath(fileName, p)
    p.contract()
    w = c.frame.body.wrapper
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
</t>
<t tx="ekr.20031218072017.3344">def __init__(self, context, gnx=None):
    """
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = 1 whenever
    v.unknownAttributes or any mutable VNode object changes.
    """
    # The primary data: headline and body text.
    self._headString = 'newHeadline'
    self._bodyString = ''
    # Structure data...
    self.children = []
        # Ordered list of all children of this node.
    self.parents = []
        # Unordered list of all parents of this node.
    # Other essential data...
    self.fileIndex = None
        # The immutable fileIndex (gnx) for this node. Set below.
    self.iconVal = 0
        # The present value of the node's icon.
    self.statusBits = 0
        # status bits
    # Information that is never written to any file...
    self.context = context  # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.expandedPositions = []
        # Positions that should be expanded.
    self.insertSpot = None
        # Location of previous insert point.
    self.scrollBarSpot = None
        # Previous value of scrollbar position.
    self.selectionLength = 0
        # The length of the selected body text.
    self.selectionStart = 0
        # The start of the selected body text.
    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
</t>
<t tx="ekr.20031218072017.3351">def isAtIgnoreNode(self):
    """
    Returns True if:
        
    - the vnode' body contains @ignore at the start of a line or

    - the vnode's headline starts with @ignore.
    """
    # v = self
    if g.match_word(self._headString, 0, '@ignore'):
        return True
    flag, i = g.is_special(self._bodyString, "@ignore")
    return flag
</t>
<t tx="ekr.20031218072017.3395">def contract(self):
    """Contract the node."""
    self.statusBits &amp;= ~self.expandedBit

def expand(self):
    """Expand the node."""
    self.statusBits |= self.expandedBit

def initExpandedBit(self):
    """Init self.statusBits."""
    self.statusBits |= self.expandedBit

def isExpanded(self):
    """Return True if the VNode expansion bit is set."""
    return (self.statusBits &amp; self.expandedBit) != 0
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.4117">def defineMenuCallback(self, command, name, minibufferCommand):
    # pylint: disable=no-else-return
        # This code is simpler as it is.
    c = self.c
    if minibufferCommand:
        # Create a dummy event as a signal to doCommand.
        event = g.app.gui.create_key_event(c)
        # The first parameter must be event, and it must default to None.

        def minibufferMenuCallback(event=event, self=self, command=command, label=name):
            c = self.c
            return c.doCommand(command, label, event)

        return minibufferMenuCallback
    else:
        # The first parameter must be event, and it must default to None.

        def legacyMenuCallback(event=None, self=self, command=command, label=name):
            c = self.c # 2012/03/04.
            c.check_event(event)
            return c.doCommand(command, label)

        return legacyMenuCallback
</t>
<t tx="ekr.20040205071616.4">def setHeadOK(c,v):

    v.h = OKFLAG + v.h

</t>
<t tx="ekr.20040205071616.5">def insertBodystamp (c,v):

    p, u, w = c.p, c.undoer, c.frame.body.wrapper
    stamp = mnOKstamp() + '\n'
    bunch = u.beforeChangeBody(p)
    ins = w.getInsertPoint()
    w.insert(ins,stamp)
    p.v.b = w.getAllText()  # p.b would cause a redraw.
    u.afterChangeBody(p, 'insert-timestamp', bunch)
</t>
<t tx="ekr.20040205071616.9">def insertUser (self,event=None):
    """Handle the Insert User command."""
    c = self
    w = c.frame.body.wrapper
    oldSel = w.getSelectionRange()
    w.deleteTextSelection() # Works if nothing is selected.
    stamp = mnstamp()
    i = w.getInsertPoint()
    w.insert(i,stamp)
    c.frame.body.onBodyChanged('insert-user',oldSel=oldSel)
</t>
<t tx="ekr.20040305223225">def setHeadString(self, p, s):
    """
    Set the p's headline and the corresponding tree widget to s.

    This is used in by unit tests to restore the outline.
    """
    c = self
    p.initHeadString(s)
    p.setDirty()
    # Change the actual tree widget so
    # A later call to c.endEditing or c.redraw will use s.
    c.frame.tree.setHeadline(p, s)
</t>
<t tx="ekr.20040305223522">def setBodyString(self, p, s):
    """
    This is equivalent to p.b = s.
    
    Warning: This method may call c.recolor() or c.redraw().
    """
    c, v = self, p.v
    if not c or not v:
        return
    s = g.toUnicode(s)
    current = c.p
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v == current.v:
        w = c.frame.body.wrapper
        w.setAllText(s)
        v.setSelection(0,0)
        c.recolor()
    # Keep the body text in the VNode up-to-date.
    if v.b != s:
        v.setBodyString(s)
        v.setSelection(0, 0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged()
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20040315032503">def appendStringToBody(self, p, s):

    if s:
        p.b = p.b + g.toUnicode(s)
</t>
<t tx="ekr.20040324061854">if u.redoing or u.undoing:
    return None
if undo_type is None:
    return None
if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes()  # Must still recalculate the menu labels.
    return None
if oldText == newText:
    u.setUndoTypes()  # Must still recalculate the menu labels.
    return None
</t>
<t tx="ekr.20040324061854.1">u.clearOptionalIvars()
# Set the params.
u.undoType = undo_type
u.p = p.copy()
</t>
<t tx="ekr.20040324061854.2"># Remember the selection.
u.oldSel = oldSel
u.newSel = newSel
# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.wrapper.getYScrollPosition()
</t>
<t tx="ekr.20040324061854.3">@
New in Leo 4.3. Instead of creating a new bead on every character, we
may adjust the top bead:
word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c
granularity = u.granularity
old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')
&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;
# Save end selection as new "previous" selection
u.prevSel = u.newSel
if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p=p.copy(),
        kind='typing',  # lowercase.
        undoType=undo_type,  # capitalized.
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldMarked=old_p.isMarked() if old_p else p.isMarked(), # #1694
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d
bunch.leading = u.leading
bunch.trailing = u.trailing
bunch.newMarked = p.isMarked()  # #1694 
bunch.newNewlines = u.newNewlines
bunch.newMiddleLines = u.newMiddleLines
bunch.newSel = u.newSel
bunch.newText = u.newText
bunch.yview = u.yview
</t>
<t tx="ekr.20040327105706">def __init__(self, c, title, gui):
    """Ctor for the NullFrame class."""
    super().__init__(c, gui)
    assert self.c
    self.wrapper = None
    self.iconBar = NullIconBarClass(self.c, self)
    self.initComplete = True
    self.isNullFrame = True
    self.outerFrame = None
    self.ratio = self.secondary_ratio = 0.5
    self.statusLineClass = NullStatusLineClass
    self.title = title
    self.top = None  # Always None.
    # Create the component objects.
    self.body = NullBody(frame=self, parentFrame=None)
    self.log = NullLog(frame=self, parentFrame=None)
    self.menu = leoMenu.NullMenu(frame=self)
    self.tree = NullTree(frame=self)
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
</t>
<t tx="ekr.20040331071919"></t>
<t tx="ekr.20040331071919.31">@language python
@tabwidth -4

@doc
@ascskip # Time-stamp: "Tue, Jan 13 10:10 CST 2004  michael@redpriest _OpenWith_Plugin__140659092.py"

Leo's Open_With plugin can be modified so that the body text of any
outline node can be edited in XEmacs by choosing "File; OpenWith;
XEmacs" or "File; OpenWith; XEmacs - noshow"  from the menu.

What actually happens is that Leo places the text in a temporary
file, and calls XEmacs with the address of that temporary file.  Leo
then watches for changes in the temporary file.  When and if the
temporary file changes, Leo copies the contents to the body text of
the Leo node.

Below is the standard open_with.py plugin that came with Leo 4.1-rc3
The only modification I've made is to insert
@code
&lt;&lt;call XEmacs&gt;&gt;=
table = (
    ("X&amp;Emacs", "Alt+Shift+O", ("os.system","/usr/bin/gnuclient -q ", None)),
    ("X&amp;Emacs - noshow", "Ctrl+Shift+O", ("os.system","/mrc2/linux-bin/gnuclient-noshow ", None))
    )
@doc
as noted below.  A similar alteration should work for future
versions.

Note: this alteration is for XEmacs running under Linux, but a
similar command should work in the Windows environment.

I use the "gnuclient-noshow" selection to load the temporary open_with file in
the background.  It is a small bash shell script:
---
#!/bin/bash
gnuclient -eval "(find-file-noselect \"${1}\")"
---

To implement this, edit a copy of the open_with.py file that comes
with your version of Leo.  Move the original copy to a safe place,
and put your edited copy in the Leo plugins directory.  Check to see
it is included in "pluginsManager.txt" in that directory.
@ascskip on
@root "other/xemacs/open_with.py"
&lt;&lt; Open_With Plugin&gt;&gt;
@code
"""Create menu for Open With command and handle the resulting commands"""

import os
from leo.core import leoGlobals as g
Tk = g.import_module('tkinter')


if Tk: # Register the handlers...

    def on_idle (tag,keywords):
        a = g.app
        if g.app.killed: return
        for dict in a.openWithFiles:
            path = dict.get("path")
            c = dict.get("c")
            encoding = dict.get("encoding",None)
            v = dict.get("v")
            old_body = dict.get("body")
            if path and os.path.exists(path):
                try:
                    time = os.path.getmtime(path)
                    if time and time != dict.get("time"):
                        dict["time"] = time # inhibit endless dialog loop.
                        # The file has changed.
                        try:
                            # Update v from the changed temp file.
                            f=open(path)
                            s=f.read()
                            f.close()
                        except Exception:
                            g.es("can not open " + g.shortFileName(path))
                            break

                        # Convert body and s to whatever encoding is in effect.
                        body = v.bodyString()
                        body = g.toEncodedString(body,encoding,reportErrors=True)
                        s = g.toEncodedString(s,encoding,reportErrors=True) # 10/13/03

                        conflict = body != old_body and body != s

                        # Set update if we should update the outline from the file.
                        if conflict:
                            # See how the user wants to resolve the conflict.
                            g.error("conflict in " + g.shortFileName(path))
                            message = "Replace changed outline with external changes?"
                            result = g.app.gui.runAskYesNoDialog(c,"Conflict!",message)
                            update = result.lower() == "yes"
                        else:
                            update = s != body

                        if update:
                            g.blue("updated from: " + g.shortFileName(path))
                            v.b = s
                            c.selectVnode(v)
                            dict["body"] = s
                        elif conflict:
                            g.warning("not updated from: " + g.shortFileName(path))
                except Exception:
                    g.es_exception() # testing
                    pass
    def create_open_with_menu (tag,keywords):

        if  (tag in ("start2","open2") or
            (tag=="command2" and keywords.get("label")=="new")):

            # Entries in the following table are the tuple
            # (commandName,shortcut,data).
            #
            # - data is the tuple (command,arg,ext).
            # - command is one of "os.system", "os.startfile", "os.spawnl",
            # "os.spawnv" or "exec".
            #
            # Leo executes command(arg+path) where path is the full path to
            # the temp file.
            # If ext is not None, the temp file has the extension ext,
            # Otherwise, Leo computes an extension based on what @language
            # directive is in effect.

            idle_arg = "c:/python22/tools/idle/idle.py -e "

@doc
Here is where we insert the &lt; Call XEmacs &gt; code fragment defined above:
@code
            if 1: # Default table.


&lt;&lt; Call XEmacs &gt;&gt;
#               table = (
#                   # Opening idle this way doesn't work so well.
#                   # ("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
#                   ("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
#                   ("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
#           elif 1: # Test table.
#               table = ("&amp;Word","Alt+Shift+W",("os.startfile",None,".doc")),
#           else: # David McNab's table.
#               table = ("X&amp;Emacs", "Ctrl+E", ("os.spawnl","/usr/bin/gnuclient", None)),

            c.frame.menu.createOpenWithMenuFromTable(table)

    if g.app.gui is None:
        g.app.createTkGui(__file__)

    if g.app.gui.guiName() == "tkinter":

        g.app.hasOpenWithMenu = True
        g.registerHandler("idle", on_idle)
        g.registerHandler(("start2","menu2","command2"), create_open_with_menu)

        __version__ = "1.4" # Set version for the plugin handler.
        g.plugin_signon(__name__)

</t>
<t tx="ekr.20040331151007.1">def onPreSave(tag=None, keywords=None):

    """Before saving an @nosent file, make sure that all nodes have a blank line at the end."""

    global nosentNodes
    c = keywords.get('c')
    if c:
        for p in c.all_positions():
            if p.isAtNoSentinelsFileNode() and p.isDirty():
                nosentNodes.append(p.copy())
                for p2 in p.self_and_subtree():
                    s = p2.b
                    lastline = s.split('\n')[-1]
                    if lastline.strip():
                        p2.b = s + '\n'
</t>
<t tx="ekr.20040722141148">@nocolor-node
@

You would typically not enable any of the following "plugins".

These plugins contain example code only.
</t>
<t tx="ekr.20040915073259">@nocolor-node

These plugins add buttons and other widgets to the icon area or
affect Leo's panes and windows in various ways.

</t>
<t tx="ekr.20041001210557"></t>
<t tx="ekr.20041005105605.144">def write(self, kind, root, sentinels=True):
    """Write a 4.x derived file.
    root is the position of an @&lt;file&gt; node.
    sentinels will be False for @clean and @nosent nodes.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(
            root, root.anyAtFileNodeName(), kind=kind, sentinels=sentinels)
        if not fileName or not at.precheck(fileName, root):
            if sentinels:
                # Raise dialog warning of data loss.
                at.addToOrphanList(root)
            else:
                # #1450: No danger of data loss.
                pass
            return
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        at.warnAboutOrphandAndIgnoredNodes()
        contents = at.closeOutputStream()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
</t>
<t tx="ekr.20041005105605.157">def putFile(self, root, fromString='', sentinels=True):
    '''Write the contents of the file to the output stream.'''
    at = self
    s = fromString if fromString else root.v.b
    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=5")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root, fromString=fromString)
    at.putCloseNodeSentinel(root)
    # The -leo sentinel is required to handle @last.
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
</t>
<t tx="ekr.20041005105605.161">def putBody(self, p, fromString=''):
    '''
    Generate the body enclosed in sentinel lines.
    Return True if the body contains an @others line.
    '''
    at = self
    #
    # New in 4.3 b2: get s from fromString if possible.
    s = fromString if fromString else p.b
    p.v.setVisited()
        # Make sure v is never expanded again.
        # Suppress orphans check.
    #
    # Fix #1048 &amp; #1037: regularize most trailing whitespace.
    if s and (at.sentinels or at.force_newlines_in_at_nosent_bodies):
        if not s.endswith('\n'):
            s = s + '\n'
    at.raw = False  # Bug fix.
    i = 0
    status = g.Bunch(
        at_comment_seen=False,
        at_delims_seen=False,
        at_warning_given=False,
        has_at_others=False,
        in_code=True,
    )
    while i &lt; len(s):
        next_i = g.skip_line(s, i)
        assert next_i &gt; i, 'putBody'
        kind = at.directiveKind4(s, i)
        at.putLine(i, kind, p, s, status)
        i = next_i
    # pylint: disable=no-member
        # g.bunch *does* have .in_code and has_at_others members.
    if not status.in_code:
        at.putEndDocLine()
    return status.has_at_others
</t>
<t tx="ekr.20041005105605.163">def putLine(self, i, kind, p, s, status):
    '''Put the line at s[i:] of the given kind, updating the status.'''
    at = self
    if kind == at.noDirective:
        if status.in_code:
            if at.raw:
                at.putCodeLine(s, i)
            else:
                name, n1, n2 = at.findSectionName(s, i)
                if name:
                    at.putRefLine(s, i, n1, n2, name, p)
                else:
                    at.putCodeLine(s, i)
        else:
            at.putDocLine(s, i)
    elif at.raw:
        if kind == at.endRawDirective:
            at.raw = False
            at.putSentinel("@@end_raw")
        else:
            # Fix bug 784920: @raw mode does not ignore directives
            at.putCodeLine(s, i)
    elif kind in (at.docDirective, at.atDirective):
        if not status.in_code:
            # Bug fix 12/31/04: handle adjacent doc parts.
            at.putEndDocLine()
        at.putStartDocLine(s, i, kind)
        status.in_code = False
    elif kind in (at.cDirective, at.codeDirective):
        # Only @c and @code end a doc part.
        if not status.in_code:
            at.putEndDocLine()
        at.putDirective(s, i, p)
        status.in_code = True
    elif kind == at.allDirective:
        if status.in_code:
            if p == self.root:
                at.putAtAllLine(s, i, p)
            else:
                at.error(f"@all not valid in: {p.h}")
        else: at.putDocLine(s, i)
    elif kind == at.othersDirective:
        if status.in_code:
            if status.has_at_others:
                at.error(f"multiple @others in: {p.h}")
            else:
                at.putAtOthersLine(s, i, p)
                status.has_at_others = True
        else:
            at.putDocLine(s, i)
    elif kind == at.rawDirective:
        at.raw = True
        at.putSentinel("@@raw")
    elif kind == at.endRawDirective:
        # Fix bug 784920: @raw mode does not ignore directives
        at.error(f"unmatched @end_raw directive: {p.h}")
    elif kind == at.startVerbatim:
        # Fix bug 778204: @verbatim not a valid Leo directive.
        if g.unitTesting:
            # A hack: unit tests for @shadow use @verbatim as a kind of directive.
            pass
        else:
            at.error(f"@verbatim is not a Leo directive: {p.h}")
    elif kind == at.miscDirective:
        # Fix bug 583878: Leo should warn about @comment/@delims clashes.
        if g.match_word(s, i, '@comment'):
            status.at_comment_seen = True
        elif g.match_word(s, i, '@delims'):
            status.at_delims_seen = True
        if (
            status.at_comment_seen and
            status.at_delims_seen and not
            status.at_warning_given
        ):
            status.at_warning_given = True
            at.error(f"@comment and @delims in node {p.h}")
        at.putDirective(s, i, p)
    else:
        at.error(f"putBody: can not happen: unknown directive kind: {kind}")
</t>
<t tx="ekr.20041005105605.174">def putCodeLine(self, s, i):
    '''Put a normal code line.'''
    at = self
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s, i)
    if g.match(s, k, self.startSentinelComment + '@'):
        self.putSentinel('@verbatim')
    j = g.skip_line(s, i)
    line = s[i:j]
    # Don't put any whitespace in otherwise blank lines.
    if len(line) &gt; 1:  # Preserve *anything* the user puts on the line!!!
        if not at.raw:
            at.putIndent(at.indent, line)
        if line[-1:] == '\n':
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    elif line:
        at.os(line)  # Bug fix: 2013/09/16
    else:
        g.trace('Can not happen: completely empty line')
</t>
<t tx="ekr.20041005105605.204">def os(self, s):
    """
    Append a string to at.outputList.

    All output produced by leoAtFile module goes here.
    """
    at = self
    if s.startswith(self.underindentEscapeString):
        try:
            junk, s = at.parseUnderindentTag(s)
        except Exception:
            at.exception("exception writing:" + s)
            return
    s = g.toUnicode(s, at.encoding)
    at.outputList.append(s)
</t>
<t tx="ekr.20041030092101">@Notes by EKR: The dyna plugin is a remarkable body of work by 'e'. Have fun with it.

You may download the latest version at: http: // rclick.netfirms.com / dyna_menu.py.html
</t>
<t tx="ekr.20041114102139">@nocolor

Comments
--------

Most of the comments in the style guide are comments*about*the style guide.
You would replace these comments with your own, or eliminate them entirely in
your plugin.

Docstrings
----------

Several plugins show the docstring, so please take care to do a good job of
describing what the plugin does and how to use it.

Directives
----------

Please put the following at the end of the plugin's top-level node.

    @language python
    @tabwidth-4

Imports
-------

-Do* not*assume that modules like Qt are always available.

-Do* not*use from m import*

-Your code should test whether modules have been imported only if those modules
  may not be available on all platforms.

-To fail gracefully if the Qt gui is not in effect, put the following at
  the top level::

      g.assertUi('qt')

Exceptions
----------

It is usually best* not*to catch exceptions in plugins: doHook catches all
exceptions and disables further calls to plugins.

If a plugin catches exceptions during startup it should do either raise the
exception again or provide an init function at the top level that reports the
failure by returning False.

Use separate nodes
------------------

**Please**define each class, function or method in a separate node!To
make this work, just put@others in the root of your plugin as shown.Note
that@others may be nested, as shown in class myClass.
</t>
<t tx="ekr.20041119204700.1">def traverse(self):
    """Traverse the entire settings tree."""
    c = self.c
    self.settingsDict = g.TypedDict(
        name=f"settingsDict for {c.shortFileName()}",
        keyType=type('settingName'),
        valType=g.GeneralSetting)
    self.shortcutsDict = g.TypedDict(  # was TypedDictOfLists.
        name=f"shortcutsDict for {c.shortFileName()}",
        keyType=str,
        valType=g.BindingInfo)
    # This must be called after the outline has been inited.
    p = c.config.settingsRoot()
    if not p:
        # c.rootPosition() doesn't exist yet.
        # This is not an error.
        return self.shortcutsDict, self.settingsDict
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        if result == "skip":
            # g.warning('skipping settings in',p.h)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    # Return the raw dict, unmerged.
    return self.shortcutsDict, self.settingsDict
</t>
<t tx="ekr.20041120074536">def settingsRoot(self):
    """Return the position of the @settings tree."""
    c = self.c
    for p in c.all_unique_positions():
        # #1792: Allow comments after @settings.
        if g.match_word(p.h.rstrip(), 0, "@settings"):
            return p.copy()
    return None
</t>
<t tx="ekr.20050111122605"></t>
<t tx="ekr.20050125203937"># Fix #653: undoer problem: be wary of the ternary operator here.
old_start = old_end = new_start = new_end = 0
if oldSel is not None:
    old_start, old_end = oldSel
if newSel is not None:
    new_start, new_end = newSel
if u.prevSel is None:
    prev_start, prev_end = 0, 0
else:
    prev_start, prev_end = u.prevSel
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    # 2011/04/01: Patch by Sam Hartsfield
    old_row, old_col = g.convertPythonIndexToRowCol(
        oldText, old_start)
    new_row, new_col = g.convertPythonIndexToRowCol(
        newText, new_start)
    prev_row, prev_col = g.convertPythonIndexToRowCol(
        oldText, prev_start)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col - new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        # py-lint: disable=W0511
        # W0511:1362: TODO
        # TODO this is not true, we might as well just have entered a
        # char at the beginning of an existing line
        pass  # We have just inserted a line.
    else:
        # 2011/04/01: Patch by Sam Hartsfield
        old_s = old_lines[old_row]
        new_s = new_lines[new_row]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col - 1 &gt;= len(old_s) or new_col - 1 &gt;= len(new_s):
            newBead = True
        else:
            old_ch = old_s[old_col - 1]
            new_ch = new_s[new_col - 1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines, old_row, old_col, old_ch,
                new_lines, new_row, new_col, new_ch,
                prev_row, prev_col)
</t>
<t tx="ekr.20050125220613"># Set newBead to True if undo_type is not 'Typing' so that commands that
# get treated like typing (by onBodyChanged) don't get lumped
# with 'real' typing.
@c
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True  # We can't share the previous node.
elif granularity == 'char':
    newBead = True  # This was the old way.
elif granularity == 'node':
    newBead = False  # Always replace previous bead.
else:
    assert granularity in ('line', 'word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading', 0) != u.leading or
        old_d.get('trailing', 0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            &lt;&lt; set newBead if the change does not continue a word &gt;&gt;
        except Exception:
            g.error('Unexpected exception...')
            g.es_exception()
            newBead = True
</t>
<t tx="ekr.20050126081529">def recognizeStartOfTypingWord(self,
    old_lines, old_row, old_col, old_ch,
    new_lines, new_row, new_col, new_ch,
    prev_row, prev_col
):
    """
    A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.

    u.doTyping calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.

    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.

    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.
    """
    # Start a word if new_ch begins whitespace + word
    new_word_started = not old_ch.isspace() and new_ch.isspace()
    # Start a word if the cursor has been moved since the last change
    moved_cursor = new_row != prev_row or new_col != prev_col + 1
    return new_word_started or moved_cursor
</t>
<t tx="ekr.20050130120433">'''A plugin to test import problems.'''

from leo.core import leoGlobals as g

def onStart(tag,keywords):
    pass

# pylint: disable=unused-import
try:
    import xyzzy
except ImportError:
    g.cantImport('xyzzy',pluginName='failed_import')

def init():
    '''Return True if the plugin has loaded successfully.'''
    g.registerHandler("start2", onStart)
    g.plugin_signon(__name__)
    return True
</t>
<t tx="ekr.20050303051035">@nocolor-node

The following nodes show recommended style when writing plugins.</t>
<t tx="ekr.20050303051035.2">'''
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
'''
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4
</t>
<t tx="ekr.20050303051035.5">from leo.core import leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050303051101">def init():
    '''Return True if the plugin has loaded successfully.'''
    ok=g.app.gui.guiName() in('qt','qttabs')
    if ok:
        if 1: # Use this if you want to create the commander class before the frame is fully created.
            g.registerHandler('before-create-leo-frame',onCreate)
        else: # Use this if you want to create the commander class after the frame is fully created.
            g.registerHandler('after-create-leo-frame',onCreate)
    return ok</t>
<t tx="ekr.20050303051150">def onCreate(tag, keys):

    c=keys.get('c')
    if not c: return

    thePluginController=pluginController(c)
</t>
<t tx="ekr.20050303051222">class pluginController:

    @others</t>
<t tx="ekr.20050303051222.1">def __init__(self,c):

    self.c=c
    # Warning: hook handlers must use keywords.get('c'), NOT self.c.
</t>
<t tx="ekr.20050306071540">def onStart2(tag, keywords):

    """
    Showing how to define a global hook that affects all commanders.
    """

    log=c.frame.log.__class__

    # Replace frame.put with newPut (not shown).
    g.funcToMethod(newPut,log,"put")</t>
<t tx="ekr.20050306071629">'''
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
'''
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4</t>
<t tx="ekr.20050306071629.1">'''This docstring should be a clear, concise description of
what the plugin does and how to use it.
'''
</t>
<t tx="ekr.20050306071629.3">from leo.core import leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050306071629.4">def init():
    '''Return True if the plugin has loaded successfully.'''
    ok=True # This might depend on imports, etc.
    if ok:
        g.registerHandler('start2',onStart2)
    return ok</t>
<t tx="ekr.20050306081349"></t>
<t tx="ekr.20050315133212.2">def beforeChangeNodeContents(self, p):
    """Return data that gets passed to afterChangeNode."""
    c, u = self.c, self
    w = c.frame.body.wrapper
    bunch = u.createCommonBunch(p)
    bunch.oldBody = p.b
    bunch.oldHead = p.h
    # #1413: Always restore yScroll if possible.
    bunch.oldYScroll = w.getYScrollPosition() if w else 0
    return bunch
</t>
<t tx="ekr.20050315134017.2">def afterChangeNodeContents(self, p, command, bunch):
    """Create an undo node using d created by beforeChangeNode."""
    u = self
    c = self.c
    w = c.frame.body.wrapper
    if u.redoing or u.undoing:
        return
    # Set the type &amp; helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents
    bunch.inHead = False  # 2013/08/26
    bunch.newBody = p.b
    bunch.newHead = p.h
    bunch.newMarked = p.isMarked()
    # Bug fix 2017/11/12: don't use ternary operator.
    if w:
        bunch.newSel = w.getSelectionRange()
    else:
        bunch.newSel = 0, 0
    bunch.newYScroll = w.getYScrollPosition() if w else 0
    u.pushBead(bunch)
</t>
<t tx="ekr.20050408100042">def undoRedoTree(self, p, new_data, old_data):
    """Replace p and its subtree using old_data during undo."""
    # Same as undoReplace except uses g.Bunch.
    u = self; c = u.c
    if new_data is None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch
    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p, p.b)  # This is not a do-nothing.
    return p  # Nothing really changes.
</t>
<t tx="ekr.20050412084532">def redoInsertNode(self):
    u = self; c = u.c; cc = c.chapterController
    if cc:
        cc.selectChapterByName('main')
    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent, 0)
    else:
        u.newP._linkAsRoot()
    if u.pasteAsClone:
        for bunch in u.afterTree:
            v = bunch.v
            if u.newP.v == v:
                u.newP.b = bunch.body
                u.newP.h = bunch.head
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
    u.newP.setDirty()
    c.selectPosition(u.newP)
</t>
<t tx="ekr.20050412085112">def undoInsertNode(self):
    u = self; c = u.c; cc = c.chapterController
    if cc: cc.selectChapterByName('main')
    u.newP.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.newP)
    c.deleteOutline()
        # Bug fix: 2016/03/30.
        # This always selects the proper new position.
        # c.selectPosition(u.p)
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            v = bunch.v
            if u.p.v == v:
                u.p.b = bunch.body
                u.p.h = bunch.head
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
</t>
<t tx="ekr.20050721093241">@nobeautify
@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1.

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.

- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20050804081215">@nocolor
@
http://sourceforge.net/forum/message.php?msg_id=3276408

Leo has great potential for smoothing some of the bumps
outside of learning the details of the markup.
Here is my wish list;

(done) - Section level handling.
  - one of the problems with using rst comes when a new
    section level is inserted into a document. Leo can
    take care of this effortlessly, providing a correct
   underline character for each section heading.

    Other than the section management, I want Leo to
    assume that I'm writing rst, and should be rendered
    as-is. If I want to include some pretty Python, I put
    it in a ..  python-code:: block (or some such)

    On top of this base could be built special case
    handling.

- Assist in viewing rendered output
  - easy access to the command to render a tree to  html.
  - I would like an option which automatically inserted
    a @url node which pointed to the rendered file, or
    some other trick to make switching between source
    and output painless.

- Assist in working with the CSS file
  - a CSS file is now required by docutils. A @setting
    could specify the file. I would like some kind of
    sugar which made it easy to edit the CSS file, maybe
    an option to create a @file node automatically,
    like the @url node above. Again, I want to be able
    to effortlessly edit the CSS and see the results.

- The third file of interest when writing rst is the config
   file which controls many behaviours of the renderer.
   Again, some intelligence which located it, made it
   convenient to edit it, maybe even linked to
   documentation for it, would be very nice.

(done) - I would like a setting which would save the file with the
  rst markup and make it easy to examine and edit.

- On the someday/maybe list would be a @publish
  feature, which configured a directory to ftp the rendered
  file to.
</t>
<t tx="ekr.20050805162550">&lt;&lt; docstring &gt;&gt;

# Original rst code by Josef Dalcolmo:
# contributed under the same licensed as Leo.py itself.
# rst3.py based on rst2.py v2.4.
# This has largely been superceded by leo.core.leoRst.

&lt;&lt; imports &gt;&gt;
&lt;&lt; to do &gt;&gt;

bwm_file = None
if 0:
    bwm_file = open("bwm_file", "w")
controllers = {} # For use by @button rst3 code.

@others
</t>
<t tx="ekr.20050805162550.1">''' Creates output files from Leo outlines containing rST (reStructuredText)
markup. This plugin has been superseded by Leo's core rst3 command.

This is a powerful plugin with many options.  The full documentation is at:
http://leoeditor.com//rstplugin3.html

The rst3 plugin adds the Write Restructured Text command to Leo's Edit menu. This
command searches the selected outline looking for **rst root nodes** whose
headline have the form @rst &lt;filename&gt;. The plugin then creates the named file
in various ways depending which rst3 options are in effect.

By default, the rst3 plugin creates rST headings automatically from outlines, so
the higher-level nodes in the outline correspond to higher-level sections in the
output. Creating rST headings automatically eliminates one of the most tedious
chores associated with rST markup.

To use this plugin effectively, Python's docutils module must be installed. The
rst3 plugin will use the SilverCity syntax coloring package if it installed.

This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.

rst3 options control most aspects of this plugin's operations. You can set
options in @settings trees, in headlines and in body text. There are too many
details to discuss here. For full details see:
http://leoeditor.com//rstplugin3.html

'''
</t>
<t tx="ekr.20050805162550.10">def __init__ (self,c):

    global SilverCity
    self.c = c
    &lt;&lt; init ivars &gt;&gt;

    self.createDefaultOptionsDict()
    self.initOptionsFromSettings() # Still needed.
    self.initHeadlineCommands() # Only needs to be done once.
    self.initSingleNodeOptions()
    self.addMenu()
</t>
<t tx="ekr.20050805162550.11">self.silverCityWarningGiven = False

# The options dictionary.
self.optionsDict = {}
self.option_prefix = '@rst-option'

# Formatting...
self.code_block_string = ''
self.node_counter = 0
self.toplevel = 0
self.topNode = None
self.use_alternate_code_block = SilverCity is None

# Http support...
self.nodeNumber = 0
# All nodes are numbered so that unique anchors can be generated.

self.http_map = {}
# Keys are named hyperlink targets.  Value are positions.
# The targets mark the beginning of the html code specific
# for this position.

self.anchor_map = {}
# Maps anchors (generated by this module) to positions

self.rst3_all = False
# Set to True by the button which processes all @rst trees.

# For writing.
self.defaultEncoding = 'utf-8'
self.leoDirectivesList = g.globalDirectiveList
self.encoding = self.defaultEncoding
self.ext = None # The file extension.
self.outputFileName = None # The name of the file being written.
self.outputFile = None # The open file being written.
self.path = '' # The path from any @path directive.
self.source = None # The written source as a string.
</t>
<t tx="ekr.20050805162550.12">def addMenu (self):

    c = self.c
    editMenu = c.frame.menu.getMenu('Edit')

    def rst3PluginCallback (event=None):
        self.processTopTree(c.p)

    c.k.registerCommand('write-restructured-text', rst3PluginCallback)
    table = (
        ("-",None,None),
        # ("Write Restructed Text","",rst3PluginCallback),
        '&amp;write-restructured-text',
    )
    c.frame.menu.createMenuEntries(editMenu, table)
</t>
<t tx="ekr.20050805162550.13">def initOptionsFromSettings (self):
    '''Init all options from settings.'''
    c = self.c
    d = self.defaultOptionsDict
    for key in sorted(d.keys()):
        for getter,kind in (
            (c.config.getBool,'@bool'),
            (c.config.getString,'@string'),
            (d.get,'default'),
        ):
            val = getter(key)
            if kind == 'default' or val is not None:
                self.setOption(key,val,'initOptionsFromSettings')
                break
    # Special case.
    if self.getOption('http_server_support') and not mod_http:
        g.error('No http_server_support: can not import mod_http plugin')
        self.setOption('http_server_support',False,tag='initOptionsFromSettings')
</t>
<t tx="ekr.20050805162550.16">def encode (self,s):

    return g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
</t>
<t tx="ekr.20050805162550.17">def processTree(self,p,ext,toString,justOneFile):

    '''Process all @rst nodes in a tree.'''

    self.preprocessTree(p)
    found = False ; self.stringOutput = ''
    p = p.copy() ; after= p.nodeAfterTree()
    while p and p != after:
        h = p.h.strip()
        if g.match_word(h,0,"@rst"):
            self.outputFileName = h[4:].strip()
            if (
                (self.outputFileName and self.outputFileName[0] != '-') or
                (toString and not self.outputFileName)
            ):
                found = True
                self.toplevel = p.level() # Define toplevel separately for each rst file.
                if toString:
                    self.ext = ext
                else:
                    self.ext = g.os_path_splitext(self.outputFileName)[1].lower()
                if self.ext in ('.htm','.html','.tex','.pdf'):
                    ok = self.writeSpecialTree(p,toString=toString,justOneFile=justOneFile)
                else:
                    ok = self.writeNormalTree(p,toString=toString)
                self.scanAllOptions(p) # Restore the top-level verbose setting.
                if toString:
                    return p.copy(),self.stringOutput
                else:
                    if ok: self.report(self.outputFileName)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else: p.moveToThreadNext()
    if not found:
        g.warning('No @rst nodes in selected tree')
    return None,None
</t>
<t tx="ekr.20050805162550.19">def underline (self,s,p):
    '''Return the underlining string to be used at the given level for string s.'''
    u = self.getOption('underline_characters') #  '''#=+*^~"'`-:&gt;&lt;_'''
    level = max(0,p.level()-self.toplevel)
    level = min(level+1,len(u)-1) # Reserve the first character for explicit titles.
    ch = u [level]
    n = max(4,len(s))
    return ch * n + '\n'
</t>
<t tx="ekr.20050805162550.2">from leo.core import leoGlobals as g

import html.parser as HTMLParser
import os
import pprint
import io
StringIO = io.StringIO
import sys

# Make sure the present directory in in sys.path.
dir,junk = os.path.split(__file__)
if dir not in sys.path: sys.path.append(dir)

try:
    from leo.plugins import mod_http
except ImportError:
    mod_http = None

try:
    import docutils
    import docutils.parsers.rst
    import docutils.core
    import docutils.io
except ImportError:
    # This message given in init.
    # g.pr('rst3 plugin: can not import docutils')
    docutils = None

try:
    import SilverCity
except ImportError:
    if '--silent' not in sys.argv and not g.unitTesting and not g.app.batchMode:
        g.pr('rst3 plugin: SilverCity not loaded')
    SilverCity = None
</t>
<t tx="ekr.20050805162550.20">def report (self,name):

    if self.getOption('verbose'):

        name = g.os_path_finalize(name)

        g.blue('wrote: %s' % (name))
</t>
<t tx="ekr.20050805162550.21">def writeSpecialTree (self,p,toString,justOneFile):

    c = self.c
    isHtml = self.ext in ('.html','.htm')
    if isHtml and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            g.es('SilverCity not present so no syntax highlighting')

    self.initWrite(p)
        # was ,encoding=g.choose(isHtml,'utf-8','iso-8859-1'))
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if not toString:
        # Compute this here for use by intermediate file.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)

        # Create the directory if it doesn't exist.
        theDir, junk = g.os_path_split(self.outputFileName)
        theDir = g.os_path_finalize(theDir) # #1341.
        if not g.os_path_exists(theDir):
            ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
            if not ok:
                g.error('did not create:',theDir)
                return False

        # if not os.access(theDir,os.F_OK):
            # os.mkdir(theDir)

        if self.getOption('write_intermediate_file'):
            name = self.outputFileName + '.txt'
            f = open(name,'w')
            f.write(self.source)
            f.close()
            self.report(name)

    try:
        output = self.writeToDocutils(self.source)
        ok = True
    except Exception:
        g.pr('Exception in docutils')
        g.es_exception()
        ok = False

    if ok:
        if isHtml:
            import re
            idxTitle = output.find('&lt;title&gt;&lt;/title&gt;')
            if idxTitle &gt; -1:
                m = re.search('&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;', output)
                if not m:
                    m = re.search('&lt;h1&gt;&lt;[^&gt;]+&gt;([^&lt;]*)&lt;/a&gt;&lt;/h1&gt;', output)
                if m:
                    output = output.replace(
                        '&lt;title&gt;&lt;/title&gt;',
                        '&lt;title&gt;%s&lt;/title&gt;' % m.group(1)
                    )


        if toString:
            self.stringOutput = output
        else:
            # Write the file to the directory containing the .leo file.
            f = open(self.outputFileName,'w')
            f.write(output)
            f.close()
            self.http_endTree(self.outputFileName, p, justOneFile=justOneFile)

    return ok
</t>
<t tx="ekr.20050805162550.23">def writeTree(self,p):
    '''Write p's tree to self.outputFile.'''
    self.scanAllOptions(p)
    if self.getOption('generate_rst'):
        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % self.outputFileName))
    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.writeNode(p)
</t>
<t tx="ekr.20050805162550.26">def writeHeadline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''

    docOnly             =  self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.writeHeadlineHelper(p)
</t>
<t tx="ekr.20050805162550.30">def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
</t>
<t tx="ekr.20050805162550.33"></t>
<t tx="ekr.20050805162550.34"># Was http_support_main

def http_endTree (self,filename,p,justOneFile):

    '''Do end-of-tree processing to support the http plugin.'''

    if (
        self.getOption('http_server_support') and
        self.getOption('generate_rst')
    ):
        self.set_initial_http_attributes(filename)
        self.find_anchors(p)
        if justOneFile:
            self.relocate_references(p.self_and_subtree)

        g.blue('html updated for http plugin')

        if self.getOption('clear_http_attributes'):
            g.es_print("http attributes cleared")
</t>
<t tx="ekr.20050805162550.35">def http_attribute_iter (self, p):
    """
    Iterator for all the nodes which have html code.
    Look at the descendents of p.
    Used for relocation.
    """

    for p1 in p.self_and_subtree():
        attr = mod_http.get_http_attribute(p1)
        if attr:
            yield (p1.copy(),attr)
</t>
<t tx="ekr.20050805162550.36">def set_initial_http_attributes (self,filename):

    f = open(filename)
    parser = htmlParserClass(self)

    for line in f.readlines():
        parser.feed(line)

    f.close()
</t>
<t tx="ekr.20050805162550.37">@ Relocate references here if we are only running for one file.

Otherwise we must postpone the relocation until we have processed all files.
@c

def relocate_references (self, iterator_generator):

    for p in iterator_generator():
        attr = mod_http.get_http_attribute(p)
        if not attr:
            continue
        if bwm_file:
            print &gt;&gt; bwm_file
            print &gt;&gt; bwm_file, "relocate_references(1): Position, attr:"
            pprint.pprint((p, attr), bwm_file)
        # http_lines = attr [3:]
        parser = link_htmlparserClass(self,p)
        for line in attr [3:]:
            try:
                parser.feed(line)
            except Exception:
                line = ''.join([ch for ch in line if ord(ch) &lt;= 127])
                parser.feed(line)
        replacements = parser.get_replacements()
        replacements.reverse()
        if not replacements:
            continue
        if bwm_file:
            print &gt;&gt; bwm_file, "relocate_references(2): Replacements:"
            pprint.pprint(replacements, bwm_file)
        for line, column, href, href_file, http_node_ref in replacements:
            if bwm_file:
                print &gt;&gt; bwm_file, ( "relocate_references(3): line:",
                    line, "Column:", column, "href:", href,
                    "href_file:", href_file, "http_node_ref:", http_node_ref)
            marker_parts = href.split("#")
            if len(marker_parts) == 2:
                marker = marker_parts [1]
                replacement = "%s#%s" % (http_node_ref,marker)
                try:
                    attr [line + 2] = attr [line + 2].replace(
                        'href="%s"' % href,'href="%s"' % replacement)
                except Exception:
                    g.es("Skipped ", attr[line + 2])
            else:
                # filename = marker_parts [0]
                try:
                    attr [line + 2] = attr [line + 2].replace(
                        'href="%s"' % href,
                        'href="%s"' % http_node_ref)
                except Exception:
                    g.es("Skipped", attr[line+2])
</t>
<t tx="ekr.20050805162550.38">def find_anchors (self, p):

    '''Find the anchors in all the nodes.'''

    for p1, attrs in self.http_attribute_iter(p):
        html = mod_http.reconstruct_html_from_attrs(attrs)
        parser = anchor_htmlParserClass(self, p1)
        for line in html:
            try:
                parser.feed(line)
            except Exception:
                line = ''.join([ch for ch in line if ord(ch) &lt;= 127])
                # filter out non-ascii characters.
                # bwm: not quite sure what's going on here.
                parser.feed(line)
</t>
<t tx="ekr.20050805162550.39">@
The parser classes are used to construct the html code for nodes. The algorithm has two phases:
    1. In the first phase, the html code for each node is identified.
    2. The second phase identifies all links and checks if these links need to be modified.
The first phase of scanning is done by the anchor_hmlParserClass. The second phase of this algorithm is
done with the link_htmlParserClass.
@code

&lt;&lt; class linkAnchorParserClass &gt;&gt;

@others
</t>
<t tx="ekr.20050805162550.4"></t>
<t tx="ekr.20050805162550.40">class linkAnchorParserClass (HTMLParser.HTMLParser):

    '''
    A class to recognize anchors and links in HTML documents.
    A special marker is the "node_marker" which demarkates the border between
    node and the next.
    '''

    @others
</t>
<t tx="ekr.20050805162550.41">def __init__(self,rst):

    super().__init__()
    self.rst = rst

    # Set ivars from options.  This works only if we don't change nodes!
    self.node_begin_marker      = rst.getOption('node_begin_marker')
    self.clear_http_attributes  = rst.getOption('clear_http_attributes')
    self.current_file = rst.outputFileName
</t>
<t tx="ekr.20050805162550.42">def is_anchor(self, tag, attrs):
    """
    Check if the current tag is an anchor.
    Returns *all* anchors.
    Works with docutils 0.4
    """

    if tag == 'a':
        return True

    if self.is_node_marker(attrs):
        return True
    return tag == "span"
</t>
<t tx="ekr.20050805162550.43">def is_link(self, tag, attrs):
    '''
    Return True if tag, attrs is represents a link.
    '''

    if tag != 'a':
        return False

    result = 'href' in dict(attrs)
    return result
</t>
<t tx="ekr.20050805162550.44">class htmlParserClass (linkAnchorParserClass):

    '''
    The responsibility of the html parser is:
        1. Find out which html code belongs to which node.
        2. Keep a stack of open tags which apply to the current node.
        3. Keep a list of tags which should be included in the nodes, even
           though they might be closed.
           The &lt;style&gt; tag is one example of that.

    Later, we have to relocate inter-file links: if a reference to another location
    is in a file, we must change the link.

    '''

    @others
</t>
<t tx="ekr.20050805162550.45">def __init__ (self,rst):

    super().__init__(rst) # Init the base class.

    self.stack = None
    # The stack contains lists of the form:
        # [text1, text2, previous].
        # text1 is the opening tag
        # text2 is the closing tag
        # previous points to the previous stack element

    self.node_marker_stack = []
    # self.node_marker_stack.pop() returns True for a closing
    # tag if the opening tag identified an anchor belonging to a vnode.

    self.node_code = []
        # Accumulated html code.
        # Once the hmtl code is assigned a vnode, it is deleted here.

    self.deleted_lines = 0 # Number of lines deleted in self.node_code

    self.endpos_pending = False
    # Do not include self.node_code[0:self.endpos_pending] in the html code.

    self.last_position = None
    # Last position; we must attach html code to this node.

    self.last_marker = None
</t>
<t tx="ekr.20050805162550.46">def handle_starttag (self,tag,attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If it is an anchor, we check if this anchor marks the beginning of a new
       node
    3. If a new node begins, then we might have to store html code for the previous
       node.
    4. In any case, put the new tag on the stack.
    '''
    is_node_marker = False
    if self.is_anchor(tag,attrs) and self.is_node_marker(attrs):
        is_node_marker = self.is_node_marker(attrs)
        line, column = self.getpos()
        if self.last_position:
            lines = self.node_code [:]
            lines [0] = lines [0] [self.startpos:]
            del lines [line-self.deleted_lines-1:]
            mod_http.get_http_attribute(self.last_position).extend(lines)
            &lt;&lt; trace the unknownAttribute &gt;&gt;
        if self.deleted_lines &lt; line-1:
            del self.node_code [: line-1-self.deleted_lines]
            self.deleted_lines = line-1
            self.endpos_pending = True
    starttag = self.get_starttag_text()
    self.stack = [starttag, None, self.stack]
    self.node_marker_stack.append(is_node_marker)
</t>
<t tx="ekr.20050805162550.47">def handle_endtag(self, tag):
    '''
    1. Set the second element of the current top of stack.
    2. If this is the end tag for an anchor for a node,
       store the current stack for that node.
    '''
    self.stack[1] = "&lt;/" + tag + "&gt;"

    if self.endpos_pending:
        line, column = self.getpos()
        self.startpos = self.node_code[0].find("&gt;", column) + 1
        self.endpos_pending = False

    is_node_marker = self.node_marker_stack.pop()

    if is_node_marker and not self.clear_http_attributes:
        self.last_position = self.rst.http_map[is_node_marker]
        if is_node_marker != self.last_marker:
            if bwm_file: print &gt;&gt; bwm_file, "Handle endtag:", is_node_marker, self.stack
            mod_http.set_http_attribute(self.rst.http_map[is_node_marker], self.stack)
            self.last_marker = is_node_marker
            #bwm: last_marker is not needed?

    self.stack = self.stack[2]
</t>
<t tx="ekr.20050805162550.49">def feed(self, line):

    self.node_code.append(line)

    HTMLParser.HTMLParser.feed(self, line) # Call the base class's feed().
</t>
<t tx="ekr.20050805162550.5">def init ():
    '''Return True if the plugin has loaded successfully.'''
    ok = docutils is not None # Ok for unit testing.
    if ok:
        g.registerHandler('after-create-leo-frame', onCreate)
        g.plugin_signon(__name__)
    else:
        g.error('rst3 plugin not loaded: can not load docutils')
    return ok
</t>
<t tx="ekr.20050805162550.50">class anchor_htmlParserClass (linkAnchorParserClass):

    '''
    This htmlparser does the first step of relocating: finding all the anchors within the html nodes.

    Each anchor is mapped to a tuple:
        (current_file, position).

    Filters out markers which mark the beginning of the html code for a node.
    '''

    @others
</t>
<t tx="ekr.20050805162550.51">def __init__ (self,rst,p):

    super().__init__(rst)

    self.p = p.copy()
    self.anchor_map = rst.anchor_map
</t>
<t tx="ekr.20050805162550.52">def handle_starttag(self, tag, attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If the current tag is an anchor, update the mapping;
         anchor -&gt; (filename, p)
    '''
    if not self.is_anchor(tag, attrs):
        return

    if self.current_file not in self.anchor_map:
        self.anchor_map[self.current_file] = (self.current_file, self.p)
        simple_name = g.os_path_split(self.current_file)[1]
        self.anchor_map[simple_name] = self.anchor_map[self.current_file]
        if bwm_file: print &gt;&gt; bwm_file, (
            "anchor(1): current_file:", self.current_file,
            "position:", self.p,
            "Simple name:", simple_name,
        )
        # Not sure what to do here, exactly. Do I need to manipulate
        # the pathname?

    for name, value in attrs:
        if name == 'name' or tag == 'span' and name == 'id':
            if not value.startswith(self.node_begin_marker):
                if bwm_file: print &gt;&gt; bwm_file, "anchor(2):", value, self.p
                self.anchor_map[value] = (self.current_file, self.p.copy())
</t>
<t tx="ekr.20050805162550.53">class link_htmlparserClass (linkAnchorParserClass):

    '''This html parser does the second step of relocating links:
    1. It scans the html code for links.
    2. If there is a link which links to a previously processed file
       then this link is changed so that it now refers to the node.
    '''

    @others
</t>
<t tx="ekr.20050805162550.54">def __init__ (self,rst,p):

    super().__init__(rst)

    self.p = p.copy()
    self.anchor_map = rst.anchor_map
    self.replacements = []
</t>
<t tx="ekr.20050805162550.55">def handle_starttag(self, tag, attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If the current tag is an anchor, update the mapping;
         anchor -&gt; p
        Update the list of replacements for the document.
    '''
    if bwm_file: print &gt;&gt; bwm_file, "Is link?", tag, attrs
    if not self.is_link(tag, attrs):
        return

    marker = self.node_begin_marker
    for name, value in attrs:
        if name == 'href':
            href = value
            href_parts = href.split("#")
            if len(href_parts) == 1:
                href_a = href_parts[0]
            else:
                href_a = href_parts[1]
            if bwm_file: print &gt;&gt; bwm_file, "link(1):", name, value, href_a
            if not href_a.startswith(marker):
                if href_a in self.anchor_map:
                    href_file, href_node = self.anchor_map[href_a]
                    http_node_ref = mod_http.node_reference(href_node)
                    line, column = self.getpos()
                    if bwm_file: print &gt;&gt; bwm_file, "link(2):", line, column, href, href_file, http_node_ref
                    self.replacements.append((line, column, href, href_file, http_node_ref))
</t>
<t tx="ekr.20050805162550.56">def get_replacements(self):

    return self.replacements
</t>
<t tx="ekr.20050805162550.6">def onCreate(tag, keywords):

    c = keywords.get('new_c') or keywords.get('c')
    if c:
        global controllers
        controllers[c] = rstClass(c)
        # Warning: Do not return anything but None here!
        # Doing so suppresses the loading of other 'new' or 'open2' hooks!
</t>
<t tx="ekr.20050805162550.8">class rstClass:

    '''A class to write rst markup in Leo outlines.'''

@ This plugin optionally stores information for the http plugin.

Each node can have one additional attribute, with the name rst_http_attributename, which is a list.

The first three elements are stack of tags, the rest is html code.

[&lt;tag n start&gt;, &lt;tag n end&gt;, &lt;other stack elements&gt;, &lt;html line 1&gt;, &lt;html line 2&gt;, ...]

&lt;other stack elements has the same structure:
    [&lt;tag n-1 start&gt;, &lt;tag n-1 end&gt;, &lt;other stack elements&gt;]
@c

    @others
</t>
<t tx="ekr.20050805162550.9"></t>
<t tx="ekr.20050806101253">def code_block (name,arguments,options,content,lineno,content_offset,block_text,state,state_machine):

    '''Implement the code-block directive for docutils.'''

    try:
        language = arguments [0]
        # See http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252170
        module = SilverCity and getattr(SilverCity,language)
        generator = module and getattr(module,language+"HTMLGenerator")
        if generator:
            io = StringIO()
            generator().generate_html(io,'\n'.join(content))
            html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n' % io.getvalue()
        else:
            html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n' % '&lt;br&gt;\n'.join(content)
        raw = docutils.nodes.raw('',html,format='html')
        return [raw]
    except Exception: # Return html as shown.  Lines are separated by &lt;br&gt; elements.
        g.es_trace('exception in rst3:code_block()')
        g.es_exception()
        return [None]

# See http://docutils.sourceforge.net/spec/howto/rst-directives.html
code_block.arguments = (
    1, # Number of required arguments.
    0, # Number of optional arguments.
    0) # True if final argument may contain whitespace.

# A mapping from option name to conversion function.
if docutils:
    code_block.options = {
        'language':
        docutils.parsers.rst.directives.unchanged # Return the text argument, unchanged.
    }
    code_block.content = 1 # True if content is allowed.

    # Register the directive with docutils.
    docutils.parsers.rst.directives.register_directive('code-block',code_block)
else:
    code_block.options = {}

</t>
<t tx="ekr.20050806162146">@nocolor
@

- Specify option for the spelling of special doc parts.
    - The present code assumes to much about these commands.
- Warn if option gets set twice in same vnode.

Later or never:
    - show_context option.
    - encoding option: can override @encoding directives
    - Support docutils config files.

@c

@others
</t>
<t tx="ekr.20050807120331.1">def preprocessTree (self,root):

    self.tnodeOptionDict = {}

    # Bug fix 12/4/05: must preprocess parents too.
    for p in root.parents():
        self.preprocessNode(p)

    for p in root.self_and_subtree():
        self.preprocessNode(p)

    if 0:
        g.trace(root.h)
        for key in self.tnodeOptionDict.keys():
            g.trace(key)
            g.printDict(self.tnodeOptionDict.get(key))
</t>
<t tx="ekr.20050807120331.2">def scanNodeForOptions (self,p):
    '''
    Return a dictionary containing all the option-name:value entries in p.

    Such entries may arise from @rst-option or @rst-options in the headline,
    or from @ @rst-options doc parts.
    '''
    d = self.scanHeadlineForOptions(p)
    d2 = self.scanForOptionDocParts(p,p.b)
    # A fine point: body options over-ride headline options.
    d.update(d2)
    return d
</t>
<t tx="ekr.20050808064245">def createDefaultOptionsDict(self):

    # Warning: changing the names of options changes the names of the corresponding ivars.

    self.defaultOptionsDict = {
        # Http options...
        'rst3_clear_http_attributes':   False,
        'rst3_http_server_support':     False,
        'rst3_http_attributename':      'rst_http_attribute',
        'rst3_node_begin_marker':       'http-node-marker-',
        # Path options...
        'rst3_default_path': None, # New in Leo 4.4a4 # Bug fix: must be None, not ''.
        'rst3_stylesheet_name': 'default.css',
        'rst3_stylesheet_path': None, # Bug fix: must be None, not ''.
        'rst3_publish_argv_for_missing_stylesheets': None,
        # Global options...
        'rst3_code_block_string': '',
        'rst3_number_code_lines': True,
        'rst3_underline_characters': '''#=+*^~"'`-:&gt;&lt;_''',
        'rst3_verbose':True,
        'rst3_write_intermediate_file': False, # Used only if generate_rst is True.
        # Mode options...
        'rst3_code_mode': False, # True: generate rst markup from @code and @doc parts.
        'rst3_doc_only_mode': False, # True: generate only from @doc parts.
        'rst3_generate_rst': True, # True: generate rst markup.  False: generate plain text.
        'rst3_generate_rst_header_comment': True,
            # True generate header comment (requires generate_rst option)
        # Formatting options that apply to both code and rst modes....
        'rst3_show_headlines': True,  # Can be set by @rst-no-head headlines.
        'rst3_show_organizer_nodes': True,
        'rst3_show_options_nodes': False,
        'rst3_show_sections': True,
        'rst3_strip_at_file_prefixes': True,
        'rst3_show_doc_parts_in_rst_mode': True,
        # Formatting options that apply only to code mode.
        'rst3_show_doc_parts_as_paragraphs': False,
        'rst3_show_leo_directives': True,
        'rst3_show_markup_doc_parts': False,
        'rst3_show_options_doc_parts': False,
        # *Names* of headline commands...
        'rst3_code_prefix':             '@rst-code',     # Enter code mode.
        'rst3_doc_only_prefix':         '@rst-doc-only', # Enter doc-only mode.
        'rst3_rst_prefix':              '@rst',          # Enter rst mode.
        'rst3_ignore_headline_prefix':  '@rst-no-head',
        'rst3_ignore_headlines_prefix': '@rst-no-headlines',
        'rst3_ignore_node_prefix':      '@rst-ignore-node',
        'rst3_ignore_prefix':           '@rst-ignore',
        'rst3_ignore_tree_prefix':      '@rst-ignore-tree',
        'rst3_option_prefix':           '@rst-option',
        'rst3_options_prefix':          '@rst-options',
        'rst3_preformat_prefix':        '@rst-preformat',
        'rst3_show_headline_prefix':    '@rst-head',
    }
</t>
<t tx="ekr.20050808070018">def scanOption (self,p,s):
    '''
    Return { name:val } if s is a line of the form name=val.
    Otherwise return {}
    '''
    if not s.strip() or s.strip().startswith('..'):
        return {}
    data = self.parseOptionLine(s)
    if data:
        name,val = data
        fullName = 'rst3_' + self.munge(name)
        if fullName in self.defaultOptionsDict.keys():
            if   val.lower() == 'true': val = True
            elif val.lower() == 'false': val = False
            return { self.munge(name): val }
        else:
            g.error('ignoring unknown option: %s' % (name))
            return {}
    else:
        g.trace(repr(s))
        g.error('bad rst3 option in %s: %s' % (p.h,s))
        return {}
</t>
<t tx="ekr.20050808070018.1">def scanOptions (self,p,s):

    '''Return a dictionary containing all the options in s.'''

    d = {}

    for line in g.splitLines(s):
        d2 = self.scanOption(p,line)
        if d2: d.update(d2)

    return d
</t>
<t tx="ekr.20050808070018.2">def scanForOptionDocParts (self,p,s):

    '''Return a dictionary containing all options from @rst-options doc parts in p.
    Multiple @rst-options doc parts are allowed: this code aggregates all options.
    '''

    d = {} ; n = 0 ; lines = g.splitLines(s)
    while n &lt; len(lines):
        line = lines[n] ; n += 1
        if line.startswith('@'):
            i = g.skip_ws(line,1)
            for kind in ('@rst-options','@rst-option'):
                if g.match_word(line,i,kind):
                    # Allow options on the same line.
                    line = line[i+len(kind):]
                    d.update(self.scanOption(p,line))
                    # Add options until the end of the doc part.
                    while n &lt; len(lines):
                        line = lines[n] ; n += 1 ; found = False
                        for stop in ('@c','@code', '@'):
                            if g.match_word(line,0,stop):
                                found = True ; break
                        if found:
                            break
                        else:
                            d.update(self.scanOption(p,line))
                    break
    return d
</t>
<t tx="ekr.20050808072943">def munge (self,name):

    '''Convert an option name to the equivalent ivar name.'''

    i = 3 if name.startswith('rst') else 0

    while i &lt; len(name) and name[i].isdigit():
        i += 1

    if i &lt; len(name) and name[i] == '_':
        i += 1

    s = name[i:].lower()
    s = s.replace('-','_')

    return s
</t>
<t tx="ekr.20050808072943.1">def parseOptionLine (self,s):
    '''
    Parse a line containing name=val and return (name,value) or None.
    If no value is found, default to True.
    '''
    s = s.strip()
    if s.endswith(','): s = s[:-1]
    # Get name.  Names may contain '-' and '_'.
    i = g.skip_id(s,0,chars='-_')
    name = s [:i]
    if not name:
        return None,'False'
    j = g.skip_ws(s,i)
    if g.match(s,j,'='):
        val = s [j+1:].strip()
        return name,val
    else:
        return name,'True'
</t>
<t tx="ekr.20050808142313.28"># Once an option is seen, no other related options in ancestor nodes have any effect.

def scanAllOptions(self,p):

    '''Scan position p and p's ancestors looking for options,
    setting corresponding ivars.
    '''

    self.initOptionsFromSettings()
        # Must be done on every node.
    self.handleSingleNodeOptions(p)
    seen = self.singleNodeOptions[:]
        # Suppress inheritance of single-node options.
    for p in p.self_and_parents():
        d = self.tnodeOptionDict.get(p.v,{})
        for key in d.keys():
            ivar = self.munge(key)
            if ivar not in seen:
                seen.append(ivar)
                val = d.get(key)
                self.setOption(key,val,p.h)
    # self.dumpSettings()
    if self.rst3_all:
        self.setOption("generate_rst", True, "rst3_all")
        self.setOption("generate_rst_header_comment",True, "rst3_all")
        self.setOption("http_server_support", True, "rst3_all")
        self.setOption("write_intermediate_file", True, "rst3_all")
</t>
<t tx="ekr.20050809074827"></t>
<t tx="ekr.20050809075309">def initWrite (self,p):

    self.initOptionsFromSettings() # Still needed.

    # Set the encoding from any parent @encoding directive.
    # This can be overridden by @rst-option encoding=whatever.
    c = self.c
    d = c.scanAllDirectives(p)
    self.encoding = d.get('encoding') or self.defaultEncoding
    self.path = d.get('path') or ''
</t>
<t tx="ekr.20050809080031">def write (self,s):

    s = self.encode(s)

    self.outputFile.write(s)
</t>
<t tx="ekr.20050809080925">def writeNormalTree (self,p,toString=False):

    self.initWrite(p)

    # Always write to a string first.
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.stringOutput = self.outputFile.getvalue()

    # Copy to a file if requested.
    if not toString:
        # Comput the output file name *after* calling writeTree.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)
        self.outputFile = open(self.outputFileName,'w')
        self.outputFile.write(self.stringOutput)
        self.outputFile.close()

    return True
</t>
<t tx="ekr.20050809082854"></t>
<t tx="ekr.20050809082854.1">def writeToDocutils (self,s):
    '''
    Send s to docutils using the writer implied by self.ext and return the
    result.
    '''
    # openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }
    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()
    writer = None
    for ext,writer in (
        ('.html','html'),
        ('.htm','html'),
        ('.tex','latex'),
        ('.pdf','leo_pdf'),
    ):
        if self.ext == ext:
            break
    else:
        g.error('unknown docutils extension: %s' % (self.ext))
        return ''

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if g.os_path_exists(path):
        if self.ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.error('stylesheet not found: %s' % (path))
    else:
        g.error('stylesheet not found\n',path)
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        res = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer_name=writer,
                settings_overrides=overrides)
    except docutils.ApplicationError as error:
        g.es_print('Error (%s): %s' % (error.__class__.__name__, error))
    return res
</t>
<t tx="ekr.20050810083057">def writeNode (self,p):

    '''Format a node according to the options presently in effect.'''

    self.initCodeBlockString(p)
    self.scanAllOptions(p)

    if 0:
        g.trace('%24s code_mode %s' % (p.h,self.getOption('code_mode')))

    h = p.h.strip()

    if self.getOption('preformat_this_node'):
        self.http_addNodeMarker(p)
        self.writePreformat(p)
        p.moveToThreadNext()
    elif self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.writeHeadline(p)
        self.writeBody(p)
        p.moveToThreadNext()
</t>
<t tx="ekr.20050810083314"></t>
<t tx="ekr.20050810083856">def rstComment (self,s):

    return '.. %s' % s
</t>
<t tx="ekr.20050810103731">def handleSingleNodeOptions (self,p):

    '''Init the settings of single-node options from the tnodeOptionsDict.

    All such options default to False.'''

    d = self.tnodeOptionDict.get(p.v, {} )

    for ivar in self.singleNodeOptions:
        val = d.get(ivar,False)
        self.setOption(ivar,val,p.h)

</t>
<t tx="ekr.20050811101550.1">def writeBody (self,p):

    # remove trailing cruft and split into lines.
    lines = p.b.rstrip().split('\n')

    if self.getOption('code_mode'):
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    s = '\n'.join(lines).strip()
    if s:
        self.write('%s\n\n' % s)
</t>
<t tx="ekr.20050811102607">def skip_literal_block (self,lines,n):

    s = lines[n] ; result = [s] ; n += 1
    indent = g.skip_ws(s,0)

    # Skip lines until a non-blank line is found with same or less indent.
    while n &lt; len(lines):
        s = lines[n]
        indent2 = g.skip_ws(s,0)
        if s and not s.isspace() and indent2 &lt;= indent:
            break # We will rescan lines [n]
        n += 1
        result.append(s)

    # g.printList(result,tag='literal block')
    return n, result
</t>
<t tx="ekr.20050811105438">def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,0,key):
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20050811105438.1">def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20050811135526">def setOption (self,name,val,tag):

    ivar = self.munge(name)
    self.optionsDict [ivar] = val
</t>
<t tx="ekr.20050811150541">def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or
            (self.getOption('show_doc_parts_as_paragraphs') and self.isSpecialDocPart(s,None))
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []
    return self.rstripList(result)
</t>
<t tx="ekr.20050811152104">def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
</t>
<t tx="ekr.20050811153208">def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) &gt; 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    return result
</t>
<t tx="ekr.20050811154552">def getDocPart (self,lines,n):

    result = []
    &lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
            break
        result.append(s)
    return n, result
</t>
<t tx="ekr.20050811163802">def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
</t>
<t tx="ekr.20050811173750">def scanHeadlineForOptions (self,p):

    '''Return a dictionary containing the options implied by p's headline.'''

    h = p.h.strip()

    if p == self.topNode:
        return {} # Don't mess with the root node.
    elif g.match_word(h,0,self.getOption('option_prefix')): # '@rst-option'
        s = h [len(self.option_prefix):]
        return self.scanOption(p,s)
    elif g.match_word(h,0,self.getOption('options_prefix')): # '@rst-options'
        return self.scanOptions(p,p.b)
    else:
        # Careful: can't use g.match_word because options may have '-' chars.
        i = g.skip_id(h,0,chars='@-')
        word = h[0:i]

        for prefix,ivar,val in (
            ('code_prefix','code_mode',True), # '@rst-code'
            ('doc_mode_prefix','doc_only_mode',True), # @rst-doc-only.
            ('default_path_prefix','default_prefix',''), # '@rst-default-path'
            ('rst_prefix','code_mode',False), # '@rst'
            ('ignore_headline_prefix','ignore_this_headline',True), # '@rst-no-head'
            ('show_headline_prefix','show_this_headline',True), # '@rst-head'
            ('ignore_headlines_prefix','show_headlines',False), # '@rst-no-headlines'
            ('ignore_prefix','ignore_this_tree',True),      # '@rst-ignore'
            ('ignore_node_prefix','ignore_this_node',True), # '@rst-ignore-node'
            ('ignore_tree_prefix','ignore_this_tree',True), # '@rst-ignore-tree'
            ('preformat_prefix','preformat_this_node',True), # '@rst-preformat
        ):
            prefix = self.getOption(prefix)
            if prefix and word == prefix: # Do _not_ munge this prefix!
                d = { ivar: val }
                if ivar != 'code_mode':
                    d ['code_mode'] = False # Enter rst mode.
                    d ['doc_only_mode'] = False
                # Special case: Treat a bare @rst like @rst-no-head
                if h == self.getOption('rst_prefix'):
                    d ['ignore_this_headline'] = True
                return d

        if h.startswith('@rst'):
            g.trace('word',word,'rst_prefix',self.getOption('rst_prefix'))
            g.trace('unknown kind of @rst headline',p.h)

        return {}
</t>
<t tx="ekr.20050812120933">def dumpSettings (self):

    d = self.optionsDict
    keys = list(d.keys())
    keys.sort()

    g.pr('present settings...')
    for key in keys:
        g.pr('%20s %s' % (key,d.get(key)))
</t>
<t tx="ekr.20050812122236"></t>
<t tx="ekr.20050813083007">def initHeadlineCommands (self):

    '''Init the list of headline commands used by writeHeadline.'''

    self.headlineCommands = [
        self.getOption('code_prefix'),
        self.getOption('doc_only_prefix'),
        self.getOption('default_path_prefix'),
        self.getOption('rst_prefix'),
        self.getOption('ignore_headline_prefix'),
        self.getOption('ignore_headlines_prefix'),
        self.getOption('ignore_node_prefix'),
        self.getOption('ignore_tree_prefix'),
        self.getOption('option_prefix'),
        self.getOption('options_prefix'),
        self.getOption('show_headline_prefix'),
        # # Suggested by Hemanth P.S.: prevent @file nodes from creating headings.
        # self.getOption('keep_at_file_prefix'),
        # self.getOption('strip_at_file_prefix'),
    ]
</t>
<t tx="ekr.20050813085236">def initSingleNodeOptions (self):

    self.singleNodeOptions = [
        'ignore_this_headline',
        'ignore_this_node',
        'ignore_this_tree',
        'preformat_this_node',
        'show_this_headline',
    ]
</t>
<t tx="ekr.20050813155021">def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    s = '\n'.join(theList).rstrip()
    return s.split('\n')
</t>
<t tx="ekr.20050813160208">def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
</t>
<t tx="ekr.20050814134351">def getOption (self,name):

    bwm = False
    if bwm:
        g.trace("bwm: getOption self:%s, name:%s, value:%s" % (
            self, name, self.optionsDict.get(name)))

    return self.optionsDict.get(name)
</t>
<t tx="ekr.20050815091008.1">def http_addNodeMarker (self,p):

    if (
        self.getOption('http_server_support') and
        self.getOption('generate_rst')
    ):
        self.nodeNumber += 1
        anchorname = "%s%s" % (self.getOption('node_begin_marker'),self.nodeNumber)
        s = "\n\n.. _%s:\n\n" % anchorname
        self.write(s)
        self.http_map [anchorname] = p.copy()
        if bwm_file: print &gt;&gt; bwm_file, "addNodeMarker", anchorname, p
</t>
<t tx="ekr.20050815164715">def is_node_marker (self,attrs):
    '''
    Return the name of the anchor, if this is an anchor for the beginning of a node,
    False otherwise.
    '''

    d = dict(attrs)
    result = 'id' in d and d['id'].startswith(self.node_begin_marker)
    if result:
        return d['id']
    return result
</t>
<t tx="ekr.20050815164715.1">if 0:
    g.pr("rst3: unknownAttributes[self.http_attributename]")
    g.pr("For:", self.last_position)
    pprint.pprint(mod_http.get_http_attribute(self.last_position))
</t>
<t tx="ekr.20050817132814">@nocolor-node

Important: the rst3 plugin has largely been superceded by similar
commands built into Leo's core.

To activate the rst3 plugin, do the following:

1. Go to http://silvercity.sourceforge.net/.
- Follow the link 'SilverCity Releases'.
- Download the release that fits to your Python version.
- Double-klick on the downloaded file.

2. Go to http://docutils.sourceforge.net/.
- Have a look for item 'Download'
- Get, as the editor says, the latest snapshot by following the link
  'docutils-snapshot.tgz'.
- Make sure you have a application that can handle this format. 7zip is doing this great.
- Unpack it to a temporary folder.
- Open a console window, go to the temporary folder and type 'setup.py install'
  or '&lt;path_to_python.exe&gt;\python setup.py install'.

3. Start up Leo
- Check in the menu 'Edit' for item 'Write-Restructured-Text'.
</t>
<t tx="ekr.20051022044950">def computeOldStyleShortcutKey(self, s):
    '''Compute the old-style shortcut key for @shortcuts entries.'''
    # #1121: Allow Chinese characters in command names
    return s.strip()
</t>
<t tx="ekr.20051031040240" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032302d31312d31307103752e"></t>
<t tx="ekr.20051104075904.84">def setUp(self):

    c = self.c; temp_p = self.temp_p
    d = self.dialog
    assert(d)
    temp_p.setBodyString('')
    # Create a node under temp_p.
    child = temp_p.insertAsLastChild()
    assert(child)
    child.h = "import/export test: " + self.p.h
    c.selectPosition(child)
    # Get the dialog name and the fileName from the dialog node.
    # This is used below to set up the dialog dict for NullGui.simulateDialog.
    s = d.bodyString()
    lines = s.split('\n')
    name = lines[0]
    fileName = lines[1]
    # Replace '\\' by os.path.sep in fileName
    fileName = fileName.replace('\\', os.path.sep)
    self.fileName = fileName = g.os_path_finalize_join(g.app.loadDir, "..", fileName)
    # Set the dict for UnitTestGui, a subclass of NullGui.
    # NullGui.simulateDialog uses this dict to return values for dialogs.
    if self.doImport:
        theDict = {name: [fileName]}
    else:
        theDict = {name: fileName}
    self.oldGui = g.app.gui
    self.gui = leoGui.UnitTestGui(theDict)
</t>
<t tx="ekr.20051121102358">def processTopTree (self,p,justOneFile=False):

    current = p.copy()
    for p in current.self_and_parents():
        h = p.h
        if h.startswith('@rst') and not h.startswith('@rst-'):
            self.processTree(p,
                ext=None,
                toString=False,
                justOneFile=justOneFile,
            )
            break
    else:
        self.processTree(current,
            ext=None,
            toString=False,
            justOneFile=justOneFile,
        )
    g.blue('done')
</t>
<t tx="ekr.20051202070028">def computeOutputFileName (self,fileName):

    openDirectory = self.c.frame.openDirectory
    default_path = self.getOption('default_path')
    if default_path:
        path = g.os_path_finalize_join(self.path,default_path,fileName)
    elif self.path:
        path = g.os_path_finalize_join(self.path,fileName)
    elif openDirectory:
        path = g.os_path_finalize_join(self.path,openDirectory,fileName)
    else:
        path = g.os_path_finalize_join(fileName)

    return path
</t>
<t tx="ekr.20051204070141">def preprocessNode (self,p):

    d = self.tnodeOptionDict.get(p.v)
    if d is None:
        d = self.scanNodeForOptions(p)
        self.tnodeOptionDict [p.v] = d
</t>
<t tx="ekr.20060525102337">def writeNodeToString (self,p=None,ext=None):
    '''
    Scan p's tree (defaults to presently selected tree) looking for @rst nodes.
    Convert the first node found to an ouput of the type specified by ext.

    The @rst may or may not be followed by a filename; the filename is *ignored*,
    and its type does not affect ext or the output generated in any way.

    ext should start with a period:  .html, .tex or None (specifies rst output).

    Returns p, s, where p is the position of the @rst node and s is the converted text.
    '''
    c = self.c
    current = p or c.p
    for p in current.self_and_parents():
        if p.h.startswith('@rst'):
            return self.processTree(p,ext=ext,toString=True,justOneFile=True)
    return self.processTree(current,ext=ext,toString=True,justOneFile=True)
</t>
<t tx="ekr.20060526201951">def makeRegexSubs(self, change_text, groups):
    """
    Substitute group[i-1] for \\i strings in change_text.
    """

    def repl(match_object):
        # # 1494...
        n = int(match_object.group(1)) - 1
        if 0 &lt;= n &lt; len(groups):
            return (
                groups[n].
                    replace(r'\b', r'\\b').
                    replace(r'\f', r'\\f').
                    replace(r'\n', r'\\n').
                    replace(r'\r', r'\\r').
                    replace(r'\t', r'\\t').
                    replace(r'\v', r'\\v'))
        # No replacement.
        return match_object.group(0)

    result = re.sub(r'\\([0-9])', repl, change_text)
    # print(
        # f"makeRegexSubs:\n"
        # f"change_text: {change_text!s}\n"
        # f"     groups: {groups!s}\n"
        # f"     result: {result!s}")
    return result
</t>
<t tx="ekr.20060608094815">def handleDocOnlyMode (self,p,lines):
    '''
    Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.
    '''
    # ignore            = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')
    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            self.writeHeadlineHelper(p)
    return result
</t>
<t tx="ekr.20060608094815.1">def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
</t>
<t tx="ekr.20060608102001">def writeHeadlineHelper (self,p):

    h = p.h.strip()

    # Remove any headline command before writing the
    i = g.skip_id(h,0,chars='@-')
    word = h [:i]
    if word:
        # Never generate a section for @rst-option or @rst-options.
        if word in (self.getOption('option_prefix'),self.getOption('options_prefix')):
            return
        # Remove all other headline commands from the headline.
        for prefix in self.headlineCommands:
            if word == prefix:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write('%s\n%s\n' % (h,self.underline(h,p)))
        else:
            self.write('\n%s\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
</t>
<t tx="ekr.20060610104435">if n &gt; 0:
    line = lines[n-1]
    if line.startswith('@doc'):
        s = line[4:].lstrip()
    elif line.startswith('@'):
        s = line[1:].lstrip()
    else:
        s = ''

    # New in Leo 4.4.4: remove these special tags.
    for tag in ('@rst-options','@rst-option','@rst-markup'):
        if g.match_word(s,0,tag):
            s = s[len(tag):].strip()

    if s.strip():
        result.append(s)
</t>
<t tx="ekr.20060928062431">@g.commander_command('expand-ancestors-only')
def expandOnlyAncestorsOfNode(self, event=None, p=None):
    """Contract all nodes in the outline."""
    c = self
    level = 1
    if p: c.selectPosition(p)  # 2013/12/25
    root = c.p
    for p in c.all_unique_positions():
        p.v.expandedPositions = []
        p.v.contract()
    for p in root.parents():
        p.expand()
        level += 1
    c.expansionLevel = level  # Reset expansion level.
</t>
<t tx="ekr.20061008140603">def runEditCommandTest(self, p):
    tm = self
    c = self.c
    atTest = p.copy()
    w = c.frame.body.wrapper
    h = atTest.h
    assert h.startswith('@test '), f"expected head: {'@test'}, got: {h}"
    commandName = h[6:].strip()
    # Ignore everything after the actual command name.
    i = g.skip_id(commandName, 0, chars='-')
    commandName = commandName[:i]
    assert commandName, 'empty command name'
    command = c.commandsDict.get(commandName)
    assert command, f"no command: {commandName}"
    work, before, after = tm.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node, h in ((work, 'work'), (before, before_h), (after, after_h)):
        h2 = node.h
        assert h2.startswith(h), f"expected head: {h}, got: {h2}"
    sels = []
    for node, h in ((before, before_h), (after, after_h)):
        sel = node.h[len(h) :].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    # pylint: disable=unbalanced-tuple-unpacking
    sel1, sel2 = sels
    c.selectPosition(work)
    work.b = before.b
    w.setSelectionRange(sel1[0], sel1[1], insert=sel1[1])
    ### g.trace(commandName, sel1[0], sel1[1])
    ### g.printObj(g.splitLines(w.getSelectedText()))
    c.k.simulateCommand(commandName)
    s1 = work.b; s2 = after.b
    assert s1 == s2, (
        f"mismatch in body\n"
        f"expected: {s2!r}\n"
        f"     got: {s1!r}")
    sel3 = w.getSelectionRange()
    # Convert both selection ranges to gui indices.
    sel2_orig = sel2
    assert len(sel2) == 2, f"Bad headline index.  Expected index,index.  got: {sel2}"
    i, j = sel2; sel2 = w.toPythonIndex(i), w.toPythonIndex(j)
    assert len(sel3) == 2, f"Bad headline index.  Expected index,index.  got: {sel3}"
    i, j = sel3; sel3 = w.toPythonIndex(i), w.toPythonIndex(j)
    if 0:  # Be more permissive.
        if sel2 != sel3:
            print(f"\n{p.h}\nexpected: {sel2_orig} = {sel2}, got: {sel3}")
    else:
        message = f"mismatch in sel\nexpected: {sel2_orig} = {sel2}, got: {sel3}"
        assert sel2 == sel3, message
    c.selectPosition(atTest)
    atTest.contract()
    # Don't redraw.
</t>
<t tx="ekr.20061031131434.10">@cmd('auto-complete-force')
def autoCompleteForce(self, event=None):
    """Show autocompletion, even if autocompletion is not presently enabled."""
    return self.autoComplete(event, force=True)
</t>
<t tx="ekr.20061031131434.100">def addModeCommands(self):
    """Add commands created by @mode settings to c.commandsDict."""
    k = self; c = k.c
    d = g.app.config.modeCommandsDict  # Keys are command names: enter-x-mode.
    # Create the callback functions and update c.commandsDict.
    for key in d.keys():
        # pylint: disable=cell-var-from-loop

        def enterModeCallback(event=None, name=key):
            k.enterNamedMode(event, name)

        c.commandsDict[key] = enterModeCallback
</t>
<t tx="ekr.20061031131434.101">def initSpecialIvars(self):
    """Set ivars for special keystrokes from previously-existing bindings."""
    c, k = self.c, self
    warn = c.config.getBool('warn-about-missing-settings')
    for ivar, commandName in (
        ('fullCommandKey', 'full-command'),
        ('abortAllModesKey', 'keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey', 'auto-complete-force'),
        ('demoNextKey', 'demo-next'),
        ('demoPrevKey', 'demo-prev'),
    ):
        junk, aList = c.config.getShortcut(commandName)
        aList, found = aList or [], False
        for pane in ('text', 'all'):
            for bi in aList:
                if bi.pane == pane:
                    setattr(k, ivar, bi.stroke)
                    found = True; break
        if not found and warn:
            g.trace(f"no setting for {commandName}")
</t>
<t tx="ekr.20061031131434.102">def makeBindingsFromCommandsDict(self):
    """Add bindings for all entries in c.commandsDict."""
    c, k = self.c, self
    d = c.commandsDict
    #
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of bi with bi.stroke == stroke.
    d2 = g.TypedDict(  # was TypedDictOfLists.
        name='makeBindingsFromCommandsDict helper dict',
        keyType=g.KeyStroke,
        valType=g.BindingInfo,
    )
    for commandName in sorted(d):
        command = d.get(commandName)
        key, aList = c.config.getShortcut(commandName)
        for bi in aList:
            # Important: bi.stroke is already canonicalized.
            stroke = bi.stroke
            bi.commandName = commandName
            if stroke:
                assert g.isStroke(stroke)
                d2.add_to_list(stroke, bi)
    #
    # Step 2: make the bindings.
    for stroke in sorted(d2.keys()):
        aList2 = d2.get(stroke)
        for bi in aList2:
            commandName = bi.commandName
            command = c.commandsDict.get(commandName)
            tag = bi.kind
            pane = bi.pane
            if stroke and not pane.endswith('-mode'):
                k.bindKey(pane, stroke, command, commandName, tag=tag)
</t>
<t tx="ekr.20061031131434.103">def makeMasterGuiBinding(self, stroke, w=None):
    """Make a master gui binding for stroke in pane w, or in all the standard widgets."""
    k = self; c = k.c; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = (
            f.tree
            and hasattr(f.tree, 'bindingWidget')
            and f.tree.bindingWidget
            or None)
        wrapper = f.body and hasattr(f.body, 'wrapper') and f.body.wrapper or None
        canvas = f.tree and hasattr(f.tree, 'canvas') and f.tree.canvas or None
        widgets = (c.miniBufferWidget, wrapper, canvas, bindingWidget)
    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke, [])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict[stroke] = aList
</t>
<t tx="ekr.20061031131434.104"></t>
<t tx="ekr.20061031131434.108">def callStateFunction(self, event):
    """Call the state handler associated with this event."""
    k = self
    ch = event.char
    #
    # Defensive programming
    if not k.state.kind:
        return None
    if not k.state.handler:
        g.error('callStateFunction: no state function for', k.state.kind)
        return None
    #
    # Handle auto-completion before checking for unbound keys.
    if k.state.kind == 'auto-complete':
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        return val
    #
    # Ignore unbound non-ascii keys.
    if (
        k.ignore_unbound_non_ascii_keys and
        len(ch) == 1 and
        ch and ch not in ('\b', '\n', '\r', '\t') and
        (ord(ch) &lt; 32 or ord(ch) &gt; 128)
    ):
        return None
    #
    # Call the state handler.
    val = k.state.handler(event)
    return val
</t>
<t tx="ekr.20061031131434.11">def auto_completer_state_handler(self, event):
    """Handle all keys while autocompleting."""
    c, k, tag = self.c, self.k, 'auto-complete'
    state = k.getState(tag)
    ch = event.char if event else ''
    stroke = event.stroke if event else ''
    is_plain = k.isPlainKey(stroke)
    if state == 0:
        c.frame.log.clearTab(self.tabName)
        common_prefix, prefix, tabList = self.compute_completion_list()
        if tabList:
            k.setState(tag, 1, handler=self.auto_completer_state_handler)
        else:
            self.exit()
    elif ch in ('\n', 'Return'):
        self.exit()
    elif ch == 'Escape':
        self.exit()
    elif ch in ('\t', 'Tab'):
        self.compute_completion_list()
    elif ch in ('\b', 'BackSpace'):
        self.do_backspace()
    elif ch == '.':
        self.insert_string('.')
        self.compute_completion_list()
    elif ch == '?':
        self.info()
    elif ch == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        kind = 'ON' if self.verbose else 'OFF'
        message = f"verbose completions {kind}"
        g.es_print(message)
        # This doesn't work because compute_completion_list clears the autocomplete tab.
        # self.put('', message, tabName=self.tabName)
        # This is almost invisible: the fg='red' is not honored.
        c.frame.putStatusLine(message, fg='red')
        self.compute_completion_list()
    # elif ch == 'Down' and hasattr(self,'onDown'):
        # self.onDown()
    # elif ch == 'Up' and hasattr(self,'onUp'):
        # self.onUp()
    elif is_plain and ch and ch in string.printable:
        self.insert_general_char(ch)
    elif stroke == k.autoCompleteForceKey:
        # This is probably redundant because completions will exist.
        # However, it doesn't hurt, and it may be useful rarely.
        common_prefix, prefix, tabList = self.compute_completion_list()
        if tabList:
            self.show_completion_list(common_prefix, prefix, tabList)
        else:
            g.warning('No completions')
            self.exit()
    else:
        self.abort()
        return 'do-standard-keys'
    return None
</t>
<t tx="ekr.20061031131434.111">@cmd('full-command')
def fullCommand(
    self,
    event,
    specialStroke=None,
    specialFunc=None,
    help=False,
    helpHandler=None,
):
    """Handle 'full-command' (alt-x) mode."""
    try:
        k = self; c = k.c
        state = k.getState('full-command')
        helpPrompt = 'Help for command: '
        c.check_event(event)
        ch = char = event.char if event else ''
        stroke = event.stroke if event else ''
        if state &gt; 0:
            k.setLossage(char, stroke)
        if state == 0:
            k.mb_event = event  # Save the full event for later.
            k.setState('full-command', 1, handler=k.fullCommand)
            prompt = helpPrompt if help else k.altX_prompt
            k.setLabelBlue(prompt)
            k.mb_help = help
            k.mb_helpHandler = helpHandler
            c.minibufferWantsFocus()
        elif char == 'Ins' or k.isFKey(char):
            pass
        elif char == 'Escape':
            k.keyboardQuit()
        elif char == 'Down':
            k.commandHistoryFwd()
        elif char == 'Up':
            k.commandHistoryBackwd()
        elif char in ('\n', 'Return'):
            # Fix bug 157: save and restore the selection.
            w = k.mb_event and k.mb_event.w
            if w and hasattr(w, 'hasSelection') and w.hasSelection():
                sel1, sel2 = w.getSelectionRange()
                ins = w.getInsertPoint()
                c.frame.log.deleteTab('Completion')
                w.setSelectionRange(sel1, sel2, insert=ins)
            else:
                c.frame.log.deleteTab('Completion')
                    # 2016/04/27
            if k.mb_help:
                s = k.getLabel()
                commandName = s[len(helpPrompt) :].strip()
                k.clearState()
                k.resetLabel()
                if k.mb_helpHandler: k.mb_helpHandler(commandName)
            else:
                s = k.getLabel(ignorePrompt=True)
                commandName = s.strip()
                ok = k.callAltXFunction(k.mb_event)
                if ok:
                    k.addToCommandHistory(commandName)
        elif char in ('\t', 'Tab'):
            k.doTabCompletion(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif char in ('\b', 'BackSpace'):
            k.doBackSpace(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif k.ignore_unbound_non_ascii_keys and len(ch) &gt; 1:
            if specialStroke:
                g.trace(specialStroke)
                specialFunc()
            c.minibufferWantsFocus()
        else:
            # Clear the list, any other character besides tab indicates that a new prefix is in effect.
            k.mb_tabList = []
            k.updateLabel(event)
            k.mb_tabListPrefix = k.getLabel()
            c.minibufferWantsFocus()
    except Exception:
        g.es_exception()
        self.keyboardQuit()
</t>
<t tx="ekr.20061031131434.112">def callAltXFunction(self, event):
    """Call the function whose name is in the minibuffer."""
    c, k = self.c, self
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.

        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))

    else:
        func = c.commandsDict.get(commandName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
        else:
            c.widgetWantsFocusNow(event and event.widget)  # So cut-text works, e.g.
        try:
            func(event)
        except Exception:
            g.es_exception()
        return True
    # Show possible completions if the command does not exist.
    k.doTabCompletion(list(c.commandsDict.keys()))
    return False
</t>
<t tx="ekr.20061031131434.114"></t>
<t tx="ekr.20061031131434.119">@cmd('show-bindings')
def printBindings(self, event=None):
    """Print all the bindings presently in effect."""
    k = self; c = k.c
    d = k.bindingsDict; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] @mode, @button, @command

'''
    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend, c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke), stroke
        aList = d.get(stroke, [])
        for bi in aList:
            s1 = '' if bi.pane == 'all' else bi.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = bi.commandName
            s4 = bi.kind or '&lt;no hash&gt;'
            data.append((s1, s2, s3, s4),)
    # Print keys by type:
    result = []
    result.append('\n' + legend)
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Ctrl', 'Alt+Shift', 'Alt',  # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift', 'Ctrl+Meta', 'Ctrl+Shift', 'Ctrl',  # Ctrl+Key: done by Ctrl.
        'Meta+Key', 'Meta+Shift', 'Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1, s2, s3, s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append(f"***** {prefix}...\n")
        self.printBindingsHelper(result, data2, prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result, data, prefix=None)
    if not g.unitTesting:
        g.es_print('', ''.join(result), tabName=tabName)
    k.showStateAndMode()
    return result  # for unit test.
</t>
<t tx="ekr.20061031131434.12">@cmd('disable-autocompleter')
def disableAutocompleter(self, event=None):
    """Disable the autocompleter."""
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

@cmd('disable-calltips')
def disableCalltips(self, event=None):
    """Disable calltips."""
    self.k.enable_calltips = False
    self.showCalltipsStatus()

@cmd('enable-autocompleter')
def enableAutocompleter(self, event=None):
    """Enable the autocompleter."""
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

@cmd('enable-calltips')
def enableCalltips(self, event=None):
    """Enable calltips."""
    self.k.enable_calltips = True
    self.showCalltipsStatus()

@cmd('toggle-autocompleter')
def toggleAutocompleter(self, event=None):
    """Toggle whether the autocompleter is enabled."""
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

@cmd('toggle-calltips')
def toggleCalltips(self, event=None):
    """Toggle whether calltips are enabled."""
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
</t>
<t tx="ekr.20061031131434.120">def printBindingsHelper(self, result, data, prefix):
    """Helper for k.printBindings"""
    c, lm = self.c, g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        letter = lm.computeBindingLetter(c, kind)
        pane = f"{pane if pane else 'all':4}: "
        left = pane + key  # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
</t>
<t tx="ekr.20061031131434.121">@cmd('show-commands')
def printCommands(self, event=None):
    """Print all the known commands and their bindings, if any."""
    k = self; c = k.c; tabName = 'Commands'
    c.frame.log.clearTab(tabName)
    inverseBindingDict = k.computeInverseBindingDict()
    data, n = [], 0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName, [('', ''),])
        for z in dataList:
            pane, key = z
            pane = f"{pane} " if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key', '')
            s1 = pane + key
            s2 = commandName
            n = max(n, len(s1))
            data.append((s1, s2),)
    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n, z1, z2) for z1, z2 in data]
    g.es_print('', ''.join(lines), tabName=tabName)
</t>
<t tx="ekr.20061031131434.122">@cmd('repeat-complex-command')
def repeatComplexCommand(self, event):
    """Repeat the previously executed minibuffer command."""
    k = self
    if k.mb_history:
        k.setState('last-full-command', 1, handler=k.repeatComplexCommandHelper)
        k.setLabelBlue(f"Redo: {str(k.mb_history[0])}")
    else:
        g.warning('no previous minibuffer command')
</t>
<t tx="ekr.20061031131434.123">@cmd('set-command-state')
def setCommandState(self, event):
    """Enter the 'command' editing state."""
    k = self
    k.setInputState('command', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-insert-state')
def setInsertState(self, event):
    """Enter the 'insert' editing state."""
    k = self
    k.setInputState('insert', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-overwrite-state')
def setOverwriteState(self, event):
    """Enter the 'overwrite' editing state."""
    k = self
    k.setInputState('overwrite', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.124">@cmd('toggle-input-state')
def toggleInputState(self, event=None):
    """The toggle-input-state command."""
    k = self; c = k.c
    default = c.config.getString('top-level-unbound-key-action') or 'insert'
    state = k.unboundKeyAction
    if default == 'insert':
        state = 'command' if state == 'insert' else 'insert'
    elif default == 'overwrite':
        state = 'command' if state == 'overwrite' else 'overwrite'
    else:
        state = 'insert' if state == 'command' else 'command'  # prefer insert to overwrite.
    k.setInputState(state)
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.125"></t>
<t tx="ekr.20061031131434.126">def manufactureKeyPressForCommandName(self, w, commandName):
    """
    Implement a command by passing a keypress to the gui.
    
    **Only unit tests use this method.**
    """
    c, k = self.c, self
    stroke = k.getStrokeForCommandName(commandName)
    assert g.isStroke(stroke), (commandName, stroke.__class__.__name__)
    shortcut = stroke.s
    shortcut = g.checkUnicode(shortcut)
    if shortcut and w:
        g.app.gui.set_focus(c, w)
        g.app.gui.event_generate(c, None, shortcut, w)
    else:
        message = f"no shortcut for {commandName}"
        if g.app.unitTesting:
            raise AttributeError(message)
        g.error(message)
</t>
<t tx="ekr.20061031131434.127">def simulateCommand(self, commandName, event=None):
    """Execute a Leo command by name."""
    c = self.c
    if not event:
        # Create a default key event.
        event = g.app.gui.create_key_event(c)
    c.doCommandByName(commandName, event)
</t>
<t tx="ekr.20061031131434.13">@cmd('show-calltips')
def showCalltips(self, event=None, force=False):
    """Show the calltips at the cursor."""
    c, k = self.c, self.c.k
    w = event and event.w
    if not w:
        return
    is_headline = c.widget_name(w).startswith('head')
    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not is_headline:
        self.w = w
        self.calltip()
    else:
        c.insertCharFromEvent(event)
</t>
<t tx="ekr.20061031131434.130">@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True):
    """Clears the state and the minibuffer label."""
    k = self; c = k.c
    if g.app.quitting:
        return
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
    k.resetCommandHistory()
</t>
<t tx="ekr.20061031131434.131">def registerCommand(self, commandName, func,
    allowBinding=False,
    pane='all',
    shortcut=None,  # Must be None unless allowBindings is True.
    ** kwargs
):
    """
    Make the function available as a minibuffer command.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.
    
    Ignore the 'shortcut' arg unless 'allowBinding' is True.
    
    Only k.bindOpenWith and the mod_scripting.py plugin should set
    allowBinding.
    """
    c, k = self.c, self
    if not func:
        g.es_print('Null func passed to k.registerCommand\n', commandName)
        return
    f = c.commandsDict.get(commandName)
    if f and f.__name__ != func.__name__:
        g.trace('redefining', commandName, f, '-&gt;', func)
    c.commandsDict[commandName] = func
    # Warn about deprecated arguments.
    if shortcut and not allowBinding:
        g.es_print('The "shortcut" keyword arg to k.registerCommand will be ignored')
        g.es_print('Called from', g.callers())
        shortcut = None
    for arg, val in kwargs.items():
        if val is not None:
            g.es_print(f'The "{arg}" keyword arg to k.registerCommand is deprecated')
            g.es_print('Called from', g.callers())
    # Make requested bindings, even if a warning has been given.
    # This maintains strict compatibility with existing plugins and scripts.
    k.registerCommandShortcut(
        commandName=commandName,
        func=func,
        pane=pane,
        shortcut=shortcut,
    )
</t>
<t tx="ekr.20061031131434.133">def setInputState(self, state, set_border=False):
    k = self
    k.unboundKeyAction = state
</t>
<t tx="ekr.20061031131434.135"># def minibufferWantsFocus(self):
    # c = self.c
    # c.widgetWantsFocus(c.miniBufferWidget)
</t>
<t tx="ekr.20061031131434.14">@cmd('show-calltips-force')
def showCalltipsForce(self, event=None):
    """Show the calltips at the cursor, even if calltips are not presently enabled."""
    return self.showCalltips(event, force=True)
</t>
<t tx="ekr.20061031131434.145"></t>
<t tx="ekr.20061031131434.146">def masterKeyHandler(self, event):
    """The master key handler for almost all key bindings."""
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    c, k = self.c, self
    # Setup...
    if trace:
        g.trace(repr(k.state.kind), repr(event.char), repr(event.stroke))
    k.checkKeyEvent(event)
    k.setEventWidget(event)
    k.traceVars(event)
    # Order is very important here...
    if k.isSpecialKey(event):
        return
    # Add *all* characters to the lossage.
    k.setLossage(event.char, event.stroke)
    if k.doKeyboardQuit(event):
        return
    if k.doDemo(event):
        return
    if k.doMode(event):
        return
    if k.doVim(event):
        return
    if k.doBinding(event):
        return
    # Handle abbreviations.
    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, event.stroke):
        return
    # Handle the character given by event *without*
    # executing any command that might be bound to it.
    c.insertCharFromEvent(event)
</t>
<t tx="ekr.20061031131434.15">def showAutocompleterStatus(self):
    """Show the autocompleter status."""
    k = self.k
    if not g.unitTesting:
        s = f"autocompleter {'On' if k.enable_autocompleter else 'Off'}"
        g.red(s)

def showCalltipsStatus(self):
    """Show the autocompleter status."""
    k = self.k
    if not g.unitTesting:
        s = f"calltips {'On'}" if k.enable_calltips else 'Off'
        g.red(s)
</t>
<t tx="ekr.20061031131434.152">def handleMiniBindings(self, event, state, stroke):
    """Find and execute commands bound to the event."""
    k = self
    #
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    #
    # Ignore other special keys in the minibuffer.
    if state in ('getArg', 'full-command'):
        if stroke in (
            '\b', 'BackSpace',
            '\r', 'Linefeed',
            '\n', 'Return',
            '\t', 'Tab',
            'Escape',
        ):
            return False
        if k.isFKey(stroke):
            return False
    #
    # Ignore autocompletion state.
    if state.startswith('auto-'):
        return False
    #
    # Ignore plain key binding in the minibuffer.
    if not stroke or k.isPlainKey(stroke):
        return False
    #
    # Get the command, based on the pane.
    for pane in ('mini', 'all', 'text'):
        result = k.handleMinibufferHelper(event, pane, state, stroke)
        assert result in ('continue', 'found', 'ignore')
        if result == 'ignore':
            return False  # Let getArg handle it.
        if result == 'found':
            # Do not call k.keyboardQuit here!
            return True
    #
    # No binding exists.
    return False
</t>
<t tx="ekr.20061031131434.156"></t>
<t tx="ekr.20061031131434.157">def badMode(self, modeName):
    k = self
    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey(f"@mode {modeName} is not defined (or is empty)")
</t>
<t tx="ekr.20061031131434.158">def createModeBindings(self, modeName, d, w):
    """Create mode bindings for the named mode using dictionary d for w, a text widget."""
    k = self; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*', '*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:', commandName, 'Referenced from', modeName)
            continue
        aList = d.get(commandName, [])
        for bi in aList:
            stroke = bi.stroke
            # Important: bi.val is canonicalized.
            if stroke and stroke not in ('None', 'none', None):
                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)
                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName, {})
                d2[stroke] = g.BindingInfo(
                    kind=f"mode&lt;{modeName}&gt;",
                    commandName=commandName,
                    func=func,
                    nextMode=bi.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
</t>
<t tx="ekr.20061031131434.16"></t>
<t tx="ekr.20061031131434.160">def enterNamedMode(self, event, commandName):
    k = self; c = k.c
    modeName = commandName[6:]
    c.inCommand = False  # Allow inner commands in the mode.
    k.generalModeHandler(event, modeName=modeName)
</t>
<t tx="ekr.20061031131434.161">@cmd('exit-named-mode')
def exitNamedMode(self, event=None):
    """Exit an input mode."""
    k = self
    if k.inState():
        k.endMode()
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.163">def initMode(self, event, modeName):

    k = self; c = k.c
    if not modeName:
        g.trace('oops: no modeName')
        return
    d = g.app.config.modeCommandsDict.get('enter-' + modeName)
    if not d:
        self.badMode(modeName)
        return
    k.modeBindingsDict = d
    bi = d.get('*command-prompt*')
    prompt = bi.kind if bi else modeName
    k.inputModeName = modeName
    k.silentMode = False
    aList = d.get('*entry-commands*', [])
    if aList:
        for bi in aList:
            commandName = bi.commandName
            k.simulateCommand(commandName)
            # Careful, the command can kill the commander.
            if g.app.quitting or not c.exists: return
            # New in Leo 4.5: a startup command can immediately transfer to another mode.
            if commandName.startswith('enter-'):
                return
    # Create bindings after we know whether we are in silent mode.
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    k.showStateAndMode(prompt=prompt)
</t>
<t tx="ekr.20061031131434.164">def reinitMode(self, modeName):
    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName + ': ')  # ,protect=True)
</t>
<t tx="ekr.20061031131434.165">@cmd('mode-help')
def modeHelp(self, event):
    """
    The mode-help command.

    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.
    """
    k = self; c = k.c
    c.endEditing()
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-' + k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
</t>
<t tx="ekr.20061031131434.166">def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for bi in aList:
                stroke = bi.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[:-4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', f"{prompt.kind.strip()}\n\n", tabName=tabName)
    else:
        g.es('', f"{modeName} mode\n\n", tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
</t>
<t tx="ekr.20061031131434.176">def computeInverseBindingDict(self):
    k = self
    d = {}
        # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        aList = k.bindingsDict.get(stroke, [])
        for bi in aList:
            shortcutList = k.bindingsDict.get(bi.commandName, [])
                # Bug fix: 2017/03/26.
            bi_list = k.bindingsDict.get(
                stroke, g.BindingInfo(kind='dummy', pane='all'))
                # Important: only bi.pane is required below.
            for bi in bi_list:
                pane = f"{bi.pane}:"
                data = (pane, stroke)
                if data not in shortcutList:
                    shortcutList.append(data)
            d[bi.commandName] = shortcutList
    return d
</t>
<t tx="ekr.20061031131434.179">def getStrokeForCommandName(self, commandName):
    k = self; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke, aList in k.bindingsDict.items():
            for bi in aList:
                if bi.commandName == commandName:
                    return stroke
    return None
</t>
<t tx="ekr.20061031131434.18">def appendTabName(self, word):
    self.setTabName(self.tabName + '.' + word)

def beginTabName(self, word):
    self.setTabName('AutoComplete ' + word)

def clearTabName(self):
    self.setTabName('AutoComplete ')

def popTabName(self):
    s = self.tabName
    i = s.rfind('.', 0, -1)
    if i &gt; -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!

def setTabName(self, s):
    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_', '') or ''
    c.frame.log.clearTab(self.tabName)
</t>
<t tx="ekr.20061031131434.181"></t>
<t tx="ekr.20061031131434.182">def isPlainKey(self, stroke):
    """Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key."""
    if not stroke:
        return False
    if not g.isStroke(stroke):
        # Happens during unit tests.
        stroke = g.KeyStroke(stroke)
    #
    # altgr combos (Alt+Ctrl) are always plain keys
    # g.KeyStroke does not handle this, because it has no "c" ivar.
    #
    if stroke.isAltCtrl() and not self.enable_alt_ctrl_bindings:
        return True
    return stroke.isPlainKey()
</t>
<t tx="ekr.20061031131434.191">def prettyPrintKey(self, stroke, brief=False):

    if not stroke:
        return ''
    if not g.assert_is(stroke, g.KeyStroke):
        return stroke
    return stroke.prettyPrint()
</t>
<t tx="ekr.20061031131434.192">def showStateAndMode(self, w=None, prompt=None, setFocus=True):
    """Show the state and mode at the start of the minibuffer."""
    c, k = self.c, self
    state = k.unboundKeyAction
    mode = k.getStateKind()
    if not g.app.gui:
        return
    if not w:
        if hasattr(g.app.gui, 'set_minibuffer_label'):
            pass  # we don't need w
        else:
            w = g.app.gui.get_focus(c)
            if not w:
                return
    isText = g.isTextWrapper(w)
    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return
    wname = g.app.gui.widget_name(w).lower()
    # Get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree, 'getWrapper'):
            if hasattr(w, 'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2, item=None)
            isText = bool(w)  # A benign hack.
    if mode:
        if mode in ('getArg', 'getFileName', 'full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = f"{mode.capitalize()} Mode"
    elif c.vim_mode and c.vimCommands:
        c.vimCommands.show_status()
        return
    else:
        s = f"{state.capitalize()} State"
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'
    if s:
        k.setLabelBlue(s)
    if w and isText:
        # k.showStateColors(inOutline,w)
        k.showStateCursor(state, w)
    # 2015/07/11: reset the status line.
    if hasattr(c.frame.tree, 'set_status_line'):
        c.frame.tree.set_status_line(c.p)
</t>
<t tx="ekr.20061031131434.193"></t>
<t tx="ekr.20061031131434.194">def clearState(self):
    """Clear the key handler state."""
    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
</t>
<t tx="ekr.20061031131434.195">def getStateHandler(self):
    return self.state.handler
</t>
<t tx="ekr.20061031131434.196">def getState(self, kind):
    k = self
    val = k.state.n if k.state.kind == kind else 0
    return val
</t>
<t tx="ekr.20061031131434.197">def getStateKind(self):
    return self.state.kind
</t>
<t tx="ekr.20061031131434.198">def inState(self, kind=None):
    k = self
    if kind:
        return k.state.kind == kind and k.state.n is not None
    return k.state.kind and k.state.n is not None
</t>
<t tx="ekr.20061031131434.199">def setState(self, kind, n, handler=None):

    k = self
    if kind and n is not None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()
    # k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.20">def calltip(self):
    """Show the calltips for the present prefix.
    ch is '(' if the user has just typed it.
    """
    obj, prefix = self.get_object()
    if obj:
        self.calltip_success(prefix, obj)
    else:
        self.calltip_fail(prefix)
    self.exit()
</t>
<t tx="ekr.20061031131434.28">def compute_completion_list(self):
    """Return the autocompleter completion list."""
    prefix = self.get_autocompleter_prefix()
    key, options = self.get_cached_options(prefix)
    if not options:
        options = self.get_completions(prefix)
    tabList, common_prefix = g.itemsMatchingPrefixInList(
        prefix, options, matchEmptyPrefix=False)
    if not common_prefix:
        tabList, common_prefix = g.itemsMatchingPrefixInList(
            prefix, options, matchEmptyPrefix=True)
    if tabList:
        self.show_completion_list(common_prefix, prefix, tabList)
    return common_prefix, prefix, tabList
</t>
<t tx="ekr.20061031131434.29">def do_backspace(self):
    """Delete the character and recompute the completion list."""
    c, w = self.c, self.w
    c.bodyWantsFocusNow()
    i = w.getInsertPoint()
    if i &lt;= 0:
        self.exit()
        return
    w.delete(i - 1, i)
    w.setInsertPoint(i - 1)
    if i &lt;= 1:
        self.exit()
    else:
        # Update the list. Abort if there is no prefix.
        common_prefix, prefix, tabList = self.compute_completion_list()
        if not prefix:
            self.exit()
</t>
<t tx="ekr.20061031131434.31">def insert_string(self, s, select=False):
    """
    Insert an auto-completion string s at the insertion point.
    
    Leo 6.4. This *part* of auto-completion is no longer undoable.
    """
    c, w = self.c, self.w
    if not g.isTextWrapper(w):
        return
    c.widgetWantsFocusNow(w)
    #
    # Don't make this undoable.
        # oldText = w.getAllText()
        # oldSel = w.getSelectionRange()
        # bunch = u.beforeChangeBody(p)
    i = w.getInsertPoint()
    w.insert(i, s)
    if select:
        j = i + len(s)
        w.setSelectionRange(i, j, insert=j)
    #
    # Don't make this undoable.
        # if 0:
            # u.doTyping(p, 'Typing',
                # oldSel=oldSel,
                # oldText=oldText,
                # newText=w.getAllText(),
                # newInsert=w.getInsertPoint(), 
                # newSel=w.getSelectionRange())
        # else:
            # u.afterChangeBody(p, 'auto-complete', bunch)
    if self.use_qcompleter and self.qw:
        c.widgetWantsFocusNow(self.qw.leo_qc)
</t>
<t tx="ekr.20061031131434.38">def info(self):
    """Show the docstring for the present completion."""
    c = self.c
    obj, prefix = self.get_object()
    c.frame.log.clearTab('Info', wrap='word')
    put = lambda s: self.put('', s, tabName='Info')
    put(prefix)
    try:
        argspec = inspect.getargspec(obj)
        # uses None instead of empty list
        argn = len(argspec.args or [])
        defn = len(argspec.defaults or [])
        put("args:")
        simple_args = argspec.args[: argn - defn]
        if not simple_args:
            put('    (none)')
        else:
            put('    ' + ', '.join(' ' + i for i in simple_args))
        put("keyword args:")
        if not argspec.defaults:
            put('    (none)')
        for i in range(defn):
            arg = argspec.args[-defn + i]
            put(f"    {arg} = {repr(argspec.defaults[i])}")
        if argspec.varargs:
            put("varargs: *" + argspec.varargs)
        if argspec.keywords:
            put("keywords: **" + argspec.keywords)
        put('\n')  # separate docstring
    except TypeError:
        put('\n')  # not a callable
    doc = inspect.getdoc(obj)
    put(doc if doc else "No docstring for " + repr(prefix))
</t>
<t tx="ekr.20061031131434.39">def insert_general_char(self, ch):

    trace = all(z in g.app.debug for z in ('abbrev', 'verbose'))
    k, w = self.k, self.w
    if g.isWordChar(ch):
        if trace: g.trace('ch', repr(ch))
        self.insert_string(ch)
        common_prefix, prefix, aList = self.compute_completion_list()
        if not aList:
            if self.forbid_invalid:
                # Delete the character we just inserted.
                self.do_backspace()
        # @bool auto_tab_complete is deprecated.
        # Auto-completion makes no sense if it is False.
        elif self.auto_tab and len(common_prefix) &gt; len(prefix):
            extend = common_prefix[len(prefix) :]
            ins = w.getInsertPoint()
            if trace: g.trace('extend', repr(extend))
            w.insert(ins, extend)
        return
    if ch == '(' and k.enable_calltips:
        # This calls self.exit if the '(' is valid.
        self.calltip()
    else:
        if trace: g.trace('ch', repr(ch))
        self.insert_string(ch)
        self.exit()
</t>
<t tx="ekr.20061031131434.4">class AutoCompleterClass:
    """A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    """
    @others
</t>
<t tx="ekr.20061031131434.46">def start(self, event):
    """Init the completer and start the state handler."""
    # We don't need to clear this now that we don't use ContextSniffer.
    c = self.c
    if c.config.getBool('use-jedi', default=True):
        self.completionsDict = {}
    if self.use_qcompleter:
        self.init_qcompleter(event)
    else:
        self.init_tabcompleter(event)
</t>
<t tx="ekr.20061031131434.5">def __init__(self, k):
    """Ctor for AutoCompleterClass class."""
    # Ivars...
    self.c = k.c
    self.k = k
    self.force = None
    self.language = None
    self.namespaces = []
        # additional namespaces to search for objects, other code
        # can append namespaces to this to extend scope of search
    self.qw = None
        # The object that supports qcompletion methods.
    self.tabName = None
        # The name of the main completion tab.
    self.verbose = False
        # True: print all members, regardless of how many there are.
    self.w = None
        # The widget that gets focus after autocomplete is done.
    self.warnings = {}
        # Keys are language names.
    # Codewise pre-computes...
    self.codewiseSelfList = []
        # The (global) completions for "self."
    self.completionsDict = {}
        # Keys are prefixes, values are completion lists.
    self.reloadSettings()

def reloadSettings(self):
    c = self.c
    self.auto_tab = c.config.getBool('auto-tab-complete', True)
    self.forbid_invalid = c.config.getBool('forbid-invalid-completions', False)
    self.use_jedi = c.config.getBool('use-jedi', False)
    self.use_qcompleter = c.config.getBool('use-qcompleter', False)
        # True: show results in autocompleter tab.
        # False: show results in a QCompleter widget.
</t>
<t tx="ekr.20061031131434.74">class KeyHandlerClass:
    """
    A class to support emacs-style commands.
    c.k is an instance of this class.
    """
    @others
</t>
<t tx="ekr.20061031131434.75"></t>
<t tx="ekr.20061031131434.76">def __init__(self, c):
    """Create a key handler for c."""
    self.c = c
    self.dispatchEvent = None
    self.fnc = None
        # A singleton defined in k.finishCreate.
    self.getArgInstance = None
        # A singleton defined in k.finishCreate.
    self.inited = False
        # Set at end of finishCreate.
    self.killedBindings = []
        # A list of commands whose bindings have been set to None in the local file.
    self.replace_meta_with_alt = False
        # True: (Mac only) swap Meta and Alt keys.
    self.w = None
        # Note: will be None for NullGui.
    # Generalize...
    self.x_hasNumeric = ['sort-lines', 'sort-fields']
    self.altX_prompt = 'full-command: '
    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke
    # Define all ivars...
    self.defineExternallyVisibleIvars()
    self.defineInternalIvars()
    self.reloadSettings()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None  # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction()
</t>
<t tx="ekr.20061031131434.78">def defineExternallyVisibleIvars(self):

    self.abbrevOn = False  # True: abbreviations are on.
    self.arg = ''  # The value returned by k.getArg.
    self.getArgEscapeFlag = False  # True: the user escaped getArg in an unusual way.
    self.getArgEscapes = []
    self.inputModeName = ''  # The name of the input mode, or None.
    self.modePrompt = ''  # The mode promopt.
    self.state = g.bunch(kind=None, n=None, handler=None)
    
    # Remove ???
    self.givenArgs = []  # Args specified after the command name in k.simulateCommand.
    self.functionTail = None  # For commands that take minibuffer arguments.
</t>
<t tx="ekr.20061031131434.79">def defineInternalIvars(self):
    """Define internal ivars of the KeyHandlerClass class."""
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of BindingInfo objects.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are BindingInfo objects.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None  # New support for the demo.py plugin.
    self.demoPrevKey = None  # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
</t>
<t tx="ekr.20061031131434.8"></t>
<t tx="ekr.20061031131434.80">def finishCreate(self):
    """
    Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.
    """
    c, k = self.c, self
    k.w = c.frame.miniBufferWidget
        # Will be None for NullGui.
    k.fnc = FileNameChooser(c)
        # A singleton. Defined here so that c.k will exist.
    k.getArgInstance = GetArg(c)
        # a singleton. Defined here so that c.k will exist.
    k.makeAllBindings()
        # Important: This must be called this now,
        # even though LM.laod calls g.app.makeAllBindings later.
    k.initCommandHistory()
    k.inited = True
    k.setDefaultInputState()
    k.resetLabel()
</t>
<t tx="ekr.20061031131434.82">def setDefaultUnboundKeyAction(self, allowCommandState=True):
    k = self; c = k.c
    defaultAction = c.config.getString('top-level-unbound-key-action') or 'insert'
    defaultAction.lower()
    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command', 'insert', 'overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace(f"ignoring top_level_unbound_key_action setting: {defaultAction}")
        self.unboundKeyAction = 'insert'
    self.defaultUnboundKeyAction = self.unboundKeyAction
    k.setInputState(self.defaultUnboundKeyAction)
</t>
<t tx="ekr.20061031131434.88"></t>
<t tx="ekr.20061031131434.89">def bindKey(self, pane, shortcut, callback, commandName, modeFlag=False, tag=None):
    """
    Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict
    and k.bindingsDict.

    tag gives the source of the binding.
    
    Return True if the binding was made successfully.
    """
    k = self
    if not shortcut:
        # Don't use this method to undo bindings.
        return False
    if not k.check_bind_key(commandName, pane, shortcut):
        return False
    aList = k.bindingsDict.get(shortcut, [])
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s, stroke
        else:
            assert shortcut, g.callers()
            stroke = g.KeyStroke(binding=shortcut)
        bi = g.BindingInfo(
            kind=tag,
            pane=pane,
            func=callback,
            commandName=commandName,
            stroke=stroke)
        if shortcut:
            k.bindKeyToDict(pane, shortcut, bi)
                # Updates k.masterBindingsDict
        if shortcut and not modeFlag:
            aList = k.remove_conflicting_definitions(
                aList, commandName, pane, shortcut)
            # 2013/03/02: a real bug fix.
        aList.append(bi)
        if shortcut:
            assert stroke
            k.bindingsDict[stroke] = aList
        return True
    except Exception:  # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding', shortcut, 'to', commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey  # For compatibility
</t>
<t tx="ekr.20061031131434.9">@cmd('auto-complete')
def autoComplete(self, event=None, force=False):
    """An event handler for autocompletion."""
    c, k = self.c, self.k
    # pylint: disable=consider-using-ternary
    w = event and event.w or c.get_focus()
    self.force = force
    if k.unboundKeyAction not in ('insert', 'overwrite'):
        return
    if not force:
        # Ctrl-period does *not* insert a period,
        # but plain periods *must* be inserted!
        c.insertCharFromEvent(event)
    if c.exists:
        c.frame.updateStatusLine()
    # Allow autocompletion only in the body pane.
    if not c.widget_name(w).lower().startswith('body'):
        return
    self.language = g.scanForAtLanguage(c, c.p)
    if w and (k.enable_autocompleter or force):
        self.w = w
        self.start(event)
</t>
<t tx="ekr.20061031131434.92">def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):

    k = self
    result = []
    for bi in aList:
        if pane in ('button', 'all', bi.pane):
            k.kill_one_shortcut(shortcut)
        else:
            result.append(bi)
    return result
</t>
<t tx="ekr.20061031131434.93">def bindKeyToDict(self, pane, stroke, bi):
    """Update k.masterBindingsDict for the stroke."""
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = bi
    k.masterBindingsDict[pane] = d
</t>
<t tx="ekr.20061031131434.94">def bindOpenWith(self, d):
    """Register an open-with command."""
    k = self; c = k.c
    shortcut = d.get('shortcut') or ''
    name = d.get('name')
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = f"open-with-{name.lower()}"
    k.registerCommand(
        allowBinding=True,
        commandName=commandName,
        func=openWithCallback,
        pane='all',
        shortcut=shortcut,
    )
</t>
<t tx="ekr.20061031131434.95">def checkBindings(self):
    """
    Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course."""
    k = self; c = k.c
    if not c.config.getBool('warn-about-missing-settings'): return
    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;', '')
        if not c.config.exists(key, 'shortcut'):
            if abbrev:
                g.trace(f"No shortcut for abbrev {name} -&gt; {abbrev} = {key}")
            else:
                g.trace(f"No shortcut for {name} = {key}")
</t>
<t tx="ekr.20061031131434.96">def completeAllBindingsForWidget(self, w):
    """Make all a master gui binding for widget w."""
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
</t>
<t tx="ekr.20061031131434.97">def completeAllBindings(self, w=None):
    """
    Make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.
    """
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
</t>
<t tx="ekr.20061031131434.98">def makeAllBindings(self):
    """Make all key bindings in all of Leo's panes."""
    k = self
    k.bindingsDict = {}
    k.addModeCommands()
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    k.completeAllBindings()
    k.checkBindings()
</t>
<t tx="ekr.20061031131434.99">def initAbbrev(self):
    k = self; c = k.c; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass  # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName, key)
</t>
<t tx="ekr.20061031170011.10">def setLabelBlue(self, label, protect=True):
    """Set the minibuffer label."""
    k, w = self, self.w
    if hasattr(g.app.gui, 'set_minibuffer_label'):
        g.app.gui.set_minibuffer_label(self.c, label)
    elif w:
        w.setStyleClass('')  # normal state, not warning or error
        if label is not None:
            k.setLabel(label, protect=protect)
</t>
<t tx="ekr.20061031170011.11">def setLabelGrey(self, label=None):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_warning')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
</t>
<t tx="ekr.20061031170011.12">def updateLabel(self, event):
    """
    Mimic what would happen with the keyboard and a Text editor
    instead of plain accumulation.
    """
    k = self; c = k.c; w = self.w
    ch = event.char if event else ''
    if ch and ch not in ('\n', '\r'):
        c.widgetWantsFocusNow(w)
        i, j = w.getSelectionRange()
        ins = w.getInsertPoint()
        if i != j:
            w.delete(i, j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) &gt; len(k.mb_prefix):
                w.delete(i - 1)
                i -= 1
        else:
            w.insert(ins, ch)
            i = ins + 1
</t>
<t tx="ekr.20061031170011.13">def getEditableTextRange(self):
    k = self; w = self.w
    s = w.getAllText()
    i = len(k.mb_prefix)
    j = len(s)
    return i, j
</t>
<t tx="ekr.20061031170011.3"># These may be overridden, but this code is now gui-independent.
</t>
<t tx="ekr.20061031170011.5">def getLabel(self, ignorePrompt=False):
    k = self; w = self.w
    if not w: return ''
    s = w.getAllText()
    if ignorePrompt:
        return s[len(k.mb_prefix) :]
    return s or ''
</t>
<t tx="ekr.20061031170011.6">def protectLabel(self):
    k = self; w = self.w
    if not w: return
    k.mb_prefix = w.getAllText()
</t>
<t tx="ekr.20061031170011.7">def resetLabel(self):
    """Reset the minibuffer label."""
    k = self
    c, w = k.c, k.w
    k.setLabelGrey('')
    k.mb_prefix = ''
    if w:
        w.setSelectionRange(0, 0, insert=0)
        state = k.unboundKeyAction
        if c.vim_mode and c.vimCommands:
            c.vimCommands.show_status()
        else:
            k.setLabelBlue(label=f"{state.capitalize()} State")
</t>
<t tx="ekr.20061031170011.8">def setLabel(self, s, protect=False):
    """Set the label of the minibuffer."""
    c, k, w = self.c, self, self.w
    if w:
        # Support for the curses gui.
        if hasattr(g.app.gui, 'set_minibuffer_label'):
            g.app.gui.set_minibuffer_label(c, s)
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n, n, insert=n)
        if protect:
            k.mb_prefix = s
</t>
<t tx="ekr.20061031170011.9">def extendLabel(self, s, select=False, protect=False):

    k = self; c = k.c; w = self.w
    if not (w and s):
        return
    c.widgetWantsFocusNow(w)
    w.insert('end', s)
    if select:
        i, j = k.getEditableTextRange()
        w.setSelectionRange(i, j, insert=j)
    if protect:
        k.protectLabel()
</t>
<t tx="ekr.20061101071425">def oops(self):

    g.trace('Should be defined in subclass:', g.callers(4))
</t>
<t tx="ekr.20070130115927.6">@cmd('cut-text')
def cutText(self, event=None):
    """Invoked from the mini-buffer and from shortcuts."""
    f = self; c = f.c; w = event and event.widget
    if not w or not g.isTextWrapper(w):
        return
    name = c.widget_name(w)
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    i, j = w.getSelectionRange()
    # Update the widget and set the clipboard text.
    s = w.get(i, j)
    if i != j:
        w.delete(i, j)
        w.see(i)  # 2016/01/19: important
        g.app.gui.replaceClipboardWith(s)
    else:
        ins = w.getInsertPoint()
        i, j = g.getLine(oldText, ins)
        s = w.get(i, j)
        w.delete(i, j)
        w.see(i)  # 2016/01/19: important
        g.app.gui.replaceClipboardWith(s)
    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut', oldSel=oldSel)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        s = w.getAllText()
        # 2011/11/14: Not used at present.
        # width = f.tree.headWidth(p=None,s=s)
        # w.setWidth(width)
    else: pass

OnCutFromMenu = cutText
</t>
<t tx="ekr.20070130115927.7">@cmd('paste-text')
def pasteText(self, event=None, middleButton=False):
    """
    Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.
    """
    c = self.c
    w = event and event.widget
    wname = c.widget_name(w)
    if not w or not g.isTextWrapper(w):
        return
    if self.cursorStay and wname.startswith('body'):
        tCurPosition = w.getInsertPoint()
    i, j = oldSel = w.getSelectionRange()
        # Returns insert point if no selection.
    if middleButton and c.k.previousSelection is not None:
        start, end = c.k.previousSelection
        s = w.getAllText()
        s = s[start:end]
        c.k.previousSelection = None
    else:
        s = g.app.gui.getTextFromClipboard()
    s = g.checkUnicode(s)
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s[-1] in ('\n', '\r'):
            s = s[:-1]
    # Save the horizontal scroll position.
    if hasattr(w, 'getXScrollPosition'):
        x_pos = w.getXScrollPosition()
    # Update the widget.
    if i != j:
        w.delete(i, j)
    w.insert(i, s)
    w.see(i + len(s) + 2)
    if wname.startswith('body'):
        if self.cursorStay:
            if tCurPosition == j:
                offset = len(s) - (j - i)
            else:
                offset = 0
            newCurPosition = tCurPosition + offset
            w.setSelectionRange(i=newCurPosition, j=newCurPosition)
        c.frame.body.onBodyChanged('Paste', oldSel=oldSel)
    elif singleLine:
        s = w.getAllText()
        while s and s[-1] in ('\n', '\r'):
            s = s[:-1]
        # 2011/11/14: headline width methods do nothing at present.
        # if wname.startswith('head'):
            # The headline is not officially changed yet.
            # p.initHeadString(s)
            # width = f.tree.headWidth(p=None,s=s)
            # w.setWidth(width)
    else:
        pass
    # Never scroll horizontally.
    if hasattr(w, 'getXScrollPosition'):
        w.setXScrollPosition(x_pos)

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20070218130238">def dumpMasterBindingsDict(self):
    """Dump k.masterBindingsDict."""
    k = self; d = k.masterBindingsDict
    g.pr('\nk.masterBindingsDict...\n')
    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            bi = d2.get(key2)
            g.pr(f"{key2:20} {bi.commandName}")
</t>
<t tx="ekr.20070613133500">def menuCommandKey(self, event=None):
    # This method must exist, but it never gets called.
    pass
</t>
<t tx="ekr.20070713075352">def scanUnknownFileType(self, s, p, ext):
    """Scan the text of an unknown file type."""
    body = ''
    if ext in ('.html', '.htm'): body += '@language html\n'
    elif ext in ('.txt', '.text'): body += '@nocolor\n'
    else:
        language = self.languageForExtension(ext)
        if language: body += f"@language {language}\n"
    self.setBodyString(p, body + self.rootLine + s)
    for p in p.self_and_subtree():
        p.clearDirty()
    g.app.unitTestDict = {'result': True}
    return True
</t>
<t tx="ekr.20070909100252">def readOneAtAutoNode(self, fileName, p):
    '''Read an @auto file into p. Return the *new* position.'''
    at, c, ic = self, self.c, self.c.importCommands
    # #1521 &amp; #1341.
    fileName = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fileName)
    if not g.os_path_exists(fileName):
        g.error(f"not found: {p.h!r}", nodeLink=p.get_UNL(with_proto=True))
        return p
    # Remember that we have seen the @auto node.
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName, p)
    # if not g.unitTesting: g.es("reading:", p.h)
    try:
        # For #451: return p.
        old_p = p.copy()
        at.scanAllDirectives(
            p,
            forcePythonSentinels=False,
            importing=True,
            reading=True,
        )
        p.v.b = ''  # Required for @auto API checks.
        p.v._deleteAllChildren()
        p = ic.createOutline(fileName, parent=p.copy())
        # Do *not* select a postion here.
        # That would improperly expand nodes.
            # c.selectPosition(p)
    except Exception:
        p = old_p
        ic.errors += 1
        g.es_print('Unexpected exception importing', fileName)
        g.es_exception()
    if ic.errors:
        g.error(f"errors inhibited read @auto {fileName}")
    elif c.persistenceController:
        c.persistenceController.update_after_read_foreign_file(p)
    # Finish.
    if ic.errors or not g.os_path_exists(fileName):
        p.clearDirty()
    else:
        g.doHook('after-auto', c=c, p=p)
    return p
</t>
<t tx="ekr.20071015110830">def initCodeBlockString(self,p):

    # New in Leo 4.4.4: do this here, not in initWrite:
    c = self.c
    d = c.scanAllDirectives(p)
    language = d.get('language')
    if language is None:
        language = 'python'
    else:
        language = language.lower()
    syntax = SilverCity is not None
    s = self.getOption('code_block_string')
    if s:
        self.code_block_string = s.replace('\\n','\n')
    elif syntax and language in ('python','ruby','perl','c'):
        self.code_block_string = '**code**:\n\n.. code-block:: %s\n' % language.title()
    else:
        self.code_block_string = '**code**:\n\n.. class:: code\n..\n\n::\n'
</t>
<t tx="ekr.20071113084440"># These plugins are for testing Leo's own plugin loading logic.
# There is no reason ever to enable these plugins.</t>
<t tx="ekr.20071115061253">def writePreformat (self,p):

    '''Write p's body text lines as if preformatted.

     ::

        line 1
        line 2 etc.
    '''
    lines = p.b.split('\n')
    lines = [' '*4 + z for z in lines]
    lines.insert(0,'::\n')
    s = '\n'.join(lines)
    if s.strip():
        self.write('%s\n\n' % s)
</t>
<t tx="ekr.20071212104050">def overrideCommand(self, commandName, func):
    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            bi = d2.get(key2)
            if bi.commandName == commandName:
                bi.func = func
                d2[key2] = bi
</t>
<t tx="ekr.20080408060320.790">def selectAll(self):
    """Select all the user-editable text of the minibuffer."""
    w = self.w
    i, j = self.getEditableTextRange()
    w.setSelectionRange(i, j, insert=j)
</t>
<t tx="ekr.20080408060320.791">def killLine(self, protect=True):
    k = self
    w = k.w
    s = w.getAllText()
    s = s[: len(k.mb_prefix)]
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n, n, insert=n)
    if protect:
        k.mb_prefix = s
</t>
<t tx="ekr.20080412053100.5">@language rest
</t>
<t tx="ekr.20080509064108.6">def defineSingleLineCommands(self):
    k = self
    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home',  # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
            # 'negative-argument',
            # 'number-command',
            # 'number-command-0',
            # 'number-command-1',
            # 'number-command-2',
            # 'number-command-3',
            # 'number-command-4',
            # 'number-command-5',
            # 'number-command-6',
            # 'number-command-7',
            # 'number-command-8',
            # 'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere',  # 2011/06/07
        'set-find-node-only',  # 2011/06/07
        'set-find-suboutline-only',  # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    ]
</t>
<t tx="ekr.20080509064108.7">def defineMultiLineCommands(self):
    k = self
    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
</t>
<t tx="ekr.20080510153327.2">def setLabelRed(self, label=None, protect=False):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_error')
    if label is not None:
        k.setLabel(label, protect)
</t>
<t tx="ekr.20080511122507.4">def setDefaultInputState(self):
    k = self; state = k.defaultUnboundKeyAction
    k.setInputState(state)
</t>
<t tx="ekr.20080708094444.36">def propagate_changes(self, old_public_file, old_private_file):
    """
    Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)
    """
    x, at = self, self.c.atFileCommands
    at.errors = 0
    self.encoding = at.encoding
    s = at.readFileToUnicode(old_private_file)
        # Sets at.encoding and inits at.readLines.
    old_private_lines = g.splitLines(s or '')  # #1466.
    s = at.readFileToUnicode(old_public_file)
    if at.encoding != self.encoding:
        g.trace(f"can not happen: encoding mismatch: {at.encoding} {self.encoding}")
        at.encoding = self.encoding
    old_public_lines = g.splitLines(s)
    if 0:
        g.trace(f"\nprivate lines...{old_private_file}")
        for s in old_private_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
        g.trace(f"\npublic lines...{old_public_file}")
        for s in old_public_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
    marker = x.markerFromFileLines(old_private_lines, old_private_file)
    new_private_lines = x.propagate_changed_lines(
        old_public_lines, old_private_lines, marker)
    # Important bug fix: Never create the private file here!
    fn = old_private_file
    exists = g.os_path_exists(fn)
    different = new_private_lines != old_private_lines
    copy = exists and different
    # 2010/01/07: check at.errors also.
    if copy and x.errors == 0 and at.errors == 0:
        s = ''.join(new_private_lines)
        x.replaceFileWithString(at.encoding, fn, s)
    return copy
</t>
<t tx="ekr.20080708094444.38">def propagate_changed_lines(
    self, new_public_lines, old_private_lines, marker, p=None):
    &lt;&lt; docstring &gt;&gt;
    x = self
    x.init_ivars(new_public_lines, old_private_lines, marker)
    sm = difflib.SequenceMatcher(None, x.a, x.b)
    # Ensure leading sentinels are put first.
    x.put_sentinels(0)
    x.sentinels[0] = []
    for tag, ai, aj, bi, bj in sm.get_opcodes():
        f = x.dispatch_dict.get(tag, x.op_bad)
        f(tag, ai, aj, bi, bj)
    # Put the trailing sentinels &amp; check the result.
    x.results.extend(x.trailing_sentinels)
    # check_output is likely to be more buggy than the code under test.
    # x.check_output()
    return x.results
</t>
<t tx="ekr.20080708094444.40">def init_ivars(self, new_public_lines, old_private_lines, marker):
    """Init all ivars used by propagate_changed_lines &amp; its helpers."""
    x = self
    x.delim1, x.delim2 = marker.getDelims()
    x.marker = marker
    x.old_sent_lines = old_private_lines
    x.results = []
    x.verbatim_line = f"{x.delim1}@verbatim{x.delim2}\n"
    old_public_lines = x.init_data()
    x.b = x.preprocess(new_public_lines)
    x.a = x.preprocess(old_public_lines)
</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20080811174246.1">def languageForExtension(self, ext):
    """Return the language corresponding to the extension ext."""
    unknown = 'unknown_language'
    if ext.startswith('.'): ext = ext[1:]
    if ext:
        z = g.app.extra_extension_dict.get(ext)
        if z not in (None, 'none', 'None'):
            language = z
        else:
            language = g.app.extension_dict.get(ext)
        if language in (None, 'none', 'None'):
            language = unknown
    else:
        language = unknown
    # Return the language even if there is no colorizer mode for it.
    return language
</t>
<t tx="ekr.20090110073010.1">@cmd('redraw')
def redraw_command(self, event):
    c = event.get('c')
    if c:
        c.redraw()

def redraw(self, p=None):
    """Redraw the screen immediately."""
    c = self
    # New in Leo 5.6: clear the redraw request.
    c.requestLaterRedraw = False
    if not p:
        p = c.p or c.rootPosition()
    if not p:
        return
    c.expandAllAncestors(p)
    if p:
        # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1183855
        # This looks redundant, but it is probably the only safe fix.
        c.frame.tree.select(p)
    # tree.redraw will change the position if p is a hoisted @chapter node.
    p2 = c.frame.tree.redraw(p)
    # Be careful.  NullTree.redraw returns None.
    # #503: NullTree.redraw(p) now returns p.
    c.selectPosition(p2 or p)
    # Do not call treeFocusHelper here.
        # c.treeFocusHelper()
    # Clear the redraw request, again.
    c.requestLaterRedraw = False

# Compatibility with old scripts

force_redraw = redraw
redraw_now = redraw
</t>
<t tx="ekr.20090122201952.4">def appendStringToBody(self, p, s):
    """Similar to c.appendStringToBody,
    but does not recolor the text or redraw the screen."""
    if s:
        p.b = p.b + g.toUnicode(s, self.encoding)

def setBodyString(self, p, s):
    """
    Similar to c.setBodyString, but does not recolor the text or
    redraw the screen.
    """
    c, v = self.c, p.v
    if not c or not p:
        return
    s = g.toUnicode(s, self.encoding)
    if c.p and p.v == c.p.v:
        w = c.frame.body.wrapper
        i = len(s)
        w.setAllText(s)
        w.setSelectionRange(i, i, insert=i)
    # Keep the body text up-to-date.
    if v.b != s:
        v.setBodyString(s)
        v.setSelection(0, 0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged()
</t>
<t tx="ekr.20090128083459.74"></t>
<t tx="ekr.20090128083459.75">def __get_b(self):
    """Return the body text of a position."""
    p = self
    return p.bodyString()

def __set_b(self, val):
    """
    Set the body text of a position.

    **Warning: the p.b = whatever is *expensive* because it calls
    c.setBodyString().

    Usually, code *should* use this setter, despite its cost, because it
    update's Leo's outline pane properly. Calling c.redraw() is *not*
    enough.

    This performance gotcha becomes important for repetitive commands, like
    cff, replace-all and recursive import. In such situations, code should
    use p.v.b instead of p.b.
    """
    p = self
    c = p.v and p.v.context
    if c:
        c.setBodyString(p, val)
        # Warning: c.setBodyString is *expensive*.

b = property(
    __get_b, __set_b,
    doc="position body string property")
</t>
<t tx="ekr.20090128083459.76">def __get_h(self):
    p = self
    return p.headString()

def __set_h(self, val):
    """
    Set the headline text of a position.

    **Warning: the p.h = whatever is *expensive* because it calls
    c.setHeadString().

    Usually, code *should* use this setter, despite its cost, because it
    update's Leo's outline pane properly. Calling c.redraw() is *not*
    enough.

    This performance gotcha becomes important for repetitive commands, like
    cff, replace-all and recursive import. In such situations, code should
    use p.v.h instead of p.h.
    """
    p = self
    c = p.v and p.v.context
    if c:
        c.setHeadString(p, val)
        # Warning: c.setHeadString is *expensive*.

h = property(
    __get_h, __set_h,
    doc="position property returning the headline string")
</t>
<t tx="ekr.20090215165030.3">def __get_gnx(self):
    p = self
    return p.v.fileIndex

gnx = property(
    __get_gnx,  # __set_gnx,
    doc="position gnx property")
</t>
<t tx="ekr.20090428082801.64">def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    d = {}
    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return d

    args = s.strip()
    if args.find(',') == -1:
        args = [args]
    else:
        args = args.split(',')

    for arg in args:
        data = arg.split('=')
        if len(data) == 1:
            key = data[0]
            d[str(key)] = ""
        elif len(data) == 2:
            key,value = data
            d[str(key)] = str(value)
        else:
            g.error('bad option: %s' % s)
            break

    return d
</t>
<t tx="ekr.20090429055156.63">def runUnitTests(c):

    rstClass(c)
    p = g.findNodeAnywhere(c,'UnitTests')
    if p:
        c.selectPosition(p)
        c.testManager.doTests(all=None, marked=None, verbosity=1)
</t>
<t tx="ekr.20090514111518.5661">def checkPythonCode(self, contents, fileName, root, pyflakes_errors_only=False):
    """Perform python-related checks on root."""
    at = self
    if contents and fileName and fileName.endswith(
        '.py') and at.checkPythonCodeOnWrite:
        # It's too slow to check each node separately.
        if pyflakes_errors_only:
            ok = True
        else:
            ok = at.checkPythonSyntax(root, contents)
        # Syntax checking catches most indentation problems.
            # if ok: at.tabNannyNode(root,s)
        if ok and at.runPyFlakesOnWrite and not g.unitTesting:
            ok2 = self.runPyflakes(root, pyflakes_errors_only=pyflakes_errors_only)
        else:
            ok2 = True
        if not ok or not ok2:
            g.app.syntax_error_files.append(g.shortFileName(fileName))
</t>
<t tx="ekr.20090514111518.5663">def checkPythonSyntax(self, p, body, supress=False):
    at = self
    try:
        body = body.replace('\r', '')
        fn = f"&lt;node: {p.h}&gt;"
        compile(body + '\n', fn, 'exec')
        return True
    except SyntaxError:
        if not supress:
            at.syntaxError(p, body)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
    return False
</t>
<t tx="ekr.20090514111518.5665">def tabNannyNode(self, p, body, suppress=False):
    import parser
    import tabnanny
    import tokenize
    try:
        readline = g.ReadLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
    except parser.ParserError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("ParserError in", p.h)
        g.es('', str(msg))
    except IndentationError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("IndentationError in", p.h)
        g.es('', str(msg))
    except tokenize.TokenError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("TokenError in", p.h)
        g.es('', str(msg))
    except tabnanny.NannyNag:
        junk, nag, junk = sys.exc_info()
        if suppress:
            raise
        badline = nag.get_lineno()
        line = nag.get_line()
        message = nag.get_msg()
        g.error("indentation error in", p.h, "line", badline)
        g.es(message)
        line2 = repr(str(line))[1:-1]
        g.es("offending line:\n", line2)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        if suppress: raise
</t>
<t tx="ekr.20090514111518.5666">def syntaxError(self, p, body):
    """Report a syntax error."""
    g.error(f"Syntax error in: {p.h}")
    typ, val, tb = sys.exc_info()
    message = hasattr(val, 'message') and val.message
    if message: g.es_print(message)
    if val is None: return
    lines = g.splitLines(body)
    n = val.lineno
    offset = val.offset or 0
    if n is None: return
    i = val.lineno - 1
    for j in range(max(0, i - 2), min(i + 2, len(lines) - 1)):
        if j == i:
            mark = '*'
            node_link = f"{p.get_UNL(with_proto=True, with_count=True)},-{j+1:d}"
        else:
            mark = ' '
            node_link = None
        text = f"{j+1:5}:{mark} {lines[j].rstrip()}"
        g.es_print(text, nodeLink=node_link)
        if j == i:
            g.es_print(' ' * (7 + offset) + '^')
</t>
<t tx="ekr.20090518072506.8494">def isFKey(self, stroke):
    # k = self
    if not stroke: return False
    assert isinstance(stroke, str) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) &lt;= 3 and s[1:].isdigit()
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20091230094319.6240">def getPaneBinding(self, event):

    c, k, state = self.c, self, self.unboundKeyAction
    stroke, w = event.stroke, event.w
    if not g.assert_is(stroke, g.KeyStroke):
        return None
    #
    # #1757: Always insert plain keys in the body.
    #        Valid because mode bindings have already been handled.
    if (
        k.isPlainKey(stroke)
        and w == c.frame.body.widget
        and state in ('insert', 'overwrite')
    ):
        return None
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'),  # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        bi = k.getBindingHelper(key, name, stroke, w)
        if bi:
            return bi
    return None
</t>
<t tx="ekr.20091230094319.6244">def doMode(self, event):
    """
    Handle mode bindings.
    Return True if k.masterKeyHandler should return.
    """
    #
    # #1757: Leo's default vim bindings make heavy use of modes.
    #        Retain these traces!
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    k = self
    state = k.state.kind
    stroke = event.stroke
    if not k.inState():
        return False
    #
    # First, honor minibuffer bindings for all except user modes.
    if state == 'input-shortcut':
        k.handleInputShortcut(event, stroke)
        if trace: g.trace(state, 'k.handleInputShortcut', stroke)
        return True
    if state in (
        'getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'
    ):
        if k.handleMiniBindings(event, state, stroke):
            if trace: g.trace(state, 'k.handleMiniBindings', stroke)
            return True
    #
    # Second, honor general modes.
    #
    if state == 'getArg':
        # New in Leo 5.8: Only call k.getArg for keys it can handle.
        if k.isPlainKey(stroke):
            k.getArg(event, stroke=stroke)
            if trace: g.trace(state, 'k.isPlain: getArg', stroke)
            return True
        if stroke.s in ('Escape', 'Tab', 'BackSpace'):
            k.getArg(event, stroke=stroke)
            if trace: g.trace(state, f"{stroke.s!r}: getArg", stroke)
            return True
        return False
    if state in ('getFileName', 'get-file-name'):
        k.getFileName(event)
        if trace: g.trace(state, 'k.getFileName', stroke)
        return True
    if state in ('full-command', 'auto-complete'):
        val = k.callStateFunction(event)
            # Do the default state action.
            # Calls end-command.
        if val != 'do-standard-keys':
            handler = k.state.handler and k.state.handler.__name__ or '&lt;no handler&gt;'
            if trace: g.trace(state, 'k.callStateFunction:', handler, stroke)
            return True
        return False
    #
    # Third, pass keys to user modes.
    #
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        bi = d.get(stroke)
        if bi:
            # Bound keys continue the mode.
            k.generalModeHandler(event,
                commandName=bi.commandName,
                func=bi.func,
                modeName=state,
                nextMode=bi.nextMode)
            if trace: g.trace(state, 'k.generalModeHandler', stroke)
            return True
        # Unbound keys end mode.
        k.endMode()
        return False
    #
    # Fourth, call the state handler.
    #
    handler = k.getStateHandler()
    if handler:
        handler(event)
    if trace:
        handler_name = handler and handler.__name__ or '&lt;no handler&gt;'
        g.trace(state, 'handler:', handler_name, stroke)
    return True
</t>
<t tx="ekr.20100103093121.5365"># These are experimental plugins.
</t>
<t tx="ekr.20100124110832.6212">def propegateDirtyNodes(self):
    fc = self; c = fc.c
    aList = [z for z in c.all_positions() if z.isDirty()]
    for p in aList:
        p.setAllAncestorAtFileNodesDirty()
</t>
<t tx="ekr.20100205060712.8314">def handleNodeConflicts(self):
    """Create a 'Recovered Nodes' node for each entry in c.nodeConflictList."""
    c = self.c
    if not c.nodeConflictList:
        return None
    if not c.make_node_conflicts_node:
        s = f"suppressed {len(c.nodeConflictList)} node conflicts"
        g.es(s, color='red')
        g.pr('\n' + s + '\n')
        return None
    # Create the 'Recovered Nodes' node.
    last = c.lastTopLevel()
    root = last.insertAfter()
    root.setHeadString('Recovered Nodes')
    root.expand()
    # For each conflict, create one child and two grandchildren.
    for bunch in c.nodeConflictList:
        tag = bunch.get('tag') or ''
        gnx = bunch.get('gnx') or ''
        fn = bunch.get('fileName') or ''
        b1, h1 = bunch.get('b_old'), bunch.get('h_old')
        b2, h2 = bunch.get('b_new'), bunch.get('h_new')
        root_v = bunch.get('root_v') or ''
        child = root.insertAsLastChild()
        h = f'Recovered node "{h1}" from {g.shortFileName(fn)}'
        child.setHeadString(h)
        if b1 == b2:
            lines = [
                'Headline changed...',
                f"{tag} gnx: {gnx} root: {(root_v and root.v)!r}",
                f"old headline: {h1}",
                f"new headline: {h2}",
            ]
            child.setBodyString('\n'.join(lines))
        else:
            line1 = f"{tag} gnx: {gnx} root: {root_v and root.v!r}\nDiff...\n"
            d = difflib.Differ().compare(g.splitLines(b1), g.splitLines(b2))
                # 2017/06/19: reverse comparison order.
            diffLines = [z for z in d]
            lines = [line1]
            lines.extend(diffLines)
            # There is less need to show trailing newlines because
            # we don't report changes involving only trailing newlines.
            child.setBodyString(''.join(lines))
            n1 = child.insertAsNthChild(0)
            n2 = child.insertAsNthChild(1)
            n1.setHeadString('old:' + h1)
            n1.setBodyString(b1)
            n2.setHeadString('new:' + h2)
            n2.setBodyString(b2)
    return root
</t>
<t tx="ekr.20101004082701.5674"></t>
<t tx="ekr.20101101175644.5891">def put(self, *args, **keys):
    """Put s to the given tab.

    May be overridden in subclasses."""
    # print('autoCompleter.put',args,keys)
    if g.unitTesting:
        pass
    else:
        g.es(*args, **keys)
</t>
<t tx="ekr.20101110150056.9453"># Some of the most important recent plugins work only with the Qt gui.
</t>
<t tx="ekr.20101110150056.9457"></t>
<t tx="ekr.20110202111105.15439">def showStateCursor(self, state, w):
    pass
</t>
<t tx="ekr.20110209093958.15411">def setEditingState(self):
    k = self; state = k.defaultEditingAction
    k.setInputState(state)
</t>
<t tx="ekr.20110209093958.15413">def setDefaultEditingAction(self):
    k = self; c = k.c
    action = c.config.getString('default-editing-state') or 'insert'
    action.lower()
    if action not in ('command', 'insert', 'overwrite'):
        g.trace(f"ignoring default_editing_state: {action}")
        action = 'insert'
    self.defaultEditingAction = action
</t>
<t tx="ekr.20110314115639.14269">def is_leo_source_file(self):
    """Return True if this is one of Leo's source files."""
    c = self.c
    table = (z.lower() for z in (
        'leoDocs.leo',
        'LeoGui.leo', 'LeoGuiPluginsRef.leo',
        # 'leoPlugins.leo', 'leoPluginsRef.leo',
        'leoPy.leo', 'leoPyRef.leo',
        'myLeoSettings.leo', 'leoSettings.leo',
        'ekr.leo',
        # 'test.leo',
    ))
    return c.shortFileName().lower() in table
</t>
<t tx="ekr.20110509064011.14556">def attr_matches(self, s, namespace):
    """Compute matches when string s is of the form name.name....name.

    Evaluates s using eval(s,namespace)

    Assuming the text is of the form NAME.NAME....[NAME], and is evaluatable in
    the namespace, it will be evaluated and its attributes (as revealed by
    dir()) are used as possible completions.

    For class instances, class members are are also considered.)

    **Warning**: this can still invoke arbitrary C code, if an object
    with a __getattr__ hook is evaluated.

    """
    # Seems to work great. Catches things like ''.&lt;tab&gt;
    m = re.match(r"(\S+(\.\w+)*)\.(\w*)$", s)
    if not m:
        return []
    expr, attr = m.group(1, 3)
    try:
        safe_expr = self.strip_brackets(expr)
        obj = eval(safe_expr, namespace)
    except Exception:
        return []
    # Build the result.
    words = dir(obj)
    n = len(attr)
    result = [f"{expr}.{w}" for w in words if w[:n] == attr]
    return result
</t>
<t tx="ekr.20110509064011.14557">def get_leo_completions(self, prefix):
    """Return completions in an environment defining c, g and p."""
    aList = []
    for d in self.namespaces + [self.get_leo_namespace(prefix)]:
        aList.extend(self.attr_matches(prefix, d))
    aList.sort()
    return aList
</t>
<t tx="ekr.20110509064011.14561">def get_autocompleter_prefix(self):
    # Only the body pane supports auto-completion.
    w = self.c.frame.body.wrapper
    s = w.getAllText()
    if not s: return ''
    i = w.getInsertPoint() - 1
    i = j = max(0, i)
    while i &gt;= 0 and (s[i].isalnum() or s[i] in '._'):
        i -= 1
    i += 1
    j += 1
    prefix = s[i:j]
    return prefix
</t>
<t tx="ekr.20110510071925.14586">def init_qcompleter(self, event=None):

    # Compute the prefix and the list of options.
    prefix = self.get_autocompleter_prefix()
    options = self.get_completions(prefix)
    w = self.c.frame.body.wrapper.widget
        # A LeoQTextBrowser.  May be none for unit tests.
    if w and options:
        self.qw = w
        self.qcompleter = w.init_completer(options)
        self.auto_completer_state_handler(event)
    else:
        if not g.unitTesting:
            g.warning('No completions')
        self.exit()
</t>
<t tx="ekr.20110510120621.14539">def get_codewise_completions(self, prefix):
    """Use codewise to generate a list of hits."""
    c = self.c
    m = re.match(r"(\S+(\.\w+)*)\.(\w*)$", prefix)
    if m:
        varname = m.group(1)
        ivar = m.group(3)
        kind, aList = self.guess_class(c, varname)
    else:
        kind, aList = 'none', []
        varname, ivar = None, None
    if aList:
        if kind == 'class':
            hits = self.lookup_methods(aList, ivar)
            hits.extend(self.codewiseSelfList)
        elif kind == 'module':
            hits = self.lookup_modules(aList, ivar)
    else:
        aList2 = prefix.split('.')
        if aList2:
            func = aList2[-1]
            hits = self.lookup_functions(func)
        else:
            hits = []
    if 1:  # A kludge: add the prefix to each hit.
        hits = [f"{varname}.{z}" for z in hits]
    return hits
</t>
<t tx="ekr.20110510120621.14540">def clean(self, hits):
    """Clean up hits, a list of ctags patterns, for use in completion lists."""
    # Just take the function name: ignore the signature &amp; file.
    aList = list(set([z[0] for z in hits]))
    aList.sort()
    return aList
</t>
<t tx="ekr.20110510120621.14542">def guess_class(self, c, varname):
    """Return kind, class_list"""
    # if varname == 'g':
        # return 'module',['leoGlobals']
    if varname == 'p':
        return 'class', ['position']
    if varname == 'c':
        return 'class', ['Commands']
    if varname == 'self':
        # Return the nearest enclosing class.
        for p in c.p.parents():
            h = p.h
            m = re.search(r'class\s+(\w+)', h)
            if m:
                return 'class', [m.group(1)]
    if 1:
        aList = []
    else:
        # This is not needed now that we add the completions for 'self'.
        aList = ContextSniffer().get_classes(c.p.b, varname)
    return 'class', aList
</t>
<t tx="ekr.20110510120621.14543">def lookup_functions(self, prefix):
    aList = codewise.cmd_functions([prefix])
    hits = [z.split(None, 1) for z in aList if z.strip()]
    return self.clean(hits)

def lookup_methods(self, aList, prefix):  # prefix not used, only aList[0] used.
    aList = codewise.cmd_members([aList[0]])
    hits = [z.split(None, 1) for z in aList if z.strip()]
    return self.clean(hits)

def lookup_modules(self, aList, prefix):  # prefix not used, only aList[0] used.
    aList = codewise.cmd_functions([aList[0]])
    hits = [z.split(None, 1) for z in aList if z.strip()]
    return self.clean(hits)
</t>
<t tx="ekr.20110510133719.14548">def do_qcompleter_tab(self, prefix, options):
    """Return the longest common prefix of all the options."""
    matches, common_prefix = g.itemsMatchingPrefixInList(
        prefix, options, matchEmptyPrefix=False)
    return common_prefix
</t>
<t tx="ekr.20110511133940.14552">def init_tabcompleter(self, event=None):
    # Compute the prefix and the list of options.
    prefix = self.get_autocompleter_prefix()
    options = self.get_completions(prefix)
    if options:
        self.clearTabName()  # Creates the tabbed pane.
        self.auto_completer_state_handler(event)
    else:
        g.warning('No completions')
        self.exit()
</t>
<t tx="ekr.20110511133940.14561">def show_completion_list(self, common_prefix, prefix, tabList):

    c = self.c
    aList = common_prefix.split('.')
    header = '.'.join(aList[:-1])
    # "!" toggles self.verbose.
    if self.verbose or self.use_qcompleter or len(tabList) &lt; 20:
        tabList = self.clean_completion_list(header, tabList,)
    else:
        tabList = self.get_summary_list(header, tabList)
    if self.use_qcompleter:
        # Put the completions in the QListView.
        if self.qw:
            self.qw.show_completions(tabList)
    else:
        # Update the tab name, creating the tab if necessary.
        c.widgetWantsFocus(self.w)
        c.frame.log.clearTab(self.tabName)
        self.beginTabName(header + '.' if header else '')
        s = '\n'.join(tabList)
        self.put('', s, tabName=self.tabName)
</t>
<t tx="ekr.20110512090917.14466">def get_leo_namespace(self, prefix):
    """
    Return an environment in which to evaluate prefix.
    Add some common standard library modules as needed.
    """
    k = self.k
    d = {'c': k.c, 'p': k.c.p, 'g': g}
    aList = prefix.split('.')
    if len(aList) &gt; 1:
        name = aList[0]
        m = sys.modules.get(name)
        if m:
            d[name] = m
    return d
</t>
<t tx="ekr.20110512090917.14468">def calltip_fail(self, prefix):
    """Evaluation of prefix failed."""
    self.insert_string('(')
</t>
<t tx="ekr.20110512090917.14469">def calltip_success(self, prefix, obj):
    try:
        # Get the parenthesized argument list.
        s1, s2, s3, s4 = inspect.getargspec(obj)
        s = inspect.formatargspec(s1, s2, s3, s4)
    except Exception:
        self.insert_string('(')
        return
    # Clean s and insert it: don't include the opening "(".
    if g.match(s, 1, 'self,'):
        s = s[6:].strip()
    elif g.match_word(s, 1, 'self'):
        s = s[5:].strip()
    else:
        s = s[1:].strip()
    self.insert_string("(", select=False)
    self.insert_string(s, select=True)
</t>
<t tx="ekr.20110512170111.14471">def strip_brackets(self, s):
    """Return s with all brackets removed.

    This (mostly) ensures that eval will not execute function calls, etc.
    """
    for ch in '[]{}()':
        s = s.replace(ch, '')
    return s
</t>
<t tx="ekr.20110512170111.14472">def get_object(self):
    """Return the object corresponding to the current prefix."""
    common_prefix, prefix1, aList = self.compute_completion_list()
    if not aList:
        return None, prefix1
    if len(aList) == 1:
        prefix = aList[0]
    else:
        prefix = common_prefix
    if prefix.endswith('.') and self.use_qcompleter:
        prefix += self.qcompleter.get_selection()
    safe_prefix = self.strip_brackets(prefix)
    for d in self.namespaces + [self.get_leo_namespace(prefix)]:
        try:
            obj = eval(safe_prefix, d)
            break  # only reached if none of the exceptions below occur
        except AttributeError:
            obj = None
        except NameError:
            obj = None
        except SyntaxError:
            obj = None
        except Exception:
            g.es_exception()
            obj = None
    return obj, prefix
</t>
<t tx="ekr.20110512212836.14469">def exit(self):

    trace = all(z in g.app.debug for z in ('abbrev', 'verbose'))
    if trace: g.trace('(AutoCompleterClass)')
    c, p, u = self.c, self.c.p, self.c.undoer
    w = self.w or c.frame.body.wrapper
    c.k.keyboardQuit()
    if self.use_qcompleter:
        if self.qw:
            self.qw.end_completer()
            self.qw = None  # Bug fix: 2013/09/24.
    else:
        for name in (self.tabName, 'Modules', 'Info'):
            c.frame.log.deleteTab(name)
    # Restore the selection range that may have been destroyed by changing tabs.
    c.widgetWantsFocusNow(w)
    i, j = w.getSelectionRange()
    w.setSelectionRange(i, j, insert=j)
    newText = w.getAllText()
    if p.b == newText:
        return
    bunch = u.beforeChangeBody(p)
    p.v.b = newText  # p.b would cause a redraw.
    u.afterChangeBody(p, 'auto-completer', bunch)

finish = exit
abort = exit
</t>
<t tx="ekr.20110512212836.14471">jedi_warning = False

def get_completions(self, prefix):
    """Return jedi or codewise completions."""
    d = self.completionsDict
    if self.use_jedi:
        try:
            import jedi
        except ImportError:
            if not self.jedi_warning:
                self.jedi_warning = False
                g.es_print('can not import jedi')
                g.es_print('ignoring @bool use_jedi = True')
        if jedi:
            aList = (
                self.get_jedi_completions(prefix) or
                    # Prefer the jedi completions.
                self.get_leo_completions(prefix))
            d[prefix] = aList
            return aList
    #
    # Not jedi. Use codewise.
    # Precompute the codewise completions for '.self'.
    if not self.codewiseSelfList:
        aList = self.get_codewise_completions('self.')
        self.codewiseSelfList = [z[5:] for z in aList]
        d['self.'] = self.codewiseSelfList
    # Use the cached list if it exists.
    aList = d.get(prefix)
    if aList:
        return aList
    aList = (
        self.get_leo_completions(prefix) or
            # Prefer the Leo completions.
        self.get_codewise_completions(prefix)
    )
    d[prefix] = aList
    return aList
</t>
<t tx="ekr.20110512232915.14481">def clean_for_display(self, hits):
    """Clean up hits, a list of ctags patterns, for display purposes."""
    aList = []
    for h in hits:
        s = h[0]
        # Display oriented: no good for completion list.
        fn = h[1].strip()
        if fn.startswith('/'):
            sig = fn[2:-4].strip()
        else:
            sig = fn
        aList.append(f"{s}: {sig}")
    aList = list(set(aList))
    aList.sort()
    return aList
</t>
<t tx="ekr.20110513104728.14453">def clean_completion_list(self, header, tabList):
    """Return aList with header removed from the start of each list item."""
    return [
        z[len(header) + 1 :] if z.startswith(header) else z
            for z in tabList]
</t>
<t tx="ekr.20110513104728.14454">def get_summary_list(self, header, tabList):
    """Show the possible starting letters,
    but only if there are more than one.
    """
    d = {}
    for z in tabList:
        tail = z[len(header) :] if z else ''
        if tail.startswith('.'): tail = tail[1:]
        ch = tail[0] if tail else ''
        if ch:
            n = d.get(ch, 0)
            d[ch] = n + 1
    aList = [f"{ch2} {d.get(ch2)}" for ch2 in sorted(d)]
    if len(aList) &gt; 1:
        tabList = aList
    else:
        tabList = self.clean_completion_list(header, tabList)
    return tabList
</t>
<t tx="ekr.20110514051607.14524">def get_cached_options(self, prefix):
    d = self.completionsDict
    # Search the completions Dict for shorter and shorter prefixes.
    i = len(prefix)
    while i &gt; 0:
        key = prefix[:i]
        i -= 1
        # Make sure we report hits only of real objects.
        if key.endswith('.'):
            return key, []
        options = d.get(key)
        if options:
            return key, options
    return None, []
</t>
<t tx="ekr.20110530124245.18248">def looksLikeDerivedFile(self, fn):
    """
    Return True if fn names a file that looks like an
    external file written by Leo.
    """
    # c = self
    try:
        with open(fn, 'rb') as f:  # 2020/11/14: Allow unicode characters!
            s = f.read()
            s = g.toUnicode(s)
        return s.find('@+leo-ver=') &gt; -1
    except Exception:
        g.es_exception()
        return False
</t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.
</t>
<t tx="ekr.20110605121601.17875">def drawNode(self, p, parent_item):
    """Draw the node p."""
    c = self.c
    v = p.v
    # Allocate the QTreeWidgetItem.
    item = self.createTreeItem(p, parent_item)
    #
    # Update the data structures.
    itemHash = self.itemHash(item)
    self.position2itemDict[p.key()] = item
    self.item2positionDict[itemHash] = p.copy()  # was item
    self.item2vnodeDict[itemHash] = v  # was item
    d = self.vnode2itemsDict
    aList = d.get(v, [])
    if item not in aList:
        aList.append(item)
    d[v] = aList
    # Set the headline and maybe the icon.
    self.setItemText(item, p.h)
    # #1310: Add a tool tip.
    item.setToolTip(0, p.h)
    if self.use_declutter:
        icon = self.declutter_node(c, p, item)
        if icon:
            item.setIcon(0, icon)
        return item
    # Draw the icon.
    v.iconVal = v.computeIcon()
    icon = self.getCompositeIconImage(p, v.iconVal)
        # **Slow**, but allows per-vnode icons.
    if icon:
        item.setIcon(0, icon)
    return item
</t>
<t tx="ekr.20110605121601.17911">def endEditLabel(self):
    """
    Override LeoTree.endEditLabel.

    Just end editing of the presently-selected QLineEdit!
    This will trigger the editingFinished_callback defined in createEditorForItem.
    """
    item = self.getCurrentItem()
    if not item:
        return
    e = self.getTreeEditorForItem(item)
    if not e:
        return
    # Trigger the end-editing event.
    w = self.treeWidget
    w.closeEditor(e, QtWidgets.QAbstractItemDelegate.NoHint)
    w.setCurrentItem(item)
</t>
<t tx="ekr.20110605121601.18005">if QtWidgets:


    class LeoQTextBrowser(QtWidgets.QTextBrowser):
        """A subclass of QTextBrowser that overrides the mouse event handlers."""
        @others
</t>
<t tx="ekr.20110605121601.18006">def __init__(self, parent, c, wrapper):
    """ctor for LeoQTextBrowser class."""
    for attr in ('leo_c', 'leo_wrapper',):
        assert not hasattr(QtWidgets.QTextBrowser, attr), attr
    self.leo_c = c
    self.leo_s = ''  # The cached text.
    self.leo_wrapper = wrapper
    self.htmlFlag = True
    super().__init__(parent)
    self.setCursorWidth(c.config.getInt('qt-cursor-width') or 1)
    
    # Connect event handlers...
    if 0:  # Not a good idea: it will complicate delayed loading of body text.
        self.textChanged.connect(self.onTextChanged)
    # #1286
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.onContextMenu)
    # This event handler is the easy way to keep track of the vertical scroll position.
    self.leo_vsb = vsb = self.verticalScrollBar()
    vsb.valueChanged.connect(self.onSliderChanged)
    # For QCompleter
    self.leo_q_completer = None
    self.leo_options = None
    self.leo_model = None
</t>
<t tx="ekr.20110605121601.18007">def __repr__(self):
    return f"(LeoQTextBrowser) {id(self)}"

__str__ = __repr__
</t>
<t tx="ekr.20110605121601.18008"></t>
<t tx="ekr.20110605121601.18009">class LeoQListWidget(QtWidgets.QListWidget):
    @others
</t>
<t tx="ekr.20110605121601.18010">def __init__(self, c):
    """ctor for LeoQListWidget class"""
    super().__init__()
    self.setWindowFlags(QtCore.Qt.Popup | self.windowFlags())
    # Make this window a modal window.
    # Calling this does not fix the Ubuntu-specific modal behavior.
    # self.setWindowModality(QtCore.Qt.NonModal) # WindowModal)
    # Inject the ivars
    self.leo_w = c.frame.body.wrapper.widget
        # A LeoQTextBrowser, a subclass of QtWidgets.QTextBrowser.
    self.leo_c = c
    # A weird hack.
    self.leo_geom_set = False  # When true, self.geom returns global coords!
    self.itemClicked.connect(self.select_callback)
</t>
<t tx="ekr.20110605121601.18011">def closeEvent(self, event):
    """Kill completion and close the window."""
    self.leo_c.k.autoCompleter.abort()
</t>
<t tx="ekr.20110605121601.18012">def end_completer(self):
    """End completion."""
    c = self.leo_c
    c.in_qt_dialog = False
    # This is important: it clears the autocompletion state.
    c.k.keyboardQuit()
    c.bodyWantsFocusNow()
    try:
        self.deleteLater()
    except RuntimeError:
        # Avoid bug 1338773: Autocompleter error
        pass
</t>
<t tx="ekr.20110605121601.18013">def keyPressEvent(self, event):
    """Handle a key event from QListWidget."""
    c = self.leo_c
    w = c.frame.body.wrapper
    qt = QtCore.Qt
    key = event.key()
    if event.modifiers() != qt.NoModifier and not event.text():
        # A modifier key on it's own.
        pass
    elif key in (qt.Key_Up, qt.Key_Down):
        QtWidgets.QListWidget.keyPressEvent(self, event)
    elif key == qt.Key_Tab:
        self.tab_callback()
    elif key in (qt.Key_Enter, qt.Key_Return):
        self.select_callback()
    else:
        # Pass all other keys to the autocompleter via the event filter.
        w.ev_filter.eventFilter(obj=self, event=event)
</t>
<t tx="ekr.20110605121601.18014">def select_callback(self):
    """
    Called when user selects an item in the QListWidget.
    """
    c = self.leo_c
    p = c.p
    w = c.k.autoCompleter.w or c.frame.body.wrapper
    oldSel = w.getSelectionRange()
    oldText = w.getAllText()
    # Replace the tail of the prefix with the completion.
    completion = self.currentItem().text()
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &gt; 1:
        tail = parts[-1]
    else:
        tail = prefix
    if tail != completion:
        j = w.getInsertPoint()
        i = j - len(tail)
        w.delete(i, j)
        w.insert(i, completion)
        j = i + len(completion)
        c.setChanged()
        w.setInsertPoint(j)
        c.undoer.doTyping(p, 'Typing', oldText,
            newText=w.getAllText(),
            newInsert=w.getInsertPoint(),
            newSel=w.getSelectionRange(),
            oldSel=oldSel,
        )
    self.end_completer()
</t>
<t tx="ekr.20110605121601.18015">def set_position(self, c):
    """Set the position of the QListWidget."""

    def glob(obj, pt):
        """Convert pt from obj's local coordinates to global coordinates."""
        return obj.mapToGlobal(pt)

    w = self.leo_w
    vp = self.viewport()
    r = w.cursorRect()
    geom = self.geometry()  # In viewport coordinates.
    gr_topLeft = glob(w, r.topLeft())
    # As a workaround to the Qt setGeometry bug,
    # The window is destroyed instead of being hidden.
    if self.leo_geom_set:
        g.trace('Error: leo_geom_set')
        return
    # This code illustrates the Qt bug...
        # if self.leo_geom_set:
            # # Unbelievable: geom is now in *global* coords.
            # gg_topLeft = geom.topLeft()
        # else:
            # # Per documentation, geom in local (viewport) coords.
            # gg_topLeft = glob(vp,geom.topLeft())
    gg_topLeft = glob(vp, geom.topLeft())
    delta_x = gr_topLeft.x() - gg_topLeft.x()
    delta_y = gr_topLeft.y() - gg_topLeft.y()
    # These offset are reasonable. Perhaps they should depend on font size.
    x_offset, y_offset = 10, 60
    # Compute the new geometry, setting the size by hand.
    geom2_topLeft = QtCore.QPoint(
        geom.x() + delta_x + x_offset,
        geom.y() + delta_y + y_offset)
    geom2_size = QtCore.QSize(400, 100)
    geom2 = QtCore.QRect(geom2_topLeft, geom2_size)
    # These tests fail once offsets are added.
    if x_offset == 0 and y_offset == 0:
        if self.leo_geom_set:
            if geom2.topLeft() != glob(w, r.topLeft()):
                g.trace(
                    f"Error: geom.topLeft: {geom2.topLeft()}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
        else:
            if glob(vp, geom2.topLeft()) != glob(w, r.topLeft()):
                g.trace(
                    f"Error 2: geom.topLeft: {glob(vp, geom2.topLeft())}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
    self.setGeometry(geom2)
    self.leo_geom_set = True
</t>
<t tx="ekr.20110605121601.18016">def show_completions(self, aList):
    """Set the QListView contents to aList."""
    self.clear()
    self.addItems(aList)
    self.setCurrentRow(0)
    self.activateWindow()
    self.setFocus()
</t>
<t tx="ekr.20110605121601.18017">def init_completer(self, options):
    """Connect a QCompleter."""
    c = self.leo_c
    self.leo_qc = qc = self.LeoQListWidget(c)
    # Move the window near the body pane's cursor.
    qc.set_position(c)
    # Show the initial completions.
    c.in_qt_dialog = True
    qc.show()
    qc.activateWindow()
    c.widgetWantsFocusNow(qc)
    qc.show_completions(options)
    return qc
</t>
<t tx="ekr.20110605121601.18018">def end_completer(self):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.end_completer()
        delattr(self, 'leo_qc')

def show_completions(self, aList):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.show_completions(aList)
</t>
<t tx="ekr.20110605121601.18019">def leo_dumpButton(self, event, tag):

    button = event.button()
    table = (
        (QtCore.Qt.NoButton, 'no button'),
        (QtCore.Qt.LeftButton, 'left-button'),
        (QtCore.Qt.RightButton, 'right-button'),
        (QtCore.Qt.MidButton, 'middle-button'),
    )
    for val, s in table:
        if button == val:
            kind = s; break
    else:
        kind = f"unknown: {repr(button)}"
    return kind
</t>
<t tx="ekr.20110605121601.18077">def leoMoveCursorHelper(self, kind, extend=False, linesPerPage=15):
    """QTextEditWrapper."""
    w = self.widget
    tc = QtGui.QTextCursor
    d = {
        'begin-line': tc.StartOfLine,  # Was start-line
        'down': tc.Down,
        'end': tc.End,
        'end-line': tc.EndOfLine,  # Not used.
        'exchange': True,  # Dummy.
        'home': tc.Start,
        'left': tc.Left,
        'page-down': tc.Down,
        'page-up': tc.Up,
        'right': tc.Right,
        'up': tc.Up,
    }
    kind = kind.lower()
    op = d.get(kind)
    mode = tc.KeepAnchor if extend else tc.MoveAnchor
    if not op:
        g.trace(f"can not happen: bad kind: {kind}")
        return
    if kind in ('page-down', 'page-up'):
        self.pageUpDown(op, mode)
    elif kind == 'exchange':  # exchange-point-and-mark
        cursor = w.textCursor()
        anchor = cursor.anchor()
        pos = cursor.position()
        cursor.setPosition(pos, tc.MoveAnchor)
        cursor.setPosition(anchor, tc.KeepAnchor)
        w.setTextCursor(cursor)
    else:
        if not extend:
            # Fix an annoyance. Make sure to clear the selection.
            cursor = w.textCursor()
            cursor.clearSelection()
            w.setTextCursor(cursor)
        w.moveCursor(op, mode)
    self.seeInsertPoint()
    self.rememberSelectionAndScroll()
    # #218.
    cursor = w.textCursor()
    sel = cursor.selection().toPlainText()
    if sel and hasattr(g.app.gui, 'setClipboardSelection'):
        g.app.gui.setClipboardSelection(sel)
    self.c.frame.updateStatusLine()
</t>
<t tx="ekr.20110605121601.18090">def see(self, see_i):
    """Scroll so that position see_i is visible."""
    w = self.widget
    tc = w.textCursor()
    # Put see_i in range.
    s = self.getAllText()
    see_i = max(0, min(see_i, len(s)))
    # Remember the old cursor
    old_cursor = QtGui.QTextCursor(tc)
    # Scroll so that see_i is visible.
    tc.setPosition(see_i)
    w.setTextCursor(tc)
    w.ensureCursorVisible()
    # Restore the old cursor
    w.setTextCursor(old_cursor)

def seeInsertPoint(self):
    """Make sure the insert point is visible."""
    self.widget.ensureCursorVisible()
</t>
<t tx="ekr.20110605121601.18411">def getIcon(self, p):
    """Return the proper icon for position p."""
    if self.use_declutter:
        item = self.position2item(p)
        return item and self.declutter_node(self.c, p, item)
    p.v.iconVal = iv = p.v.computeIcon()
    return self.getCompositeIconImage(p, iv)


</t>
<t tx="ekr.20110605121601.18412">def getCompositeIconImage(self, p, val):
    """Get the icon at position p."""
    fnames = self.icon_filenames_for_node(p, val)
    h = ':'.join(fnames)
    icon = g.app.gui.iconimages.get(h)
    loaded_images = self.loaded_images
    images = list(map(loaded_images.get, fnames))
    if not icon:
        icon = self.make_composite_icon(images)
        g.app.gui.iconimages[h] = icon
    return icon
</t>
<t tx="ekr.20110605121601.18418">def connectEditorWidget(self, e, item):
    """
    Connect QLineEdit e to QTreeItem item.
    
    Also callback for when the editor ends.
    
    New in Leo 6.4: The callback handles all updates w/o calling onHeadChanged.
    """
    c, p, u = self.c, self.c.p, self.c.undoer
    @others  # define the callback.
    if e:
        # Hook up the widget.
        wrapper = self.getWrapper(e, item)
        e.editingFinished.connect(editingFinished_callback)
        return wrapper  # 2011/02/12
    g.trace('can not happen: no e')
    return None
</t>
<t tx="ekr.20110605121601.18540">def eventFilter(self, obj, event):
    """Return False if Qt should handle the event."""
    c, k = self.c, self.c.k
    #
    # Handle non-key events first.
    if not self.c.p:
        return False  # Startup.
    #
    # Trace events.
    if 'events' in g.app.debug:
        if isinstance(event, QtGui.QKeyEvent):
            self.traceKeys(obj, event)
        else:
            self.traceEvent(obj, event)
            self.traceWidget(event)
    #
    # Let Qt handle the non-key events.
    if self.doNonKeyEvent(event, obj):
        return False
    #
    # Ignore incomplete key events.
    if self.shouldIgnoreKeyEvent(event, obj):
        return False
    #
    # Generate a g.KeyStroke for k.masterKeyHandler.
    try:
        binding, ch = self.toBinding(event)
        if not binding:
            return False  # Not the correct event type.
        #
        # Pass the KeyStroke to masterKeyHandler.
        key_event = self.createKeyEvent(event, c, self.w, ch, binding)
        k.masterKeyHandler(key_event)
        c.outerUpdate()
    except Exception:
        g.es_exception()
    return True
        # Whatever happens, suppress all other Qt key handling.
</t>
<t tx="ekr.20110605121601.18543">def toBinding(self, event):
    """
    Return (binding, actual_ch):

    binding:    A user binding, to create g.KeyStroke.
                Spelling no longer fragile.
    actual_ch:  The insertable key, or ''.
    """
    mods = self.qtMods(event)
    keynum, text, toString, ch = self.qtKey(event)
    actual_ch = text or toString
    #
    # Never allow empty chars, or chars in g.app.gui.ignoreChars
    if toString in g.app.gui.ignoreChars:
        return None, None
    ch = ch or toString or ''
    if not ch:
        return None, None
    #
    # Check for AltGr and Alt+Ctrl keys *before* creating a binding.
    actual_ch, ch, mods = self.doMacTweaks(actual_ch, ch, mods)
    mods = self.doAltTweaks(actual_ch, keynum, mods, toString)
    #
    # Use *ch* in the binding.
    # Clearer w/o f-strings.
    binding = '%s%s' % (''.join([f"{z}+" for z in mods]), ch)
    #
    # Return the tweaked *actual* char.
    binding, actual_ch = self.doLateTweaks(binding, actual_ch)
    return binding, actual_ch
</t>
<t tx="ekr.20110605121601.18544">def qtKey(self, event):
    """
    Return the components of a Qt key event.

    Modifiers are handled separately.

    Return (keynum, text, toString, ch).

    keynum: event.key()
    ch:     chr(keynum) or '' if there is an exception.
    toString:
        For special keys: made-up spelling that become part of the setting.
        For all others:   QtGui.QKeySequence(keynum).toString()
    text:   event.text()
    """
    keynum = event.key()
    text = event.text()  # This is the unicode character!
    qt = QtCore.Qt
    d = {
        qt.Key_Alt: 'Key_Alt',
        qt.Key_AltGr: 'Key_AltGr',
            # On Windows, when the KeyDown event for this key is sent,
            # the Ctrl+Alt modifiers are also set.
        qt.Key_Control: 'Key_Control',  # MacOS: Command key
        qt.Key_Meta: 'Key_Meta',
            # MacOS: Control key, Alt-Key on Microsoft keyboard on MacOs.
        qt.Key_Shift: 'Key_Shift',
        qt.Key_NumLock: 'Num_Lock',
            # 868.
        qt.Key_Super_L: 'Key_Super_L',
        qt.Key_Super_R: 'Key_Super_R',
        qt.Key_Hyper_L: 'Key_Hyper_L',
        qt.Key_Hyper_R: 'Key_Hyper_R',
    }
    if d.get(keynum):
        if 0:  # Allow bare modifier key.
            toString = d.get(keynum)
        else:
            toString = ''
    else:
        toString = QtGui.QKeySequence(keynum).toString()
    # Fix bug 1244461: Numpad 'Enter' key does not work in minibuffer
    if toString == 'Enter':
        toString = 'Return'
    if toString == 'Esc':
        toString = 'Escape'
    try:
        ch = chr(keynum)
    except ValueError:
        ch = ''
    # g.trace(keynum, ch)
    return keynum, text, toString, ch
</t>
<t tx="ekr.20110605121601.18624">def restart_match_span(self, s,
    delegate, end, exclude_match, kind,
    no_escape, no_line_break, no_word_break
):
    """Remain in this state until 'end' is seen."""
    self.matcher_name = 'restart:' + self.matcher_name.replace('restart:','')
    i = 0
    j = self.match_span_helper(s, i, end, no_escape, no_line_break, no_word_break)
    if j == -1:
        j2 = len(s) + 1
    elif j &gt; len(s):
        j2 = j
    else:
        j2 = j + len(end)
    if delegate:
        self.colorRangeWithTag(s, i, j, kind,
            delegate=delegate, exclude_match=exclude_match)
        self.colorRangeWithTag(s, j, j2, kind,
            delegate=None, exclude_match=exclude_match)
    else:  # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s, i, j2, kind,
            delegate=None, exclude_match=exclude_match)
    j = j2
    self.trace_match(kind, s, i, j)
    if j &gt; len(s):

        def span(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate, end, exclude_match, kind,
                no_escape, no_line_break, no_word_break)

        self.setRestart(span,
            # These must be keywords args.
            delegate=delegate, end=end, kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)
    else:
        self.clearState()
    return j  # Return the new i, *not* the length of the match.
</t>
<t tx="ekr.20110605121601.18637">def colorRangeWithTag(self, s, i, j, tag, delegate='', exclude_match=False):
    """
    Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.
    """
    trace = 'coloring' in g.app.debug and not g.unitTesting
        # setTag does most tracing.
    if not self.inColorState():
        # Do *not* check x.flag here. It won't work.
        if trace: g.trace('not in color state')
        return
    self.delegate_name = delegate
    if delegate:
        if trace:
            if len(repr(s[i:j])) &lt;= 20:
                s2 = repr(s[i:j])
            else:
                s2 = repr(s[i : i + 17 - 2] + '...')
            kind_s = f"{delegate}:{tag}"
            print(
                f"\ncolorRangeWithTag: {kind_s:25} {i:3} {j:3} "
                f"{s2:&gt;20} {self.matcher_name}\n")
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 &lt;= i &lt; j and i &lt; len(s):
            progress = i
            assert j &gt;= 0, j
            for f in self.rulesDict.get(s[i], []):
                n = f(self, s, i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n &gt; 0:
                    self.matcher_name = f.__name__
                    i += n
                    break
            else:
                # Use the default chars for everything else.
                # Use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                self.setTag(default_tag or tag, s, i, i + 1)
                i += 1
            assert i &gt; progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        self.setTag(tag, s, i, j)
    if tag != 'url':
        # Allow UNL's and URL's *everywhere*.
        j = min(j, len(s))
        while i &lt; j:
            ch = s[i].lower()
            if ch == 'u':
                n = self.match_unl(s, i)
                i += max(1, n)
            elif ch in 'fh':  # file|ftp|http|https
                n = self.match_any_url(s, i)
                i += max(1, n)
            else:
                i += 1
</t>
<t tx="ekr.20110605121601.18638">tot_time = 0.0

def mainLoop(self, n, s):
    """Colorize a *single* line s, starting in state n."""
    trace = 'coloring' in g.app.debug
    t1 = time.process_time()
    f = self.restartDict.get(n)
    if trace:
        p = self.c and self.c.p
        if p and p.v != self.last_v:
            self.last_v = p.v
            f_name = f.__name__ if f else 'None'
            print('')
            g.trace(f"NEW NODE: state {n} = {f_name} {p.h}\n")
    i = f(s) if f else 0
    while i &lt; len(s):
        progress = i
        functions = self.rulesDict.get(s[i], [])
        for f in functions:
            n = f(self, s, i)
            if n is None:
                g.trace('Can not happen: n is None', repr(f))
                break
            elif n &gt; 0:  # Success. The match has already been colored.
                self.matcher_name = f.__name__  # For traces.
                i += n
                break
            elif n &lt; 0:  # Total failure.
                i += -n
                break
            else:  # Partial failure: Do not break or change i!
                pass
        else:
            i += 1
        assert i &gt; progress
    # Don't even *think* about changing state here.
    self.tot_time += time.process_time() - t1
</t>
<t tx="ekr.20110605121601.18640">def recolor(self, s):
    """
    jEdit.recolor: Recolor a *single* line, s.
    QSyntaxHighligher calls this method repeatedly and automatically.
    """
    p = self.c.p
    self.recolorCount += 1
    block_n = self.currentBlockNumber()
    n = self.prevState()
    if p.v == self.old_v:
        new_language = self.n2languageDict.get(n)
        if new_language != self.language:
            self.language = new_language
            self.init(p)
    else:
        self.updateSyntaxColorer(p)  # Force a full recolor
        assert self.language
        self.init_all_state(p.v)
        self.init(p)
    if block_n == 0:
        n = self.initBlock0()
    n = self.setState(n)  # Required.
    # Always color the line, even if colorizing is disabled.
    if s:
        self.mainLoop(n, s)
</t>
<t tx="ekr.20110605121601.18641">last_v = None

def setTag(self, tag, s, i, j):
    """Set the tag in the highlighter."""
    trace = 'coloring' in g.app.debug and not g.unitTesting
    self.n_setTag += 1
    if i == j:
        return
    wrapper = self.wrapper  # A QTextEditWrapper
    if not tag.strip():
        return
    tag = tag.lower().strip()
    # A hack to allow continuation dots on any tag.
    dots = tag.startswith('dots')
    if dots:
        tag = tag[len('dots') :]
    colorName = wrapper.configDict.get(tag)
        # This color name should already be valid.
    if not colorName:
        return
    #
    # New in Leo 5.8.1: allow symbolic color names here.
    # This now works because all keys in leo_color_database are normalized.
    colorName = colorName.replace(
        ' ', '').replace('-', '').replace('_', '').lower().strip()
    colorName = leo_color_database.get(colorName, colorName)
    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            g.trace('unknown color name', colorName, g.callers())
            return
    underline = wrapper.configUnderlineDict.get(tag)
    format = QtGui.QTextCharFormat()
    font = self.fonts.get(tag)
    if font:
        format.setFont(font)
    if tag in ('blank', 'tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setUnderlineStyle(format.SingleUnderline)
        format.setFontUnderline(True)
    elif dots or tag == 'trailing_whitespace':
        format.setForeground(color)
        format.setUnderlineStyle(format.DotLine)
    else:
        format.setForeground(color)
        format.setUnderlineStyle(format.NoUnderline)
    self.tagCount += 1
    if trace:
        # A superb trace.
        ###
            # p = self.c and self.c.p
            # if p and p.v != self.last_v:
                # print(f'\nsetTag: NEW NODE: {p.h}\n')
                # self.last_v = p.v
        if len(repr(s[i:j])) &lt;= 20:
            s2 = repr(s[i:j])
        else:
            s2 = repr(s[i : i + 17 - 2] + '...')
        kind_s = f"{self.language}.{tag}"
        kind_s2 = f"{self.delegate_name}:" if self.delegate_name else ''
        print(
            f"setTag: {kind_s:25} {i:3} {j:3} {s2:&gt;20} "
            f"{self.rulesetName}:{kind_s2}{self.matcher_name}"
        )
    self.highlighter.setFormat(i, j - i, format)
</t>
<t tx="ekr.20110605195119.16937">def createKeyEvent(self, event, c, w, ch, binding):

    return leoGui.LeoKeyEvent(
        c=self.c,
        char=ch,
            # char = None doesn't work at present.
            # But really, the binding should suffice.
        event=event,
        binding=binding,
        w=w,
        x=getattr(event, 'x', None) or 0,
        y=getattr(event, 'y', None) or 0,
        x_root=getattr(event, 'x_root', None) or 0,
        y_root=getattr(event, 'y_root', None) or 0,
    )
</t>
<t tx="ekr.20110606004638.16929">def stroke2char(self, stroke):
    """
    Convert a stroke to an (insertable) char.
    This method allows Leo to use strokes everywhere.
    """
    if not stroke:
        return ''
    if not g.isStroke(stroke):
        # vim commands pass a plain key.
        stroke = g.KeyStroke(stroke)
    return stroke.toInsertableChar()
</t>
<t tx="ekr.20110609161752.16459">def setLossage(self, ch, stroke):

    # k = self
    if ch or stroke:
        if len(g.app.lossage) &gt; 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0, (ch, stroke),)
</t>
<t tx="ekr.20111002125540.7021">def getYScrollPosition(self):
    """Get the vertical scrollbar position."""
    w = self
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setYScrollPosition(self, pos):
    """Set the position of the vertical scrollbar."""
    w = self
    if pos is None: pos = 0
    sb = w.verticalScrollBar()
    sb.setSliderPosition(pos)
</t>
<t tx="ekr.20111005081134.15543">def createMoveMarkedNode(c):
    oldRoot = c.rootPosition()
    p = oldRoot.insertAfter()
    p.h = 'Moved marked nodes'
    p.moveToRoot()
    return p
</t>
<t tx="ekr.20111015194452.15686">def onSelectItem(self, it, it_prev=None):

    c = self.c
    tgt = self.its.get(it and id(it))
    if not tgt:
        return
    # if Ctrl key is down, delete item and
    # children (based on indent) and return
    modifiers = QtWidgets.QApplication.keyboardModifiers()
    if modifiers == QtCore.Qt.ControlModifier:
        row = self.lw.row(it)
        init_indent = len(it.text()) - len(str(it.text()).lstrip())
        self.lw.blockSignals(True)
        while row &lt; self.lw.count():
            self.lw.item(row).setHidden(True)
            row += 1
            cur = self.lw.item(row)
            # #1751.
            if not cur:
                break
            s = cur.text() or ''
            indent = len(s) - len(str(s).lstrip())
            if indent &lt;= init_indent:
                break
        self.lw.setCurrentRow(row)
        self.lw.blockSignals(False)
        return
    # generic callable
    if callable(tgt):
        tgt()
    elif len(tgt) == 2:
        p, pos = tgt
        if hasattr(p,'v'): #p might be "Root"
            if not c.positionExists(p):
                g.es("Node moved or deleted.\nMaybe re-do search.",
                    color='red')
                return
            c.selectPosition(p)
            if pos is not None:
                st, en = pos
                w = c.frame.body.wrapper
                w.setSelectionRange(st,en)
                w.seeInsertPoint()
            self.lw.setFocus()
</t>
<t tx="ekr.20120110174009.9965">def shouldPromptForDangerousWrite(self, fn, p):
    '''
    Return True if Leo should warn the user that p is an @&lt;file&gt; node that
    was not read during startup. Writing that file might cause data loss.
    
    See #50: https://github.com/leo-editor/leo-editor/issues/50
    '''
    trace = 'save' in g.app.debug
    sfn = g.shortFileName(fn)
    c = self.c
    efc = g.app.externalFilesController
    if p.isAtNoSentFileNode():
        # #1450.
        # No danger of overwriting a file.
        # It was never read.
        return False
    if not g.os_path_exists(fn):
        # No danger of overwriting fn.
        if trace: g.trace('Return False: does not exist:', sfn)
        return False
    # #1347: Prompt if the external file is newer.
    if efc:
        # Like c.checkFileTimeStamp.
        if c.sqlite_connection and c.mFileName == fn:
            # sqlite database file is never actually overwriten by Leo,
            # so do *not* check its timestamp.
            pass
        elif efc.has_changed(fn):
            if trace: g.trace('Return True: changed:', sfn)
            return True
    if hasattr(p.v, 'at_read'):
        # Fix bug #50: body text lost switching @file to @auto-rst
        d = p.v.at_read
        for k in d:
            # Fix bug # #1469: make sure k still exists.
            if (
                os.path.exists(k) and os.path.samefile(k, fn)
                and p.h in d.get(k, set())
            ):
                d[fn] = d[k]
                if trace: g.trace('Return False: in p.v.at_read:', sfn)
                return False
        aSet = d.get(fn, set())
        if trace:
            g.trace(f"Return {p.h not in aSet()}: p.h not in aSet(): {sfn}")
        return p.h not in aSet
    if trace:
        g.trace('Return True: never read:', sfn)
    return True  # The file was never read.
</t>
<t tx="ekr.20120112084820.10001">def rememberReadPath(self, fn, p):
    '''
    Remember the files that have been read *and*
    the full headline (@&lt;file&gt; type) that caused the read.
    '''
    v = p.v
    # Fix bug #50: body text lost switching @file to @auto-rst
    if not hasattr(v, 'at_read'):
        v.at_read = {}
    d = v.at_read
    aSet = d.get(fn, set())
    aSet.add(p.h)
    d[fn] = aSet
</t>
<t tx="ekr.20120130074511.10227">def kill_one_shortcut(self, stroke):
    """
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    """
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDict(  # was TypedDictOfLists.
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.BindingInfo,
        )
    inv_d = lm.invert(d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
</t>
<t tx="ekr.20120130074511.10228">def check_bind_key(self, commandName, pane, stroke):
    """
    Return True if the binding of stroke to commandName for the given
    pane can be made.
    """
    # k = self
    assert g.isStroke(stroke)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if stroke.lower().find(s) &gt; -1:
            g.warning('ignoring invalid key binding:', f"{commandName} = {stroke}")
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', stroke, commandName, g.callers())
        return False
    return True
</t>
<t tx="ekr.20120204061120.10067">def __repr__(self):
    return f"&lt;KeyStroke: {repr(self.s)}&gt;"

def __str__(self):
    return repr(self.s)
</t>
<t tx="ekr.20120204061120.10084">def qtMods(self, event):
    """Return the text version of the modifiers of the key event."""
    qt = QtCore.Qt
    modifiers = event.modifiers()
    mod_table = (
        (qt.AltModifier, 'Alt'),
        (qt.ControlModifier, 'Control'),
        (qt.MetaModifier, 'Meta'),
        (qt.ShiftModifier, 'Shift'),
        (qt.KeypadModifier, 'KeyPad'),
            # #1448: Replacing this by 'Key' would make separate keypad bindings impossible.
    )
    mods = [b for a, b in mod_table if (modifiers &amp; a)]
    #
    # MacOS: optionally convert Meta (Ctrl key) to Alt.
    # 945: remove @bool swap-mac-keys and @bool replace-meta-with-alt.
    # if g.isMac:
        # c = self.c
        # if c.k.replace_meta_with_alt:
            # if 'Meta' in mods:
                # mods.remove('Meta')
                # mods.append('Alt')
        # if c.k.swap_mac_keys:
            # # Swap the Command (clover) and Control keys.
            # # That is, swap the meaning of the Control and Meta modifiers.
            # if 'Meta' in mods and 'Control' not in mods:
                # mods.remove('Meta')
                # mods.append('Control')
            # elif 'Control' in mods and 'Meta' not in mods:
                # mods.remove('Control')
                # mods.append('Meta')
    return mods
</t>
<t tx="ekr.20120208064440.10179">def endMode(self):
    k = self; c = k.c
    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode')  # Changes focus to the body pane
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()  # Restores focus.
    if w:
        c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20120208064440.10190"></t>
<t tx="ekr.20120208064440.10199">def generalModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    """Handle a mode defined by an @mode node in leoSettings.leo."""
    k = self; c = k.c
    state = k.getState(modeName)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, w=k.modeWidget)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName)  # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False  # All silent modes must do --&gt; set-silent-mode.
                self.initMode(event, nextMode)  # Enter another mode.
</t>
<t tx="ekr.20120212220616.10537">def readExternalFiles(self, fileName):
    """Read all external files."""
    c, fc = self.c, self
    c.atFileCommands.readAll(c.rootPosition(), force=False)
    recoveryNode = fc.handleNodeConflicts()
    # Do this after reading external files.
    # The descendent nodes won't exist unless we have read
    # the @thin nodes!
    fc.restoreDescendentAttributes()
    fc.setPositionsFromVnodes()
    return recoveryNode
</t>
<t tx="ekr.20120213081706.10382">def readGlobalSettingsFiles(self):
    """
    Read leoSettings.leo and myLeoSettings.leo using a null gui.
    
    New in Leo 6.1: this sets ivars for the ActiveSettingsOutline class.
    """
    trace = 'themes' in g.app.debug
    lm = self
    # Open the standard settings files with a nullGui.
    # Important: their commanders do not exist outside this method!
    old_commanders = g.app.commanders()
    lm.leo_settings_path = lm.computeLeoSettingsPath()
    lm.my_settings_path = lm.computeMyLeoSettingsPath()
    lm.leo_settings_c = lm.openSettingsFile(self.leo_settings_path)
    lm.my_settings_c = lm.openSettingsFile(self.my_settings_path)
    commanders = [lm.leo_settings_c, lm.my_settings_c]
    commanders = [z for z in commanders if z]
    settings_d, bindings_d = lm.createDefaultSettingsDicts()
    for c in commanders:
        # Merge the settings dicts from c's outline into
        # *new copies of* settings_d and bindings_d.
        settings_d, bindings_d = lm.computeLocalSettings(
            c, settings_d, bindings_d, localFlag=False)
    # Adjust the name.
    bindings_d.setName('lm.globalBindingsDict')
    lm.globalSettingsDict = settings_d
    lm.globalBindingsDict = bindings_d
    # Add settings from --theme or @string theme-name files.
    # This must be done *after* reading myLeoSettigns.leo.
    lm.theme_path = lm.computeThemeFilePath()
    if lm.theme_path:
        lm.theme_c = lm.openSettingsFile(lm.theme_path)
        if lm.theme_c:
            # Merge theme_c's settings into globalSettingsDict.
            settings_d, junk_shortcuts_d = lm.computeLocalSettings(
                lm.theme_c, settings_d, bindings_d, localFlag=False)
            lm.globalSettingsDict = settings_d
            # Set global vars
            g.app.theme_directory = g.os_path_dirname(lm.theme_path)
                # Used by the StyleSheetManager.
            if trace: g.trace('g.app.theme_directory', g.app.theme_directory)
    # Clear the cache entries for the commanders.
    # This allows this method to be called outside the startup logic.
    for c in commanders:
        if c not in old_commanders:
            g.app.forgetOpenFile(c.fileName())
</t>
<t tx="ekr.20120214165710.10726">def createSettingsDicts(self, c, localFlag):

    from leo.core import leoConfig
    if c:
        parser = leoConfig.SettingsTreeParser(c, localFlag)
            # returns the *raw* shortcutsDict, not a *merged* shortcuts dict.
        shortcutsDict, settingsDict = parser.traverse()
        return shortcutsDict, settingsDict
    return None, None
</t>
<t tx="ekr.20120217070122.10479">def reloadSettings(self):
    # Part 1: These were in the ctor.
    c = self.c
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter = getBool('enable-autocompleter-initially')
    self.enable_calltips = getBool('enable-calltips-initially')
    self.ignore_unbound_non_ascii_keys = getBool('ignore-unbound-non-ascii-keys')
    self.minibuffer_background_color = getColor(
        'minibuffer-background-color') or 'lightblue'
    self.minibuffer_foreground_color = getColor(
        'minibuffer-foreground-color') or 'black'
    self.minibuffer_warning_color = getColor(
        'minibuffer-warning-color') or 'lightgrey'
    self.minibuffer_error_color = getColor('minibuffer-error-color') or 'red'
    self.replace_meta_with_alt = getBool('replace-meta-with-alt')
    self.warn_about_redefined_shortcuts = getBool('warn-about-redefined-shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings = c.config.getBool('enable-alt-ctrl-bindings')
    # Part 2: These were in finishCreate.
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body-text-background-color') or 'white'
    fg = c.config.getColor('body-text-foreground-color') or 'black'
    self.command_mode_bg_color = getColor('command-mode-bg-color') or bg
    self.command_mode_fg_color = getColor('command-mode-fg-color') or fg
    self.insert_mode_bg_color = getColor('insert-mode-bg-color') or bg
    self.insert_mode_fg_color = getColor('insert-mode-fg-color') or fg
    self.overwrite_mode_bg_color = getColor('overwrite-mode-bg-color') or bg
    self.overwrite_mode_fg_color = getColor('overwrite-mode-fg-color') or fg
    self.unselected_body_bg_color = getColor('unselected-body-bg-color') or bg
    self.unselected_body_fg_color = getColor('unselected-body-fg-color') or bg
</t>
<t tx="ekr.20120219154958.10483">def computeFilesList(self, options, fileName):
    """Return the list of files on the command line."""
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = g.glob_glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return [g.os_path_normslashes(z) for z in result]
</t>
<t tx="ekr.20120219154958.10486">def scanOptions(self, fileName, pymacs):
    """Handle all options, remove them from sys.argv and set lm.options."""
    lm = self
    table = (
        '--dock',
        '--global-docks',  # #1643. use --use-docks instead.
        '--init-docks',
        '--no-cache',
        '--no-dock',  # #1171 and #1514: use --use-docks instead.
        '--session-restore',
        '--session-save',
        '--use-docks',
    )
    trace_m = '''abbrev,beauty,cache,coloring,drawing,events,focus,
      git,gnx,importers,ipython,keys,layouts,plugins,save,
      select,shutdown,size,startup,themes,undo,verbose,zoom'''
    for bad_option in table:
        if bad_option in sys.argv:
            sys.argv.remove(bad_option)
            print(f"Ignoring the unused/deprecated {bad_option} option")
    lm.old_argv = sys.argv[:]
    parser = optparse.OptionParser(
        usage="usage: launchLeo.py [options] file1, file2, ...")
        # Automatically implements the --help option.
    #
    # Parse the options, and remove them from sys.argv.
    self.addOptionsToParser(parser, trace_m)
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]]
    sys.argv.extend(args)
    # Handle simple args...
    self.doSimpleOptions(options, trace_m)
    # Compute the lm.files ivar.
    lm.files = lm.computeFilesList(options, fileName)
    script = None if pymacs else self.doScriptOption(options, parser)
    d = {
        'gui': lm.doGuiOption(options),
        'load_type': lm.doLoadTypeOption(options),
        'screenshot_fn': lm.doScreenShotOption(options),
            # --screen-shot=fn
        'script': script,
        'select': options.select and options.select.strip('"'),
            # --select=headline
        'theme_path': options.theme,
            # --theme=name
        'version': options.version,
            # --version: print the version and exit.
        'windowFlag': script and options.script_window,
        'windowSize': lm.doWindowSizeOption(options),
        'windowSpot': lm.doWindowSpotOption(options),
    }
    return d
</t>
<t tx="ekr.20120309073937.9878"></t>
<t tx="ekr.20120427064024.10064">def checkForOpenFile(self, c, fn):
    """Warn if fn is already open and add fn to already_open_files list."""
    d, tag = g.app.db, 'open-leo-files'
    if g.app.reverting:
        # #302: revert to saved doesn't reset external file change monitoring
        g.app.already_open_files = []
    if (d is None or
        g.app.unitTesting or
        g.app.batchMode or
        g.app.reverting or
        g.app.inBridge
    ):
        return
    # #1519: check os.path.exists.
    aList = g.app.db.get(tag) or []
    if [x for x in aList if os.path.exists(x) and os.path.samefile(x, fn)]:
        # The file may be open in another copy of Leo, or not:
        # another Leo may have been killed prematurely.
        # Put the file on the global list.
        # A dialog will warn the user such files later.
        if fn not in g.app.already_open_files:
            g.es('may be open in another Leo:', color='red')
            g.es(fn)
            g.app.already_open_files.append(fn)
    else:
        g.app.rememberOpenFile(fn)
</t>
<t tx="ekr.20120427064024.10065">def rememberOpenFile(self, fn):

    #
    # Do not call g.trace, etc. here.
    d, tag = g.app.db, 'open-leo-files'
    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        pass
    elif g.app.preReadFlag:
        pass
    else:
        aList = d.get(tag) or []
        # It's proper to add duplicates to this list.
        aList.append(fn)
        d[tag] = aList
</t>
<t tx="ekr.20120427064024.10066">def forgetOpenFile(self, fn, force=False):
    """Forget the open file, so that is no longer considered open."""
    trace = 'shutdown' in g.app.debug
    d, tag = g.app.db, 'open-leo-files'
    if not d or not fn:
        # #69.
        return
    if not force and (
        d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting):
        return
    aList = d.get(tag) or []
    if fn in aList:
        aList.remove(fn)
        if trace:
            g.pr(f"forgetOpenFile: {g.shortFileName(fn)}")
        d[tag] = aList
    # elif trace: g.pr(f"forgetOpenFile: did not remove: {fn}")
</t>
<t tx="ekr.20120427064024.10068"></t>
<t tx="ekr.20120520174745.9867">@cmd('show-buttons')
def printButtons(self, event=None):
    """Print all @button and @command commands, their bindings and their source."""
    k = self; c = k.c
    tabName = '@buttons &amp;&amp; @commands'
    c.frame.log.clearTab(tabName)

    def put(s):
        g.es('', s, tabName=tabName)

    data = []
    for aList in [c.config.getButtons(), c.config.getCommands()]:
        for z in aList:
            p, script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h, tag),)
    for aList in [g.app.config.atLocalButtonsList, g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h, 'L'),)
    result = [f"{z[1]} {z[0]}" for z in sorted(data)]
    result.extend([
        '',
        'legend:',
        'G leoSettings.leo',
        'L local .leo File',
        'M myLeoSettings.leo',
    ])
    put('\n'.join(result))
</t>
<t tx="ekr.20120925061642.13506">def onSliderChanged(self, arg):
    """Handle a Qt onSliderChanged event."""
    c = self.leo_c
    p = c.p
    # Careful: changing nodes changes the scrollbars.
    if hasattr(c.frame.tree, 'tree_select_lockout'):
        if c.frame.tree.tree_select_lockout:
            return
    # Only scrolling in the body pane should set v.scrollBarSpot.
    if not c.frame.body or self != c.frame.body.wrapper.widget:
        return
    if p:
        p.v.scrollBarSpot = arg
</t>
<t tx="ekr.20121126102050.10134"></t>
<t tx="ekr.20130924035029.12741">def initOneAbbrev(self, commandName, key):
    """Enter key as an abbreviation for commandName in c.commandsDict."""
    c = self.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s', key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            c.commandsDict[key] = func
        else:
            g.warning('bad abbrev:', key, 'unknown command name:', commandName)
</t>
<t tx="ekr.20130927050813.13031"></t>
<t tx="ekr.20131017100903.16689">def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState()  # Bug fix.
        if last.isdigit():
            # Special case: for the number Easter Egg.
            c.goToLineNumber(int(last))
        else:
            c.commandsDict[last](event)
    else:
        k.keyboardQuit()
</t>
<t tx="ekr.20131017174814.17480">def shouldBeExpanded(self, p):
    """Return True if the node at position p should be expanded."""
    c, v = self, p.v
    if not p.hasChildren():
        return False
    # Always clear non-existent positions.
    v.expandedPositions = [z for z in v.expandedPositions if c.positionExists(z)]
    if not p.isCloned():
        # Do not call p.isExpanded here! It calls this method.
        return p.v.isExpanded()
    if p.isAncestorOf(c.p):
        return True
    for p2 in v.expandedPositions:
        if p == p2:
            return True
    return False
</t>
<t tx="ekr.20131111060930.18010"># Standard bindings...
# run-selected-unit-tests-externally = Alt-4 
# run-marked-unit-tests-externally = Alt-5
# run-marked-unit-tests-locally = Alt-6
run-selected-unit-tests-locally = Alt-4
do-nothing = Alt-5
run-marked-unit-tests-locally = Alt-6
</t>
<t tx="ekr.20131111105746.16544">def vim_dot(self):
    """Repeat the last command."""
    if self.in_dot:
        return
    try:
        self.in_dot = True
        # Save the dot list.
        self.old_dot_list = self.dot_list[:]
        # Copy the list so it can't change in the loop.
        for event in self.dot_list[:]:
            # Only k.masterKeyHandler can insert characters!
            #
            # #1757: Create a LeoKeyEvent.
            event = LeoKeyEvent(
                binding=g.KeyStroke(event.stroke),
                c = self.c,
                char=event.char,
                event=event,
                w=self.w,
            )
            self.k.masterKeyHandler(event)
        # For the dot list to be the old dot list, whatever happens.
        self.command_list = self.old_dot_list[:]
        self.dot_list = self.old_dot_list[:]
    finally:
        self.in_dot = False
    self.done()
</t>
<t tx="ekr.20131111140646.16544"># Similar to runEditCommandTest.

def runVimTest(self, p):
    tm = self
    c = self.c
    vc = c.vimCommands
    atTest = p.copy()
    w = c.frame.body.wrapper
    h = atTest.h
    assert h.startswith('@test '), f"expected head: {'@test'}, got: {h}"
    s = h[6:].strip()
    # The vim command is everything up to the first blank.
    i = 0
    while i &lt; len(s) and s[i] not in ' \t\n':
        i += 1
    command = s[:i]
    assert command, 'empty vim command'
    assert command, f"no command: {command}"
    work, before, after = tm.findChildrenOf(atTest)
    before_h = 'before sel='
    after_h = 'after sel='
    for node, h in ((work, 'work'), (before, before_h), (after, after_h)):
        h2 = node.h
        assert h2.startswith(h), f"expected head: {h}, got: {h2}"
    sels = []
    for node, h in ((before, before_h), (after, after_h)):
        sel = node.h[len(h) :].strip()
        aList = [str(z) for z in sel.split(',')]
        sels.append(tuple(aList))
    if 1:
        # pylint: disable=unbalanced-tuple-unpacking
        sel1, sel2 = sels
    c.selectPosition(work)
    work.b = before.b
    w.setSelectionRange(sel1[0], sel1[1], insert=sel1[1])
    # The vim-specific part.
    status, n1, command, n2, motion = vc.scan(command)
    assert status == 'done', repr(status)
    vc.exec_(command, n1, n2, motion)
    # Check the result.
    s1 = work.b; s2 = after.b
    assert s1 == s2, (
        f"mismatch in body\n"
        f"expected: {s2!r}\n"
        f"     got: {s1!r}")
    sel3 = w.getSelectionRange()
    # Convert both selection ranges to gui indices.
    sel2_orig = sel2
    assert len(sel2) == 2, f"Bad headline index.  Expected index,index.  got: {sel2}"
    i, j = sel2; sel2 = w.toPythonIndex(i), w.toPythonIndex(j)
    assert len(sel3) == 2, f"Bad headline index.  Expected index,index.  got: {sel3}"
    i, j = sel3; sel3 = w.toPythonIndex(i), w.toPythonIndex(j)
    assert sel2 == sel3, f"mismatch in sel\nexpected: {sel2_orig} = {sel2}, got: {sel3}"
    c.selectPosition(atTest)
    atTest.contract()
    # Don't redraw.
</t>
<t tx="ekr.20131121084830.16362">@language python

# Toggle the settings.
g.app.debug_app = not g.app.debug_app
g.app.debug_widgets = not g.app.debug_widgets
# Report the new settings.
print('g.app.debug_app: %s' % g.app.debug_app)
print('g.app.debug_widgets: %s' % g.app.debug_widgets)
</t>
<t tx="ekr.20131222112420.16371">def contract(self):
    """Contract p.v and clear p.v.expandedPositions list."""
    p, v = self, self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    v.contract()

def expand(self):
    p = self
    v = self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    for p2 in v.expandedPositions:
        if p == p2:
            break
    else:
        v.expandedPositions.append(p.copy())
    v.expand()

def isExpanded(self):
    p = self
    if p.isCloned():
        c = p.v.context
        return c.shouldBeExpanded(p)
    return p.v.isExpanded()
</t>
<t tx="ekr.20140102162014.16438">unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class LocalConfigManager--&gt;c.config.Getters--&gt;c.config.Getters--&gt;c.config.getData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class GlobalConfigManager--&gt;gcm.Getters...--&gt;gcm.getData &amp; getOutlineData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;&lt;&lt; class ParserBaseClass &gt;&gt;--&gt;kind handlers (ParserBaseClass)--&gt;doData
@language rest
The parser for @data nodes, doData, no longer strips *anything*.</t>
<t tx="ekr.20140103105930.16446"></t>
<t tx="ekr.20140114145953.16691">def isLocalSetting(self, setting, kind):
    """Return True if the indicated setting comes from a local .leo file."""
    if not kind or kind in ('shortcut', 'shortcuts', 'openwithtable'):
        return False
    key = g.app.config.munge(setting)
    if key is None:
        return False
    if not self.settingsDict:
        return False
    gs = self.settingsDict.get(key)
    if not gs:
        return False
    assert isinstance(gs, g.GeneralSetting), repr(gs)
    path = gs.path.lower()
    for fn in ('myLeoSettings.leo', 'leoSettings.leo'):
        if path.endswith(fn.lower()):
            return False
    return True
</t>
<t tx="ekr.20140203082618.15486">def __get_script(self):
    p = self
    return g.getScript(p.v.context, p,
        useSelectedText=False,  # Always return the entire expansion.
        forcePythonSentinels=True,
        useSentinels=False)

script = property(
    __get_script,  # __set_script,
    doc="position property returning the script formed by p and its descendants")
</t>
<t tx="ekr.20140218040104.16761">def __get_nosentinels(self):
    p = self
    return ''.join([z for z in g.splitLines(p.b) if not g.isDirective(z)])

nosentinels = property(
    __get_nosentinels,  # __set_nosentinels
    doc="position property returning the body text without sentinels")
</t>
<t tx="ekr.20140221085636.16685">def do_key(self, event):
    """
    Handle the next key in vim mode:
    - Set event, w, stroke and ch ivars for *all* handlers.
    - Call handler().
    Return True if k.masterKeyHandler should handle this key.
    """
    try:
        self.init_scanner_vars(event)
        self.do_trace(blank_line=True)
        self.return_value = None
        if not self.handle_specials():
            self.handler()
        if self.return_value not in (True, False):
            # It looks like no acceptance method has been called.
            self.oops(
                f"bad return_value: {repr(self.return_value)} "
                f"{self.state} {self.next_func}")
            self.done()  # Sets self.return_value to True.
    except Exception:
        g.es_exception()
        self.quit()
    return self.return_value
</t>
<t tx="ekr.20140723122936.17925"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins now contain the importer code for all kinds of @auto nodes.
# Each plugin must define a top-level importer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20140724064952.18038">def dispatch(self, ext, p):
    """Return the correct scanner function for p, an @auto node."""
    # Match the @auto type first, then the file extension.
    c = self.c
    return g.app.scanner_for_at_auto(c, p) or g.app.scanner_for_ext(c, ext)
</t>
<t tx="ekr.20140724073946.18050">def get_import_filename(self, fileName, parent):
    """Return the absolute path of the file and set .default_directory."""
    c = self.c
    self.default_directory = g.setDefaultDirectory(c, parent, importing=False)
    fileName = g.os_path_finalize_join(self.default_directory, fileName)  # 1341
    fileName = fileName.replace('\\', '/')  # 2011/11/25
    return fileName
</t>
<t tx="ekr.20140724175458.18052">def init_import(self, atShadow, ext, fileName, s):
    """
    Init ivars imports and read the file into s.
    Return ext, s.
    """
    junk, self.fileName = g.os_path_split(fileName)
    self.methodName, self.fileType = g.os_path_splitext(self.fileName)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        # Set the kind for error messages in readFileIntoString.
        s, e = g.readFileIntoString(
            fileName,
            encoding=self.encoding,
            kind='@shadow ' if atShadow else '@auto ',
        )
            # Kind is used only for messages.
        if s is None:
            return None, None
        if e: self.encoding = e
    if self.treeType == '@root':
        self.rootLine = "@root-code " + self.fileName + '\n'
    else:
        self.rootLine = ''
    return ext, s
</t>
<t tx="ekr.20140726091031.18071"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins contain the write code for all kinds of special @auto nodes.
# Each plugin must define a top-level writer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20140802120757.18001">def save_body(self):
    """Undoably preserve any changes to body text."""
    c = self.c
    w = self.command_w or self.w
    name = c.widget_name(w)
    if w and name.startswith('body'):
        # Similar to selfInsertCommand.
        oldSel = self.old_sel or w.getSelectionRange()
        newText = w.getAllText()
        if c.p.b != newText:
            # To do: set undoType to the command spelling?
            # undoType = ''.join(self.command_list) or 'Typing'
            c.frame.body.onBodyChanged(undoType='vc-save-body', oldSel=oldSel)
</t>
<t tx="ekr.20140802120757.18003">def init_scanner_vars(self, event):
    """Init all ivars used by the scanner."""
    assert event
    self.event = event
    stroke = event.stroke
    self.ch = event.char  # Required for f,F,t,T.
    self.stroke = stroke.s if g.isStroke(stroke) else stroke
    self.w = event and event.w
    if not self.in_command:
        self.in_command = True  # May be cleared later.
        if self.is_text_wrapper(self.w):
            self.old_sel = self.w.getSelectionRange()
</t>
<t tx="ekr.20140802225657.18021">def handle_specials(self):
    """Return True self.stroke is an Escape or a Return in the outline pane."""
    if self.stroke == 'Escape':
        # k.masterKeyHandler handles Ctrl-G.
        # Escape will end insert mode.
        self.vim_esc()
        return True
    if self.stroke == '\n' and self.in_headline(self.w):
        # End headline editing and enter normal mode.
        self.c.endEditing()
        self.done()
        return True
    return False
</t>
<t tx="ekr.20140808103117.18035"></t>
<t tx="ekr.20140808103117.18038">gnx: ekr.20110605121601.18698
</t>
<t tx="ekr.20140808103117.18040">gnx: ekr.20110605121601.18703
</t>
<t tx="ekr.20140808103117.18042">gnx: ekr.20110605121601.18704
</t>
<t tx="ekr.20140808103117.18044">gnx: ekr.20110605121601.18709
</t>
<t tx="ekr.20140813052702.18203">def getFileName(self, event, callback=None,
    filterExt=None, prompt='Enter File Name: ', tabName='Dired'
):
    """Get a file name from the minibuffer."""
    k = self
    k.fnc.get_file_name(event, callback, filterExt, prompt, tabName)
</t>
<t tx="ekr.20140816165728.18968"># New in Leo 5.4

def getNextArg(self, handler):
    """
    Get the next arg.  For example, after a Tab in the find commands.
    See the docstring for k.get1Arg for examples of its use.
    """
    # Replace the current handler.
    self.getArgInstance.after_get_arg_state = ('getarg', 1, handler)
    self.c.minibufferWantsFocusNow()

# New in Leo 5.4

def get1Arg(self, event, handler,
    # returnKind=None, returnState=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    &lt;&lt; docstring for k.get1arg &gt;&gt;
    returnKind, returnState = None, None
    assert handler, g.callers()
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def getArg(self, event,
    returnKind=None, returnState=None, handler=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    """Convenience method mapping k.getArg to ga.get_arg."""
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def doBackSpace(self, tabList, completion=True):
    """Convenience method mapping k.doBackSpace to ga.do_back_space."""
    self.getArgInstance.do_back_space(tabList, completion)

def doTabCompletion(self, tabList):
    """Convenience method mapping k.doTabCompletion to ga.do_tab."""
    self.getArgInstance.do_tab(tabList)

def getMinibufferCommandName(self):
    """
    Convenience method mapping k.getMinibufferCommandName to
    ga.get_minibuffer_command_name.
    """
    return self.getArgInstance.get_minibuffer_command_name()
</t>
<t tx="ekr.20140822051549.18298">def setStatusLabel(self, s):
    """
    Set the label to s.

    Use k.setStatusLabel, not k.setLael, to report the status of a Leo
    command. This allows the option to use g.es instead of the minibuffer
    to report status.
    """
    k = self
    k.setLabel(s, protect=False)
</t>
<t tx="ekr.20140831085423.18630">This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:

si:     a g.ShortcutInfo object.
ks:     a g.KeyStroke object
stroke: a KeyStroke object.

btw:    leoFrame.BaseTextWrapper
stw:    leoFrame.StringTextWrapper

bqtw:   qt_text.BaseQTextWrapper
lqtb:   qt_text.LeoQTextBrowser
qhlw:   qt_text.QHeadlineWrapper
qmbw:   qt_text.QMinibufferWrapper
qlew:   qt_text.QLineEditWrapper
qsciw:  qt_text.QScintiallaWrapper
qtew:   qt_text.QTextEditWrapper</t>
<t tx="ekr.20140831085423.18631">The following 'official' ivars will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.widget     The gui widget for the body pane.
c.frame.body.wrapper    The high level interface for the body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.log.widget      The gui widget for the log pane.
c.frame.log.wrapper     The high-level inteface for the log pane.
c.frame.tree            The tree pane.

The following were official ivars that no longer exist:

c.frame.body.bodyCtrl   Use c.frame.body.wrapper instead.
c.frame.log.logCtrl     Use c.frame.log.wrapper instead.
</t>
<t tx="ekr.20140831085423.18639">Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly.  Instead...

2. A **wrapper class** defines a standard api that hides the details
   of the underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All wrapper classes define an official ``widget`` ivar, so core or plugin code can gain access to the real Qt widget using wrapper.widget. Searching for wrapper.widget will find all gui-dependent snippets of code in Leo's core.
</t>
<t tx="ekr.20140901062324.18714">def onTextChanged(self):
    """
    Update Leo after the body has been changed.

    tree.tree_select_lockout is True during the entire selection process.
    """
    # Important: usually w.changingText is True.
    # This method very seldom does anything.
    w = self
    c = self.c; p = c.p
    tree = c.frame.tree
    if w.changingText:
        return
    if tree.tree_select_lockout:
        g.trace('*** LOCKOUT', g.callers())
        return
    if not p:
        return
    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText()  # Converts to unicode.
    # Get the previous values from the VNode.
    oldText = p.b
    if oldText == newText:
        # This can happen as the result of undo.
        # g.error('*** unexpected non-change')
        return
    i, j = p.v.selectionStart, p.v.selectionLength
    oldSel = (i, i + j)
    c.undoer.doTyping(p, 'Typing', oldText, newText,
        oldSel=oldSel, oldYview=None, newInsert=newInsert, newSel=newSel)
</t>
<t tx="ekr.20140901062324.18716">def onCursorPositionChanged(self, event=None):
    
    c = self.c
    name = c.widget_name(self)
    # Apparently, this does not cause problems
    # because it generates no events in the body pane.
    if not name.startswith('body'):
        return
    if hasattr(c.frame, 'statusLine'):
        c.frame.statusLine.update()
</t>
<t tx="ekr.20140902032918.18591">@language rest
@wrap

Leo uses a model/view/controller architecture.

- Controller: The Commands class and its helpers in leoCommands.py and leoEditCommands.py.

- Model: The VNode and Position classes in leoNodes.py.

- View: The gui-independent base classes are in the node "Gui Base Classes". The Qt-Specific subclasses are in the node "Qt gui".

**Important**: The general organization of these classes have changed hardly at all in Leo's 20+ year history.  The reason is that what each class does is fairly obvious.  How the gets the job done may have changed drastically, but *that's an internal implementation detail of the class itself*.  This is the crucial design principle that allows Leo's code to remain stable.  *Classes do not know or meddle in the internal details of other classes*.  As a result, nobody, including EKR, needs to remember internal details.

</t>
<t tx="ekr.20140902155015.18674"></t>
<t tx="ekr.20140916101314.19538">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20140920064112.17946"></t>
<t tx="ekr.20141024170936.7">def get_selection(self):
    """Return the presently selected item's text."""
    return self.currentItem().text()
</t>
<t tx="ekr.20141103061944.31">def getXScrollPosition(self):
    """Get the horizontal scrollbar position."""
    w = self
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setXScrollPosition(self, pos):
    """Set the position of the horizontal scrollbar."""
    if pos is not None:
        w = self
        sb = w.horizontalScrollBar()
        sb.setSliderPosition(pos)
</t>
<t tx="ekr.20150207044400.12">def op_delete(self, tag, ai, aj, bi, bj):
    """Handle the 'delete' opcode."""
    x = self
    for i in range(ai, aj):
        x.put_sentinels(i)
</t>
<t tx="ekr.20150207044400.13">def op_equal(self, tag, ai, aj, bi, bj):
    """Handle the 'equal' opcode."""
    x = self
    assert aj - ai == bj - bi and x.a[ai:aj] == x.b[bi:bj]
    for i in range(ai, aj):
        x.put_sentinels(i)
        x.put_plain_line(x.a[i])
            # works because x.lines[ai:aj] == x.lines[bi:bj]
</t>
<t tx="ekr.20150207044400.14">def op_insert(self, tag, ai, aj, bi, bj):
    """Handle the 'insert' opcode."""
    x = self
    for i in range(bi, bj):
        x.put_plain_line(x.b[i])
    # Prefer to put sentinels after inserted nodes.
    # Requires a call to x.put_sentinels(0) before the main loop.
</t>
<t tx="ekr.20150207044400.15">def op_replace(self, tag, ai, aj, bi, bj):
    """Handle the 'replace' opcode."""
    x = self
    if 1:
        # Intersperse sentinels and lines.
        b_lines = x.b[bi:bj]
        for i in range(ai, aj):
            x.put_sentinels(i)
            if b_lines:
                x.put_plain_line(b_lines.pop(0))
        # Put any trailing lines.
        while b_lines:
            x.put_plain_line(b_lines.pop(0))
    else:
        # Feasible. Causes the present unit tests to fail.
        for i in range(ai, aj):
            x.put_sentinels(i)
        for i in range(bi, bj):
            x.put_plain_line(x.b[i])
</t>
<t tx="ekr.20150207044400.16">def op_bad(self, tag, ai, aj, bi, bj):
    """Report an unexpected opcode."""
    x = self
    x.error(f"unknown SequenceMatcher opcode: {tag!r}")
</t>
<t tx="ekr.20150207044400.9">"""
The Mulder update algorithm, revised by EKR.

Use the diff between the old and new public lines to insperse sentinels
from old_private_lines into the result.

The algorithm never deletes or rearranges sentinels. However, verbatim
sentinels may be inserted or deleted as needed.
"""
</t>
<t tx="ekr.20150207111757.178">def dump_lines(self, lines, title):
    """Dump the given lines."""
    print(f"\n{title}...\n")
    for i, line in enumerate(lines):
        g.pr(f"{i:4} {line!r}")
</t>
<t tx="ekr.20150207111757.180">def dump_args(self):
    """Dump the argument lines."""
    x = self
    table = (
        (x.old_sent_lines, 'old private lines'),
        (x.a, 'old public lines'),
        (x.b, 'new public lines'),
    )
    for lines, title in table:
        x.dump_lines(lines, title)
    g.pr()
</t>
<t tx="ekr.20150208060128.7">def preprocess(self, lines):
    """
    Preprocess public lines, adding newlines as needed.
    This happens before the diff.
    """
    result = []
    for line in lines:
        if not line.endswith('\n'):
            line = line + '\n'
        result.append(line)
    return result
</t>
<t tx="ekr.20150208223018.4">def put_plain_line(self, line):
    """Put a plain line to x.results, inserting verbatim lines if necessary."""
    x = self
    if x.marker.isSentinel(line):
        x.results.append(x.verbatim_line)
        if x.trace: print(f"put {repr(x.verbatim_line)}")
    x.results.append(line)
    if x.trace: print(f"put {line!r}")
</t>
<t tx="ekr.20150209044257.6">def init_data(self):
    """
    Init x.sentinels and x.trailing_sentinels arrays.
    Return the list of non-sentinel lines in x.old_sent_lines.
    """
    x = self
    lines = x.old_sent_lines
    sentinels = []
        # The sentinels preceding each non-sentinel line,
        # not including @verbatim sentinels.
    new_lines = []
        # A list of all non-sentinel lines found.  Should match x.a.
    x.sentinels = []
        # A list of lists of sentinels preceding each line.
    i = 0
    while i &lt; len(lines):
        line = lines[i]
        i += 1
        if x.marker.isVerbatimSentinel(line):
            # Do *not* include the @verbatim sentinel.
            if i &lt; len(lines):
                line = lines[i]
                i += 1
                x.sentinels.append(sentinels)
                sentinels = []
                new_lines.append(line)
            else:
                x.verbatim_error()
        elif x.marker.isSentinel(line):
            sentinels.append(line)
        else:
            x.sentinels.append(sentinels)
            sentinels = []
            new_lines.append(line)
    x.trailing_sentinels = sentinels
    return new_lines
</t>
<t tx="ekr.20150209044257.8">def put_sentinels(self, i):
    """Put all the sentinels to the results"""
    x = self
    if 0 &lt;= i &lt; len(x.sentinels):
        sentinels = x.sentinels[i]
        if x.trace: g.trace(f"{i:3} {sentinels}")
        x.results.extend(sentinels)
</t>
<t tx="ekr.20150304125314.4">@tabwidth -2
@killbeautify
@language xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;!--
    &lt;link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/default.min.css"&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"&gt;&lt;/script&gt;
    --&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;!-- &lt;h4&gt;Outline Pane&lt;/h4&gt; --&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;!-- &lt;h4&gt;Body Pane&lt;/h4&gt; --&gt;
      &lt;pre class="body-text"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test ='./v' &gt;
        &lt;xsl:attribute name="has-children"&gt;1&lt;/xsl:attribute&gt;
        &lt;h1&gt;+ &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
        &lt;xsl:apply-templates select = 'v'/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test ='vh' &gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:when&gt;
      &lt;!--
      &lt;xsl:otherwise&gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:otherwise&gt;
      --&gt;
    &lt;/xsl:choose&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.4">@language xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;h1&gt;Body Pane&lt;/h1&gt;
      &lt;pre class="body-text"&gt;body&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;h1&gt;&lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
    &lt;xsl:if test ='./v' &gt;
      &lt;xsl:apply-templates select = 'v'/&gt;
    &lt;/xsl:if&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.5">&lt;style&gt;
    /* pre { background:#FFE7C6; } */
    /* Must use h1 for nodes: see below. */
    h1 {
      font-size: 12pt;
      font-style: normal;
      font-weight: normal;
    }
    div.outlinepane {
      position: absolute;
      background: #ffffec; /* Leo yellow */
      top: 10px;
      height: 300px;
      width: 700px;
      overflow: scroll;
      line-height: 0.8;

    }
    div.bodypane {
      position: absolute;
      top: 310px;
      height: 300px;
      width: 700px;
      overflow: scroll;
    }
    div.tnode {
        visibility: hidden;
        height: 0;
    }
    div.node {
        position: relative;
        left: 20px;
    }
    div.node[has-children] &gt; h1 {
        &lt;!-- works --&gt;
        &lt;!-- background: red; --&gt;
    }
&lt;/style&gt;
</t>
<t tx="ekr.20150304130753.6">@language javascript

&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;script&gt;

  $(document).ready(function(){
    if (true) {
        // Toggle all but top-level nodes.
        // This requires an indication
        $(".node").toggle()
        $(".outlinepane").children(".node").toggle()
    } else {
        // Toggle all second-level nodes.
        // Safer, until we can see which nodes have children.
        $(".outlinepane").children(".node").children(".node").toggle()
    }
    $("h1").click(function(){
      $(this).parent().children("div.node").toggle();
      // The parent div's id is v.x.
      // Find the tnode div whose id is t.x.
      console.clear();
      parent_id=$(this).parent().attr("id");
      if (parent_id) {
        target=$(this).parent().attr("id").substring(2);
          console.log("clicked:"+$(this).text())
          // console.log("parent:"+$(this).parent())
          // console.log("target:"+target)
        $(".tnode").each(function(){
          console.log($(this).attr("id"))
          target2=$(this).attr("id").substring(2);
          if (target === target2) {
            console.log("found:"+target2)
            // $("pre.body-text").text($(this).text());
            $("code").text($(this).text());
          };
        }); // end .each.
      };
    });
  });
@language html
&lt;/script&gt;
</t>
<t tx="ekr.20150326145530.1"># Hand-written Leo colorizer control file for forth mode.
# This file is in the public domain.
@killbeautify
from leo.core import leoGlobals as g
&lt;&lt; define mode rules &gt;&gt;
&lt;&lt; define mode data &gt;&gt;
&lt;&lt; define extendForth class &gt;&gt;
e = extendForth()

def pre_init_mode(c):
    e.c = c
    e.init()
    e.createKeywords()
    e.createBracketRules()
    e.createDefiningWordRules()

</t>
<t tx="ekr.20150326145530.10">def createKeywords(self):
    """
    Create the mode keyword table and
    entries in the rulesDict for the forth_keyword_rule.
    """
    # global forth_main_keywords_dict
    # global forth_keyword_rule
    table = (
        (self.keywords, 'keyword1'),
      # (self.definingwords,    'keyword2'), # Done in createDefiningWordRules.
        (self.boldwords, 'keyword3'),
        (self.bolditalicwords, 'keyword4'),
        (self.italicwords, 'keyword5'),
        (self.stringwords, 'string'),
    )
    d = forth_main_keywords_dict
    for keywordList, kind in table:
        for z in keywordList:
            # Create the entry in the keyword table.
            if kind == 'string':
                func = self.createStringRule(d, z)
            else:
                func = forth_keyword_rule
            # Always make the entry.
            d[z] = kind
            self.extendRulesDict(ch=z[0], func=func)

</t>
<t tx="ekr.20150326145530.11">def createStringRule(self, d, pair):
    """Create an entry in d for a string keyword."""
    aList = pair.split(' ')
    if len(aList) != 2:
        g.trace('can not happen: expecting pair of forth strings:', pair)
        return None
    begin, end = aList

    def forth_string_word_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin=begin.strip(), end=end.strip(),
            at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)  # Don't require ending word.

    return forth_string_word_rule

</t>
<t tx="ekr.20150326145530.12">def extendRulesDict(self, ch, func):
    global rulesDict
    # Extend the rulesDict entry for the first character of z.
    aList = rulesDict.get(ch, [])
    if func not in aList:
        aList.append(func)
        rulesDict[ch] = aList

</t>
<t tx="ekr.20150326145530.2"># Rules for forth_main ruleset.

def forth_block_comment_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="(", end=")",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def forth_comment_rule(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="\\",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word
        delegate="", exclude_match=False)

def forth_keyword_rule(colorer, s, i):
    return colorer.match_keywords(s, i)

def forth_string_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
# ==========================

if 0:

    def forth_rule0(colorer, s, i):
        return colorer.match_eol_span(s, i, kind="comment1", seq="#",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False)

    def forth_rule1(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="\"\"\"", end="\"\"\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule2(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="'''", end="'''",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule3(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule4(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule5(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule6(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="!",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule7(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule8(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule9(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="+",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule10(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="-",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule11(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="/",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule12(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="*",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule13(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule14(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule15(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="%",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule16(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&amp;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule17(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="|",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule18(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="^",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule19(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="~",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule20(colorer, s, i):
        return colorer.match_mark_previous(s, i, kind="function", pattern="(",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

    def forth_rule21(colorer, s, i):
        return colorer.match_keywords(s, i)
</t>
<t tx="ekr.20150326145530.3"># Properties for forth mode.

properties = {
    # "indentNextLines": "\\s*[^#]{3,}:\\s*(#.*)?",
    "lineComment": "\\",
}
# Attributes dict for forth_main ruleset.
forth_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    # "escape": "\\",
    "highlight_digits": "false",
    "ignore_case": "false",
    "no_word_sep": "",
}
# Dictionary of attributes dictionaries for forth mode.
attributesDictDict = {
    "forth_main": forth_main_attributes_dict,
}
# Keywords dict for forth_main ruleset.
forth_main_keywords_dict = {}  # Created by extendForth class.
# Dictionary of keywords dictionaries for forth mode.
keywordsDictDict = {
    "forth_main": forth_main_keywords_dict,
}
# Rules dict for forth_main ruleset.
# This is extended by extendForth.
rulesDict = {
    '(': [forth_block_comment_rule],
    '\\': [forth_comment_rule],
    '"': [forth_string_rule],
}
# x.rulesDictDict for forth mode.
rulesDictDict = {
    "forth_main": rulesDict,
}
# Import dict for forth mode.
importDict = {}


class extendForth:
    """A helper class to extend the mode tables from @data forth-x settings."""

</t>
<t tx="ekr.20150326145530.4">    @others
</t>
<t tx="ekr.20150326145530.5">def __init__(self):
    self.c = None  # set by pre_init_mode function.
    #
    # Default forth keywords: extended by @data forth-words
    # Forth words to be rendered in boldface: extended by @data forth-bold-words
    self.boldwords = []
    #
    # Forth bold-italics words: extended by @data forth-bold-italic-words
    # Note: on some boxen, bold italics may show in plain bold.
    self.bolditalicwords = []
    #
    # Forth words that define brackets: extended by @data forth-delimiter-pairs
    self.brackets = []  # Helper: a list of tuples.
    self.brackets1 = []
    self.brackets2 = []
    #
    # Words which define other words: extended by forth-defwords
    self.definingwords = []
    #
    # Forth words to be rendered in italics: extended by forth-italic-words
    self.italicwords = []
    #
    # Default keywords: extended by @data forth-keywords
    self.keywords = []
        # "variable", "constant", "code", "end-code",
        # "dup", "2dup", "swap", "2swap", "drop", "2drop",
        # "r&gt;", "&gt;r", "2r&gt;", "2&gt;r",
        # "if", "else", "then",
        # "begin", "again", "until", "while", "repeat",
        # "v-for", "v-next", "exit",
        # "meta", "host", "target", "picasm", "macro",
        # "needs", "include",
        # "'", "[']",
        # # ":", # Now a defining word.
        # ";",
        # "@", "!", ",", "1+", "+", "-",
        # "&lt;", "&lt;=", "=", "&gt;=", "&gt;",
        # "invert", "and", "or",
    #
    # Forth words which start strings: extended by @data forth-string-word-pairs
    self.stringwords = []
    self.stringwords1 = []
    self.stringwords2 = []
    self.verbose = False  # True: tell when extending forth words.

</t>
<t tx="ekr.20150326145530.6">def init(self):
    """Set our ivars from settings."""
    c = self.c
    assert(c)
    table = (
        (self.definingwords, "forth-defwords"),
        (self.brackets, "forth-delimiter-pairs"),
        (self.keywords, "forth-words"),
        (self.stringwords, "forth-string-word-pairs"),
        (self.boldwords, "forth-bold-words"),
        (self.bolditalicwords, "forth-bold-italic-words"),
        (self.italicwords, "forth-italic-words"),
    )
    # Add entries from @data nodes (if they exist) to the corresponding lists.
    for (ivarList, setting) in table:
        extras = []
        aList = c.config.getData(setting)
        if aList:
            for s in aList:
                s = s.strip()
                if s and s[0] != '\\':
                    extras.append(s)
            if extras:
                if self.verbose:
                    if not g.app.unitTesting and not g.app.batchMode:
                        g.pr("Found extra forth: %s" % " ".join(extras))
                ivarList.extend(extras)
    # Create brackets1/2 and stringwords1/2 lists.
    table2 = (
        ("brackets", "@data forth-delimiter-pairs"),
        ("stringwords", "@data forth-string-word-pairs"),
    )
    for (ivar, setting) in table2:
        self.splitList(ivar, setting)

</t>
<t tx="ekr.20150326145530.7">def splitList(self, ivar, setting):
    """Process lines containing pairs of entries
    in a list whose *name* is ivar.
    Put the results in ivars whose names are ivar1 and ivar2."""
    result1 = []; result2 = []
    aList = getattr(self, ivar)
    # Look for pairs.  Comments have already been removed.
    for s in aList:
        pair = s.split(' ')
        if len(pair) == 2 and pair[0].strip() and pair[1].strip():
            result1.append(pair[0].strip())
            result2.append(pair[1].strip())
        else:
            g.es_print('%s: ignoring line: %s' % (setting, s))
    # Set the ivars.
    name1 = '%s1' % ivar
    name2 = '%s2' % ivar
    setattr(self, name1, result1)
    setattr(self, name2, result2)

</t>
<t tx="ekr.20150326145530.8">def createBracketRules(self):
    for z in self.brackets1:
        func = self.createBracketRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createBracketRule(self, begin):
    i = self.brackets1.index(begin)
    end = self.brackets2[i]

    def forth_bracket_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="bracketRange", begin=begin, end=end,
            at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=True)  # Require word.

    return forth_bracket_rule

</t>
<t tx="ekr.20150326145530.9">def createDefiningWordRules(self):
    for z in self.definingwords:
        func = self.createDefiningWordRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createDefiningWordRule(self, word):

    def forth_defining_word_rule(colorer, s, i):

        return colorer.match_word_and_regexp(s, i,
            kind1="keyword2",  # defining word
            word=word,
            kind2="keyword3",  # bold
            pattern=r'(\s)*(\S)+',
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            exclude_match=False)

    return forth_defining_word_rule

</t>
<t tx="ekr.20150330033306.1">on_idle_count = 0

def on_idle(self):
    '''
    Check for changed open-with files and all external files in commanders
    for which @bool check_for_changed_external_file is True.
    '''
    #
    # #1240: Note: The "asking" dialog prevents idle time.
    #
    if not g.app or g.app.killed or g.app.restarting:  # #1240.
        return
    self.on_idle_count += 1
    # New in Leo 5.7: always handle delayed requests.
    if g.app.windowList:
        c = g.app.log and g.app.log.c
        if c:
            c.outerUpdate()
    # Fix #262: Improve performance when @bool check-for-changed-external-files is True.
    if self.unchecked_files:
        # Check all external files.
        for ef in self.unchecked_files:
            self.idle_check_open_with_file(ef)
        self.unchecked_files = []
    elif self.unchecked_commanders:
        # Check the next commander for which
        # @bool check_for_changed_external_file is True.
        c = self.unchecked_commanders.pop()
        self.idle_check_commander(c)
    else:
        # Add all commanders for which
        # @bool check_for_changed_external_file is True.
        self.unchecked_commanders = [
            z for z in g.app.commanders() if self.is_enabled(z)
        ]
        self.unchecked_files = [z for z in self.files if z.exists()]
</t>
<t tx="ekr.20150402111403.1"></t>
<t tx="ekr.20150402111413.1">def addToCommandHistory(self, commandName):
    """Add a name to the command history."""
    k = self
    h = k.commandHistory
    if commandName in h:
        h.remove(commandName)
    h.append(commandName)
    k.commandIndex = None
</t>
<t tx="ekr.20150402111935.1">def sortCommandHistory(self):
    """Sort the command history."""
    k = self
    k.commandHistory.sort()
    k.commandIndex = None
</t>
<t tx="ekr.20150402165918.1">def commandHistoryFwd(self):
    """
    Move down the Command History - fall off the bottom (return empty string)
    if necessary
    """
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        commandName = ''
        if i == len(h) - 1:
            # fall off the bottom
            i = None
        elif i is not None:
            # move to next down in list
            i += 1
            commandName = h[i]
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
</t>
<t tx="ekr.20150402171131.1">def commandHistoryBackwd(self):
    """
    Return the previous entry in the Command History - stay at the top
    if we are there
    """
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        if i is None:
            # first time in - set to last entry
            i = len(h) - 1
        elif i &gt; 0:
            i -= 1
        commandName = h[i]
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
</t>
<t tx="ekr.20150403044823.1">def idle_check_at_file_node(self, c, p):
    '''Check the @&lt;file&gt; node at p for external changes.'''
    path = g.fullPath(c, p)
    if not self.has_changed(path):
        return
    if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
        # Fix #1081: issue a warning.
        self.warn(c, path, p=p)
    elif self.ask(c, path, p=p):
        c.redraw(p=p)
        c.refreshFromDisk(p)
        c.redraw()
    # Always update the path &amp; time to prevent future warnings.
    self.set_time(path)
    self.checksum_d[path] = self.checksum(path)
</t>
<t tx="ekr.20150404045115.1">def idle_check_commander(self, c):
    '''
    Check all external files corresponding to @&lt;file&gt; nodes in c for
    changes.
    '''
    # #1240: Check the .leo file itself.
    self.idle_check_leo_file(c)
    #
    # #1100: always scan the entire file for @&lt;file&gt; nodes.
    # #1134: Nested @&lt;file&gt; nodes are no longer valid, but this will do no harm.
    for p in c.all_unique_positions():
        if p.isAnyAtFileNode():
            self.idle_check_at_file_node(c, p)
</t>
<t tx="ekr.20150405200212.1">def ask(self, c, path, p=None):
    '''
    Ask user whether to overwrite an @&lt;file&gt; tree.
    Return True if the user agrees.
    '''
    if g.unitTesting:
        return False
    if c not in g.app.commanders():
        return False
    is_leo = path.endswith(('.leo', '.db'))
    is_external_file = not is_leo
    #
    # Create the message.
    message1 = f"{g.splitLongFileName(path)} has changed outside Leo.\n"
    if is_leo:
        message2 = 'Restart Leo?'
    elif p:
        message2 = f"Reload {p.h}?"
    else:
        for ef in self.files:
            if ef.path == path:
                message2 = f"Reload {ef.p.h}?"
                break
        else:
            message2 = f"Reload {path}?"
    #
    # #1240: Note: This dialog prevents idle time.
    result = g.app.gui.runAskYesNoDialog(c,
        'Overwrite the version in Leo?',
        message1 + message2,
        yes_all=is_external_file,
        no_all=is_external_file,
    )
    return bool(result and 'yes' in result.lower())
        # Careful: may be unit testing.
</t>
<t tx="ekr.20150407124259.1">def idle_check_open_with_file(self, ef):
    '''Update the open-with node given by ef.'''
    assert isinstance(ef, ExternalFile), ef
    if ef.path and os.path.exists(ef.path):
        time = self.get_mtime(ef.path)
        if time and time != ef.time:
            ef.time = time  # inhibit endless dialog loop.
            self.update_open_with_node(ef)
</t>
<t tx="ekr.20150407205631.1">def update_open_with_node(self, ef):
    '''Update the body text of ef.p to the contents of ef.path.'''
    assert isinstance(ef, ExternalFile), ef
    c, p = ef.c, ef.p.copy()
    # Ask the user how to resolve the conflict.
    if self.ask(c, ef.path, p=p):
        g.blue(f"updated {p.h}")
        s, e = g.readFileIntoString(ef.path)
        p.b = s
        if c.config.getBool('open-with-goto-node-on-update'):
            c.selectPosition(p)
        if c.config.getBool('open-with-save-on-update'):
            c.save()
        else:
            p.setDirty()
            c.setChanged()
</t>
<t tx="ekr.20150413091056.1">"""Warn if leoProjects.txt or leoToDo.txt contain any clones."""

clones,nodes,seen = 0,0,set()
table = (
  '@file ../doc/leoProjects.txt',
  '@file ../doc/leoToDo.txt',
)

def check_clone(c,p0,root):
    """Warn if p appears in any @&lt;file&gt; node outside of root's tree."""
    global nodes,seen
    v = p0.v
    for p in c.all_positions():
        nodes += 1
        if p.v == v:
            # Check *all* ancestors, not just the nearest one.
            for parent in p.self_and_parents():
                nodes += 1
                if parent.isAnyAtFileNode() and parent.v != root.v:
                    if parent.v not in seen:
                        seen.add(parent.v)
                        g.es_print('%s and %s contain clone: %s' % (
                            root.h,parent.h,p0.h))

for h in table:
    root = g.findNodeAnywhere(c,h)
    if root:
        for p in root.self_and_subtree():
            nodes += 1
            if p.isCloned():
                clones += 1
                check_clone(c,p,root)
    else:
        g.es_print('not found',h,color='red')
print('done: %s nodes, %s clones' % (nodes,clones))

@tabwidth -4
@language python
</t>
<t tx="ekr.20150425143043.1">def initCommandHistory(self):
    """Init command history from @data command-history nodes."""
    k, c = self, self.c
    aList = c.config.getData('history-list') or []
    for command in reversed(aList):
        k.addToCommandHistory(command)

def resetCommandHistory(self):
    """ reset the command history index to indicate that
        we are pointing 'past' the last entry
    """
    self.commandIndex = None
    #
</t>
<t tx="ekr.20150425145248.1">run-pylint
clone-to-at-spot
beautify-tree
cfa-code
sort-lines
# show-data
# test-ptb
check-clones
expand-log-pane
contract-log-pane</t>
<t tx="ekr.20150502050609.1">c.backup_helper(sub_dir='leoPy')
</t>
<t tx="ekr.20150507170849.1">g.cls()

print('===== Start =====')

class CreateDecorators:
    """
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    """
    def __init__(self,c,make_changes):
        self.c = c
        self.fixups = self.create_fixups()
        self.n = 0
        self.n_fail = 0
        self.make_changes=make_changes
        self.suppress = [
            'c.frame.body and c.frame.body.addEditor',
            'cls','cloneFindParents','cycleTabFocus',
            'k and k.keyboardQuit',
            'menuShortcutPlaceHolder','removeBlankLines',
            'saveBuffersKillLeo',
        ]
    @others

CreateDecorators(c,make_changes=False).run()
</t>
<t tx="ekr.20150507174711.1">def find_next_clone(self,p):
    v = p.v
    p = p.copy()
    p.moveToThreadNext()
    wrapped = False
    while 1:
        # g.trace(p.v,p.h)
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()
    return p
</t>
<t tx="ekr.20150507175246.1">def munge_lines(self,root,publicCommands):
    """Return munged lines of """
    s = publicCommands.b
    i,j = s.find('{'),s.find('}')
    s = s[i+1:j]
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150508062944.1">def run(self):
    """Top-level code."""
    self.n = 0
    found = g.findNodeAnywhere(c,'Found: getPublicCommands')
    assert found
    for child in found.children():
        publicCommands = self.find_next_clone(child)
        root = self.find_class(publicCommands)
        if root:
            lines = self.munge_lines(root,publicCommands)
            d = self.create_d(lines,publicCommands)
            self.create_decorators(d,root)
    print('\n%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150508063412.1">def create_decorators(self,d,root):
    """Create decorators for all items in d in root's tree."""
    # print('***** %s' % root.h)
    if root.h in self.fixups:
        roots = []
        aList = self.fixups.get(root.h)
        for root2_h in aList:
            root2 = g.findNodeAnywhere(self.c,root2_h)
            if root2:
                # g.trace(root.h,'=====&gt;',root2.h)
                roots.append(root2)
            else:
                g.trace('===== not found',root2_h)
    else:
        roots = [root]
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print('===== not found: %30s %s' % (root.h,f_name))
            self.n_fail += 1
</t>
<t tx="ekr.20150508063538.1">def create_d(self,lines,publicCommands):
    """Create a dict. keys are method names; values are command names."""
    trace = False
    if trace:
        g.trace('\n', publicCommands.h)
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150508063926.1">def find_class(self,p):
    """Return the position of the class enclosing p."""
    for p2 in p.parents():
        if p2.h.lower().find('class') &gt; -1 and p2.b.find('class') &gt; -1:
            return p2
    else:
        g.trace('*** no class for p.h')
        return None
</t>
<t tx="ekr.20150508071622.1">def create_decorator(self,c_name,f_name,root):
    """
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    """
    # g.trace('%45s %s' % (c_name,f_name))
    trace = False
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        # if changed and self.make_changes:
            # new_body = ''.join(result)
            # # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150508074623.1">def create_fixups(self):
    """
    Return a fixup dict.
    Keys are headlines for classes.
    Values are new headlines of nodes containing the actual class.
    """
    return {
        'ChapterCommandsClass': ['class ChapterController'],
        'EditCommandsClass': [
            'EditCommandsClass',
            'class Commands',
            'class LeoQtFrame',
            'class LeoBody',
        ],
        'class SearchCommandsClass': ['class LeoFind (LeoFind.py)'],
        'KeyHandlerCommandsClass (add docstrings)': [
            'class KeyHandlerClass',
            'class AutoCompleterClass',
        ]
    }
</t>
<t tx="ekr.20150509035028.1">def cmd(name):
    """Command decorator for the leoKeys class."""
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'k',])
</t>
<t tx="ekr.20150509035140.1">def cmd(name):
    """Command decorator for the AutoCompleter class."""
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'k', 'autoCompleter'])
</t>
<t tx="ekr.20150509183433.1">g.cls()

# Changed files:
# leoApp.py
# leoAtFile.py
# leoCommands.py
# leoFileCommands.py
# leoFrame.py
# leoUndo.py
# qt_frame.py

make_changes = True
    # True, actually make the change

class CreateDecorators:
    """
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    """
    def __init__(self):
        self.n = 0
        self.n_fail = 0
        self.s = self.define_s()
    @others

CreateDecorators().run()
</t>
<t tx="ekr.20150509183433.2">def create_d(self,lines):
    """Create a dict. keys are method names; values are command names."""
    trace = False
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150509183433.3">def create_decorator(self,c_name,f_name,root):
    """
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    """
    trace = True
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        if changed and make_changes:
            new_body = ''.join(result)
            print('%40s %s' % (p.h[:40],decorator.rstrip()))
            # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150509183433.4">def create_decorators(self,d):
    """Create decorators for all items in d in root's tree."""
    table = (
        'class Commands', # c.
        'class LeoQtFrame', # f.
        'class LeoFrame', # f.
        'class LeoApp', # g.app.
        '@file leoAtFile.py', # c.atFileCommands
        '@file leoFileCommands.py', # c.fileCommands
        'class Undoer', # c.undoer
    )
    roots = []
    for h in table:
        root = g.findNodeAnywhere(c,h)
        assert root,h
        roots.append(root)
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print(f"===== not found: {f_name!r}")
            self.n_fail += 1
</t>
<t tx="ekr.20150509183433.8">def munge_lines(self,s):
    """Return munged lines of s. """
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150509183433.9">def run(self):
    """Top-level code."""
    lines = self.munge_lines(self.s)
    d = self.create_d(lines)
    self.create_decorators(d)
    print('%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150514035207.1"></t>
<t tx="ekr.20150514043714.3"></t>
<t tx="ekr.20150514043714.4">def beginCommand(self, w, undoType='Typing'):
    """Do the common processing at the start of each command."""
    c, p, u = self.c, self.c.p, self.c.undoer
    name = c.widget_name(w)
    if name.startswith('body'):
        self.undoData = b = g.Bunch()
        # To keep pylint happy.
        b.ch = ''
        b.name = name
        b.oldSel = w.getSelectionRange()
        b.oldText = p.b
        b.w = w
        b.undoType = undoType
        b.undoer_bunch = u.beforeChangeBody(p)  # #1733.
    else:
        self.undoData = None
    return w
</t>
<t tx="ekr.20150514043714.6">def endCommand(self, label=None, changed=True, setLabel=True):
    """
    Do the common processing at the end of each command.
    Handles undo only if we are in the body pane.
    """
    k, p, u= self.c.k, self.c.p, self.c.undoer
    w = self.editWidget(event=None)
    b = self.undoData
    if b and b.name.startswith('body') and changed:
        newText = w.getAllText()
        if b.undoType.capitalize() == 'Typing':
            u.doTyping(p, 'Typing', oldText=b.oldText, newText=newText, oldSel=b.oldSel)
        else:
            p.v.b = newText  # p.b would cause a redraw.
            u.afterChangeBody(p, b.undoType, b.undoer_bunch)
            
    self.undoData = None
    k.clearState()
    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
</t>
<t tx="ekr.20150514043850.14">def find_place_holder(self, p, do_placeholder):
    """
    Search for the next place-holder.
    If found, select the place-holder (without the delims).
    """
    c = self.c
    # Do #438: Search for placeholder in headline.
    s = p.h
    if do_placeholder or c.abbrev_place_start and c.abbrev_place_start in s:
        new_s, i, j = self.next_place(s, offset=0)
        if i is not None:
            p.h = new_s
            c.redraw(p)
            c.editHeadline()
            w = c.edit_widget(p)
            w.setSelectionRange(i, j, insert=j)
            return True
    s = p.b
    if do_placeholder or c.abbrev_place_start and c.abbrev_place_start in s:
        new_s, i, j = self.next_place(s, offset=0)
        if i is None:
            return False
        w = c.frame.body.wrapper
        switch = p != c.p
        if switch:
            c.selectPosition(p)
        else:
            scroll = w.getYScrollPosition()
        oldSel = w.getSelectionRange()
        w.setAllText(new_s)
        c.frame.body.onBodyChanged(undoType='find-place-holder', oldSel=oldSel)
        c.p.b = new_s
        if switch:
            c.redraw()
        w.setSelectionRange(i, j, insert=j)
        if switch:
            w.seeInsertPoint()
        else:
            # Keep the scroll point if possible.
            w.setYScrollPosition(scroll)
            w.seeInsertPoint()
        c.bodyWantsFocusNow()
        return True
    # #453: do nothing here.
        # c.frame.body.forceFullRecolor()
        # c.bodyWantsFocusNow()
    return False
</t>
<t tx="ekr.20150514043850.15">def make_script_substitutions(self, i, j, val):
    """Make scripting substitutions in node p."""
    c = self.c
    if not c.abbrev_subst_start:
        return val, False
    # Nothing to undo.
    if c.abbrev_subst_start not in val:
        return val, False
    # Perform all scripting substitutions.
    self.save_ins = None
    self.save_sel = None
    while c.abbrev_subst_start in val:
        prefix, rest = val.split(c.abbrev_subst_start, 1)
        content = rest.split(c.abbrev_subst_end, 1)
        if len(content) != 2:
            break
        content, rest = content
        try:
            self.expanding = True
            c.abbrev_subst_env['x'] = ''
            exec(content, c.abbrev_subst_env, c.abbrev_subst_env)
        except Exception:
            g.es_print('exception evaluating', content)
            g.es_exception()
        finally:
            self.expanding = False
        x = c.abbrev_subst_env.get('x')
        if x is None: x = ''
        val = f"{prefix}{x}{rest}"
        # Save the selection range.
        w = c.frame.body.wrapper
        self.save_ins = w.getInsertPoint()
        self.save_sel = w.getSelectionRange()
    if val == "__NEXT_PLACEHOLDER":
        # user explicitly called for next placeholder in an abbrev.
        # inserted previously
        val = ''
        do_placeholder = True
    else:
        do_placeholder = False
        oldSel = i, j
        c.frame.body.onBodyChanged(undoType='make-script-substitution', oldSel=oldSel)
    return val, do_placeholder
</t>
<t tx="ekr.20150514043850.18">def replace_selection(self, w, i, j, s):
    """Replace w[i:j] by s."""
    w_name = g.app.gui.widget_name(w)
    c = self.c
    if i == j:
        abbrev = ''
    else:
        abbrev = w.get(i, j)
        w.delete(i, j)
    if s is not None:
        w.insert(i, s)
    if w_name.startswith('head'):
        pass  # Don't set p.h here!
    else:
        # Fix part of #438. Don't leave the headline.
        oldSel = j, j
        c.frame.body.onBodyChanged('Abbreviation', oldSel=oldSel)
    # Adjust self.save_sel &amp; self.save_ins
    if s is not None and self.save_sel is not None:
        # pylint: disable=unpacking-non-sequence
        i, j = self.save_sel
        ins = self.save_ins
        delta = len(s) - len(abbrev)
        self.save_sel = i + delta, j + delta
        self.save_ins = ins + delta
</t>
<t tx="ekr.20150514043850.8">def init_settings(self):
    """Called from AbbrevCommands.reload_settings aka reloadSettings."""
    c = self.c
    c.k.abbrevOn = c.config.getBool('enable-abbreviations', default=False)
    c.abbrev_place_end = c.config.getString('abbreviations-place-end')
    c.abbrev_place_start = c.config.getString('abbreviations-place-start')
    c.abbrev_subst_end = c.config.getString('abbreviations-subst-end')
    c.abbrev_subst_env = {'c': c, 'g': g, '_values': {},}
        # The environment for all substitutions.
        # May be augmented in init_env.
    c.abbrev_subst_start = c.config.getString('abbreviations-subst-start')
    # Local settings.
    self.enabled = (
        c.config.getBool('scripting-at-script-nodes') or
        c.config.getBool('scripting-abbreviations'))
    self.globalDynamicAbbrevs = c.config.getBool('globalDynamicAbbrevs')
    # @data abbreviations-subst-env must *only* be defined in leoSettings.leo or myLeoSettings.leo!
    if c.config:
        key = 'abbreviations-subst-env'
        if c.config.isLocalSetting(key, 'data'):
            g.issueSecurityWarning(f"@data {key}")
            self.subst_env = ""
        else:
            self.subst_env = c.config.getData(key, strip_data=False)
</t>
<t tx="ekr.20150514045829.12">def renameBuffer(self, event):
    """Rename a buffer, i.e., change a node's headline."""
    g.es('rename-buffer not ready yet')
    if 0:
        self.c.k.setLabelBlue('Rename buffer from: ')
        self.getBufferName(event, self.renameBufferFinisher1)

def renameBufferFinisher1(self, name):
    self.fromName = name
    self.c.k.setLabelBlue(f"Rename buffer from: {name} to: ")
    event = None
    self.getBufferName(event, self.renameBufferFinisher2)

def renameBufferFinisher2(self, name):
    c = self.c
    p = self.findBuffer(self.fromName)
    if p:
        c.endEditing()
        p.h = name
        c.redraw(p)
</t>
<t tx="ekr.20150514063305.244">@cmd('indent-relative')
def indentRelative(self, event):
    """
    The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.

    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.
    """
    c = self.c
    undoType = 'indent-relative'
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    s = w.getAllText()
    ins = w.getInsertPoint()
    oldSel = w.getSelectionRange()
    # Find the previous non-blank line
    i, j = g.getLine(s, ins)
    while 1:
        if i &lt;= 0: return
        i, j = g.getLine(s, i - 1)
        line = s[i:j]
        if line.strip(): break
    self.beginCommand(w, undoType=undoType)
    try:
        k = g.skip_ws(s, i)
        ws = s[i:k]
        i2, j2 = g.getLine(s, ins)
        k = g.skip_ws(s, i2)
        line = ws + s[k:j2]
        w.delete(i2, j2)
        w.insert(i2, line)
        w.setInsertPoint(i2 + len(ws))
        c.frame.body.onBodyChanged(undoType, oldSel=oldSel)
    finally:
        self.endCommand(changed=True, setLabel=True)
</t>
<t tx="ekr.20150514063305.253">@cmd('backward-delete-char')
def backwardDeleteCharacter(self, event=None):
    """Delete the character to the left of the cursor."""
    c = self.c
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i, j = w.getSelectionRange()
    if wname.startswith('body'):
        self.beginCommand(w, undoType='Typing')
        try:
            tab_width = c.getTabWidth(c.p)
            changed = True
            if i != j:
                w.delete(i, j)
                w.setSelectionRange(i, i, insert=i)
            elif i == 0:
                changed = False
            elif tab_width &gt; 0:
                w.delete(ins - 1)
                w.setSelectionRange(ins - 1, ins - 1, insert=ins - 1)
            else:
                &lt;&lt; backspace with negative tab_width &gt;&gt;
        finally:
            self.endCommand(changed=changed, setLabel=False)
                # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        s = w.getAllText()
        # Delete something if we can.
        if i != j:
            j = max(i, min(j, len(s)))
            w.delete(i, j)
            w.setSelectionRange(i, i, insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins - 1)
            ins = ins - 1
            w.setSelectionRange(ins, ins, insert=ins)
</t>
<t tx="ekr.20150514063305.254">s = prev = w.getAllText()
ins = w.getInsertPoint()
i, j = g.getLine(s, ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)
# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n, n2)
count = 0
while n2 &gt; 0:
    n2 -= 1
    ch = prev[n - count - 1]
    if ch != ' ': break
    else: count += 1
# Make sure we actually delete something.
i = ins - (max(1, count))
w.delete(i, ins)
w.setSelectionRange(i, i, insert=i)
</t>
<t tx="ekr.20150514063305.259">@cmd('delete-char')
def deleteNextChar(self, event):
    """Delete the character to the right of the cursor."""
    c, w = self.c, self.editWidget(event)
    if not w:
        return
    wname = c.widget_name(w)
    if wname.startswith('body'):
        s = w.getAllText()
        i, j = w.getSelectionRange()
        self.beginCommand(w, undoType='delete-char')
        changed = True
        if i != j:
            w.delete(i, j)
            w.setInsertPoint(i)
        elif j &lt; len(s):
            w.delete(i)
            w.setInsertPoint(i)
        else:
            changed = False
        self.endCommand(changed=changed, setLabel=False)
    else:
        # No undo in this widget.
        s = w.getAllText()
        i, j = w.getSelectionRange()
        # Delete something if we can.
        if i != j:
            w.delete(i, j)
            w.setInsertPoint(i)
        elif j &lt; len(s):
            w.delete(i)
            w.setInsertPoint(i)
</t>
<t tx="ekr.20150514063305.262">@cmd('insert-newline')
def insertNewLine(self, event):
    """Insert a newline at the cursor."""
    self.insertNewlineBase(event)

insertNewline = insertNewLine

def insertNewlineBase(self, event):
    """A helper that can be monkey-patched by tables.py plugin."""
    # Note: insertNewlineHelper already exists.
    c, k = self.c, self.c.k
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    if not g.isTextWrapper(w):
        return  # pragma: no cover (defensive)
    name = c.widget_name(w)
    if name.startswith('head'):
        return
    oldSel = w.getSelectionRange()
    self.beginCommand(w, undoType='newline')
    self.insertNewlineHelper(w=w, oldSel=oldSel, undoType=None)
    k.setInputState('insert')
    k.showStateAndMode()
    self.endCommand()
</t>
<t tx="ekr.20150514063305.263">@cmd('newline-and-indent')
def insertNewLineAndTab(self, event):
    """Insert a newline and tab at the cursor."""
    trace = 'keys' in g.app.debug
    c, k = self.c, self.c.k
    p = c.p
    w = self.editWidget(event)
    if not w:
        return
    if not g.isTextWrapper(w):
        return
    name = c.widget_name(w)
    if name.startswith('head'):
        return
    if trace: g.trace('(newline-and-indent)')
    self.beginCommand(w, undoType='insert-newline-and-indent')
    oldSel = w.getSelectionRange()
    self.insertNewlineHelper(w=w, oldSel=oldSel, undoType=None)
    self.updateTab(p, w, smartTab=False)
    k.setInputState('insert')
    k.showStateAndMode()
    self.endCommand(changed=True, setLabel=False)
</t>
<t tx="ekr.20150514063305.266">@cmd('remove-blank-lines')
def removeBlankLines(self, event):
    """
    Remove lines containing nothing but whitespace.

    Select all lines if there is no existing selection.
    """
    c, p, u, w = self.c, self.c.p, self.c.undoer, self.editWidget(event)
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Initial data.
    oldYview = w.getYScrollPosition()
    lines = g.splitLines(w.getAllText())
    #
    # Calculate the result.
    changed, result = False, []
    for line in lines:
        if line.strip():
            result.append(line)
        else:
            changed = True
    if not changed:
        return  # pragma: no cover (defensive)
    #
    # Set p.b and w's text first.
    result = ''.join(result)
    p.b = result
    w.setAllText(result)
    i, j = 0, max(0, len(result) - 1)
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    c.undoer.afterChangeBody(p, 'remove-blank-lines', bunch)
</t>
<t tx="ekr.20150514063305.268"># @cmd('self-insert-command')

def selfInsertCommand(self, event, action='insert'):
    """
    Insert a character in the body pane.

    This is the default binding for all keys in the body pane.
    It handles undo, bodykey events, tabs, back-spaces and bracket matching.
    """
    trace = 'keys' in g.app.debug
    c, p, u, w = self.c, self.c.p, self.c.undoer, self.editWidget(event)
    undoType = 'Typing'
    if not w:
        return  # pragma: no cover (defensive)
    &lt;&lt; set local vars &gt;&gt;
    if not ch:
        return
    if trace: g.trace('ch', repr(ch)) # and ch in '\n\r\t'
    assert g.isStrokeOrNone(stroke)
    if g.doHook("bodykey1", c=c, p=p, ch=ch, oldSel=oldSel, undoType=undoType):
        return
    if ch == '\t':
        self.updateTab(p, w, smartTab=True)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key.
        self.backwardDeleteCharacter(event)
    elif ch in ('\r', '\n'):
        ch = '\n'
        self.insertNewlineHelper(w, oldSel, undoType)
    elif ch in '\'"' and c.config.getBool('smart-quotes'):
        self.doSmartQuote(action, ch, oldSel, w)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p, w, ch, oldSel)
    elif ch:
        # Null chars must not delete the selection.
        self.doPlainChar(action, ch, event, inBrackets, oldSel, stroke, w)
    #
    # Common processing.
    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w, spot)
    #
    # Update the text and handle undo.
    newText = w.getAllText()
    if newText != oldText:
        # Call u.doTyping to honor the user's undo granularity.
        newSel = w.getSelectionRange()
        newInsert = w.getInsertPoint()
        newSel = w.getSelectionRange()
        newText = w.getAllText()  # Converts to unicode.
        u.doTyping(p, 'Typing', oldText, newText,
            oldSel=oldSel, oldYview=oldYview, newInsert=newInsert, newSel=newSel)
    g.doHook("bodykey2", c=c, p=p, ch=ch, oldSel=oldSel, undoType=undoType)
</t>
<t tx="ekr.20150514063305.269">stroke = event.stroke if event else None
ch = event.char if event else ''
if ch == 'Return':
    ch = '\n'  # This fixes the MacOS return bug.
if ch == 'Tab':
    ch = '\t'
name = c.widget_name(w)
oldSel = w.getSelectionRange() if name.startswith('body') else (None, None)
oldText = p.b if name.startswith('body') else ''
oldYview = w.getYScrollPosition()
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.checkUnicode(ch) in brackets
</t>
<t tx="ekr.20150514063305.270">def doPlainTab(self, s, i, tab_width, w):
    """
    A helper for selfInsertCommand, called from updateTab.
    
    Insert spaces equivalent to one tab.
    """
    trace = 'keys' in g.app.debug
    start, end = g.getLine(s, i)
    s2 = s[start:i]
    width = g.computeWidth(s2, tab_width)
    if trace: g.trace('width', width)
    if tab_width &gt; 0:
        w.insert(i, '\t')
        ins = i + 1
    else:
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i, ' ' * n)
        ins = i + n
    w.setSelectionRange(ins, ins, insert=ins)
</t>
<t tx="ekr.20150514063305.271">def flashCharacter(self, w, i):
    """Flash the character at position i of widget w."""
    bg = self.bracketsFlashBg or 'DodgerBlue1'
    fg = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 3
    delay = self.bracketsFlashDelay or 75
    w.flashCharacter(i, bg, fg, flashes, delay)
</t>
<t tx="ekr.20150514063305.272">def flashMatchingBracketsHelper(self, c, ch, i, p, w):
    """Flash matching brackets at char ch at position i at widget w."""
    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d[self.openBracketsList[z]] = self.closeBracketsList[z]
        # reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d[self.closeBracketsList[z]] = self.openBracketsList[z]
        # reverse = True # Search backward
    s = w.getAllText()
    # A partial fix for bug 127: Bracket matching is buggy.
    language = g.getLanguageAtPosition(c, p)
    if language == 'perl':
        return
    j = g.MatchBrackets(c, p, language).find_matching_bracket(ch, s, i)
    if j is not None:
        self.flashCharacter(w, j)
</t>
<t tx="ekr.20150514063305.273">def initBracketMatcher(self, c):
    """Init the bracket matching code."""
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList = '([{'
        self.closeBracketsList = ')]}'
</t>
<t tx="ekr.20150514063305.274">def insertNewlineHelper(self, w, oldSel, undoType):

    c, p = self.c, self.c.p
    i, j = oldSel
    ch = '\n'
    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i, j)
        w.insert(i, ch)
        w.setInsertPoint(i + 1)
    else:
        w.insert(i, ch)
        w.setInsertPoint(i + 1)
        if (c.autoindent_in_nocolor or
            (c.frame.body.colorizer.useSyntaxColoring(p) and
            undoType != "Change")
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p, w)
    w.seeInsertPoint()
</t>
<t tx="ekr.20150514063305.275">def updateAutoIndent(self, p, w):
    """Handle auto indentation."""
    c = self.c
    tab_width = c.getTabWidth(p)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s, ins)
    i, j = g.getLine(s, i - 1)
    s = s[i : j - 1]
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s, 0, tab_width)
    if s and s[-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.findLanguageDirectives(c, p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width]
        tabex = 0
        for i, ch in enumerate(s):
            if ch == '\t':
                tabex += tab_width - 1
            if ch in '([{':
                bracketWidths.append(i + tabex + 1)
            elif ch in '}])' and len(bracketWidths) &gt; 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width, tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i, ws)
        w.setInsertPoint(i + len(ws))
        w.seeInsertPoint()
            # 2011/10/02: Fix cursor-movement bug.
</t>
<t tx="ekr.20150514063305.276">def updateAutomatchBracket(self, p, w, ch, oldSel):

    c = self.c
    d = c.scanAllDirectives(p)
    i, j = oldSel
    language = d.get('language')
    s = w.getAllText()
    if ch in ('(', '[', '{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(': ')', '[': ']', '{': '}'}.get(ch)
        if i != j: w.delete(i, j)
        w.insert(i, ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins - 1)
    else:
        ins = w.getInsertPoint()
        ch2 = s[ins] if ins &lt; len(s) else ''
        if ch2 in (')', ']', '}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins + 1)
        else:
            if i != j: w.delete(i, j)
            w.insert(i, ch)
            w.setInsertPoint(i + 1)
</t>
<t tx="ekr.20150514063305.277">def updateTab(self, p, w, smartTab=True):
    """
    A helper for selfInsertCommand.

    Add spaces equivalent to a tab.
    """
    c = self.c
    i, j = w.getSelectionRange()
        # Returns insert point if no selection, with i &lt;= j.
    if i != j:
        c.indentBody()
        return
    tab_width = c.getTabWidth(p)
    # Get the preceeding characters.
    s = w.getAllText()
    start, end = g.getLine(s, i)
    after = s[i:end]
    if after.endswith('\n'):
        after = after[:-1]
    # Only do smart tab at the start of a blank line.
    doSmartTab = (smartTab and c.smart_tab and i == start)
        # Truly at the start of the line.
        # and not after # Nothing *at all* after the cursor.
    if doSmartTab:
        self.updateAutoIndent(p, w)
        # Add a tab if otherwise nothing would happen.
        if s == w.getAllText():
            self.doPlainTab(s, i, tab_width, w)
    else:
        self.doPlainTab(s, i, tab_width, w)
</t>
<t tx="ekr.20150514063305.278">@cmd('insert-file-name')
def insertFileName(self, event=None):
    """
    Prompt for a file name, then insert it at the cursor position.
    This operation is undoable if done in the body pane.

    The initial path is made by concatenating path_for_p() and the selected
    text, if there is any, or any path like text immediately preceding the
    cursor.
    """
    c, u, w = self.c, self.c.undoer, self.editWidget(event)
    if not w:
        return

    def callback(arg, w=w):
        i = w.getSelectionRange()[0]
        p = c.p
        w.deleteTextSelection()
        w.insert(i, arg)
        newText = w.getAllText()
        if g.app.gui.widget_name(w) == 'body' and p.b != newText:
            bunch = u.beforeChangeBody(p)
            p.v.b = newText  # p.b would cause a redraw.
            u.afterChangeBody(p, 'insert-file-name', bunch)

    # see if the widget already contains the start of a path

    start_text = w.getSelectedText()
    if not start_text:  # look at text preceeding insert point
        start_text = w.getAllText()[: w.getInsertPoint()]
        if start_text:
            # make non-path characters whitespace
            start_text = ''.join(i if i not in '\'"`()[]{}&lt;&gt;!|*,@#$&amp;' else ' '
                                 for i in start_text)
            if start_text[-1].isspace():  # use node path if nothing typed
                start_text = ''
            else:
                start_text = start_text.rsplit(None, 1)[-1]
                # set selection range so w.deleteTextSelection() works in the callback
                w.setSelectionRange(
                    w.getInsertPoint() - len(start_text), w.getInsertPoint())

    c.k.functionTail = g.os_path_finalize_join(
        self.path_for_p(c, c.p), start_text or '')
    c.k.getFileName(event, callback=callback)
</t>
<t tx="ekr.20150514063305.285"></t>
<t tx="ekr.20150514063305.286"></t>
<t tx="ekr.20150514063305.287">def extendHelper(self, w, extend, spot, upOrDown=False):
    """
    Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    """
    c, p = self.c, self.c.p
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i, j = w.getSelectionRange()
    # Reset the move spot if needed.
    if self.moveSpot is None or p.v != self.moveSpotNode:
        self.setMoveCol(w, ins if extend else spot)  # sets self.moveSpot.
    elif extend:
        # 2011/05/20: Fix bug 622819
        # Ctrl-Shift movement is incorrect when there is an unexpected selection.
        if i == j:
            self.setMoveCol(w, ins)  # sets self.moveSpot.
        elif self.moveSpot in (i, j) and self.moveSpot != ins:
            # The bug fix, part 1.
            pass
        else:
            # The bug fix, part 2.
            # Set the moveCol to the *not* insert point.
            if ins == i: k = j
            elif ins == j: k = i
            else: k = ins
            self.setMoveCol(w, k)  # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2, j2 = g.getLine(s, spot)
            line = s[i2:j2]
            row, col = g.convertPythonIndexToRowCol(s, spot)
            if True:  # was j2 &lt; len(s)-1:
                n = min(self.moveCol, max(0, len(line) - 1))
            else:
                n = min(self.moveCol, max(0, len(line)))  # A tricky boundary.
            spot = g.convertRowColToPythonIndex(s, row, n)
        else:  # Plain move forward or back.
            self.setMoveCol(w, spot)  # sets self.moveSpot.
    if extend:
        if spot &lt; self.moveSpot:
            w.setSelectionRange(spot, self.moveSpot, insert=spot)
        else:
            w.setSelectionRange(self.moveSpot, spot, insert=spot)
    else:
        w.setSelectionRange(spot, spot, insert=spot)
    w.seeInsertPoint()
    c.frame.updateStatusLine()
</t>
<t tx="ekr.20150514063305.288">def moveToHelper(self, event, spot, extend):
    """
    Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.
    """
    c, k = self.c, self.c.k
    w = self.editWidget(event)
    if not w: return
    c.widgetWantsFocusNow(w)
    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i, j = k.getEditableTextRange()
        if spot &lt; i: spot = i
        elif spot &gt; j: spot = j
    self.extendHelper(w, extend, spot, upOrDown=False)
</t>
<t tx="ekr.20150514063305.289">def setMoveCol(self, w, spot):
    """Set the column to which an up or down arrow will attempt to move."""
    p = self.c.p
    i, row, col = w.toPythonIndexRowCol(spot)
    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v
</t>
<t tx="ekr.20150514063305.290">@cmd('back-to-home')
def backToHome(self, event, extend=False):
    """
    Smart home:
    Position the point at the first non-blank character on the line,
    or the start of the line if already there.
    """
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    if s:
        i, j = g.getLine(s, ins)
        i1 = i
        while i &lt; j and s[i] in (' \t'):
            i += 1
        if i == ins:
            i = i1
        self.moveToHelper(event, i, extend=extend)

@cmd('back-to-home-extend-selection')
def backToHomeExtendSelection(self, event):
    self.backToHome(event, extend=True)
</t>
<t tx="ekr.20150514063305.291">@cmd('back-to-indentation')
def backToIndentation(self, event):
    """Position the point at the first non-blank character on the line."""
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    s = w.getAllText()
    ins = w.getInsertPoint()
    i, j = g.getLine(s, ins)
    while i &lt; j and s[i] in (' \t'):
        i += 1
    self.moveToHelper(event, i, extend=False)
</t>
<t tx="ekr.20150514063305.292">@cmd('next-line')
def nextLine(self, event):
    """Move the cursor down, extending the selection if in extend mode."""
    self.moveUpOrDownHelper(event, 'down', extend=False)

@cmd('next-line-extend-selection')
def nextLineExtendSelection(self, event):
    """Extend the selection by moving the cursor down."""
    self.moveUpOrDownHelper(event, 'down', extend=True)

@cmd('previous-line')
def prevLine(self, event):
    """Move the cursor up, extending the selection if in extend mode."""
    self.moveUpOrDownHelper(event, 'up', extend=False)

@cmd('previous-line-extend-selection')
def prevLineExtendSelection(self, event):
    """Extend the selection by moving the cursor up."""
    self.moveUpOrDownHelper(event, 'up', extend=True)
</t>
<t tx="ekr.20150514063305.293">def moveUpOrDownHelper(self, event, direction, extend):

    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()
    if hasattr(w, 'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=direction, extend=extend)
    else:
        # Find the start of the next/prev line.
        row, col = g.convertPythonIndexToRowCol(s, ins)
        i, j = g.getLine(s, ins)
        if direction == 'down':
            i2, j2 = g.getLine(s, j)
        else:
            i2, j2 = g.getLine(s, i - 1)
        # The spot is the start of the line plus the column index.
        n = max(0, j2 - i2 - 1)  # The length of the new line.
        col2 = min(col, n)
        spot = i2 + col2
        self.extendHelper(w, extend, spot, upOrDown=True)
</t>
<t tx="ekr.20150514063305.294">@cmd('beginning-of-buffer')
def beginningOfBuffer(self, event):
    """Move the cursor to the start of the body text."""
    self.moveToBufferHelper(event, 'home', extend=False)

@cmd('beginning-of-buffer-extend-selection')
def beginningOfBufferExtendSelection(self, event):
    """Extend the text selection by moving the cursor to the start of the body text."""
    self.moveToBufferHelper(event, 'home', extend=True)

@cmd('end-of-buffer')
def endOfBuffer(self, event):
    """Move the cursor to the end of the body text."""
    self.moveToBufferHelper(event, 'end', extend=False)

@cmd('end-of-buffer-extend-selection')
def endOfBufferExtendSelection(self, event):
    """Extend the text selection by moving the cursor to the end of the body text."""
    self.moveToBufferHelper(event, 'end', extend=True)
</t>
<t tx="ekr.20150514063305.295">def moveToBufferHelper(self, event, spot, extend):
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    if hasattr(w, 'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot, extend=extend)
    else:
        if spot == 'home':
            self.moveToHelper(event, 0, extend=extend)
        elif spot == 'end':
            s = w.getAllText()
            self.moveToHelper(event, len(s), extend=extend)
        else:
            g.trace('can not happen: bad spot', spot)  # pragma: no cover (defensive)
</t>
<t tx="ekr.20150514063305.296">@cmd('back-char')
def backCharacter(self, event):
    """Move the cursor back one character, extending the selection if in extend mode."""
    self.moveToCharacterHelper(event, 'left', extend=False)

@cmd('back-char-extend-selection')
def backCharacterExtendSelection(self, event):
    """Extend the selection by moving the cursor back one character."""
    self.moveToCharacterHelper(event, 'left', extend=True)

@cmd('forward-char')
def forwardCharacter(self, event):
    """Move the cursor forward one character, extending the selection if in extend mode."""
    self.moveToCharacterHelper(event, 'right', extend=False)

@cmd('forward-char-extend-selection')
def forwardCharacterExtendSelection(self, event):
    """Extend the selection by moving the cursor forward one character."""
    self.moveToCharacterHelper(event, 'right', extend=True)
</t>
<t tx="ekr.20150514063305.297">def moveToCharacterHelper(self, event, spot, extend):
    w = self.editWidget(event)
    if not w:
        return
    if hasattr(w, 'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot, extend=extend)
    else:
        i = w.getInsertPoint()
        if spot == 'left':
            i = max(0, i - 1)
            self.moveToHelper(event, i, extend=extend)
        elif spot == 'right':
            i = min(i + 1, len(w.getAllText()))
            self.moveToHelper(event, i, extend=extend)
        else:
            g.trace(f"can not happen: bad spot: {spot}")
</t>
<t tx="ekr.20150514063305.298">@cmd('clear-extend-mode')
def clearExtendMode(self, event):
    """Turn off extend mode: cursor movement commands do not extend the selection."""
    self.extendModeHelper(event, False)

@cmd('set-extend-mode')
def setExtendMode(self, event):
    """Turn on extend mode: cursor movement commands do extend the selection."""
    self.extendModeHelper(event, True)

@cmd('toggle-extend-mode')
def toggleExtendMode(self, event):
    """Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections."""
    self.extendModeHelper(event, not self.extendMode)

def extendModeHelper(self, event, val):
    c = self.c
    w = self.editWidget(event)
    if w:
        self.extendMode = val
        if not g.unitTesting:
            # g.red('extend mode','on' if val else 'off'))
            c.k.showStateAndMode()
        c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20150514063305.299">@cmd('exchange-point-mark')
def exchangePointMark(self, event):
    """
    Exchange the point (insert point) with the mark (the other end of the
    selected text).
    """
    c = self.c
    w = self.editWidget(event)
    if not w:
        return
    if hasattr(w, 'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind='exchange', extend=False)
    else:
        c.widgetWantsFocusNow(w)
        i, j = w.getSelectionRange(sort=False)
        if i == j: return
        ins = w.getInsertPoint()
        ins = j if ins == i else i
        w.setInsertPoint(ins)
        w.setSelectionRange(i, j, insert=None)
</t>
<t tx="ekr.20150514063305.300">@cmd('extend-to-line')
def extendToLine(self, event):
    """Select the line at the cursor."""
    w = self.editWidget(event)
    if not w:
        return
    s = w.getAllText()
    n = len(s)
    i = w.getInsertPoint()
    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i -= 1
    i += 1
    i1 = i
    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i += 1
    w.setSelectionRange(i1, i)
</t>
<t tx="ekr.20150514063305.301">@cmd('extend-to-sentence')
def extendToSentence(self, event):
    """Select the line at the cursor."""
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    s = w.getAllText()
    n = len(s)
    i = w.getInsertPoint()
    i2 = 1 + s.find('.', i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.', 0, i2 - 1)
    w.setSelectionRange(i1, i2)
</t>
<t tx="ekr.20150514063305.302">@cmd('extend-to-word')
def extendToWord(self, event, select=True, w=None):
    """Compute the word at the cursor. Select it if select arg is True."""
    if not w:
        w = self.editWidget(event)
    if not w:
        return 0, 0  # pragma: no cover (defensive)
    s = w.getAllText()
    n = len(s)
    i = i1 = w.getInsertPoint()
    # Find a word char on the present line if one isn't at the cursor.
    if not (0 &lt;= i &lt; n and g.isWordChar(s[i])):
        # First, look forward
        while i &lt; n and not g.isWordChar(s[i]) and s[i] != '\n':
            i += 1
        # Next, look backward.
        if not (0 &lt;= i &lt; n and g.isWordChar(s[i])):
            i = i1 - 1 if (i &gt;= n or s[i] == '\n') else i1
            while i &gt;= 0 and not g.isWordChar(s[i]) and s[i] != '\n':
                i -= 1
    # Make sure s[i] is a word char.
    if 0 &lt;= i &lt; n and g.isWordChar(s[i]):
        # Find the start of the word.
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i -= 1
        i += 1
        i1 = i
        # Find the end of the word.
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i += 1
        if select:
            w.setSelectionRange(i1, i)
        return i1, i
    return 0, 0
</t>
<t tx="ekr.20150514063305.303">@cmd('move-past-close')
def movePastClose(self, event):
    """Move the cursor past the closing parenthesis."""
    self.movePastCloseHelper(event, extend=False)

@cmd('move-past-close-extend-selection')
def movePastCloseExtendSelection(self, event):
    """Extend the selection by moving the cursor past the closing parenthesis."""
    self.movePastCloseHelper(event, extend=True)
</t>
<t tx="ekr.20150514063305.304">def movePastCloseHelper(self, event, extend):
    c = self.c
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i &gt;= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j &gt;= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i &lt; j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 &lt; len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 &lt; len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 &gt; j2: return
    self.moveToHelper(event, i2 + 1, extend)
</t>
<t tx="ekr.20150514063305.305">def moveWithinLineHelper(self, event, spot, extend):
    w = self.editWidget(event)
    if not w:
        return
    # Bug fix: 2012/02/28: don't use the Qt end-line logic:
    # it apparently does not work for wrapped lines.
    spots = ('end-line', 'finish-line', 'start-line')
    if hasattr(w, 'leoMoveCursorHelper') and spot not in spots:
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot, extend=extend)
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i, j = g.getLine(s, ins)
        line = s[i:j]
        if spot == 'begin-line':  # was 'start-line'
            self.moveToHelper(event, i, extend=extend)
        elif spot == 'end-line':
            # Bug fix: 2011/11/13: Significant in external tests.
            if g.match(s, j - 1, '\n') and i != j: j -= 1
            self.moveToHelper(event, j, extend=extend)
        elif spot == 'finish-line':
            if not line.isspace():
                if g.match(s, j - 1, '\n'): j -= 1
                while j &gt;= 0 and s[j].isspace():
                    j -= 1
            self.moveToHelper(event, j, extend=extend)
        elif spot == 'start-line':  # new
            if not line.isspace():
                while i &lt; j and s[i].isspace():
                    i += 1
            self.moveToHelper(event, i, extend=extend)
        else:
            g.trace(f"can not happen: bad spot: {spot}")
</t>
<t tx="ekr.20150514063305.306">@cmd('back-page')
def backPage(self, event):
    """Move the cursor back one page,
    extending the selection if in extend mode."""
    self.movePageHelper(event, kind='back', extend=False)

@cmd('back-page-extend-selection')
def backPageExtendSelection(self, event):
    """Extend the selection by moving the cursor back one page."""
    self.movePageHelper(event, kind='back', extend=True)

@cmd('forward-page')
def forwardPage(self, event):
    """Move the cursor forward one page,
    extending the selection if in extend mode."""
    self.movePageHelper(event, kind='forward', extend=False)

@cmd('forward-page-extend-selection')
def forwardPageExtendSelection(self, event):
    """Extend the selection by moving the cursor forward one page."""
    self.movePageHelper(event, kind='forward', extend=True)
</t>
<t tx="ekr.20150514063305.307">def movePageHelper(self, event, kind, extend):  # kind in back/forward.
    """Move the cursor up/down one page, possibly extending the selection."""
    w = self.editWidget(event)
    if not w:
        return
    linesPerPage = 15  # To do.
    if hasattr(w, 'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(
            kind='page-down' if kind == 'forward' else 'page-up',
            extend=extend, linesPerPage=linesPerPage)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        ins = w.getInsertPoint()
        s = w.getAllText()
        lines = g.splitLines(s)
        row, col = g.convertPythonIndexToRowCol(s, ins)
        if kind == 'back':
            row2 = max(0, row - linesPerPage)
        else:
            row2 = min(row + linesPerPage, len(lines) - 1)
        if row == row2: return
        spot = g.convertRowColToPythonIndex(s, row2, col, lines=lines)
        self.extendHelper(w, extend, spot, upOrDown=True)
</t>
<t tx="ekr.20150514063305.308">@cmd('back-paragraph')
def backwardParagraph(self, event):
    """Move the cursor to the previous paragraph."""
    self.backwardParagraphHelper(event, extend=False)

@cmd('back-paragraph-extend-selection')
def backwardParagraphExtendSelection(self, event):
    """Extend the selection by moving the cursor to the previous paragraph."""
    self.backwardParagraphHelper(event, extend=True)

@cmd('forward-paragraph')
def forwardParagraph(self, event):
    """Move the cursor to the next paragraph."""
    self.forwardParagraphHelper(event, extend=False)

@cmd('forward-paragraph-extend-selection')
def forwardParagraphExtendSelection(self, event):
    """Extend the selection by moving the cursor to the next paragraph."""
    self.forwardParagraphHelper(event, extend=True)
</t>
<t tx="ekr.20150514063305.309">def backwardParagraphHelper(self, event, extend):
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    s = w.getAllText()
    i, j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i, j = g.getLine(s, j)
    line = s[i:j]
    if line.strip():
        # Find the start of the present paragraph.
        while i &gt; 0:
            i, j = g.getLine(s, i - 1)
            line = s[i:j]
            if not line.strip(): break
    # Find the end of the previous paragraph.
    while i &gt; 0:
        i, j = g.getLine(s, i - 1)
        line = s[i:j]
        if line.strip():
            i = j - 1
            break
    self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.310">def forwardParagraphHelper(self, event, extend):
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i, j = g.getLine(s, ins)
    line = s[i:j]
    if line.strip():  # Skip past the present paragraph.
        self.selectParagraphHelper(w, i)
        i, j = w.getSelectionRange()
        j += 1
    # Skip to the next non-blank line.
    i = j
    while j &lt; len(s):
        i, j = g.getLine(s, j)
        line = s[i:j]
        if line.strip(): break
    w.setInsertPoint(ins)  # Restore the original insert point.
    self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.311">@cmd('select-all')
def selectAllText(self, event):
    """Select all text."""
    k = self.c.k
    w = self.editWidget(event)
    if not w: return
    # Bug fix 2013/12/13: Special case the minibuffer.
    if w == k.w:
        k.selectAll()
    elif w and g.isTextWrapper(w):
        w.selectAllText()
</t>
<t tx="ekr.20150514063305.312">@cmd('back-sentence')
def backSentence(self, event):
    """Move the cursor to the previous sentence."""
    self.backSentenceHelper(event, extend=False)

@cmd('back-sentence-extend-selection')
def backSentenceExtendSelection(self, event):
    """Extend the selection by moving the cursor to the previous sentence."""
    self.backSentenceHelper(event, extend=True)

@cmd('forward-sentence')
def forwardSentence(self, event):
    """Move the cursor to the next sentence."""
    self.forwardSentenceHelper(event, extend=False)

@cmd('forward-sentence-extend-selection')
def forwardSentenceExtendSelection(self, event):
    """Extend the selection by moving the cursor to the next sentence."""
    self.forwardSentenceHelper(event, extend=True)
</t>
<t tx="ekr.20150514063305.313">def backSentenceHelper(self, event, extend):
    c = self.c
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Find the starting point of the scan.
    i = ins
    i -= 1  # Ensure some progress.
    if i &lt; 0:
        return
    # Tricky.
    if s[i] == '.':
        i -= 1
    while i &gt;= 0 and s[i] in ' \n':
        i -= 1
    if i &gt;= ins:
        i -= 1
    if i &gt;= len(s):
        i -= 1
    if i &lt;= 0:
        return
    if s[i] == '.':
        i -= 1
    # Scan backwards to the end of the paragraph.
    # Stop at empty lines.
    # Skip periods within words.
    # Stop at sentences ending in non-periods.
    end = False
    while not end and i &gt;= 0:
        progress = i
        if s[i] == '.':
            # Skip periods surrounded by letters/numbers
            if i &gt; 0 and s[i - 1].isalnum() and s[i + 1].isalnum():
                i -= 1
            else:
                i += 1
                while i &lt; len(s) and s[i] in ' \n':
                    i += 1
                i -= 1
                break
        elif s[i] == '\n':
            j = i - 1
            while j &gt;= 0:
                if s[j] == '\n':
                    # Don't include first newline.
                    end = True
                    break  # found blank line.
                elif s[j] == ' ':
                    j -= 1
                else:
                    i -= 1
                    break  # no blank line found.
            else:
                # No blank line found.
                i -= 1
        else:
            i -= 1
        assert end or progress &gt; i
    i += 1
    if i &lt; ins:
        self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.314">def forwardSentenceHelper(self, event, extend):
    c = self.c
    w = self.editWidget(event)
    if not w:
        return
    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    if ins &gt;= len(s):
        return
    # Find the starting point of the scan.
    i = ins
    if i + 1 &lt; len(s) and s[i + 1] == '.':
        i += 1
    if s[i] == '.':
        i += 1
    else:
        while i &lt; len(s) and s[i] in ' \n':
            i += 1
        i -= 1
    if i &lt;= ins:
        i += 1
    if i &gt;= len(s):
        return
    # Scan forward to the end of the paragraph.
    # Stop at empty lines.
    # Skip periods within words.
    # Stop at sentences ending in non-periods.
    end = False
    while not end and i &lt; len(s):
        progress = i
        if s[i] == '.':
            # Skip periods surrounded by letters/numbers
            if 0 &lt; i &lt; len(s) and s[i - 1].isalnum() and s[i + 1].isalnum():
                i += 1
            else:
                i += 1
                break  # Include the paragraph.
        elif s[i] == '\n':
            j = i + 1
            while j &lt; len(s):
                if s[j] == '\n':
                    # Don't include first newline.
                    end = True
                    break  # found blank line.
                elif s[j] == ' ':
                    j += 1
                else:
                    i += 1
                    break  # no blank line found.
            else:
                # No blank line found.
                i += 1
        else:
            i += 1
        assert end or progress &lt; i
    i = min(i, len(s))
    if i &gt; ins:
        self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.316">@cmd('back-word')
def backwardWord(self, event):
    """Move the cursor to the previous word."""
    self.moveWordHelper(event, extend=False, forward=False)

@cmd('back-word-extend-selection')
def backwardWordExtendSelection(self, event):
    """Extend the selection by moving the cursor to the previous word."""
    self.moveWordHelper(event, extend=True, forward=False)

@cmd('back-word-smart')
def backwardWordSmart(self, event):
    """Move the cursor to the beginning of the current or the end of the previous word."""
    self.moveWordHelper(event, extend=False, forward=False, smart=True)

@cmd('back-word-smart-extend-selection')
def backwardWordSmartExtendSelection(self, event):
    """Extend the selection by moving the cursor to the beginning of the current
    or the end of the previous word."""
    self.moveWordHelper(event, extend=True, forward=False, smart=True)
</t>
<t tx="ekr.20150514063305.317">def moveWordHelper(self, event, extend, forward, end=False, smart=False):
    """
    Move the cursor to the next/previous word.
    The cursor is placed at the start of the word unless end=True
    """
    c = self.c
    w = self.editWidget(event)
    if not w:
        return  # pragma: no cover (defensive)
    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    n = len(s)
    i = w.getInsertPoint()
    alphanumeric_re = re.compile(r"\w")
    whitespace_re = re.compile(r"\s")
    simple_whitespace_re = re.compile(r"[ \t]")
    @others
    if smart:
        if forward:
            if 0 &lt;= i &lt; n:
                if is_alphanumeric(s[i]):
                    i = seek_word_end(i)
                    i = seek_simple_whitespace_end(i)
                elif is_simple_whitespace(s[i]):
                    i = seek_simple_whitespace_end(i)
                elif is_special(s[i]):
                    i = seek_special_end(i)
                    i = seek_simple_whitespace_end(i)
                else:
                    i += 1  # e.g. for newlines
        else:
            i -= 1  # Shift cursor temporarily by -1 to get easy read access to the prev. char
            if 0 &lt;= i &lt; n:
                if is_alphanumeric(s[i]):
                    i = seek_word_start(i)
                    # Do not seek further whitespace here
                elif is_simple_whitespace(s[i]):
                    i = seek_simple_whitespace_start(i)
                elif is_special(s[i]):
                    i = seek_special_start(i)
                    # Do not seek further whitespace here
                else:
                    i -= 1  # e.g. for newlines
            i += 1
    else:
        if forward:
            # Unlike backward-word moves, there are two options...
            if end:
                while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                    i += 1
                while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                    i += 1
            else:
                #1653. Scan for non-words *first*.
                while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                    i += 1
                while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                    i += 1
        else:
            i -= 1
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i -= 1
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i -= 1
            i += 1  # 2015/04/30
    self.moveToHelper(event, i, extend)
</t>
<t tx="ekr.20150514063305.318">def is_alphanumeric(c):
    return alphanumeric_re.match(c) is not None

def is_whitespace(c):
    return whitespace_re.match(c) is not None

def is_simple_whitespace(c):
    return simple_whitespace_re.match(c) is not None

def is_line_break(c):
    return is_whitespace(c) and not is_simple_whitespace(c)

def is_special(c):
    return not is_alphanumeric(c) and not is_whitespace(c)

def seek_until_changed(i, match_function, step):
    while 0 &lt;= i &lt; n and match_function(s[i]):
        i += step
    return i

def seek_word_end(i):
    return seek_until_changed(i, is_alphanumeric, 1)

def seek_word_start(i):
    return seek_until_changed(i, is_alphanumeric, -1)

def seek_simple_whitespace_end(i):
    return seek_until_changed(i, is_simple_whitespace, 1)

def seek_simple_whitespace_start(i):
    return seek_until_changed(i, is_simple_whitespace, -1)

def seek_special_end(i):
    return seek_until_changed(i, is_special, 1)

def seek_special_start(i):
    return seek_until_changed(i, is_special, -1)
</t>
<t tx="ekr.20150514063305.504">def change(self, event=None):
    """Make the selected change to the text"""
    if not self.loaded:
        return False
    c = self.c
    w = c.frame.body.wrapper
    selection = self.tab.getSuggestion()
    if selection:
        # Use getattr to keep pylint happy.
        i = getattr(self.tab, 'change_i', None)
        j = getattr(self.tab, 'change_j', None)
        if i is not None:
            start, end = i, j
            oldSel = start, end
        else:
            start, end = oldSel = w.getSelectionRange()
        if start is not None:
            if start &gt; end: start, end = end, start
            w.delete(start, end)
            w.insert(start, selection)
            w.setSelectionRange(start, start + len(selection))
            c.frame.body.onBodyChanged("Change", oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocus()
            return True
    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocus()
    return False
</t>
<t tx="ekr.20150604130353.1">gnx: ekr.20150604130223.363
</t>
<t tx="ekr.20150604130353.2"></t>
<t tx="ekr.20150621062355.1">def runAlreadyOpenDialog(self, c):
    """Warn about possibly already-open files."""
    if g.app.already_open_files:
        aList = sorted(set(g.app.already_open_files))
        g.app.already_open_files = []
        g.app.gui.dismiss_splash_screen()
        message = (
            'The following files may already be open\n'
            'in another copy of Leo:\n\n' +
            '\n'.join(aList))
        g.app.gui.runAskOkDialog(c,
            title='Already Open Files',
            message=message,
            text="Ok")
</t>
<t tx="ekr.20150703061709.1">@language python

"""myLeoSettings.py: save the outline and run the pylint command"""

# print('@button run-pylint: %s' % c.shortFileName())
if c.isChanged():
    c.save()
c.k.simulateCommand('pylint')
</t>
<t tx="ekr.20160122104332.1">@language python
</t>
<t tx="ekr.20160123142722.1"># An example configuration file for make_stub_files.py.
# By default, this is ~/stubs/make_stub_files.cfg.
# Can be changed using the --config=path command-line option.

[Global]

files:

    # Files to be used *only* if no files are given on the command line.
    # glob.glob wildcards are supported.

    # c:/leo.repo/leo-editor/leo/core/leoAst.py
    # c:/leo.repo/leo-editor/leo/core/*.py
    # c:/leo.repo/leo-editor/plugins/*.py

output_directory: ~/stubs

prefix_lines:
    # Lines to be inserted at the start of each stub file.
    from typing import TypeVar, Iterable, Tuple
    T = TypeVar('T', int, float, complex)

[Def Name Patterns]

[General Patterns]
</t>
<t tx="ekr.20160129073222.1">def __get_u(self):
    p = self
    return p.v.u

def __set_u(self, val):
    p = self
    p.v.u = val

u = property(
    __get_u, __set_u,
    doc="p.u property")
</t>
<t tx="ekr.20160409035115.1">def searchTree(self, char):
    """Search all visible nodes for a headline starting with stroke."""
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        """Return True if p contains char."""
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) &gt; -1

    # Start at c.p, then retry everywhere.

    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) &gt; -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
</t>
<t tx="ekr.20160420054135.4">gnx: ekr.20160412193816.5
unl: qt_quicksearch declarations
gnx: ekr.20160412193816.6
unl: class Ui_LeoQuickSearchWidget
gnx: ekr.20160412193816.7
unl: class Ui_LeoQuickSearchWidget--&gt;setupUi
gnx: ekr.20160412193816.8
unl: class Ui_LeoQuickSearchWidget--&gt;retranslateUi
</t>
<t tx="ekr.20160420054135.5"></t>
<t tx="ekr.20160425070345.1">gnx: ekr.20160412193816.1
unl: qt_main declarations
gnx: ekr.20160412193816.2
unl: class Ui_MainWindow
gnx: ekr.20160412193816.3
unl: class Ui_MainWindow--&gt;setupUi
gnx: ekr.20160412193816.4
unl: class Ui_MainWindow--&gt;retranslateUi
</t>
<t tx="ekr.20160425070345.2"></t>
<t tx="ekr.20160920221324.1">def convert_to_html(self, s):
    '''Convert s to html using docutils.'''
    c, p = self.c, self.c.p
    # Update the current path.
    path = g.scanAllAtPathDirectives(c, p) or c.getNodePath(p)
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    if os.path.isdir(path):
        os.chdir(path)
    try:
        if self.title:
            s = self.underline(self.title) + s
            self.title = None
        # Call docutils to get the string.
        s = publish_string(s, writer_name='html')
        s = g.toUnicode(s)
    except SystemMessage as sm:
        msg = sm.args[0]
        if 'SEVERE' in msg or 'FATAL' in msg:
            s = 'RST error:\n%s\n\n%s' % (msg, s)
    return s

def update_plantuml(self, s, keywords):
    pc = self
    w = pc.ensure_text_widget()
    path = self.c.p.h[9:].strip()
    print("Plantuml output file name: ", path)
    with open("temp.plantuml", "w") as f:
        f.write(s)
    pth_plantuml_jar = "~/.leo"
    os.system("cat temp.plantuml | java -jar %s/plantuml.jar -pipe &gt; %s" % (pth_plantuml_jar, path))
    template = image_template % (path)
    # Only works in Python 3.x.
    template = g.adjustTripleString(template, pc.c.tab_width).strip()
    pc.show()
    w.setReadOnly(False)
    w.setHtml(template)
    w.setReadOnly(True)

</t>
<t tx="ekr.20160924135613.1">def doPlainChar(self, action, ch, event, inBrackets, oldSel, stroke, w):
    c, p = self.c, self.c.p
    isPlain = stroke.find('Alt') == -1 and stroke.find('Ctrl') == -1
    i, j = oldSel
    if i &gt; j: i, j = j, i
    # Use raw insert/delete to retain the coloring.
    if i != j: w.delete(i, j)
    elif action == 'overwrite': w.delete(i)
    if isPlain:
        ins = w.getInsertPoint()
        if self.autojustify &gt; 0 and not inBrackets:
            # Support #14: auto-justify body text.
            s = w.getAllText()
            i = g.skip_to_start_of_line(s, ins)
            i, j = g.getLine(s, i)
            # Only insert a newline at the end of a line.
            if j - i &gt;= self.autojustify and (ins &gt;= len(s) or s[ins] == '\n'):
                # Find the start of the word.
                n = 0
                ins -= 1
                while ins - 1 &gt; 0 and g.isWordChar(s[ins - 1]):
                    n += 1
                    ins -= 1
                sins = ins  # start of insert, to collect trailing whitespace
                while sins &gt; 0 and s[sins - 1] in (' \t'):
                    sins -= 1
                oldSel = (sins, ins)
                self.insertNewlineHelper(w, oldSel, undoType=None)
                ins = w.getInsertPoint()
                ins += (n + 1)
        w.insert(ins, ch)
        w.setInsertPoint(ins + 1)
    else:
        g.app.gui.insertKeyEvent(event, i)
    if inBrackets and self.flashMatchingBrackets:
        self.flashMatchingBracketsHelper(c, ch, i, p, w)
</t>
<t tx="ekr.20161020031633.1">"""
k.get1Arg: Handle the next character the user types when accumulating
a user argument from the minibuffer. Ctrl-G will abort this processing
at any time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.

Example 1: get one argument from the user:

    @g.command('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)

    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

Example 2: get two arguments from the user:

    @g.command('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)

    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.extendLabel(' second prompt: ', select=False, protect=True)
        k.getNextArg(handler=self.myCommand2)

    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

k.get1Arg and k.getNextArg are a convenience methods. They simply pass
their arguments to the get_arg method of the singleton GetArg
instance. This docstring describes k.get1arg and k.getNextArg as if
they were the corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n,
handler) though they aren't represented that way. When the state
machine in the GetArg class is active, the kind is 'getArg'. This
constant has special meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    &lt;Return&gt; or (sometimes) &lt;tab&gt;.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.

"""
</t>
<t tx="ekr.20161021084954.1">def runPyflakes(self, root, pyflakes_errors_only):
    """Run pyflakes on the selected node."""
    try:
        from leo.commands import checkerCommands
        if checkerCommands.pyflakes:
            x = checkerCommands.PyflakesCommand(self.c)
            ok = x.run(p=root, pyflakes_errors_only=pyflakes_errors_only)
            return ok
        return True  # Suppress error if pyflakes can not be imported.
    except Exception:
        g.es_exception()
</t>
<t tx="ekr.20161028040054.1">self.already_open_files = []
    # A list of file names that *might* be open in another
    # copy of Leo.
self.dragging = False
    # True: dragging.
self.inBridge = False
    # True: running from leoBridge module.
self.inScript = False
    # True: executing a script.
self.initing = True
    # True: we are initiing the app.
self.initComplete = False
    # True: late bindings are not allowed.
self.killed = False
    # True: we are about to destroy the root window.
self.openingSettingsFile = False
    # True, opening a settings file.
self.preReadFlag = False
    # True: we are pre-reading a settings file.
self.quitting = False
    # True: quitting.  Locks out some events.
self.restarting = False
    # True: restarting all of Leo. #1240.
self.reverting = False
    # True: executing the revert command.
self.syntax_error_files = []
</t>
<t tx="ekr.20161029103615.1">class Py_Importer(Importer):
    '''A class to store and update scanning state.'''

    def __init__(self, importCommands, language='python', **kwargs):
        '''Py_Importer.ctor.'''
        super().__init__(
            importCommands,
            language=language,
            state_class = Python_ScanState,
            strict=True,
        )
        self.put_decorators = self.c.config.getBool('put-python-decorators-in-imported-headlines')

    @others
</t>
<t tx="ekr.20161108131153.10">def run(self, s, parent, parse_body=False):
    '''The common top-level code for all scanners.'''
    c = self.c
    # Fix #449: Cloned @auto nodes duplicates section references.
    if parent.isCloned() and parent.hasChildren():
        return None
    self.root = root = parent.copy()
    self.file_s = s
    # Init the error/status info.
    self.errors = 0
    self.parse_body = parse_body
    # Check for intermixed blanks and tabs.
    self.tab_width = c.getTabWidth(p=root)
    ws_ok = self.check_blanks_and_tabs(s) # Only issues warnings.
    # Regularize leading whitespace
    if not ws_ok:
        s = self.regularize_whitespace(s)
    # Generate the nodes, including directives and section references.
    # Completely generate all nodes.
    self.generate_nodes(s, parent)
    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    if parse_body:
        ok = self.errors == 0 # Work around problems with directives.
    else:
        ok = self.errors == 0 and self.check(s, parent)
    g.app.unitTestDict['result'] = ok
    # Insert an @ignore directive if there were any serious problems.
    if not ok:
        self.insert_ignore_directive(parent)
    # It's always useless for an an import to dirty the outline.
    for p in root.self_and_subtree():
        p.clearDirty()
    # #1451: The caller should be responsible for this.
        # if changed:
            # c.setChanged()
        # else:
            # c.clearChanged()
    return ok
</t>
<t tx="ekr.20161108131153.11">def check_blanks_and_tabs(self, lines):
    '''Check for intermixed blank &amp; tabs.'''
    # Do a quick check for mixed leading tabs/blanks.
    fn = g.shortFileName(self.root.h)
    w = self.tab_width
    blanks = tabs = 0
    for s in g.splitLines(lines):
        lws = self.get_str_lws(s)
        blanks += lws.count(' ')
        tabs += lws.count('\t')
    # Make sure whitespace matches @tabwidth directive.
    if w &lt; 0:
        ok = tabs == 0
        message = 'tabs found with @tabwidth %s in %s' % (w, fn)
    elif w &gt; 0:
        ok = blanks == 0
        message = 'blanks found with @tabwidth %s in %s' % (w, fn)
    if ok:
        ok = (blanks == 0 or tabs == 0)
        message = 'intermixed blanks and tabs in: %s' % (fn)
    if not ok:
        if g.unitTesting:
            self.report(message)
        else:
            g.es(message)
    return ok
</t>
<t tx="ekr.20161108131153.12">def insert_ignore_directive(self, parent):
    c = self.c
    parent.v.b = parent.v.b.rstrip() + '\n@ignore\n'
        # Do *not* update the screen by setting p.b.
    if g.unitTesting:
        g.app.unitTestDict['fail'] = g.callers()
    elif parent.isAnyAtFileNode() and not parent.isAtAutoNode():
        g.warning('inserting @ignore')
        c.import_error_nodes.append(parent.h)
</t>
<t tx="ekr.20161108131153.13">def post_pass(self, parent):
    '''
    Optional Stage 2 of the importer pipeline, consisting of zero or more
    substages. Each substage alters nodes in various ways.

    Subclasses may freely override this method, **provided** that all
    substages use the API for setting body text. Changing p.b directly will
    cause asserts to fail later in i.finish().
    '''
    self.clean_all_headlines(parent)
    if self.add_context:
        self.add_class_names(parent)
    self.clean_all_nodes(parent)
    self.unindent_all_nodes(parent)
    #
    # This sub-pass must follow unindent_all_nodes.
    self.promote_trailing_underindented_lines(parent)
    self.promote_last_lines(parent)
    #
    # This probably should be the last sub-pass.
    self.delete_all_empty_nodes(parent)
</t>
<t tx="ekr.20161108131153.14">def regularize_whitespace(self, s):
    '''
    Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    '''
    kind = 'tabs' if self.tab_width &gt; 0 else 'blanks'
    kind2 = 'blanks' if self.tab_width &gt; 0 else 'tabs'
    fn = g.shortFileName(self.root.h)
    lines = g.splitLines(s)
    count, result, tab_width = 0, [], self.tab_width
    self.ws_error = False # 2016/11/23
    if tab_width &lt; 0: # Convert tabs to blanks.
        for n, line in enumerate(lines):
            i, w = g.skip_leading_ws_with_indent(line, 0, tab_width)
            s = g.computeLeadingWhitespace(w, -abs(tab_width)) + line[i:]
                # Use negative width.
            if s != line:
                count += 1
            result.append(s)
    elif tab_width &gt; 0: # Convert blanks to tabs.
        for n, line in enumerate(lines):
            s = g.optimizeLeadingWhitespace(line, abs(tab_width))
                # Use positive width.
            if s != line:
                count += 1
            result.append(s)
    if count:
        self.ws_error = True # A flag to check.
        if not g.unitTesting:
            # g.es_print('Warning: Intermixed tabs and blanks in', fn)
            # g.es_print('Perfect import test will ignoring leading whitespace.')
            g.es('changed leading %s to %s in %s line%s in %s' % (
                kind2, kind, count, g.plural(count), fn))
        if g.unitTesting: # Sets flag for unit tests.
            self.report('changed %s lines' % count)
    return ''.join(result)
</t>
<t tx="ekr.20161108131153.15"></t>
<t tx="ekr.20161108131153.17">def get_str_lws(self, s):
    '''Return the characters of the lws of s.'''
    m = re.match(r'([ \t]*)', s)
    return m.group(0) if m else ''
</t>
<t tx="ekr.20161108131153.18">def error(self, s):
    '''Issue an error and cause a unit test to fail.'''
    self.errors += 1
    self.importCommands.errors += 1

def report(self, message):
    if self.strict:
        self.error(message)
    else:
        self.warning(message)

def warning(self, s):
    if not g.unitTesting:
        g.warning('Warning:', s)
</t>
<t tx="ekr.20161108131153.19">def undent(self, p):
    '''Remove maximal leading whitespace from the start of all lines.'''
    if self.is_rst:
        return p.b # Never unindent rst code.
    lines = self.get_lines(p)
    ws = self.common_lws(lines)
    result = []
    for s in lines:
        if s.startswith(ws):
            result.append(s[len(ws):])
        elif s.isspace():
            # Never change blank lines.
            result.append(s)
        else:
            # Indicate that the line is underindented.
            result.append("%s%s.%s" % (
                self.c.atFileCommands.underindentEscapeString,
                g.computeWidth(ws, self.tab_width),
                s.lstrip()))
    return result
</t>
<t tx="ekr.20161108131153.20">def common_lws(self, lines):
    '''Return the lws (a string) common to all lines.'''
    if not lines:
        return ''
    lws = self.get_str_lws(lines[0])
    for s in lines:
        if not self.is_ws_line(s):
            lws2 = self.get_str_lws(s)
            if lws2.startswith(lws):
                pass
            elif lws.startswith(lws2):
                lws = lws2
            else:
                lws = '' # Nothing in common.
                break
    return lws
</t>
<t tx="ekr.20161108131153.21">def underindented_comment(self, line):
    if self.at_auto_warns_about_leading_whitespace:
        self.warning(
            'underindented python comments.\n' +
            'Extra leading whitespace will be added\n' + line)

def underindented_line(self, line):
    if self.warn_about_underindented_lines:
        self.error(
            'underindented line.\n'
            'Extra leading whitespace will be added\n' + line)
</t>
<t tx="ekr.20161108131153.3">def check(self, unused_s, parent):
    '''True if perfect import checks pass.'''
    if g.app.suppressImportChecks:
        g.app.suppressImportChecks = False
        return True
    c = self.c
    sfn = g.shortFileName(self.root.h)
    s1 = g.toUnicode(self.file_s, self.encoding)
    s2 = self.trial_write()
    lines1, lines2 = g.splitLines(s1), g.splitLines(s2)
    if 0: # An excellent trace for debugging.
        g.trace(c.shortFileName())
        g.printObj(lines1, tag='lines1')
        g.printObj(lines2, tag='lines2')
    if self.strict:
        # Ignore blank lines only.
        # Adding nodes may add blank lines.
        lines1 = self.strip_blank_lines(lines1)
        lines2 = self.strip_blank_lines(lines2)
    else:
        # Ignore blank lines and leading whitespace.
        # Importing may regularize whitespace, and that's good.
        lines1 = self.strip_all(lines1)
        lines2 = self.strip_all(lines2)
    # Forgive trailing whitespace problems in the last line.
    # This is not the same as clean_last_lines.
    if lines1 and lines2 and lines1 != lines2:
        lines1[-1] = lines1[-1].rstrip()+'\n'
        lines2[-1] = lines2[-1].rstrip()+'\n'
    # self.trace_lines(lines1, lines2, parent)
    ok = lines1 == lines2
    if not ok and not self.strict:
        # Issue an error only if something *other than* lws is amiss.
        lines1, lines2 = self.strip_lws(lines1), self.strip_lws(lines2)
        ok = lines1 == lines2
        if ok and not g.unitTesting:
            print('warning: leading whitespace changed in:', self.root.h)
    if not ok:
        self.show_failure(lines1, lines2, sfn)
        # self.trace_lines(lines1, lines2, parent)
    # Ensure that the unit tests fail when they should.
    # Unit tests do not generate errors unless the mismatch line does not match.
    if g.app.unitTesting:
        d = g.app.unitTestDict
        d['result'] = ok
        if not ok:
            d['fail'] = g.callers()
            # Used in a unit test.
            c.importCommands.errors += 1
    return ok
</t>
<t tx="ekr.20161108131153.4">def clean_blank_lines(self, lines):
    '''Remove all blanks and tabs in all blank lines.'''
    return [self.lstrip_line(z) if z.isspace() else z for z in lines]
</t>
<t tx="ekr.20161108131153.5">def lstrip_line(self, s):
    '''Delete leading whitespace, *without* deleting the trailing newline!'''
    # This fixes a major bug in strip_lws.
    assert s, g.callers()
    return '\n' if s.isspace() else s.lstrip()

def strip_all(self, lines):
    '''Strip blank lines and leading whitespace from all lines of s.'''
    return self.strip_lws(self.strip_blank_lines(lines))

def strip_blank_lines(self, lines):
    '''Strip all blank lines from s.'''
    return [z for z in lines if not z.isspace()]

def strip_lws(self, lines):
    '''Strip leading whitespace from all lines.'''
    return [self.lstrip_line(z) for z in lines]
    # This also works, but I prefer the "extra" call to lstrip().
    # return ['\n' if z.isspace() else z.lstrip() for z in lines].


</t>
<t tx="ekr.20161108131153.6">def trial_write(self):
    '''Return the trial write for self.root.'''
    at = self.c.atFileCommands
    # Leo 5.6: Allow apparent section refs for *all* languages.
    ivar = 'allow_undefined_refs'
    try:
        setattr(at, ivar, True)
        result = at.atAutoToString(self.root)
    finally:
        if hasattr(at, ivar):
            delattr(at, ivar)
    return g.toUnicode(result, self.encoding)
</t>
<t tx="ekr.20161108131153.7"># These can be overridden in subclasses.
</t>
<t tx="ekr.20161108131153.8">def adjust_parent(self, parent, headline):
    '''Return the effective parent.

    This is overridden by the RstScanner class.'''
    return parent
</t>
<t tx="ekr.20161108131153.9">def clean_headline(self, s, p=None):
    '''
    Return the cleaned version headline s.
    Will typically be overridden in subclasses.
    '''
    return s.strip()
</t>
<t tx="ekr.20161108155143.3">def get_int_lws(self, s):
    '''Return the the lws (a number) of line s.'''
    # Important: use self.tab_width, *not* c.tab_width.
    return g.computeLeadingWhitespaceWidth(s, self.tab_width)
</t>
<t tx="ekr.20161108155143.4">def match(self, s, i, pattern):
    '''Return True if the pattern matches at s[i:]'''
    return s[i:i+len(pattern)] == pattern
</t>
<t tx="ekr.20161108155730.1">class Importer:
    '''
    The new, unified, simplified, interface to Leo's importer code.

    Eventually, all importers will create use this class.
    '''

    @others
</t>
<t tx="ekr.20161108155925.1">def __init__(self,
    importCommands,
    gen_refs=False, # True: generate section references,
    language=None, # For @language directive.
    name=None, # The kind of importer, usually the same as language
    state_class=None, # For i.scan_line
    strict=False,
    **kwargs
):
    '''
    Importer.__init__: New in Leo 6.1.1: ic and c may be None for unit tests.
    '''
    # Copies of args...
    self.importCommands = ic = importCommands
    self.c = c = ic and ic.c
    self.encoding = ic and ic.encoding or 'utf-8'
    self.gen_refs = gen_refs
    self.language = language or name
        # For the @language directive.
    self.name = name or language
    language = self.language
    name = self.name
    assert language and name
    assert self.language and self.name
    self.state_class = state_class
    self.strict = strict
        # True: leading whitespace is significant.
    #
    # Set from ivars...
    self.has_decls = name not in ('xml', 'org-mode', 'vimoutliner')
    self.is_rst = name in ('rst',)
    self.tree_type = ic.treeType if c else None # '@root', '@file', etc.
    #
    # Constants...
    if ic:
        data = g.set_delims_from_language(self.name)
        self.single_comment, self.block1, self.block2 = data
    else:
        self.single_comment, self.block1, self.block2 = '//', '/*', '*/' # Javascript.
    if ic:
        self.escape = c.atFileCommands.underindentEscapeString
        self.escape_string = r'%s([0-9]+)\.' % re.escape(self.escape)
        # m.group(1) is the unindent value.
        self.escape_pattern = re.compile(self.escape_string)
    self.ScanState = ScanState
        # Must be set by subclasses that use general_scan_line.
    self.tab_width = 0 # Must be set in run, using self.root.
    self.ws_pattern = re.compile(r'^\s*$|^\s*%s' % (self.single_comment or ''))
    #
    # Settings...
    self.reloadSettings()
    #
    # State vars.
    self.errors = 0
    if ic:
        ic.errors = 0 # Required.
    self.parse_body = False
    self.refs_dict = {}
        # Keys are headlines. Values are disambiguating number.
    self.skip = 0 # A skip count for x.gen_lines &amp; its helpers.
    self.ws_error = False
    self.root = None

def reloadSettings(self):
    c = self.c
    if not c:
        return
    getBool = c.config.getBool
    c.registerReloadSettings(self)
    # self.at_auto_separate_non_def_nodes = False
    self.add_context = getBool("add-context-to-headlines")
    self.add_file_context = getBool("add-file-context-to-headlines")
    self.at_auto_warns_about_leading_whitespace = getBool('at_auto_warns_about_leading_whitespace')
    self.warn_about_underindented_lines = True
   
</t>
<t tx="ekr.20161108160409.1">def gen_lines(self, s, parent):
    '''
    Non-recursively parse all lines of s into parent, creating descendant
    nodes as needed.
    '''
    trace = 'importers' in g.app.debug
    tail_p = None
    prev_state = self.state_class()
    target = Target(parent, prev_state)
    stack = [target, target]
    self.inject_lines_ivar(parent)
    lines = g.splitLines(s)
    self.skip = 0
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        top = stack[-1]
        # g.trace(new_state.level(), f"{new_state.level() &lt; top.state.level():1}", repr(line))
        if trace:
            g.trace('%d %d %s' % (
                self.starts_block(i, lines, new_state, prev_state),
                self.ends_block(line, new_state, prev_state, stack),
                line.rstrip()))
        if self.skip &gt; 0:
            self.skip -= 1
        elif self.is_ws_line(line):
            p = tail_p or top.p
            self.add_line(p, line)
        elif self.starts_block(i, lines, new_state, prev_state):
            tail_p = None
            self.start_new_block(i, lines, new_state, prev_state, stack)
        elif self.ends_block(line, new_state, prev_state, stack):
            tail_p = self.end_block(line, new_state, stack)
        else:
            p = tail_p or top.p
            self.add_line(p, line)
        prev_state = new_state
</t>
<t tx="ekr.20161108160409.3">def end_block(self, line, new_state, stack):
    # The block is ending. Add tail lines until the start of the next block.
    p = stack[-1].p
    self.add_line(p, line)
    self.cut_stack(new_state, stack)
    tail_p = None if self.gen_refs else p
    return tail_p
</t>
<t tx="ekr.20161108160409.5">def add_root_directives(self, parent):
    '''Return the proper directives for the root node p.'''
    table = [
        '@language %s\n' % self.language,
        '@tabwidth %d\n' % self.tab_width,
    ]
    if self.parse_body:
        pass
    elif self.has_lines(parent):
        # Make sure the last line ends with a newline.
        lines = self.get_lines(parent)
        if lines:
            last_line = lines.pop()
            last_line = last_line.rstrip() + '\n'
            self.add_line(parent, last_line)
        self.extend_lines(parent, table)
    else:
        self.set_lines(parent, table)
</t>
<t tx="ekr.20161108160409.6">def start_new_block(self, i, lines, new_state, prev_state, stack):
    '''Create a child node and update the stack.'''
    if hasattr(new_state, 'in_context'):
        assert not new_state.in_context(), ('start_new_block', new_state)
    line = lines[i]
    target=stack[-1]
    # Insert the reference in *this* node.
    h = self.gen_ref(line, target.p, target)
    # Create a new child and associated target.
    child = self.create_child_node(target.p, line, h)
    stack.append(Target(child, new_state))
</t>
<t tx="ekr.20161108160409.7">def create_child_node(self, parent, body, headline):
    '''Create a child node of parent.'''
    child = parent.insertAsLastChild()
    self.inject_lines_ivar(child)
    if body:
        self.add_line(child, body)
    assert isinstance(headline, str), repr(headline)
    child.h = headline.strip()
    return child
</t>
<t tx="ekr.20161108160409.8">def gen_ref(self, line, parent, target):
    '''
    Generate the ref line. Return the headline.
    '''
    indent_ws = self.get_str_lws(line)
    h = self.clean_headline(line, p=None)
    if self.gen_refs:
        # Fix #441: Make sure all section refs are unique.
        d = self.refs_dict
        n = d.get(h, 0)
        d [h] = n + 1
        if n &gt; 0:
            h = '%s: %s' % (n, h)
        headline = g.angleBrackets(' %s ' % h)
        ref = '%s%s\n' % (
            indent_ws,
            g.angleBrackets(' %s ' % h))
    else:
        if target.ref_flag:
            ref = None
        else:
            ref = '%s@others\n' % indent_ws
            target.at_others_flag = True
        target.ref_flag = True
            # Don't generate another @others in this target.
        headline = h
    if ref:
        self.add_line(parent,ref)
    return headline
</t>
<t tx="ekr.20161108165530.1"></t>
<t tx="ekr.20161108170435.1">def scan_line(self, s, prev_state):
    '''
    A generalized scan-line method.

    SCAN STATE PROTOCOL:

    The Importer class should have a state_class ivar that references a
    **state class**. This class probably should *not* be subclass of the
    ScanState class, but it should observe the following protocol:

    1. The state class's ctor must have the following signature:

        def __init__(self, d)

    2. The state class must have an update method.
    '''
    # This dict allows new data to be added without changing ScanState signatures.
    d = {
        'indent': self.get_int_lws(s),
        'is_ws_line': self.is_ws_line(s),
        'prev':prev_state,
        's':s,
    }
    new_state = self.state_class(d)
    i = 0
    while i &lt; len(s):
        progress = i
        context = new_state.context
        table = self.get_table(context)
        data = self.scan_dict(context, i, s, table)
        i = new_state.update(data)
        assert progress &lt; i
    return new_state
</t>
<t tx="ekr.20161108180655.2">def undent_by(self, s, undent_val):
    '''
    Remove leading whitespace equivalent to undent_val from each line.

    Strict languages: prepend the underindent escape for underindented lines.
    '''
    if self.is_rst:
        return s # Never unindent rst code.
    result = []
    for line in g.splitlines(s):
        lws_s = self.get_str_lws(line)
        lws = g.computeWidth(lws_s, self.tab_width)
        # Add underindentEscapeString only for strict languages.
        if self.strict and not line.isspace() and lws &lt; undent_val:
            # End the underindent count with a period to
            # protect against lines that start with a digit!
            result.append("%s%s.%s" % (
                self.escape, undent_val-lws, line.lstrip()))
        else:
            s = g.removeLeadingWhitespace(line, undent_val, self.tab_width)
            result.append(s)
    return ''.join(result)
</t>
<t tx="ekr.20161109045312.1"></t>
<t tx="ekr.20161109045619.1">def print_lines(self, lines):
    '''Print lines for debugging.'''
    print('[')
    for line in lines:
        print(repr(line))
    print(']')

print_list = print_lines
</t>
<t tx="ekr.20161109052011.1">def is_ws_line(self, s):
    '''Return True if s is nothing but whitespace and single-line comments.'''
    return bool(self.ws_pattern.match(s))
</t>
<t tx="ekr.20161109053143.1">def get_leading_indent(self, lines, i, ignoreComments=True):
    '''
    Return the leading whitespace (an int) of the first significant line.
    Ignore blank and comment lines if ignoreComments is True
    '''
    if ignoreComments:
        while i &lt; len(lines):
            if self.is_ws_line(lines[i]):
                i += 1
            else:
                break
    return self.get_int_lws(lines[i]) if i &lt; len(lines) else 0
</t>
<t tx="ekr.20161109072221.1">def undent_body_lines(self, lines, ignoreComments=True):
    '''
    Remove the first line's leading indentation from all lines.
    Return the resulting string.
    '''
    s = ''.join(lines)
    if self.is_rst:
        return s # Never unindent rst code.
    # Calculate the amount to be removed from each line.
    undent_val = self.get_leading_indent(lines, 0, ignoreComments=ignoreComments)
    if undent_val == 0:
        return s
    result = self.undent_by(s, undent_val)
    return result
</t>
<t tx="ekr.20161110042020.1">def finalize_ivars(self, parent):
    '''
    Update the body text of all nodes in parent's tree using the injected
    v._import_lines lists.
    '''
    for p in parent.self_and_subtree():
        v = p.v
        # Make sure that no code in x.post_pass has mistakenly set p.b.
        assert not v._bodyString, repr(v._bodyString)
        lines = v._import_lines
        if lines:
            if not lines[-1].endswith('\n'):
                lines[-1] += '\n'
        v._bodyString = g.toUnicode(''.join(lines), reportErrors=True)
            # Bug fix: 2017/01/24: must convert to unicode!
            # This was the source of the internal error in the p.b getter.
        delattr(v, '_import_lines')
</t>
<t tx="ekr.20161110042512.1"># All code in passes 1 and 2 *must* use this API to change body text.

def add_line(self, p, s):
    '''Append the line s to p.v._import_lines.'''
    assert s and isinstance(s, str), (repr(s), g.callers())
    # *Never* change p unexpectedly!
    assert hasattr(p.v, '_import_lines'), (repr(s), g.callers())
    p.v._import_lines.append(s)

def clear_lines(self, p):
    p.v._import_lines = []

def extend_lines(self, p, lines):
    p.v._import_lines.extend(list(lines))

def get_lines(self, p):
    # *Never* change p unexpectedly!
    assert hasattr(p.v, '_import_lines'), (p and p.h, g.callers())
    return p.v._import_lines

def has_lines(self, p):
    return hasattr(p.v, '_import_lines')

def inject_lines_ivar(self, p):
    '''Inject _import_lines into p.v.'''
    # *Never* change p unexpectedly!
    assert not p.v._bodyString, (p and p.h, g.callers(10))
    p.v._import_lines = []

def prepend_lines(self, p, lines):
    p.v._import_lines = list(lines) + p.v._import_lines

def set_lines(self, p, lines):
    p.v._import_lines = list(lines)
</t>
<t tx="ekr.20161110073751.1">def clean_headline(self, s, p=None):
    '''Return a cleaned up headline s.'''
    if p: # Called from clean_all_headlines:
        return self.get_decorator(p) + p.h
    # Handle defs.
    m = re.match(r'\s*def\s+(\w+)', s)
    if m:
        return m.group(1)
    # Handle classes.
    #913: Show base classes in python importer.
    #978: Better regex handles class C(bar.Bar)
    m = re.match(r'\s*class\s+(\w+)\s*(\([\w.]+\))?', s)
    if m:
        return 'class %s%s' % (m.group(1), m.group(2) or '')
    return s.strip()

def get_decorator(self, p):
    if g.unitTesting or self.put_decorators:
        for s in self.get_lines(p):
            if not s.isspace():
                m = re.match(r'\s*@\s*([\w\.]+)', s)
                if m:
                    s = s.strip()
                    if s.endswith('('):
                        s = s[:-1].strip()
                    return s + ' '
                return ''
    return ''
</t>
<t tx="ekr.20161110125940.1">def clean_all_headlines(self, parent):
    '''
    Clean all headlines in parent's tree by calling the language-specific
    clean_headline method.
    '''
    for p in parent.subtree():
        # Note: i.gen_ref calls clean_headline without knowing p.
        # As a result, the first argument is required.
        h = self.clean_headline(p.h, p=p)
        if h and h != p.h:
            p.h = h
    
</t>
<t tx="ekr.20161110130157.1">def clean_all_nodes(self, parent):
    '''Clean the nodes in parent's tree, in a language-dependent way.'''
    # i.clean_nodes does nothing.
    # Subclasses may override as desired.
    # See perl_i.clean_nodes for an example.
    self.clean_nodes(parent)
</t>
<t tx="ekr.20161110130337.1">def unindent_all_nodes(self, parent):
    '''Unindent all nodes in parent's tree.'''
    for p in parent.subtree():
        lines = self.get_lines(p)
        if all([z.isspace() for z in lines]):
            # Somewhat dubious, but i.check covers for us.
            self.clear_lines(p)
        else:
            self.set_lines(p, self.undent(p))
</t>
<t tx="ekr.20161110130709.1">def delete_all_empty_nodes(self, parent):
    '''
    Delete nodes consisting of nothing but whitespace.
    Move the whitespace to the preceding node.
    '''
    c = self.c
    aList = []
    for p in parent.subtree():
        back = p.threadBack()
        if back and back.v != parent.v and back.v != self.root.v and not p.isCloned():
            lines = self.get_lines(p)
            # Move the whitespace from p to back.
            if all([z.isspace() for z in lines]):
                self.extend_lines(back, lines)
                # New in Leo 5.7: empty nodes may have children.
                if p.hasChildren():
                    # Don't delete p.
                    p.h = 'organizer'
                    self.clear_lines(p)
                else:
                    # Do delete p.
                    aList.append(p.copy())
    if aList:
        c.deletePositionsInList(aList, redraw=False)
            # Suppress redraw.
</t>
<t tx="ekr.20161110131509.1">def promote_trailing_underindented_lines(self, parent):
    '''
    Promote all trailing underindent lines to the node's parent node,
    deleting one tab's worth of indentation. Typically, this will remove
    the underindent escape.
    '''
    pattern = self.escape_pattern # A compiled regex pattern
    for p in parent.subtree():
        lines = self.get_lines(p)
        tail = []
        while lines:
            line = lines[-1]
            m = pattern.match(line)
            if m:
                lines.pop()
                n_str = m.group(1)
                try:
                    n = int(n_str)
                except ValueError:
                    break
                if n == abs(self.tab_width):
                    new_line = line[len(m.group(0)):]
                    tail.append(new_line)
                else:
                    g.trace('unexpected unindent value', n)
                    g.trace(line)
                    # Fix #652 by restoring the line.
                    new_line = line[len(m.group(0)):].lstrip()
                    lines.append(new_line)
                    break
            else:
                break
        if tail:
            parent = p.parent()
            if parent.parent() == self.root:
                parent = parent.parent()
            self.set_lines(p, lines)
            self.extend_lines(parent, reversed(tail))
</t>
<t tx="ekr.20161110173058.1">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an examplle.
    '''
    pass
</t>
<t tx="ekr.20161111023249.1">def finish(self, parent):
    '''
    Stage 3 (the last) stage of the importer pipeline.

    Subclasses should never need to override this method.
    '''
    # Put directives at the end, so as not to interfere with shebang lines, etc.
    self.add_root_directives(parent)
    #
    # Finally, remove all v._import_list temporaries.
    self.finalize_ivars(parent)
</t>
<t tx="ekr.20161111024447.1">def generate_nodes(self, s, parent):
    '''
    A three-stage pipeline to generate all imported nodes.
    '''
    # Stage 1: generate nodes.
    # After this stage, the p.v._import_lines list contains p's future body text.
    self.gen_lines(s, parent)
    #
    # Optional Stage 2, consisting of zero or more sub-stages.
    # Subclasses may freely override this method, **provided**
    # that all substages use the API for setting body text.
    # Changing p.b directly will cause asserts to fail in i.finish().
    self.post_pass(parent)
    #
    # Stage 3: Put directives in the root node and set p.b for all nodes.
    #
    # Subclasses should never need to override this stage.
    self.finish(parent)
</t>
<t tx="ekr.20161113135037.1">@nobeautify
cached_scan_tables = {}

def get_table(self, context):
    '''
    Return the state table for the given context.

    This method handles caching.  x.get_new_table returns the actual table.
    '''
    key = '%s.%s' % (self.name, context)
        # Bug fix: must keep tables separate.
    table = self.cached_scan_tables.get(key)
    if table:
        return table
    table = self.get_new_dict(context)
    self.cached_scan_tables[key] = table
    return table
</t>
<t tx="ekr.20161114012522.1">def all_contexts(self, table):
    '''
    Return a list of all contexts contained in the third column of the given table.

    This is a support method for unit tests.
    '''
    contexts = set()
    d = table
    for key in d:
        aList = d.get(key)
        for data in aList:
            if len(data) == 4:
                # It's an out-of-context entry.
                contexts.add(data[2])
    # Order must not matter, so sorting is ok.
    return sorted(contexts)
</t>
<t tx="ekr.20161114024119.1">def test_scan_state(self, tests, State):
    '''
    Test x.scan_line or i.scan_line.

    `tests` is a list of g.Bunches with 'line' and 'ctx' fields.

    A typical @command test:

        if c.isChanged(): c.save()
        &lt; &lt; imp.reload importers.linescanner and importers.python &gt; &gt;
        importer = py.Py_Importer(c.importCommands)
        importer.test_scan_state(tests, Python_ScanState)
    '''
    assert self.single_comment == '#', self.single_comment
    table = self.get_table(context='')
    contexts = self.all_contexts(table)
    for bunch in tests:
        assert bunch.line is not None
        line = bunch.line
        ctx = getattr(bunch, 'ctx', None)
        if ctx: # Test one transition.
            ctx_in, ctx_out = ctx
            prev_state =  State()
            prev_state.context = ctx_in
            new_state = self.scan_line(line, prev_state)
            new_context = new_state.context
            assert new_context == ctx_out, (
                'FAIL1:\nline: %r\ncontext: %r new_context: %r ctx_out: %r\n%s\n%s' % (
                    line, ctx_in, new_context, ctx_out, prev_state, new_state))
        else: # Test all transitions.
            for context in contexts:
                prev_state =  State()
                prev_state.context = context
                new_state = self.scan_line(line, prev_state)
                assert new_state.context == context, (
                    'FAIL2:\nline: %r\ncontext: %r new_context: %r\n%s\n%s' % (
                        line, context, new_state.context, prev_state, new_state))
</t>
<t tx="ekr.20161116034633.2">def cut_stack(self, new_state, stack, append=False):
    '''Cut back the stack until stack[-1] matches new_state.'''
    # pylint: disable=arguments-differ
    assert len(stack) &gt; 1 # Fail on entry.
    while stack:
        top_state = stack[-1].state
        if new_state.level() &lt; top_state.level():
            assert len(stack) &gt; 1, stack # &lt;
            stack.pop()
        elif top_state.level() == new_state.level():
            assert len(stack) &gt; 1, stack # ==
            if append:
                pass # Append line to the previous node.
            else:
                stack.pop() # Create a new node.
            break
        else:
            # This happens often in valid Python programs.
            break
    # Restore the guard entry if necessary.
    if len(stack) == 1:
        stack.append(stack[-1])
    assert len(stack) &gt; 1 # Fail on exit.
</t>
<t tx="ekr.20161116034633.7">def start_new_block(self, i, lines, new_state, prev_state, stack):
    '''Create a child node and update the stack.'''
    assert not prev_state.in_context(), prev_state
    line = lines[i]
    top = stack[-1]
    # Adjust the stack.
    if new_state.indent &gt; top.state.indent:
        pass
    elif new_state.indent == top.state.indent:
        stack.pop()
    else:
        self.cut_stack(new_state, stack)
    # Create the child.
    top = stack[-1]
    parent = top.p
    self.gen_ref(line, parent, top)
    h = self.clean_headline(line, p=None)
    child = self.create_child_node(parent, line, h)
    self.prepend_lines(child, self.decorator_lines)
    self.decorator_lines = []
    target = PythonTarget(child, new_state)
    target.kind = 'class' if h.startswith('class') else 'def'
    stack.append(target)
</t>
<t tx="ekr.20161116040557.1">starts_pattern = re.compile(r'\s*(class|def)\s+')
    # Matches lines that apparently start a class or def.

def starts_block(self, i, lines, new_state, prev_state, stack):
    '''True if the line startswith class or def outside any context.'''
    # pylint: disable=arguments-differ
    if prev_state.in_context():
        return False
    line = lines[i]
    m = self.starts_pattern.match(line)
    if not m:
        return False
    top = stack[-1]
    prev_indent = top.state.indent
    if top.kind == 'None' and new_state.indent &gt; 0:
        # Underindented top-level class/def.
        return False
    if top.kind == 'def' and new_state.indent &gt; prev_indent:
        # class/def within a def.
        # #1493: Insert decorators.
        p = self.tail_p or top.p
        for line in self.decorator_lines:
            self.add_line(p, line)
        return False
    if top.at_others_flag and new_state.indent &gt; prev_indent:
        return False
    return True
</t>
<t tx="ekr.20161116173901.1">def end_block(self, i, lines, new_state, prev_state, stack):
    '''
    Handle a line that terminates the previous class/def. The line is
    neither a class/def line, and we are not in a multi-line token.

    Skip all lines that are at the same level as the class/def.
    '''
    # pylint: disable=arguments-differ
    top = stack[-1]
    assert new_state.indent &lt; top.state.indent, (
        '\nnew: %s\ntop: %s' % (new_state, top.state))
    assert self.skip == 0, self.skip
    end_indent = new_state.indent
    while i &lt; len(lines):
        progress = i
        self.cut_stack(new_state, stack, append=True)
        top = stack[-1]
        # Add the line.
        line = lines[i]
        self.add_line(top.p, line)
        # Move to the next line.
        i += 1
        if i &gt;= len(lines):
            break
        prev_state = new_state
        new_state = self.scan_line(line, prev_state)
        if self.starts_block(i, lines, new_state, prev_state, stack):
            break
        elif not self.is_ws_line(line) and new_state.indent &lt;= end_indent:
            break
        else:
            self.skip += 1
        assert progress &lt; i, repr(line)
    return top.p
</t>
<t tx="ekr.20161119083054.1">def find_class(self, parent):
    '''
    Find the start and end of a class/def in a node.

    Return (kind, i, j), where kind in (None, 'class', 'def')
    '''
    # Called from Leo's core to implement two minor commands.
    prev_state = Python_ScanState()
    target = Target(parent, prev_state)
    stack = [target, target]
    lines = g.splitlines(parent.b)
    index = 0
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        if self.starts_block(i, lines, new_state, prev_state, stack):
                # Bug fix 2019/06/05: added "stack" arg(!)
            return self.skip_block(i, index, lines, new_state, stack)
        prev_state = new_state
        index += len(line)
    return None, -1, -1
</t>
<t tx="ekr.20161119124217.1">def starts_block(self, i, lines, new_state, prev_state):
    '''True if the new state starts a block.'''
    return new_state.level() &gt; prev_state.level()
</t>
<t tx="ekr.20161119130337.1">def cut_stack(self, new_state, stack):
    '''Cut back the stack until stack[-1] matches new_state.'''
    
    def underflow(n):
        g.trace(n)
        g.trace(new_state)
        g.printList(stack)
        
    # assert len(stack) &gt; 1 # Fail on entry.
    if len(stack) &lt;= 1:
        return underflow(0)
    while stack:
        top_state = stack[-1].state
        if new_state.level() &lt; top_state.level():
            if len(stack) &gt; 1:
                stack.pop()
            else:
                return underflow(1)
        elif top_state.level() == new_state.level():
            # assert len(stack) &gt; 1, stack # ==
            # This is the only difference between i.cut_stack and python/cs.cut_stack
            if len(stack) &lt;= 1:
                return underflow(2)
            break
        else:
            # This happens often in valid Python programs.
            break
    # Restore the guard entry if necessary.
    if len(stack) == 1:
        stack.append(stack[-1])
    elif len(stack) &lt;= 1:
        return underflow(3)
    return None
</t>
<t tx="ekr.20161119161953.1">def gen_lines(self, s, parent):
    '''
    Non-recursively parse all lines of s into parent, creating descendant
    nodes as needed.
    '''
    self.tail_p = None
    prev_state = self.state_class()
    target = PythonTarget(parent, prev_state)
    stack = [target, target]
    self.decorator_lines = []
    self.inject_lines_ivar(parent)
    lines = g.splitLines(s)
    self.skip = 0
    first = True
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        top = stack[-1]
        if self.skip &gt; 0:
            self.skip -= 1
        elif self.starts_decorator(i, lines, new_state):
            pass # Sets self.skip and self.decorator_lines.
        elif self.starts_block(i, lines, new_state, prev_state, stack):
            first = False
            self.tail_p = None
            self.start_new_block(i, lines, new_state, prev_state, stack)
        elif first:
            if self.is_ws_line(line):
                p = self.tail_p or top.p
                self.add_line(p, line)
            else:
                first = False
                h = 'Declarations'
                self.gen_ref(line, parent, target)
                p = self.create_child_node(parent, body=line, headline=h)
                stack.append(PythonTarget(p, new_state))
        elif self.ends_block(line, new_state, prev_state, stack):
            first = False
            self.tail_p = self.end_block(i, lines, new_state, prev_state, stack)
        else:
            p = self.tail_p or top.p
            self.add_line(p, line)
        prev_state = new_state
    if self.skip:
        g.trace('can not happen: self.skip &gt; 0', color='red')
    if self.decorator_lines:
        g.trace('can not happen: unused decorator lines...', color='red')
        g.printObj(self.decorator_lines)

</t>
<t tx="ekr.20161119162451.1">def trace_status(self, line, new_state, prev_state, stack, top):
    '''Print everything important in the i.gen_lines loop.'''
    print('')
    try:
        g.trace('===== %r' % line)
    except Exception:
        g.trace('     top.p: %s' % g.toEncodedString(top.p.h))
    # print('len(stack): %s' % len(stack))
    print(' new_state: %s' % new_state)
    print('prev_state: %s' % prev_state)
    # print(' top.state: %s' % top.state)
    g.printList(stack)
</t>
<t tx="ekr.20161120022121.1"></t>
<t tx="ekr.20161123210335.1">def trace_lines(self, lines1, lines2, parent):
    '''Show both s1 and s2.'''
    print('===== s1: %s' % parent.h)
    for i, s in enumerate(lines1):
        g.pr('%3s %r' % (i+1, s))
    print('===== s2')
    for i, s in enumerate(lines2):
        g.pr('%3s %r' % (i+1, s))
</t>
<t tx="ekr.20161123210716.1">def show_failure(self, lines1, lines2, sfn):
    '''Print the failing lines, with surrounding context.'''
    if not g.unitTesting:
        g.es('@auto failed:', sfn, color='red')
    n1, n2 = len(lines1), len(lines2)
    print('\n===== PERFECT IMPORT FAILED =====', sfn)
    print('len(s1): %s len(s2): %s' % (n1, n2))
    for i in range(min(n1, n2)):
        line1, line2 = lines1[i], lines2[i]
        if line1 != line2:
            print('first mismatched line: %s' % (i+1))
            print('s1...')
            print(''.join(self.context_lines(lines1, i)))
            print('s2...')
            print(''.join(self.context_lines(lines2, i)))
            # print(repr(line1))
            # print(repr(line2))
            break
    else:
        print('all common lines match')
</t>
<t tx="ekr.20161124030004.1">def clean_last_lines(self, lines):
    '''Remove blank lines from the end of lines.'''
    while lines and lines[-1].isspace():
        lines.pop()
    return lines
</t>
<t tx="ekr.20161125174423.1">def print_stack(self, stack):
    '''Print a stack of positions.'''
    g.printList([p.h for p in stack])
</t>
<t tx="ekr.20161127102339.1">def ends_block(self, line, new_state, prev_state, stack):
    '''True if line ends the block.'''
    # Comparing new_state against prev_state does not work for python.
    top = stack[-1]
    return new_state.level() &lt; top.state.level()
</t>
<t tx="ekr.20161128025444.1">def scan_dict(self, context, i, s, d):
    '''
    i.scan_dict: Scan at position i of s with the give context and dict.
    Return the 6-tuple: (new_context, i, delta_c, delta_p, delta_s, bs_nl)
    '''
    found = False
    delta_c = delta_p = delta_s = 0
    ch = s[i]
    aList = d.get(ch)
    if aList and context:
        # In context.
        for data in aList:
            kind, pattern, ends = data
            if self.match(s, i, pattern):
                if ends is None:
                    found = True
                    new_context = context
                    break
                elif ends:
                    found = True
                    new_context = ''
                    break
                else:
                    pass # Ignore this match.
    elif aList:
        # Not in context.
        for data in aList:
            kind, pattern, new_context, deltas = data
            if self.match(s, i, pattern):
                found = True
                if deltas:
                    delta_c, delta_p, delta_s = deltas
                break
    if found:
        if kind == 'all':
            i = len(s)
        elif kind == 'len+1':
            i += (len(pattern) + 1)
        else:
            assert kind == 'len', (kind, self.name)
            i += len(pattern)
        bs_nl = pattern == '\\\n'
        return new_context, i, delta_c, delta_p, delta_s, bs_nl
    #
    # No match: stay in present state. All deltas are zero.
    new_context = context
    return new_context, i+1, 0, 0, 0, False
</t>
<t tx="ekr.20161128025508.1">@nobeautify

def get_new_dict(self, context):
    '''
    Return a *general* state dictionary for the given context.
    Subclasses may override...
    '''
    comment, block1, block2 = self.single_comment, self.block1, self.block2

    def add_key(d, pattern, data):
        key = pattern[0]
        aList = d.get(key,[])
        aList.append(data)
        d[key] = aList

    if context:
        d = {
            # key    kind      pattern  ends?
            '\\':   [('len+1', '\\',    None),],
            '"':    [('len',   '"',     context == '"'),],
            "'":    [('len',   "'",     context == "'"),],
        }
        if block1 and block2:
            add_key(d, block2, ('len', block2, True))
    else:
        # Not in any context.
        d = {
            # key    kind pattern new-ctx  deltas
            '\\':[('len+1', '\\', context, None),],
            '"':    [('len', '"', '"',     None),],
            "'":    [('len', "'", "'",     None),],
            '{':    [('len', '{', context, (1,0,0)),],
            '}':    [('len', '}', context, (-1,0,0)),],
            '(':    [('len', '(', context, (0,1,0)),],
            ')':    [('len', ')', context, (0,-1,0)),],
            '[':    [('len', '[', context, (0,0,1)),],
            ']':    [('len', ']', context, (0,0,-1)),],
        }
        if comment:
            add_key(d, comment, ('all', comment, '', None))
        if block1 and block2:
            add_key(d, block1, ('len', block1, block1, None))
    return d
</t>
<t tx="ekr.20161128054630.1">@nobeautify

def get_new_dict(self, context):
    '''
    Return a *general* state dictionary for the given context.
    Subclasses may override...
    '''
    comment, block1, block2 = self.single_comment, self.block1, self.block2

    def add_key(d, key, data):
        aList = d.get(key,[])
        aList.append(data)
        d[key] = aList

    if context:
        d = {
            # key   kind    pattern ends?
            '\\':   [('len+1', '\\',None),],
            '"':[
                    ('len', '"""',  context == '"""'),
                    ('len', '"',    context == '"'),
                ],
            "'":[
                    ('len', "'''",  context == "'''"),
                    ('len', "'",    context == "'"),
                ],
        }
        if block1 and block2:
            add_key(d, block2[0], ('len', block1, True))
    else:
        # Not in any context.
        d = {
            # key    kind pattern new-ctx  deltas
            '\\': [('len+1','\\', context, None),],
            '#':  [('all', '#',   context, None),],
            '"':[
                    # order matters.
                    ('len', '"""',  '"""', None),
                    ('len', '"',    '"',   None),
                ],
            "'":[
                    # order matters.
                    ('len', "'''",  "'''", None),
                    ('len', "'",    "'",   None),
                ],
            '{':    [('len', '{', context, (1,0,0)),],
            '}':    [('len', '}', context, (-1,0,0)),],
            '(':    [('len', '(', context, (0,1,0)),],
            ')':    [('len', ')', context, (0,-1,0)),],
            '[':    [('len', '[', context, (0,0,1)),],
            ']':    [('len', ']', context, (0,0,-1)),],
        }
        if comment:
            add_key(d, comment[0], ('all', comment, '', None))
        if block1 and block2:
            add_key(d, block1[0], ('len', block1, block1, None))
    return d
</t>
<t tx="ekr.20161205052712.1">def skip_block(self, i, index, lines, prev_state, stack):
    '''
    Find the end of a class/def starting at index
    on line i of lines.

    Return (kind, i, j), where kind in (None, 'class', 'def')
    .'''
    index1 = index
    line = lines[i]
    kind = 'class' if line.strip().startswith('class') else 'def'
    i += 1
    while i &lt; len(lines):
        progress = i
        line = lines[i]
        index += len(line)
        new_state = self.scan_line(line, prev_state)
        if self.ends_block(line, new_state, prev_state, stack):
            return kind, index1, index
        prev_state = new_state
        i += 1
        assert progress &lt; i
    return None, -1, -1
</t>
<t tx="ekr.20161220064822.1">def gen_ref(self, line, parent, target):
    '''
    Generate the at-others and a flag telling this method whether a previous
    @others
    '''
    indent_ws = self.get_str_lws(line)
    h = self.clean_headline(line, p=None)
    if not target.at_others_flag:
        target.at_others_flag = True
        ref = '%s@others\n' % indent_ws
        self.add_line(parent,ref)
    return h
</t>
<t tx="ekr.20161220073836.1">def ends_block(self, line, new_state, prev_state, stack):
    '''True if line ends the block.'''
    # Comparing new_state against prev_state does not work for python.
    if self.is_ws_line(line) or prev_state.in_context():
        return False
    # *Any* underindented non-blank line ends the class/def.
    top = stack[-1]
    return new_state.level() &lt; top.state.level()
</t>
<t tx="ekr.20161220171728.1">def common_lws(self, lines):
    '''Return the lws (a string) common to all lines.'''
    return self.get_str_lws(lines[0]) if lines else ''
        # We must unindent the class/def line fully.
        # It would be wrong to examine the indentation of other lines.
</t>
<t tx="ekr.20161222112801.1">def promote_trailing_underindented_lines(self, parent):
    '''
    Promote all trailing underindent lines to the node's parent node,
    deleting one tab's worth of indentation. Typically, this will remove
    the underindent escape.
    '''
    pattern = self.escape_pattern # A compiled regex pattern
    for p in parent.children(): # 2018/05/24.
        lines = self.get_lines(p)
        tail = []
        while lines:
            line = lines[-1]
            m = pattern.match(line)
            if m:
                lines.pop()
                n_str = m.group(1)
                try:
                    n = int(n_str)
                except ValueError:
                    break
                if n == abs(self.tab_width):
                    new_line = line[len(m.group(0)):]
                    tail.append(new_line)
                else:
                    g.trace('unexpected unindent value', n)
                    break
            else:
                break
        if tail:
            parent = p.parent()
            self.set_lines(p, lines)
            self.extend_lines(parent, reversed(tail))
</t>
<t tx="ekr.20161222122914.1">def promote_last_lines(self, parent):
    '''A placeholder for python_i.promote_last_lines.'''
</t>
<t tx="ekr.20161222123105.1">def promote_last_lines(self, parent):
    '''python_i.promote_last_lines.'''
    last = parent.lastNode()
    if not last or last.h == 'Declarations':
        return
    if last.parent() != parent:
        return # The indentation would be wrong.
    lines = self.get_lines(last)
    prev_state = self.state_class()
    if_pattern = re.compile(r'^\s*if\b')
    # Scan for a top-level if statement.
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        m = if_pattern.match(line)
        if m and not prev_state.context and new_state.indent == 0:
            self.set_lines(last, lines[:i])
            self.extend_lines(parent, lines[i:])
            break
        else:
            prev_state = new_state
</t>
<t tx="ekr.20170126100139.1">def initBlock0(self):
    """
    Init *local* ivars when handling block 0.
    This prevents endless recalculation of the proper default state.
    """
    if self.enabled:
        n = self.setInitialStateNumber()
    else:
        n = self.setRestart(self.restartNoColor)
    return n
</t>
<t tx="ekr.20170126101049.1">def setInitialStateNumber(self):
    """
    Init the initialStateNumber ivar for clearState()
    This saves a lot of work.

    Called from init() and initBlock0.
    """
    state = self.languageTag(self.language)
    n = self.stateNameToStateNumber(None, state)
    self.initialStateNumber = n
    self.blankStateNumber = self.stateNameToStateNumber(None, state + ';blank')
    return n
</t>
<t tx="ekr.20170126103925.1">def languageTag(self, name):
    """
    Return the standardized form of the language name.
    Doing this consistently prevents subtle bugs.
    """
    if name:
        table = (
            ('markdown', 'md'),
            ('python', 'py'),
            ('javascript', 'js'),
        )
        for pattern, s in table:
            name = name.replace(pattern, s)
        return name
    return 'no-language'
</t>
<t tx="ekr.20170305105047.1">decorator_pattern = re.compile(r'^\s*@\s*(\w+)')

def starts_decorator(self, i, lines, prev_state):
    '''
    True if the line looks like a decorator outside any context.

    Puts the entire decorator into the self.decorator_lines list,
    and sets self.skip so that the next line to be handled is a class/def line.
    '''
    assert self.skip == 0
    if prev_state.context:
        # Only test for docstrings, not [{(.
        return False
    old_skip = self.skip
    old_decorator_lines = self.decorator_lines[:]
    line = lines[i]
    m = self.decorator_pattern.match(line)
    if m and m.group(1) not in g.globalDirectiveList:
        # Fix #360: allow multiline matches
        # Carefully skip all lines until a class/def.
        self.decorator_lines = [line]
        for i, line in enumerate(lines[i+1:]):
            new_state = self.scan_line(line, prev_state)
            m = self.starts_pattern.match(line)
            if m:
                # 2018/05/24: don't check in_context!
                # The class or def could start a context.
                return True
            self.decorator_lines.append(line)
            self.skip += 1
            prev_state = new_state
    # Recover froma a bare decorator, without a class or def.
    self.skip = old_skip
    self.decorator_lines = old_decorator_lines
    return False
</t>
<t tx="ekr.20170404035138.1">def context_lines(self, aList, i, n=2):
    '''Return a list containing the n lines of surrounding context of aList[i].'''
    result = []
    aList1 = aList[max(0, i-n):i]
    aList2 = aList[i+1:i+n+1]
    result.extend(['  %4s %r\n' % (i + 1 - len(aList1) + j, g.truncate(s,60))
        for j, s in enumerate(aList1)])
    result.append('* %4s %r\n' % (i + 1, g.truncate(aList[i], 60)))
    result.extend(['  %4s %r\n' % (i + 2 + j, g.truncate(s, 60))
        for j, s in enumerate(aList2)])
    return result
</t>
<t tx="ekr.20170405191106.1">def import_binary_file(self, fileName, parent):

    # Fix bug 1185409 importing binary files puts binary content in body editor.
    # Create an @url node.
    c = self.c
    if parent:
        p = parent.insertAsLastChild()
    else:
        p = c.lastTopLevel().insertAfter()
    p.h = f"@url file://{fileName}"
    return p
</t>
<t tx="ekr.20170414034616.3">def gitInfo(path=None):
    """
    Path may be a directory or file.

    Return the branch and commit number or ('', '').
    """
    branch, commit = '', ''  # Set defaults.
    if path is None:
        # Default to leo/core.
        path = os.path.dirname(__file__)
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    # Does path/../ref exist?
    path = g.gitHeadPath(path)
    if not path:
        return branch, commit
    try:
        with open(path) as f:
            s = f.read()
            if not s.startswith('ref'):
                branch = 'None'
                commit = s[:7]
                return branch, commit
        # On a proper branch
        pointer = s.split()[1]
        dirs = pointer.split('/')
        branch = dirs[-1]
    except IOError:
        g.trace('can not open:', path)
        return branch, commit
    # Try to get a better commit number.
    git_dir = g.os_path_finalize_join(path, '..')
    try:
        path = g.os_path_finalize_join(git_dir, pointer)
        with open(path) as f:
            s = f.read()
        commit = s.strip()[0:12]
        # shorten the hash to a unique shortname
    except IOError:
        try:
            path = g.os_path_finalize_join(git_dir, 'packed-refs')
            with open(path) as f:
                for line in f:
                    if line.strip().endswith(' ' + pointer):
                        commit = line.split()[0][0:12]
                        break
        except IOError:
            pass
    return branch, commit
</t>
<t tx="ekr.20170414034616.6">def gitHeadPath(path):
    """
    Compute the path to .git/HEAD given the path.
    """
    #Transcrypt does not support Python's pathlib module.
    # __pragma__ ('skip')
    from pathlib import Path
    path = Path(path)
    # #1780: Look up the directory tree, looking the .git directory.
    while os.path.exists(path):
        head = os.path.join(path, '.git', 'HEAD')
        if os.path.exists(head):
            return head
        if path == path.parent:
            break
        path = path.parent
    # __pragma__ ('noskip')

    return None
</t>
<t tx="ekr.20170427112302.1">g.cls()
import glob
files = glob.glob(g.os_path_join(g.app.loadDir, '*.py'))
files = [z for z in files if g.os_path_basename(z).startswith('leo')]
if 0:
    g.printList(files)
found = set()
for p in c.all_unique_positions():
    name = p.isAnyAtFileNode()
    if name and name.startswith('leo'):
        path = g.os_path_join(g.app.loadDir, name)
        found.add(path)
if 0:
    print('found')
    g.printList(list(found))
else:
    missing = set(files) - found
    if missing:
        print('not found...')
        g.printList(list(sorted(missing)))
    else:
        print('done')
        </t>
<t tx="ekr.20170427114412.1"></t>
<t tx="ekr.20170428084123.1">"""Recursively import all python files in a directory and clean the result."""
g.cls()
# dir_ = r'C:\leo.repo\leointeg\src'
# dir_ = r'C:\apps\Emacs\share\emacs\26.1\lisp\outline.el'
# dir_ = r'C:\Users\edreamleo\Anaconda3\Lib\site-packages\Pymacs.py'
# dir_ = r'C:\Users\edreamleo\emacs-packages\pymacs.el'
# dir_ = r'C:\leo.repo\pscript'
dir_ = r'C:\Users\edreamleo\Anaconda3\Lib\site-packages\black.py'
c.recursiveImport(
    dir_ = dir_,
    kind = '@clean', # '@clean', #'@nosent','@auto','@file',
    recursive = False,
    safe_at_file = False,
    theTypes = ['.py',] # '.py',],
)
</t>
<t tx="ekr.20170428084208.443">#!/usr/bin/python
# This file generates pyflakes warnings for *all* imported symbols.
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20170428084208.444">from .globals                   import DEBUG, DISABLE_RESIZE_SYSTEM

from .wgwidget                  import TEST_SETTINGS, ExhaustedTestInput, add_test_input_from_iterable, add_test_input_ch

from .npyssafewrapper           import wrapper, wrapper_basic

from   .npysThemeManagers       import ThemeManager, disableColor, enableColor
from   . import npysThemes      as     Themes
from   .apNPSApplication        import NPSApp
from   .apNPSApplicationManaged import NPSAppManaged
from   .proto_fm_screen_area    import setTheme
from   .fmForm                  import FormBaseNew, Form, TitleForm, TitleFooterForm, SplitForm, FormExpanded, FormBaseNewExpanded, blank_terminal
from   .fmActionForm            import ActionForm, ActionFormExpanded
from   .fmActionFormV2          import ActionFormV2, ActionFormExpandedV2, ActionFormMinimal
from   .fmFormWithMenus         import FormWithMenus, ActionFormWithMenus, \
                                       FormBaseNewWithMenus, SplitFormWithMenus, \
                                       ActionFormV2WithMenus
from   .fmPopup                 import Popup, MessagePopup, ActionPopup, PopupWide, ActionPopupWide
from   .fmFormMutt              import FormMutt, FormMuttWithMenus
from   .fmFileSelector          import FileSelector, selectFile

from .fmFormMuttActive          import ActionControllerSimple, TextCommandBox, \
                                       FormMuttActive, FormMuttActiveWithMenus
from .fmFormMuttActive          import FormMuttActiveTraditional, FormMuttActiveTraditionalWithMenus


from .fmFormMultiPage           import FormMultiPage, FormMultiPageAction,\
                                       FormMultiPageActionWithMenus, FormMultiPageWithMenus

from .npysNPSFilteredData       import NPSFilteredDataBase, NPSFilteredDataList

from .wgbutton                  import MiniButton
from .wgbutton                  import MiniButtonPress
from .wgbutton                  import MiniButton      as Button
from .wgbutton                  import MiniButtonPress as ButtonPress

from .wgtextbox                 import Textfield, FixedText
from .wgtitlefield              import TitleText, TitleFixedText
from .wgpassword                import PasswordEntry, TitlePassword
from .wgannotatetextbox         import AnnotateTextboxBase
from .wgannotatetextbox         import AnnotateTextboxBaseRight

from .wgslider                  import Slider, TitleSlider
from .wgslider                  import SliderNoLabel, TitleSliderNoLabel
from .wgslider                  import SliderPercent, TitleSliderPercent

from .wgwidget                  import DummyWidget, NotEnoughSpaceForWidget
from . import wgwidget as widget

from .wgmultiline               import MultiLine, Pager, TitleMultiLine, TitlePager, MultiLineAction, BufferPager, TitleBufferPager
from .wgmultiselect             import MultiSelect, TitleMultiSelect, MultiSelectFixed, \
                                       TitleMultiSelectFixed, MultiSelectAction
from .wgeditmultiline           import MultiLineEdit
from .wgcombobox                import ComboBox, TitleCombo
from .wgcheckbox                import Checkbox, RoundCheckBox, CheckBoxMultiline, RoundCheckBoxMultiline, CheckBox, CheckboxBare
from .wgFormControlCheckbox     import FormControlCheckbox
from .wgautocomplete            import TitleFilename, Filename, Autocomplete
from .muMenu                    import Menu
from .wgselectone               import SelectOne, TitleSelectOne
from .wgdatecombo               import DateCombo, TitleDateCombo

from .npysTree import TreeData
from .wgmultilinetree           import MLTree, MLTreeAnnotated, MLTreeAction, MLTreeAnnotatedAction
from .wgmultilinetreeselectable import MLTreeMultiSelect, TreeLineSelectable
from .wgmultilinetreeselectable import MLTreeMultiSelectAnnotated, TreeLineSelectableAnnotated


# The following are maintained for compatibility with old code only. ##########################################

from .compatibility_code.oldtreeclasses import MultiLineTree, SelectOneTree
from .compatibility_code.oldtreeclasses import MultiLineTreeNew, MultiLineTreeNewAction, TreeLine, TreeLineAnnotated # Experimental
from .compatibility_code.oldtreeclasses import MultiLineTreeNewAnnotatedAction, MultiLineTreeNewAnnotated # Experimental
from .compatibility_code.npysNPSTree import NPSTreeData

# End compatibility. ###########################################################################################

from .wgfilenamecombo           import FilenameCombo, TitleFilenameCombo
from .wgboxwidget               import BoxBasic, BoxTitle
from .wgmultiline               import MultiLineActionWithShortcuts
from .wgmultilineeditable       import MultiLineEditable, MultiLineEditableTitle, MultiLineEditableBoxed

from .wgmonthbox                import MonthBox
from .wggrid                    import SimpleGrid
from .wggridcoltitles           import GridColTitles

from .muNewMenu                 import NewMenu, MenuItem
from .wgNMenuDisplay            import MenuDisplay, MenuDisplayScreen

from .npyspmfuncs               import CallSubShell

from .utilNotify                 import notify, notify_confirm, notify_wait, notify_ok_cancel, notify_yes_no

# Base classes for overriding:

# Standard Forms:
from . import stdfmemail

# Experimental Only
from .wgtextboxunicode import TextfieldUnicode
from .wgtexttokens     import TextTokens, TitleTextTokens

# Very experimental. Don't use for anything serious
from .apOptions import SimpleOptionForm
from .apOptions import OptionListDisplay, OptionChanger, OptionList, OptionLimitedChoices, OptionListDisplayLine
from .apOptions import OptionFreeText, OptionSingleChoice, OptionMultiChoice, OptionMultiFreeList, \
                       OptionBoolean, OptionFilename, OptionDate, OptionMultiFreeText


# This really is about as experimental as it gets
from .apNPSApplicationEvents import StandardApp
from .eveventhandler import Event


</t>
<t tx="ekr.20170428085201.1">@nosearch</t>
<t tx="ekr.20170510100003.1">def h_return (self, ch):
    '''
    Handle the return key in the minibuffer.
    Send the contents to k.masterKeyHandler.
    '''
    c = self.leo_c
    k = c.k
    val = self.value.strip()
    self.value = ''
    self.update()
    # g.trace('===== inState: %r val: %r' % (k.inState(), val))
    commandName = val
    c.frame.tree.set_status_line(c.p)
        # This may be changed by the command.
    if k.inState():
        # Handle the key.
        k.w = self.leo_wrapper
        k.arg = val
        g.app.gui.curses_gui_arg = val
        k.masterKeyHandler(
            event=KeyEvent(c, char='\n', event='', shortcut='\n', w=None))
        g.app.gui.curses_gui_arg = None
        k.clearState()
    elif commandName == 'repeat-complex-command':
        g.app.gui.repeatComplexCommand(c)
    else:
        # All other alt-x command
        event=KeyEvent(c,char='',event='',shortcut='',w=None)
        c.doCommandByName(commandName, event)
        # Support repeat-complex-command.
        c.setComplexCommand(commandName=commandName)
        c.redraw()
    # Do a full redraw, with c.p as the first visible node.
    # g.trace('----- after command')
    g.app.gui.redraw_in_context(c)
</t>
<t tx="ekr.20170522015906.1">@cmd('paste-text')
def pasteText(self, event=None, middleButton=False):
    '''
    Paste the clipboard into a widget.
    If middleButton is True, support x-windows middle-mouse-button easter-egg.
    '''
    trace = False and not g.unitTesting
    c = self.c
    w = event and event.widget
    if not isinstance(w, leoFrame.StringTextWrapper):
        g.trace('not a StringTextWrapper', repr(w))
        return
    wname = c.widget_name(w)
    i, j = oldSel = w.getSelectionRange()
        # Returns insert point if no selection.
    s = g.app.gui.getTextFromClipboard()
    s = g.toUnicode(s)
    if trace: g.trace('wname', wname, 'len(s)', len(s))
    single_line = any([wname.startswith(z) for z in ('head', 'minibuffer')])
    if single_line:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s[-1] in ('\n', '\r'):
            s = s[: -1]
    # Update the widget.
    if i != j:
        w.delete(i, j)
    w.insert(i, s)
    if wname.startswith('body'):
        c.frame.body.onBodyChanged('Paste', oldSel=oldSel)
    elif wname.startswith('head'):
        c.frame.tree.onHeadChanged(c.p, s=w.getAllText(), undoType='Paste')
            # New for Curses gui.

OnPasteFromMenu = pasteText
</t>
<t tx="ekr.20170606100707.1">def update_body(self, ins, s):
    '''
    Update self.values and p.b and vnode ivars after the present line changes.
    '''
    # pylint: disable=no-member,access-member-before-definition
    trace = False and not g.unitTesting
    c = self.leo_c
    p = c.p
    v = p.v
    undoType = 'update-body'
    i = self.cursor_line
    wrapper = c.frame.body.wrapper
    assert isinstance(wrapper, BodyWrapper), repr(wrapper)
    lines = self.values
    if trace: g.trace(i, len(lines), s.endswith('\n'), repr(s))
    head = lines[:i]
    tail = lines[i+1:]
    if i &lt; len(lines):
        if not s.endswith('\n'):
            s = s + '\n'
        aList = head + [s] + tail
        self.values = aList
        c.p.b = ''.join(aList)
        v.selectionLength = 0
        v.selectionStart = ins
        wrapper.ins = ins
        wrapper.sel = ins, ins
        self.onBodyChanged(undoType=undoType)
    elif i == len(lines):
        aList = head + [s]
        self.values = aList
        c.p.b = ''.join(aList)
        v.selectionLength = 0
        v.selectionStart = ins
        wrapper.ins = ins
        wrapper.sel = ins, ins
        self.onBodyChanged(undoType=undoType)
    else:
        g.trace('Can not happen', i, len(lines), repr(s))
        v.selectionLength = 0
        v.selectionStart = 0
    if g.splitLines(c.p.b) != self.values:
        g.trace('self.values')
        g.printList(self.values)
        g.trace('g.splitLines(c.p.b)')
        g.printList(g.splitLines(c.p.b))
</t>
<t tx="ekr.20170616102324.1">def execGitCommand(command, directory=None):
    """Execute the given git command in the given directory."""
    git_dir = g.os_path_finalize_join(directory, '.git')
    if not g.os_path_exists(git_dir):
        g.trace('not found:', git_dir, g.callers())
        return []
    if '\n' in command:
        g.trace('removing newline from', command)
        command = command.replace('\n', '')
    # #1777: Save/restore os.curdir
    old_dir = os.path.normpath(os.path.abspath(os.curdir))
    if directory:
        os.chdir(directory)
    try:
        p = subprocess.Popen(
            shlex.split(command),
            stdout=subprocess.PIPE,
            stderr=None,  # Shows error traces.
            shell=False,
        )
        out, err = p.communicate()
        lines = [g.toUnicode(z) for z in g.splitLines(out or [])]
    finally:
        os.chdir(old_dir)
    return lines
</t>
<t tx="ekr.20170617125213.1">def clean_all_headlines(self, parent):
    '''
    Clean all headlines in parent's tree by calling the language-specific
    clean_headline method.
    '''
    for p in parent.subtree():
        # Important: i.gen_ref does not know p when it calls
        # self.clean_headline.
        h = self.clean_headline(p.h, p=p)
        if h and h != p.h:
            p.h = h
</t>
<t tx="ekr.20170707072347.1">@cmd('beginning-of-line')
def beginningOfLine(self, event):
    """Move the cursor to the first character of the line."""
    self.moveWithinLineHelper(event, 'begin-line', extend=False)

@cmd('beginning-of-line-extend-selection')
def beginningOfLineExtendSelection(self, event):
    """
    Extend the selection by moving the cursor to the first character of the
    line.
    """
    self.moveWithinLineHelper(event, 'begin-line', extend=True)
</t>
<t tx="ekr.20170707072524.1">@cmd('end-of-line')
def endOfLine(self, event):
    """Move the cursor to the last character of the line."""
    self.moveWithinLineHelper(event, 'end-line', extend=False)

@cmd('end-of-line-extend-selection')
def endOfLineExtendSelection(self, event):
    """Extend the selection by moving the cursor to the last character of the line."""
    self.moveWithinLineHelper(event, 'end-line', extend=True)
</t>
<t tx="ekr.20170707072644.1">@cmd('start-of-line')
def startOfLine(self, event):
    """Move the cursor to first non-blank character of the line."""
    self.moveWithinLineHelper(event, 'start-line', extend=False)

@cmd('start-of-line-extend-selection')
def startOfLineExtendSelection(self, event):
    """
    Extend the selection by moving the cursor to first non-blank character
    of the line.
    """
    self.moveWithinLineHelper(event, 'start-line', extend=True)
</t>
<t tx="ekr.20170707072837.1">@cmd('finish-of-line')
def finishOfLine(self, event):
    """Move the cursor to the last character of the line."""
    self.moveWithinLineHelper(event, 'finish-line', extend=False)

@cmd('finish-of-line-extend-selection')
def finishOfLineExtendSelection(self, event):
    """Extend the selection by moving the cursor to the last character of the line."""
    self.moveWithinLineHelper(event, 'finish-line', extend=True)
</t>
<t tx="ekr.20170707093335.1">@cmd('pop-cursor')
def popCursor(self, event=None):
    """Restore the node, selection range and insert point from the stack."""
    c = self.c
    w = self.editWidget(event)
    if w and self.cursorStack:
        p, i, j, ins = self.cursorStack.pop()
        if c.positionExists(p):
            c.selectPosition(p)
            c.redraw()
            w.setSelectionRange(i, j, insert=ins)
            c.bodyWantsFocus()
        else:
            g.es('invalid position', c.p.h)
    elif not w:
        g.es('no stacked cursor', color='blue')

@cmd('push-cursor')
def pushCursor(self, event=None):
    """Push the selection range and insert point on the stack."""
    c = self.c
    w = self.editWidget(event)
    if w:
        p = c.p.copy()
        i, j = w.getSelectionRange()
        ins = w.getInsertPoint()
        self.cursorStack.append((p, i, j, ins),)
    else:
        g.es('cursor not pushed', color='blue')
</t>
<t tx="ekr.20170707160947.1">@cmd('forward-end-word')
def forwardEndWord(self, event):  # New in Leo 4.4.2
    """Move the cursor to the next word."""
    self.moveWordHelper(event, extend=False, forward=True, end=True)

@cmd('forward-end-word-extend-selection')
def forwardEndWordExtendSelection(self, event):  # New in Leo 4.4.2
    """Extend the selection by moving the cursor to the next word."""
    self.moveWordHelper(event, extend=True, forward=True, end=True)

@cmd('forward-word')
def forwardWord(self, event):
    """Move the cursor to the next word."""
    self.moveWordHelper(event, extend=False, forward=True)

@cmd('forward-word-extend-selection')
def forwardWordExtendSelection(self, event):
    """Extend the selection by moving the cursor to the end of the next word."""
    self.moveWordHelper(event, extend=True, forward=True)

@cmd('forward-word-smart')
def forwardWordSmart(self, event):
    """Move the cursor to the end of the current or the beginning of the next word."""
    self.moveWordHelper(event, extend=False, forward=True, smart=True)

@cmd('forward-word-smart-extend-selection')
def forwardWordSmartExtendSelection(self, event):
    """Extend the selection by moving the cursor to the end of the current
    or the beginning of the next word."""
    self.moveWordHelper(event, extend=True, forward=True, smart=True)
</t>
<t tx="ekr.20170806094320.15">def get_file_from_rev(self, rev, fn):
    """Get the file from the given rev, or the working directory if None."""
    path = g.os_path_finalize_join(self.repo_dir, fn)
    if not g.os_path_exists(path):
        return ''
    if rev:
        # Get the file using git.
        # Use the file name, not the path.
        command = f"git show {rev}:{fn}"
        lines = g.execGitCommand(command, self.repo_dir)
        s = ''.join(lines)
    else:
        try:
            with open(path, 'rb') as f:  # Was 'r'
                s = f.read()
        except Exception:
            g.es_print('Can not read', path)
            g.es_exception()
            s = ''
    return g.toUnicode(s).replace('\r', '')
</t>
<t tx="ekr.20170806094320.6">def diff_file(self, fn, directory=None, rev1='HEAD', rev2=''):
    """
    Create an outline describing the git diffs for fn.
    """
    # Common code.
    c = self.c
    if not self.set_directory(directory):
        return
    path = g.os_path_finalize_join(self.repo_dir, fn)  # #1781: bug fix.
    if not os.path.exists(path):
        g.trace('NOT FOUND', path)
        return
    s1 = self.get_file_from_rev(rev1, fn)
    s2 = self.get_file_from_rev(rev2, fn)
    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    diff_list = list(difflib.unified_diff(
        lines1,
        lines2,
        rev1 or 'uncommitted',
        rev2 or 'uncommitted',
    ))
    diff_list.insert(0, '@ignore\n@nosearch\n@language patch\n')
    self.file_node = self.create_file_node(diff_list, fn)
    # #1777: The file node will contain the entire added/deleted file.
    if not s1:
        self.file_node.h = f"Added: {self.file_node.h}"
        return
    if not s2:
        self.file_node.h = f"Deleted: {self.file_node.h}"
        return
    # Finish.
    c1 = c2 = None
    if fn.endswith('.leo'):
        c1 = self.make_leo_outline(fn, path, s1, rev1)
        c2 = self.make_leo_outline(fn, path, s2, rev2)
    else:
        root = self.find_file(fn)
        if c.looksLikeDerivedFile(path):
            c1 = self.make_at_file_outline(fn, s1, rev1)
            c2 = self.make_at_file_outline(fn, s2, rev2)
        elif root:
            c1 = self.make_at_clean_outline(fn, root, s1, rev1)
            c2 = self.make_at_clean_outline(fn, root, s2, rev2)
    if c1 and c2:
        self.make_diff_outlines(c1, c2, fn, rev1, rev2)
        self.file_node.b = (
            f"{self.file_node.b.rstrip()}\n"
            f"@language {c2.target_language}\n")
</t>
<t tx="ekr.20170806094320.9">def get_files(self, rev1, rev2):
    """Return a list of changed files."""
    command = f"git diff --name-only {(rev1 or '')} {(rev2 or '')}"
    files = [
        z.strip() for z in g.execGitCommand(command, self.repo_dir)
            if not z.strip().endswith(('.db', '.zip'))
                # #1781: Allow diffs of .leo files.
    ]
    return files
</t>
<t tx="ekr.20170811173924.1">@language python
import os
import subprocess
import sys
import time
win = sys.platform.startswith('win')
old_dir = g.os_path_abspath('.')
if win:
    new_dir = r'C:\leo.repo\leo-editor'
    path = r'C:\Users\edreamleo\Backup'
else:
    new_dir = '/home/edward/leo.repo/leo-editor'
    path = '/home/edward/Backup'
assert g.os_path_exists(new_dir), repr(new_dir)
assert g.os_path_exists(path), repr(path)
stamp = time.strftime("%Y%m%d-%H%M%S")
fn = g.os_path_finalize_join(path, f"leo-bundle-all-{stamp}")
bundle_command = 'git bundle create %s --all' % fn
print(bundle_command)
os.chdir(new_dir)
# os.system(bundle_command)
proc = subprocess.Popen(bundle_command, shell=True)
proc.wait()
os.chdir(old_dir)
print('done! wrote %s' % fn)
</t>
<t tx="ekr.20171031111403.1"></t>
<t tx="ekr.20171122055719.1">def declutter_style(arg, cmd):
    """Handle style options."""
    arg = c.styleSheetManager.expand_css_constants(arg).split()[0]
    if cmd == 'ICON':
        new_icons.append(arg)
    elif cmd == 'BG':
        item.setBackground(0, QtGui.QBrush(QtGui.QColor(arg)))
    elif cmd == 'FG':
        item.setForeground(0, QtGui.QBrush(QtGui.QColor(arg)))
    elif cmd == 'FONT':
        item.setFont(0, QtGui.QFont(arg))
    elif cmd == 'ITALIC':
        font = item.font(0)
        font.setItalic(bool(int(arg)))
        item.setFont(0, font)
    elif cmd == 'WEIGHT':
        arg = getattr(QtGui.QFont, arg, 75)
        font = item.font(0)
        font.setWeight(arg)
        item.setFont(0, font)
    elif cmd == 'PX':
        font = item.font(0)
        font.setPixelSize(int(arg))
        item.setFont(0, font)
    elif cmd == 'PT':
        font = item.font(0)
        font.setPointSize(int(arg))
        item.setFont(0, font)
</t>
<t tx="ekr.20171122064635.1">def declutter_replace(arg, cmd):
    """
    Execute cmd and return True if cmd is any replace command.
    """
    # pylint: disable=undefined-loop-variable
    if cmd == 'REPLACE':
        s = pattern.sub(arg, text)
        item.setText(0, s)
        return True
    if cmd == 'REPLACE-HEAD':
        s = text[: m.start()]
        item.setText(0, s.rstrip())
        return True
    if cmd == 'REPLACE-TAIL':
        s = text[m.end() :]
        item.setText(0, s.lstrip())
        return True
    if cmd == 'REPLACE-REST':
        s = text[:m.start] + text[m.end() :]
        item.setText(0, s.strip())
        return True
    return False
</t>
<t tx="ekr.20171123135625.18">@g.commander_command('convert-blanks')
def convertBlanks(self, event=None):
    """
    Convert *all* blanks to tabs in the selected node.
    Return True if the the p.b was changed.
    """
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    oldYview = w.getYScrollPosition()
    w.selectAllText()
    head, lines, tail, oldSel, oldYview = c.getBodyLines()
    #
    # Use the relative @tabwidth, not the global one.
    d = c.scanAllDirectives()
    tabWidth = d.get("tabwidth")
    if not tabWidth:
        return False
    #
    # Calculate the result.
    changed, result = False, []
    for line in lines:
        s = g.optimizeLeadingWhitespace(line, abs(tabWidth))  # Use positive width.
        if s != line:
            changed = True
        result.append(s)
    if not changed:
        return False
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    p.b = head + middle + tail  # Sets dirty and changed bits.
    w.setAllText(head + middle + tail)
    #
    # Select all text and set scroll position.
    w.selectAllText()
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Indent Region', bunch)
    return True
</t>
<t tx="ekr.20171123135625.19">@g.commander_command('convert-tabs')
def convertTabs(self, event=None):
    """Convert all tabs to blanks in the selected node."""
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Data...
    w.selectAllText()
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    # Use the relative @tabwidth, not the global one.
    theDict = c.scanAllDirectives()
    tabWidth = theDict.get("tabwidth")
    if not tabWidth:
        return False
    #
    # Calculate the result.
    changed,result = False, []
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line, 0, tabWidth)
        s = g.computeLeadingWhitespace(width, -abs(tabWidth)) + line[i:]
            # use negative width.
        if s != line: changed = True
        result.append(s)
    if not changed:
        return False
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    p.b = head + middle + tail  # Sets dirty and changed bits.
    w.setAllText(head + middle + tail)
    #
    # Calculate the proper selection range (i, j, ins).
    i = len(head)
    j = max(i, len(head) + len(middle) - 1)
    #
    # Set the selection range and scroll position.
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Add Comments', bunch)
    return True
</t>
<t tx="ekr.20171123135625.21">@g.commander_command('unindent-region')
def dedentBody(self, event=None):
    """Remove one tab's worth of indentation from all presently selected lines."""
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # Initial data.
    sel_1, sel_2 = w.getSelectionRange()
    tab_width = c.getTabWidth(c.p)
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    bunch = u.beforeChangeBody(p)
    #
    # Calculate the result.
    changed, result = False, []
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
        s = g.computeLeadingWhitespace(width - abs(tab_width), tab_width) + line[i:]
        if s != line:
            changed = True
        result.append(s)
    if not changed:
        return
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    all = head + middle + tail
    p.b = all # Sets dirty and changed bits.
    w.setAllText(all)
    #
    # Calculate the proper selection range (i, j, ins).
    if sel_1 == sel_2:
        line = result[0]
        ins, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
        i = j = len(head) + ins
    else:
        i = len(head)
        j = len(head) + len(middle)
        if middle.endswith('\n'): # #1742.
            j -= 1
    #
    # Set the selection range and scroll position.
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    u.afterChangeBody(p, 'Unindent Region', bunch)
</t>
<t tx="ekr.20171123135625.29">def getBodyLines(self):
    """
    Return (head, lines, tail, oldSel, oldYview).

    - head: string containg all the lines before the selected text (or the
      text before the insert point if no selection)
    - lines: list of lines containing the selected text
      (or the line containing the insert point if no selection)
    - after: string containing all lines after the selected text
      (or the text after the insert point if no  selection)
    - oldSel: tuple containing the old selection range, or None.
    - oldYview: int containing the old y-scroll value, or None.
    """
    c = self
    body = c.frame.body
    w = body.wrapper
    oldVview = w.getYScrollPosition()
    # Note: lines is the entire line containing the insert point if no selection.
    head, s, tail = body.getSelectionLines()
    lines = g.splitLines(s)  # Retain the newlines of each line.
    # Expand the selection.
    i = len(head)
    j = len(head) + len(s)
    oldSel = i, j
    return head, lines, tail, oldSel, oldVview  # string,list,string,tuple,int.
</t>
<t tx="ekr.20171123135625.30">@g.commander_command('always-indent-region')
def alwaysIndentBody(self, event=None):
    """
    The always-indent-region command indents each line of the selected body
    text. The @tabwidth directive in effect determines amount of
    indentation.
    """
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Initial data.
    sel_1, sel_2 = w.getSelectionRange()
    tab_width = c.getTabWidth(p)
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    #
    # Calculate the result.
    changed, result = False, []
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
        s = g.computeLeadingWhitespace(width + abs(tab_width), tab_width) + line[i:]
        if s != line:
            changed = True
        result.append(s)
    if not changed:
        return
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    all = head + middle + tail
    p.b = all # Sets dirty and changed bits.
    w.setAllText(all)
    #
    # Calculate the proper selection range (i, j, ins).
    if sel_1 == sel_2:
        line = result[0]
        i, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
        i = j = len(head) + i
    else:
        i = len(head)
        j = len(head) + len(middle)
        if middle.endswith('\n'):  # #1742.
            j -= 1
    #
    # Set the selection range and scroll position.
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Indent Region', bunch)

@g.commander_command('indent-region')
def indentBody(self, event=None):
    """
    The indent-region command indents each line of the selected body text.
    Unlike the always-indent-region command, this command inserts a tab
    (soft or hard) when there is no selected text.
    
    The @tabwidth directive in effect determines amount of indentation.
    """
    c, w = self, self.frame.body.wrapper
    # # 1739. Special case for a *plain* tab bound to indent-region.
    sel_1, sel_2 = w.getSelectionRange()
    if sel_1 == sel_2:
        char = getattr(event, 'char', None)
        stroke = getattr(event, 'stroke', None)
        if char == '\t' and stroke and stroke.isPlainKey():
            c.editCommands.selfInsertCommand(event)  # Handles undo.
            return
    c.alwaysIndentBody(event)
</t>
<t tx="ekr.20171123135625.34">@g.commander_command('add-comments')
def addComments(self, event=None):
    &lt;&lt; addComments docstring &gt;&gt;
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Make sure there is a selection.
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    if not lines:
        g.warning('no text selected')
        return
    #
    # The default language in effect at p.
    language = c.frame.body.colorizer.scanLanguageDirectives(p)
    if c.hasAmbiguousLanguage(p):
        language = c.getLanguageAtCursor(p, language)
    d1, d2, d3 = g.set_delims_from_language(language)
    d2 = d2 or ''; d3 = d3 or ''
    if d1:
        openDelim, closeDelim = d1 + ' ', ''
    else:
        openDelim, closeDelim = d2 + ' ', ' ' + d3
    #
    # Calculate the result.
    indent = c.config.getBool('indent-added-comments', default=True)
    result = []
    for line in lines:
        if line.strip():
            i = g.skip_ws(line, 0)
            if indent:
                s = line[i:].replace('\n', '')
                result.append(line[0:i] + openDelim + s + closeDelim + '\n')
            else:
                s = line.replace('\n', '')
                result.append(openDelim + s + closeDelim + '\n')
        else:
            result.append(line)
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    p.b = head + middle + tail  # Sets dirty and changed bits.
    w.setAllText(head + middle + tail)
    #
    # Calculate the proper selection range (i, j, ins).
    i = len(head)
    j = max(i, len(head) + len(middle) - 1)
    #
    # Set the selection range and scroll position.
    w.setSelectionRange(i, j, insert=j)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Add Comments', bunch)
</t>
<t tx="ekr.20171123135625.35">@pagewidth 50
"""
Converts all selected lines to comment lines using
the comment delimiters given by the applicable @language directive.

Inserts single-line comments if possible; inserts
block comments for languages like html that lack
single-line comments.

@bool indent_added_comments

If True (the default), inserts opening comment
delimiters just before the first non-whitespace
character of each line. Otherwise, inserts opening
comment delimiters at the start of each line.

*See also*: delete-comments.
"""
</t>
<t tx="ekr.20171123135625.36">@g.commander_command('delete-comments')
def deleteComments(self, event=None):
    &lt;&lt; deleteComments docstring &gt;&gt;
    c, p, u, w = self, self.p, self.undoer, self.frame.body.wrapper
    #
    # "Before" snapshot.
    bunch = u.beforeChangeBody(p)
    #
    # Initial data.
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    if not lines:
        g.warning('no text selected')
        return
    # The default language in effect at p.
    language = c.frame.body.colorizer.scanLanguageDirectives(p)
    if c.hasAmbiguousLanguage(p):
        language = c.getLanguageAtCursor(p, language)
    d1, d2, d3 = g.set_delims_from_language(language)
    #
    # Calculate the result.
    changed, result = False, []
    if d1:
        # Remove the single-line comment delim in front of each line
        d1b = d1 + ' '
        n1, n1b = len(d1), len(d1b)
        for s in lines:
            i = g.skip_ws(s, 0)
            if g.match(s, i, d1b):
                result.append(s[:i] + s[i + n1b :])
                changed = True
            elif g.match(s, i, d1):
                result.append(s[:i] + s[i + n1 :])
                changed = True
            else:
                result.append(s)
    else:
        # Remove the block comment delimiters from each line.
        n2, n3 = len(d2), len(d3)
        for s in lines:
            i = g.skip_ws(s, 0)
            j = s.find(d3, i + n2)
            if g.match(s, i, d2) and j &gt; -1:
                first = i + n2
                if g.match(s, first, ' '):
                    first += 1
                last = j
                if g.match(s, last - 1, ' '):
                    last -= 1
                result.append(s[:i] + s[first:last] + s[j + n3 :])
                changed = True
            else:
                result.append(s)
    if not changed:
        return
    #
    # Set p.b and w's text first.
    middle = ''.join(result)
    p.b = head + middle + tail  # Sets dirty and changed bits.
    w.setAllText(head + middle + tail)
    #
    # Set the selection range and scroll position.
    i = len(head)
    j = ins = max(i, len(head) + len(middle) - 1)
    w.setSelectionRange(i, j, insert=ins)
    w.setYScrollPosition(oldYview)
    #
    # "after" snapshot.
    u.afterChangeBody(p, 'Indent Region', bunch)
</t>
<t tx="ekr.20171123135625.37">@pagewidth 50
"""
Removes one level of comment delimiters from all
selected lines.  The applicable @language directive
determines the comment delimiters to be removed.

Removes single-line comments if possible; removes
block comments for languages like html that lack
single-line comments.

*See also*: add-comments.
"""
</t>
<t tx="ekr.20171123135625.38">@g.commander_command('insert-body-time')
def insertBodyTime(self, event=None):
    """Insert a time/date stamp at the cursor."""
    c = self; undoType = 'Insert Body Time'
    w = c.frame.body.wrapper
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    oldSel = w.getSelectionRange()
    w.deleteTextSelection()
    s = self.getTime(body=True)
    i = w.getInsertPoint()
    w.insert(i, s)
    c.frame.body.onBodyChanged(undoType, oldSel=oldSel)
</t>
<t tx="ekr.20171123135625.47">def rp_reformat(c, head, oldSel, oldYview, original, result, tail, undoType):
    """Reformat the body and update the selection."""
    p, u, w = c.p, c.undoer, c.frame.body.wrapper
    s = head + result + tail
    changed = original != s
    bunch = u.beforeChangeBody(p)
    if changed:
        w.setAllText(s)  # Destroys coloring.
    #
    # #1748: Always advance to the next paragraph.
    i = len(head)
    j = max(i, len(head) + len(result) - 1)
    ins = j + 1
    while ins &lt; len(s):
        i, j = g.getLine(s, ins)
        line = s[i:j]
        # It's annoying, imo, to treat @ lines differently.
        if line.isspace():
            ins = j + 1
        else:
            ins = i
            break
    ins = min(ins, len(s))
    w.setSelectionRange(ins, ins, insert=ins)
    #
    # Show more lines, if they exist.
    k = g.see_more_lines(s, ins, 4)
    p.v.insertSpot = ins
    w.see(k)  # New in 6.4. w.see works!
    if not changed:
        return
    #
    # Finish.
    p.v.b = s  # p.b would cause a redraw.
    u.afterChangeBody(p, undoType, bunch)
    w.setXScrollPosition(0)  # Never scroll horizontally.
</t>
<t tx="ekr.20171123135625.50">def unreformat(c, head, oldSel, oldYview, original, result, tail, undoType):
    """unformat the body and update the selection."""
    body, w = c.frame.body, c.frame.body.wrapper
    s = head + result + tail
    ins = max(len(head), len(head) + len(result) - 1)
    w.setAllText(s)  # Destroys coloring.
    changed = original != s
    if changed:
        body.onBodyChanged(undoType, oldSel=oldSel)
    # Advance to the next paragraph.
    ins += 1  # Move past the selection.
    while ins &lt; len(s):
        i, j = g.getLine(s, ins)
        line = s[i:j]
        if line.isspace():
            ins = j + 1
        else:
            ins = i
            break
    c.recolor()  # Required.
    w.setSelectionRange(ins, ins, insert=ins)
    # More useful than for reformat-paragraph.
    w.see(ins)
    # Make sure we never scroll horizontally.
    w.setXScrollPosition(0)
</t>
<t tx="ekr.20171124043747.1">def registerCommandShortcut(self, commandName, func, pane, shortcut):
    """
    Register a shortcut for the a command.
    
    **Important**: Bindings created here from plugins can not be overridden.
    This includes @command and @button bindings created by mod_scripting.py.
    """
    c, k = self.c, self
    is_local = c.shortFileName() not in ('myLeoSettings.leo', 'leoSettings.leo')
    assert not g.isStroke(shortcut)
    if shortcut:
        stroke = g.KeyStroke(binding=shortcut) if shortcut else None
    elif commandName.lower() == 'shortcut':  # Causes problems.
        stroke = None
    elif is_local:
        # 327: Don't get defaults when handling a local file.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk, aList = c.config.getShortcut(commandName)
        for bi in aList:
            if bi.stroke and not bi.pane.endswith('-mode'):
                stroke = bi.stroke
                pane = bi.pane  # 2015/05/11.
                break
    if stroke:
        k.bindKey(pane, stroke, func, commandName, tag='register-command')
            # Must be a stroke.
        k.makeMasterGuiBinding(stroke)  # Must be a stroke.
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict[key] = c.commandsDict.get(commandName)
                    break
</t>
<t tx="ekr.20180210092235.1">def backup_helper(self,
    base_dir=None,
    env_key='LEO_BACKUP',
    sub_dir=None,
    use_git_prefix=True,
):
    """
    A helper for scripts that back up a .leo file.
    Use os.environ[env_key] as the base_dir only if base_dir is not given.
    Backup to base_dir or join(base_dir, sub_dir).
    """
    c = self
    old_cwd = os.getcwd()
    join = g.os_path_finalize_join
    if not base_dir:
        if env_key:
            try:
                base_dir = os.environ[env_key]
            except KeyError:
                print(f"No environment var: {env_key}")
                base_dir = None
    if base_dir and g.os_path_exists(base_dir):
        if use_git_prefix:
            git_branch, junk = g.gitInfo()
        else:
            git_branch = None
        theDir, fn = g.os_path_split(c.fileName())
        backup_dir = join(base_dir, sub_dir) if sub_dir else base_dir
        path = join(backup_dir, fn)
        if g.os_path_exists(backup_dir):
            written_fn = c.backup(
                path,
                prefix=git_branch,
                silent=True,
                useTimeStamp=True,
            )
            g.es_print(f"wrote: {written_fn}")
        else:
            g.es_print(f"backup_dir not found: {backup_dir!r}")
    else:
        g.es_print(f"base_dir not found: {base_dir!r}")
    os.chdir(old_cwd)
</t>
<t tx="ekr.20180225010644.1">@nobeautify</t>
<t tx="ekr.20180225010707.1"></t>
<t tx="ekr.20180225010743.1">@nosearch</t>
<t tx="ekr.20180225010850.1"></t>
<t tx="ekr.20180225010913.1"></t>
<t tx="ekr.20180312150559.1">@nobeautify

def addOptionsToParser(self, parser, trace_m):
    
    add = parser.add_option
    
    def add_bool(option, help, dest=None):
        add(option, action='store_true', dest=dest, help=help)

    def add_other(option, help, dest=None, m=None):
        add(option, dest=dest, help=help, metavar=m)

    add_bool('--diff',          'use Leo as an external git diff')
    add_bool('--fullscreen',    'start fullscreen')
    add_bool('--ipython',       'enable ipython support')
    add_bool('--fail-fast',     'stop unit tests after the first failure')
    add_other('--gui',          'gui to use (qt/console/null)')
    add_bool('--listen-to-log', 'start log_listener.py on startup')
    add_other('--load-type',    '@&lt;file&gt; type for non-outlines', m='TYPE')
    add_bool('--maximized',     'start maximized')
    add_bool('--minimized',     'start minimized')
    add_bool('--no-plugins',    'disable all plugins')
    add_bool('--no-splash',     'disable the splash screen')
    add_other('--screen-shot',  'take a screen shot and then exit', m='PATH')
    add_other('--script',       'execute a script and then exit', m="PATH")
    add_bool('--script-window', 'execute script using default gui')
    add_other('--select',       'headline or gnx of node to select', m='ID')
    add_bool('--silent',        'disable all log messages')
    add_other('--theme',        'use the named theme file', m='NAME')
    add_other('--trace',        'add one or more strings to g.app.debug', m=trace_m)
    add_other('--trace-binding', 'trace commands bound to a key', m='KEY')
    add_other('--trace-setting', 'trace where named setting is set', m="NAME")
    add_other('--window-size',  'initial window size (height x width)', m='SIZE')
    add_other('--window-spot',  'initial window position (top x left)', m='SPOT')
    # Multiple bool values.
    add('-v', '--version', action='store_true',
        help='print version number and exit')
</t>
<t tx="ekr.20180312150805.1">def doGuiOption(self, options):
    gui = options.gui
    if gui:
        gui = gui.lower()
        # #1171: retire non-tabbed qt gui.
        if gui in ('qt', 'qttabs'):
            gui = 'qt'  # For compatibilty with g.UiTypeException
        elif gui.startswith('browser'):
            pass
        elif gui in ('console', 'curses', 'text', 'null'):
            pass
        else:
            print(f"scanOptions: unknown gui: {gui}.  Using qt gui")
            gui = 'qt'
    else:
        gui = 'qt'
    assert gui
    assert gui != 'qttabs'  # For compatibilty with g.UiTypeException
    g.app.qt_use_tabs = gui == 'qt'
    g.app.guiArgName = gui
    return gui
</t>
<t tx="ekr.20180312151544.1">def doSimpleOptions(self, options, trace_m):
    """These args just set g.app ivars."""
    # --fail-fast
    g.app.failFast = options.fail_fast
    # --fullscreen
    g.app.start_fullscreen = options.fullscreen
    # --git-diff
    g.app.diff = options.diff
    # --listen-to-log
    g.app.listen_to_log_flag = options.listen_to_log
    # --ipython
    g.app.useIpython = options.ipython
    # --maximized
    g.app.start_maximized = options.maximized
    # --minimized
    g.app.start_minimized = options.minimized
    # --no-plugins
    if options.no_plugins:
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = not options.no_splash and not options.minimized
    # --silent
    g.app.silentMode = options.silent
    # --trace=...
    valid = trace_m.replace(' ', '').replace('\n', '').split(',')
    # g.trace('valid', valid)
    if options.trace:
        values = options.trace.lstrip('(').lstrip('[').rstrip(')').rstrip(']')
        for val in values.split(','):
            if val in valid:
                g.app.debug.append(val)
            else:
                g.es_print(f"unknown --trace value: {val}")
    #
    # These are not bool options.
    # --trace-binding
    g.app.trace_binding = options.trace_binding
        # g.app.config does not exist yet.
    #
    # --trace-setting=setting
    g.app.trace_setting = options.trace_setting
        # g.app.config does not exist yet.
</t>
<t tx="ekr.20180312152329.1">def doLoadTypeOption(self, options):

    s = options.load_type
    s = s.lower() if s else 'edit'
    return '@' + s
</t>
<t tx="ekr.20180312152609.1">def doScreenShotOption(self, options):

    # --screen-shot=fn
    s = options.screen_shot
    if s:
        s = s.strip('"')
    return s
</t>
<t tx="ekr.20180312153008.1">def doScriptOption(self, options, parser):

    # --script
    script = options.script
    if script:
        # #1090: use cwd, not g.app.loadDir, to find scripts.
        fn = g.os_path_finalize_join(os.getcwd(), script)
        script, e = g.readFileIntoString(fn, kind='script:', verbose=False)
        if not script:
            print(f"script not found: {fn}")
            sys.exit(1)
    else:
        script = None
    return script
</t>
<t tx="ekr.20180312154839.1">def doWindowSizeOption(self, options):

    # --window-size
    windowSize = options.window_size
    if windowSize:
        try:
            h, w = windowSize.split('x')
            windowSize = int(h), int(w)
        except ValueError:
            windowSize = None
            print('scanOptions: bad --window-size:', windowSize)
    return windowSize
</t>
<t tx="ekr.20180318133620.1">def computeThemeFilePath(self):
    """
    Return the absolute path to the theme .leo file, resolved using the search order for themes.
    
    1. Use the --theme command-line option if it exists.
    
    2. Otherwise, preload the first .leo file.
       Load the file given by @string theme-name setting.
       
    3. Finally, look up the @string theme-name in the already-loaded, myLeoSettings.leo.
       Load the file if setting exists.  Otherwise return None.
    """
    trace = 'themes' in g.app.db
    lm = self
    resolve = self.resolve_theme_path
    #
    # Step 1: Use the --theme command-line options if it exists
    path = resolve(lm.options.get('theme_path'), tag='--theme')
    if path:
        # Caller (LM.readGlobalSettingsFiles) sets lm.theme_path
        if trace: g.trace('--theme:', path)
        return path
    #
    # Step 2: look for the @string theme-name setting in the first loaded file.
    path = lm.files and lm.files[0]
    if path and g.os_path_exists(path):
        # Tricky: we must call lm.computeLocalSettings *here*.
        theme_c = lm.openSettingsFile(path)
        if theme_c:
            settings_d, junk_shortcuts_d = lm.computeLocalSettings(
                c=theme_c,
                settings_d=lm.globalSettingsDict,
                bindings_d=lm.globalBindingsDict,
                localFlag=False,
            )
            setting = settings_d.get_string_setting('theme-name')
            if setting:
                tag = theme_c.shortFileName()
                path = resolve(setting, tag=tag)
                if path:
                    # Caller (LM.readGlobalSettingsFiles) sets lm.theme_path
                    if trace: g.trace(f"First loaded file", theme_c.shortFileName(), path)
                    return path
    #
    # Step 3: use the @string theme-name setting in myLeoSettings.leo.
    # Note: the setting should *never* appear in leoSettings.leo!
    setting = lm.globalSettingsDict.get_string_setting('theme-name')
    tag = 'myLeoSettings.leo'
    path = resolve(setting, tag=tag)
    if trace: g.trace(f"myLeoSettings.leo", path)
    return path
</t>
<t tx="ekr.20180321124503.1">def resolve_theme_path(self, fn, tag):
    """Search theme directories for the given .leo file."""
    if not fn or fn.lower().strip() == 'none':
        return None
    if not fn.endswith('.leo'):
        fn += '.leo'
    for directory in self.computeThemeDirectories():
        path = g.os_path_join(directory, fn)
            # Normalizes slashes, etc.
        if g.os_path_exists(path):
            return path
    print(f"theme .leo file not found: {fn}")
    return None
</t>
<t tx="ekr.20180324065741.1">"""Copy the selected text to the next node."""
w = c.frame.body.wrapper
s = w.getSelectedText()
if s.strip():
    w.deleteTextSelection()
    c.p.b = w.getAllText()
    w.setInsertPoint(0)
    p = c.insertHeadline()
    c.selectPosition(p)
    p.b = s
    c.editHeadline()
else:
    g.es_print('no text selected')
</t>
<t tx="ekr.20180410074238.1">def insert_toc(c, kind):
    """Insert a table of contents at the cursor."""
    undoType = f"Insert {kind.capitalize()} TOC"
    w = c.frame.body.wrapper
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    oldSel = w.getSelectionRange()
    w.deleteTextSelection()
    s = make_toc(c, kind=kind, root=c.p)
    i = w.getInsertPoint()
    w.insert(i, s)
    c.frame.body.onBodyChanged(undoType, oldSel=oldSel)
</t>
<t tx="ekr.20180413180751.2">def doNonKeyEvent(self, event, obj):
    """Handle all non-key event. """
    c = self.c
    ev = QtCore.QEvent
    eventType = event.type()
    if eventType == ev.WindowActivate:
        g.app.gui.onActivateEvent(event, c, obj, self.tag)
    elif eventType == ev.WindowDeactivate:
        g.app.gui.onDeactivateEvent(event, c, obj, self.tag)
    elif eventType == ev.FocusIn:
        if self.tag == 'body':
            c.frame.body.onFocusIn(obj)
        if c.frame and c.frame.top and obj is c.frame.top.lineEdit:
            if c.k.getStateKind() == 'getArg':
                c.frame.top.lineEdit.restore_selection()
    elif eventType == ev.FocusOut and self.tag == 'body':
        c.frame.body.onFocusOut(obj)
    return eventType not in (ev.ShortcutOverride, ev.KeyPress, ev.KeyRelease)
        # Return True unless we have a key event.
</t>
<t tx="ekr.20180413180751.3">def shouldIgnoreKeyEvent(self, event, obj):
    """
    Return True if we should ignore the key event.
    
    Alas, QLineEdit *only* generates ev.KeyRelease on Windows, Ubuntu,
    so the following hack is required.
    """
    c = self.c
    ev = QtCore.QEvent
    t = event.type()
    isEditWidget = (obj == c.frame.tree.edit_widget(c.p))
    if isEditWidget:
        return t != ev.KeyRelease
            # QLineEdit: ignore all key events except keyRelease events.
    if t == ev.KeyPress:
        return False  # Never ignore KeyPress events.
    # This doesn't work. Two shortcut-override events are generated!
        # if t == ev.ShortcutOverride and event.text():
            # return False # Don't ignore shortcut overrides with a real value.
    return True  # Ignore everything else.
</t>
<t tx="ekr.20180417161548.1">def doLateTweaks(self, binding, ch):
    """Make final tweaks. g.KeyStroke does other tweaks later."""
    #
    # These are needed  because ch is separate from binding.
    if ch == '\r':
        ch = '\n'
    if binding == 'Escape':
        ch = 'Escape'
    #
    # Adjust the case of the binding string (for the minibuffer).
    if len(ch) == 1 and len(binding) == 1 and ch.isalpha() and binding.isalpha():
        if ch != binding:
            binding = ch
    return binding, ch
</t>
<t tx="ekr.20180418023827.1">def doDemo(self, event):
    """
    Support the demo.py plugin.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    stroke = event.stroke
    demo = getattr(g.app, 'demo', None)
    if not demo:
        return False
    #
    # Shortcut everything so that demo-next or demo-prev won't alter of our ivars.
    if k.demoNextKey and stroke == k.demoNextKey:
        if demo.trace:
            g.trace('demo-next', stroke)
        demo.next_command()
        return True
    if k.demoPrevKey and stroke == k.demoPrevKey:
        if demo.trace:
            g.trace('demo-prev', stroke)
        demo.prev_command()
        return True
    return False
</t>
<t tx="ekr.20180418024449.1">def doKeyboardQuit(self, event):
    """
    A helper for k.masterKeyHandler: Handle keyboard-quit logic.
    
    return True if k.masterKeyHandler should return.
    """
    c, k = self.c, self
    stroke = getattr(event, 'stroke', None)
    if k.abortAllModesKey and stroke and stroke == k.abortAllModesKey:
        if getattr(c, 'screenCastController', None):
            c.screenCastController.quit()
        c.doCommandByName('keyboard-quit', event)
        return True
    return False
</t>
<t tx="ekr.20180418025241.1">def doVim(self, event):
    """
    Handle vim mode.
    Return True if k.masterKeyHandler should return.
    """
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    c = self.c
    if c.vim_mode and c.vimCommands:
        # The "acceptance methods" in leoVim.py return True
        # if vim node has completely handled the key.
        # Otherwise, processing in k.masterKeyHandler continues.
        ok = c.vimCommands.do_key(event)
        if trace: g.trace('do_key returns', ok, repr(event and event.stroke))
        return ok
    return False
</t>
<t tx="ekr.20180418031118.1">def isSpecialKey(self, event):
    """Return True if char is a special key."""
    if not event:
        # An empty event is not an error.
        return False
    # Fix #917.
    if len(event.char) &gt; 1 and not event.stroke.s:
        # stroke.s was cleared, but not event.char.
        return True
    return event.char in g.app.gui.ignoreChars
</t>
<t tx="ekr.20180418031417.1">def traceVars(self, event):

    trace = False and not g.unitTesting
    traceGC = False
    verbose = False
    k = self
    if not trace:
        return
    if traceGC:
        g.printNewObjects('masterKey 1')
    if verbose:
        char = event.char
        state = k.state.kind
        stroke = event.stroke
        g.trace(
            f"stroke: {stroke!r}, "
            f"char: {char!r}, "
            f"state: {state}, "
            f"state2: {k.unboundKeyAction}")
</t>
<t tx="ekr.20180418033838.1">def doBinding(self, event):
    """
    Attempt to find a binding for the event's stroke.
    If found, execute the command and return True
    Otherwise, return False
    """
    trace = 'keys' in g.app.debug
    c, k = self.c, self
    #
    # Experimental special case:
    # Inserting a '.' always invokes the auto-completer.
    # The auto-completer just inserts a '.' if it isn't enabled.
    stroke = event.stroke
    if (
        stroke.s == '.'
        and k.isPlainKey(stroke)
        and self.unboundKeyAction in ('insert', 'overwrite')
    ):
        c.doCommandByName('auto-complete', event)
        return True
    #
    # Use getPaneBindings for *all* keys.
    bi = k.getPaneBinding(event)
    #
    # #327: Ignore killed bindings.
    if bi and bi.commandName in k.killedBindings:
        return False  
    #
    # Execute the command if the binding exists.
    if bi:
        # A superb trace. !s gives shorter trace.
        if trace: g.trace(f"{event.stroke!s} {bi.commandName}")
        c.doCommandByName(bi.commandName, event)
        return True
    #
    # No binding exists.
    return False
</t>
<t tx="ekr.20180418034305.1">def setEventWidget(self, event):
    """
    A hack: redirect the event to the text part of the log.
    """
    c = self.c
    w = event.widget
    w_name = c.widget_name(w)
    if w_name.startswith('log'):
        event.widget = c.frame.log.logCtrl
</t>
<t tx="ekr.20180418040158.1">def checkKeyEvent(self, event):
    """Perform sanity checks on the incoming event."""
    # These assert's should be safe, because eventFilter
    # calls k.masterKeyHandler inside a try/except block.
    c = self.c
    assert event is not None
    c.check_event(event)
    assert hasattr(event, 'char')
    assert hasattr(event, 'stroke')
    if not hasattr(event, 'widget'):
        event.widget = None
    assert g.isStrokeOrNone(event.stroke)
    if event:
        assert event.stroke.s not in g.app.gui.ignoreChars, repr(event.stroke.s)
            # A continuous unit test, better than "@test k.isPlainKey".
</t>
<t tx="ekr.20180418105228.1">def getBindingHelper(self, key, name, stroke, w):
    """Find a binding for the widget with the given name."""
    c, k = self.c, self
    # trace = 'keys' in g.app.debug and 'verbose' in g.app.debug
    #
    # Return if the pane's name doesn't match the event's widget.
    state = k.unboundKeyAction
    w_name = c.widget_name(w)
    pane_matches = (
        name and w_name.startswith(name) or
        key in ('command', 'insert', 'overwrite') and state == key or
        key in ('text', 'all') and g.isTextWrapper(w) or
        key in ('button', 'all')
    )
    if not pane_matches:
        return None
    #
    # Return if there is no binding at all.
    d = k.masterBindingsDict.get(key, {})
    if not d:
        return None
    bi = d.get(stroke)
    if not bi:
        return None
    #
    # Ignore previous/next-line commands while editing headlines.
    if (
        key == 'text' and
        name == 'head' and
        bi.commandName in ('previous-line', 'next-line')
    ):
        return None
    #
    # The binding has been found.
    return bi
</t>
<t tx="ekr.20180418114300.1">def handleMinibufferHelper(self, event, pane, state, stroke):
    """
    Execute a pane binding in the minibuffer.
    Return 'continue', 'ignore', 'found'
    """
    c, k = self.c, self
    d = k.masterBindingsDict.get(pane)
    if not d:
        return 'continue'
    bi = d.get(stroke)
    if not bi:
        return 'continue'
    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
    # Ignore the replace-string command in the minibuffer.
    if bi.commandName == 'replace-string' and state == 'getArg':
        return 'ignore'
    # Execute this command.
    if bi.commandName not in k.singleLineCommandList:
        k.keyboardQuit()
    else:
        c.minibufferWantsFocus()
        c.doCommandByName(bi.commandName, event)
    # Careful: the command could exit.
    if c.exists and not k.silentMode:
        # Use the state *after* executing the command.
        if k.state.kind:
            c.minibufferWantsFocus()
        else:
            c.bodyWantsFocus()
    return 'found'
</t>
<t tx="ekr.20180419154543.1">def doAltTweaks(self, actual_ch, keynum, mods, toString):
    """Turn AltGr and some Alt-Ctrl keys into plain keys."""
    qt = QtCore.Qt

    def removeAltCtrl(mods):
        for mod in ('Alt', 'Control'):
            if mod in mods:
                mods.remove(mod)
        return mods

    #
    # Remove Alt, Ctrl for AltGr keys.
    # See https://en.wikipedia.org/wiki/AltGr_key

    if keynum == qt.Key_AltGr:
        return removeAltCtrl(mods)
    #
    # Never alter complex characters.
    if len(actual_ch) != 1:
        return mods
    #
    # #1563: A hack for German keyboards:
    #        Remove *plain* Shift modifier for colon and semicolon.
    #        https://en.m.wikipedia.org/wiki/German_keyboard_layout
    if (
        self.use_german_keyboard
        and actual_ch in ":;" and 'Shift' in mods
        and 'Alt' not in mods and 'Control' not in mods
    ):
        mods.remove('Shift')
        # g.trace('mods', mods, 'ch', repr(actual_ch))
    #
    # Handle Alt-Ctrl modifiers for chars whose that are not ascii.
    # Testing: Alt-Ctrl-E is ''.
    if ord(actual_ch) &gt; 127 and 'Alt' in mods and 'Control' in mods:
        return removeAltCtrl(mods)
    return mods
</t>
<t tx="ekr.20180419160958.1">def doMacTweaks(self, actual_ch, ch, mods):
    """Replace MacOS Alt characters."""
    if not g.isMac:
        return actual_ch, ch, mods
    if ch == 'Backspace':
        # On the Mac, the reported char can be DEL (7F)
        return '\b', ch, mods
    if len(mods) == 1 and mods[0] == 'Alt':
        # Patch provided by resi147.
        # See the thread: special characters in MacOSX, like '@'.
        mac_d = {
            '/': '\\',
            '5': '[',
            '6': ']',
            '7': '|',
            '8': '{',
            '9': '}',
            'e': '',
            'l': '@',
        }
        if ch.lower() in mac_d:
            # Ignore the case.
            actual_ch = ch = g.checkUnicode(mac_d.get(ch.lower()))
            mods = []
    return actual_ch, ch, mods
</t>
<t tx="ekr.20180504191650.34"></t>
<t tx="ekr.20180504191650.36"></t>
<t tx="ekr.20180504191650.42"></t>
<t tx="ekr.20180504191650.68"></t>
<t tx="ekr.20180504192522.1"></t>
<t tx="ekr.20180507212821.1">def diff_two_revs(self, directory=None, rev1='HEAD', rev2=''):
    """
    Create an outline describing the git diffs for all files changed
    between rev1 and rev2.
    """
    c = self.c
    if not self.set_directory(directory):
        return
    # Get list of changed files.
    files = self.get_files(rev1, rev2)
    n = len(files)
    message = f"diffing {n} file{g.plural(n)}"
    if n &gt; 5:
        message += ". This may take awhile..."
    g.es_print(message)
    # Create the root node.
    self.root = c.lastTopLevel().insertAfter()
    self.root.h = f"git diff revs: {rev1} {rev2}"
    self.root.b = '@ignore\n@nosearch\n'
    # Create diffs of all files.
    for fn in files:
        self.diff_file(fn=fn, rev1=rev1, rev2=rev2)
    self.finish()
</t>
<t tx="ekr.20180519111302.1">def get_jedi_completions(self, prefix):

    c = self.c
    w = c.frame.body.wrapper
    i = w.getInsertPoint()
    p = c.p
    body_s = p.b
    #
    # Get the entire source for jedi.
    t1 = time.process_time()
    goto = gotoCommands.GoToCommands(c)
    root, fileName = goto.find_root(p)
    if root:
        source = goto.get_external_file_with_sentinels(root=root or p)
        n0 = goto.find_node_start(p=p, s=source)
        if n0 is None: n0 = 0
    else:
        source = body_s
        n0 = 0
    t2 = time.process_time()
    #
    # Get local line
    lines = g.splitLines(body_s)
    row, column = g.convertPythonIndexToRowCol(body_s, i)
    if row &gt;= len(lines):  # 2020/11/27
        return []
    line = lines[row]
    #
    # Find the global line, and compute offsets.
    source_lines = g.splitLines(source)
    for jedi_line, g_line in enumerate(source_lines[n0:]):
        if line.lstrip() == g_line.lstrip():
            # Adjust the column.
            indent1 = len(line) - len(line.lstrip())
            indent2 = len(g_line) - len(g_line.lstrip())
            if indent2 &gt;= indent1:
                local_column = column  # For traces.
                column += abs(indent2 - indent1)
                break
    else:
        completions = None
        jedi_line, indent1, indent2 = None, None, None
        g.printObj(source_lines[n0 - 1 : n0 + 30])
        print(f"can not happen: not found: {line!r}")
    #
    # Get the jedi completions.
    if jedi_line is not None:
        import jedi
        try:
            script = jedi.Script(
                source=source,
                line=1 + n0 + jedi_line,
                column=column,
                path=g.shortFileName(fileName),
                # encoding='utf-8',
                # sys_path=None):
            )
            completions = script.completions()
            t3 = time.process_time()
        except ValueError:
            t3 = time.process_time()
            completions = None
            g.printObj(source_lines[n0 - 1 : n0 + 30])
            print('ERROR', p.h)
    if not completions:
        return []
    # May be used in traces below.
    assert t3 &gt;= t2 &gt;= t1
    assert local_column is not None
    completions = [z.name for z in completions]
    completions = [self.add_prefix(prefix, z) for z in completions]
    # Retain these for now...
        # g.printObj(completions[:5])
        # head = line[:local_column]
        # ch = line[local_column:local_column+1]
        # g.trace(len(completions), repr(ch), head.strip())
    return completions
</t>
<t tx="ekr.20180524130023.1">file_pattern = re.compile(r'^(([@])+(auto|clean|edit|file|nosent))')
    # Note: this method is never called for @clean trees.

def add_class_names(self, p):
    '''
    Add class names to headlines for all descendant nodes.

    Called only when @bool add-context-to-headlines is True.
    '''
    if g.app.unitTesting:
        return # Don't changes the expected headlines.
    after, fn, class_name = None, None, None
    for p in p.self_and_subtree():
        # Part 1: update the status.
        m = self.file_pattern.match(p.h)
        if m:
            prefix = m.group(1)
            fn = g.shortFileName(p.h[len(prefix):].strip())
            after, class_name = None, None
            continue
        if p.h.startswith('@path '):
            after, fn, class_name = None, None, None
        elif p.h.startswith('class '):
            class_name = p.h[5:].strip()
            if class_name:
                after = p.nodeAfterTree()
                continue
        elif p == after:
            after, class_name = None, None
        # Part 2: update the headline.
        if class_name:
            if not p.h.startswith(class_name):
                p.h = '%s.%s' % (class_name, p.h)
        elif fn and self.add_file_context:
            tag = ' (%s)' % fn
            if not p.h.endswith(tag):
                p.h += tag
</t>
<t tx="ekr.20180524173510.1"></t>
<t tx="ekr.20180526211127.1">def add_prefix(self, prefix, s):
    """A hack to match the callers expectations."""
    if prefix.find('.') &gt; -1:
        aList = prefix.split('.')
        prefix = '.'.join(aList[:-1]) + '.'
    return s if s.startswith(prefix) else prefix + s
</t>
<t tx="ekr.20180602062323.7"># #1510: https://en.wikipedia.org/wiki/Valid_characters_in_XML.
translate_table = {z: None for z in range(20) if chr(z) not in '\t\r\n'}

def readWithElementTree(self, path, s):

    contents = g.toUnicode(s)
    contents = contents.translate(self.translate_table)
        # Fix #1036 and #1046.
    try:
        xroot = ElementTree.fromstring(contents)
    except Exception as e:
        # #970: Just report failure here.
        if path:
            message = f"bad .leo file: {g.shortFileName(path)}"
        else:
            message = 'The clipboard is not a vaild .leo file'
        g.es_print('\n' + message, color='red')
        g.es_print(g.toUnicode(e))
        print('')
        # #1510: Return a tuple.
        return None, None
    g_element = xroot.find('globals')
    v_elements = xroot.find('vnodes')
    t_elements = xroot.find('tnodes')
    gnx2body, gnx2ua = self.scanTnodes(t_elements)
    hidden_v = self.scanVnodes(gnx2body, self.gnx2vnode, gnx2ua, v_elements)
    self.handleBits()
    return hidden_v, g_element
</t>
<t tx="ekr.20180602062323.8">def scanTnodes(self, t_elements):

    gnx2body, gnx2ua = {}, defaultdict(dict)
    for e in t_elements:
        # First, find the gnx.
        gnx = e.attrib['tx']
        gnx2body[gnx] = e.text or ''
        # Next, scan for uA's for this gnx.
        for key, val in e.attrib.items():
            if key != 'tx':
                gnx2ua[gnx][key] = self.resolveUa(key, val)
    return gnx2body, gnx2ua
</t>
<t tx="ekr.20180602062323.9">def scanVnodes(self, gnx2body, gnx2vnode, gnx2ua, v_elements):

    c, fc = self.c, self.c.fileCommands
    &lt;&lt; define v_element_visitor &gt;&gt;
    #
    # Create the hidden root vnode.

    gnx = 'hidden-root-vnode-gnx'
    hidden_v = leoNodes.VNode(context=c, gnx=gnx)
    hidden_v._headString = '&lt;hidden root vnode&gt;'
    gnx2vnode[gnx] = hidden_v
    #
    # Traverse the tree of v elements.
    v_element_visitor(v_elements, hidden_v)
    return hidden_v
</t>
<t tx="ekr.20180604110143.1">def readFile(self, theFile, path):
    """Read the file, change splitter ratiors, and return its hidden vnode."""
    s = theFile.read()
    v, g_element = self.readWithElementTree(path, s)
    if not v:  # #1510.
        return None
    self.scanGlobals(g_element)
        # Fix #1047: only this method changes splitter sizes.
    #
    # Fix bug #1111: ensure that all outlines have at least one node.
    if not v.children:
        new_vnode = leoNodes.VNode(context=self.c)
        new_vnode.h = 'newHeadline'
        v.children = [new_vnode]
    return v

def readFileFromClipboard(self, s):
    """
    Recreate a file from a string s, and return its hidden vnode.
    
    Unlike readFile above, this does not affect splitter sizes.
    """
    v, g_element = self.readWithElementTree(path=None, s=s)
    if not v:  # #1510.
        return None
    #
    # Fix bug #1111: ensure that all outlines have at least one node.
    if not v.children:
        new_vnode = leoNodes.VNode(context=self.c)
        new_vnode.h = 'newHeadline'
        v.children = [new_vnode]
    return v
</t>
<t tx="ekr.20180605062300.1">def scanGlobals(self, g_element):
    """Get global data from the cache, with reasonable defaults."""
    c = self.c
    d = self.getGlobalData()
    windowSize = g.app.loadManager.options.get('windowSize')
    windowSpot = g.app.loadManager.options.get('windowSpot')
    if windowSize is not None:
        h, w = windowSize  # checked in LM.scanOption.
    else:
        w, h = d.get('width'), d.get('height')
    if windowSpot is None:
        x, y = d.get('left'), d.get('top')
    else:
        y, x = windowSpot  # #1263: (top, left)
    if 'size' in g.app.debug:
        g.trace(w, h, x, y, c.shortFileName())
    # c.frame may be a NullFrame.
    c.frame.setTopGeometry(w, h, x, y)
    r1, r2 = d.get('r1'), d.get('r2')
    c.frame.resizePanesToRatio(r1, r2)
    frameFactory = getattr(g.app.gui, 'frameFactory', None)
    if not frameFactory:
        return
    assert frameFactory is not None
    mf = frameFactory.masterFrame
    if g.app.start_minimized:
        mf.showMinimized()
    elif g.app.start_maximized:
        # #1189: fast.scanGlobals calls showMaximized later.
        mf.showMaximized()
    elif g.app.start_fullscreen:
        mf.showFullScreen()
    else:
        mf.show()
</t>
<t tx="ekr.20180605075042.1">v = leoNodes.VNode(context=c, gnx=gnx)
gnx2vnode[gnx] = v
parent_v.children.append(v)
v.parents.append(parent_v)
body = g.toUnicode(gnx2body.get(gnx) or '')
assert g.isUnicode(body), body.__class__.__name__
v._bodyString = body
v._headString = 'PLACE HOLDER'
</t>
<t tx="ekr.20180605075113.1"># Like fc.handleVnodeSaxAttrutes.
#
# The native attributes of &lt;v&gt; elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnode/VnodeUnknownAttributes.
d = e.attrib
s = d.get('tnodeList', '')
tnodeList = s and s.split(',')
if tnodeList:
    # This tnodeList will be resolved later.
    v.tempTnodeList = tnodeList
s = d.get('descendentTnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentTnodeUaDictList.append(aDict)
s = d.get('descendentVnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentVnodeUaDictList.append((v, aDict),)
#
# Handle vnode uA's
uaDict = gnx2ua[gnx]
    # gnx2ua is a defaultdict(dict)
    # It might already exists because of tnode uA's.
for key, val in d.items():
    if key not in self.nativeVnodeAttributes:
        uaDict[key] = self.resolveUa(key, val)
if uaDict:
    v.unknownAttributes = uaDict
</t>
<t tx="ekr.20180605102822.1">def v_element_visitor(parent_e, parent_v):
    """Visit the given element, creating or updating the parent vnode."""
    for e in parent_e:
        assert e.tag in ('v', 'vh'), e.tag
        if e.tag == 'vh':
            parent_v._headString = g.toUnicode(e.text or '')
            continue
        # #1581: Attempt to handle old Leo outlines.
        try:
            gnx = e.attrib['t']
            v = gnx2vnode.get(gnx)
        except KeyError:
            # g.trace('no "t" attrib')
            gnx = None
            v = None
        if v:
            # A clone
            parent_v.children.append(v)
            v.parents.append(parent_v)
            # The body overrides any previous body text.
            body = g.toUnicode(gnx2body.get(gnx) or '')
            assert g.isUnicode(body), body.__class__.__name__
            v._bodyString = body
        else:
            &lt;&lt; Make a new vnode, linked to the parent &gt;&gt;
            &lt;&lt; handle all other v attributes &gt;&gt;
            # Handle all inner elements.
            v_element_visitor(e, v)

</t>
<t tx="ekr.20180606035619.1"></t>
<t tx="ekr.20180606041211.1">def resolveUa(self, attr, val, kind=None):  # Kind is for unit testing.
    """Parse an unknown attribute in a &lt;v&gt; or &lt;t&gt; element."""
    try:
        val = g.toEncodedString(val)
    except Exception:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()
        return None
    # Leave string attributes starting with 'str_' alone.
    if attr.startswith('str_'):
        if isinstance(val, (str, bytes)):
            return g.toUnicode(val)
    try:
        binString = binascii.unhexlify(val)
            # Throws a TypeError if val is not a hex string.
    except Exception:
        # Assume that Leo 4.1 or above wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw', f"unit test failed: kind={kind}"
        else:
            g.trace(f"can not unhexlify {attr}={val}")
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        return val2
    except Exception:
        try:
            val2 = pickle.loads(binString, encoding='bytes')
            val2 = self.bytesToUnicode(val2)
            return val2
        except Exception:
            g.trace(f"can not unpickle {attr}={val}")
            return val
</t>
<t tx="ekr.20180606044154.1">def bytesToUnicode(self, ob):
    """
    Recursively convert bytes objects in strings / lists / dicts to str
    objects, thanks to TNT
    http://stackoverflow.com/questions/22840092
    Needed for reading Python 2.7 pickles in Python 3.4.
    """
    # This is simpler than using isinstance.
    # pylint: disable=unidiomatic-typecheck
    t = type(ob)
    if t in (list, tuple):
        l = [str(i, 'utf-8') if type(i) is bytes else i for i in ob]
        l = [self.bytesToUnicode(i)
                if type(i) in (list, tuple, dict) else i
                    for i in l]
        ro = tuple(l) if t is tuple else l
    elif t is dict:
        byte_keys = [i for i in ob if type(i) is bytes]
        for bk in byte_keys:
            v = ob[bk]
            del(ob[bk])
            ob[str(bk, 'utf-8')] = v
        for k in ob:
            if type(ob[k]) is bytes:
                ob[k] = str(ob[k], 'utf-8')
            elif type(ob[k]) in (list, tuple, dict):
                ob[k] = self.bytesToUnicode(ob[k])
        ro = ob
    elif t is bytes:  # TNB added this clause
        ro = str(ob, 'utf-8')
    else:
        ro = ob
    return ro
</t>
<t tx="ekr.20180624125321.1">def handleBits(self):
    """Restore the expanded and marked bits from c.db."""
    c, fc = self.c, self.c.fileCommands
    expanded = c.db.get('expanded')
    marked = c.db.get('marked')
    expanded = expanded.split(',') if expanded else []
    marked = marked.split(',') if marked else []
    fc.descendentExpandedList = expanded
    fc.descendentMarksList = marked
</t>
<t tx="ekr.20180708060437.1">def getGlobalData(self):
    """Return a dict containing all global data."""
    c = self.c
    try:
        window_pos = c.db.get('window_position')
        r1 = float(c.db.get('body_outline_ratio', '0.5'))
        r2 = float(c.db.get('body_secondary_ratio', '0.5'))
        top, left, height, width = window_pos
        return {
            'top': int(top),
            'left': int(left),
            'height': int(height),
            'width': int(width),
            'r1': r1,
            'r2': r2,
        }
    except Exception:
        pass
    # Use reasonable defaults.
    return {
        'top': 50, 'left': 50,
        'height': 500, 'width': 800,
        'r1': 0.5, 'r2': 0.5,
    }
</t>
<t tx="ekr.20180708145905.1">@language rest
@wrap

This is the theory of operation document for py2cs.py. The most interesting aspect of this script is the TokenSync class. This class provides a reliable way of associating tokenizer tokens with ast nodes.

@others
</t>
<t tx="ekr.20180708145905.6">
### Using the TokenSync class

The present code is driven by ast trees, but each visitor of the CoffeeScriptTraverser class takes care to preserve **otherwise-ignored tokens**. These are tokens that would otherwise be ignored: namely blank lines and comments, both entire-line comments and trailing comments.

The visitor for each statement intersperses otherwise ignored tokens using calls to the TokenSync class.  The simplest cases are like this:

    def do_Break(self, node):
        head = self.leading_string(node)
        tail = self.trailing_comment(node)
        return head + self.indent('break') + tail

The leading_string and trailing_comment methods simply redirect to the corresponding methods in the TokenSync class.  Saves a bit of typing. Compound statements are a bit more bother, but not overly so. For example:

    def do_If(self, node):

        result = self.leading_lines(node)
        tail = self.trailing_comment(node)
        s = 'if %s:%s' % (self.visit(node.test), tail)
        result.append(self.indent(s))
        for z in node.body:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
        if node.orelse:
            tail = self.tail_after_body(node.body, node.orelse, result)
            result.append(self.indent('else:' + tail))
            for z in node.orelse:
                self.level += 1
                result.append(self.visit(z))
                self.level -= 1
        return ''.join(result)

The line:

        tail = self.tail_after_body(node.body, node.orelse, result)

is a hack needed to compensate for the lack of an actual ast.Else node.
</t>
<t tx="ekr.20180708145905.7">
### Summary

The TokenSync class is, a new, elegant, unexpected and happy development. It is a relatively easy-to-use helper that allows parser-based code to preserve data that is not easily accessible in parse trees.

The TokenSync class avoids [problems with the col_offset field](
http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) in ast nodes. The TokenSync class depends only on the ast.lineno field and the tokenize module. We can expect it to be rock solid.

Edward K. Ream
February 20 to 25, 2016



</t>
<t tx="ekr.20180708152000.1">
### The problem

The initial version of py2cs.py (the script) used only tokens. This solved all token-related problems, but made parsing difficult. Alas, it is [difficult](http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) to associate tokens with ast nodes.

The script needs the following token-related data:

- The **ignored lines** (comment lines and blank lines) that precede any statement.

- The **trailing comment** strings that might follow any line.

- Optionally, the **line breaks** occurring within lines. At present, this script does not preserve such breaks, and it's probably not worth doing. Indeed, automatically breaking long lines seems more useful, especially considering that coffeescript lines may be substantially shorter than the corresponding python lines.

- The **exact spelling** of all strings.

The [ast_utils module](
https://bitbucket.org/plas/thonny/src/3b71fda7ac0b66d5c475f7a668ffbdc7ae48c2b5/thonny/ast_utils.py?at=master) purports to solve this problem with convoluted adjustments to the col_offset field. This approach is subject to subtle Python bugs, and subtle differences between Python 2 and Python 3. There is a better way...
</t>
<t tx="ekr.20180708152018.1">
### Design

The main idea is to use *only* the ast.lineno fields and the tokenizer module to recreate token data. The design assumes only that both the ast.lineno field and Python's tokenizer module are solid. This is a much more reasonable assumption than assuming that the col_offset field always tells the truth. In short, this design *ignores* the ast.col_offset field.

At startup, the TokenSync ctor assigns all the incoming tokens to various lists.  These lists are indexed by lineno:

    ts.line_tokens[i]: all the tokens on line i
    ts.string_tokens[i]: all string tokens on line i
    st.ignored_lines: the blank or comment line on line i

It is very easy to create these lists. The code does not depend on any arcane details.

#### Recovering the exact spelling of stings.

ts.synch_string returns the *next* string on the line. Here it is, stripped of defensive code:

    def sync_string(self, node):
        '''Return the spelling of the string at the given node.'''
        tokens = self.string_tokens[node.lineno-1]
        token = tokens.pop(0)
        self.string_tokens[node.lineno-1] = tokens
        return self.token_val(token)

Stripped of defensive code, the do_Str visitor is just:

    def do_Str(self, node):
        '''A string constant, including docstrings.'''
        return self.sync_string(node)

#### Recovering otherwise ignored nodes

**ts.leading_lines(node)** returns a list of otherwise ignored lines that
precede the node's line that have not already been returned.
**ts.leading_string(node)** is a convenience method that returns ''.join(ts.leading_lines(node)). The visitors of the CoffeeScriptTraverser class show how to use these methods.
</t>
<t tx="ekr.20180806045802.1">def doSmartQuote(self, action, ch, oldSel, w):
    """Convert a straight quote to a curly quote, depending on context."""
    i, j = oldSel
    if i &gt; j:
        i, j = j, i
    # Use raw insert/delete to retain the coloring.
    if i != j:
        w.delete(i, j)
    elif action == 'overwrite':
        w.delete(i)
    ins = w.getInsertPoint()
    # Pick the correct curly quote.
    s = w.getAllText() or ""
    i2 = g.skip_to_start_of_line(s, max(0, ins - 1))
    open_curly = ins == i2 or ins &gt; i2 and s[ins - 1] in ' \t'
        # not s[ins-1].isalnum()
    if open_curly:
        ch = '' if ch == "'" else ""
    else:
        ch = '' if ch == "'" else ""
    w.insert(ins, ch)
    w.setInsertPoint(ins + 1)
</t>
<t tx="ekr.20180810052056.2">def yieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    yield p
    while p:
        if p == target_p:
            return
        v = p.v
        if (v.children and (
            # Use slower test for clones:
            len(v.parents) &gt; 1 and p in v.expandedPositions or
            # Use a quick test for non-clones:
            len(v.parents) &lt;= 1 and (v.statusBits &amp; v.expandedBit) != 0
        )):
            # p.moveToFirstChild()
            p.stack.append((v, p._childIndex),)
            p.v = v.children[0]
            p._childIndex = 0
            yield p
            continue
        # if p.hasNext():
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        if p._childIndex + 1 &lt; len(parent_v.children):
            # p.moveToNext()
            p._childIndex += 1
            p.v = parent_v.children[p._childIndex]
            yield p
            continue
        #
        # A fast version of p.moveToThreadNext().
        # We look for a parent with a following sibling.
        while p.stack:
            # p.moveToParent()
            p.v, p._childIndex = p.stack.pop()
            # if p.hasNext():
            parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
            if p._childIndex + 1 &lt; len(parent_v.children):
                # p.moveToNext()
                p._childIndex += 1
                p.v = parent_v.children[p._childIndex]
                break  # Found: moveToThreadNext()
        else:
            break  # Not found.
        # Found moveToThreadNext()
        yield p
        continue
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
</t>
<t tx="ekr.20180816105258.1">import leo.commands.editFileCommands as efc

efc.GitDiffController(c).diff_two_branches(
    branch1='bc24e607a5', # '6bd282f', # 'bc24e607a5', # old branch/rev
    branch2='devel', # new branch/rev
    fn='leo/plugins/nested_splitter.py',
    directory=None,
)
</t>
<t tx="ekr.20180824065751.1">print(p.gnx)</t>
<t tx="ekr.20181009072707.1"># -*- coding: utf-8 -*-
import os
import sys
import unittest
from leo.core import leoBridge

load_dir = os.path.abspath(os.path.dirname(__file__))
test_dir = os.path.join(load_dir, 'leo', 'test')
path = os.path.join(test_dir, 'unitTest.leo')
assert os.path.exists(path), repr(path)
controller = leoBridge.controller(gui='nullGui',
    loadPlugins=False, readSettings=True,
    silent=False, verbose=False)
g = controller.globals()
c = controller.openLeoFile(path)
try:
    # Run all unit tests locally.
    root = g.findTopLevelNode(c, 'Active Unit Tests', exact=True)
    assert root, 'Not found: Active Unit Tests'
    c.selectPosition(root)
    tm = c.testManager
    g.unitTesting = g.app.unitTesting = True
    suite = unittest.makeSuite(unittest.TestCase)
    aList = tm.findAllUnitTestNodes(all=False, marked=False)
    setup_script = None
    found = False
    for p in aList:
        if tm.isTestSetupNode(p):
            setup_script = p.b
            test = None
        elif tm.isTestNode(p):
            test = tm.makeTestCase(p, setup_script)
        elif tm.isSuiteNode(p):
            test = tm.makeTestSuite(p, setup_script)
        elif tm.isTestClassNode(p):
            test = tm.makeTestClass(p)
        else:
            test = None
        if test:
            suite.addTest(test)
            found = True
    if not found:
        print('No unit tests')
        sys.exit(1)
    runner = unittest.TextTestRunner(failfast=True, verbosity=1)
    try:
        result = runner.run(suite)
        if result.errors or result.failures:
            print(f"errors: {len(result.errors)}, failures: {len(result.failures)}")
            sys.exit(1)
        else:
            print('Travis unit tests all passed.')
            sys.exit(0)
    except Exception:
        print('Unexpected exception')
        g.es_exception()
        sys.exit(1)
except Exception as e:
    print('Unexpected exception 2', e)
    sys.exit(1)
</t>
<t tx="ekr.20181013081645.1">@path test</t>
<t tx="ekr.20181027133311.1">def issueSecurityWarning(setting):
    g.es('Security warning! Ignoring...', color='red')
    g.es(setting, color='red')
    g.es('This setting can be set only in')
    g.es('leoSettings.leo or myLeoSettings.leo')
</t>
<t tx="ekr.20181027151243.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1006

@language python
</t>
<t tx="ekr.20181030041436.1"></t>
<t tx="ekr.20181102040815.1">files = [
    'test/unittest.leo',
]
for fn in files:
    path = g.os_path_finalize_join(g.app.loadDir, '..', fn)
    assert g.os_path_exists(path), repr(path)
    with open(path, 'r') as f:
        s = f.read()
        for line in g.splitLines(s):
            if len(line) &gt; 150:
                print(line)</t>
<t tx="ekr.20190108105509.1">def writePathChanged(self, p):
    '''
    raise IOError if p's path has changed *and* user forbids the write.
    '''
    at, c = self, self.c
    #
    # Suppress this message during save-as and save-to commands.
    if c.ignoreChangedPaths:
        return
    oldPath = g.os_path_normcase(at.getPathUa(p))
    newPath = g.os_path_normcase(g.fullPath(c, p))
    try:  # #1367: samefile can throw an exception.
        changed = oldPath and not os.path.samefile(oldPath, newPath)
    except Exception:
        changed = True
    if not changed:
        return
    ok = at.promptForDangerousWrite(
        fileName=None,
        message=(
            f"{g.tr('path changed for %s' % (p.h))}\n"
            f"{g.tr('write this file anyway?')}"
        ),
    )
    if not ok:
        raise IOError
    at.setPathUa(p, newPath)  # Remember that we have changed paths.
</t>
<t tx="ekr.20190108112519.1">def reportEndOfWrite(self, files, all, dirty):

    if g.unitTesting:
        return
    if files:
        g.es('finished')
    elif all:
        g.warning("no @&lt;file&gt; nodes in the selected tree")
    elif dirty:
        g.es("no dirty @&lt;file&gt; nodes in the selected tree")
</t>
<t tx="ekr.20190109142026.1">def atFileToString(self, root, sentinels=True):
    """Write an external file to a string, and return its contents."""
    at, c = self, self.c
    try:
        c.endEditing()
        at.initWriteIvars(root, "&lt;string-file&gt;", sentinels=sentinels)
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        assert root == at.root, 'write'
        result = at.closeOutputStream()
        # Major bug: failure to clear this wipes out headlines!
        #            Sometimes this causes slight problems...
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
            root.v._p_changed = True
        return result
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.exception("exception preprocessing script")
        root.v._p_changed = True
        return ''
</t>
<t tx="ekr.20190111045822.1">def precheck(self, fileName, root):
    """
    Check whether a dirty, potentially dangerous, file should be written.
    
    Return True if so.  Return False *and* issue a warning otherwise.
    """
    at = self
    #
    # #1450: First, check that the directory exists.
    theDir = g.os_path_dirname(fileName)
    if theDir and not g.os_path_exists(theDir):
        at.error(f"Directory not found:\n{theDir}")
        return False
    #
    # Now check the file.
    if not at.shouldPromptForDangerousWrite(fileName, root):
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    #
    # Prompt if the write would overwrite the existing file.
    ok = self.promptForDangerousWrite(fileName)
    if ok:
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    #
    # Fix #1031: do not add @ignore here!
    g.es("not written:", fileName)
    return False
</t>
<t tx="ekr.20190122185223.1">@language text

Find all kwargs using regex:

^\s*(def\s+\w+\s*\(.*\=.*\))

found 1154 nodes

^\s*(def\s+\w+\s*\(.*\=.*\=.*\))

found 284 nodes
</t>
<t tx="ekr.20190306105229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1032

@language python
</t>
<t tx="ekr.20190326183005.1">def reloadSettings(self):
    """Complete the initialization of all settings."""
    if 'coloring' in g.app.debug and not g.unitTesting:
        print('jedit.reloadSettings.')
    # Do the basic inits.
    BaseJEditColorizer.reloadSettings(self)
    # Init everything else.
    self.init_style_ivars()
    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
    self.init()
</t>
<t tx="ekr.20190402091335.1">from leo.commands import editFileCommands as efc

efc.GitDiffController(c).diff_two_revs(
    rev1='51715f5', # Before, the *original* base of ekr-theme.
    rev2='HEAD',    # After: Latest ekr-theme (or devel) commit.
)
</t>
<t tx="ekr.20190406154306.1">g.openWithFileName(r'C:\apps\pyzo\pyzo.leo')</t>
<t tx="ekr.20190406193429.1"># Extra plugins, for this file only.

# Essential...
plugins_menu.py
free_layout.py
    # Now loaded automatically.
    # Disabled for testing bug 882824.
mod_scripting.py
viewrendered.py

# Testing only...
# nodetags.py
# python_terminal.py
# multifile.py
# livecode.py

# Others...
# bookmarks.py
# demo.py
# mod_http.py
# richtext.py

# Standard plugins

# backlink.py
# bigdash.py
# contextmenu.py
# line_numbering.py
# nav_qt.py
# nodetags.py
# quicksearch.py
# screen_capture.py
# todo.py
# valuespace.py
# xdb_pane.py
</t>
<t tx="ekr.20190410171646.1">@first # -*- coding: utf-8 -*-
'''
pyzo_support.py: Will probably be deleted.
'''
&lt;&lt; copyright &gt;&gt;
from leo.core import leoGlobals as g
assert g
@others
</t>
<t tx="ekr.20190410171905.1">def init():
    print('pyzo_support.py is not a real plugin')
    return False
</t>
<t tx="ekr.20190412042616.1">@
This file uses code from pyzo. Here is the pyzo copyright notice:

Copyright (C) 2013-2018, the Pyzo development team

Pyzo is distributed under the terms of the (new) BSD License.
The full license can be found in 'license.txt'.

Yoton is distributed under the terms of the (new) BSD License.
The full license can be found in 'license.txt'.
</t>
<t tx="ekr.20190418161712.1">class PyzoInterface:
    '''
    A class representing the singleton running instance of pyzo.
    
    Instantiated in the top-level init() function.
    '''

    @others
</t>
<t tx="ekr.20190505173053.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1132

@language python
</t>
<t tx="ekr.20190506055928.1">@nosearch

# flattened, word, ignore-case, head, body

# found 5 nodes
</t>
<t tx="ekr.20190506060857.1"></t>
<t tx="ekr.20190506061636.1"></t>
<t tx="ekr.20190602151043.2">def batchRegexReplace(self, s):
    """
    Perform all regex find/replace on s.
    return (count, new_s)
    """
    count, prev_i, result = 0, 0, []

    flags = re.MULTILINE
    if self.ignore_case:
        flags |= re.IGNORECASE
    for m in re.finditer(self.find_text, s, flags):
        count += 1
        i = m.start()
        result.append(s[prev_i:i])
        # #1748.
        groups = m.groups()
        if groups:
            change_text = self.makeRegexSubs(self.change_text, groups)
        else:
            change_text = self.change_text
        result.append(change_text)
        prev_i = m.end()
    # Compute the result.
    result.append(s[prev_i:])
    s = ''.join(result)
    return count, s
</t>
<t tx="ekr.20190607124533.1"></t>
<t tx="ekr.20190611095758.1"></t>
<t tx="ekr.20190803175344.1">def patch_pyzo(self):
    '''
    Called at the end of pyzo.start to embed Leo into pyzo.
    '''
</t>
<t tx="ekr.20190805022257.1">@first # -*- coding: utf-8 -*-
"""pyzo_file_browser.py: Experimental plugin that adds pyzo's file browser dock to Leo."""
&lt;&lt; pyzo_file_browser imports &gt;&gt;
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190809093446.1">import sys
from leo.core import leoGlobals as g
from leo.core.leoQt import QtCore
#
# Must patch sys.path here.
plugins_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
sys.path.insert(0, plugins_dir)
#
# Start pyzo, de-fanged.
import pyzo
# pylint: disable=no-member
</t>
<t tx="ekr.20190809093459.1"></t>
<t tx="ekr.20190809093459.3">init_warning_given = False

def init(): # pyzo_file_browser.py
    '''Return True if this plugin can be loaded.'''
    
    def oops(message):
        global init_warning_given
        if not init_warning_given:
            init_warning_given = True
            print('%s %s' % (__name__, message))
        return False
        
    if g.app.gui.guiName() != "qt":
        return oops('requires Qt gui')
     if not getattr(g.app, 'dock'):
        return oops('requires Qt Docks')
    g.plugin_signon(__name__)
    g.registerHandler('after-create-leo-frame', onCreate)
    return True
</t>
<t tx="ekr.20190809093459.4">def onCreate(tag, keys): # pyzo_file_browser.py
    '''Create a pyzo file browser in c's outline.'''
    c = keys.get('c')
    dw = c and c.frame and c.frame.top
    if not dw:
        return
    pyzo.start_pyzo_in_leo(c, pyzo)
    from pyzo.tools.pyzoFileBrowser import PyzoFileBrowser
    make_dock(c,
        name="File Browser",
        widget=PyzoFileBrowser(parent=None),
    )
</t>
<t tx="ekr.20190814050007.1">def make_dock(c, name, widget): # pyzo_file_browser.py
    """Create a dock with the given name and widget in c's main window."""
    dw = c.frame.top
    dock = g.app.gui.create_dock_widget(
        closeable=True,
        moveable=True,
        height=100,
        name=name,
    )
    dw.leo_docks.append(dock)
    dock.setWidget(widget)
    area = QtCore.Qt.LeftDockWidgetArea
    dw.addDockWidget(area, dock)
    widget.show()
</t>
<t tx="ekr.20190923170528.1">def doWindowSpotOption(self, options):

    # --window-spot
    spot = options.window_spot
    if spot:
        try:
            top, left = spot.split('x')
            spot = int(top), int(left)
        except ValueError:
            print('scanOptions: bad --window-spot:', spot)
            spot = None

    return spot
</t>
<t tx="ekr.20191021002252.1">
(base) c:\leo.repo\leo-editor&gt;mypy leo\core\runLeo.py

leo\external\__init__.py:3: error: Need type annotation for '__all__' (hint: "__all__: List[&lt;type&gt;] = ...")

leo\external\codewise.py:100: error: Cannot find module named '__builtin__'
leo\external\codewise.py:100: error: Name 'builtins' already defined (by an import)

leo\core\leoGlobals.py:34: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoGlobals.py:39: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoGlobals.py:43: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoGlobals.py:309: error: Need type annotation for 'tree_popup_handlers' (hint: "tree_popup_handlers: List[&lt;type&gt;] = ...")
leo\core\leoGlobals.py:310: error: Need type annotation for 'user_dict' (hint: "user_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:2088: error: Need type annotation for 'tracing_signatures' (hint: "tracing_signatures: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:2600: error: No library stub file for module 'PyQt5.QtCore'
leo\core\leoGlobals.py:2600: error: No library stub file for module 'PyQt5'
leo\core\leoGlobals.py:2603: error: No library stub file for module 'PyQt4.QtCore'
leo\core\leoGlobals.py:2603: note: (Stub files are from https://github.com/python/typeshed)
leo\core\leoGlobals.py:2603: error: No library stub file for module 'PyQt4'
leo\core\leoGlobals.py:2702: error: No library stub file for module 'pylint'
leo\core\leoGlobals.py:2770: error: Need type annotation for 'lastObjectsDict' (hint: "lastObjectsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:2771: error: Need type annotation for 'lastTypesDict' (hint: "lastTypesDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:2772: error: Need type annotation for 'lastFunctionsDict' (hint: "lastFunctionsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:5261: error: Need type annotation for 'childrenModifiedSet' (hint: "childrenModifiedSet: Set[&lt;type&gt;] = ...")
leo\core\leoGlobals.py:5262: error: Need type annotation for 'contentModifiedSet' (hint: "contentModifiedSet: Set[&lt;type&gt;] = ...")
leo\core\leoGlobals.py:5767: error: Need type annotation for 'checkUnicode_dict' (hint: "checkUnicode_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:5925: error: Need type annotation for 'unicode_warnings' (hint: "unicode_warnings: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:6814: error: Need type annotation for 'init_zodb_failed' (hint: "init_zodb_failed: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:6815: error: Need type annotation for 'init_zodb_db' (hint: "init_zodb_db: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:6829: error: Cannot find module named 'ZODB'
leo\core\leoGlobals.py:6829: note: See https://mypy.readthedocs.io/en/latest/running_mypy.html#missing-imports
leo\core\leoGlobals.py:6964: error: Need type annotation for 'deprecated_messages' (hint: "deprecated_messages: List[&lt;type&gt;] = ...")

leo\plugins\importers\ipynb.py:7: error: No library stub file for module 'nbformat'

leo\core\leoVim.py:2054: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2058: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2062: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2075: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2080: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2088: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2093: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2097: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2102: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2106: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2110: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2121: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2141: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2147: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2155: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2160: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2167: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"

leo\core\leoUndo.py:1162: error: Argument 1 to "cmd" has incompatible type "str"; expected "Undoer"
leo\core\leoUndo.py:1441: error: Argument 1 to "cmd" has incompatible type "str"; expected "Undoer"

leo\core\leoFind.py:304: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:322: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:327: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:489: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:495: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:505: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:517: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:526: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:587: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:600: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:609: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:624: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:639: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:654: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:669: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:865: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:866: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:867: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:894: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:895: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:896: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:924: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:925: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:926: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:952: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:961: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:972: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:978: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1083: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1090: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1107: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1115: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1133: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1158: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1259: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1266: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1279: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1287: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1292: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1297: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1302: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1307: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1312: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1317: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1322: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1333: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1338: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1343: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1355: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1411: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"

leo\core\leoFind.py:2211: error: Need type annotation for 'debugIndices' (hint: "debugIndices: List[&lt;type&gt;] = ...")

leo\core\leoDebugger.py:75: error: No library stub file for standard library module 'bdb'

leo\commands\checkerCommands.py:12: error: No library stub file for module 'flake8'
leo\commands\checkerCommands.py:16: error: No library stub file for module 'pyflakes'
leo\commands\checkerCommands.py:487: error: No library stub file for module 'pylint'

leo\core\leoChapters.py:94: error: Argument 1 to "cmd" has incompatible type "str"; expected "ChapterController"
leo\core\leoChapters.py:110: error: Argument 1 to "cmd" has incompatible type "str"; expected "ChapterController"
leo\core\leoChapters.py:119: error: Argument 1 to "cmd" has incompatible type "str"; expected "ChapterController"

leo\core\leoBeautify.py:11: error: Cannot find module named 'leoGlobals'
leo\core\leoBeautify.py:11: error: Name 'g' already defined (by an import)
leo\core\leoBeautify.py:18: error: Incompatible types in assignment (expression has type "Callable[[Any], Any]", variable has type "Type[Command]")
leo\core\leoBeautify.py:31: error: Cannot find module named 'black'

leo\core\leoIPython.py:35: error: Cannot find module named 'ipykernel.connect'
leo\core\leoIPython.py:40: error: Cannot find module named 'ipykernel.kernelapp'
leo\core\leoIPython.py:45: error: "None" has no attribute "ipython_inited"

leo\core\leoNodes.py:326: error: Incompatible types in assignment (expression has type "None", base class "object" defined the type as "Callable[[object], int]")

leo\core\leoQt.py:27: error: No library stub file for module 'PyQt5'
leo\core\leoQt.py:31: error: No library stub file for module 'PyQt4'
leo\core\leoQt.py:52: error: Name 'QtCore' already defined on line 44
leo\core\leoQt.py:53: error: Name 'QtGui' already defined on line 44
leo\core\leoQt.py:54: error: Name 'QtWidgets' already defined on line 44
leo\core\leoQt.py:55: error: No library stub file for module 'PyQt5.QtCore'
leo\core\leoQt.py:55: error: Name 'QUrl' already defined on line 44
leo\core\leoQt.py:56: error: Name 'Signal' already defined on line 49
leo\core\leoQt.py:57: error: "None" has no attribute "Qt"
leo\core\leoQt.py:65: error: Name 'QtCore' already defined on line 44
leo\core\leoQt.py:66: error: Name 'QtGui' already defined on line 44
leo\core\leoQt.py:67: error: No library stub file for module 'PyQt4.QtCore'
leo\core\leoQt.py:67: error: Name 'QUrl' already defined on line 44
leo\core\leoQt.py:68: error: Name 'Signal' already defined on line 49
leo\core\leoQt.py:82: error: "None" has no attribute "QT_VERSION_STR"
leo\core\leoQt.py:92: error: "None" has no attribute "QString"
leo\core\leoQt.py:96: error: No library stub file for module 'PyQt5.QtDeclarative'
leo\core\leoQt.py:96: error: Name 'QtDeclarative' already defined on line 45
leo\core\leoQt.py:100: error: No library stub file for module 'PyQt5.phonon'
leo\core\leoQt.py:100: error: Name 'phonon' already defined on line 46
leo\core\leoQt.py:101: error: "None" has no attribute "Phonon"
leo\core\leoQt.py:105: error: Name 'QtMultimedia' already defined on line 45
leo\core\leoQt.py:109: error: Name 'Qsci' already defined on line 45
leo\core\leoQt.py:113: error: No library stub file for module 'PyQt5.QtSvg'
leo\core\leoQt.py:113: error: Name 'QtSvg' already defined on line 45
leo\core\leoQt.py:117: error: Name 'uic' already defined on line 46
leo\core\leoQt.py:121: error: Name 'QtWebKit' already defined on line 45
leo\core\leoQt.py:125: error: Name 'QtWebKit' already defined on line 45
leo\core\leoQt.py:129: error: No library stub file for module 'PyQt5.QtWebKitWidgets'
leo\core\leoQt.py:129: error: Name 'QtWebKitWidgets' already defined on line 45
leo\core\leoQt.py:135: error: No library stub file for module 'PyQt5.QtWebEngineWidgets'
leo\core\leoQt.py:135: error: Name 'QtWebKitWidgets' already defined on line 45
leo\core\leoQt.py:136: error: "None" has no attribute "QWebView"
leo\core\leoQt.py:136: error: "None" has no attribute "QWebEngineView"
leo\core\leoQt.py:137: error: "None" has no attribute "QWebSettings"
leo\core\leoQt.py:137: error: "None" has no attribute "QWebEngineSettings"
leo\core\leoQt.py:138: error: "None" has no attribute "QWebPage"
leo\core\leoQt.py:138: error: "None" has no attribute "QWebEnginePage"
leo\core\leoQt.py:143: error: "None" has no attribute "QString"
leo\core\leoQt.py:147: error: No library stub file for module 'PyQt4.QtDeclarative'
leo\core\leoQt.py:147: error: Name 'QtDeclarative' already defined on line 45
leo\core\leoQt.py:153: error: No library stub file for module 'PyQt4.phonon'
leo\core\leoQt.py:153: error: Name 'phonon' already defined on line 46
leo\core\leoQt.py:154: error: Item "None" of "Optional[Any]" has no attribute "Phonon"
leo\core\leoQt.py:158: error: Name 'Qsci' already defined on line 45
leo\core\leoQt.py:162: error: No library stub file for module 'PyQt4.QtSvg'
leo\core\leoQt.py:162: error: Name 'QtSvg' already defined on line 45
leo\core\leoQt.py:166: error: Name 'uic' already defined on line 46
leo\core\leoQt.py:170: error: Name 'QtWebKit' already defined on line 45
leo\core\leoQt.py:174: error: No library stub file for module 'PyQt4.QtWebKit'
leo\core\leoQt.py:174: error: Name 'QtWebKitWidgets' already defined on line 45

leo\core\leoCheck.py:1457: error: Need type annotation for 'assigns_d' (hint: "assigns_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:1458: error: Need type annotation for 'calls_d' (hint: "calls_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:1459: error: Need type annotation for 'classes_d' (hint: "classes_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:1460: error: Need type annotation for 'defs_d' (hint: "defs_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:1461: error: Need type annotation for 'returns_d' (hint: "returns_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:2047: error: Need type annotation for 'd' (hint: "d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")

leo\plugins\nested_splitter.py:9: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\plugins\nested_splitter.py:26: error: Name 'QtWidgets.QWidget' is not defined
leo\plugins\nested_splitter.py:51: error: Name 'QtWidgets.QWidget' is not defined
leo\plugins\nested_splitter.py:108: error: Name 'QtWidgets.QWidget' is not defined
leo\plugins\nested_splitter.py:130: error: Name 'QtWidgets.QSplitterHandle' is not defined
leo\plugins\nested_splitter.py:391: error: Name 'QtWidgets.QSplitter' is not defined

leo\plugins\editpane\clicky_splitter.py:13: error: Name 'QtWidgets.QSplitterHandle' is not defined
leo\plugins\editpane\clicky_splitter.py:25: error: Name 'QtWidgets.QSplitter' is not defined

leo\plugins\qt_text.py:416: error: Name 'QtWidgets.QFrame' is not defined
leo\plugins\qt_text.py:454: error: Name 'QtWidgets.QTextBrowser' is not defined
leo\plugins\qt_text.py:485: error: Name 'QtWidgets.QListWidget' is not defined
leo\plugins\qt_text.py:744: error: Name 'QtWidgets.QFrame' is not defined

leo\core\leoColorizer.py:23: error: No library stub file for module 'pygments'
leo\core\leoColorizer.py:339: error: Need type annotation for 'zoom_dict' (hint: "zoom_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2325: error: Name 'QtGui.QSyntaxHighlighter' is not defined
leo\core\leoColorizer.py:2457: error: No library stub file for module 'pygments.styles'
leo\core\leoColorizer.py:2492: error: Name 'Qsci.QsciLexerCustom' is not defined
leo\core\leoColorizer.py:2588: error: Need type annotation for 'traced_dict' (hint: "traced_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2618: error: Need type annotation for 'format_dict' (hint: "format_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2620: error: Need type annotation for 'lexers_dict' (hint: "lexers_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2622: error: Need type annotation for 'state_s_dict' (hint: "state_s_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2624: error: Need type annotation for 'state_n_dict' (hint: "state_n_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2690: error: No library stub file for module 'pygments.token'
leo\core\leoColorizer.py:2711: error: No library stub file for module 'pygments.lexers'
leo\core\leoColorizer.py:2730: error: No library stub file for module 'pygments.lexer'
leo\core\leoColorizer.py:3044: error: Name 'QtGui.QTextBlockUserData' is not defined
leo\core\leoColorizer.py:3064: error: Cannot assign to a type
leo\core\leoColorizer.py:3064: error: Incompatible types in assignment (expression has type "Type[NullObject]", variable has type "Type[PygmentsBlockUserData]")

leo\core\leoRst.py:20: error: "None" has no attribute "debug"
leo\core\leoRst.py:25: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:35: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:37: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:40: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:45: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:50: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:54: error: Cannot find module named 'SilverCity'
leo\core\leoRst.py:86: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "arguments"
leo\core\leoRst.py:92: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "options"
leo\core\leoRst.py:97: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "content"
leo\core\leoRst.py:101: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "options"
leo\core\leoRst.py:306: error: Argument 1 to "cmd" has incompatible type "str"; expected "RstCommands"
leo\core\leoRst.py:501: error: Argument 1 to "cmd" has incompatible type "str"; expected "RstCommands"

leo\core\leoPrinting.py:97: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:103: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:112: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:118: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:127: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:134: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:145: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:152: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:159: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:165: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:172: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:182: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:188: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:197: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:203: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:212: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:219: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:230: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:237: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:243: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:249: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:258: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"

leo\core\leoImport.py:16: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoImport.py:22: error: No library stub file for module 'lxml.html'
leo\core\leoImport.py:22: error: No library stub file for module 'lxml'

leo\core\leoFileCommands.py:1802: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"
leo\core\leoFileCommands.py:1810: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"
leo\core\leoFileCommands.py:1822: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"
leo\core\leoFileCommands.py:1829: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"

leo\core\leoKeys.py:196: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:218: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:223: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:229: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:235: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:241: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:247: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:253: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:259: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:274: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:538: error: Cannot find module named 'jedi'
leo\core\leoKeys.py:2335: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2477: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2551: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2581: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2602: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2623: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2632: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2641: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2650: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2797: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:3935: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:3943: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"

leo\commands\spellCommands.py:15: error: Cannot find module named 'enchant'
leo\commands\convertCommands.py:1598: error: No library stub file for module 'nbformat'

leo\core\leoAtFile.py:239: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:971: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:979: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:987: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:996: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:2306: error: No library stub file for standard library module 'parser'

leo\core\leoCommands.py:20: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoCommands.py:736: error: Cannot find module named '_pytest.config'
leo\core\leoCommands.py:737: error: Cannot find module named '_pytest.assertion.rewrite'
leo\core\leoCommands.py:1990: error: Need type annotation for 'deprecated_messages' (hint: "deprecated_messages: List[&lt;type&gt;] = ...")

leo\core\leoApp.py:1036: error: Cannot find module named 'flexx'
leo\core\leoApp.py:1443: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"
leo\core\leoApp.py:1444: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"
leo\core\leoApp.py:1591: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"
leo\core\leoApp.py:1592: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"

leo\plugins\editpane\editpane.py:10: error: Cannot find module named 'OpenGL'
leo\plugins\editpane\editpane.py:66: error: Name 'QtWidgets.QWidget' is not defined

leo\core\leoFrame.py:905: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:926: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:962: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:1030: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:1044: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"

leo\core\runLeo.py:17: error: Argument 1 to "join" has incompatible type "Optional[str]"; expected "Union[str, _PathLike[str]]"
leo\core\runLeo.py:28: error: Incompatible types in assignment (expression has type "LeoApp", variable has type "None")

leo\plugins\mod_scripting.py:459: error: Cannot find module named 'rpdb2'
leo\plugins\mod_scripting.py:504: error: Cannot find module named 'leo.core.leoScriptModule'
leo\plugins\mod_scripting.py:1204: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1240: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1295: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1319: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1338: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"

leo\plugins\qt_events.py:46: error: Name 'QtCore.QObject' is not defined

leo\core\leoTest.py:27: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoTest.py:1711: error: Need type annotation for 'lastObjectsDict' (hint: "lastObjectsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoTest.py:1712: error: Need type annotation for 'lastTypesDict' (hint: "lastTypesDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoTest.py:1713: error: Need type annotation for 'lastFunctionsDict' (hint: "lastFunctionsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")

leo\plugins\cursesGui2.py:39: error: Cannot assign to a type
leo\plugins\cursesGui2.py:39: error: Incompatible types in assignment (expression has type "None", variable has type "Type[Tk]")
leo\plugins\cursesGui2.py:48: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\plugins\cursesGui2.py:58: error: Cannot find module named 'npyscreen.utilNotify'
leo\plugins\cursesGui2.py:58: error: Cannot find module named 'npyscreen'
leo\plugins\cursesGui2.py:60: error: Cannot find module named 'npyscreen.wgwidget'
leo\plugins\cursesGui2.py:73: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:208: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:299: error: Name 'npyscreen.TreeData' is not defined
leo\plugins\cursesGui2.py:479: error: Name 'npyscreen.TreeLine' is not defined
leo\plugins\cursesGui2.py:699: error: Name 'npyscreen.MiniButtonPress' is not defined
leo\plugins\cursesGui2.py:1823: error: Need type annotation for 'set_focus_fail' (hint: "set_focus_fail: List[&lt;type&gt;] = ...")
leo\plugins\cursesGui2.py:2328: error: Argument 1 to "cmd" has incompatible type "str"; expected "CoreFrame"
leo\plugins\cursesGui2.py:2397: error: Argument 1 to "cmd" has incompatible type "str"; expected "CoreLog"
leo\plugins\cursesGui2.py:2724: error: Name 'npyscreen.NPSApp' is not defined
leo\plugins\cursesGui2.py:2741: error: Name 'npyscreen.MultiLineEditable' is not defined
leo\plugins\cursesGui2.py:2955: error: Name 'npyscreen.MultiLineEditable' is not defined
leo\plugins\cursesGui2.py:3103: error: Name 'npyscreen.Form' is not defined
leo\plugins\cursesGui2.py:3117: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:3276: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:3290: error: Name 'npyscreen.MLTree' is not defined
leo\plugins\cursesGui2.py:3952: error: Name 'npyscreen.TreeData' is not defined

leo\plugins\qt_frame.py:27: error: Cannot determine type of 'enabled'
leo\plugins\qt_frame.py:31: error: Cannot assign multiple types to name "splitter_class" without an explicit "Type[...]" annotation
leo\plugins\qt_frame.py:31: error: "None" has no attribute "QSplitter"
leo\plugins\qt_frame.py:38: error: Name 'QtWidgets.QMainWindow' is not defined
leo\plugins\qt_frame.py:1503: error: Name 'QtWidgets.QTabWidget' is not defined
leo\plugins\qt_frame.py:1737: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:1738: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:1793: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:1794: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:2490: error: Need type annotation for 'styleSheetCache' (hint: "styleSheetCache: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\plugins\qt_frame.py:3010: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3022: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3038: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3047: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3063: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3077: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3093: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3321: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtLog"
leo\plugins\qt_frame.py:3923: error: Name 'QtWidgets.QTreeWidget' is not defined
leo\plugins\qt_frame.py:4632: error: Name 'QtWidgets.QTabBar' is not defined
leo\plugins\qt_frame.py:4647: error: Name 'QtWidgets.QMenu' is not defined

leo\core\leoConfig.py:37: error: Need type annotation for 'settingsDict' (hint: "settingsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoConfig.py:2043: error: Need type annotation for 'no_menu_dict' (hint: "no_menu_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")

leo\plugins\leoflexx.py:39: error: Cannot find module named 'flexx'
leo\plugins\leoflexx.py:40: error: Cannot find module named 'pscript'
leo\plugins\leoflexx.py:1186: error: Need type annotation for 'attributes' (hint: "attributes: Set[&lt;type&gt;] = ...")

leo\plugins\qt_gui.py:618: error: Cannot find module named 'pyzo'
leo\plugins\qt_gui.py:619: error: Cannot find module named 'pyzo.core.menu'
leo\plugins\qt_gui.py:619: error: Cannot find module named 'pyzo.core'
leo\plugins\qt_gui.py:622: error: Cannot find module named 'pyzo.tools.pyzoFileBrowser'
leo\plugins\qt_gui.py:622: error: Cannot find module named 'pyzo.tools'
leo\plugins\qt_gui.py:627: error: Cannot find module named 'pyzo.core.main'
leo\plugins\qt_gui.py:989: error: Need type annotation for 'size_warnings' (hint: "size_warnings: List[&lt;type&gt;] = ...")
leo\plugins\qt_gui.py:1349: error: Name 'QtWidgets.QMessageBox' is not defined
leo\plugins\qt_gui.py:1487: error: No library stub file for module 'PyQt5.QtTest'
leo\plugins\qt_gui.py:1491: error: "None" has no attribute "QObject"
leo\plugins\qt_gui.py:1492: error: "None" has no attribute "QObject"
leo\plugins\qt_gui.py:1493: error: "None" has no attribute "QObject"

Found 360 errors in 40 files (checked 1 source file)
</t>
<t tx="ekr.20191029023442.1">@language rest
@wrap

A tutorial: (learn by doing: teacher guides)
    is learning-oriented
    allows the newcomer to get started
    is a lesson
    
A how-to guide: (recipe: users ask questions)
    is goal-oriented
    shows how to solve a specific problem
    is a series of steps

A reference guide:
    is information-oriented
    describes the machinery
    is accurate and complete

An explanation/discussion
    is understanding-oriented
    explains
    provides background and context</t>
<t tx="ekr.20191206073301.1">@language rest
@wrap

@clean and @auto may not always be updated reliably

https://github.com/leo-editor/leo-editor/issues/1451

#1361 may be the culprit
https://github.com/leo-editor/leo-editor/issues/1361

*** --trace=write

@language python
</t>
<t tx="ekr.20191207065251.1"></t>
<t tx="ekr.20200212095937.1"></t>
<t tx="ekr.20200212095937.2">True:  allow joined lines to contain strings.
False: (Recommended by EKR): Retain alignment of strings.</t>
<t tx="ekr.20200212095937.3">True: Retain indentation of overindented stand-alone comment lines.</t>
<t tx="ekr.20200212095937.5"># At present I am of the opinion that joining lines is usually a bad idea.

Should be &lt;= beautify-max-split-line-length</t>
<t tx="ekr.20200212095937.6"></t>
<t tx="ekr.20200222083959.1">import logging
rootLogger = logging.getLogger('')
rootLogger.setLevel(logging.DEBUG)
socketHandler = logging.handlers.SocketHandler(
    'localhost',
    logging.handlers.DEFAULT_TCP_LOGGING_PORT,
)
rootLogger.addHandler(socketHandler)
logging.info('-' * 20)
</t>
<t tx="ekr.20200222151754.1">import yoton

# Create another context and a sub channel
ct2 = yoton.Context()
sub = yoton.SubChannel(ct2, 'chat')

# Connect
ct2.connect('publichost:test')

# Receive
while True:
    i = int(sub.recv())
    print(i)
    if i == 10:
        break
</t>
<t tx="ekr.20200304130514.1">def onContextMenu(self, point):
    """LeoQTextBrowser: Callback for customContextMenuRequested events."""
    # #1286.
    c, w = self.leo_c, self
    g.app.gui.onContextMenu(c, w, point)
</t>
<t tx="ekr.20200308193719.1">d = {}  # Keys are gnxs, values is a list of vnodes with that gnx.
for v in c.all_nodes():
    gnx = v.gnx
    aList = d.get(gnx, [])
    if v not in aList:
        aList.append(v)
        d [gnx] = aList
        if len(aList) &gt; 1:
            print(f"gnx clash: {gnx}")
            g.printObj(aList)
print('done')</t>
<t tx="ekr.20200401074555.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1557

Create mypy command?

@language python
</t>
<t tx="ekr.20200422075655.1">@g.commander_command('restart-leo')
def restartLeo(self, event=None):
    """Restart Leo, reloading all presently open outlines."""
    c, lm = self, g.app.loadManager
    trace = 'shutdown' in g.app.debug
    # 1. Write .leoRecentFiles.txt.
    g.app.recentFilesManager.writeRecentFilesFile(c)
    # 2. Abort the restart if the user veto's any close.
    for c in g.app.commanders():
        if c.changed:
            veto = False
            try:
                c.promptingForClose = True
                veto = c.frame.promptForSave()
            finally:
                c.promptingForClose = False
            if veto:
                g.es_print('Cancelling restart-leo command')
                return
    # 3. Officially begin the restart process. A flag for efc.ask.
    g.app.restarting = True  # #1240.
    # 4. Save session data.
    if g.app.sessionManager:
        g.app.sessionManager.save_snapshot()
    # 5. Close all unsaved outlines.
    g.app.setLog(None)  # Kill the log.
    for c in g.app.commanders():
        frame = c.frame
        # This is similar to g.app.closeLeoWindow.
        g.doHook("close-frame", c=c)
        # Save the window state
        g.app.commander_cacher.commit() # store cache, but don't close it.
        # This may remove frame from the window list.
        if frame in g.app.windowList:
            g.app.destroyWindow(frame)
            g.app.windowList.remove(frame)
        else:
            # #69.
            g.app.forgetOpenFile(fn=c.fileName(), force=True)
    # 6. Complete the shutdown.
    g.app.finishQuit()
    # 7. Restart, restoring the original command line.
    args = ['-c'] + [z for z in lm.old_argv]
    if trace: g.trace('restarting with args', args)
    sys.stdout.flush()
    sys.stderr.flush()
    os.execv(sys.executable, args)
</t>
<t tx="ekr.20200522075411.1">def doCommandByName(self, command_name, event):
    """
    Execute one command, given the name of the command.
    
    The caller must do any required keystroke-only tasks.
    
    Return the result, if any, of the command.
    """
    c = self
    # Get the command's function.
    command_func = c.commandsDict.get(command_name.replace('&amp;', ''))
    if not command_func:
        message = f"no command function for {command_name!r}"
        if g.app.unitTesting or g.app.inBridge:
            raise AttributeError(message)
        g.es_print(message, color='red')
        g.trace(g.callers())
        return None
    # Invoke the function.
    val = c.doCommand(command_func, command_name, event)
    if c.exists:
        c.frame.updateStatusLine()
    return val
</t>
<t tx="ekr.20200522082827.1"></t>
<t tx="ekr.20200523135601.1">def insertCharFromEvent(self, event):
    """
    Handle the character given by event, ignoring various special keys:
    - getArg state: k.getArg.
    - Tree: onCanvasKey or onHeadlineKey.
    - Body: ec.selfInsertCommand
    - Log: log_w.insert
    """
    trace = all(z in g.app.debug for z in ('keys', 'verbose'))
    c, k, w = self, self.k, event.widget
    name = c.widget_name(w)
    stroke = event.stroke
    if trace: g.trace('stroke', stroke, 'plain:', k.isPlainKey(stroke), 'widget', name)
    if not stroke:
        return
    #
    # Part 1: Very late special cases.
    #
    # #1448
    if stroke.isNumPadKey() and k.state.kind == 'getArg':
        stroke.removeNumPadModifier()
        k.getArg(event, stroke=stroke)
        return
    # Handle all unbound characters in command mode.
    if k.unboundKeyAction == 'command':
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return
    #
    # Part 2: Filter out keys that should never be inserted by default.
    #
    # Ignore unbound F-keys.
    if stroke.isFKey():
        return
    # Ignore unbound Alt/Ctrl keys.
    if stroke.isAltCtrl():
        if not k.enable_alt_ctrl_bindings:
            return
        if k.ignore_unbound_non_ascii_keys:
            return
    # #868
    if stroke.isPlainNumPad():
        stroke.removeNumPadModifier()
        event.stroke = stroke
    # #868
    if stroke.isNumPadKey():
        return
    # Ignore unbound non-ascii character.
    if k.ignore_unbound_non_ascii_keys and not stroke.isPlainKey():
        return
    # Never insert escape or insert characters.
    if 'Escape' in stroke.s or 'Insert' in stroke.s:
        return
    #
    # Part 3: Handle the event depending on the pane and state.
    #
    # Handle events in the body pane.
    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
            c.frame.updateStatusLine()
        return
    #
    # Handle events in headlines.
    if name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return
    #
    # Handle events in the background tree (not headlines).
    if name.startswith('canvas'):
        if event.char:
            k.searchTree(event.char)
        # Not exactly right, but it seems to be good enough.
        elif not stroke:
            c.onCanvasKey(event)
        return
    #
    # Ignore all events outside the log pane.
    if not name.startswith('log'):
        return
    #
    # Make sure we can insert into w.
    log_w = event.widget
    if not hasattr(log_w, 'supportsHighLevelInterface'):
        return
    #
    # Send the event to the text widget, not the LeoLog instance.
    i = log_w.getInsertPoint()
    s = stroke.toGuiChar()
    log_w.insert(i, s)
</t>
<t tx="ekr.20200524151214.1"></t>
<t tx="ekr.20200727095246.1"></t>
<t tx="ekr.20200913074639.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1599

@language python
@nosearch
</t>
<t tx="ekr.20200913074701.1"># in appearance.py
# In effect, this is a subclass of QPlainTextEditor!

def paintEvent(self,event):
    """ paintEvent(event)

    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    super(IndentationGuides, self).paintEvent(event)

    if not self.showIndentationGuides():
        return

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    # Get multiplication factor and indent width
    indentWidth = self.indentWidth()
    if self.indentUsingSpaces():
        factor = 1
    else:
        factor = indentWidth

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    format = self.getStyleElementFormat('editor.IndentationGuides')
    pen = QtGui.QPen(format.fore)
    pen.setStyle(format.linestyle)
    painter.setPen(pen)
    offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        bd = cursor.block().userData()
        if bd and hasattr(bd, 'indentation') and bd.indentation:
            for x in range(indentWidth, bd.indentation * factor, indentWidth):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)

    # Done
    painter.end()
</t>
<t tx="ekr.20200913075121.1">def __init__(self,*args, **kwds):
    super(CodeEditorBase, self).__init__(*args)

    # Set font (always monospace)
    self.__zoom = 0
    self.setFont()

    # Create highlighter class
    self.__highlighter = Highlighter(self, self.document())

    # Set some document options
    option = self.document().defaultTextOption()
    option.setFlags(    option.flags() | option.IncludeTrailingSpaces |
                        option.AddSpaceForLineAndParagraphSeparators )
    self.document().setDefaultTextOption(option)

    # When the cursor position changes, invoke an update, so that
    # the hihghlighting etc will work
    self.cursorPositionChanged.connect(self.viewport().update)

    # Init styles to default values
    self.__style = {}
    for element in self.getStyleElementDescriptions():
        self.__style[element.key] = element.defaultFormat

    # Connext style update
    self.styleChanged.connect(self.__afterSetStyle)
    self.__styleChangedPending = False

    # Init margins
    self._leftmargins = []

    # Init options now.
    # NOTE TO PEOPLE DEVELOPING EXTENSIONS:
    # If an extension has an __init__ in which it first calls the
    # super().__init__, this __initOptions() function will be called,
    # while the extension's init is not yet finished.
    self.__initOptions(kwds)

    # Define colors from Solarized theme
    # NOTE TO PEOPLE WANTING CUSTOM COLORS: ignore this and check the
    # commented lines near the bottom of this method.
    base03  = "#002b36"
    base02  = "#073642"
    base01  = "#586e75"
    base00  = "#657b83"
    base0   = "#839496"
    base1   = "#93a1a1"
    base2   = "#eee8d5"
    base3   = "#fdf6e3"
    yellow  = "#b58900"
    orange  = "#cb4b16"
    red     = "#dc322f"  # noqa
    magenta = "#d33682"
    violet  = "#6c71c4"
    blue    = "#268bd2"
    cyan    = "#2aa198"
    green   = "#859900"  # noqa

    if 1: # EKR:patch: use a dark theme.
        back1, back2, back3 = base03, base02, base01
        fore1, fore2, fore3, fore4 = base0, base1, base2, base3  # noqa
    else:
        # Original code.
        #back1, back2, back3 = base3, base2, base1 # real solarised
        back1, back2, back3 = "#fff", base2, base1 # crispier
        fore1, fore2, fore3, fore4 = base00, base01, base02, base03

    # todo: proper testing of syntax style

    # Define style using "Solarized" colors
    S  = {}
    S["Editor.text"] = "back:%s, fore:%s" % (back1, fore1)
    S['Syntax.identifier'] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.nonidentifier"] = "fore:%s, bold:no, italic:no, underline:no" % fore2
    S["Syntax.keyword"] = "fore:%s, bold:yes, italic:no, underline:no" % fore2

    S["Syntax.builtins"] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.instance"] = "fore:%s, bold:no, italic:no, underline:no" % fore1

    S["Syntax.functionname"] = "fore:%s, bold:yes, italic:no, underline:no" % fore3
    S["Syntax.classname"] = "fore:%s, bold:yes, italic:no, underline:no" % orange

    S["Syntax.string"] = "fore:%s, bold:no, italic:no, underline:no" % violet
    S["Syntax.unterminatedstring"] = "fore:%s, bold:no, italic:no, underline:dotted" % violet
    S["Syntax.python.multilinestring"] = "fore:%s, bold:no, italic:no, underline:no" % blue

    S["Syntax.number"] = "fore:%s, bold:no, italic:no, underline:no" % cyan
    S["Syntax.comment"] = "fore:%s, bold:no, italic:no, underline:no" % yellow
    S["Syntax.todocomment"] = "fore:%s, bold:no, italic:yes, underline:no" % magenta
    S["Syntax.python.cellcomment"] = "fore:%s, bold:yes, italic:no, underline:full" % yellow

    S["Editor.Long line indicator"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Highlight current line"] = "back:%s" % back2
    S["Editor.Indentation guides"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Line numbers"] = "back:%s, fore:%s" % (back2, back3)

    # Define style using html color names. All 140 legal HTML colour
    # names can be used (in addition to HEX codes). A full list of
    # recognized colour names is available e.g. here
    # http://www.html-color-names.com/color-chart.php
#         S  = {}
#         S["Editor.text"] = "back: white, fore: black"
#         S['Syntax.identifier'] = "fore: black, bold:no, italic:no, underline:no"
#         S["Syntax.nonidentifier"] = "fore: blue, bold:no, italic:no, underline:no"
#         S["Syntax.keyword"] = "fore: blue, bold:yes, italic:no, underline:no"
#         S["Syntax.functionname"] = "fore: black, bold:yes, italic:no, underline:no"
#         S["Syntax.classname"] = "fore: magenta, bold:yes, italic:no, underline:no"
#         S["Syntax.string"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.unterminatedstring"] = "fore: red, bold:no, italic:no, underline:dotted"
#         S["Syntax.python.multilinestring"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.number"] = "fore: dark orange, bold:no, italic:no, underline:no"
#         S["Syntax.comment"] ="fore: green, bold:no, italic:yes, underline:no"
#         S["Syntax.todocomment"] = "fore: magenta, bold:no, italic:yes, underline:no"
#         S["Syntax.python.cellcomment"] = "fore: green, bold:yes, italic:no, underline:full"
#         S["Editor.Long line indicator"] = "linestyle:solid, fore: dark grey"
#         S["Editor.Highlight current line"] = "back: light grey"
#         S["Editor.Indentation guides"] = "linestyle:solid, fore: light grey"
#         S["Editor.Line numbers"] = "back: light grey, fore: black"

    # Apply style
    self.setStyle(S)
</t>
<t tx="ekr.20200913075250.1">def paintEvent(self, event):
    """
    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    ### super(IndentationGuides, self).paintEvent(event)
    super().paintEvent(event)
    return ###
    c = self.leo_c
    print('===== paintEvent', c.shortFileName())

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    ###
        # # Get multiplication factor and indent width
        # indentWidth = self.indentWidth()
        # if self.indentUsingSpaces():
            # factor = 1
        # else:
            # factor = indentWidth
    if c.tab_width &gt; 1: # Tabs
        ### editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
        ### editor.setIndentUsingSpaces(False)
        factor = 1
    else: # Spaces
        #### editor.setIndentWidth(indentWidth)
        ### editor.setIndentUsingSpaces(True)
        factor = 5 ### self.indentWidth()
    if 0:
        g.trace(factor)

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    if 1:
        pen = QtGui.QPen()
        pen.setWidthF(1)
        # pen.setColor(QtGui.QColor('red'))
        offset = 0 # doc.documentMargin() + self.contentOffset().x()
    else:
        format = self.getStyleElementFormat('editor.IndentationGuides')
        pen = QtGui.QPen(format.fore)
        pen.setStyle(format.linestyle) # QtCore.Qt.PenStyle.SolidLine
        painter.setPen(pen)
        offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        ### bd = cursor.block().userData()
        ### if bd and hasattr(bd, 'indentation') and bd.indentation:
        if True:
            ### for x in range(indentWidth, bd.indentation * factor, indentWidth):
            ### for x in range(5, 5*factor, 5):
            for x in (5, 10):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)
    # Done
    painter.end()
</t>
<t tx="ekr.20200913082124.1">def doForVisibleBlocks(self, function):
    """ doForVisibleBlocks(function)

    Call the given function(cursor) for all blocks that are currently
    visible. This is used by several appearence extensions that
    paint per block.

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    # Start cursor at top line.
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    cursor.movePosition(cursor.StartOfBlock)

    if not self.isVisible():
        return

    while True:
        # Call the function with a copy of the cursor
        function(QtGui.QTextCursor(cursor))

        # Go to the next block (or not if we are done)
        y = self.cursorRect(cursor).bottom()
        if y &gt; self.height():
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text
        cursor.movePosition(cursor.NextBlock)
</t>
<t tx="ekr.20200913082155.1">def doForVisibleBlocks(self, function):
    """ doForVisibleBlocks(function)

    Call the given function(cursor) for all blocks that are currently
    visible. This is used by several appearence extensions that
    paint per block.

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    # Start cursor at top line.
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    cursor.movePosition(cursor.StartOfBlock)

    if not self.isVisible():
        return

    while True:
        # Call the function with a copy of the cursor
        function(QtGui.QTextCursor(cursor))

        # Go to the next block (or not if we are done)
        y = self.cursorRect(cursor).bottom()
        if y &gt; self.height():
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text
        cursor.movePosition(cursor.NextBlock)
</t>
<t tx="ekr.20200914071303.1">def paintEvent(self, event):
    """
    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    ### super(IndentationGuides, self).paintEvent(event)
    super().paintEvent(event)
    return ###
    c = self.leo_c
    print('===== paintEvent', c.shortFileName())

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    ###
        # # Get multiplication factor and indent width
        # indentWidth = self.indentWidth()
        # if self.indentUsingSpaces():
            # factor = 1
        # else:
            # factor = indentWidth
    if c.tab_width &gt; 1: # Tabs
        ### editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
        ### editor.setIndentUsingSpaces(False)
        factor = 1
    else: # Spaces
        #### editor.setIndentWidth(indentWidth)
        ### editor.setIndentUsingSpaces(True)
        factor = 5 ### self.indentWidth()
    if 0:
        g.trace(factor)

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    if 1:
        pen = QtGui.QPen()
        pen.setWidthF(1)
        # pen.setColor(QtGui.QColor('red'))
        offset = 0 # doc.documentMargin() + self.contentOffset().x()
    else:
        format = self.getStyleElementFormat('editor.IndentationGuides')
        pen = QtGui.QPen(format.fore)
        pen.setStyle(format.linestyle) # QtCore.Qt.PenStyle.SolidLine
        painter.setPen(pen)
        offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        ### bd = cursor.block().userData()
        ### if bd and hasattr(bd, 'indentation') and bd.indentation:
        if True:
            ### for x in range(indentWidth, bd.indentation * factor, indentWidth):
            ### for x in range(5, 5*factor, 5):
            for x in (5, 10):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)
    # Done
    painter.end()
</t>
<t tx="ekr.20201012111545.1">@language python
@tabwidth -4
@pagewidth 80
</t>
<t tx="ekr.20201012111649.1">gnx: ekr.20170925083314.1
</t>
<t tx="ekr.20201012111649.3">gnx: ekr.20170925083853.1
</t>
<t tx="ekr.20201012114516.1">@nosearch</t>
<t tx="ekr.20201012142922.2">gnx: ekr.20201012111338.43
unl: Declarations (leo_cloud_server.py)
</t>
<t tx="ekr.20201013034659.1"></t>
<t tx="ekr.20201013034742.1"></t>
<t tx="ekr.20201013034742.10"># These can be overridden in subclasses.
</t>
<t tx="ekr.20201013034742.11">### Define an override if desired...

if 0: # The base class
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        return s.strip()
        
if 0: # A more complex example, for the C language.
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        import re
        type1 = r'(static|extern)*'
        type2 = r'(void|int|float|double|char)*'
        class_pattern = r'\s*(%s)\s*class\s+(\w+)' % (type1)
        pattern = r'\s*(%s)\s*(%s)\s*(\w+)' % (type1, type2)
        m = re.match(class_pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            return '%sclass %s' % (prefix1, m.group(2))
        m = re.match(pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            prefix2 = '%s ' % (m.group(2)) if m.group(2) else ''
            h = m.group(3) or '&lt;no c function name&gt;'
            return '%s%s%s' % (prefix1, prefix2, h)
        else:
            return s
</t>
<t tx="ekr.20201013034742.12">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an examplle.
    '''
    pass
</t>
<t tx="ekr.20201013034742.13">class {{cap_name}}_ScanState:
    '''A class representing the state of the {{name}} line-oriented scan.'''
    
    def __init__(self, d=None):
        '''{{cap_name}}_ScanState.__init__'''
        if d:
            prev = d.get('prev')
            self.context = prev.context
            ### Adjust these by hand.
            self.curlies = prev.curlies
        else:
            self.context = ''
            ### Adjust these by hand.
            self.curlies = 0

    def __repr__(self):
        '''{{cap_name}}_ScanState.__repr__'''
        ### Adjust these by hand.
        return "{{cap_name}}_ScanState context: %r curlies: %s" % (
            self.context, self.curlies)

    __str__ = __repr__

    @others
</t>
<t tx="ekr.20201013034742.14">def level(self):
    '''{{cap_name}}_ScanState.level.'''
    return {{state_ivar}}

</t>
<t tx="ekr.20201013034742.15">def update(self, data):
    '''
    {{cap_name}}_ScanState.update

    Update the state using the 6-tuple returned by v2_scan_line.
    Return i = data[1]
    '''
    context, i, delta_c, delta_p, delta_s, bs_nl = data
    # All ScanState classes must have a context ivar.
    self.context = context
    self.curlies += delta_c  
    ### Update {{cap_name}}_ScanState ivars
    # self.bs_nl = bs_nl
    # self.parens += delta_p
    # self.squares += delta_s
    return i
</t>
<t tx="ekr.20201013034742.16">'''Converts the word at the cursor to pep8 style throughout a given tree.'''
# aTestExample notFoundExample.
import re
# clear()
table = (
    # 'BLS.new_scan',
    # 'BLS.Code generation',
    # 'class Importer',
)
@others
Pep8(table, change=True).run()
</t>
<t tx="ekr.20201013034742.17">class Pep8:
    '''
    Convert the word under the cursor to pep8 style in all subtrees in
    table.
    '''
    
    def __init__ (self, table, change=False):
        '''Ctor for Pep8 class.'''
        self.change = change
        self.table = table
        
    @others
</t>
<t tx="ekr.20201013034742.18">def change_all(self, name, new_name, root):
    '''Change name to new_name throughout root's tree.'''
    u = c.undoer
    bunch = u.beforeChangeTree(root)
    found = False
    self.pattern = re.compile(r'\b%s\b' % name)
    for p in root.self_and_subtree():
        found = self.change_headline(name, new_name, p) or found
        found = self.change_body(name, new_name, p) or found
    if found:
        u.afterChangeTree(root, 'pep8', bunch)
    return found
</t>
<t tx="ekr.20201013034742.19">def change_body(self, name, new_name, p):
    indices = []
    for m in self.pattern.finditer(p.b):
        indices.append(str(m.start()))
    if indices:
        n = len(indices)
        g.es_print('%s change%s: %s' % (n, g.plural(n), p.h))
        s = p.b
        for i in reversed(indices):
            i = int(i)
            s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.b = s
            p.setDirty()
        else:
            g.es_print(s)
    return bool(indices)</t>
<t tx="ekr.20201013034742.2">g.cls()
# define constants that describe the new language.
name = 'php'
    # The name of the file, and the prefix for classes.
language = 'php'
    # The name of the language, case doesn't matter.
extensions = ['.php',]
    # A list of file extensions supported by this importer.
strict = False
    # True if leading whitespace is particularly significant.
state_ivar = 'self.curlies'
    # 'self.indent' for python, coffeescript.
    # 'self.curlies' for many other languages
    # '(self, curlies, self.parens)' for more complex comparisons
&lt;&lt; define run &amp; helpers &gt;&gt;
run(extensions, language, name, state_ivar)
</t>
<t tx="ekr.20201013034742.20">def change_headline(self, name, new_name, p):
    m = self.pattern.search(p.h)
    if m:
        i = m.start()
        s = p.h
        s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.h = s
            p.setDirty()
            g.es_print('changed headline', s)
        else:
            g.es_print('headline', s)
    return bool(m)
</t>
<t tx="ekr.20201013034742.21">def get_name(self):
    i, j = c.editCommands.extendToWord(event=None, select=False)
    w = c.frame.body.wrapper
    s = w.getAllText()
    name = s[i:j]
    return name
</t>
<t tx="ekr.20201013034742.22">def run(self):
    # self.clear()
    name = self.get_name()
    new_name = self.to_pep8(name)
    if len(name) &lt; 2:
        g.es_print('name too short:', name)
    elif new_name == name:
        g.es_print('already pep8:', name)
    else:
        g.es_print('%s -&gt; %s' % (name, new_name))
        c.findCommands.ftm.setFindText(new_name)
            # Preload the replacement text.
        found = False
        for target in table:
            root = g.findNodeAnywhere(c, target)
            if root:
                found = self.change_all(name, new_name, root) or found
            else:
                g.es_print('not found: %s' % target)
        if found:
            c.redraw()
        else:
            g.es_print('not found:', name)
</t>
<t tx="ekr.20201013034742.23">def to_pep8(self, s):
    
    if len(s) &gt; 1 and s[0].islower() and s.lower() != s:
        result = []
        for ch in s:
            result.append(ch)
            if ch.isupper():
                result.pop()
                result.append('_%s' % (ch.lower()))
        return ''.join(result)
    else:
        return name</t>
<t tx="ekr.20201013034742.24">def clear():
    g.cls()
    c.k.simulateCommand('clear-log')
</t>
<t tx="ekr.20201013034742.25"># g.cls()
import re
import sys
if 1:
    h = 'import-neural-networks.ipynb'
    fn = r'c:\test\export-neural-networds.ipynb'
else:
    h = 'import-Julia.ipynb'
    fn = r'c:\test\export-julia.ipynb'
p = g.findTopLevelNode(c, h)
assert p, h
@others
Export_IPYNB(c).export_outline(p, fn=fn)
</t>
<t tx="ekr.20201013034742.26">'''Imports c:\prog\Julia.ipynb to the node import-Julia.ipynb'''
import nbformat
@others
g.cls()
if 0:
    # fn = r'c:\test\Julia.ipynb'
    fn = r'c:\test\export-neural-networds.ipynb'
    h = 'import-Julia.ipynb'
else:
    h = fn = r'c:\test\04_Neural_Networks.ipynb'
root = g.findTopLevelNode(c, h)
if root:
    while root.hasChildren():
        root.lastChild().doDelete()
else:
    p = c.lastTopLevel()
    root = p.insertAfter()
    root.h = h
x = Import_IPYNB(c)
x.import_file(fn, root)
if not g.unitTesting:
    # These don't work when running unit tests.
    c.selectPosition(root)
    # c.expandAllSubheads()
    c.redraw() 
    g.es_print('done')
</t>
<t tx="ekr.20201013034742.3">@others</t>
<t tx="ekr.20201013034742.4">def copy_tree(source, root, h):
    '''Copy the source tree to the node after p, with headline h.'''
    p2 = root.insertAfter()
    source.copyTreeFromSelfTo(p2)
    p2.h = h
    return p2
 </t>
<t tx="ekr.20201013034742.5">def make_substitutions(destination, patterns):
    '''Make all substitutions in the destination tree.'''
    for p in destination.self_and_subtree():
        h = substitute(p.h, patterns)
        if p.h != h:
            # g.trace('CHANGED:', p.h, '==&gt;', h)
            p.h = h
        b = substitute(p.b, patterns)
        if p.b != b:
            # g.trace('CHANGED:', p.b, '==&gt;', b)
            p.b = b
</t>
<t tx="ekr.20201013034742.6">def run(extensions, language, name, state_ivar):
    '''The driver for this script.'''
    patterns = {
        'cap_name': name.capitalize(),
        'extensions': '[%s]' % ', '.join(["'%s'" % (z) for z in extensions]),
        'language': language.lower(),
        'name': name.lower(),
        'strict': 'True' if strict else 'False',
        'state_ivar': state_ivar,
    }
    h = '@button make-importer'
    root = g.findNodeAnywhere(c, h)
    assert root, h
    h = '@@file importers/{{name}}.py'
    source = g.findNodeInTree(c, root, h)
    assert source, h
    destination = copy_tree(source, root, h)
    make_substitutions(destination, patterns)
    c.contractAllHeadlines()
    c.redraw()</t>
<t tx="ekr.20201013034742.7">def substitute(s, patterns):
    '''Make all substitutions in s.'''
    for pattern in patterns:
        find = '{{%s}}' % pattern
        replace = patterns.get(pattern)
        i = 0
        while i &lt; len(s):
            progress = i
            j = s.find(find, i)
            if j == -1: break
            s = s[:j] + replace + s[j+len(find):]
            i = j+len(replace)
            assert progress &lt; i
    return s
</t>
<t tx="ekr.20201013034742.8">'''The @auto importer for the {{name}} language.'''
import leo.plugins.importers.linescanner as linescanner
Importer = linescanner.Importer
@others
importer_dict = {
    'class': {{cap_name}}_Importer,
    'extensions': {{extensions}},
}
@language python
@tabwidth -4


</t>
<t tx="ekr.20201013034742.9">class {{cap_name}}_Importer(Importer):
    '''The importer for the {{name}} lanuage.'''

    def __init__(self, importCommands, atAuto):
        '''{{cap_name}}_Importer.__init__'''
        # Init the base class.
        Importer.__init__(self,
            importCommands,
            atAuto = atAuto,
            language = '{{language}}',
            state_class = {{cap_name}}_ScanState,
            strict = {{strict}},
        )
        
    @others
</t>
<t tx="ekr.20201015145257.1">import leo.core.leoImport as leoImport
import importlib
importlib.reload(leoImport)
g.cls()
# Change path as necessary.
path = r'c:\users\edreamleo\lsa.py'
assert g.os_path_exists(path)
x = leoImport.LegacyExternalFileImporter(c)
x.import_file(path)
</t>
<t tx="ekr.20201018062305.1">"""Update LeoPyRef.leo from the given list of nodes."""
import os
@others
main(node_list = ['Startup', 'Notes', 'Code'])
</t>
<t tx="ekr.20201018063747.1">def get_content(positions_list):
    """
    Return the desired contents of leoPyRef.leo.
    
    Based on code by  .
    """
    # Make only one copy for all calls.
    fc = c.fileCommands
    fc.currentPosition = c.p
    fc.rootPosition = c.rootPosition()
    fc.vnodesDict = {}
    # Put the file
    fc.outputFile = g.FileLikeObject()
    fc.putProlog()
    fc.putHeader()
    fc.putGlobals()
    fc.putPrefs()
    fc.putFindSettings()
    fc.put("&lt;vnodes&gt;\n")
    for p in positions_list:
        # An optimization: Write the next top-level node.
        fc.putVnode(p, isIgnore=p.isAtIgnoreNode())
    fc.put("&lt;/vnodes&gt;\n")
    fc.putTnodes()
    fc.putPostlog()
    return fc.outputFile.getvalue()
</t>
<t tx="ekr.20201018065757.1">def check_file_names():
    """Return True if leoPyRef exists and we are running from leoPy.leo."""
    if not 'leoPy.leo' in c.shortFileName():
        oops('Run this script only from leoPy.leo')
        return None
    fileName = g.os_path_finalize_join(g.app.loadDir, '..', 'core', 'leoPyRef.leo')
    if not os.path.exists(fileName):
        oops(f"Not found: {fileName}")
        return None
    return fileName</t>
<t tx="ekr.20201018065921.1">def check_nodes(node_list):
    """Return True if all nodes are found."""
    result = []
    for node in node_list:
        p = g.findTopLevelNode(c, node, exact=True)
        if p:
            result.append(p.copy())
        else:
            oops(f"Top-level node {node} not found")
            return []
    return result</t>
<t tx="ekr.20201018070822.1">def main(node_list):
    """The main line."""
    c.endEditing()
    fileName = check_file_names()
    if not fileName:
        return
    positions_list = check_nodes(node_list)
    if not positions_list:
        return
    content = get_content(positions_list)
    with open(fileName, 'w', encoding="utf-8", newline='\n') as f:
        f.write(content)
    print('')
    g.es_print(f"Updated {g.shortFileName(fileName)}")
</t>
<t tx="ekr.20201018072911.1">def oops(message):
    """Print an error message"""
    print('')
    g.es_print(message)
    print('')</t>
<t tx="ekr.20201021075956.1"># Leo colorizer control file for php mode.
# This file is in the public domain.

# **Important**: this file was **not** generated by jEdit2py.
# It contains "by-hand" changes at the end of the file marked with "EKR".

@others
if use_php_hack:
    # EKR: in effect: we replace the php_main state by the php_php state.
    # php_main_keywords_dict = php_php_keywords_dict
    rulesDictDict['php_main'] = rulesDict4 # EKR: was php_rulesDict1
@language python
@tabwidth -4
</t>
<t tx="ekr.20201021093630.1"></t>
<t tx="ekr.20201022053829.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1718

@language python
@nosearch
</t>
<t tx="ekr.20201022053907.1"># Leo colorizer control file for php mode.
# This file is in the public domain.

# **Important**: this file was **not** generated by jEdit2py.
# It contains "by-hand" changes by EKR.
&lt;&lt; Attribute dicts &gt;&gt;
&lt;&lt; Keyword dicts &gt;&gt;
@others
&lt;&lt; rulesDictDict &gt;&gt;
# Import dict for php mode.
importDict = {
    "php_javascript_php": ["javascript::main",],
}
if False:
    # EKR: in effect: we replace the php_main state by the php_php state.
    # php_main_keywords_dict = php_php_keywords_dict
    rulesDictDict['php_main'] = php_php_rulesdict

@language python
@tabwidth -4
</t>
<t tx="ekr.20201022053907.10">def php_php_function_rule(colorer, s, i):
    return colorer.match_mark_previous(s, i, kind="function", pattern="(",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

def php_php_keyword_rule1(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

def php_php_keyword_rule2(colorer, s, i):
    return colorer.match_keywords(s, i)
</t>
<t tx="ekr.20201022053907.11">def php_php_op1(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op2(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op3(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="!",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op4(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op5(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op6(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op7(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="+",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op8(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op9(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op10(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op11(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op12(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op13(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="%",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op14(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&amp;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op15(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="|",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op16(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="^",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op17(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="~",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op18(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=".",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op19(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="}",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op20(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op21(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=",",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op22(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op23(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="]",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op24(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="[",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op25(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="?",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op26(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="@",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def php_php_op27(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=":",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
</t>
<t tx="ekr.20201022053907.12"># Rules dict for php_php ruleset.
php_php_rulesdict = {
    "!": [php_php_op3],
    "\"": [php_php_literal1],
    "#": [php_php_comment4],
    "$": [php_php_keyword_rule1],
    "%": [php_php_op13],
    "&amp;": [php_php_op14],
    "'": [php_php_literal2],
    "(": [php_php_function_rule],
    "*": [php_php_op10],
    "+": [php_php_op7],
    ",": [php_php_op21],
    "-": [php_php_op2, php_php_op8],
    ".": [php_php_op18],
    "/": [php_php_comment1, php_php_comment2, php_php_comment3, php_php_op9],
    "0": [php_php_keyword_rule2],
    "1": [php_php_keyword_rule2],
    "2": [php_php_keyword_rule2],
    "3": [php_php_keyword_rule2],
    "4": [php_php_keyword_rule2],
    "5": [php_php_keyword_rule2],
    "6": [php_php_keyword_rule2],
    "7": [php_php_keyword_rule2],
    "8": [php_php_keyword_rule2],
    "9": [php_php_keyword_rule2],
    ":": [php_php_op27],
    ";": [php_php_op22],
    "&lt;": [php_php_op5, php_php_op12],
    "&lt; ": [php_php_literal4],
    "=": [php_php_op1, php_php_op6],
    "&gt;": [php_php_op4, php_php_op11],
    "?": [php_php_op25],
    "@": [php_php_op26, php_php_keyword_rule2],
    "A": [php_php_keyword_rule2],
    "B": [php_php_keyword_rule2],
    "C": [php_php_keyword_rule2],
    "D": [php_php_keyword_rule2],
    "E": [php_php_keyword_rule2],
    "F": [php_php_keyword_rule2],
    "G": [php_php_keyword_rule2],
    "H": [php_php_keyword_rule2],
    "I": [php_php_keyword_rule2],
    "J": [php_php_keyword_rule2],
    "K": [php_php_keyword_rule2],
    "L": [php_php_keyword_rule2],
    "M": [php_php_keyword_rule2],
    "N": [php_php_keyword_rule2],
    "O": [php_php_keyword_rule2],
    "P": [php_php_keyword_rule2],
    "Q": [php_php_keyword_rule2],
    "R": [php_php_keyword_rule2],
    "S": [php_php_keyword_rule2],
    "T": [php_php_keyword_rule2],
    "U": [php_php_keyword_rule2],
    "V": [php_php_keyword_rule2],
    "W": [php_php_keyword_rule2],
    "X": [php_php_keyword_rule2],
    "Y": [php_php_keyword_rule2],
    "Z": [php_php_keyword_rule2],
    "[": [php_php_op24],
    "]": [php_php_op23],
    "^": [php_php_op16],
    "_": [php_php_keyword_rule2],
    "`": [php_php_literal3],
    "a": [php_php_keyword_rule2],
    "b": [php_php_keyword_rule2],
    "c": [php_php_keyword_rule2],
    "d": [php_php_keyword_rule2],
    "e": [php_php_keyword_rule2],
    "f": [php_php_keyword_rule2],
    "g": [php_php_keyword_rule2],
    "h": [php_php_keyword_rule2],
    "i": [php_php_keyword_rule2],
    "j": [php_php_keyword_rule2],
    "k": [php_php_keyword_rule2],
    "l": [php_php_keyword_rule2],
    "m": [php_php_keyword_rule2],
    "n": [php_php_keyword_rule2],
    "o": [php_php_keyword_rule2],
    "p": [php_php_keyword_rule2],
    "q": [php_php_keyword_rule2],
    "r": [php_php_keyword_rule2],
    "s": [php_php_keyword_rule2],
    "t": [php_php_keyword_rule2],
    "u": [php_php_keyword_rule2],
    "v": [php_php_keyword_rule2],
    "w": [php_php_keyword_rule2],
    "x": [php_php_keyword_rule2],
    "y": [php_php_keyword_rule2],
    "z": [php_php_keyword_rule2],
    "{": [php_php_op20],
    "|": [php_php_op15],
    "}": [php_php_op19],
    "~": [php_php_op17],
}
</t>
<t tx="ekr.20201022053907.13"># Rules for the php_php_literal ruleset.

def php_php_literal_rule1(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

# Rules dict for php_php_literal ruleset.
php_php_literal_rulesdict = {
    "$": [php_php_literal_rule1],
}
</t>
<t tx="ekr.20201022053907.14"># Rules for the php_javascript_php ruleset...

def php_javascript_php_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_javascript_php_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_javascript_php_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

# Rules dict for php_javascript_php ruleset.
php_javascript_php_rulesdict = {
    "&lt;": [
        php_javascript_php_rule1,
        php_javascript_php_rule2,
        php_javascript_php_rule3],
}
</t>
<t tx="ekr.20201022053907.15"># Rules for the php_javascript ruleset...

def php_rule58(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::javascript+php")

def php_rule59(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="SRC=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::back_to_html")

# Rules dict for php_javascript ruleset.
php_javascript_rulesdict = {
    "&gt;": [php_rule58],
    "S": [php_rule59],
}

</t>
<t tx="ekr.20201022053907.16">def phpdoc_rule1(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def phpdoc_rule2(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def phpdoc_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def phpdoc_rule4(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

def phpdoc_rule5(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
        
def phpdoc_rule6(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt; ",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
        
def phpdoc_rule7(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::tags",exclude_match=False,
        no_escape=False, no_line_break=True, no_word_break=False)
        
def phpdoc_rule8(colorer, s, i):
    return colorer.match_keywords(s, i)
    
# Rules dict for php_phpdoc ruleset.
phpdoc_rulesdict = {
    "*": [phpdoc_rule2],
    "0": [phpdoc_rule8],
    "1": [phpdoc_rule8],
    "2": [phpdoc_rule8],
    "3": [phpdoc_rule8],
    "4": [phpdoc_rule8],
    "5": [phpdoc_rule8],
    "6": [phpdoc_rule8],
    "7": [phpdoc_rule8],
    "8": [phpdoc_rule8],
    "9": [phpdoc_rule8],
    "&lt;": [phpdoc_rule3,phpdoc_rule4,phpdoc_rule5,phpdoc_rule6,phpdoc_rule7],
    "@": [phpdoc_rule8],
    "A": [phpdoc_rule8],
    "B": [phpdoc_rule8],
    "C": [phpdoc_rule8],
    "D": [phpdoc_rule8],
    "E": [phpdoc_rule8],
    "F": [phpdoc_rule8],
    "G": [phpdoc_rule8],
    "H": [phpdoc_rule8],
    "I": [phpdoc_rule8],
    "J": [phpdoc_rule8],
    "K": [phpdoc_rule8],
    "L": [phpdoc_rule8],
    "M": [phpdoc_rule8],
    "N": [phpdoc_rule8],
    "O": [phpdoc_rule8],
    "P": [phpdoc_rule8],
    "Q": [phpdoc_rule8],
    "R": [phpdoc_rule8],
    "S": [phpdoc_rule8],
    "T": [phpdoc_rule8],
    "U": [phpdoc_rule8],
    "V": [phpdoc_rule8],
    "W": [phpdoc_rule8],
    "X": [phpdoc_rule8],
    "Y": [phpdoc_rule8],
    "Z": [phpdoc_rule8],
    "_": [phpdoc_rule8],
    "a": [phpdoc_rule8],
    "b": [phpdoc_rule8],
    "c": [phpdoc_rule8],
    "d": [phpdoc_rule8],
    "e": [phpdoc_rule8],
    "f": [phpdoc_rule8],
    "g": [phpdoc_rule8],
    "h": [phpdoc_rule8],
    "i": [phpdoc_rule8],
    "j": [phpdoc_rule8],
    "k": [phpdoc_rule8],
    "l": [phpdoc_rule8],
    "m": [phpdoc_rule8],
    "n": [phpdoc_rule8],
    "o": [phpdoc_rule8],
    "p": [phpdoc_rule8],
    "q": [phpdoc_rule8],
    "r": [phpdoc_rule8],
    "s": [phpdoc_rule8],
    "t": [phpdoc_rule8],
    "u": [phpdoc_rule8],
    "v": [phpdoc_rule8],
    "w": [phpdoc_rule8],
    "x": [phpdoc_rule8],
    "y": [phpdoc_rule8],
    "z": [phpdoc_rule8],
    "{": [phpdoc_rule1],
}
</t>
<t tx="ekr.20201022053907.17"># rulesDictDict for php mode.
rulesDictDict = {
    "php_javascript": php_javascript_rulesdict,
    "php_javascript_php": php_javascript_php_rulesdict,
    "php_main": php_main_rulesdict,
    "php_php": php_php_rulesdict,
    "php_php_literal": php_php_literal_rulesdict,
    "php_phpdoc": phpdoc_rulesdict,
    "php_tags": php_tags_rulesdict,
    "php_tags_literal": php_tags_literal_rulesdict,
}
</t>
<t tx="ekr.20201022053907.2">

# Properties for php mode.
properties = {
    "commentEnd": "--&gt;",
    "commentStart": "&lt;!--",
    "indentCloseBrackets": "}",
    "indentOpenBrackets": "{",
    "lineUpClosingBracket": "true",
}

# Attributes dict for php_main ruleset.
php_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags ruleset.
php_tags_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags_literal ruleset.
php_tags_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php ruleset.
php_php_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php_literal ruleset.
php_php_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript ruleset.
php_javascript_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript_php ruleset.
php_javascript_php_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_phpdoc ruleset.
php_phpdoc_attributes_dict = {
    "default": "COMMENT3",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Dictionary of attributes dictionaries for php mode.
attributesDictDict = {
    "php_javascript": php_javascript_attributes_dict,
    "php_javascript_php": php_javascript_php_attributes_dict,
    "php_main": php_main_attributes_dict,
    "php_php": php_php_attributes_dict,
    "php_php_literal": php_php_literal_attributes_dict,
    "php_phpdoc": php_phpdoc_attributes_dict,
    "php_tags": php_tags_attributes_dict,
    "php_tags_literal": php_tags_literal_attributes_dict,
}
</t>
<t tx="ekr.20201022053907.3"># Keywords dict for php_main ruleset.
php_main_keywords_dict = {}

# Keywords dict for php_tags ruleset.
php_tags_keywords_dict = {}

# Keywords dict for php_tags_literal ruleset.
php_tags_literal_keywords_dict = {}

# Keywords dict for php_php ruleset.
php_php_keywords_dict = {
    "__class__": "keyword3",
    "__file__": "keyword3",
    "__function__": "keyword3",
    "__line__": "keyword3",
    "__method__": "keyword3",
    "abs": "keyword2",
    "abstract": "keyword1",
    "accept_connect": "keyword2",
    "acos": "keyword2",
    "add": "keyword2",
    "add_iovec": "keyword2",
    "addaction": "keyword2",
    "addcolor": "keyword2",
    "addcslashes": "keyword2",
    "addentry": "keyword2",
    "addfill": "keyword2",
    "addshape": "keyword2",
    "addslashes": "keyword2",
    "addstring": "keyword2",
    "align": "keyword2",
    "and": "operator",
    "apache_child_terminate": "keyword2",
    "apache_lookup_uri": "keyword2",
    "apache_note": "keyword2",
    "apache_sub_req": "keyword2",
    "array": "keyword1",
    "array_combine": "keyword2",
    "array_count_values": "keyword2",
    "array_diff": "keyword2",
    "array_diff_assoc": "keyword2",
    "array_diff_uassoc": "keyword2",
    "array_filter": "keyword2",
    "array_flip": "keyword2",
    "array_intersect": "keyword2",
    "array_intersect_assoc": "keyword2",
    "array_keys": "keyword2",
    "array_map": "keyword2",
    "array_merge": "keyword2",
    "array_merge_recursive": "keyword2",
    "array_multisort": "keyword2",
    "array_pad": "keyword2",
    "array_pop": "keyword2",
    "array_push": "keyword2",
    "array_rand": "keyword2",
    "array_reduce": "keyword2",
    "array_reverse": "keyword2",
    "array_search": "keyword2",
    "array_shift": "keyword2",
    "array_slice": "keyword2",
    "array_splice": "keyword2",
    "array_sum": "keyword2",
    "array_udiff": "keyword2",
    "array_udiff_assoc": "keyword2",
    "array_udiff_uassoc": "keyword2",
    "array_unique": "keyword2",
    "array_unshift": "keyword2",
    "array_values": "keyword2",
    "array_walk": "keyword2",
    "array_walk_recursive": "keyword2",
    "arsort": "keyword2",
    "as": "keyword1",
    "asin": "keyword2",
    "asort": "keyword2",
    "aspell_check": "keyword2",
    "aspell_check_raw": "keyword2",
    "aspell_new": "keyword2",
    "aspell_suggest": "keyword2",
    "assert": "keyword2",
    "assert_options": "keyword2",
    "atan": "keyword2",
    "atan2": "keyword2",
    "base64_decode": "keyword2",
    "base64_encode": "keyword2",
    "base_convert": "keyword2",
    "basename": "keyword2",
    "bcadd": "keyword2",
    "bccomp": "keyword2",
    "bcdiv": "keyword2",
    "bcmod": "keyword2",
    "bcmul": "keyword2",
    "bcpow": "keyword2",
    "bcscale": "keyword2",
    "bcsqrt": "keyword2",
    "bcsub": "keyword2",
    "bin2hex": "keyword2",
    "bind": "keyword2",
    "bindec": "keyword2",
    "bindtextdomain": "keyword2",
    "break": "keyword1",
    "build_iovec": "keyword2",
    "bzclose": "keyword2",
    "bzcompress": "keyword2",
    "bzdecompress": "keyword2",
    "bzerrno": "keyword2",
    "bzerror": "keyword2",
    "bzerrstr": "keyword2",
    "bzflush": "keyword2",
    "bzopen": "keyword2",
    "bzread": "keyword2",
    "bzwrite": "keyword2",
    "call_user_func": "keyword2",
    "call_user_func_array": "keyword2",
    "call_user_method": "keyword2",
    "call_user_method_array": "keyword2",
    "case": "keyword1",
    "catch": "keyword1",
    "ccvs_add": "keyword2",
    "ccvs_auth": "keyword2",
    "ccvs_command": "keyword2",
    "ccvs_count": "keyword2",
    "ccvs_delete": "keyword2",
    "ccvs_done": "keyword2",
    "ccvs_init": "keyword2",
    "ccvs_lookup": "keyword2",
    "ccvs_new": "keyword2",
    "ccvs_report": "keyword2",
    "ccvs_return": "keyword2",
    "ccvs_reverse": "keyword2",
    "ccvs_sale": "keyword2",
    "ccvs_status": "keyword2",
    "ccvs_textvalue": "keyword2",
    "ccvs_void": "keyword2",
    "ceil": "keyword2",
    "chdir": "keyword2",
    "checkdate": "keyword2",
    "checkdnsrr": "keyword2",
    "chgrp": "keyword2",
    "chmod": "keyword2",
    "chop": "keyword2",
    "chown": "keyword2",
    "chr": "keyword2",
    "chroot": "keyword2",
    "chunk_split": "keyword2",
    "class": "keyword1",
    "class_exists": "keyword2",
    "clearstatcache": "keyword2",
    "clone": "keyword1",
    "close": "keyword2",
    "closedir": "keyword2",
    "closelog": "keyword2",
    "com_get": "keyword2",
    "com_invoke": "keyword2",
    "com_load": "keyword2",
    "com_propget": "keyword2",
    "com_propput": "keyword2",
    "com_propset": "keyword2",
    "com_set": "keyword2",
    "compact": "keyword2",
    "confirm_cybermut_compiled": "keyword2",
    "confirm_extname_compiled": "keyword2",
    "connect": "keyword2",
    "connection_aborted": "keyword2",
    "connection_status": "keyword2",
    "const": "keyword1",
    "constant": "keyword2",
    "continue": "keyword1",
    "convert_cyr_string": "keyword2",
    "convert_uudecode": "keyword2",
    "convert_uuencode": "keyword2",
    "copy": "keyword2",
    "cos": "keyword2",
    "count": "keyword2",
    "count_chars": "keyword2",
    "cpdf_add_annotation": "keyword2",
    "cpdf_add_outline": "keyword2",
    "cpdf_arc": "keyword2",
    "cpdf_begin_text": "keyword2",
    "cpdf_circle": "keyword2",
    "cpdf_clip": "keyword2",
    "cpdf_close": "keyword2",
    "cpdf_closepath": "keyword2",
    "cpdf_closepath_fill_stroke": "keyword2",
    "cpdf_closepath_stroke": "keyword2",
    "cpdf_continue_text": "keyword2",
    "cpdf_curveto": "keyword2",
    "cpdf_end_text": "keyword2",
    "cpdf_fill": "keyword2",
    "cpdf_fill_stroke": "keyword2",
    "cpdf_finalize": "keyword2",
    "cpdf_finalize_page": "keyword2",
    "cpdf_global_set_document_limits": "keyword2",
    "cpdf_import_jpeg": "keyword2",
    "cpdf_lineto": "keyword2",
    "cpdf_moveto": "keyword2",
    "cpdf_newpath": "keyword2",
    "cpdf_open": "keyword2",
    "cpdf_output_buffer": "keyword2",
    "cpdf_page_init": "keyword2",
    "cpdf_place_inline_image": "keyword2",
    "cpdf_rect": "keyword2",
    "cpdf_restore": "keyword2",
    "cpdf_rlineto": "keyword2",
    "cpdf_rmoveto": "keyword2",
    "cpdf_rotate": "keyword2",
    "cpdf_rotate_text": "keyword2",
    "cpdf_save": "keyword2",
    "cpdf_save_to_file": "keyword2",
    "cpdf_scale": "keyword2",
    "cpdf_set_action_url": "keyword2",
    "cpdf_set_char_spacing": "keyword2",
    "cpdf_set_creator": "keyword2",
    "cpdf_set_current_page": "keyword2",
    "cpdf_set_font": "keyword2",
    "cpdf_set_font_directories": "keyword2",
    "cpdf_set_font_map_file": "keyword2",
    "cpdf_set_horiz_scaling": "keyword2",
    "cpdf_set_keywords": "keyword2",
    "cpdf_set_leading": "keyword2",
    "cpdf_set_page_animation": "keyword2",
    "cpdf_set_subject": "keyword2",
    "cpdf_set_text_matrix": "keyword2",
    "cpdf_set_text_pos": "keyword2",
    "cpdf_set_text_rendering": "keyword2",
    "cpdf_set_text_rise": "keyword2",
    "cpdf_set_title": "keyword2",
    "cpdf_set_viewer_preferences": "keyword2",
    "cpdf_set_word_spacing": "keyword2",
    "cpdf_setdash": "keyword2",
    "cpdf_setflat": "keyword2",
    "cpdf_setgray": "keyword2",
    "cpdf_setgray_fill": "keyword2",
    "cpdf_setgray_stroke": "keyword2",
    "cpdf_setlinecap": "keyword2",
    "cpdf_setlinejoin": "keyword2",
    "cpdf_setlinewidth": "keyword2",
    "cpdf_setmiterlimit": "keyword2",
    "cpdf_setrgbcolor": "keyword2",
    "cpdf_setrgbcolor_fill": "keyword2",
    "cpdf_setrgbcolor_stroke": "keyword2",
    "cpdf_show": "keyword2",
    "cpdf_show_xy": "keyword2",
    "cpdf_stringwidth": "keyword2",
    "cpdf_stroke": "keyword2",
    "cpdf_text": "keyword2",
    "cpdf_translate": "keyword2",
    "crack_check": "keyword2",
    "crack_closedict": "keyword2",
    "crack_getlastmessage": "keyword2",
    "crack_opendict": "keyword2",
    "crash": "keyword2",
    "crc32": "keyword2",
    "create_function": "keyword2",
    "crypt": "keyword2",
    "ctype_alnum": "keyword2",
    "ctype_alpha": "keyword2",
    "ctype_cntrl": "keyword2",
    "ctype_digit": "keyword2",
    "ctype_graph": "keyword2",
    "ctype_lower": "keyword2",
    "ctype_print": "keyword2",
    "ctype_punct": "keyword2",
    "ctype_space": "keyword2",
    "ctype_upper": "keyword2",
    "ctype_xdigit": "keyword2",
    "curl_close": "keyword2",
    "curl_errno": "keyword2",
    "curl_error": "keyword2",
    "curl_exec": "keyword2",
    "curl_getinfo": "keyword2",
    "curl_init": "keyword2",
    "curl_setopt": "keyword2",
    "curl_version": "keyword2",
    "current": "keyword2",
    "cv_add": "keyword2",
    "cv_auth": "keyword2",
    "cv_command": "keyword2",
    "cv_count": "keyword2",
    "cv_delete": "keyword2",
    "cv_done": "keyword2",
    "cv_init": "keyword2",
    "cv_lookup": "keyword2",
    "cv_new": "keyword2",
    "cv_report": "keyword2",
    "cv_return": "keyword2",
    "cv_reverse": "keyword2",
    "cv_sale": "keyword2",
    "cv_status": "keyword2",
    "cv_textvalue": "keyword2",
    "cv_void": "keyword2",
    "cybercash_base64_decode": "keyword2",
    "cybercash_base64_encode": "keyword2",
    "cybercash_decr": "keyword2",
    "cybercash_encr": "keyword2",
    "cybermut_creerformulairecm": "keyword2",
    "cybermut_creerreponsecm": "keyword2",
    "cybermut_testmac": "keyword2",
    "date": "keyword2",
    "dba_close": "keyword2",
    "dba_delete": "keyword2",
    "dba_exists": "keyword2",
    "dba_fetch": "keyword2",
    "dba_firstkey": "keyword2",
    "dba_insert": "keyword2",
    "dba_nextkey": "keyword2",
    "dba_open": "keyword2",
    "dba_optimize": "keyword2",
    "dba_popen": "keyword2",
    "dba_replace": "keyword2",
    "dba_sync": "keyword2",
    "dbase_add_record": "keyword2",
    "dbase_close": "keyword2",
    "dbase_create": "keyword2",
    "dbase_delete_record": "keyword2",
    "dbase_get_record": "keyword2",
    "dbase_get_record_with_names": "keyword2",
    "dbase_numfields": "keyword2",
    "dbase_numrecords": "keyword2",
    "dbase_open": "keyword2",
    "dbase_pack": "keyword2",
    "dbase_replace_record": "keyword2",
    "dblist": "keyword2",
    "dbmclose": "keyword2",
    "dbmdelete": "keyword2",
    "dbmexists": "keyword2",
    "dbmfetch": "keyword2",
    "dbmfirstkey": "keyword2",
    "dbminsert": "keyword2",
    "dbmnextkey": "keyword2",
    "dbmopen": "keyword2",
    "dbmreplace": "keyword2",
    "dbx_close": "keyword2",
    "dbx_cmp_asc": "keyword2",
    "dbx_cmp_desc": "keyword2",
    "dbx_connect": "keyword2",
    "dbx_error": "keyword2",
    "dbx_query": "keyword2",
    "dbx_sort": "keyword2",
    "dcgettext": "keyword2",
    "debug_backtrace": "keyword2",
    "debug_print_backtrace": "keyword2",
    "decbin": "keyword2",
    "dechex": "keyword2",
    "declare": "keyword1",
    "decoct": "keyword2",
    "default": "keyword1",
    "define": "keyword2",
    "define_syslog_variables": "keyword2",
    "defined": "keyword2",
    "deg2rad": "keyword2",
    "delete_iovec": "keyword2",
    "dgettext": "keyword2",
    "die": "keyword2",
    "dir": "keyword2",
    "dirname": "keyword2",
    "diskfreespace": "keyword2",
    "display_disabled_function": "keyword2",
    "dl": "keyword2",
    "do": "keyword1",
    "domxml_add_root": "keyword2",
    "domxml_attributes": "keyword2",
    "domxml_children": "keyword2",
    "domxml_dumpmem": "keyword2",
    "domxml_elem_get_attribute": "keyword2",
    "domxml_elem_set_attribute": "keyword2",
    "domxml_get_attribute": "keyword2",
    "domxml_getattr": "keyword2",
    "domxml_new_child": "keyword2",
    "domxml_new_xmldoc": "keyword2",
    "domxml_node": "keyword2",
    "domxml_node_attributes": "keyword2",
    "domxml_node_children": "keyword2",
    "domxml_node_new_child": "keyword2",
    "domxml_node_set_content": "keyword2",
    "domxml_node_unlink_node": "keyword2",
    "domxml_root": "keyword2",
    "domxml_set_attribute": "keyword2",
    "domxml_setattr": "keyword2",
    "domxml_unlink_node": "keyword2",
    "domxml_version": "keyword2",
    "doubleval": "keyword2",
    "drawarc": "keyword2",
    "drawcircle": "keyword2",
    "drawcubic": "keyword2",
    "drawcubicto": "keyword2",
    "drawcurve": "keyword2",
    "drawcurveto": "keyword2",
    "drawglyph": "keyword2",
    "drawline": "keyword2",
    "drawlineto": "keyword2",
    "each": "keyword2",
    "easter_date": "keyword2",
    "easter_days": "keyword2",
    "echo": "keyword1",
    "else": "keyword1",
    "elseif": "keyword1",
    "empty": "keyword1",
    "end": "keyword2",
    "endfor": "keyword1",
    "endforeach": "keyword1",
    "endif": "keyword1",
    "endswitch": "keyword1",
    "endwhile": "keyword1",
    "ereg": "keyword2",
    "ereg_replace": "keyword2",
    "eregi": "keyword2",
    "eregi_replace": "keyword2",
    "error_log": "keyword2",
    "error_reporting": "keyword2",
    "escapeshellarg": "keyword2",
    "escapeshellcmd": "keyword2",
    "exec": "keyword2",
    "exit": "keyword2",
    "exp": "keyword2",
    "explode": "keyword2",
    "extends": "keyword1",
    "extension_loaded": "keyword2",
    "extract": "keyword2",
    "ezmlm_hash": "keyword2",
    "false": "keyword3",
    "fbsql": "keyword2",
    "fbsql_affected_rows": "keyword2",
    "fbsql_autocommit": "keyword2",
    "fbsql_close": "keyword2",
    "fbsql_commit": "keyword2",
    "fbsql_connect": "keyword2",
    "fbsql_create_db": "keyword2",
    "fbsql_data_seek": "keyword2",
    "fbsql_database": "keyword2",
    "fbsql_database_password": "keyword2",
    "fbsql_db_query": "keyword2",
    "fbsql_drop_db": "keyword2",
    "fbsql_errno": "keyword2",
    "fbsql_error": "keyword2",
    "fbsql_fetch_array": "keyword2",
    "fbsql_fetch_assoc": "keyword2",
    "fbsql_fetch_field": "keyword2",
    "fbsql_fetch_lengths": "keyword2",
    "fbsql_fetch_object": "keyword2",
    "fbsql_fetch_row": "keyword2",
    "fbsql_field_flags": "keyword2",
    "fbsql_field_len": "keyword2",
    "fbsql_field_name": "keyword2",
    "fbsql_field_seek": "keyword2",
    "fbsql_field_table": "keyword2",
    "fbsql_field_type": "keyword2",
    "fbsql_free_result": "keyword2",
    "fbsql_hostname": "keyword2",
    "fbsql_insert_id": "keyword2",
    "fbsql_list_dbs": "keyword2",
    "fbsql_list_fields": "keyword2",
    "fbsql_list_tables": "keyword2",
    "fbsql_next_result": "keyword2",
    "fbsql_num_fields": "keyword2",
    "fbsql_num_rows": "keyword2",
    "fbsql_password": "keyword2",
    "fbsql_pconnect": "keyword2",
    "fbsql_query": "keyword2",
    "fbsql_result": "keyword2",
    "fbsql_rollback": "keyword2",
    "fbsql_select_db": "keyword2",
    "fbsql_start_db": "keyword2",
    "fbsql_stop_db": "keyword2",
    "fbsql_username": "keyword2",
    "fbsql_warnings": "keyword2",
    "fclose": "keyword2",
    "fd_alloc": "keyword2",
    "fd_clear": "keyword2",
    "fd_dealloc": "keyword2",
    "fd_isset": "keyword2",
    "fd_set": "keyword2",
    "fd_zero": "keyword2",
    "fdf_add_template": "keyword2",
    "fdf_close": "keyword2",
    "fdf_create": "keyword2",
    "fdf_get_file": "keyword2",
    "fdf_get_status": "keyword2",
    "fdf_get_value": "keyword2",
    "fdf_next_field_name": "keyword2",
    "fdf_open": "keyword2",
    "fdf_save": "keyword2",
    "fdf_set_ap": "keyword2",
    "fdf_set_file": "keyword2",
    "fdf_set_flags": "keyword2",
    "fdf_set_javascript_action": "keyword2",
    "fdf_set_opt": "keyword2",
    "fdf_set_status": "keyword2",
    "fdf_set_submit_form_action": "keyword2",
    "fdf_set_value": "keyword2",
    "feof": "keyword2",
    "fetch_iovec": "keyword2",
    "fflush": "keyword2",
    "fgetc": "keyword2",
    "fgetcsv": "keyword2",
    "fgets": "keyword2",
    "fgetss": "keyword2",
    "file": "keyword2",
    "file_exists": "keyword2",
    "file_get_contents": "keyword2",
    "file_put_contents": "keyword2",
    "fileatime": "keyword2",
    "filectime": "keyword2",
    "filegroup": "keyword2",
    "fileinode": "keyword2",
    "filemtime": "keyword2",
    "fileowner": "keyword2",
    "fileperms": "keyword2",
    "filepro": "keyword2",
    "filepro_fieldcount": "keyword2",
    "filepro_fieldname": "keyword2",
    "filepro_fieldtype": "keyword2",
    "filepro_fieldwidth": "keyword2",
    "filepro_retrieve": "keyword2",
    "filepro_rowcount": "keyword2",
    "filesize": "keyword2",
    "filetype": "keyword2",
    "final": "keyword1",
    "floatval": "keyword2",
    "flock": "keyword2",
    "floor": "keyword2",
    "flush": "keyword2",
    "fopen": "keyword2",
    "fopenstream": "keyword2",
    "for": "keyword1",
    "foreach": "keyword1",
    "fpassthru": "keyword2",
    "fputs": "keyword2",
    "fread": "keyword2",
    "free_iovec": "keyword2",
    "frenchtojd": "keyword2",
    "fribidi_log2vis": "keyword2",
    "fscanf": "keyword2",
    "fseek": "keyword2",
    "fsockopen": "keyword2",
    "fstat": "keyword2",
    "ftell": "keyword2",
    "ftp_alloc": "keyword2",
    "ftp_cdup": "keyword2",
    "ftp_chdir": "keyword2",
    "ftp_connect": "keyword2",
    "ftp_delete": "keyword2",
    "ftp_exec": "keyword2",
    "ftp_fget": "keyword2",
    "ftp_fput": "keyword2",
    "ftp_get": "keyword2",
    "ftp_login": "keyword2",
    "ftp_mdtm": "keyword2",
    "ftp_mkdir": "keyword2",
    "ftp_nlist": "keyword2",
    "ftp_pasv": "keyword2",
    "ftp_put": "keyword2",
    "ftp_pwd": "keyword2",
    "ftp_quit": "keyword2",
    "ftp_rawlist": "keyword2",
    "ftp_rename": "keyword2",
    "ftp_rmdir": "keyword2",
    "ftp_site": "keyword2",
    "ftp_size": "keyword2",
    "ftp_ssl_connect": "keyword2",
    "ftp_systype": "keyword2",
    "ftruncate": "keyword2",
    "func_get_arg": "keyword2",
    "func_get_args": "keyword2",
    "func_num_args": "keyword2",
    "function": "keyword1",
    "function_exists": "keyword2",
    "fwrite": "keyword2",
    "gd_info": "keyword2",
    "get_all_headers": "keyword2",
    "get_browser": "keyword2",
    "get_cfg_var": "keyword2",
    "get_class": "keyword2",
    "get_class_methods": "keyword2",
    "get_class_vars": "keyword2",
    "get_current_user": "keyword2",
    "get_declared_classes": "keyword2",
    "get_declared_interfaces": "keyword2",
    "get_defined_functions": "keyword2",
    "get_defined_vars": "keyword2",
    "get_extension_funcs": "keyword2",
    "get_headers": "keyword2",
    "get_html_translation_table": "keyword2",
    "get_included_files": "keyword2",
    "get_loaded_extensions": "keyword2",
    "get_magic_quotes_gpc": "keyword2",
    "get_magic_quotes_runtime": "keyword2",
    "get_meta_tags": "keyword2",
    "get_object_vars": "keyword2",
    "get_parent_class": "keyword2",
    "get_required_files": "keyword2",
    "get_resource_type": "keyword2",
    "getallheaders": "keyword2",
    "getascent": "keyword2",
    "getcwd": "keyword2",
    "getdate": "keyword2",
    "getdescent": "keyword2",
    "getenv": "keyword2",
    "getheight": "keyword2",
    "gethostbyaddr": "keyword2",
    "gethostbyname": "keyword2",
    "gethostbynamel": "keyword2",
    "getimagesize": "keyword2",
    "getlastmod": "keyword2",
    "getleading": "keyword2",
    "getmxrr": "keyword2",
    "getmyinode": "keyword2",
    "getmypid": "keyword2",
    "getmyuid": "keyword2",
    "getopt": "keyword2",
    "getpeername": "keyword2",
    "getprotobyname": "keyword2",
    "getprotobynumber": "keyword2",
    "getrandmax": "keyword2",
    "getrusage": "keyword2",
    "getservbyname": "keyword2",
    "getservbyport": "keyword2",
    "getshape1": "keyword2",
    "getshape2": "keyword2",
    "getsockname": "keyword2",
    "getsockopt": "keyword2",
    "gettext": "keyword2",
    "gettimeofday": "keyword2",
    "gettype": "keyword2",
    "getwidth": "keyword2",
    "global": "keyword1",
    "gmdate": "keyword2",
    "gmmktime": "keyword2",
    "gmp_abs": "keyword2",
    "gmp_add": "keyword2",
    "gmp_and": "keyword2",
    "gmp_clrbit": "keyword2",
    "gmp_cmp": "keyword2",
    "gmp_com": "keyword2",
    "gmp_div": "keyword2",
    "gmp_div_q": "keyword2",
    "gmp_div_qr": "keyword2",
    "gmp_div_r": "keyword2",
    "gmp_divexact": "keyword2",
    "gmp_fact": "keyword2",
    "gmp_gcd": "keyword2",
    "gmp_gcdext": "keyword2",
    "gmp_hamdist": "keyword2",
    "gmp_init": "keyword2",
    "gmp_intval": "keyword2",
    "gmp_invert": "keyword2",
    "gmp_jacobi": "keyword2",
    "gmp_legendre": "keyword2",
    "gmp_mod": "keyword2",
    "gmp_mul": "keyword2",
    "gmp_neg": "keyword2",
    "gmp_or": "keyword2",
    "gmp_perfect_square": "keyword2",
    "gmp_popcount": "keyword2",
    "gmp_pow": "keyword2",
    "gmp_powm": "keyword2",
    "gmp_prob_prime": "keyword2",
    "gmp_random": "keyword2",
    "gmp_scan0": "keyword2",
    "gmp_scan1": "keyword2",
    "gmp_setbit": "keyword2",
    "gmp_sign": "keyword2",
    "gmp_sqrt": "keyword2",
    "gmp_sqrtrem": "keyword2",
    "gmp_strval": "keyword2",
    "gmp_sub": "keyword2",
    "gmp_xor": "keyword2",
    "gmstrftime": "keyword2",
    "gregoriantojd": "keyword2",
    "gzclose": "keyword2",
    "gzcompress": "keyword2",
    "gzdeflate": "keyword2",
    "gzencode": "keyword2",
    "gzeof": "keyword2",
    "gzfile": "keyword2",
    "gzgetc": "keyword2",
    "gzgets": "keyword2",
    "gzgetss": "keyword2",
    "gzinflate": "keyword2",
    "gzopen": "keyword2",
    "gzpassthru": "keyword2",
    "gzputs": "keyword2",
    "gzread": "keyword2",
    "gzrewind": "keyword2",
    "gzseek": "keyword2",
    "gztell": "keyword2",
    "gzuncompress": "keyword2",
    "gzwrite": "keyword2",
    "header": "keyword2",
    "headers_list": "keyword2",
    "headers_sent": "keyword2",
    "hebrev": "keyword2",
    "hebrevc": "keyword2",
    "hexdec": "keyword2",
    "highlight_file": "keyword2",
    "highlight_string": "keyword2",
    "htmlentities": "keyword2",
    "htmlspecialchars": "keyword2",
    "http_build_query": "keyword2",
    "hw_array2objrec": "keyword2",
    "hw_changeobject": "keyword2",
    "hw_children": "keyword2",
    "hw_childrenobj": "keyword2",
    "hw_close": "keyword2",
    "hw_connect": "keyword2",
    "hw_connection_info": "keyword2",
    "hw_cp": "keyword2",
    "hw_deleteobject": "keyword2",
    "hw_docbyanchor": "keyword2",
    "hw_docbyanchorobj": "keyword2",
    "hw_document_attributes": "keyword2",
    "hw_document_bodytag": "keyword2",
    "hw_document_content": "keyword2",
    "hw_document_setcontent": "keyword2",
    "hw_document_size": "keyword2",
    "hw_dummy": "keyword2",
    "hw_edittext": "keyword2",
    "hw_error": "keyword2",
    "hw_errormsg": "keyword2",
    "hw_free_document": "keyword2",
    "hw_getanchors": "keyword2",
    "hw_getanchorsobj": "keyword2",
    "hw_getandlock": "keyword2",
    "hw_getcgi": "keyword2",
    "hw_getchildcoll": "keyword2",
    "hw_getchildcollobj": "keyword2",
    "hw_getchilddoccoll": "keyword2",
    "hw_getchilddoccollobj": "keyword2",
    "hw_getobject": "keyword2",
    "hw_getobjectbyftquery": "keyword2",
    "hw_getobjectbyftquerycoll": "keyword2",
    "hw_getobjectbyftquerycollobj": "keyword2",
    "hw_getobjectbyftqueryobj": "keyword2",
    "hw_getobjectbyquery": "keyword2",
    "hw_getobjectbyquerycoll": "keyword2",
    "hw_getobjectbyquerycollobj": "keyword2",
    "hw_getobjectbyqueryobj": "keyword2",
    "hw_getparents": "keyword2",
    "hw_getparentsobj": "keyword2",
    "hw_getrellink": "keyword2",
    "hw_getremote": "keyword2",
    "hw_getremotechildren": "keyword2",
    "hw_getsrcbydestobj": "keyword2",
    "hw_gettext": "keyword2",
    "hw_getusername": "keyword2",
    "hw_identify": "keyword2",
    "hw_incollections": "keyword2",
    "hw_info": "keyword2",
    "hw_inscoll": "keyword2",
    "hw_insdoc": "keyword2",
    "hw_insertanchors": "keyword2",
    "hw_insertdocument": "keyword2",
    "hw_insertobject": "keyword2",
    "hw_mapid": "keyword2",
    "hw_modifyobject": "keyword2",
    "hw_mv": "keyword2",
    "hw_new_document": "keyword2",
    "hw_new_document_from_file": "keyword2",
    "hw_objrec2array": "keyword2",
    "hw_output_document": "keyword2",
    "hw_pconnect": "keyword2",
    "hw_pipecgi": "keyword2",
    "hw_pipedocument": "keyword2",
    "hw_root": "keyword2",
    "hw_setlinkroot": "keyword2",
    "hw_stat": "keyword2",
    "hw_unlock": "keyword2",
    "hw_who": "keyword2",
    "ibase_blob_add": "keyword2",
    "ibase_blob_cancel": "keyword2",
    "ibase_blob_close": "keyword2",
    "ibase_blob_create": "keyword2",
    "ibase_blob_echo": "keyword2",
    "ibase_blob_get": "keyword2",
    "ibase_blob_import": "keyword2",
    "ibase_blob_info": "keyword2",
    "ibase_blob_open": "keyword2",
    "ibase_close": "keyword2",
    "ibase_commit": "keyword2",
    "ibase_connect": "keyword2",
    "ibase_errmsg": "keyword2",
    "ibase_execute": "keyword2",
    "ibase_fetch_object": "keyword2",
    "ibase_fetch_row": "keyword2",
    "ibase_field_info": "keyword2",
    "ibase_free_query": "keyword2",
    "ibase_free_result": "keyword2",
    "ibase_num_fields": "keyword2",
    "ibase_pconnect": "keyword2",
    "ibase_prepare": "keyword2",
    "ibase_query": "keyword2",
    "ibase_rollback": "keyword2",
    "ibase_timefmt": "keyword2",
    "ibase_trans": "keyword2",
    "icap_create_calendar": "keyword2",
    "icap_delete_calendar": "keyword2",
    "icap_delete_event": "keyword2",
    "icap_fetch_event": "keyword2",
    "icap_list_alarms": "keyword2",
    "icap_list_events": "keyword2",
    "icap_open": "keyword2",
    "icap_popen": "keyword2",
    "icap_rename_calendar": "keyword2",
    "icap_reopen": "keyword2",
    "icap_snooze": "keyword2",
    "icap_store_event": "keyword2",
    "iconv": "keyword2",
    "iconv_get_encoding": "keyword2",
    "iconv_set_encoding": "keyword2",
    "idate": "keyword2",
    "if": "keyword1",
    "ifx_affected_rows": "keyword2",
    "ifx_blobinfile_mode": "keyword2",
    "ifx_byteasvarchar": "keyword2",
    "ifx_close": "keyword2",
    "ifx_connect": "keyword2",
    "ifx_copy_blob": "keyword2",
    "ifx_create_blob": "keyword2",
    "ifx_create_char": "keyword2",
    "ifx_do": "keyword2",
    "ifx_error": "keyword2",
    "ifx_errormsg": "keyword2",
    "ifx_fetch_row": "keyword2",
    "ifx_fieldproperties": "keyword2",
    "ifx_fieldtypes": "keyword2",
    "ifx_free_blob": "keyword2",
    "ifx_free_char": "keyword2",
    "ifx_free_result": "keyword2",
    "ifx_get_blob": "keyword2",
    "ifx_get_char": "keyword2",
    "ifx_getsqlca": "keyword2",
    "ifx_htmltbl_result": "keyword2",
    "ifx_nullformat": "keyword2",
    "ifx_num_fields": "keyword2",
    "ifx_num_rows": "keyword2",
    "ifx_pconnect": "keyword2",
    "ifx_prepare": "keyword2",
    "ifx_query": "keyword2",
    "ifx_textasvarchar": "keyword2",
    "ifx_update_blob": "keyword2",
    "ifx_update_char": "keyword2",
    "ifxus_close_slob": "keyword2",
    "ifxus_create_slob": "keyword2",
    "ifxus_free_slob": "keyword2",
    "ifxus_open_slob": "keyword2",
    "ifxus_read_slob": "keyword2",
    "ifxus_seek_slob": "keyword2",
    "ifxus_tell_slob": "keyword2",
    "ifxus_write_slob": "keyword2",
    "ignore_user_abort": "keyword2",
    "iis_addserver": "keyword2",
    "iis_getdirsecurity": "keyword2",
    "iis_getscriptmap": "keyword2",
    "iis_getserverbycomment": "keyword2",
    "iis_getserverbypath": "keyword2",
    "iis_getserverright": "keyword2",
    "iis_getservicestate": "keyword2",
    "iis_removeserver": "keyword2",
    "iis_setappsettings": "keyword2",
    "iis_setdirsecurity": "keyword2",
    "iis_setscriptmap": "keyword2",
    "iis_setserverright": "keyword2",
    "iis_startserver": "keyword2",
    "iis_startservice": "keyword2",
    "iis_stopserver": "keyword2",
    "iis_stopservice": "keyword2",
    "image2wbmp": "keyword2",
    "image_type_to_extension": "keyword2",
    "imagealphablending": "keyword2",
    "imagearc": "keyword2",
    "imagechar": "keyword2",
    "imagecharup": "keyword2",
    "imagecolorallocate": "keyword2",
    "imagecolorat": "keyword2",
    "imagecolorclosest": "keyword2",
    "imagecolorclosestalpha": "keyword2",
    "imagecolorclosesthwb": "keyword2",
    "imagecolordeallocate": "keyword2",
    "imagecolorexact": "keyword2",
    "imagecolorexactalpha": "keyword2",
    "imagecolormatch": "keyword2",
    "imagecolorresolve": "keyword2",
    "imagecolorresolvealpha": "keyword2",
    "imagecolorset": "keyword2",
    "imagecolorsforindex": "keyword2",
    "imagecolorstotal": "keyword2",
    "imagecolortransparent": "keyword2",
    "imagecopy": "keyword2",
    "imagecopymerge": "keyword2",
    "imagecopymergegray": "keyword2",
    "imagecopyresampled": "keyword2",
    "imagecopyresized": "keyword2",
    "imagecreate": "keyword2",
    "imagecreatefromgif": "keyword2",
    "imagecreatefromjpeg": "keyword2",
    "imagecreatefrompng": "keyword2",
    "imagecreatefromstring": "keyword2",
    "imagecreatefromwbmp": "keyword2",
    "imagecreatefromxbm": "keyword2",
    "imagecreatefromxpm": "keyword2",
    "imagecreatetruecolor": "keyword2",
    "imagedashedline": "keyword2",
    "imagedestroy": "keyword2",
    "imageellipse": "keyword2",
    "imagefill": "keyword2",
    "imagefilledarc": "keyword2",
    "imagefilledellipse": "keyword2",
    "imagefilledpolygon": "keyword2",
    "imagefilledrectangle": "keyword2",
    "imagefilltoborder": "keyword2",
    "imagefilter": "keyword2",
    "imagefontheight": "keyword2",
    "imagefontwidth": "keyword2",
    "imagegammacorrect": "keyword2",
    "imagegif": "keyword2",
    "imageinterlace": "keyword2",
    "imagejpeg": "keyword2",
    "imagelayereffect": "keyword2",
    "imageline": "keyword2",
    "imageloadfont": "keyword2",
    "imagepalettecopy": "keyword2",
    "imagepng": "keyword2",
    "imagepolygon": "keyword2",
    "imagepsbbox": "keyword2",
    "imagepscopyfont": "keyword2",
    "imagepsencodefont": "keyword2",
    "imagepsextendfont": "keyword2",
    "imagepsfreefont": "keyword2",
    "imagepsloadfont": "keyword2",
    "imagepsslantfont": "keyword2",
    "imagepstext": "keyword2",
    "imagerectangle": "keyword2",
    "imagerotate": "keyword2",
    "imagesetbrush": "keyword2",
    "imagesetpixel": "keyword2",
    "imagesetstyle": "keyword2",
    "imagesetthickness": "keyword2",
    "imagesettile": "keyword2",
    "imagestring": "keyword2",
    "imagestringup": "keyword2",
    "imagesx": "keyword2",
    "imagesy": "keyword2",
    "imagetruecolortopalette": "keyword2",
    "imagettfbbox": "keyword2",
    "imagettftext": "keyword2",
    "imagetypes": "keyword2",
    "imagewbmp": "keyword2",
    "imap_8bit": "keyword2",
    "imap_alerts": "keyword2",
    "imap_append": "keyword2",
    "imap_base64": "keyword2",
    "imap_binary": "keyword2",
    "imap_body": "keyword2",
    "imap_bodystruct": "keyword2",
    "imap_check": "keyword2",
    "imap_clearflag_full": "keyword2",
    "imap_close": "keyword2",
    "imap_create": "keyword2",
    "imap_createmailbox": "keyword2",
    "imap_delete": "keyword2",
    "imap_deletemailbox": "keyword2",
    "imap_errors": "keyword2",
    "imap_expunge": "keyword2",
    "imap_fetch_overview": "keyword2",
    "imap_fetchbody": "keyword2",
    "imap_fetchheader": "keyword2",
    "imap_fetchstructure": "keyword2",
    "imap_fetchtext": "keyword2",
    "imap_get_quota": "keyword2",
    "imap_getmailboxes": "keyword2",
    "imap_getsubscribed": "keyword2",
    "imap_header": "keyword2",
    "imap_headerinfo": "keyword2",
    "imap_headers": "keyword2",
    "imap_last_error": "keyword2",
    "imap_list": "keyword2",
    "imap_listmailbox": "keyword2",
    "imap_listsubscribed": "keyword2",
    "imap_lsub": "keyword2",
    "imap_mail": "keyword2",
    "imap_mail_compose": "keyword2",
    "imap_mail_copy": "keyword2",
    "imap_mail_move": "keyword2",
    "imap_mailboxmsginfo": "keyword2",
    "imap_mime_header_decode": "keyword2",
    "imap_msgno": "keyword2",
    "imap_num_msg": "keyword2",
    "imap_num_recent": "keyword2",
    "imap_open": "keyword2",
    "imap_ping": "keyword2",
    "imap_popen": "keyword2",
    "imap_qprint": "keyword2",
    "imap_rename": "keyword2",
    "imap_renamemailbox": "keyword2",
    "imap_reopen": "keyword2",
    "imap_rfc822_parse_adrlist": "keyword2",
    "imap_rfc822_parse_headers": "keyword2",
    "imap_rfc822_write_address": "keyword2",
    "imap_scan": "keyword2",
    "imap_scanmailbox": "keyword2",
    "imap_search": "keyword2",
    "imap_set_quota": "keyword2",
    "imap_setflag_full": "keyword2",
    "imap_sort": "keyword2",
    "imap_status": "keyword2",
    "imap_subscribe": "keyword2",
    "imap_uid": "keyword2",
    "imap_undelete": "keyword2",
    "imap_unsubscribe": "keyword2",
    "imap_utf7_decode": "keyword2",
    "imap_utf7_encode": "keyword2",
    "imap_utf8": "keyword2",
    "implements": "keyword1",
    "implode": "keyword2",
    "in_array": "keyword2",
    "include": "keyword1",
    "include_once": "keyword1",
    "ingres_autocommit": "keyword2",
    "ingres_close": "keyword2",
    "ingres_commit": "keyword2",
    "ingres_connect": "keyword2",
    "ingres_fetch_array": "keyword2",
    "ingres_fetch_object": "keyword2",
    "ingres_fetch_row": "keyword2",
    "ingres_field_length": "keyword2",
    "ingres_field_name": "keyword2",
    "ingres_field_nullable": "keyword2",
    "ingres_field_precision": "keyword2",
    "ingres_field_scale": "keyword2",
    "ingres_field_type": "keyword2",
    "ingres_num_fields": "keyword2",
    "ingres_num_rows": "keyword2",
    "ingres_pconnect": "keyword2",
    "ingres_query": "keyword2",
    "ingres_rollback": "keyword2",
    "ini_alter": "keyword2",
    "ini_get": "keyword2",
    "ini_restore": "keyword2",
    "ini_set": "keyword2",
    "instanceof": "operator",
    "interface": "keyword1",
    "intval": "keyword2",
    "ip2long": "keyword2",
    "iptcembed": "keyword2",
    "iptcparse": "keyword2",
    "ircg_channel_mode": "keyword2",
    "ircg_disconnect": "keyword2",
    "ircg_html_encode": "keyword2",
    "ircg_ignore_add": "keyword2",
    "ircg_ignore_del": "keyword2",
    "ircg_is_conn_alive": "keyword2",
    "ircg_join": "keyword2",
    "ircg_kick": "keyword2",
    "ircg_lookup_format_messages": "keyword2",
    "ircg_msg": "keyword2",
    "ircg_nick": "keyword2",
    "ircg_nickname_escape": "keyword2",
    "ircg_nickname_unescape": "keyword2",
    "ircg_notice": "keyword2",
    "ircg_part": "keyword2",
    "ircg_pconnect": "keyword2",
    "ircg_register_format_messages": "keyword2",
    "ircg_set_current": "keyword2",
    "ircg_topic": "keyword2",
    "ircg_whois": "keyword2",
    "is_array": "keyword2",
    "is_bool": "keyword2",
    "is_dir": "keyword2",
    "is_double": "keyword2",
    "is_executable": "keyword2",
    "is_file": "keyword2",
    "is_float": "keyword2",
    "is_int": "keyword2",
    "is_integer": "keyword2",
    "is_link": "keyword2",
    "is_long": "keyword2",
    "is_null": "keyword2",
    "is_numeric": "keyword2",
    "is_object": "keyword2",
    "is_readable": "keyword2",
    "is_real": "keyword2",
    "is_resource": "keyword2",
    "is_scalar": "keyword2",
    "is_string": "keyword2",
    "is_subclass_of": "keyword2",
    "is_uploaded_file": "keyword2",
    "is_writable": "keyword2",
    "is_writeable": "keyword2",
    "isset": "keyword1",
    "java_last_exception_clear": "keyword2",
    "java_last_exception_get": "keyword2",
    "jddayofweek": "keyword2",
    "jdmonthname": "keyword2",
    "jdtofrench": "keyword2",
    "jdtogregorian": "keyword2",
    "jdtojewish": "keyword2",
    "jdtojulian": "keyword2",
    "jdtounix": "keyword2",
    "jewishtojd": "keyword2",
    "join": "keyword2",
    "jpeg2wbmp": "keyword2",
    "juliantojd": "keyword2",
    "key": "keyword2",
    "krsort": "keyword2",
    "ksort": "keyword2",
    "labelframe": "keyword2",
    "lcg_value": "keyword2",
    "ldap_8859_to_t61": "keyword2",
    "ldap_add": "keyword2",
    "ldap_bind": "keyword2",
    "ldap_close": "keyword2",
    "ldap_compare": "keyword2",
    "ldap_connect": "keyword2",
    "ldap_count_entries": "keyword2",
    "ldap_delete": "keyword2",
    "ldap_dn2ufn": "keyword2",
    "ldap_err2str": "keyword2",
    "ldap_errno": "keyword2",
    "ldap_error": "keyword2",
    "ldap_explode_dn": "keyword2",
    "ldap_first_attribute": "keyword2",
    "ldap_first_entry": "keyword2",
    "ldap_first_reference": "keyword2",
    "ldap_free_result": "keyword2",
    "ldap_get_attributes": "keyword2",
    "ldap_get_dn": "keyword2",
    "ldap_get_entries": "keyword2",
    "ldap_get_option": "keyword2",
    "ldap_get_values": "keyword2",
    "ldap_get_values_len": "keyword2",
    "ldap_list": "keyword2",
    "ldap_mod_add": "keyword2",
    "ldap_mod_del": "keyword2",
    "ldap_mod_replace": "keyword2",
    "ldap_modify": "keyword2",
    "ldap_next_attribute": "keyword2",
    "ldap_next_entry": "keyword2",
    "ldap_next_reference": "keyword2",
    "ldap_parse_reference": "keyword2",
    "ldap_parse_result": "keyword2",
    "ldap_read": "keyword2",
    "ldap_rename": "keyword2",
    "ldap_search": "keyword2",
    "ldap_set_option": "keyword2",
    "ldap_t61_to_8859": "keyword2",
    "ldap_unbind": "keyword2",
    "leak": "keyword2",
    "levenshtein": "keyword2",
    "link": "keyword2",
    "linkinfo": "keyword2",
    "list": "keyword1",
    "listen": "keyword2",
    "localeconv": "keyword2",
    "localtime": "keyword2",
    "log": "keyword2",
    "log10": "keyword2",
    "long2ip": "keyword2",
    "lstat": "keyword2",
    "ltrim": "keyword2",
    "magic_quotes_runtime": "keyword2",
    "mail": "keyword2",
    "max": "keyword2",
    "mb_convert_case": "keyword2",
    "mb_strtolower": "keyword2",
    "mb_strtoupper": "keyword2",
    "mcal_append_event": "keyword2",
    "mcal_close": "keyword2",
    "mcal_create_calendar": "keyword2",
    "mcal_date_compare": "keyword2",
    "mcal_date_valid": "keyword2",
    "mcal_day_of_week": "keyword2",
    "mcal_day_of_year": "keyword2",
    "mcal_days_in_month": "keyword2",
    "mcal_delete_calendar": "keyword2",
    "mcal_delete_event": "keyword2",
    "mcal_event_add_attribute": "keyword2",
    "mcal_event_init": "keyword2",
    "mcal_event_set_alarm": "keyword2",
    "mcal_event_set_category": "keyword2",
    "mcal_event_set_class": "keyword2",
    "mcal_event_set_description": "keyword2",
    "mcal_event_set_end": "keyword2",
    "mcal_event_set_recur_daily": "keyword2",
    "mcal_event_set_recur_monthly_mday": "keyword2",
    "mcal_event_set_recur_monthly_wday": "keyword2",
    "mcal_event_set_recur_none": "keyword2",
    "mcal_event_set_recur_weekly": "keyword2",
    "mcal_event_set_recur_yearly": "keyword2",
    "mcal_event_set_start": "keyword2",
    "mcal_event_set_title": "keyword2",
    "mcal_fetch_current_stream_event": "keyword2",
    "mcal_fetch_event": "keyword2",
    "mcal_is_leap_year": "keyword2",
    "mcal_list_alarms": "keyword2",
    "mcal_list_events": "keyword2",
    "mcal_next_recurrence": "keyword2",
    "mcal_open": "keyword2",
    "mcal_popen": "keyword2",
    "mcal_rename_calendar": "keyword2",
    "mcal_reopen": "keyword2",
    "mcal_snooze": "keyword2",
    "mcal_store_event": "keyword2",
    "mcal_time_valid": "keyword2",
    "mcal_week_of_year": "keyword2",
    "mcrypt_cbc": "keyword2",
    "mcrypt_cfb": "keyword2",
    "mcrypt_create_iv": "keyword2",
    "mcrypt_decrypt": "keyword2",
    "mcrypt_ecb": "keyword2",
    "mcrypt_enc_get_algorithms_name": "keyword2",
    "mcrypt_enc_get_block_size": "keyword2",
    "mcrypt_enc_get_iv_size": "keyword2",
    "mcrypt_enc_get_key_size": "keyword2",
    "mcrypt_enc_get_modes_name": "keyword2",
    "mcrypt_enc_get_supported_key_sizes": "keyword2",
    "mcrypt_enc_is_block_algorithm": "keyword2",
    "mcrypt_enc_is_block_algorithm_mode": "keyword2",
    "mcrypt_enc_is_block_mode": "keyword2",
    "mcrypt_enc_self_test": "keyword2",
    "mcrypt_encrypt": "keyword2",
    "mcrypt_generic": "keyword2",
    "mcrypt_generic_deinit": "keyword2",
    "mcrypt_generic_end": "keyword2",
    "mcrypt_generic_init": "keyword2",
    "mcrypt_get_block_size": "keyword2",
    "mcrypt_get_cipher_name": "keyword2",
    "mcrypt_get_iv_size": "keyword2",
    "mcrypt_get_key_size": "keyword2",
    "mcrypt_list_algorithms": "keyword2",
    "mcrypt_list_modes": "keyword2",
    "mcrypt_module_close": "keyword2",
    "mcrypt_module_get_algo_block_size": "keyword2",
    "mcrypt_module_get_algo_key_size": "keyword2",
    "mcrypt_module_get_supported_key_sizes": "keyword2",
    "mcrypt_module_is_block_algorithm": "keyword2",
    "mcrypt_module_is_block_algorithm_mode": "keyword2",
    "mcrypt_module_is_block_mode": "keyword2",
    "mcrypt_module_open": "keyword2",
    "mcrypt_module_self_test": "keyword2",
    "mcrypt_ofb": "keyword2",
    "md5": "keyword2",
    "md5_file": "keyword2",
    "mdecrypt_generic": "keyword2",
    "metaphone": "keyword2",
    "method_exists": "keyword2",
    "mhash": "keyword2",
    "mhash_count": "keyword2",
    "mhash_get_block_size": "keyword2",
    "mhash_get_hash_name": "keyword2",
    "mhash_keygen_s2k": "keyword2",
    "microtime": "keyword2",
    "min": "keyword2",
    "ming_setcubicthreshold": "keyword2",
    "ming_setscale": "keyword2",
    "mkdir": "keyword2",
    "mktime": "keyword2",
    "move": "keyword2",
    "move_uploaded_file": "keyword2",
    "movepen": "keyword2",
    "movepento": "keyword2",
    "moveto": "keyword2",
    "msql": "keyword2",
    "msql_affected_rows": "keyword2",
    "msql_close": "keyword2",
    "msql_connect": "keyword2",
    "msql_create_db": "keyword2",
    "msql_createdb": "keyword2",
    "msql_data_seek": "keyword2",
    "msql_db_query": "keyword2",
    "msql_dbname": "keyword2",
    "msql_drop_db": "keyword2",
    "msql_dropdb": "keyword2",
    "msql_error": "keyword2",
    "msql_fetch_array": "keyword2",
    "msql_fetch_field": "keyword2",
    "msql_fetch_object": "keyword2",
    "msql_fetch_row": "keyword2",
    "msql_field_flags": "keyword2",
    "msql_field_len": "keyword2",
    "msql_field_name": "keyword2",
    "msql_field_seek": "keyword2",
    "msql_field_table": "keyword2",
    "msql_field_type": "keyword2",
    "msql_fieldflags": "keyword2",
    "msql_fieldlen": "keyword2",
    "msql_fieldname": "keyword2",
    "msql_fieldtable": "keyword2",
    "msql_fieldtype": "keyword2",
    "msql_free_result": "keyword2",
    "msql_freeresult": "keyword2",
    "msql_list_dbs": "keyword2",
    "msql_list_fields": "keyword2",
    "msql_list_tables": "keyword2",
    "msql_listdbs": "keyword2",
    "msql_listfields": "keyword2",
    "msql_listtables": "keyword2",
    "msql_num_fields": "keyword2",
    "msql_num_rows": "keyword2",
    "msql_numfields": "keyword2",
    "msql_numrows": "keyword2",
    "msql_pconnect": "keyword2",
    "msql_query": "keyword2",
    "msql_regcase": "keyword2",
    "msql_result": "keyword2",
    "msql_select_db": "keyword2",
    "msql_selectdb": "keyword2",
    "msql_tablename": "keyword2",
    "mssql_affected_rows": "keyword2",
    "mssql_close": "keyword2",
    "mssql_connect": "keyword2",
    "mssql_data_seek": "keyword2",
    "mssql_fetch_array": "keyword2",
    "mssql_fetch_batch": "keyword2",
    "mssql_fetch_field": "keyword2",
    "mssql_fetch_object": "keyword2",
    "mssql_fetch_row": "keyword2",
    "mssql_field_length": "keyword2",
    "mssql_field_name": "keyword2",
    "mssql_field_seek": "keyword2",
    "mssql_field_type": "keyword2",
    "mssql_free_result": "keyword2",
    "mssql_get_last_message": "keyword2",
    "mssql_min_client_severity": "keyword2",
    "mssql_min_error_severity": "keyword2",
    "mssql_min_message_severity": "keyword2",
    "mssql_min_server_severity": "keyword2",
    "mssql_next_result": "keyword2",
    "mssql_num_fields": "keyword2",
    "mssql_num_rows": "keyword2",
    "mssql_pconnect": "keyword2",
    "mssql_query": "keyword2",
    "mssql_result": "keyword2",
    "mssql_rows_affected": "keyword2",
    "mssql_select_db": "keyword2",
    "mt_getrandmax": "keyword2",
    "mt_rand": "keyword2",
    "mt_srand": "keyword2",
    "multcolor": "keyword2",
    "muscat_close": "keyword2",
    "muscat_get": "keyword2",
    "muscat_give": "keyword2",
    "muscat_setup": "keyword2",
    "muscat_setup_net": "keyword2",
    "mysql": "keyword2",
    "mysql_affected_rows": "keyword2",
    "mysql_close": "keyword2",
    "mysql_connect": "keyword2",
    "mysql_create_db": "keyword2",
    "mysql_createdb": "keyword2",
    "mysql_data_seek": "keyword2",
    "mysql_db_name": "keyword2",
    "mysql_db_query": "keyword2",
    "mysql_dbname": "keyword2",
    "mysql_drop_db": "keyword2",
    "mysql_dropdb": "keyword2",
    "mysql_errno": "keyword2",
    "mysql_error": "keyword2",
    "mysql_escape_string": "keyword2",
    "mysql_fetch_array": "keyword2",
    "mysql_fetch_assoc": "keyword2",
    "mysql_fetch_field": "keyword2",
    "mysql_fetch_lengths": "keyword2",
    "mysql_fetch_object": "keyword2",
    "mysql_fetch_row": "keyword2",
    "mysql_field_flags": "keyword2",
    "mysql_field_len": "keyword2",
    "mysql_field_name": "keyword2",
    "mysql_field_seek": "keyword2",
    "mysql_field_table": "keyword2",
    "mysql_field_type": "keyword2",
    "mysql_fieldflags": "keyword2",
    "mysql_fieldlen": "keyword2",
    "mysql_fieldname": "keyword2",
    "mysql_fieldtable": "keyword2",
    "mysql_fieldtype": "keyword2",
    "mysql_free_result": "keyword2",
    "mysql_freeresult": "keyword2",
    "mysql_get_client_info": "keyword2",
    "mysql_get_host_info": "keyword2",
    "mysql_get_proto_info": "keyword2",
    "mysql_get_server_info": "keyword2",
    "mysql_insert_id": "keyword2",
    "mysql_list_dbs": "keyword2",
    "mysql_list_fields": "keyword2",
    "mysql_list_tables": "keyword2",
    "mysql_listdbs": "keyword2",
    "mysql_listfields": "keyword2",
    "mysql_listtables": "keyword2",
    "mysql_num_fields": "keyword2",
    "mysql_num_rows": "keyword2",
    "mysql_numfields": "keyword2",
    "mysql_numrows": "keyword2",
    "mysql_pconnect": "keyword2",
    "mysql_query": "keyword2",
    "mysql_result": "keyword2",
    "mysql_select_db": "keyword2",
    "mysql_selectdb": "keyword2",
    "mysql_tablename": "keyword2",
    "mysql_unbuffered_query": "keyword2",
    "natcasesort": "keyword2",
    "natsort": "keyword2",
    "new": "keyword1",
    "new_xmldoc": "keyword2",
    "next": "keyword2",
    "nextframe": "keyword2",
    "nl2br": "keyword2",
    "notes_body": "keyword2",
    "notes_copy_db": "keyword2",
    "notes_create_db": "keyword2",
    "notes_create_note": "keyword2",
    "notes_drop_db": "keyword2",
    "notes_find_note": "keyword2",
    "notes_header_info": "keyword2",
    "notes_list_msgs": "keyword2",
    "notes_mark_read": "keyword2",
    "notes_mark_unread": "keyword2",
    "notes_nav_create": "keyword2",
    "notes_search": "keyword2",
    "notes_unread": "keyword2",
    "notes_version": "keyword2",
    "null": "keyword3",
    "number_format": "keyword2",
    "ob_end_clean": "keyword2",
    "ob_end_flush": "keyword2",
    "ob_get_clean": "keyword2",
    "ob_get_contents": "keyword2",
    "ob_get_flush": "keyword2",
    "ob_get_length": "keyword2",
    "ob_gzhandler": "keyword2",
    "ob_iconv_handler": "keyword2",
    "ob_implicit_flush": "keyword2",
    "ob_list_handlers": "keyword2",
    "ob_start": "keyword2",
    "ocibindbyname": "keyword2",
    "ocicancel": "keyword2",
    "ocicollappend": "keyword2",
    "ocicollassign": "keyword2",
    "ocicollassignelem": "keyword2",
    "ocicolldateappendelem": "keyword2",
    "ocicolldateassignelem": "keyword2",
    "ocicolldategetelem": "keyword2",
    "ocicollgetelem": "keyword2",
    "ocicollmax": "keyword2",
    "ocicollsize": "keyword2",
    "ocicolltrim": "keyword2",
    "ocicolumnisnull": "keyword2",
    "ocicolumnname": "keyword2",
    "ocicolumnprecision": "keyword2",
    "ocicolumnscale": "keyword2",
    "ocicolumnsize": "keyword2",
    "ocicolumntype": "keyword2",
    "ocicolumntyperaw": "keyword2",
    "ocicommit": "keyword2",
    "ocidefinebyname": "keyword2",
    "ocierror": "keyword2",
    "ociexecute": "keyword2",
    "ocifetch": "keyword2",
    "ocifetchinto": "keyword2",
    "ocifetchstatement": "keyword2",
    "ocifreecoll": "keyword2",
    "ocifreecursor": "keyword2",
    "ocifreedesc": "keyword2",
    "ocifreestatement": "keyword2",
    "ociinternaldebug": "keyword2",
    "ociloadlob": "keyword2",
    "ocilogoff": "keyword2",
    "ocilogon": "keyword2",
    "ocinewcollection": "keyword2",
    "ocinewcursor": "keyword2",
    "ocinewdescriptor": "keyword2",
    "ocinlogon": "keyword2",
    "ocinumcols": "keyword2",
    "ociparse": "keyword2",
    "ociplogon": "keyword2",
    "ociresult": "keyword2",
    "ocirollback": "keyword2",
    "ocirowcount": "keyword2",
    "ocisavelob": "keyword2",
    "ocisavelobfile": "keyword2",
    "ociserverversion": "keyword2",
    "ocisetprefetch": "keyword2",
    "ocistatementtype": "keyword2",
    "ociwritelobtofile": "keyword2",
    "octdec": "keyword2",
    "odbc_autocommit": "keyword2",
    "odbc_binmode": "keyword2",
    "odbc_close": "keyword2",
    "odbc_close_all": "keyword2",
    "odbc_columnprivileges": "keyword2",
    "odbc_columns": "keyword2",
    "odbc_commit": "keyword2",
    "odbc_connect": "keyword2",
    "odbc_cursor": "keyword2",
    "odbc_data_source": "keyword2",
    "odbc_do": "keyword2",
    "odbc_error": "keyword2",
    "odbc_errormsg": "keyword2",
    "odbc_exec": "keyword2",
    "odbc_execute": "keyword2",
    "odbc_fetch_array": "keyword2",
    "odbc_fetch_into": "keyword2",
    "odbc_fetch_object": "keyword2",
    "odbc_fetch_row": "keyword2",
    "odbc_field_len": "keyword2",
    "odbc_field_name": "keyword2",
    "odbc_field_num": "keyword2",
    "odbc_field_precision": "keyword2",
    "odbc_field_scale": "keyword2",
    "odbc_field_type": "keyword2",
    "odbc_foreignkeys": "keyword2",
    "odbc_free_result": "keyword2",
    "odbc_gettypeinfo": "keyword2",
    "odbc_longreadlen": "keyword2",
    "odbc_next_result": "keyword2",
    "odbc_num_fields": "keyword2",
    "odbc_num_rows": "keyword2",
    "odbc_pconnect": "keyword2",
    "odbc_prepare": "keyword2",
    "odbc_primarykeys": "keyword2",
    "odbc_procedurecolumns": "keyword2",
    "odbc_procedures": "keyword2",
    "odbc_result": "keyword2",
    "odbc_result_all": "keyword2",
    "odbc_rollback": "keyword2",
    "odbc_setoption": "keyword2",
    "odbc_specialcolumns": "keyword2",
    "odbc_statistics": "keyword2",
    "odbc_tableprivileges": "keyword2",
    "odbc_tables": "keyword2",
    "old_function": "keyword1",
    "open_listen_sock": "keyword2",
    "opendir": "keyword2",
    "openlog": "keyword2",
    "openssl_error_string": "keyword2",
    "openssl_free_key": "keyword2",
    "openssl_get_privatekey": "keyword2",
    "openssl_get_publickey": "keyword2",
    "openssl_open": "keyword2",
    "openssl_pkcs7_decrypt": "keyword2",
    "openssl_pkcs7_encrypt": "keyword2",
    "openssl_pkcs7_sign": "keyword2",
    "openssl_pkcs7_verify": "keyword2",
    "openssl_seal": "keyword2",
    "openssl_sign": "keyword2",
    "openssl_verify": "keyword2",
    "openssl_x509_checkpurpose": "keyword2",
    "openssl_x509_free": "keyword2",
    "openssl_x509_parse": "keyword2",
    "openssl_x509_read": "keyword2",
    "or": "operator",
    "ora_bind": "keyword2",
    "ora_close": "keyword2",
    "ora_columnname": "keyword2",
    "ora_columnsize": "keyword2",
    "ora_columntype": "keyword2",
    "ora_commit": "keyword2",
    "ora_commitoff": "keyword2",
    "ora_commiton": "keyword2",
    "ora_do": "keyword2",
    "ora_error": "keyword2",
    "ora_errorcode": "keyword2",
    "ora_exec": "keyword2",
    "ora_fetch": "keyword2",
    "ora_fetch_into": "keyword2",
    "ora_getcolumn": "keyword2",
    "ora_logoff": "keyword2",
    "ora_logon": "keyword2",
    "ora_numcols": "keyword2",
    "ora_numrows": "keyword2",
    "ora_open": "keyword2",
    "ora_parse": "keyword2",
    "ora_plogon": "keyword2",
    "ora_rollback": "keyword2",
    "orbit_caught_exception": "keyword2",
    "orbit_exception_id": "keyword2",
    "orbit_exception_value": "keyword2",
    "orbit_get_repository_id": "keyword2",
    "orbit_load_idl": "keyword2",
    "ord": "keyword2",
    "output": "keyword2",
    "ovrimos_close": "keyword2",
    "ovrimos_close_all": "keyword2",
    "ovrimos_commit": "keyword2",
    "ovrimos_connect": "keyword2",
    "ovrimos_cursor": "keyword2",
    "ovrimos_exec": "keyword2",
    "ovrimos_execute": "keyword2",
    "ovrimos_fetch_into": "keyword2",
    "ovrimos_fetch_row": "keyword2",
    "ovrimos_field_len": "keyword2",
    "ovrimos_field_name": "keyword2",
    "ovrimos_field_num": "keyword2",
    "ovrimos_field_type": "keyword2",
    "ovrimos_free_result": "keyword2",
    "ovrimos_longreadlen": "keyword2",
    "ovrimos_num_fields": "keyword2",
    "ovrimos_num_rows": "keyword2",
    "ovrimos_prepare": "keyword2",
    "ovrimos_result": "keyword2",
    "ovrimos_result_all": "keyword2",
    "ovrimos_rollback": "keyword2",
    "pack": "keyword2",
    "parse_ini_file": "keyword2",
    "parse_str": "keyword2",
    "parse_url": "keyword2",
    "passthru": "keyword2",
    "pathinfo": "keyword2",
    "pclose": "keyword2",
    "pdf_add_annotation": "keyword2",
    "pdf_add_bookmark": "keyword2",
    "pdf_add_launchlink": "keyword2",
    "pdf_add_locallink": "keyword2",
    "pdf_add_note": "keyword2",
    "pdf_add_outline": "keyword2",
    "pdf_add_pdflink": "keyword2",
    "pdf_add_thumbnail": "keyword2",
    "pdf_add_weblink": "keyword2",
    "pdf_arc": "keyword2",
    "pdf_arcn": "keyword2",
    "pdf_attach_file": "keyword2",
    "pdf_begin_page": "keyword2",
    "pdf_begin_pattern": "keyword2",
    "pdf_begin_template": "keyword2",
    "pdf_circle": "keyword2",
    "pdf_clip": "keyword2",
    "pdf_close": "keyword2",
    "pdf_close_image": "keyword2",
    "pdf_close_pdi": "keyword2",
    "pdf_close_pdi_page": "keyword2",
    "pdf_closepath": "keyword2",
    "pdf_closepath_fill_stroke": "keyword2",
    "pdf_closepath_stroke": "keyword2",
    "pdf_concat": "keyword2",
    "pdf_continue_text": "keyword2",
    "pdf_curveto": "keyword2",
    "pdf_delete": "keyword2",
    "pdf_end_page": "keyword2",
    "pdf_end_pattern": "keyword2",
    "pdf_end_template": "keyword2",
    "pdf_endpath": "keyword2",
    "pdf_fill": "keyword2",
    "pdf_fill_stroke": "keyword2",
    "pdf_findfont": "keyword2",
    "pdf_get_buffer": "keyword2",
    "pdf_get_font": "keyword2",
    "pdf_get_fontname": "keyword2",
    "pdf_get_fontsize": "keyword2",
    "pdf_get_image_height": "keyword2",
    "pdf_get_image_width": "keyword2",
    "pdf_get_parameter": "keyword2",
    "pdf_get_pdi_parameter": "keyword2",
    "pdf_get_pdi_value": "keyword2",
    "pdf_get_value": "keyword2",
    "pdf_initgraphics": "keyword2",
    "pdf_lineto": "keyword2",
    "pdf_makespotcolor": "keyword2",
    "pdf_moveto": "keyword2",
    "pdf_new": "keyword2",
    "pdf_open": "keyword2",
    "pdf_open_ccitt": "keyword2",
    "pdf_open_file": "keyword2",
    "pdf_open_gif": "keyword2",
    "pdf_open_image": "keyword2",
    "pdf_open_image_file": "keyword2",
    "pdf_open_jpeg": "keyword2",
    "pdf_open_memory_image": "keyword2",
    "pdf_open_pdi": "keyword2",
    "pdf_open_pdi_page": "keyword2",
    "pdf_open_png": "keyword2",
    "pdf_open_tiff": "keyword2",
    "pdf_place_image": "keyword2",
    "pdf_place_pdi_page": "keyword2",
    "pdf_rect": "keyword2",
    "pdf_restore": "keyword2",
    "pdf_rotate": "keyword2",
    "pdf_save": "keyword2",
    "pdf_scale": "keyword2",
    "pdf_set_border_color": "keyword2",
    "pdf_set_border_dash": "keyword2",
    "pdf_set_border_style": "keyword2",
    "pdf_set_char_spacing": "keyword2",
    "pdf_set_duration": "keyword2",
    "pdf_set_font": "keyword2",
    "pdf_set_horiz_scaling": "keyword2",
    "pdf_set_info": "keyword2",
    "pdf_set_info_author": "keyword2",
    "pdf_set_info_creator": "keyword2",
    "pdf_set_info_keywords": "keyword2",
    "pdf_set_info_subject": "keyword2",
    "pdf_set_info_title": "keyword2",
    "pdf_set_leading": "keyword2",
    "pdf_set_parameter": "keyword2",
    "pdf_set_text_pos": "keyword2",
    "pdf_set_text_rendering": "keyword2",
    "pdf_set_text_rise": "keyword2",
    "pdf_set_transition": "keyword2",
    "pdf_set_value": "keyword2",
    "pdf_set_word_spacing": "keyword2",
    "pdf_setcolor": "keyword2",
    "pdf_setdash": "keyword2",
    "pdf_setflat": "keyword2",
    "pdf_setfont": "keyword2",
    "pdf_setgray": "keyword2",
    "pdf_setgray_fill": "keyword2",
    "pdf_setgray_stroke": "keyword2",
    "pdf_setlinecap": "keyword2",
    "pdf_setlinejoin": "keyword2",
    "pdf_setlinewidth": "keyword2",
    "pdf_setmatrix": "keyword2",
    "pdf_setmiterlimit": "keyword2",
    "pdf_setpolydash": "keyword2",
    "pdf_setrgbcolor": "keyword2",
    "pdf_setrgbcolor_fill": "keyword2",
    "pdf_setrgbcolor_stroke": "keyword2",
    "pdf_show": "keyword2",
    "pdf_show_boxed": "keyword2",
    "pdf_show_xy": "keyword2",
    "pdf_skew": "keyword2",
    "pdf_stringwidth": "keyword2",
    "pdf_stroke": "keyword2",
    "pdf_translate": "keyword2",
    "pfpro_cleanup": "keyword2",
    "pfpro_init": "keyword2",
    "pfpro_process": "keyword2",
    "pfpro_process_raw": "keyword2",
    "pfpro_version": "keyword2",
    "pfsockopen": "keyword2",
    "pg_client_encoding": "keyword2",
    "pg_clientencoding": "keyword2",
    "pg_close": "keyword2",
    "pg_cmdtuples": "keyword2",
    "pg_connect": "keyword2",
    "pg_convert": "keyword2",
    "pg_dbname": "keyword2",
    "pg_delete": "keyword2",
    "pg_end_copy": "keyword2",
    "pg_errormessage": "keyword2",
    "pg_exec": "keyword2",
    "pg_fetch_all": "keyword2",
    "pg_fetch_array": "keyword2",
    "pg_fetch_assoc": "keyword2",
    "pg_fetch_object": "keyword2",
    "pg_fetch_row": "keyword2",
    "pg_fieldisnull": "keyword2",
    "pg_fieldname": "keyword2",
    "pg_fieldnum": "keyword2",
    "pg_fieldprtlen": "keyword2",
    "pg_fieldsize": "keyword2",
    "pg_fieldtype": "keyword2",
    "pg_freeresult": "keyword2",
    "pg_get_notify": "keyword2",
    "pg_get_pid": "keyword2",
    "pg_getlastoid": "keyword2",
    "pg_host": "keyword2",
    "pg_insert": "keyword2",
    "pg_loclose": "keyword2",
    "pg_locreate": "keyword2",
    "pg_loexport": "keyword2",
    "pg_loimport": "keyword2",
    "pg_loopen": "keyword2",
    "pg_loread": "keyword2",
    "pg_loreadall": "keyword2",
    "pg_lounlink": "keyword2",
    "pg_lowrite": "keyword2",
    "pg_meta_data": "keyword2",
    "pg_numfields": "keyword2",
    "pg_numrows": "keyword2",
    "pg_options": "keyword2",
    "pg_pconnect": "keyword2",
    "pg_ping": "keyword2",
    "pg_port": "keyword2",
    "pg_put_line": "keyword2",
    "pg_result": "keyword2",
    "pg_result_seek": "keyword2",
    "pg_select": "keyword2",
    "pg_set_client_encoding": "keyword2",
    "pg_setclientencoding": "keyword2",
    "pg_trace": "keyword2",
    "pg_tty": "keyword2",
    "pg_unescape_bytea": "keyword2",
    "pg_untrace": "keyword2",
    "pg_update": "keyword2",
    "php_logo_guid": "keyword2",
    "php_sapi_name": "keyword2",
    "php_uname": "keyword2",
    "phpcredits": "keyword2",
    "phpinfo": "keyword2",
    "phpversion": "keyword2",
    "pi": "keyword2",
    "png2wbmp": "keyword2",
    "popen": "keyword2",
    "pos": "keyword2",
    "posix_ctermid": "keyword2",
    "posix_getcwd": "keyword2",
    "posix_getegid": "keyword2",
    "posix_geteuid": "keyword2",
    "posix_getgid": "keyword2",
    "posix_getgrgid": "keyword2",
    "posix_getgrnam": "keyword2",
    "posix_getgroups": "keyword2",
    "posix_getlogin": "keyword2",
    "posix_getpgid": "keyword2",
    "posix_getpgrp": "keyword2",
    "posix_getpid": "keyword2",
    "posix_getppid": "keyword2",
    "posix_getpwnam": "keyword2",
    "posix_getpwuid": "keyword2",
    "posix_getrlimit": "keyword2",
    "posix_getsid": "keyword2",
    "posix_getuid": "keyword2",
    "posix_isatty": "keyword2",
    "posix_kill": "keyword2",
    "posix_mkfifo": "keyword2",
    "posix_setegid": "keyword2",
    "posix_seteuid": "keyword2",
    "posix_setgid": "keyword2",
    "posix_setpgid": "keyword2",
    "posix_setsid": "keyword2",
    "posix_setuid": "keyword2",
    "posix_times": "keyword2",
    "posix_ttyname": "keyword2",
    "posix_uname": "keyword2",
    "pow": "keyword2",
    "preg_grep": "keyword2",
    "preg_match": "keyword2",
    "preg_match_all": "keyword2",
    "preg_quote": "keyword2",
    "preg_replace": "keyword2",
    "preg_replace_callback": "keyword2",
    "preg_split": "keyword2",
    "prev": "keyword2",
    "print_r": "keyword2",
    "printer_abort": "keyword2",
    "printer_close": "keyword2",
    "printer_create_brush": "keyword2",
    "printer_create_dc": "keyword2",
    "printer_create_font": "keyword2",
    "printer_create_pen": "keyword2",
    "printer_delete_brush": "keyword2",
    "printer_delete_dc": "keyword2",
    "printer_delete_font": "keyword2",
    "printer_delete_pen": "keyword2",
    "printer_draw_bmp": "keyword2",
    "printer_draw_chord": "keyword2",
    "printer_draw_elipse": "keyword2",
    "printer_draw_line": "keyword2",
    "printer_draw_pie": "keyword2",
    "printer_draw_rectangle": "keyword2",
    "printer_draw_roundrect": "keyword2",
    "printer_draw_text": "keyword2",
    "printer_end_doc": "keyword2",
    "printer_end_page": "keyword2",
    "printer_get_option": "keyword2",
    "printer_list": "keyword2",
    "printer_logical_fontheight": "keyword2",
    "printer_open": "keyword2",
    "printer_select_brush": "keyword2",
    "printer_select_font": "keyword2",
    "printer_select_pen": "keyword2",
    "printer_set_option": "keyword2",
    "printer_start_doc": "keyword2",
    "printer_start_page": "keyword2",
    "printer_write": "keyword2",
    "printf": "keyword2",
    "private": "keyword1",
    "protected": "keyword1",
    "pspell_add_to_personal": "keyword2",
    "pspell_add_to_session": "keyword2",
    "pspell_check": "keyword2",
    "pspell_clear_session": "keyword2",
    "pspell_config_create": "keyword2",
    "pspell_config_ignore": "keyword2",
    "pspell_config_mode": "keyword2",
    "pspell_config_personal": "keyword2",
    "pspell_config_repl": "keyword2",
    "pspell_config_runtogether": "keyword2",
    "pspell_config_save_repl": "keyword2",
    "pspell_new": "keyword2",
    "pspell_new_config": "keyword2",
    "pspell_new_personal": "keyword2",
    "pspell_save_wordlist": "keyword2",
    "pspell_store_replacement": "keyword2",
    "pspell_suggest": "keyword2",
    "public": "keyword1",
    "putenv": "keyword2",
    "qdom_error": "keyword2",
    "qdom_tree": "keyword2",
    "quoted_printable_decode": "keyword2",
    "quotemeta": "keyword2",
    "rad2deg": "keyword2",
    "rand": "keyword2",
    "range": "keyword2",
    "rawurldecode": "keyword2",
    "rawurlencode": "keyword2",
    "read": "keyword2",
    "read_exif_data": "keyword2",
    "readdir": "keyword2",
    "readfile": "keyword2",
    "readgzfile": "keyword2",
    "readline": "keyword2",
    "readline_add_history": "keyword2",
    "readline_clear_history": "keyword2",
    "readline_completion_function": "keyword2",
    "readline_info": "keyword2",
    "readline_list_history": "keyword2",
    "readline_read_history": "keyword2",
    "readline_write_history": "keyword2",
    "readlink": "keyword2",
    "readv": "keyword2",
    "realpath": "keyword2",
    "recode": "keyword2",
    "recode_file": "keyword2",
    "recode_string": "keyword2",
    "recv": "keyword2",
    "recvfrom": "keyword2",
    "recvmsg": "keyword2",
    "register_shutdown_function": "keyword2",
    "register_tick_function": "keyword2",
    "remove": "keyword2",
    "rename": "keyword2",
    "require": "keyword1",
    "require_once": "keyword1",
    "reset": "keyword2",
    "restore_error_handler": "keyword2",
    "return": "keyword1",
    "rewind": "keyword2",
    "rewinddir": "keyword2",
    "rmdir": "keyword2",
    "rotate": "keyword2",
    "rotateto": "keyword2",
    "round": "keyword2",
    "rsort": "keyword2",
    "rtrim": "keyword2",
    "satellite_caught_exception": "keyword2",
    "satellite_exception_id": "keyword2",
    "satellite_exception_value": "keyword2",
    "satellite_get_repository_id": "keyword2",
    "satellite_load_idl": "keyword2",
    "save": "keyword2",
    "savetofile": "keyword2",
    "scale": "keyword2",
    "scaleto": "keyword2",
    "scandir": "keyword2",
    "select": "keyword2",
    "sem_acquire": "keyword2",
    "sem_get": "keyword2",
    "sem_release": "keyword2",
    "send": "keyword2",
    "sendmsg": "keyword2",
    "sendto": "keyword2",
    "serialize": "keyword2",
    "session_cache_limiter": "keyword2",
    "session_decode": "keyword2",
    "session_destroy": "keyword2",
    "session_encode": "keyword2",
    "session_get_cookie_params": "keyword2",
    "session_id": "keyword2",
    "session_is_registered": "keyword2",
    "session_module_name": "keyword2",
    "session_name": "keyword2",
    "session_register": "keyword2",
    "session_save_path": "keyword2",
    "session_set_cookie_params": "keyword2",
    "session_set_save_handler": "keyword2",
    "session_start": "keyword2",
    "session_unregister": "keyword2",
    "session_unset": "keyword2",
    "session_write_close": "keyword2",
    "set_content": "keyword2",
    "set_error_handler": "keyword2",
    "set_file_buffer": "keyword2",
    "set_iovec": "keyword2",
    "set_magic_quotes_runtime": "keyword2",
    "set_nonblock": "keyword2",
    "set_socket_blocking": "keyword2",
    "set_time_limit": "keyword2",
    "setaction": "keyword2",
    "setbackground": "keyword2",
    "setbounds": "keyword2",
    "setcolor": "keyword2",
    "setcookie": "keyword2",
    "setdepth": "keyword2",
    "setdimension": "keyword2",
    "setdown": "keyword2",
    "setfont": "keyword2",
    "setframes": "keyword2",
    "setheight": "keyword2",
    "sethit": "keyword2",
    "setindentation": "keyword2",
    "setleftfill": "keyword2",
    "setleftmargin": "keyword2",
    "setline": "keyword2",
    "setlinespacing": "keyword2",
    "setlocale": "keyword2",
    "setmargins": "keyword2",
    "setmatrix": "keyword2",
    "setname": "keyword2",
    "setover": "keyword2",
    "setrate": "keyword2",
    "setratio": "keyword2",
    "setrightfill": "keyword2",
    "setrightmargin": "keyword2",
    "setsockopt": "keyword2",
    "setspacing": "keyword2",
    "settype": "keyword2",
    "setup": "keyword2",
    "sha1": "keyword2",
    "sha1_file": "keyword2",
    "shell_exec": "keyword2",
    "shm_attach": "keyword2",
    "shm_detach": "keyword2",
    "shm_get_var": "keyword2",
    "shm_put_var": "keyword2",
    "shm_remove": "keyword2",
    "shm_remove_var": "keyword2",
    "shmop_close": "keyword2",
    "shmop_delete": "keyword2",
    "shmop_open": "keyword2",
    "shmop_read": "keyword2",
    "shmop_size": "keyword2",
    "shmop_write": "keyword2",
    "show_source": "keyword2",
    "shuffle": "keyword2",
    "shutdown": "keyword2",
    "signal": "keyword2",
    "similar_text": "keyword2",
    "sin": "keyword2",
    "sizeof": "keyword2",
    "skewx": "keyword2",
    "skewxto": "keyword2",
    "skewy": "keyword2",
    "skewyto": "keyword2",
    "sleep": "keyword2",
    "snmp_get_quick_print": "keyword2",
    "snmp_set_quick_print": "keyword2",
    "snmpget": "keyword2",
    "snmprealwalk": "keyword2",
    "snmpset": "keyword2",
    "snmpwalk": "keyword2",
    "snmpwalkoid": "keyword2",
    "socket": "keyword2",
    "socket_get_status": "keyword2",
    "socket_set_blocking": "keyword2",
    "socket_set_timeout": "keyword2",
    "socketpair": "keyword2",
    "sort": "keyword2",
    "soundex": "keyword2",
    "split": "keyword2",
    "spliti": "keyword2",
    "sprintf": "keyword2",
    "sql_regcase": "keyword2",
    "sqrt": "keyword2",
    "srand": "keyword2",
    "sscanf": "keyword2",
    "stat": "keyword2",
    "static": "keyword1",
    "str_pad": "keyword2",
    "str_repeat": "keyword2",
    "str_replace": "keyword2",
    "str_rot13": "keyword2",
    "str_split": "keyword2",
    "str_word_count": "keyword2",
    "strcasecmp": "keyword2",
    "strchr": "keyword2",
    "strcmp": "keyword2",
    "strcoll": "keyword2",
    "strcspn": "keyword2",
    "stream_context_create": "keyword2",
    "stream_context_set_option": "keyword2",
    "stream_context_set_params": "keyword2",
    "stream_filter_append": "keyword2",
    "stream_filter_prepend": "keyword2",
    "stream_get_status": "keyword2",
    "stream_select": "keyword2",
    "stream_set_blocking": "keyword2",
    "stream_set_timeout": "keyword2",
    "streammp3": "keyword2",
    "strerror": "keyword2",
    "strftime": "keyword2",
    "strip_tags": "keyword2",
    "stripcslashes": "keyword2",
    "stripos": "keyword2",
    "stripslashes": "keyword2",
    "stristr": "keyword2",
    "strlen": "keyword2",
    "strnatcasecmp": "keyword2",
    "strnatcmp": "keyword2",
    "strncasecmp": "keyword2",
    "strncmp": "keyword2",
    "strpbrk": "keyword2",
    "strpos": "keyword2",
    "strrchr": "keyword2",
    "strrev": "keyword2",
    "strrpos": "keyword2",
    "strspn": "keyword2",
    "strstr": "keyword2",
    "strtok": "keyword2",
    "strtolower": "keyword2",
    "strtotime": "keyword2",
    "strtoupper": "keyword2",
    "strtr": "keyword2",
    "strval": "keyword2",
    "substr": "keyword2",
    "substr_compare": "keyword2",
    "substr_count": "keyword2",
    "substr_replace": "keyword2",
    "swf_actiongeturl": "keyword2",
    "swf_actiongotoframe": "keyword2",
    "swf_actiongotolabel": "keyword2",
    "swf_actionnextframe": "keyword2",
    "swf_actionplay": "keyword2",
    "swf_actionprevframe": "keyword2",
    "swf_actionsettarget": "keyword2",
    "swf_actionstop": "keyword2",
    "swf_actiontogglequality": "keyword2",
    "swf_actionwaitforframe": "keyword2",
    "swf_addbuttonrecord": "keyword2",
    "swf_addcolor": "keyword2",
    "swf_closefile": "keyword2",
    "swf_definebitmap": "keyword2",
    "swf_definefont": "keyword2",
    "swf_defineline": "keyword2",
    "swf_definepoly": "keyword2",
    "swf_definerect": "keyword2",
    "swf_definetext": "keyword2",
    "swf_endbutton": "keyword2",
    "swf_enddoaction": "keyword2",
    "swf_endshape": "keyword2",
    "swf_endsymbol": "keyword2",
    "swf_fontsize": "keyword2",
    "swf_fontslant": "keyword2",
    "swf_fonttracking": "keyword2",
    "swf_getbitmapinfo": "keyword2",
    "swf_getfontinfo": "keyword2",
    "swf_getframe": "keyword2",
    "swf_labelframe": "keyword2",
    "swf_lookat": "keyword2",
    "swf_modifyobject": "keyword2",
    "swf_mulcolor": "keyword2",
    "swf_nextid": "keyword2",
    "swf_oncondition": "keyword2",
    "swf_openfile": "keyword2",
    "swf_ortho": "keyword2",
    "swf_ortho2": "keyword2",
    "swf_perspective": "keyword2",
    "swf_placeobject": "keyword2",
    "swf_polarview": "keyword2",
    "swf_popmatrix": "keyword2",
    "swf_posround": "keyword2",
    "swf_pushmatrix": "keyword2",
    "swf_removeobject": "keyword2",
    "swf_rotate": "keyword2",
    "swf_scale": "keyword2",
    "swf_setfont": "keyword2",
    "swf_setframe": "keyword2",
    "swf_shapearc": "keyword2",
    "swf_shapecurveto": "keyword2",
    "swf_shapecurveto3": "keyword2",
    "swf_shapefillbitmapclip": "keyword2",
    "swf_shapefillbitmaptile": "keyword2",
    "swf_shapefilloff": "keyword2",
    "swf_shapefillsolid": "keyword2",
    "swf_shapelinesolid": "keyword2",
    "swf_shapelineto": "keyword2",
    "swf_shapemoveto": "keyword2",
    "swf_showframe": "keyword2",
    "swf_startbutton": "keyword2",
    "swf_startdoaction": "keyword2",
    "swf_startshape": "keyword2",
    "swf_startsymbol": "keyword2",
    "swf_textwidth": "keyword2",
    "swf_translate": "keyword2",
    "swf_viewport": "keyword2",
    "swfaction": "keyword2",
    "swfbitmap": "keyword2",
    "swfbutton": "keyword2",
    "swfbutton_keypress": "keyword2",
    "swffill": "keyword2",
    "swffont": "keyword2",
    "swfgradient": "keyword2",
    "swfmorph": "keyword2",
    "swfmovie": "keyword2",
    "swfshape": "keyword2",
    "swfsprite": "keyword2",
    "swftext": "keyword2",
    "swftextfield": "keyword2",
    "switch": "keyword1",
    "sybase_affected_rows": "keyword2",
    "sybase_close": "keyword2",
    "sybase_connect": "keyword2",
    "sybase_data_seek": "keyword2",
    "sybase_fetch_array": "keyword2",
    "sybase_fetch_field": "keyword2",
    "sybase_fetch_object": "keyword2",
    "sybase_fetch_row": "keyword2",
    "sybase_field_seek": "keyword2",
    "sybase_free_result": "keyword2",
    "sybase_get_last_message": "keyword2",
    "sybase_min_client_severity": "keyword2",
    "sybase_min_error_severity": "keyword2",
    "sybase_min_message_severity": "keyword2",
    "sybase_min_server_severity": "keyword2",
    "sybase_num_fields": "keyword2",
    "sybase_num_rows": "keyword2",
    "sybase_pconnect": "keyword2",
    "sybase_query": "keyword2",
    "sybase_result": "keyword2",
    "sybase_select_db": "keyword2",
    "symlink": "keyword2",
    "syslog": "keyword2",
    "system": "keyword2",
    "tan": "keyword2",
    "tempnam": "keyword2",
    "textdomain": "keyword2",
    "throw": "keyword1",
    "time": "keyword2",
    "time_nanosleep": "keyword2",
    "tmpfile": "keyword2",
    "touch": "keyword2",
    "trigger_error": "keyword2",
    "trim": "keyword2",
    "true": "keyword3",
    "try": "keyword1",
    "uasort": "keyword2",
    "ucfirst": "keyword2",
    "ucwords": "keyword2",
    "udm_add_search_limit": "keyword2",
    "udm_alloc_agent": "keyword2",
    "udm_api_version": "keyword2",
    "udm_clear_search_limits": "keyword2",
    "udm_errno": "keyword2",
    "udm_error": "keyword2",
    "udm_find": "keyword2",
    "udm_free_agent": "keyword2",
    "udm_free_ispell_data": "keyword2",
    "udm_free_res": "keyword2",
    "udm_get_doc_count": "keyword2",
    "udm_get_res_field": "keyword2",
    "udm_get_res_param": "keyword2",
    "udm_load_ispell_data": "keyword2",
    "udm_set_agent_param": "keyword2",
    "uksort": "keyword2",
    "umask": "keyword2",
    "uniqid": "keyword2",
    "unixtojd": "keyword2",
    "unlink": "keyword2",
    "unpack": "keyword2",
    "unregister_tick_function": "keyword2",
    "unserialize": "keyword2",
    "unset": "keyword2",
    "urldecode": "keyword2",
    "urlencode": "keyword2",
    "user_error": "keyword2",
    "usleep": "keyword2",
    "usort": "keyword2",
    "utf8_decode": "keyword2",
    "utf8_encode": "keyword2",
    "var": "keyword1",
    "var_dump": "keyword2",
    "velocis_autocommit": "keyword2",
    "velocis_close": "keyword2",
    "velocis_commit": "keyword2",
    "velocis_connect": "keyword2",
    "velocis_exec": "keyword2",
    "velocis_fetch": "keyword2",
    "velocis_fieldname": "keyword2",
    "velocis_fieldnum": "keyword2",
    "velocis_freeresult": "keyword2",
    "velocis_off_autocommit": "keyword2",
    "velocis_result": "keyword2",
    "velocis_rollback": "keyword2",
    "virtual": "keyword2",
    "vpopmail_add_alias_domain": "keyword2",
    "vpopmail_add_alias_domain_ex": "keyword2",
    "vpopmail_add_domain": "keyword2",
    "vpopmail_add_domain_ex": "keyword2",
    "vpopmail_add_user": "keyword2",
    "vpopmail_auth_user": "keyword2",
    "vpopmail_del_domain": "keyword2",
    "vpopmail_del_domain_ex": "keyword2",
    "vpopmail_del_user": "keyword2",
    "vpopmail_error": "keyword2",
    "vpopmail_passwd": "keyword2",
    "vpopmail_set_user_quota": "keyword2",
    "wddx_add_vars": "keyword2",
    "wddx_deserialize": "keyword2",
    "wddx_packet_end": "keyword2",
    "wddx_packet_start": "keyword2",
    "wddx_serialize_value": "keyword2",
    "wddx_serialize_vars": "keyword2",
    "while": "keyword1",
    "wordwrap": "keyword2",
    "write": "keyword2",
    "writev": "keyword2",
    "xml_error_string": "keyword2",
    "xml_get_current_byte_index": "keyword2",
    "xml_get_current_column_number": "keyword2",
    "xml_get_current_line_number": "keyword2",
    "xml_get_error_code": "keyword2",
    "xml_parse": "keyword2",
    "xml_parse_into_struct": "keyword2",
    "xml_parser_create": "keyword2",
    "xml_parser_create_ns": "keyword2",
    "xml_parser_free": "keyword2",
    "xml_parser_get_option": "keyword2",
    "xml_parser_set_option": "keyword2",
    "xml_set_character_data_handler": "keyword2",
    "xml_set_default_handler": "keyword2",
    "xml_set_element_handler": "keyword2",
    "xml_set_end_namespace_decl_handler": "keyword2",
    "xml_set_external_entity_ref_handler": "keyword2",
    "xml_set_notation_decl_handler": "keyword2",
    "xml_set_object": "keyword2",
    "xml_set_processing_instruction_handler": "keyword2",
    "xml_set_start_namespace_decl_handler": "keyword2",
    "xml_set_unparsed_entity_decl_handler": "keyword2",
    "xmldoc": "keyword2",
    "xmldocfile": "keyword2",
    "xmltree": "keyword2",
    "xpath_eval": "keyword2",
    "xpath_eval_expression": "keyword2",
    "xptr_eval": "keyword2",
    "xslt_closelog": "keyword2",
    "xslt_create": "keyword2",
    "xslt_errno": "keyword2",
    "xslt_error": "keyword2",
    "xslt_fetch_result": "keyword2",
    "xslt_free": "keyword2",
    "xslt_openlog": "keyword2",
    "xslt_output_begintransform": "keyword2",
    "xslt_output_endtransform": "keyword2",
    "xslt_process": "keyword2",
    "xslt_run": "keyword2",
    "xslt_set_base": "keyword2",
    "xslt_set_encoding": "keyword2",
    "xslt_set_error_handler": "keyword2",
    "xslt_set_sax_handler": "keyword2",
    "xslt_set_scheme_handler": "keyword2",
    "xslt_transform": "keyword2",
    "yaz_addinfo": "keyword2",
    "yaz_ccl_conf": "keyword2",
    "yaz_ccl_parse": "keyword2",
    "yaz_close": "keyword2",
    "yaz_connect": "keyword2",
    "yaz_database": "keyword2",
    "yaz_element": "keyword2",
    "yaz_errno": "keyword2",
    "yaz_error": "keyword2",
    "yaz_hits": "keyword2",
    "yaz_itemorder": "keyword2",
    "yaz_present": "keyword2",
    "yaz_range": "keyword2",
    "yaz_record": "keyword2",
    "yaz_scan": "keyword2",
    "yaz_scan_result": "keyword2",
    "yaz_search": "keyword2",
    "yaz_syntax": "keyword2",
    "yaz_wait": "keyword2",
    "yp_all": "keyword2",
    "yp_cat": "keyword2",
    "yp_err_string": "keyword2",
    "yp_errno": "keyword2",
    "yp_first": "keyword2",
    "yp_get_default_domain": "keyword2",
    "yp_master": "keyword2",
    "yp_match": "keyword2",
    "yp_next": "keyword2",
    "yp_order": "keyword2",
    "zend_logo_guid": "keyword2",
    "zend_test_func": "keyword2",
    "zend_version": "keyword2",
    "zzip_close": "keyword2",
    "zzip_closedir": "keyword2",
    "zzip_entry_compressedsize": "keyword2",
    "zzip_entry_compressionmethod": "keyword2",
    "zzip_entry_filesize": "keyword2",
    "zzip_entry_name": "keyword2",
    "zzip_open": "keyword2",
    "zzip_opendir": "keyword2",
    "zzip_read": "keyword2",
    "zzip_readdir": "keyword2",
}

# Keywords dict for php_php_literal ruleset.
php_php_literal_keywords_dict = {}

# Keywords dict for php_javascript ruleset.
php_javascript_keywords_dict = {}

# Keywords dict for php_javascript_php ruleset.
php_javascript_php_keywords_dict = {}

# Keywords dict for php_phpdoc ruleset.
php_phpdoc_keywords_dict = {
    "@abstract": "label",
    "@access": "label",
    "@author": "label",
    "@category": "label",
    "@copyright": "label",
    "@deprecated": "label",
    "@example": "label",
    "@filesource": "label",
    "@final": "label",
    "@global": "label",
    "@id": "label",
    "@ignore": "label",
    "@inheritdoc": "label",
    "@internal": "label",
    "@license": "label",
    "@link": "label",
    "@name": "label",
    "@package": "label",
    "@param": "label",
    "@return": "label",
    "@see": "label",
    "@since": "label",
    "@source": "label",
    "@static": "label",
    "@staticvar": "label",
    "@subpackage": "label",
    "@toc": "label",
    "@todo": "label",
    "@tutorial": "label",
    "@uses": "label",
    "@var": "label",
    "@version": "label",
}

# Dictionary of keywords dictionaries for php mode.
keywordsDictDict = {
    "php_javascript": php_javascript_keywords_dict,
    "php_javascript_php": php_javascript_php_keywords_dict,
    "php_main": php_main_keywords_dict,
    "php_php": php_php_keywords_dict,
    "php_php_literal": php_php_literal_keywords_dict,
    "php_phpdoc": php_phpdoc_keywords_dict,
    "php_tags": php_tags_keywords_dict,
    "php_tags_literal": php_tags_literal_keywords_dict,
}
</t>
<t tx="ekr.20201022053907.4"># Rules for php_main ruleset...
# All rules start with '&lt;' or '&amp;'.

def php_rule0(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_rule4(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="markup",
        begin="&lt;SCRIPT\\s+LANGUAGE=\"?PHP\"?&gt;", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_rule5(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;SCRIPT", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::javascript",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule6(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;STYLE", end="&lt;/STYLE&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="html::css",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule7(colorer, s, i):
    return colorer.match_span(s, i, kind="keyword2", begin="&lt;!", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::dtd-tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule8(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_rule9(colorer, s, i):
    return colorer.match_span(s, i, kind="literal2", begin="&amp;", end=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=True)

# Rules dict for php_main ruleset.
php_main_rulesdict = {
    "&amp;": [php_rule9],
    "&lt;": [php_rule0,php_rule1,php_rule2,php_rule3,php_rule4,php_rule5,php_rule6,php_rule7,php_rule8],
}
</t>
<t tx="ekr.20201022053907.5"># Rules for the php_tags ruleset...

def php_tags_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_tags_rule4(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_rule5(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
        
def php_tags_rule6(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")
        
# Rules dict for php_tags ruleset.
php_tags_rulesdict = {
    "\"": [php_tags_rule4,],
    "'": [php_tags_rule5,],
    "&lt;": [php_tags_rule1, php_tags_rule2, php_tags_rule3,],
    "=": [php_tags_rule6,],
}

</t>
<t tx="ekr.20201022053907.6">def php_tags_literal_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_literal_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_tags_literal_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

# Rules dict for php_tags_literal ruleset.
php_tags_literal_rulesdict = {
    "&lt;": [
        php_tags_literal_rule1,
        php_tags_literal_rule2,
        php_tags_literal_rule3,
    ],
}
</t>
<t tx="ekr.20201022053907.7"># Rules for the php_php ruleset...

</t>
<t tx="ekr.20201022053907.8">def php_php_comment1(colorer, s, i):
    return colorer.match_span(s, i, kind="comment3", begin="/**", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::phpdoc",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_comment2(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="/*", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_comment3(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment2", seq="//",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)

def php_php_comment4(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="#",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)
</t>
<t tx="ekr.20201022053907.9">def php_php_literal1(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_literal2(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_literal3(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="`", end="`",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def php_php_literal4(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="literal1",
        begin="&lt;&lt;&lt;[[:space:]'\"]*([[:alnum:]_]+)[[:space:]'\"]*", end="$1",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
</t>
<t tx="ekr.20201022055738.1">use_php_hack = False

# Properties for php mode.
properties = {
    "commentEnd": "--&gt;",
    "commentStart": "&lt;!--",
    "indentCloseBrackets": "}",
    "indentOpenBrackets": "{",
    "lineUpClosingBracket": "true",
}

# Attributes dict for php_main ruleset.
php_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags ruleset.
php_tags_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_tags_literal ruleset.
php_tags_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php ruleset.
php_php_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_php_literal ruleset.
php_php_literal_attributes_dict = {
    "default": "LITERAL1",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript ruleset.
php_javascript_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_javascript_php ruleset.
php_javascript_php_attributes_dict = {
    "default": "MARKUP",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Attributes dict for php_phpdoc ruleset.
php_phpdoc_attributes_dict = {
    "default": "COMMENT3",
    "digit_re": "",
    "escape": "\\",
    "highlight_digits": "true",
    "ignore_case": "true",
    "no_word_sep": "",
}

# Dictionary of attributes dictionaries for php mode.
attributesDictDict = {
    "php_javascript": php_javascript_attributes_dict,
    "php_javascript_php": php_javascript_php_attributes_dict,
    "php_main": php_main_attributes_dict,
    "php_php": php_php_attributes_dict,
    "php_php_literal": php_php_literal_attributes_dict,
    "php_phpdoc": php_phpdoc_attributes_dict,
    "php_tags": php_tags_attributes_dict,
    "php_tags_literal": php_tags_literal_attributes_dict,
}

# Keywords dict for php_main ruleset.
php_main_keywords_dict = {}

# Keywords dict for php_tags ruleset.
php_tags_keywords_dict = {}

# Keywords dict for php_tags_literal ruleset.
php_tags_literal_keywords_dict = {}

# Keywords dict for php_php ruleset.
php_php_keywords_dict = {
    "__class__": "keyword3",
    "__file__": "keyword3",
    "__function__": "keyword3",
    "__line__": "keyword3",
    "__method__": "keyword3",
    "abs": "keyword2",
    "abstract": "keyword1",
    "accept_connect": "keyword2",
    "acos": "keyword2",
    "add": "keyword2",
    "add_iovec": "keyword2",
    "addaction": "keyword2",
    "addcolor": "keyword2",
    "addcslashes": "keyword2",
    "addentry": "keyword2",
    "addfill": "keyword2",
    "addshape": "keyword2",
    "addslashes": "keyword2",
    "addstring": "keyword2",
    "align": "keyword2",
    "and": "operator",
    "apache_child_terminate": "keyword2",
    "apache_lookup_uri": "keyword2",
    "apache_note": "keyword2",
    "apache_sub_req": "keyword2",
    "array": "keyword1",
    "array_combine": "keyword2",
    "array_count_values": "keyword2",
    "array_diff": "keyword2",
    "array_diff_assoc": "keyword2",
    "array_diff_uassoc": "keyword2",
    "array_filter": "keyword2",
    "array_flip": "keyword2",
    "array_intersect": "keyword2",
    "array_intersect_assoc": "keyword2",
    "array_keys": "keyword2",
    "array_map": "keyword2",
    "array_merge": "keyword2",
    "array_merge_recursive": "keyword2",
    "array_multisort": "keyword2",
    "array_pad": "keyword2",
    "array_pop": "keyword2",
    "array_push": "keyword2",
    "array_rand": "keyword2",
    "array_reduce": "keyword2",
    "array_reverse": "keyword2",
    "array_search": "keyword2",
    "array_shift": "keyword2",
    "array_slice": "keyword2",
    "array_splice": "keyword2",
    "array_sum": "keyword2",
    "array_udiff": "keyword2",
    "array_udiff_assoc": "keyword2",
    "array_udiff_uassoc": "keyword2",
    "array_unique": "keyword2",
    "array_unshift": "keyword2",
    "array_values": "keyword2",
    "array_walk": "keyword2",
    "array_walk_recursive": "keyword2",
    "arsort": "keyword2",
    "as": "keyword1",
    "asin": "keyword2",
    "asort": "keyword2",
    "aspell_check": "keyword2",
    "aspell_check_raw": "keyword2",
    "aspell_new": "keyword2",
    "aspell_suggest": "keyword2",
    "assert": "keyword2",
    "assert_options": "keyword2",
    "atan": "keyword2",
    "atan2": "keyword2",
    "base64_decode": "keyword2",
    "base64_encode": "keyword2",
    "base_convert": "keyword2",
    "basename": "keyword2",
    "bcadd": "keyword2",
    "bccomp": "keyword2",
    "bcdiv": "keyword2",
    "bcmod": "keyword2",
    "bcmul": "keyword2",
    "bcpow": "keyword2",
    "bcscale": "keyword2",
    "bcsqrt": "keyword2",
    "bcsub": "keyword2",
    "bin2hex": "keyword2",
    "bind": "keyword2",
    "bindec": "keyword2",
    "bindtextdomain": "keyword2",
    "break": "keyword1",
    "build_iovec": "keyword2",
    "bzclose": "keyword2",
    "bzcompress": "keyword2",
    "bzdecompress": "keyword2",
    "bzerrno": "keyword2",
    "bzerror": "keyword2",
    "bzerrstr": "keyword2",
    "bzflush": "keyword2",
    "bzopen": "keyword2",
    "bzread": "keyword2",
    "bzwrite": "keyword2",
    "call_user_func": "keyword2",
    "call_user_func_array": "keyword2",
    "call_user_method": "keyword2",
    "call_user_method_array": "keyword2",
    "case": "keyword1",
    "catch": "keyword1",
    "ccvs_add": "keyword2",
    "ccvs_auth": "keyword2",
    "ccvs_command": "keyword2",
    "ccvs_count": "keyword2",
    "ccvs_delete": "keyword2",
    "ccvs_done": "keyword2",
    "ccvs_init": "keyword2",
    "ccvs_lookup": "keyword2",
    "ccvs_new": "keyword2",
    "ccvs_report": "keyword2",
    "ccvs_return": "keyword2",
    "ccvs_reverse": "keyword2",
    "ccvs_sale": "keyword2",
    "ccvs_status": "keyword2",
    "ccvs_textvalue": "keyword2",
    "ccvs_void": "keyword2",
    "ceil": "keyword2",
    "chdir": "keyword2",
    "checkdate": "keyword2",
    "checkdnsrr": "keyword2",
    "chgrp": "keyword2",
    "chmod": "keyword2",
    "chop": "keyword2",
    "chown": "keyword2",
    "chr": "keyword2",
    "chroot": "keyword2",
    "chunk_split": "keyword2",
    "class": "keyword1",
    "class_exists": "keyword2",
    "clearstatcache": "keyword2",
    "clone": "keyword1",
    "close": "keyword2",
    "closedir": "keyword2",
    "closelog": "keyword2",
    "com_get": "keyword2",
    "com_invoke": "keyword2",
    "com_load": "keyword2",
    "com_propget": "keyword2",
    "com_propput": "keyword2",
    "com_propset": "keyword2",
    "com_set": "keyword2",
    "compact": "keyword2",
    "confirm_cybermut_compiled": "keyword2",
    "confirm_extname_compiled": "keyword2",
    "connect": "keyword2",
    "connection_aborted": "keyword2",
    "connection_status": "keyword2",
    "const": "keyword1",
    "constant": "keyword2",
    "continue": "keyword1",
    "convert_cyr_string": "keyword2",
    "convert_uudecode": "keyword2",
    "convert_uuencode": "keyword2",
    "copy": "keyword2",
    "cos": "keyword2",
    "count": "keyword2",
    "count_chars": "keyword2",
    "cpdf_add_annotation": "keyword2",
    "cpdf_add_outline": "keyword2",
    "cpdf_arc": "keyword2",
    "cpdf_begin_text": "keyword2",
    "cpdf_circle": "keyword2",
    "cpdf_clip": "keyword2",
    "cpdf_close": "keyword2",
    "cpdf_closepath": "keyword2",
    "cpdf_closepath_fill_stroke": "keyword2",
    "cpdf_closepath_stroke": "keyword2",
    "cpdf_continue_text": "keyword2",
    "cpdf_curveto": "keyword2",
    "cpdf_end_text": "keyword2",
    "cpdf_fill": "keyword2",
    "cpdf_fill_stroke": "keyword2",
    "cpdf_finalize": "keyword2",
    "cpdf_finalize_page": "keyword2",
    "cpdf_global_set_document_limits": "keyword2",
    "cpdf_import_jpeg": "keyword2",
    "cpdf_lineto": "keyword2",
    "cpdf_moveto": "keyword2",
    "cpdf_newpath": "keyword2",
    "cpdf_open": "keyword2",
    "cpdf_output_buffer": "keyword2",
    "cpdf_page_init": "keyword2",
    "cpdf_place_inline_image": "keyword2",
    "cpdf_rect": "keyword2",
    "cpdf_restore": "keyword2",
    "cpdf_rlineto": "keyword2",
    "cpdf_rmoveto": "keyword2",
    "cpdf_rotate": "keyword2",
    "cpdf_rotate_text": "keyword2",
    "cpdf_save": "keyword2",
    "cpdf_save_to_file": "keyword2",
    "cpdf_scale": "keyword2",
    "cpdf_set_action_url": "keyword2",
    "cpdf_set_char_spacing": "keyword2",
    "cpdf_set_creator": "keyword2",
    "cpdf_set_current_page": "keyword2",
    "cpdf_set_font": "keyword2",
    "cpdf_set_font_directories": "keyword2",
    "cpdf_set_font_map_file": "keyword2",
    "cpdf_set_horiz_scaling": "keyword2",
    "cpdf_set_keywords": "keyword2",
    "cpdf_set_leading": "keyword2",
    "cpdf_set_page_animation": "keyword2",
    "cpdf_set_subject": "keyword2",
    "cpdf_set_text_matrix": "keyword2",
    "cpdf_set_text_pos": "keyword2",
    "cpdf_set_text_rendering": "keyword2",
    "cpdf_set_text_rise": "keyword2",
    "cpdf_set_title": "keyword2",
    "cpdf_set_viewer_preferences": "keyword2",
    "cpdf_set_word_spacing": "keyword2",
    "cpdf_setdash": "keyword2",
    "cpdf_setflat": "keyword2",
    "cpdf_setgray": "keyword2",
    "cpdf_setgray_fill": "keyword2",
    "cpdf_setgray_stroke": "keyword2",
    "cpdf_setlinecap": "keyword2",
    "cpdf_setlinejoin": "keyword2",
    "cpdf_setlinewidth": "keyword2",
    "cpdf_setmiterlimit": "keyword2",
    "cpdf_setrgbcolor": "keyword2",
    "cpdf_setrgbcolor_fill": "keyword2",
    "cpdf_setrgbcolor_stroke": "keyword2",
    "cpdf_show": "keyword2",
    "cpdf_show_xy": "keyword2",
    "cpdf_stringwidth": "keyword2",
    "cpdf_stroke": "keyword2",
    "cpdf_text": "keyword2",
    "cpdf_translate": "keyword2",
    "crack_check": "keyword2",
    "crack_closedict": "keyword2",
    "crack_getlastmessage": "keyword2",
    "crack_opendict": "keyword2",
    "crash": "keyword2",
    "crc32": "keyword2",
    "create_function": "keyword2",
    "crypt": "keyword2",
    "ctype_alnum": "keyword2",
    "ctype_alpha": "keyword2",
    "ctype_cntrl": "keyword2",
    "ctype_digit": "keyword2",
    "ctype_graph": "keyword2",
    "ctype_lower": "keyword2",
    "ctype_print": "keyword2",
    "ctype_punct": "keyword2",
    "ctype_space": "keyword2",
    "ctype_upper": "keyword2",
    "ctype_xdigit": "keyword2",
    "curl_close": "keyword2",
    "curl_errno": "keyword2",
    "curl_error": "keyword2",
    "curl_exec": "keyword2",
    "curl_getinfo": "keyword2",
    "curl_init": "keyword2",
    "curl_setopt": "keyword2",
    "curl_version": "keyword2",
    "current": "keyword2",
    "cv_add": "keyword2",
    "cv_auth": "keyword2",
    "cv_command": "keyword2",
    "cv_count": "keyword2",
    "cv_delete": "keyword2",
    "cv_done": "keyword2",
    "cv_init": "keyword2",
    "cv_lookup": "keyword2",
    "cv_new": "keyword2",
    "cv_report": "keyword2",
    "cv_return": "keyword2",
    "cv_reverse": "keyword2",
    "cv_sale": "keyword2",
    "cv_status": "keyword2",
    "cv_textvalue": "keyword2",
    "cv_void": "keyword2",
    "cybercash_base64_decode": "keyword2",
    "cybercash_base64_encode": "keyword2",
    "cybercash_decr": "keyword2",
    "cybercash_encr": "keyword2",
    "cybermut_creerformulairecm": "keyword2",
    "cybermut_creerreponsecm": "keyword2",
    "cybermut_testmac": "keyword2",
    "date": "keyword2",
    "dba_close": "keyword2",
    "dba_delete": "keyword2",
    "dba_exists": "keyword2",
    "dba_fetch": "keyword2",
    "dba_firstkey": "keyword2",
    "dba_insert": "keyword2",
    "dba_nextkey": "keyword2",
    "dba_open": "keyword2",
    "dba_optimize": "keyword2",
    "dba_popen": "keyword2",
    "dba_replace": "keyword2",
    "dba_sync": "keyword2",
    "dbase_add_record": "keyword2",
    "dbase_close": "keyword2",
    "dbase_create": "keyword2",
    "dbase_delete_record": "keyword2",
    "dbase_get_record": "keyword2",
    "dbase_get_record_with_names": "keyword2",
    "dbase_numfields": "keyword2",
    "dbase_numrecords": "keyword2",
    "dbase_open": "keyword2",
    "dbase_pack": "keyword2",
    "dbase_replace_record": "keyword2",
    "dblist": "keyword2",
    "dbmclose": "keyword2",
    "dbmdelete": "keyword2",
    "dbmexists": "keyword2",
    "dbmfetch": "keyword2",
    "dbmfirstkey": "keyword2",
    "dbminsert": "keyword2",
    "dbmnextkey": "keyword2",
    "dbmopen": "keyword2",
    "dbmreplace": "keyword2",
    "dbx_close": "keyword2",
    "dbx_cmp_asc": "keyword2",
    "dbx_cmp_desc": "keyword2",
    "dbx_connect": "keyword2",
    "dbx_error": "keyword2",
    "dbx_query": "keyword2",
    "dbx_sort": "keyword2",
    "dcgettext": "keyword2",
    "debug_backtrace": "keyword2",
    "debug_print_backtrace": "keyword2",
    "decbin": "keyword2",
    "dechex": "keyword2",
    "declare": "keyword1",
    "decoct": "keyword2",
    "default": "keyword1",
    "define": "keyword2",
    "define_syslog_variables": "keyword2",
    "defined": "keyword2",
    "deg2rad": "keyword2",
    "delete_iovec": "keyword2",
    "dgettext": "keyword2",
    "die": "keyword2",
    "dir": "keyword2",
    "dirname": "keyword2",
    "diskfreespace": "keyword2",
    "display_disabled_function": "keyword2",
    "dl": "keyword2",
    "do": "keyword1",
    "domxml_add_root": "keyword2",
    "domxml_attributes": "keyword2",
    "domxml_children": "keyword2",
    "domxml_dumpmem": "keyword2",
    "domxml_elem_get_attribute": "keyword2",
    "domxml_elem_set_attribute": "keyword2",
    "domxml_get_attribute": "keyword2",
    "domxml_getattr": "keyword2",
    "domxml_new_child": "keyword2",
    "domxml_new_xmldoc": "keyword2",
    "domxml_node": "keyword2",
    "domxml_node_attributes": "keyword2",
    "domxml_node_children": "keyword2",
    "domxml_node_new_child": "keyword2",
    "domxml_node_set_content": "keyword2",
    "domxml_node_unlink_node": "keyword2",
    "domxml_root": "keyword2",
    "domxml_set_attribute": "keyword2",
    "domxml_setattr": "keyword2",
    "domxml_unlink_node": "keyword2",
    "domxml_version": "keyword2",
    "doubleval": "keyword2",
    "drawarc": "keyword2",
    "drawcircle": "keyword2",
    "drawcubic": "keyword2",
    "drawcubicto": "keyword2",
    "drawcurve": "keyword2",
    "drawcurveto": "keyword2",
    "drawglyph": "keyword2",
    "drawline": "keyword2",
    "drawlineto": "keyword2",
    "each": "keyword2",
    "easter_date": "keyword2",
    "easter_days": "keyword2",
    "echo": "keyword1",
    "else": "keyword1",
    "elseif": "keyword1",
    "empty": "keyword1",
    "end": "keyword2",
    "endfor": "keyword1",
    "endforeach": "keyword1",
    "endif": "keyword1",
    "endswitch": "keyword1",
    "endwhile": "keyword1",
    "ereg": "keyword2",
    "ereg_replace": "keyword2",
    "eregi": "keyword2",
    "eregi_replace": "keyword2",
    "error_log": "keyword2",
    "error_reporting": "keyword2",
    "escapeshellarg": "keyword2",
    "escapeshellcmd": "keyword2",
    "exec": "keyword2",
    "exit": "keyword2",
    "exp": "keyword2",
    "explode": "keyword2",
    "extends": "keyword1",
    "extension_loaded": "keyword2",
    "extract": "keyword2",
    "ezmlm_hash": "keyword2",
    "false": "keyword3",
    "fbsql": "keyword2",
    "fbsql_affected_rows": "keyword2",
    "fbsql_autocommit": "keyword2",
    "fbsql_close": "keyword2",
    "fbsql_commit": "keyword2",
    "fbsql_connect": "keyword2",
    "fbsql_create_db": "keyword2",
    "fbsql_data_seek": "keyword2",
    "fbsql_database": "keyword2",
    "fbsql_database_password": "keyword2",
    "fbsql_db_query": "keyword2",
    "fbsql_drop_db": "keyword2",
    "fbsql_errno": "keyword2",
    "fbsql_error": "keyword2",
    "fbsql_fetch_array": "keyword2",
    "fbsql_fetch_assoc": "keyword2",
    "fbsql_fetch_field": "keyword2",
    "fbsql_fetch_lengths": "keyword2",
    "fbsql_fetch_object": "keyword2",
    "fbsql_fetch_row": "keyword2",
    "fbsql_field_flags": "keyword2",
    "fbsql_field_len": "keyword2",
    "fbsql_field_name": "keyword2",
    "fbsql_field_seek": "keyword2",
    "fbsql_field_table": "keyword2",
    "fbsql_field_type": "keyword2",
    "fbsql_free_result": "keyword2",
    "fbsql_hostname": "keyword2",
    "fbsql_insert_id": "keyword2",
    "fbsql_list_dbs": "keyword2",
    "fbsql_list_fields": "keyword2",
    "fbsql_list_tables": "keyword2",
    "fbsql_next_result": "keyword2",
    "fbsql_num_fields": "keyword2",
    "fbsql_num_rows": "keyword2",
    "fbsql_password": "keyword2",
    "fbsql_pconnect": "keyword2",
    "fbsql_query": "keyword2",
    "fbsql_result": "keyword2",
    "fbsql_rollback": "keyword2",
    "fbsql_select_db": "keyword2",
    "fbsql_start_db": "keyword2",
    "fbsql_stop_db": "keyword2",
    "fbsql_username": "keyword2",
    "fbsql_warnings": "keyword2",
    "fclose": "keyword2",
    "fd_alloc": "keyword2",
    "fd_clear": "keyword2",
    "fd_dealloc": "keyword2",
    "fd_isset": "keyword2",
    "fd_set": "keyword2",
    "fd_zero": "keyword2",
    "fdf_add_template": "keyword2",
    "fdf_close": "keyword2",
    "fdf_create": "keyword2",
    "fdf_get_file": "keyword2",
    "fdf_get_status": "keyword2",
    "fdf_get_value": "keyword2",
    "fdf_next_field_name": "keyword2",
    "fdf_open": "keyword2",
    "fdf_save": "keyword2",
    "fdf_set_ap": "keyword2",
    "fdf_set_file": "keyword2",
    "fdf_set_flags": "keyword2",
    "fdf_set_javascript_action": "keyword2",
    "fdf_set_opt": "keyword2",
    "fdf_set_status": "keyword2",
    "fdf_set_submit_form_action": "keyword2",
    "fdf_set_value": "keyword2",
    "feof": "keyword2",
    "fetch_iovec": "keyword2",
    "fflush": "keyword2",
    "fgetc": "keyword2",
    "fgetcsv": "keyword2",
    "fgets": "keyword2",
    "fgetss": "keyword2",
    "file": "keyword2",
    "file_exists": "keyword2",
    "file_get_contents": "keyword2",
    "file_put_contents": "keyword2",
    "fileatime": "keyword2",
    "filectime": "keyword2",
    "filegroup": "keyword2",
    "fileinode": "keyword2",
    "filemtime": "keyword2",
    "fileowner": "keyword2",
    "fileperms": "keyword2",
    "filepro": "keyword2",
    "filepro_fieldcount": "keyword2",
    "filepro_fieldname": "keyword2",
    "filepro_fieldtype": "keyword2",
    "filepro_fieldwidth": "keyword2",
    "filepro_retrieve": "keyword2",
    "filepro_rowcount": "keyword2",
    "filesize": "keyword2",
    "filetype": "keyword2",
    "final": "keyword1",
    "floatval": "keyword2",
    "flock": "keyword2",
    "floor": "keyword2",
    "flush": "keyword2",
    "fopen": "keyword2",
    "fopenstream": "keyword2",
    "for": "keyword1",
    "foreach": "keyword1",
    "fpassthru": "keyword2",
    "fputs": "keyword2",
    "fread": "keyword2",
    "free_iovec": "keyword2",
    "frenchtojd": "keyword2",
    "fribidi_log2vis": "keyword2",
    "fscanf": "keyword2",
    "fseek": "keyword2",
    "fsockopen": "keyword2",
    "fstat": "keyword2",
    "ftell": "keyword2",
    "ftp_alloc": "keyword2",
    "ftp_cdup": "keyword2",
    "ftp_chdir": "keyword2",
    "ftp_connect": "keyword2",
    "ftp_delete": "keyword2",
    "ftp_exec": "keyword2",
    "ftp_fget": "keyword2",
    "ftp_fput": "keyword2",
    "ftp_get": "keyword2",
    "ftp_login": "keyword2",
    "ftp_mdtm": "keyword2",
    "ftp_mkdir": "keyword2",
    "ftp_nlist": "keyword2",
    "ftp_pasv": "keyword2",
    "ftp_put": "keyword2",
    "ftp_pwd": "keyword2",
    "ftp_quit": "keyword2",
    "ftp_rawlist": "keyword2",
    "ftp_rename": "keyword2",
    "ftp_rmdir": "keyword2",
    "ftp_site": "keyword2",
    "ftp_size": "keyword2",
    "ftp_ssl_connect": "keyword2",
    "ftp_systype": "keyword2",
    "ftruncate": "keyword2",
    "func_get_arg": "keyword2",
    "func_get_args": "keyword2",
    "func_num_args": "keyword2",
    "function": "keyword1",
    "function_exists": "keyword2",
    "fwrite": "keyword2",
    "gd_info": "keyword2",
    "get_all_headers": "keyword2",
    "get_browser": "keyword2",
    "get_cfg_var": "keyword2",
    "get_class": "keyword2",
    "get_class_methods": "keyword2",
    "get_class_vars": "keyword2",
    "get_current_user": "keyword2",
    "get_declared_classes": "keyword2",
    "get_declared_interfaces": "keyword2",
    "get_defined_functions": "keyword2",
    "get_defined_vars": "keyword2",
    "get_extension_funcs": "keyword2",
    "get_headers": "keyword2",
    "get_html_translation_table": "keyword2",
    "get_included_files": "keyword2",
    "get_loaded_extensions": "keyword2",
    "get_magic_quotes_gpc": "keyword2",
    "get_magic_quotes_runtime": "keyword2",
    "get_meta_tags": "keyword2",
    "get_object_vars": "keyword2",
    "get_parent_class": "keyword2",
    "get_required_files": "keyword2",
    "get_resource_type": "keyword2",
    "getallheaders": "keyword2",
    "getascent": "keyword2",
    "getcwd": "keyword2",
    "getdate": "keyword2",
    "getdescent": "keyword2",
    "getenv": "keyword2",
    "getheight": "keyword2",
    "gethostbyaddr": "keyword2",
    "gethostbyname": "keyword2",
    "gethostbynamel": "keyword2",
    "getimagesize": "keyword2",
    "getlastmod": "keyword2",
    "getleading": "keyword2",
    "getmxrr": "keyword2",
    "getmyinode": "keyword2",
    "getmypid": "keyword2",
    "getmyuid": "keyword2",
    "getopt": "keyword2",
    "getpeername": "keyword2",
    "getprotobyname": "keyword2",
    "getprotobynumber": "keyword2",
    "getrandmax": "keyword2",
    "getrusage": "keyword2",
    "getservbyname": "keyword2",
    "getservbyport": "keyword2",
    "getshape1": "keyword2",
    "getshape2": "keyword2",
    "getsockname": "keyword2",
    "getsockopt": "keyword2",
    "gettext": "keyword2",
    "gettimeofday": "keyword2",
    "gettype": "keyword2",
    "getwidth": "keyword2",
    "global": "keyword1",
    "gmdate": "keyword2",
    "gmmktime": "keyword2",
    "gmp_abs": "keyword2",
    "gmp_add": "keyword2",
    "gmp_and": "keyword2",
    "gmp_clrbit": "keyword2",
    "gmp_cmp": "keyword2",
    "gmp_com": "keyword2",
    "gmp_div": "keyword2",
    "gmp_div_q": "keyword2",
    "gmp_div_qr": "keyword2",
    "gmp_div_r": "keyword2",
    "gmp_divexact": "keyword2",
    "gmp_fact": "keyword2",
    "gmp_gcd": "keyword2",
    "gmp_gcdext": "keyword2",
    "gmp_hamdist": "keyword2",
    "gmp_init": "keyword2",
    "gmp_intval": "keyword2",
    "gmp_invert": "keyword2",
    "gmp_jacobi": "keyword2",
    "gmp_legendre": "keyword2",
    "gmp_mod": "keyword2",
    "gmp_mul": "keyword2",
    "gmp_neg": "keyword2",
    "gmp_or": "keyword2",
    "gmp_perfect_square": "keyword2",
    "gmp_popcount": "keyword2",
    "gmp_pow": "keyword2",
    "gmp_powm": "keyword2",
    "gmp_prob_prime": "keyword2",
    "gmp_random": "keyword2",
    "gmp_scan0": "keyword2",
    "gmp_scan1": "keyword2",
    "gmp_setbit": "keyword2",
    "gmp_sign": "keyword2",
    "gmp_sqrt": "keyword2",
    "gmp_sqrtrem": "keyword2",
    "gmp_strval": "keyword2",
    "gmp_sub": "keyword2",
    "gmp_xor": "keyword2",
    "gmstrftime": "keyword2",
    "gregoriantojd": "keyword2",
    "gzclose": "keyword2",
    "gzcompress": "keyword2",
    "gzdeflate": "keyword2",
    "gzencode": "keyword2",
    "gzeof": "keyword2",
    "gzfile": "keyword2",
    "gzgetc": "keyword2",
    "gzgets": "keyword2",
    "gzgetss": "keyword2",
    "gzinflate": "keyword2",
    "gzopen": "keyword2",
    "gzpassthru": "keyword2",
    "gzputs": "keyword2",
    "gzread": "keyword2",
    "gzrewind": "keyword2",
    "gzseek": "keyword2",
    "gztell": "keyword2",
    "gzuncompress": "keyword2",
    "gzwrite": "keyword2",
    "header": "keyword2",
    "headers_list": "keyword2",
    "headers_sent": "keyword2",
    "hebrev": "keyword2",
    "hebrevc": "keyword2",
    "hexdec": "keyword2",
    "highlight_file": "keyword2",
    "highlight_string": "keyword2",
    "htmlentities": "keyword2",
    "htmlspecialchars": "keyword2",
    "http_build_query": "keyword2",
    "hw_array2objrec": "keyword2",
    "hw_changeobject": "keyword2",
    "hw_children": "keyword2",
    "hw_childrenobj": "keyword2",
    "hw_close": "keyword2",
    "hw_connect": "keyword2",
    "hw_connection_info": "keyword2",
    "hw_cp": "keyword2",
    "hw_deleteobject": "keyword2",
    "hw_docbyanchor": "keyword2",
    "hw_docbyanchorobj": "keyword2",
    "hw_document_attributes": "keyword2",
    "hw_document_bodytag": "keyword2",
    "hw_document_content": "keyword2",
    "hw_document_setcontent": "keyword2",
    "hw_document_size": "keyword2",
    "hw_dummy": "keyword2",
    "hw_edittext": "keyword2",
    "hw_error": "keyword2",
    "hw_errormsg": "keyword2",
    "hw_free_document": "keyword2",
    "hw_getanchors": "keyword2",
    "hw_getanchorsobj": "keyword2",
    "hw_getandlock": "keyword2",
    "hw_getcgi": "keyword2",
    "hw_getchildcoll": "keyword2",
    "hw_getchildcollobj": "keyword2",
    "hw_getchilddoccoll": "keyword2",
    "hw_getchilddoccollobj": "keyword2",
    "hw_getobject": "keyword2",
    "hw_getobjectbyftquery": "keyword2",
    "hw_getobjectbyftquerycoll": "keyword2",
    "hw_getobjectbyftquerycollobj": "keyword2",
    "hw_getobjectbyftqueryobj": "keyword2",
    "hw_getobjectbyquery": "keyword2",
    "hw_getobjectbyquerycoll": "keyword2",
    "hw_getobjectbyquerycollobj": "keyword2",
    "hw_getobjectbyqueryobj": "keyword2",
    "hw_getparents": "keyword2",
    "hw_getparentsobj": "keyword2",
    "hw_getrellink": "keyword2",
    "hw_getremote": "keyword2",
    "hw_getremotechildren": "keyword2",
    "hw_getsrcbydestobj": "keyword2",
    "hw_gettext": "keyword2",
    "hw_getusername": "keyword2",
    "hw_identify": "keyword2",
    "hw_incollections": "keyword2",
    "hw_info": "keyword2",
    "hw_inscoll": "keyword2",
    "hw_insdoc": "keyword2",
    "hw_insertanchors": "keyword2",
    "hw_insertdocument": "keyword2",
    "hw_insertobject": "keyword2",
    "hw_mapid": "keyword2",
    "hw_modifyobject": "keyword2",
    "hw_mv": "keyword2",
    "hw_new_document": "keyword2",
    "hw_new_document_from_file": "keyword2",
    "hw_objrec2array": "keyword2",
    "hw_output_document": "keyword2",
    "hw_pconnect": "keyword2",
    "hw_pipecgi": "keyword2",
    "hw_pipedocument": "keyword2",
    "hw_root": "keyword2",
    "hw_setlinkroot": "keyword2",
    "hw_stat": "keyword2",
    "hw_unlock": "keyword2",
    "hw_who": "keyword2",
    "ibase_blob_add": "keyword2",
    "ibase_blob_cancel": "keyword2",
    "ibase_blob_close": "keyword2",
    "ibase_blob_create": "keyword2",
    "ibase_blob_echo": "keyword2",
    "ibase_blob_get": "keyword2",
    "ibase_blob_import": "keyword2",
    "ibase_blob_info": "keyword2",
    "ibase_blob_open": "keyword2",
    "ibase_close": "keyword2",
    "ibase_commit": "keyword2",
    "ibase_connect": "keyword2",
    "ibase_errmsg": "keyword2",
    "ibase_execute": "keyword2",
    "ibase_fetch_object": "keyword2",
    "ibase_fetch_row": "keyword2",
    "ibase_field_info": "keyword2",
    "ibase_free_query": "keyword2",
    "ibase_free_result": "keyword2",
    "ibase_num_fields": "keyword2",
    "ibase_pconnect": "keyword2",
    "ibase_prepare": "keyword2",
    "ibase_query": "keyword2",
    "ibase_rollback": "keyword2",
    "ibase_timefmt": "keyword2",
    "ibase_trans": "keyword2",
    "icap_create_calendar": "keyword2",
    "icap_delete_calendar": "keyword2",
    "icap_delete_event": "keyword2",
    "icap_fetch_event": "keyword2",
    "icap_list_alarms": "keyword2",
    "icap_list_events": "keyword2",
    "icap_open": "keyword2",
    "icap_popen": "keyword2",
    "icap_rename_calendar": "keyword2",
    "icap_reopen": "keyword2",
    "icap_snooze": "keyword2",
    "icap_store_event": "keyword2",
    "iconv": "keyword2",
    "iconv_get_encoding": "keyword2",
    "iconv_set_encoding": "keyword2",
    "idate": "keyword2",
    "if": "keyword1",
    "ifx_affected_rows": "keyword2",
    "ifx_blobinfile_mode": "keyword2",
    "ifx_byteasvarchar": "keyword2",
    "ifx_close": "keyword2",
    "ifx_connect": "keyword2",
    "ifx_copy_blob": "keyword2",
    "ifx_create_blob": "keyword2",
    "ifx_create_char": "keyword2",
    "ifx_do": "keyword2",
    "ifx_error": "keyword2",
    "ifx_errormsg": "keyword2",
    "ifx_fetch_row": "keyword2",
    "ifx_fieldproperties": "keyword2",
    "ifx_fieldtypes": "keyword2",
    "ifx_free_blob": "keyword2",
    "ifx_free_char": "keyword2",
    "ifx_free_result": "keyword2",
    "ifx_get_blob": "keyword2",
    "ifx_get_char": "keyword2",
    "ifx_getsqlca": "keyword2",
    "ifx_htmltbl_result": "keyword2",
    "ifx_nullformat": "keyword2",
    "ifx_num_fields": "keyword2",
    "ifx_num_rows": "keyword2",
    "ifx_pconnect": "keyword2",
    "ifx_prepare": "keyword2",
    "ifx_query": "keyword2",
    "ifx_textasvarchar": "keyword2",
    "ifx_update_blob": "keyword2",
    "ifx_update_char": "keyword2",
    "ifxus_close_slob": "keyword2",
    "ifxus_create_slob": "keyword2",
    "ifxus_free_slob": "keyword2",
    "ifxus_open_slob": "keyword2",
    "ifxus_read_slob": "keyword2",
    "ifxus_seek_slob": "keyword2",
    "ifxus_tell_slob": "keyword2",
    "ifxus_write_slob": "keyword2",
    "ignore_user_abort": "keyword2",
    "iis_addserver": "keyword2",
    "iis_getdirsecurity": "keyword2",
    "iis_getscriptmap": "keyword2",
    "iis_getserverbycomment": "keyword2",
    "iis_getserverbypath": "keyword2",
    "iis_getserverright": "keyword2",
    "iis_getservicestate": "keyword2",
    "iis_removeserver": "keyword2",
    "iis_setappsettings": "keyword2",
    "iis_setdirsecurity": "keyword2",
    "iis_setscriptmap": "keyword2",
    "iis_setserverright": "keyword2",
    "iis_startserver": "keyword2",
    "iis_startservice": "keyword2",
    "iis_stopserver": "keyword2",
    "iis_stopservice": "keyword2",
    "image2wbmp": "keyword2",
    "image_type_to_extension": "keyword2",
    "imagealphablending": "keyword2",
    "imagearc": "keyword2",
    "imagechar": "keyword2",
    "imagecharup": "keyword2",
    "imagecolorallocate": "keyword2",
    "imagecolorat": "keyword2",
    "imagecolorclosest": "keyword2",
    "imagecolorclosestalpha": "keyword2",
    "imagecolorclosesthwb": "keyword2",
    "imagecolordeallocate": "keyword2",
    "imagecolorexact": "keyword2",
    "imagecolorexactalpha": "keyword2",
    "imagecolormatch": "keyword2",
    "imagecolorresolve": "keyword2",
    "imagecolorresolvealpha": "keyword2",
    "imagecolorset": "keyword2",
    "imagecolorsforindex": "keyword2",
    "imagecolorstotal": "keyword2",
    "imagecolortransparent": "keyword2",
    "imagecopy": "keyword2",
    "imagecopymerge": "keyword2",
    "imagecopymergegray": "keyword2",
    "imagecopyresampled": "keyword2",
    "imagecopyresized": "keyword2",
    "imagecreate": "keyword2",
    "imagecreatefromgif": "keyword2",
    "imagecreatefromjpeg": "keyword2",
    "imagecreatefrompng": "keyword2",
    "imagecreatefromstring": "keyword2",
    "imagecreatefromwbmp": "keyword2",
    "imagecreatefromxbm": "keyword2",
    "imagecreatefromxpm": "keyword2",
    "imagecreatetruecolor": "keyword2",
    "imagedashedline": "keyword2",
    "imagedestroy": "keyword2",
    "imageellipse": "keyword2",
    "imagefill": "keyword2",
    "imagefilledarc": "keyword2",
    "imagefilledellipse": "keyword2",
    "imagefilledpolygon": "keyword2",
    "imagefilledrectangle": "keyword2",
    "imagefilltoborder": "keyword2",
    "imagefilter": "keyword2",
    "imagefontheight": "keyword2",
    "imagefontwidth": "keyword2",
    "imagegammacorrect": "keyword2",
    "imagegif": "keyword2",
    "imageinterlace": "keyword2",
    "imagejpeg": "keyword2",
    "imagelayereffect": "keyword2",
    "imageline": "keyword2",
    "imageloadfont": "keyword2",
    "imagepalettecopy": "keyword2",
    "imagepng": "keyword2",
    "imagepolygon": "keyword2",
    "imagepsbbox": "keyword2",
    "imagepscopyfont": "keyword2",
    "imagepsencodefont": "keyword2",
    "imagepsextendfont": "keyword2",
    "imagepsfreefont": "keyword2",
    "imagepsloadfont": "keyword2",
    "imagepsslantfont": "keyword2",
    "imagepstext": "keyword2",
    "imagerectangle": "keyword2",
    "imagerotate": "keyword2",
    "imagesetbrush": "keyword2",
    "imagesetpixel": "keyword2",
    "imagesetstyle": "keyword2",
    "imagesetthickness": "keyword2",
    "imagesettile": "keyword2",
    "imagestring": "keyword2",
    "imagestringup": "keyword2",
    "imagesx": "keyword2",
    "imagesy": "keyword2",
    "imagetruecolortopalette": "keyword2",
    "imagettfbbox": "keyword2",
    "imagettftext": "keyword2",
    "imagetypes": "keyword2",
    "imagewbmp": "keyword2",
    "imap_8bit": "keyword2",
    "imap_alerts": "keyword2",
    "imap_append": "keyword2",
    "imap_base64": "keyword2",
    "imap_binary": "keyword2",
    "imap_body": "keyword2",
    "imap_bodystruct": "keyword2",
    "imap_check": "keyword2",
    "imap_clearflag_full": "keyword2",
    "imap_close": "keyword2",
    "imap_create": "keyword2",
    "imap_createmailbox": "keyword2",
    "imap_delete": "keyword2",
    "imap_deletemailbox": "keyword2",
    "imap_errors": "keyword2",
    "imap_expunge": "keyword2",
    "imap_fetch_overview": "keyword2",
    "imap_fetchbody": "keyword2",
    "imap_fetchheader": "keyword2",
    "imap_fetchstructure": "keyword2",
    "imap_fetchtext": "keyword2",
    "imap_get_quota": "keyword2",
    "imap_getmailboxes": "keyword2",
    "imap_getsubscribed": "keyword2",
    "imap_header": "keyword2",
    "imap_headerinfo": "keyword2",
    "imap_headers": "keyword2",
    "imap_last_error": "keyword2",
    "imap_list": "keyword2",
    "imap_listmailbox": "keyword2",
    "imap_listsubscribed": "keyword2",
    "imap_lsub": "keyword2",
    "imap_mail": "keyword2",
    "imap_mail_compose": "keyword2",
    "imap_mail_copy": "keyword2",
    "imap_mail_move": "keyword2",
    "imap_mailboxmsginfo": "keyword2",
    "imap_mime_header_decode": "keyword2",
    "imap_msgno": "keyword2",
    "imap_num_msg": "keyword2",
    "imap_num_recent": "keyword2",
    "imap_open": "keyword2",
    "imap_ping": "keyword2",
    "imap_popen": "keyword2",
    "imap_qprint": "keyword2",
    "imap_rename": "keyword2",
    "imap_renamemailbox": "keyword2",
    "imap_reopen": "keyword2",
    "imap_rfc822_parse_adrlist": "keyword2",
    "imap_rfc822_parse_headers": "keyword2",
    "imap_rfc822_write_address": "keyword2",
    "imap_scan": "keyword2",
    "imap_scanmailbox": "keyword2",
    "imap_search": "keyword2",
    "imap_set_quota": "keyword2",
    "imap_setflag_full": "keyword2",
    "imap_sort": "keyword2",
    "imap_status": "keyword2",
    "imap_subscribe": "keyword2",
    "imap_uid": "keyword2",
    "imap_undelete": "keyword2",
    "imap_unsubscribe": "keyword2",
    "imap_utf7_decode": "keyword2",
    "imap_utf7_encode": "keyword2",
    "imap_utf8": "keyword2",
    "implements": "keyword1",
    "implode": "keyword2",
    "in_array": "keyword2",
    "include": "keyword1",
    "include_once": "keyword1",
    "ingres_autocommit": "keyword2",
    "ingres_close": "keyword2",
    "ingres_commit": "keyword2",
    "ingres_connect": "keyword2",
    "ingres_fetch_array": "keyword2",
    "ingres_fetch_object": "keyword2",
    "ingres_fetch_row": "keyword2",
    "ingres_field_length": "keyword2",
    "ingres_field_name": "keyword2",
    "ingres_field_nullable": "keyword2",
    "ingres_field_precision": "keyword2",
    "ingres_field_scale": "keyword2",
    "ingres_field_type": "keyword2",
    "ingres_num_fields": "keyword2",
    "ingres_num_rows": "keyword2",
    "ingres_pconnect": "keyword2",
    "ingres_query": "keyword2",
    "ingres_rollback": "keyword2",
    "ini_alter": "keyword2",
    "ini_get": "keyword2",
    "ini_restore": "keyword2",
    "ini_set": "keyword2",
    "instanceof": "operator",
    "interface": "keyword1",
    "intval": "keyword2",
    "ip2long": "keyword2",
    "iptcembed": "keyword2",
    "iptcparse": "keyword2",
    "ircg_channel_mode": "keyword2",
    "ircg_disconnect": "keyword2",
    "ircg_html_encode": "keyword2",
    "ircg_ignore_add": "keyword2",
    "ircg_ignore_del": "keyword2",
    "ircg_is_conn_alive": "keyword2",
    "ircg_join": "keyword2",
    "ircg_kick": "keyword2",
    "ircg_lookup_format_messages": "keyword2",
    "ircg_msg": "keyword2",
    "ircg_nick": "keyword2",
    "ircg_nickname_escape": "keyword2",
    "ircg_nickname_unescape": "keyword2",
    "ircg_notice": "keyword2",
    "ircg_part": "keyword2",
    "ircg_pconnect": "keyword2",
    "ircg_register_format_messages": "keyword2",
    "ircg_set_current": "keyword2",
    "ircg_topic": "keyword2",
    "ircg_whois": "keyword2",
    "is_array": "keyword2",
    "is_bool": "keyword2",
    "is_dir": "keyword2",
    "is_double": "keyword2",
    "is_executable": "keyword2",
    "is_file": "keyword2",
    "is_float": "keyword2",
    "is_int": "keyword2",
    "is_integer": "keyword2",
    "is_link": "keyword2",
    "is_long": "keyword2",
    "is_null": "keyword2",
    "is_numeric": "keyword2",
    "is_object": "keyword2",
    "is_readable": "keyword2",
    "is_real": "keyword2",
    "is_resource": "keyword2",
    "is_scalar": "keyword2",
    "is_string": "keyword2",
    "is_subclass_of": "keyword2",
    "is_uploaded_file": "keyword2",
    "is_writable": "keyword2",
    "is_writeable": "keyword2",
    "isset": "keyword1",
    "java_last_exception_clear": "keyword2",
    "java_last_exception_get": "keyword2",
    "jddayofweek": "keyword2",
    "jdmonthname": "keyword2",
    "jdtofrench": "keyword2",
    "jdtogregorian": "keyword2",
    "jdtojewish": "keyword2",
    "jdtojulian": "keyword2",
    "jdtounix": "keyword2",
    "jewishtojd": "keyword2",
    "join": "keyword2",
    "jpeg2wbmp": "keyword2",
    "juliantojd": "keyword2",
    "key": "keyword2",
    "krsort": "keyword2",
    "ksort": "keyword2",
    "labelframe": "keyword2",
    "lcg_value": "keyword2",
    "ldap_8859_to_t61": "keyword2",
    "ldap_add": "keyword2",
    "ldap_bind": "keyword2",
    "ldap_close": "keyword2",
    "ldap_compare": "keyword2",
    "ldap_connect": "keyword2",
    "ldap_count_entries": "keyword2",
    "ldap_delete": "keyword2",
    "ldap_dn2ufn": "keyword2",
    "ldap_err2str": "keyword2",
    "ldap_errno": "keyword2",
    "ldap_error": "keyword2",
    "ldap_explode_dn": "keyword2",
    "ldap_first_attribute": "keyword2",
    "ldap_first_entry": "keyword2",
    "ldap_first_reference": "keyword2",
    "ldap_free_result": "keyword2",
    "ldap_get_attributes": "keyword2",
    "ldap_get_dn": "keyword2",
    "ldap_get_entries": "keyword2",
    "ldap_get_option": "keyword2",
    "ldap_get_values": "keyword2",
    "ldap_get_values_len": "keyword2",
    "ldap_list": "keyword2",
    "ldap_mod_add": "keyword2",
    "ldap_mod_del": "keyword2",
    "ldap_mod_replace": "keyword2",
    "ldap_modify": "keyword2",
    "ldap_next_attribute": "keyword2",
    "ldap_next_entry": "keyword2",
    "ldap_next_reference": "keyword2",
    "ldap_parse_reference": "keyword2",
    "ldap_parse_result": "keyword2",
    "ldap_read": "keyword2",
    "ldap_rename": "keyword2",
    "ldap_search": "keyword2",
    "ldap_set_option": "keyword2",
    "ldap_t61_to_8859": "keyword2",
    "ldap_unbind": "keyword2",
    "leak": "keyword2",
    "levenshtein": "keyword2",
    "link": "keyword2",
    "linkinfo": "keyword2",
    "list": "keyword1",
    "listen": "keyword2",
    "localeconv": "keyword2",
    "localtime": "keyword2",
    "log": "keyword2",
    "log10": "keyword2",
    "long2ip": "keyword2",
    "lstat": "keyword2",
    "ltrim": "keyword2",
    "magic_quotes_runtime": "keyword2",
    "mail": "keyword2",
    "max": "keyword2",
    "mb_convert_case": "keyword2",
    "mb_strtolower": "keyword2",
    "mb_strtoupper": "keyword2",
    "mcal_append_event": "keyword2",
    "mcal_close": "keyword2",
    "mcal_create_calendar": "keyword2",
    "mcal_date_compare": "keyword2",
    "mcal_date_valid": "keyword2",
    "mcal_day_of_week": "keyword2",
    "mcal_day_of_year": "keyword2",
    "mcal_days_in_month": "keyword2",
    "mcal_delete_calendar": "keyword2",
    "mcal_delete_event": "keyword2",
    "mcal_event_add_attribute": "keyword2",
    "mcal_event_init": "keyword2",
    "mcal_event_set_alarm": "keyword2",
    "mcal_event_set_category": "keyword2",
    "mcal_event_set_class": "keyword2",
    "mcal_event_set_description": "keyword2",
    "mcal_event_set_end": "keyword2",
    "mcal_event_set_recur_daily": "keyword2",
    "mcal_event_set_recur_monthly_mday": "keyword2",
    "mcal_event_set_recur_monthly_wday": "keyword2",
    "mcal_event_set_recur_none": "keyword2",
    "mcal_event_set_recur_weekly": "keyword2",
    "mcal_event_set_recur_yearly": "keyword2",
    "mcal_event_set_start": "keyword2",
    "mcal_event_set_title": "keyword2",
    "mcal_fetch_current_stream_event": "keyword2",
    "mcal_fetch_event": "keyword2",
    "mcal_is_leap_year": "keyword2",
    "mcal_list_alarms": "keyword2",
    "mcal_list_events": "keyword2",
    "mcal_next_recurrence": "keyword2",
    "mcal_open": "keyword2",
    "mcal_popen": "keyword2",
    "mcal_rename_calendar": "keyword2",
    "mcal_reopen": "keyword2",
    "mcal_snooze": "keyword2",
    "mcal_store_event": "keyword2",
    "mcal_time_valid": "keyword2",
    "mcal_week_of_year": "keyword2",
    "mcrypt_cbc": "keyword2",
    "mcrypt_cfb": "keyword2",
    "mcrypt_create_iv": "keyword2",
    "mcrypt_decrypt": "keyword2",
    "mcrypt_ecb": "keyword2",
    "mcrypt_enc_get_algorithms_name": "keyword2",
    "mcrypt_enc_get_block_size": "keyword2",
    "mcrypt_enc_get_iv_size": "keyword2",
    "mcrypt_enc_get_key_size": "keyword2",
    "mcrypt_enc_get_modes_name": "keyword2",
    "mcrypt_enc_get_supported_key_sizes": "keyword2",
    "mcrypt_enc_is_block_algorithm": "keyword2",
    "mcrypt_enc_is_block_algorithm_mode": "keyword2",
    "mcrypt_enc_is_block_mode": "keyword2",
    "mcrypt_enc_self_test": "keyword2",
    "mcrypt_encrypt": "keyword2",
    "mcrypt_generic": "keyword2",
    "mcrypt_generic_deinit": "keyword2",
    "mcrypt_generic_end": "keyword2",
    "mcrypt_generic_init": "keyword2",
    "mcrypt_get_block_size": "keyword2",
    "mcrypt_get_cipher_name": "keyword2",
    "mcrypt_get_iv_size": "keyword2",
    "mcrypt_get_key_size": "keyword2",
    "mcrypt_list_algorithms": "keyword2",
    "mcrypt_list_modes": "keyword2",
    "mcrypt_module_close": "keyword2",
    "mcrypt_module_get_algo_block_size": "keyword2",
    "mcrypt_module_get_algo_key_size": "keyword2",
    "mcrypt_module_get_supported_key_sizes": "keyword2",
    "mcrypt_module_is_block_algorithm": "keyword2",
    "mcrypt_module_is_block_algorithm_mode": "keyword2",
    "mcrypt_module_is_block_mode": "keyword2",
    "mcrypt_module_open": "keyword2",
    "mcrypt_module_self_test": "keyword2",
    "mcrypt_ofb": "keyword2",
    "md5": "keyword2",
    "md5_file": "keyword2",
    "mdecrypt_generic": "keyword2",
    "metaphone": "keyword2",
    "method_exists": "keyword2",
    "mhash": "keyword2",
    "mhash_count": "keyword2",
    "mhash_get_block_size": "keyword2",
    "mhash_get_hash_name": "keyword2",
    "mhash_keygen_s2k": "keyword2",
    "microtime": "keyword2",
    "min": "keyword2",
    "ming_setcubicthreshold": "keyword2",
    "ming_setscale": "keyword2",
    "mkdir": "keyword2",
    "mktime": "keyword2",
    "move": "keyword2",
    "move_uploaded_file": "keyword2",
    "movepen": "keyword2",
    "movepento": "keyword2",
    "moveto": "keyword2",
    "msql": "keyword2",
    "msql_affected_rows": "keyword2",
    "msql_close": "keyword2",
    "msql_connect": "keyword2",
    "msql_create_db": "keyword2",
    "msql_createdb": "keyword2",
    "msql_data_seek": "keyword2",
    "msql_db_query": "keyword2",
    "msql_dbname": "keyword2",
    "msql_drop_db": "keyword2",
    "msql_dropdb": "keyword2",
    "msql_error": "keyword2",
    "msql_fetch_array": "keyword2",
    "msql_fetch_field": "keyword2",
    "msql_fetch_object": "keyword2",
    "msql_fetch_row": "keyword2",
    "msql_field_flags": "keyword2",
    "msql_field_len": "keyword2",
    "msql_field_name": "keyword2",
    "msql_field_seek": "keyword2",
    "msql_field_table": "keyword2",
    "msql_field_type": "keyword2",
    "msql_fieldflags": "keyword2",
    "msql_fieldlen": "keyword2",
    "msql_fieldname": "keyword2",
    "msql_fieldtable": "keyword2",
    "msql_fieldtype": "keyword2",
    "msql_free_result": "keyword2",
    "msql_freeresult": "keyword2",
    "msql_list_dbs": "keyword2",
    "msql_list_fields": "keyword2",
    "msql_list_tables": "keyword2",
    "msql_listdbs": "keyword2",
    "msql_listfields": "keyword2",
    "msql_listtables": "keyword2",
    "msql_num_fields": "keyword2",
    "msql_num_rows": "keyword2",
    "msql_numfields": "keyword2",
    "msql_numrows": "keyword2",
    "msql_pconnect": "keyword2",
    "msql_query": "keyword2",
    "msql_regcase": "keyword2",
    "msql_result": "keyword2",
    "msql_select_db": "keyword2",
    "msql_selectdb": "keyword2",
    "msql_tablename": "keyword2",
    "mssql_affected_rows": "keyword2",
    "mssql_close": "keyword2",
    "mssql_connect": "keyword2",
    "mssql_data_seek": "keyword2",
    "mssql_fetch_array": "keyword2",
    "mssql_fetch_batch": "keyword2",
    "mssql_fetch_field": "keyword2",
    "mssql_fetch_object": "keyword2",
    "mssql_fetch_row": "keyword2",
    "mssql_field_length": "keyword2",
    "mssql_field_name": "keyword2",
    "mssql_field_seek": "keyword2",
    "mssql_field_type": "keyword2",
    "mssql_free_result": "keyword2",
    "mssql_get_last_message": "keyword2",
    "mssql_min_client_severity": "keyword2",
    "mssql_min_error_severity": "keyword2",
    "mssql_min_message_severity": "keyword2",
    "mssql_min_server_severity": "keyword2",
    "mssql_next_result": "keyword2",
    "mssql_num_fields": "keyword2",
    "mssql_num_rows": "keyword2",
    "mssql_pconnect": "keyword2",
    "mssql_query": "keyword2",
    "mssql_result": "keyword2",
    "mssql_rows_affected": "keyword2",
    "mssql_select_db": "keyword2",
    "mt_getrandmax": "keyword2",
    "mt_rand": "keyword2",
    "mt_srand": "keyword2",
    "multcolor": "keyword2",
    "muscat_close": "keyword2",
    "muscat_get": "keyword2",
    "muscat_give": "keyword2",
    "muscat_setup": "keyword2",
    "muscat_setup_net": "keyword2",
    "mysql": "keyword2",
    "mysql_affected_rows": "keyword2",
    "mysql_close": "keyword2",
    "mysql_connect": "keyword2",
    "mysql_create_db": "keyword2",
    "mysql_createdb": "keyword2",
    "mysql_data_seek": "keyword2",
    "mysql_db_name": "keyword2",
    "mysql_db_query": "keyword2",
    "mysql_dbname": "keyword2",
    "mysql_drop_db": "keyword2",
    "mysql_dropdb": "keyword2",
    "mysql_errno": "keyword2",
    "mysql_error": "keyword2",
    "mysql_escape_string": "keyword2",
    "mysql_fetch_array": "keyword2",
    "mysql_fetch_assoc": "keyword2",
    "mysql_fetch_field": "keyword2",
    "mysql_fetch_lengths": "keyword2",
    "mysql_fetch_object": "keyword2",
    "mysql_fetch_row": "keyword2",
    "mysql_field_flags": "keyword2",
    "mysql_field_len": "keyword2",
    "mysql_field_name": "keyword2",
    "mysql_field_seek": "keyword2",
    "mysql_field_table": "keyword2",
    "mysql_field_type": "keyword2",
    "mysql_fieldflags": "keyword2",
    "mysql_fieldlen": "keyword2",
    "mysql_fieldname": "keyword2",
    "mysql_fieldtable": "keyword2",
    "mysql_fieldtype": "keyword2",
    "mysql_free_result": "keyword2",
    "mysql_freeresult": "keyword2",
    "mysql_get_client_info": "keyword2",
    "mysql_get_host_info": "keyword2",
    "mysql_get_proto_info": "keyword2",
    "mysql_get_server_info": "keyword2",
    "mysql_insert_id": "keyword2",
    "mysql_list_dbs": "keyword2",
    "mysql_list_fields": "keyword2",
    "mysql_list_tables": "keyword2",
    "mysql_listdbs": "keyword2",
    "mysql_listfields": "keyword2",
    "mysql_listtables": "keyword2",
    "mysql_num_fields": "keyword2",
    "mysql_num_rows": "keyword2",
    "mysql_numfields": "keyword2",
    "mysql_numrows": "keyword2",
    "mysql_pconnect": "keyword2",
    "mysql_query": "keyword2",
    "mysql_result": "keyword2",
    "mysql_select_db": "keyword2",
    "mysql_selectdb": "keyword2",
    "mysql_tablename": "keyword2",
    "mysql_unbuffered_query": "keyword2",
    "natcasesort": "keyword2",
    "natsort": "keyword2",
    "new": "keyword1",
    "new_xmldoc": "keyword2",
    "next": "keyword2",
    "nextframe": "keyword2",
    "nl2br": "keyword2",
    "notes_body": "keyword2",
    "notes_copy_db": "keyword2",
    "notes_create_db": "keyword2",
    "notes_create_note": "keyword2",
    "notes_drop_db": "keyword2",
    "notes_find_note": "keyword2",
    "notes_header_info": "keyword2",
    "notes_list_msgs": "keyword2",
    "notes_mark_read": "keyword2",
    "notes_mark_unread": "keyword2",
    "notes_nav_create": "keyword2",
    "notes_search": "keyword2",
    "notes_unread": "keyword2",
    "notes_version": "keyword2",
    "null": "keyword3",
    "number_format": "keyword2",
    "ob_end_clean": "keyword2",
    "ob_end_flush": "keyword2",
    "ob_get_clean": "keyword2",
    "ob_get_contents": "keyword2",
    "ob_get_flush": "keyword2",
    "ob_get_length": "keyword2",
    "ob_gzhandler": "keyword2",
    "ob_iconv_handler": "keyword2",
    "ob_implicit_flush": "keyword2",
    "ob_list_handlers": "keyword2",
    "ob_start": "keyword2",
    "ocibindbyname": "keyword2",
    "ocicancel": "keyword2",
    "ocicollappend": "keyword2",
    "ocicollassign": "keyword2",
    "ocicollassignelem": "keyword2",
    "ocicolldateappendelem": "keyword2",
    "ocicolldateassignelem": "keyword2",
    "ocicolldategetelem": "keyword2",
    "ocicollgetelem": "keyword2",
    "ocicollmax": "keyword2",
    "ocicollsize": "keyword2",
    "ocicolltrim": "keyword2",
    "ocicolumnisnull": "keyword2",
    "ocicolumnname": "keyword2",
    "ocicolumnprecision": "keyword2",
    "ocicolumnscale": "keyword2",
    "ocicolumnsize": "keyword2",
    "ocicolumntype": "keyword2",
    "ocicolumntyperaw": "keyword2",
    "ocicommit": "keyword2",
    "ocidefinebyname": "keyword2",
    "ocierror": "keyword2",
    "ociexecute": "keyword2",
    "ocifetch": "keyword2",
    "ocifetchinto": "keyword2",
    "ocifetchstatement": "keyword2",
    "ocifreecoll": "keyword2",
    "ocifreecursor": "keyword2",
    "ocifreedesc": "keyword2",
    "ocifreestatement": "keyword2",
    "ociinternaldebug": "keyword2",
    "ociloadlob": "keyword2",
    "ocilogoff": "keyword2",
    "ocilogon": "keyword2",
    "ocinewcollection": "keyword2",
    "ocinewcursor": "keyword2",
    "ocinewdescriptor": "keyword2",
    "ocinlogon": "keyword2",
    "ocinumcols": "keyword2",
    "ociparse": "keyword2",
    "ociplogon": "keyword2",
    "ociresult": "keyword2",
    "ocirollback": "keyword2",
    "ocirowcount": "keyword2",
    "ocisavelob": "keyword2",
    "ocisavelobfile": "keyword2",
    "ociserverversion": "keyword2",
    "ocisetprefetch": "keyword2",
    "ocistatementtype": "keyword2",
    "ociwritelobtofile": "keyword2",
    "octdec": "keyword2",
    "odbc_autocommit": "keyword2",
    "odbc_binmode": "keyword2",
    "odbc_close": "keyword2",
    "odbc_close_all": "keyword2",
    "odbc_columnprivileges": "keyword2",
    "odbc_columns": "keyword2",
    "odbc_commit": "keyword2",
    "odbc_connect": "keyword2",
    "odbc_cursor": "keyword2",
    "odbc_data_source": "keyword2",
    "odbc_do": "keyword2",
    "odbc_error": "keyword2",
    "odbc_errormsg": "keyword2",
    "odbc_exec": "keyword2",
    "odbc_execute": "keyword2",
    "odbc_fetch_array": "keyword2",
    "odbc_fetch_into": "keyword2",
    "odbc_fetch_object": "keyword2",
    "odbc_fetch_row": "keyword2",
    "odbc_field_len": "keyword2",
    "odbc_field_name": "keyword2",
    "odbc_field_num": "keyword2",
    "odbc_field_precision": "keyword2",
    "odbc_field_scale": "keyword2",
    "odbc_field_type": "keyword2",
    "odbc_foreignkeys": "keyword2",
    "odbc_free_result": "keyword2",
    "odbc_gettypeinfo": "keyword2",
    "odbc_longreadlen": "keyword2",
    "odbc_next_result": "keyword2",
    "odbc_num_fields": "keyword2",
    "odbc_num_rows": "keyword2",
    "odbc_pconnect": "keyword2",
    "odbc_prepare": "keyword2",
    "odbc_primarykeys": "keyword2",
    "odbc_procedurecolumns": "keyword2",
    "odbc_procedures": "keyword2",
    "odbc_result": "keyword2",
    "odbc_result_all": "keyword2",
    "odbc_rollback": "keyword2",
    "odbc_setoption": "keyword2",
    "odbc_specialcolumns": "keyword2",
    "odbc_statistics": "keyword2",
    "odbc_tableprivileges": "keyword2",
    "odbc_tables": "keyword2",
    "old_function": "keyword1",
    "open_listen_sock": "keyword2",
    "opendir": "keyword2",
    "openlog": "keyword2",
    "openssl_error_string": "keyword2",
    "openssl_free_key": "keyword2",
    "openssl_get_privatekey": "keyword2",
    "openssl_get_publickey": "keyword2",
    "openssl_open": "keyword2",
    "openssl_pkcs7_decrypt": "keyword2",
    "openssl_pkcs7_encrypt": "keyword2",
    "openssl_pkcs7_sign": "keyword2",
    "openssl_pkcs7_verify": "keyword2",
    "openssl_seal": "keyword2",
    "openssl_sign": "keyword2",
    "openssl_verify": "keyword2",
    "openssl_x509_checkpurpose": "keyword2",
    "openssl_x509_free": "keyword2",
    "openssl_x509_parse": "keyword2",
    "openssl_x509_read": "keyword2",
    "or": "operator",
    "ora_bind": "keyword2",
    "ora_close": "keyword2",
    "ora_columnname": "keyword2",
    "ora_columnsize": "keyword2",
    "ora_columntype": "keyword2",
    "ora_commit": "keyword2",
    "ora_commitoff": "keyword2",
    "ora_commiton": "keyword2",
    "ora_do": "keyword2",
    "ora_error": "keyword2",
    "ora_errorcode": "keyword2",
    "ora_exec": "keyword2",
    "ora_fetch": "keyword2",
    "ora_fetch_into": "keyword2",
    "ora_getcolumn": "keyword2",
    "ora_logoff": "keyword2",
    "ora_logon": "keyword2",
    "ora_numcols": "keyword2",
    "ora_numrows": "keyword2",
    "ora_open": "keyword2",
    "ora_parse": "keyword2",
    "ora_plogon": "keyword2",
    "ora_rollback": "keyword2",
    "orbit_caught_exception": "keyword2",
    "orbit_exception_id": "keyword2",
    "orbit_exception_value": "keyword2",
    "orbit_get_repository_id": "keyword2",
    "orbit_load_idl": "keyword2",
    "ord": "keyword2",
    "output": "keyword2",
    "ovrimos_close": "keyword2",
    "ovrimos_close_all": "keyword2",
    "ovrimos_commit": "keyword2",
    "ovrimos_connect": "keyword2",
    "ovrimos_cursor": "keyword2",
    "ovrimos_exec": "keyword2",
    "ovrimos_execute": "keyword2",
    "ovrimos_fetch_into": "keyword2",
    "ovrimos_fetch_row": "keyword2",
    "ovrimos_field_len": "keyword2",
    "ovrimos_field_name": "keyword2",
    "ovrimos_field_num": "keyword2",
    "ovrimos_field_type": "keyword2",
    "ovrimos_free_result": "keyword2",
    "ovrimos_longreadlen": "keyword2",
    "ovrimos_num_fields": "keyword2",
    "ovrimos_num_rows": "keyword2",
    "ovrimos_prepare": "keyword2",
    "ovrimos_result": "keyword2",
    "ovrimos_result_all": "keyword2",
    "ovrimos_rollback": "keyword2",
    "pack": "keyword2",
    "parse_ini_file": "keyword2",
    "parse_str": "keyword2",
    "parse_url": "keyword2",
    "passthru": "keyword2",
    "pathinfo": "keyword2",
    "pclose": "keyword2",
    "pdf_add_annotation": "keyword2",
    "pdf_add_bookmark": "keyword2",
    "pdf_add_launchlink": "keyword2",
    "pdf_add_locallink": "keyword2",
    "pdf_add_note": "keyword2",
    "pdf_add_outline": "keyword2",
    "pdf_add_pdflink": "keyword2",
    "pdf_add_thumbnail": "keyword2",
    "pdf_add_weblink": "keyword2",
    "pdf_arc": "keyword2",
    "pdf_arcn": "keyword2",
    "pdf_attach_file": "keyword2",
    "pdf_begin_page": "keyword2",
    "pdf_begin_pattern": "keyword2",
    "pdf_begin_template": "keyword2",
    "pdf_circle": "keyword2",
    "pdf_clip": "keyword2",
    "pdf_close": "keyword2",
    "pdf_close_image": "keyword2",
    "pdf_close_pdi": "keyword2",
    "pdf_close_pdi_page": "keyword2",
    "pdf_closepath": "keyword2",
    "pdf_closepath_fill_stroke": "keyword2",
    "pdf_closepath_stroke": "keyword2",
    "pdf_concat": "keyword2",
    "pdf_continue_text": "keyword2",
    "pdf_curveto": "keyword2",
    "pdf_delete": "keyword2",
    "pdf_end_page": "keyword2",
    "pdf_end_pattern": "keyword2",
    "pdf_end_template": "keyword2",
    "pdf_endpath": "keyword2",
    "pdf_fill": "keyword2",
    "pdf_fill_stroke": "keyword2",
    "pdf_findfont": "keyword2",
    "pdf_get_buffer": "keyword2",
    "pdf_get_font": "keyword2",
    "pdf_get_fontname": "keyword2",
    "pdf_get_fontsize": "keyword2",
    "pdf_get_image_height": "keyword2",
    "pdf_get_image_width": "keyword2",
    "pdf_get_parameter": "keyword2",
    "pdf_get_pdi_parameter": "keyword2",
    "pdf_get_pdi_value": "keyword2",
    "pdf_get_value": "keyword2",
    "pdf_initgraphics": "keyword2",
    "pdf_lineto": "keyword2",
    "pdf_makespotcolor": "keyword2",
    "pdf_moveto": "keyword2",
    "pdf_new": "keyword2",
    "pdf_open": "keyword2",
    "pdf_open_ccitt": "keyword2",
    "pdf_open_file": "keyword2",
    "pdf_open_gif": "keyword2",
    "pdf_open_image": "keyword2",
    "pdf_open_image_file": "keyword2",
    "pdf_open_jpeg": "keyword2",
    "pdf_open_memory_image": "keyword2",
    "pdf_open_pdi": "keyword2",
    "pdf_open_pdi_page": "keyword2",
    "pdf_open_png": "keyword2",
    "pdf_open_tiff": "keyword2",
    "pdf_place_image": "keyword2",
    "pdf_place_pdi_page": "keyword2",
    "pdf_rect": "keyword2",
    "pdf_restore": "keyword2",
    "pdf_rotate": "keyword2",
    "pdf_save": "keyword2",
    "pdf_scale": "keyword2",
    "pdf_set_border_color": "keyword2",
    "pdf_set_border_dash": "keyword2",
    "pdf_set_border_style": "keyword2",
    "pdf_set_char_spacing": "keyword2",
    "pdf_set_duration": "keyword2",
    "pdf_set_font": "keyword2",
    "pdf_set_horiz_scaling": "keyword2",
    "pdf_set_info": "keyword2",
    "pdf_set_info_author": "keyword2",
    "pdf_set_info_creator": "keyword2",
    "pdf_set_info_keywords": "keyword2",
    "pdf_set_info_subject": "keyword2",
    "pdf_set_info_title": "keyword2",
    "pdf_set_leading": "keyword2",
    "pdf_set_parameter": "keyword2",
    "pdf_set_text_pos": "keyword2",
    "pdf_set_text_rendering": "keyword2",
    "pdf_set_text_rise": "keyword2",
    "pdf_set_transition": "keyword2",
    "pdf_set_value": "keyword2",
    "pdf_set_word_spacing": "keyword2",
    "pdf_setcolor": "keyword2",
    "pdf_setdash": "keyword2",
    "pdf_setflat": "keyword2",
    "pdf_setfont": "keyword2",
    "pdf_setgray": "keyword2",
    "pdf_setgray_fill": "keyword2",
    "pdf_setgray_stroke": "keyword2",
    "pdf_setlinecap": "keyword2",
    "pdf_setlinejoin": "keyword2",
    "pdf_setlinewidth": "keyword2",
    "pdf_setmatrix": "keyword2",
    "pdf_setmiterlimit": "keyword2",
    "pdf_setpolydash": "keyword2",
    "pdf_setrgbcolor": "keyword2",
    "pdf_setrgbcolor_fill": "keyword2",
    "pdf_setrgbcolor_stroke": "keyword2",
    "pdf_show": "keyword2",
    "pdf_show_boxed": "keyword2",
    "pdf_show_xy": "keyword2",
    "pdf_skew": "keyword2",
    "pdf_stringwidth": "keyword2",
    "pdf_stroke": "keyword2",
    "pdf_translate": "keyword2",
    "pfpro_cleanup": "keyword2",
    "pfpro_init": "keyword2",
    "pfpro_process": "keyword2",
    "pfpro_process_raw": "keyword2",
    "pfpro_version": "keyword2",
    "pfsockopen": "keyword2",
    "pg_client_encoding": "keyword2",
    "pg_clientencoding": "keyword2",
    "pg_close": "keyword2",
    "pg_cmdtuples": "keyword2",
    "pg_connect": "keyword2",
    "pg_convert": "keyword2",
    "pg_dbname": "keyword2",
    "pg_delete": "keyword2",
    "pg_end_copy": "keyword2",
    "pg_errormessage": "keyword2",
    "pg_exec": "keyword2",
    "pg_fetch_all": "keyword2",
    "pg_fetch_array": "keyword2",
    "pg_fetch_assoc": "keyword2",
    "pg_fetch_object": "keyword2",
    "pg_fetch_row": "keyword2",
    "pg_fieldisnull": "keyword2",
    "pg_fieldname": "keyword2",
    "pg_fieldnum": "keyword2",
    "pg_fieldprtlen": "keyword2",
    "pg_fieldsize": "keyword2",
    "pg_fieldtype": "keyword2",
    "pg_freeresult": "keyword2",
    "pg_get_notify": "keyword2",
    "pg_get_pid": "keyword2",
    "pg_getlastoid": "keyword2",
    "pg_host": "keyword2",
    "pg_insert": "keyword2",
    "pg_loclose": "keyword2",
    "pg_locreate": "keyword2",
    "pg_loexport": "keyword2",
    "pg_loimport": "keyword2",
    "pg_loopen": "keyword2",
    "pg_loread": "keyword2",
    "pg_loreadall": "keyword2",
    "pg_lounlink": "keyword2",
    "pg_lowrite": "keyword2",
    "pg_meta_data": "keyword2",
    "pg_numfields": "keyword2",
    "pg_numrows": "keyword2",
    "pg_options": "keyword2",
    "pg_pconnect": "keyword2",
    "pg_ping": "keyword2",
    "pg_port": "keyword2",
    "pg_put_line": "keyword2",
    "pg_result": "keyword2",
    "pg_result_seek": "keyword2",
    "pg_select": "keyword2",
    "pg_set_client_encoding": "keyword2",
    "pg_setclientencoding": "keyword2",
    "pg_trace": "keyword2",
    "pg_tty": "keyword2",
    "pg_unescape_bytea": "keyword2",
    "pg_untrace": "keyword2",
    "pg_update": "keyword2",
    "php_logo_guid": "keyword2",
    "php_sapi_name": "keyword2",
    "php_uname": "keyword2",
    "phpcredits": "keyword2",
    "phpinfo": "keyword2",
    "phpversion": "keyword2",
    "pi": "keyword2",
    "png2wbmp": "keyword2",
    "popen": "keyword2",
    "pos": "keyword2",
    "posix_ctermid": "keyword2",
    "posix_getcwd": "keyword2",
    "posix_getegid": "keyword2",
    "posix_geteuid": "keyword2",
    "posix_getgid": "keyword2",
    "posix_getgrgid": "keyword2",
    "posix_getgrnam": "keyword2",
    "posix_getgroups": "keyword2",
    "posix_getlogin": "keyword2",
    "posix_getpgid": "keyword2",
    "posix_getpgrp": "keyword2",
    "posix_getpid": "keyword2",
    "posix_getppid": "keyword2",
    "posix_getpwnam": "keyword2",
    "posix_getpwuid": "keyword2",
    "posix_getrlimit": "keyword2",
    "posix_getsid": "keyword2",
    "posix_getuid": "keyword2",
    "posix_isatty": "keyword2",
    "posix_kill": "keyword2",
    "posix_mkfifo": "keyword2",
    "posix_setegid": "keyword2",
    "posix_seteuid": "keyword2",
    "posix_setgid": "keyword2",
    "posix_setpgid": "keyword2",
    "posix_setsid": "keyword2",
    "posix_setuid": "keyword2",
    "posix_times": "keyword2",
    "posix_ttyname": "keyword2",
    "posix_uname": "keyword2",
    "pow": "keyword2",
    "preg_grep": "keyword2",
    "preg_match": "keyword2",
    "preg_match_all": "keyword2",
    "preg_quote": "keyword2",
    "preg_replace": "keyword2",
    "preg_replace_callback": "keyword2",
    "preg_split": "keyword2",
    "prev": "keyword2",
    "print_r": "keyword2",
    "printer_abort": "keyword2",
    "printer_close": "keyword2",
    "printer_create_brush": "keyword2",
    "printer_create_dc": "keyword2",
    "printer_create_font": "keyword2",
    "printer_create_pen": "keyword2",
    "printer_delete_brush": "keyword2",
    "printer_delete_dc": "keyword2",
    "printer_delete_font": "keyword2",
    "printer_delete_pen": "keyword2",
    "printer_draw_bmp": "keyword2",
    "printer_draw_chord": "keyword2",
    "printer_draw_elipse": "keyword2",
    "printer_draw_line": "keyword2",
    "printer_draw_pie": "keyword2",
    "printer_draw_rectangle": "keyword2",
    "printer_draw_roundrect": "keyword2",
    "printer_draw_text": "keyword2",
    "printer_end_doc": "keyword2",
    "printer_end_page": "keyword2",
    "printer_get_option": "keyword2",
    "printer_list": "keyword2",
    "printer_logical_fontheight": "keyword2",
    "printer_open": "keyword2",
    "printer_select_brush": "keyword2",
    "printer_select_font": "keyword2",
    "printer_select_pen": "keyword2",
    "printer_set_option": "keyword2",
    "printer_start_doc": "keyword2",
    "printer_start_page": "keyword2",
    "printer_write": "keyword2",
    "printf": "keyword2",
    "private": "keyword1",
    "protected": "keyword1",
    "pspell_add_to_personal": "keyword2",
    "pspell_add_to_session": "keyword2",
    "pspell_check": "keyword2",
    "pspell_clear_session": "keyword2",
    "pspell_config_create": "keyword2",
    "pspell_config_ignore": "keyword2",
    "pspell_config_mode": "keyword2",
    "pspell_config_personal": "keyword2",
    "pspell_config_repl": "keyword2",
    "pspell_config_runtogether": "keyword2",
    "pspell_config_save_repl": "keyword2",
    "pspell_new": "keyword2",
    "pspell_new_config": "keyword2",
    "pspell_new_personal": "keyword2",
    "pspell_save_wordlist": "keyword2",
    "pspell_store_replacement": "keyword2",
    "pspell_suggest": "keyword2",
    "public": "keyword1",
    "putenv": "keyword2",
    "qdom_error": "keyword2",
    "qdom_tree": "keyword2",
    "quoted_printable_decode": "keyword2",
    "quotemeta": "keyword2",
    "rad2deg": "keyword2",
    "rand": "keyword2",
    "range": "keyword2",
    "rawurldecode": "keyword2",
    "rawurlencode": "keyword2",
    "read": "keyword2",
    "read_exif_data": "keyword2",
    "readdir": "keyword2",
    "readfile": "keyword2",
    "readgzfile": "keyword2",
    "readline": "keyword2",
    "readline_add_history": "keyword2",
    "readline_clear_history": "keyword2",
    "readline_completion_function": "keyword2",
    "readline_info": "keyword2",
    "readline_list_history": "keyword2",
    "readline_read_history": "keyword2",
    "readline_write_history": "keyword2",
    "readlink": "keyword2",
    "readv": "keyword2",
    "realpath": "keyword2",
    "recode": "keyword2",
    "recode_file": "keyword2",
    "recode_string": "keyword2",
    "recv": "keyword2",
    "recvfrom": "keyword2",
    "recvmsg": "keyword2",
    "register_shutdown_function": "keyword2",
    "register_tick_function": "keyword2",
    "remove": "keyword2",
    "rename": "keyword2",
    "require": "keyword1",
    "require_once": "keyword1",
    "reset": "keyword2",
    "restore_error_handler": "keyword2",
    "return": "keyword1",
    "rewind": "keyword2",
    "rewinddir": "keyword2",
    "rmdir": "keyword2",
    "rotate": "keyword2",
    "rotateto": "keyword2",
    "round": "keyword2",
    "rsort": "keyword2",
    "rtrim": "keyword2",
    "satellite_caught_exception": "keyword2",
    "satellite_exception_id": "keyword2",
    "satellite_exception_value": "keyword2",
    "satellite_get_repository_id": "keyword2",
    "satellite_load_idl": "keyword2",
    "save": "keyword2",
    "savetofile": "keyword2",
    "scale": "keyword2",
    "scaleto": "keyword2",
    "scandir": "keyword2",
    "select": "keyword2",
    "sem_acquire": "keyword2",
    "sem_get": "keyword2",
    "sem_release": "keyword2",
    "send": "keyword2",
    "sendmsg": "keyword2",
    "sendto": "keyword2",
    "serialize": "keyword2",
    "session_cache_limiter": "keyword2",
    "session_decode": "keyword2",
    "session_destroy": "keyword2",
    "session_encode": "keyword2",
    "session_get_cookie_params": "keyword2",
    "session_id": "keyword2",
    "session_is_registered": "keyword2",
    "session_module_name": "keyword2",
    "session_name": "keyword2",
    "session_register": "keyword2",
    "session_save_path": "keyword2",
    "session_set_cookie_params": "keyword2",
    "session_set_save_handler": "keyword2",
    "session_start": "keyword2",
    "session_unregister": "keyword2",
    "session_unset": "keyword2",
    "session_write_close": "keyword2",
    "set_content": "keyword2",
    "set_error_handler": "keyword2",
    "set_file_buffer": "keyword2",
    "set_iovec": "keyword2",
    "set_magic_quotes_runtime": "keyword2",
    "set_nonblock": "keyword2",
    "set_socket_blocking": "keyword2",
    "set_time_limit": "keyword2",
    "setaction": "keyword2",
    "setbackground": "keyword2",
    "setbounds": "keyword2",
    "setcolor": "keyword2",
    "setcookie": "keyword2",
    "setdepth": "keyword2",
    "setdimension": "keyword2",
    "setdown": "keyword2",
    "setfont": "keyword2",
    "setframes": "keyword2",
    "setheight": "keyword2",
    "sethit": "keyword2",
    "setindentation": "keyword2",
    "setleftfill": "keyword2",
    "setleftmargin": "keyword2",
    "setline": "keyword2",
    "setlinespacing": "keyword2",
    "setlocale": "keyword2",
    "setmargins": "keyword2",
    "setmatrix": "keyword2",
    "setname": "keyword2",
    "setover": "keyword2",
    "setrate": "keyword2",
    "setratio": "keyword2",
    "setrightfill": "keyword2",
    "setrightmargin": "keyword2",
    "setsockopt": "keyword2",
    "setspacing": "keyword2",
    "settype": "keyword2",
    "setup": "keyword2",
    "sha1": "keyword2",
    "sha1_file": "keyword2",
    "shell_exec": "keyword2",
    "shm_attach": "keyword2",
    "shm_detach": "keyword2",
    "shm_get_var": "keyword2",
    "shm_put_var": "keyword2",
    "shm_remove": "keyword2",
    "shm_remove_var": "keyword2",
    "shmop_close": "keyword2",
    "shmop_delete": "keyword2",
    "shmop_open": "keyword2",
    "shmop_read": "keyword2",
    "shmop_size": "keyword2",
    "shmop_write": "keyword2",
    "show_source": "keyword2",
    "shuffle": "keyword2",
    "shutdown": "keyword2",
    "signal": "keyword2",
    "similar_text": "keyword2",
    "sin": "keyword2",
    "sizeof": "keyword2",
    "skewx": "keyword2",
    "skewxto": "keyword2",
    "skewy": "keyword2",
    "skewyto": "keyword2",
    "sleep": "keyword2",
    "snmp_get_quick_print": "keyword2",
    "snmp_set_quick_print": "keyword2",
    "snmpget": "keyword2",
    "snmprealwalk": "keyword2",
    "snmpset": "keyword2",
    "snmpwalk": "keyword2",
    "snmpwalkoid": "keyword2",
    "socket": "keyword2",
    "socket_get_status": "keyword2",
    "socket_set_blocking": "keyword2",
    "socket_set_timeout": "keyword2",
    "socketpair": "keyword2",
    "sort": "keyword2",
    "soundex": "keyword2",
    "split": "keyword2",
    "spliti": "keyword2",
    "sprintf": "keyword2",
    "sql_regcase": "keyword2",
    "sqrt": "keyword2",
    "srand": "keyword2",
    "sscanf": "keyword2",
    "stat": "keyword2",
    "static": "keyword1",
    "str_pad": "keyword2",
    "str_repeat": "keyword2",
    "str_replace": "keyword2",
    "str_rot13": "keyword2",
    "str_split": "keyword2",
    "str_word_count": "keyword2",
    "strcasecmp": "keyword2",
    "strchr": "keyword2",
    "strcmp": "keyword2",
    "strcoll": "keyword2",
    "strcspn": "keyword2",
    "stream_context_create": "keyword2",
    "stream_context_set_option": "keyword2",
    "stream_context_set_params": "keyword2",
    "stream_filter_append": "keyword2",
    "stream_filter_prepend": "keyword2",
    "stream_get_status": "keyword2",
    "stream_select": "keyword2",
    "stream_set_blocking": "keyword2",
    "stream_set_timeout": "keyword2",
    "streammp3": "keyword2",
    "strerror": "keyword2",
    "strftime": "keyword2",
    "strip_tags": "keyword2",
    "stripcslashes": "keyword2",
    "stripos": "keyword2",
    "stripslashes": "keyword2",
    "stristr": "keyword2",
    "strlen": "keyword2",
    "strnatcasecmp": "keyword2",
    "strnatcmp": "keyword2",
    "strncasecmp": "keyword2",
    "strncmp": "keyword2",
    "strpbrk": "keyword2",
    "strpos": "keyword2",
    "strrchr": "keyword2",
    "strrev": "keyword2",
    "strrpos": "keyword2",
    "strspn": "keyword2",
    "strstr": "keyword2",
    "strtok": "keyword2",
    "strtolower": "keyword2",
    "strtotime": "keyword2",
    "strtoupper": "keyword2",
    "strtr": "keyword2",
    "strval": "keyword2",
    "substr": "keyword2",
    "substr_compare": "keyword2",
    "substr_count": "keyword2",
    "substr_replace": "keyword2",
    "swf_actiongeturl": "keyword2",
    "swf_actiongotoframe": "keyword2",
    "swf_actiongotolabel": "keyword2",
    "swf_actionnextframe": "keyword2",
    "swf_actionplay": "keyword2",
    "swf_actionprevframe": "keyword2",
    "swf_actionsettarget": "keyword2",
    "swf_actionstop": "keyword2",
    "swf_actiontogglequality": "keyword2",
    "swf_actionwaitforframe": "keyword2",
    "swf_addbuttonrecord": "keyword2",
    "swf_addcolor": "keyword2",
    "swf_closefile": "keyword2",
    "swf_definebitmap": "keyword2",
    "swf_definefont": "keyword2",
    "swf_defineline": "keyword2",
    "swf_definepoly": "keyword2",
    "swf_definerect": "keyword2",
    "swf_definetext": "keyword2",
    "swf_endbutton": "keyword2",
    "swf_enddoaction": "keyword2",
    "swf_endshape": "keyword2",
    "swf_endsymbol": "keyword2",
    "swf_fontsize": "keyword2",
    "swf_fontslant": "keyword2",
    "swf_fonttracking": "keyword2",
    "swf_getbitmapinfo": "keyword2",
    "swf_getfontinfo": "keyword2",
    "swf_getframe": "keyword2",
    "swf_labelframe": "keyword2",
    "swf_lookat": "keyword2",
    "swf_modifyobject": "keyword2",
    "swf_mulcolor": "keyword2",
    "swf_nextid": "keyword2",
    "swf_oncondition": "keyword2",
    "swf_openfile": "keyword2",
    "swf_ortho": "keyword2",
    "swf_ortho2": "keyword2",
    "swf_perspective": "keyword2",
    "swf_placeobject": "keyword2",
    "swf_polarview": "keyword2",
    "swf_popmatrix": "keyword2",
    "swf_posround": "keyword2",
    "swf_pushmatrix": "keyword2",
    "swf_removeobject": "keyword2",
    "swf_rotate": "keyword2",
    "swf_scale": "keyword2",
    "swf_setfont": "keyword2",
    "swf_setframe": "keyword2",
    "swf_shapearc": "keyword2",
    "swf_shapecurveto": "keyword2",
    "swf_shapecurveto3": "keyword2",
    "swf_shapefillbitmapclip": "keyword2",
    "swf_shapefillbitmaptile": "keyword2",
    "swf_shapefilloff": "keyword2",
    "swf_shapefillsolid": "keyword2",
    "swf_shapelinesolid": "keyword2",
    "swf_shapelineto": "keyword2",
    "swf_shapemoveto": "keyword2",
    "swf_showframe": "keyword2",
    "swf_startbutton": "keyword2",
    "swf_startdoaction": "keyword2",
    "swf_startshape": "keyword2",
    "swf_startsymbol": "keyword2",
    "swf_textwidth": "keyword2",
    "swf_translate": "keyword2",
    "swf_viewport": "keyword2",
    "swfaction": "keyword2",
    "swfbitmap": "keyword2",
    "swfbutton": "keyword2",
    "swfbutton_keypress": "keyword2",
    "swffill": "keyword2",
    "swffont": "keyword2",
    "swfgradient": "keyword2",
    "swfmorph": "keyword2",
    "swfmovie": "keyword2",
    "swfshape": "keyword2",
    "swfsprite": "keyword2",
    "swftext": "keyword2",
    "swftextfield": "keyword2",
    "switch": "keyword1",
    "sybase_affected_rows": "keyword2",
    "sybase_close": "keyword2",
    "sybase_connect": "keyword2",
    "sybase_data_seek": "keyword2",
    "sybase_fetch_array": "keyword2",
    "sybase_fetch_field": "keyword2",
    "sybase_fetch_object": "keyword2",
    "sybase_fetch_row": "keyword2",
    "sybase_field_seek": "keyword2",
    "sybase_free_result": "keyword2",
    "sybase_get_last_message": "keyword2",
    "sybase_min_client_severity": "keyword2",
    "sybase_min_error_severity": "keyword2",
    "sybase_min_message_severity": "keyword2",
    "sybase_min_server_severity": "keyword2",
    "sybase_num_fields": "keyword2",
    "sybase_num_rows": "keyword2",
    "sybase_pconnect": "keyword2",
    "sybase_query": "keyword2",
    "sybase_result": "keyword2",
    "sybase_select_db": "keyword2",
    "symlink": "keyword2",
    "syslog": "keyword2",
    "system": "keyword2",
    "tan": "keyword2",
    "tempnam": "keyword2",
    "textdomain": "keyword2",
    "throw": "keyword1",
    "time": "keyword2",
    "time_nanosleep": "keyword2",
    "tmpfile": "keyword2",
    "touch": "keyword2",
    "trigger_error": "keyword2",
    "trim": "keyword2",
    "true": "keyword3",
    "try": "keyword1",
    "uasort": "keyword2",
    "ucfirst": "keyword2",
    "ucwords": "keyword2",
    "udm_add_search_limit": "keyword2",
    "udm_alloc_agent": "keyword2",
    "udm_api_version": "keyword2",
    "udm_clear_search_limits": "keyword2",
    "udm_errno": "keyword2",
    "udm_error": "keyword2",
    "udm_find": "keyword2",
    "udm_free_agent": "keyword2",
    "udm_free_ispell_data": "keyword2",
    "udm_free_res": "keyword2",
    "udm_get_doc_count": "keyword2",
    "udm_get_res_field": "keyword2",
    "udm_get_res_param": "keyword2",
    "udm_load_ispell_data": "keyword2",
    "udm_set_agent_param": "keyword2",
    "uksort": "keyword2",
    "umask": "keyword2",
    "uniqid": "keyword2",
    "unixtojd": "keyword2",
    "unlink": "keyword2",
    "unpack": "keyword2",
    "unregister_tick_function": "keyword2",
    "unserialize": "keyword2",
    "unset": "keyword2",
    "urldecode": "keyword2",
    "urlencode": "keyword2",
    "user_error": "keyword2",
    "usleep": "keyword2",
    "usort": "keyword2",
    "utf8_decode": "keyword2",
    "utf8_encode": "keyword2",
    "var": "keyword1",
    "var_dump": "keyword2",
    "velocis_autocommit": "keyword2",
    "velocis_close": "keyword2",
    "velocis_commit": "keyword2",
    "velocis_connect": "keyword2",
    "velocis_exec": "keyword2",
    "velocis_fetch": "keyword2",
    "velocis_fieldname": "keyword2",
    "velocis_fieldnum": "keyword2",
    "velocis_freeresult": "keyword2",
    "velocis_off_autocommit": "keyword2",
    "velocis_result": "keyword2",
    "velocis_rollback": "keyword2",
    "virtual": "keyword2",
    "vpopmail_add_alias_domain": "keyword2",
    "vpopmail_add_alias_domain_ex": "keyword2",
    "vpopmail_add_domain": "keyword2",
    "vpopmail_add_domain_ex": "keyword2",
    "vpopmail_add_user": "keyword2",
    "vpopmail_auth_user": "keyword2",
    "vpopmail_del_domain": "keyword2",
    "vpopmail_del_domain_ex": "keyword2",
    "vpopmail_del_user": "keyword2",
    "vpopmail_error": "keyword2",
    "vpopmail_passwd": "keyword2",
    "vpopmail_set_user_quota": "keyword2",
    "wddx_add_vars": "keyword2",
    "wddx_deserialize": "keyword2",
    "wddx_packet_end": "keyword2",
    "wddx_packet_start": "keyword2",
    "wddx_serialize_value": "keyword2",
    "wddx_serialize_vars": "keyword2",
    "while": "keyword1",
    "wordwrap": "keyword2",
    "write": "keyword2",
    "writev": "keyword2",
    "xml_error_string": "keyword2",
    "xml_get_current_byte_index": "keyword2",
    "xml_get_current_column_number": "keyword2",
    "xml_get_current_line_number": "keyword2",
    "xml_get_error_code": "keyword2",
    "xml_parse": "keyword2",
    "xml_parse_into_struct": "keyword2",
    "xml_parser_create": "keyword2",
    "xml_parser_create_ns": "keyword2",
    "xml_parser_free": "keyword2",
    "xml_parser_get_option": "keyword2",
    "xml_parser_set_option": "keyword2",
    "xml_set_character_data_handler": "keyword2",
    "xml_set_default_handler": "keyword2",
    "xml_set_element_handler": "keyword2",
    "xml_set_end_namespace_decl_handler": "keyword2",
    "xml_set_external_entity_ref_handler": "keyword2",
    "xml_set_notation_decl_handler": "keyword2",
    "xml_set_object": "keyword2",
    "xml_set_processing_instruction_handler": "keyword2",
    "xml_set_start_namespace_decl_handler": "keyword2",
    "xml_set_unparsed_entity_decl_handler": "keyword2",
    "xmldoc": "keyword2",
    "xmldocfile": "keyword2",
    "xmltree": "keyword2",
    "xpath_eval": "keyword2",
    "xpath_eval_expression": "keyword2",
    "xptr_eval": "keyword2",
    "xslt_closelog": "keyword2",
    "xslt_create": "keyword2",
    "xslt_errno": "keyword2",
    "xslt_error": "keyword2",
    "xslt_fetch_result": "keyword2",
    "xslt_free": "keyword2",
    "xslt_openlog": "keyword2",
    "xslt_output_begintransform": "keyword2",
    "xslt_output_endtransform": "keyword2",
    "xslt_process": "keyword2",
    "xslt_run": "keyword2",
    "xslt_set_base": "keyword2",
    "xslt_set_encoding": "keyword2",
    "xslt_set_error_handler": "keyword2",
    "xslt_set_sax_handler": "keyword2",
    "xslt_set_scheme_handler": "keyword2",
    "xslt_transform": "keyword2",
    "yaz_addinfo": "keyword2",
    "yaz_ccl_conf": "keyword2",
    "yaz_ccl_parse": "keyword2",
    "yaz_close": "keyword2",
    "yaz_connect": "keyword2",
    "yaz_database": "keyword2",
    "yaz_element": "keyword2",
    "yaz_errno": "keyword2",
    "yaz_error": "keyword2",
    "yaz_hits": "keyword2",
    "yaz_itemorder": "keyword2",
    "yaz_present": "keyword2",
    "yaz_range": "keyword2",
    "yaz_record": "keyword2",
    "yaz_scan": "keyword2",
    "yaz_scan_result": "keyword2",
    "yaz_search": "keyword2",
    "yaz_syntax": "keyword2",
    "yaz_wait": "keyword2",
    "yp_all": "keyword2",
    "yp_cat": "keyword2",
    "yp_err_string": "keyword2",
    "yp_errno": "keyword2",
    "yp_first": "keyword2",
    "yp_get_default_domain": "keyword2",
    "yp_master": "keyword2",
    "yp_match": "keyword2",
    "yp_next": "keyword2",
    "yp_order": "keyword2",
    "zend_logo_guid": "keyword2",
    "zend_test_func": "keyword2",
    "zend_version": "keyword2",
    "zzip_close": "keyword2",
    "zzip_closedir": "keyword2",
    "zzip_entry_compressedsize": "keyword2",
    "zzip_entry_compressionmethod": "keyword2",
    "zzip_entry_filesize": "keyword2",
    "zzip_entry_name": "keyword2",
    "zzip_open": "keyword2",
    "zzip_opendir": "keyword2",
    "zzip_read": "keyword2",
    "zzip_readdir": "keyword2",
}

# Keywords dict for php_php_literal ruleset.
php_php_literal_keywords_dict = {}

# Keywords dict for php_javascript ruleset.
php_javascript_keywords_dict = {}

# Keywords dict for php_javascript_php ruleset.
php_javascript_php_keywords_dict = {}

# Keywords dict for php_phpdoc ruleset.
php_phpdoc_keywords_dict = {
    "@abstract": "label",
    "@access": "label",
    "@author": "label",
    "@category": "label",
    "@copyright": "label",
    "@deprecated": "label",
    "@example": "label",
    "@filesource": "label",
    "@final": "label",
    "@global": "label",
    "@id": "label",
    "@ignore": "label",
    "@inheritdoc": "label",
    "@internal": "label",
    "@license": "label",
    "@link": "label",
    "@name": "label",
    "@package": "label",
    "@param": "label",
    "@return": "label",
    "@see": "label",
    "@since": "label",
    "@source": "label",
    "@static": "label",
    "@staticvar": "label",
    "@subpackage": "label",
    "@toc": "label",
    "@todo": "label",
    "@tutorial": "label",
    "@uses": "label",
    "@var": "label",
    "@version": "label",
}

# Dictionary of keywords dictionaries for php mode.
keywordsDictDict = {
    "php_javascript": php_javascript_keywords_dict,
    "php_javascript_php": php_javascript_php_keywords_dict,
    "php_main": php_main_keywords_dict,
    "php_php": php_php_keywords_dict,
    "php_php_literal": php_php_literal_keywords_dict,
    "php_phpdoc": php_phpdoc_keywords_dict,
    "php_tags": php_tags_keywords_dict,
    "php_tags_literal": php_tags_literal_keywords_dict,
}

# Rules for php_main ruleset.

</t>
<t tx="ekr.20201022055738.10">def php_rule8(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.11">def php_rule9(colorer, s, i):
    return colorer.match_span(s, i, kind="literal2", begin="&amp;", end=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=True)

# Rules dict for php_main ruleset.
rulesDict1 = {
    "&amp;": [php_rule9,],
    "&lt;": [php_rule0,php_rule1,php_rule2,php_rule3,php_rule5,php_rule6,php_rule7,php_rule8,],
    "&lt; ": [php_rule4,],
}

# Rules for php_tags ruleset.

</t>
<t tx="ekr.20201022055738.12">def php_rule10(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.13">def php_rule11(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.14">def php_rule12(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.15">def php_rule13(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.16">def php_rule14(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::tags_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.17">def php_rule15(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

# Rules dict for php_tags ruleset.
rulesDict2 = {
    "\"": [php_rule13,],
    "'": [php_rule14,],
    "&lt;": [php_rule10,php_rule11,php_rule12,],
    "=": [php_rule15,],
}

# Rules for php_tags_literal ruleset.

</t>
<t tx="ekr.20201022055738.18">def php_rule16(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.19">def php_rule17(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.2">def php_rule0(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.20">def php_rule18(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

# Rules dict for php_tags_literal ruleset.
rulesDict3 = {
    "&lt;": [php_rule16,php_rule17,php_rule18,],
}

# Rules for php_php ruleset.

</t>
<t tx="ekr.20201022055738.21">def php_rule19(colorer, s, i):
    return colorer.match_span(s, i, kind="comment3", begin="/**", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::phpdoc",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.22">def php_rule20(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="/*", end="*/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.23">def php_rule21(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.24">def php_rule22(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.25">def php_rule23(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="`", end="`",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.26">def php_rule24(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment2", seq="//",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)

</t>
<t tx="ekr.20201022055738.27">def php_rule25(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="#",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="", exclude_match=False)

</t>
<t tx="ekr.20201022055738.28">def php_rule26(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="literal1", begin="&lt;&lt;&lt;[[:space:]'\"]*([[:alnum:]_]+)[[:space:]'\"]*", end="$1",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php_literal",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.29">def php_rule27(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

</t>
<t tx="ekr.20201022055738.3">def php_rule1(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.30">def php_rule28(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.31">def php_rule29(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.32">def php_rule30(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="!",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.33">def php_rule31(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.34">def php_rule32(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.35">def php_rule33(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.36">def php_rule34(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="+",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.37">def php_rule35(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="-",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.38">def php_rule36(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="/",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.39">def php_rule37(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.4">def php_rule2(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.40">def php_rule38(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.41">def php_rule39(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.42">def php_rule40(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="%",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.43">def php_rule41(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="&amp;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.44">def php_rule42(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="|",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.45">def php_rule43(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="^",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.46">def php_rule44(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="~",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.47">def php_rule45(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=".",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.48">def php_rule46(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="}",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.49">def php_rule47(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.5">def php_rule3(colorer, s, i):
    return colorer.match_span(s, i, kind="comment1", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.50">def php_rule48(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=",",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.51">def php_rule49(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=";",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.52">def php_rule50(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="]",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.53">def php_rule51(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="[",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.54">def php_rule52(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="?",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.55">def php_rule53(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq="@",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.56">def php_rule54(colorer, s, i):
    return colorer.match_seq(s, i, kind="operator", seq=":",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.57">def php_rule55(colorer, s, i):
    return colorer.match_mark_previous(s, i, kind="function", pattern="(",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

</t>
<t tx="ekr.20201022055738.58">def php_rule56(colorer, s, i):
    return colorer.match_keywords(s, i)

# Rules dict for php_php ruleset.
rulesDict4 = {
    "!": [php_rule30,],
    "\"": [php_rule21,],
    "#": [php_rule25,],
    "$": [php_rule27,],
    "%": [php_rule40,],
    "&amp;": [php_rule41,],
    "'": [php_rule22,],
    "(": [php_rule55,],
    "*": [php_rule37,],
    "+": [php_rule34,],
    ",": [php_rule48,],
    "-": [php_rule29,php_rule35,],
    ".": [php_rule45,],
    "/": [php_rule19,php_rule20,php_rule24,php_rule36,],
    "0": [php_rule56,],
    "1": [php_rule56,],
    "2": [php_rule56,],
    "3": [php_rule56,],
    "4": [php_rule56,],
    "5": [php_rule56,],
    "6": [php_rule56,],
    "7": [php_rule56,],
    "8": [php_rule56,],
    "9": [php_rule56,],
    ":": [php_rule54,],
    ";": [php_rule49,],
    "&lt;": [php_rule32,php_rule39,],
    "&lt; ": [php_rule26,],
    "=": [php_rule28,php_rule33,],
    "&gt;": [php_rule31,php_rule38,],
    "?": [php_rule52,],
    "@": [php_rule53,php_rule56,],
    "A": [php_rule56,],
    "B": [php_rule56,],
    "C": [php_rule56,],
    "D": [php_rule56,],
    "E": [php_rule56,],
    "F": [php_rule56,],
    "G": [php_rule56,],
    "H": [php_rule56,],
    "I": [php_rule56,],
    "J": [php_rule56,],
    "K": [php_rule56,],
    "L": [php_rule56,],
    "M": [php_rule56,],
    "N": [php_rule56,],
    "O": [php_rule56,],
    "P": [php_rule56,],
    "Q": [php_rule56,],
    "R": [php_rule56,],
    "S": [php_rule56,],
    "T": [php_rule56,],
    "U": [php_rule56,],
    "V": [php_rule56,],
    "W": [php_rule56,],
    "X": [php_rule56,],
    "Y": [php_rule56,],
    "Z": [php_rule56,],
    "[": [php_rule51,],
    "]": [php_rule50,],
    "^": [php_rule43,],
    "_": [php_rule56,],
    "`": [php_rule23,],
    "a": [php_rule56,],
    "b": [php_rule56,],
    "c": [php_rule56,],
    "d": [php_rule56,],
    "e": [php_rule56,],
    "f": [php_rule56,],
    "g": [php_rule56,],
    "h": [php_rule56,],
    "i": [php_rule56,],
    "j": [php_rule56,],
    "k": [php_rule56,],
    "l": [php_rule56,],
    "m": [php_rule56,],
    "n": [php_rule56,],
    "o": [php_rule56,],
    "p": [php_rule56,],
    "q": [php_rule56,],
    "r": [php_rule56,],
    "s": [php_rule56,],
    "t": [php_rule56,],
    "u": [php_rule56,],
    "v": [php_rule56,],
    "w": [php_rule56,],
    "x": [php_rule56,],
    "y": [php_rule56,],
    "z": [php_rule56,],
    "{": [php_rule47,],
    "|": [php_rule42,],
    "}": [php_rule46,],
    "~": [php_rule44,],
}

# Rules for php_php_literal ruleset.

</t>
<t tx="ekr.20201022055738.59">def php_rule57(colorer, s, i):
    return colorer.match_mark_following(s, i, kind="keyword3", pattern="$",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=False)

# Rules dict for php_php_literal ruleset.
rulesDict5 = {
    "$": [php_rule57,],
}

# Rules for php_javascript ruleset.

</t>
<t tx="ekr.20201022055738.6">def php_rule4(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind="markup", begin="&lt;SCRIPT\\s+LANGUAGE=\"?PHP\"?&gt;", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.60">def php_rule58(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::javascript+php")

</t>
<t tx="ekr.20201022055738.61">def php_rule59(colorer, s, i):
    return colorer.match_seq(s, i, kind="markup", seq="SRC=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="php::back_to_html")

# Rules dict for php_javascript ruleset.
rulesDict6 = {
    "&gt;": [php_rule58,],
    "S": [php_rule59,],
}

# Rules for php_javascript_php ruleset.

</t>
<t tx="ekr.20201022055738.62">def php_rule60(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?php", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.63">def php_rule61(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;?", end="?&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.64">def php_rule62(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;%=", end="%&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::php",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)


# Rules dict for php_javascript_php ruleset.
rulesDict7 = {
    "&lt;": [php_rule60,php_rule61,php_rule62,],
}

# Rules for php_phpdoc ruleset.

</t>
<t tx="ekr.20201022055738.65">def php_rule63(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="{",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.66">def php_rule64(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="*",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.67">def php_rule65(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="&lt;!--", end="--&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.68">def php_rule66(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;&lt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.69">def php_rule67(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt;=",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.7">def php_rule5(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;SCRIPT", end="&lt;/SCRIPT&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="php::javascript",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.70">def php_rule68(colorer, s, i):
    return colorer.match_seq(s, i, kind="comment3", seq="&lt; ",
        at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

</t>
<t tx="ekr.20201022055738.71">def php_rule69(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::tags",exclude_match=False,
        no_escape=False, no_line_break=True, no_word_break=False)

</t>
<t tx="ekr.20201022055738.72">def php_rule70(colorer, s, i):
    return colorer.match_keywords(s, i)

# Rules dict for php_phpdoc ruleset.
rulesDict8 = {
    "*": [php_rule64,],
    "0": [php_rule70,],
    "1": [php_rule70,],
    "2": [php_rule70,],
    "3": [php_rule70,],
    "4": [php_rule70,],
    "5": [php_rule70,],
    "6": [php_rule70,],
    "7": [php_rule70,],
    "8": [php_rule70,],
    "9": [php_rule70,],
    "&lt;": [php_rule65,php_rule66,php_rule67,php_rule68,php_rule69,],
    "@": [php_rule70,],
    "A": [php_rule70,],
    "B": [php_rule70,],
    "C": [php_rule70,],
    "D": [php_rule70,],
    "E": [php_rule70,],
    "F": [php_rule70,],
    "G": [php_rule70,],
    "H": [php_rule70,],
    "I": [php_rule70,],
    "J": [php_rule70,],
    "K": [php_rule70,],
    "L": [php_rule70,],
    "M": [php_rule70,],
    "N": [php_rule70,],
    "O": [php_rule70,],
    "P": [php_rule70,],
    "Q": [php_rule70,],
    "R": [php_rule70,],
    "S": [php_rule70,],
    "T": [php_rule70,],
    "U": [php_rule70,],
    "V": [php_rule70,],
    "W": [php_rule70,],
    "X": [php_rule70,],
    "Y": [php_rule70,],
    "Z": [php_rule70,],
    "_": [php_rule70,],
    "a": [php_rule70,],
    "b": [php_rule70,],
    "c": [php_rule70,],
    "d": [php_rule70,],
    "e": [php_rule70,],
    "f": [php_rule70,],
    "g": [php_rule70,],
    "h": [php_rule70,],
    "i": [php_rule70,],
    "j": [php_rule70,],
    "k": [php_rule70,],
    "l": [php_rule70,],
    "m": [php_rule70,],
    "n": [php_rule70,],
    "o": [php_rule70,],
    "p": [php_rule70,],
    "q": [php_rule70,],
    "r": [php_rule70,],
    "s": [php_rule70,],
    "t": [php_rule70,],
    "u": [php_rule70,],
    "v": [php_rule70,],
    "w": [php_rule70,],
    "x": [php_rule70,],
    "y": [php_rule70,],
    "z": [php_rule70,],
    "{": [php_rule63,],
}

# x.rulesDictDict for php mode.
rulesDictDict = {
    "php_javascript": rulesDict6,
    "php_javascript_php": rulesDict7,
    "php_main": rulesDict1,
    "php_php": rulesDict4,
    "php_php_literal": rulesDict5,
    "php_phpdoc": rulesDict8,
    "php_tags": rulesDict2,
    "php_tags_literal": rulesDict3,
}

# Import dict for php mode.
importDict = {
    "php_javascript_php": ["javascript::main",],
}

# EKR
</t>
<t tx="ekr.20201022055738.8">def php_rule6(colorer, s, i):
    return colorer.match_span(s, i, kind="markup", begin="&lt;STYLE", end="&lt;/STYLE&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="html::css",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201022055738.9">def php_rule7(colorer, s, i):
    return colorer.match_span(s, i, kind="keyword2", begin="&lt;!", end="&gt;",
        at_line_start=False, at_whitespace_end=False, at_word_start=False,
        delegate="xml::dtd-tags",exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

</t>
<t tx="ekr.20201030052707.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1720

@language python
</t>
<t tx="ekr.20201030053803.1"></t>
<t tx="ekr.20201030065903.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1721

@language python
@nosearch</t>
<t tx="ekr.20201030084949.1"></t>
<t tx="ekr.20201030085148.1">@nosearch

# flattened, word, ignore-case, head, body

 search: c\.setBodyString\((\w+)\s*,\s*(\w+)\)
replace: \1.b = \2

# found 17 nodes</t>
<t tx="ekr.20201030085515.1"></t>
<t tx="ekr.20201031083701.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1413

@language python
@nosearch
</t>
<t tx="ekr.20201107145642.1">def afterChangeHeadline(self, p, command, bunch):
    """Create an undo node using d created by beforeChangeHeadline."""
    u = self
    if u.redoing or u.undoing:
        return
    # Set the type &amp; helpers.
    bunch.kind = 'headline'
    bunch.undoType = command
    bunch.undoHelper = u.undoChangeHeadline
    bunch.redoHelper = u.redoChangeHeadline
    bunch.newHead = p.h
    u.pushBead(bunch)

afterChangeHead = afterChangeHeadline
</t>
<t tx="ekr.20201107145859.1">def beforeChangeHeadline(self, p):
    """
    Return data that gets passed to afterChangeNode.
    
    The oldHead kwarg works around a Qt difficulty when changing headlines.
    """
    u = self
    bunch = u.createCommonBunch(p)
    bunch.oldHead = p.h
    return bunch

beforeChangeHead = beforeChangeHeadline
</t>
<t tx="ekr.20201107150041.1">def undoChangeHeadline(self):
    """Undo a change to a node's headline."""
    c, u = self.c, self
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    c.frame.body.recolor(u.p)
    u.p.initHeadString(u.oldHead)
    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.oldHead)
</t>
<t tx="ekr.20201107150619.1">def redoChangeHeadline(self):
    c, u = self.c, self
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    c.frame.body.recolor(u.p)
    # Restore the headline.
    u.p.initHeadString(u.newHead)
    # This is required so.  Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.newHead)
</t>
<t tx="ekr.20201108061811.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1726

@language python
</t>
<t tx="ekr.20201108064325.1"></t>
<t tx="ekr.20201108064358.1">@language rest
@wrap

Use leo-c to test cursesGui2.
Use f to test flexx.

How the headline was reverted:
- Ctrl-I: New headline
- type abc
- *click* (not return) another node: the headline appears to stick.
- Double click abc node: the headline reverts to newHeadline
- Does *not* happen after Ctrl-h.

@language python
</t>
<t tx="ekr.20201108144604.1"># QAbstractItemModel::headerDataChanged(Qt::Orientation orientation, int first, int last)</t>
<t tx="ekr.20201109043641.1">def editingFinished_callback():
    """Called when Qt emits the editingFinished signal."""
    s = e.text()
    i = s.find('\n')
    # Truncate to one line.
    if i &gt; -1:
        s = s[:i]
    # #1310: update the tooltip.
    if p.h != s:
        # Update p.h and handle undo.
        item.setToolTip(0, s)
        undoData = u.beforeChangeHeadline(p)
        p.v.setHeadString(s)  # Set v.h *after* calling the undoer's before method.
        if not c.changed:
            c.setChanged()
        # We must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p)
        p.setDirty()
        u.afterChangeHeadline(p, 'Edit Headline', undoData)
    self.redraw_after_head_changed()
    c.outerUpdate()
</t>
<t tx="ekr.20201109074740.1">def beforeChangeBody(self, p):
    """Return data that gets passed to afterChangeBody."""
    w = self.c.frame.body.wrapper
    bunch = self.createCommonBunch(p)
        # Sets u.oldMarked, u.oldSel, u.p
    bunch.oldBody = p.b
    bunch.oldHead = p.h
    bunch.oldIns = w.getInsertPoint()
    bunch.oldYScroll = w.getYScrollPosition()
    return bunch
</t>
<t tx="ekr.20201109075104.1">def afterChangeBody(self, p, command, bunch):
    """
    Create an undo node using d created by beforeChangeNode.
    
    *Important*: Before calling this method, caller must:
    - Set p.v.b. (Setting p.b would cause a redraw).
    - Set the desired selection range and insert point.
    - Set the y-scroll position, if desired.
    """
    c = self.c
    u, w = self, c.frame.body.wrapper
    if u.redoing or u.undoing:
        return
    # Set the type &amp; helpers.
    bunch.kind = 'body'
    bunch.undoType = command
    bunch.undoHelper = u.undoChangeBody
    bunch.redoHelper = u.redoChangeBody
    bunch.newBody = p.b
    bunch.newHead = p.h
    bunch.newIns = w.getInsertPoint()
    bunch.newMarked = p.isMarked()
    # Careful: don't use ternary operator.
    if w:
        bunch.newSel = w.getSelectionRange()
    else:
        bunch.newSel = 0, 0
    bunch.newYScroll = w.getYScrollPosition() if w else 0
    u.pushBead(bunch)
    # 
    if g.unitTesting:
        assert command.lower() != 'typing', g.callers()
    elif command.lower() == 'typing':
        g.trace(
            'Error: undoType should not be "Typing"\n'
            'Call u.doTyping instead')
    u.updateAfterTyping(p, w)
</t>
<t tx="ekr.20201109080631.1">def undoChangeBody(self):
    """
    Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    """
    c, u, w = self.c, self, self.c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:
        c.selectPosition(u.p)
    u.p.setDirty()
    u.p.b = u.oldBody
    u.p.h = u.oldHead
    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.oldHead)
    if u.oldMarked:
        u.p.setMarked()
    else:
        u.p.clearMarked()
    if u.groupCount == 0:
        w.setAllText(u.oldBody)
        i, j = u.oldSel
        w.setSelectionRange(i, j, insert=u.oldIns)
        w.setYScrollPosition(u.oldYScroll)
        c.frame.body.recolor(u.p)
    u.updateMarks('old')
</t>
<t tx="ekr.20201109080732.1">def redoChangeBody(self):
    c, u, w = self.c, self, self.c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    u.p.b = u.newBody
    u.p.h = u.newHead
    # This is required so. Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.newHead)
    if u.newMarked:
        u.p.setMarked()
    else:
        u.p.clearMarked()
    if u.groupCount == 0:
        w.setAllText(u.newBody)
        i, j = u.newSel
        w.setSelectionRange(i, j, insert=u.newIns)
        w.setYScrollPosition(u.newYScroll)
        c.frame.body.recolor(u.p)
    u.updateMarks('new')
    u.p.setDirty()
</t>
<t tx="ekr.20201109082007.1"></t>
<t tx="ekr.20201109104158.1">@nosearch

# flattened, word, ignore-case, head, body

# found 21 nodes</t>
<t tx="ekr.20201109104329.1"> search: c\.setBodyString\((\w+)\s*,\s*(\w+)\)
replace: \1.b = \2
</t>
<t tx="ekr.20201109104353.1"> search: c\.setHeadString\((\w+)\s*,\s*(\w+)\)
replace: \1.h = \2
</t>
<t tx="ekr.20201109104837.1"></t>
<t tx="ekr.20201109105836.1"></t>
<t tx="ekr.20201109110403.1"></t>
<t tx="ekr.20201110015336.1">g.cls()
import os
import re
path = os.path.join(g.app.loadDir, '..', 'modes', 'php.py')
with open(path, 'r') as f:
    contents = f.read()
def_pat = r'^def\s*(php_rule[0-9]+)'
for line in g.splitLines(contents):
    m = re.match(def_pat, line)
    if m:
        print(m.group(1))</t>
<t tx="ekr.20201110092953.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1591

In ekr-1591 branch.

@language python
@nosearch
</t>
<t tx="ekr.20201110094832.1"></t>
<t tx="ekr.20201111052557.1">def patch_1591(self):
    """
    A workaround for #1591.
    
    Add labels and tooltips for all buttons.
    """
    # Patch the buttons only if the pyqt version is greater than 5.12.
    from leo.core.leoQt import isQt5, qt_version
    if not isQt5:
        return
    qt_version = [int(z) for z in qt_version.split('.')]
    if qt_version[1] &lt;= 12:
        return
    ui = self.ui.UI
    # Add text and tooltips to all numeric priority buttons.
    for i in range(10):
        button = getattr(ui, f"butPri{i}")
        button.setText(f"{i}")
        button.setToolTip(f"Priority {i}")
    # Add text and tooltips to other buttons...
    table = (
        # Alternate priorities...
        ('butPriChk', 'Check', 'Check Mark'),
        ('butPriToDo', 'Box', 'Box Mark'),
        ('butPriX', 'X', 'Black X'),
        ('butPriXgry', 'X', 'Gray X'),
        ('butPriBang', '!', 'Exclamation Point'),
        ('butPriQuery', '?', 'Question Mark'),
        ('butPriBullet', '', 'Bullet'),
        ('butPriClr', 'Clear', 'Clear Priority'),
        # Other labels...
        ('butDetails', 'Details', 'Toggle Details'),
        ('butNext', 'Next Node', 'Next Node'),
        ('butNextTodo', 'Next Todo', 'Next To Do'),
        ('butClrTime', 'Clear Time', 'Clear Required Time'),
        ('butClrProg', 'Clear Progress', 'Clear Progress')
    )
    for attr, text, tooltip in table:
        button = getattr(ui, attr)
        button.setText(text)
        button.setToolTip(tooltip)
        
        
</t>
<t tx="ekr.20201111182127.1">indent-region       !text = Tab
newline-and-indent  = Ctrl-j
focus-to-body       !tree = Tab
unindent-region     = ctrl-less # Ctrl-Shift-&lt;
unindent-region     = Shift-tab</t>
<t tx="ekr.20201112060726.1">@language rest
@wrap

Issue: https://github.com/leo-editor/leo-editor/issues/1731
PR: https://github.com/leo-editor/leo-editor/pull/1732

in ekr-tabs branch.

@language python
@nosearch
</t>
<t tx="ekr.20201112095019.1"></t>
<t tx="ekr.20201113190926.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1734

@language python
@nosearch
</t>
<t tx="ekr.20201114110737.1">def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    """
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    
    Return the value returned by the command, or None if no command is executed.
    """
    c, k = self.c, self
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke  # Set this global for general use.
    ch = event.char if event else ''
    #
    # Ignore all special keys.
    if k.isSpecialKey(event):
        return None
    #
    # Compute func if not given.
    # It is *not* an error for func to be None.
    if commandName and not func:
        func = c.commandsDict.get(commandName.replace('&amp;', ''))
        if not func:
            g.es_print(f"no command for @item {commandName!r}", color='red')
            return None
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    if 'keys' in g.app.debug:
        # A very important trace.
        g.trace(commandName, 'stroke', stroke)
    #
    # Remember the key.
    k.setLossage(ch, stroke)
    #
    # Handle keyboard-quit.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        k.keyboardQuit()
        return None
    #
    # Ignore abbreviations.
    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, stroke):
        return None
    #
    # Invoke the command, if given.
    if func:
        return_value = c.doCommand(func, commandName, event=event)
        if c.exists:
            c.frame.updateStatusLine()
        return return_value
    #
    # Ignore unbound keys in a state.
    if k.inState():
        return None
    #
    # Finally, call k.handleDefaultChar.
    k.handleDefaultChar(event, stroke)
    if c.exists:
        c.frame.updateStatusLine()
    return None
</t>
<t tx="ekr.20201114160816.1" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032302d31312d31307103752e">@language rest
@wrap
@nosearch

**Move More. More balance. **

- Finish documentation for vim changes.
  https://github.com/leo-editor/leo-editor/issues/1757

- vs-code plugin using transcrypt.

- Buy harp for lamp.
- Christmas Present: new range, dishwasher.
- Bird Feeder

</t>
<t tx="ekr.20201114160816.10">+-- node-inspect@2.0.0</t>
<t tx="ekr.20201114160816.11">+-- npm@6.14.8
| +-- abbrev@1.1.1
| +-- ansicolors@0.3.2
| +-- ansistyles@0.1.3
| +-- aproba@2.0.0
| +-- archy@1.0.0
| +-- bin-links@1.1.8
| | +-- bluebird@3.5.5 deduped
| | +-- cmd-shim@3.0.3 deduped
| | +-- gentle-fs@2.3.1 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- npm-normalize-package-bin@1.0.1
| | `-- write-file-atomic@2.4.3 deduped
| +-- bluebird@3.5.5
| +-- byte-size@5.0.1
| +-- cacache@12.0.3
| | +-- bluebird@3.5.5 deduped
| | +-- chownr@1.1.4 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- glob@7.1.6 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- infer-owner@1.0.4 deduped
| | +-- lru-cache@5.1.1 deduped
| | +-- mississippi@3.0.0 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- move-concurrently@1.0.1 deduped
| | +-- promise-inflight@1.0.1 deduped
| | +-- rimraf@2.7.1 deduped
| | +-- ssri@6.0.1 deduped
| | +-- unique-filename@1.1.1 deduped
| | `-- y18n@4.0.0
| +-- call-limit@1.1.1
| +-- chownr@1.1.4
| +-- ci-info@2.0.0
| +-- cli-columns@3.1.2
| | +-- string-width@2.1.1
| | | +-- is-fullwidth-code-point@2.0.0
| | | `-- strip-ansi@4.0.0
| | |   `-- ansi-regex@3.0.0
| | `-- strip-ansi@3.0.1
| |   `-- ansi-regex@2.1.1
| +-- cli-table3@0.5.1
| | +-- colors@1.3.3
| | +-- object-assign@4.1.1
| | `-- string-width@2.1.1 deduped
| +-- cmd-shim@3.0.3
| | +-- graceful-fs@4.2.4 deduped
| | `-- mkdirp@0.5.5 deduped
| +-- columnify@1.5.4
| | +-- strip-ansi@3.0.1 deduped
| | `-- wcwidth@1.0.1
| |   `-- defaults@1.0.3
| |     `-- clone@1.0.4
| +-- config-chain@1.1.12
| | +-- ini@1.3.5 deduped
| | `-- proto-list@1.2.4
| +-- debuglog@1.0.1
| +-- detect-indent@5.0.0
| +-- detect-newline@2.1.0
| +-- dezalgo@1.0.3
| | +-- asap@2.0.6
| | `-- wrappy@1.0.2
| +-- editor@1.0.0
| +-- figgy-pudding@3.5.1
| +-- find-npm-prefix@1.0.2
| +-- fs-vacuum@1.2.10
| | +-- graceful-fs@4.2.4 deduped
| | +-- path-is-inside@1.0.2 deduped
| | `-- rimraf@2.7.1 deduped
| +-- fs-write-stream-atomic@1.0.10
| | +-- graceful-fs@4.2.4 deduped
| | +-- iferr@0.1.5
| | +-- imurmurhash@0.1.4 deduped
| | `-- readable-stream@2.3.6
| |   +-- core-util-is@1.0.2
| |   +-- inherits@2.0.4 deduped
| |   +-- isarray@1.0.0
| |   +-- process-nextick-args@2.0.0
| |   +-- safe-buffer@5.1.2 deduped
| |   +-- string_decoder@1.1.1
| |   | `-- safe-buffer@5.1.2 deduped
| |   `-- util-deprecate@1.0.2 deduped
| +-- gentle-fs@2.3.1
| | +-- aproba@1.2.0
| | +-- chownr@1.1.4 deduped
| | +-- cmd-shim@3.0.3 deduped
| | +-- fs-vacuum@1.2.10 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- iferr@0.1.5
| | +-- infer-owner@1.0.4 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- path-is-inside@1.0.2 deduped
| | +-- read-cmd-shim@1.0.5 deduped
| | `-- slide@1.1.6 deduped
| +-- glob@7.1.6
| | +-- fs.realpath@1.0.0
| | +-- inflight@1.0.6 deduped
| | +-- inherits@2.0.4 deduped
| | +-- minimatch@3.0.4
| | | `-- brace-expansion@1.1.11
| | |   +-- balanced-match@1.0.0
| | |   `-- concat-map@0.0.1
| | +-- once@1.4.0 deduped
| | `-- path-is-absolute@1.0.1
| +-- graceful-fs@4.2.4
| +-- has-unicode@2.0.1
| +-- hosted-git-info@2.8.8
| +-- iferr@1.0.2
| +-- imurmurhash@0.1.4
| +-- infer-owner@1.0.4
| +-- inflight@1.0.6
| | +-- once@1.4.0 deduped
| | `-- wrappy@1.0.2 deduped
| +-- inherits@2.0.4
| +-- ini@1.3.5
| +-- init-package-json@1.10.3
| | +-- glob@7.1.6 deduped
| | +-- npm-package-arg@6.1.1 deduped
| | +-- promzard@0.3.0
| | | `-- read@1.0.7 deduped
| | +-- read@1.0.7 deduped
| | +-- read-package-json@2.1.1 deduped
| | +-- semver@5.7.1 deduped
| | +-- validate-npm-package-license@3.0.4 deduped
| | `-- validate-npm-package-name@3.0.0 deduped
| +-- is-cidr@3.0.0
| | `-- cidr-regex@2.0.10
| |   `-- ip-regex@2.1.0
| +-- json-parse-better-errors@1.0.2
| +-- JSONStream@1.3.5
| | +-- jsonparse@1.3.1
| | `-- through@2.3.8
| +-- lazy-property@1.0.0
| +-- libcipm@4.0.8
| | +-- bin-links@1.1.8 deduped
| | +-- bluebird@3.5.5 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- find-npm-prefix@1.0.2 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- ini@1.3.5 deduped
| | +-- lock-verify@2.1.0 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- npm-lifecycle@3.1.5 deduped
| | +-- npm-logical-tree@1.2.1
| | +-- npm-package-arg@6.1.1 deduped
| | +-- pacote@9.5.12 deduped
| | +-- read-package-json@2.1.1 deduped
| | +-- rimraf@2.7.1 deduped
| | `-- worker-farm@1.7.0 deduped
| +-- libnpm@3.0.1
| | +-- bin-links@1.1.8 deduped
| | +-- bluebird@3.5.5 deduped
| | +-- find-npm-prefix@1.0.2 deduped
| | +-- libnpmaccess@3.0.2 deduped
| | +-- libnpmconfig@1.2.1
| | | +-- figgy-pudding@3.5.1 deduped
| | | +-- find-up@3.0.0
| | | | `-- locate-path@3.0.0
| | | |   +-- p-locate@3.0.0
| | | |   | `-- p-limit@2.2.0
| | | |   |   `-- p-try@2.2.0
| | | |   `-- path-exists@3.0.0
| | | `-- ini@1.3.5 deduped
| | +-- libnpmhook@5.0.3 deduped
| | +-- libnpmorg@1.0.1 deduped
| | +-- libnpmpublish@1.1.2
| | | +-- aproba@2.0.0 deduped
| | | +-- figgy-pudding@3.5.1 deduped
| | | +-- get-stream@4.1.0 deduped
| | | +-- lodash.clonedeep@4.5.0 deduped
| | | +-- normalize-package-data@2.5.0 deduped
| | | +-- npm-package-arg@6.1.1 deduped
| | | +-- npm-registry-fetch@4.0.7 deduped
| | | +-- semver@5.7.1 deduped
| | | `-- ssri@6.0.1 deduped
| | +-- libnpmsearch@2.0.2 deduped
| | +-- libnpmteam@1.0.2 deduped
| | +-- lock-verify@2.1.0 deduped
| | +-- npm-lifecycle@3.1.5 deduped
| | +-- npm-logical-tree@1.2.1 deduped
| | +-- npm-package-arg@6.1.1 deduped
| | +-- npm-profile@4.0.4 deduped
| | +-- npm-registry-fetch@4.0.7 deduped
| | +-- npmlog@4.1.2 deduped
| | +-- pacote@9.5.12 deduped
| | +-- read-package-json@2.1.1 deduped
| | `-- stringify-package@1.0.1 deduped
| +-- libnpmaccess@3.0.2
| | +-- aproba@2.0.0 deduped
| | +-- get-stream@4.1.0
| | | `-- pump@3.0.0 deduped
| | +-- npm-package-arg@6.1.1 deduped
| | `-- npm-registry-fetch@4.0.7 deduped
| +-- libnpmhook@5.0.3
| | +-- aproba@2.0.0 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- get-stream@4.1.0 deduped
| | `-- npm-registry-fetch@4.0.7 deduped
| +-- libnpmorg@1.0.1
| | +-- aproba@2.0.0 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- get-stream@4.1.0 deduped
| | `-- npm-registry-fetch@4.0.7 deduped
| +-- libnpmsearch@2.0.2
| | +-- figgy-pudding@3.5.1 deduped
| | +-- get-stream@4.1.0 deduped
| | `-- npm-registry-fetch@4.0.7 deduped
| +-- libnpmteam@1.0.2
| | +-- aproba@2.0.0 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- get-stream@4.1.0 deduped
| | `-- npm-registry-fetch@4.0.7 deduped
| +-- libnpx@10.2.4
| | +-- dotenv@5.0.1
| | +-- npm-package-arg@6.1.1 deduped
| | +-- rimraf@2.7.1 deduped
| | +-- safe-buffer@5.1.2 deduped
| | +-- update-notifier@2.5.0 deduped
| | +-- which@1.3.1 deduped
| | +-- y18n@4.0.0 deduped
| | `-- yargs@14.2.3
| |   +-- cliui@5.0.0
| |   | +-- string-width@3.1.0
| |   | | +-- emoji-regex@7.0.3 deduped
| |   | | +-- is-fullwidth-code-point@2.0.0
| |   | | `-- strip-ansi@5.2.0 deduped
| |   | +-- strip-ansi@5.2.0
| |   | | `-- ansi-regex@4.1.0
| |   | `-- wrap-ansi@5.1.0
| |   |   +-- ansi-styles@3.2.1 deduped
| |   |   +-- string-width@3.1.0
| |   |   | +-- emoji-regex@7.0.3 deduped
| |   |   | +-- is-fullwidth-code-point@2.0.0
| |   |   | `-- strip-ansi@5.2.0 deduped
| |   |   `-- strip-ansi@5.2.0
| |   |     `-- ansi-regex@4.1.0
| |   +-- decamelize@1.2.0
| |   +-- find-up@3.0.0
| |   | `-- locate-path@3.0.0
| |   |   +-- p-locate@3.0.0
| |   |   | `-- p-limit@2.3.0
| |   |   |   `-- p-try@2.2.0
| |   |   `-- path-exists@3.0.0 deduped
| |   +-- get-caller-file@2.0.5
| |   +-- require-directory@2.1.1
| |   +-- require-main-filename@2.0.0
| |   +-- set-blocking@2.0.0 deduped
| |   +-- string-width@3.1.0
| |   | +-- emoji-regex@7.0.3
| |   | +-- is-fullwidth-code-point@2.0.0
| |   | `-- strip-ansi@5.2.0
| |   |   `-- ansi-regex@4.1.0
| |   +-- which-module@2.0.0
| |   +-- y18n@4.0.0 deduped
| |   `-- yargs-parser@15.0.1
| |     +-- camelcase@5.3.1
| |     `-- decamelize@1.2.0 deduped
| +-- lock-verify@2.1.0
| | +-- npm-package-arg@6.1.1 deduped
| | `-- semver@5.7.1 deduped
| +-- lockfile@1.0.4
| | `-- signal-exit@3.0.2
| +-- lodash._baseindexof@3.1.0
| +-- lodash._baseuniq@4.6.0
| | +-- lodash._createset@4.0.3
| | `-- lodash._root@3.0.1
| +-- lodash._bindcallback@3.0.1
| +-- lodash._cacheindexof@3.0.2
| +-- lodash._createcache@3.1.2
| | `-- lodash._getnative@3.9.1 deduped
| +-- lodash._getnative@3.9.1
| +-- lodash.clonedeep@4.5.0
| +-- lodash.restparam@3.6.1
| +-- lodash.union@4.6.0
| +-- lodash.uniq@4.5.0
| +-- lodash.without@4.4.0
| +-- lru-cache@5.1.1
| | `-- yallist@3.0.3
| +-- meant@1.0.2
| +-- mississippi@3.0.0
| | +-- concat-stream@1.6.2
| | | +-- buffer-from@1.0.0
| | | +-- inherits@2.0.4 deduped
| | | +-- readable-stream@2.3.6
| | | | +-- core-util-is@1.0.2 deduped
| | | | +-- inherits@2.0.4 deduped
| | | | +-- isarray@1.0.0 deduped
| | | | +-- process-nextick-args@2.0.0 deduped
| | | | +-- safe-buffer@5.1.2 deduped
| | | | +-- string_decoder@1.1.1
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | `-- util-deprecate@1.0.2 deduped
| | | `-- typedarray@0.0.6
| | +-- duplexify@3.6.0
| | | +-- end-of-stream@1.4.1 deduped
| | | +-- inherits@2.0.4 deduped
| | | +-- readable-stream@2.3.6
| | | | +-- core-util-is@1.0.2 deduped
| | | | +-- inherits@2.0.4 deduped
| | | | +-- isarray@1.0.0 deduped
| | | | +-- process-nextick-args@2.0.0 deduped
| | | | +-- safe-buffer@5.1.2 deduped
| | | | +-- string_decoder@1.1.1
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | `-- util-deprecate@1.0.2 deduped
| | | `-- stream-shift@1.0.0
| | +-- end-of-stream@1.4.1
| | | `-- once@1.4.0 deduped
| | +-- flush-write-stream@1.0.3
| | | +-- inherits@2.0.4 deduped
| | | `-- readable-stream@2.3.6
| | |   +-- core-util-is@1.0.2 deduped
| | |   +-- inherits@2.0.4 deduped
| | |   +-- isarray@1.0.0 deduped
| | |   +-- process-nextick-args@2.0.0 deduped
| | |   +-- safe-buffer@5.1.2 deduped
| | |   +-- string_decoder@1.1.1
| | |   | `-- safe-buffer@5.1.2 deduped
| | |   `-- util-deprecate@1.0.2 deduped
| | +-- from2@2.3.0
| | | +-- inherits@2.0.4 deduped
| | | `-- readable-stream@2.3.6
| | |   +-- core-util-is@1.0.2 deduped
| | |   +-- inherits@2.0.4 deduped
| | |   +-- isarray@1.0.0 deduped
| | |   +-- process-nextick-args@2.0.0 deduped
| | |   +-- safe-buffer@5.1.2 deduped
| | |   +-- string_decoder@1.1.1
| | |   | `-- safe-buffer@5.1.2 deduped
| | |   `-- util-deprecate@1.0.2 deduped
| | +-- parallel-transform@1.1.0
| | | +-- cyclist@0.2.2
| | | +-- inherits@2.0.4 deduped
| | | `-- readable-stream@2.3.6
| | |   +-- core-util-is@1.0.2 deduped
| | |   +-- inherits@2.0.4 deduped
| | |   +-- isarray@1.0.0 deduped
| | |   +-- process-nextick-args@2.0.0 deduped
| | |   +-- safe-buffer@5.1.2 deduped
| | |   +-- string_decoder@1.1.1
| | |   | `-- safe-buffer@5.1.2 deduped
| | |   `-- util-deprecate@1.0.2 deduped
| | +-- pump@3.0.0
| | | +-- end-of-stream@1.4.1 deduped
| | | `-- once@1.4.0 deduped
| | +-- pumpify@1.5.1
| | | +-- duplexify@3.6.0 deduped
| | | +-- inherits@2.0.4 deduped
| | | `-- pump@2.0.1
| | |   +-- end-of-stream@1.4.1 deduped
| | |   `-- once@1.4.0 deduped
| | +-- stream-each@1.2.2
| | | +-- end-of-stream@1.4.1 deduped
| | | `-- stream-shift@1.0.0 deduped
| | `-- through2@2.0.3
| |   +-- readable-stream@2.3.6
| |   | +-- core-util-is@1.0.2 deduped
| |   | +-- inherits@2.0.4 deduped
| |   | +-- isarray@1.0.0 deduped
| |   | +-- process-nextick-args@2.0.0 deduped
| |   | +-- safe-buffer@5.1.2 deduped
| |   | +-- string_decoder@1.1.1
| |   | | `-- safe-buffer@5.1.2 deduped
| |   | `-- util-deprecate@1.0.2 deduped
| |   `-- xtend@4.0.1
| +-- mkdirp@0.5.5
| | `-- minimist@1.2.5
| +-- move-concurrently@1.0.1
| | +-- aproba@1.2.0
| | +-- copy-concurrently@1.0.5
| | | +-- aproba@1.2.0
| | | +-- fs-write-stream-atomic@1.0.10 deduped
| | | +-- iferr@0.1.5
| | | +-- mkdirp@0.5.5 deduped
| | | +-- rimraf@2.7.1 deduped
| | | `-- run-queue@1.0.3 deduped
| | +-- fs-write-stream-atomic@1.0.10 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- rimraf@2.7.1 deduped
| | `-- run-queue@1.0.3
| |   `-- aproba@1.2.0
| +-- node-gyp@5.1.0
| | +-- env-paths@2.2.0
| | +-- glob@7.1.6 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- nopt@4.0.3 deduped
| | +-- npmlog@4.1.2 deduped
| | +-- request@2.88.0 deduped
| | +-- rimraf@2.7.1 deduped
| | +-- semver@5.7.1 deduped
| | +-- tar@4.4.13 deduped
| | `-- which@1.3.1 deduped
| +-- nopt@4.0.3
| | +-- abbrev@1.1.1 deduped
| | `-- osenv@0.1.5 deduped
| +-- normalize-package-data@2.5.0
| | +-- hosted-git-info@2.8.8 deduped
| | +-- resolve@1.10.0
| | | `-- path-parse@1.0.6
| | +-- semver@5.7.1 deduped
| | `-- validate-npm-package-license@3.0.4 deduped
| +-- npm-audit-report@1.3.3
| | +-- cli-table3@0.5.1 deduped
| | `-- console-control-strings@1.1.0
| +-- npm-cache-filename@1.0.2
| +-- npm-install-checks@3.0.2
| | `-- semver@5.7.1 deduped
| +-- npm-lifecycle@3.1.5
| | +-- byline@5.0.0
| | +-- graceful-fs@4.2.4 deduped
| | +-- node-gyp@5.1.0 deduped
| | +-- resolve-from@4.0.0
| | +-- slide@1.1.6 deduped
| | +-- uid-number@0.0.6 deduped
| | +-- umask@1.1.0 deduped
| | `-- which@1.3.1 deduped
| +-- npm-package-arg@6.1.1
| | +-- hosted-git-info@2.8.8 deduped
| | +-- osenv@0.1.5 deduped
| | +-- semver@5.7.1 deduped
| | `-- validate-npm-package-name@3.0.0 deduped
| +-- npm-packlist@1.4.8
| | +-- ignore-walk@3.0.3
| | | `-- minimatch@3.0.4 deduped
| | +-- npm-bundled@1.1.1
| | | `-- npm-normalize-package-bin@1.0.1 deduped
| | `-- npm-normalize-package-bin@1.0.1 deduped
| +-- npm-pick-manifest@3.0.2
| | +-- figgy-pudding@3.5.1 deduped
| | +-- npm-package-arg@6.1.1 deduped
| | `-- semver@5.7.1 deduped
| +-- npm-profile@4.0.4
| | +-- aproba@2.0.0 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | `-- npm-registry-fetch@4.0.7 deduped
| +-- npm-registry-fetch@4.0.7
| | +-- bluebird@3.5.5 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- JSONStream@1.3.5 deduped
| | +-- lru-cache@5.1.1 deduped
| | +-- make-fetch-happen@5.0.2
| | | +-- agentkeepalive@3.5.2
| | | | `-- humanize-ms@1.2.1
| | | |   `-- ms@2.1.1
| | | +-- cacache@12.0.3 deduped
| | | +-- http-cache-semantics@3.8.1
| | | +-- http-proxy-agent@2.1.0
| | | | +-- agent-base@4.3.0
| | | | | `-- es6-promisify@5.0.0
| | | | |   `-- es6-promise@4.2.8
| | | | `-- debug@3.1.0
| | | |   `-- ms@2.0.0
| | | +-- https-proxy-agent@2.2.4
| | | | +-- agent-base@4.3.0 deduped
| | | | `-- debug@3.1.0 deduped
| | | +-- lru-cache@5.1.1 deduped
| | | +-- mississippi@3.0.0 deduped
| | | +-- node-fetch-npm@2.0.2
| | | | +-- encoding@0.1.12
| | | | | `-- iconv-lite@0.4.23
| | | | |   `-- safer-buffer@2.1.2 deduped
| | | | +-- json-parse-better-errors@1.0.2 deduped
| | | | `-- safe-buffer@5.1.2 deduped
| | | +-- promise-retry@1.1.1 deduped
| | | +-- socks-proxy-agent@4.0.2
| | | | +-- agent-base@4.2.1
| | | | | `-- es6-promisify@5.0.0 deduped
| | | | `-- socks@2.3.3
| | | |   +-- ip@1.1.5
| | | |   `-- smart-buffer@4.1.0
| | | `-- ssri@6.0.1 deduped
| | +-- npm-package-arg@6.1.1 deduped
| | `-- safe-buffer@5.2.1
| +-- npm-user-validate@1.0.0
| +-- npmlog@4.1.2
| | +-- are-we-there-yet@1.1.4
| | | +-- delegates@1.0.0
| | | `-- readable-stream@2.3.6
| | |   +-- core-util-is@1.0.2 deduped
| | |   +-- inherits@2.0.4 deduped
| | |   +-- isarray@1.0.0 deduped
| | |   +-- process-nextick-args@2.0.0 deduped
| | |   +-- safe-buffer@5.1.2 deduped
| | |   +-- string_decoder@1.1.1
| | |   | `-- safe-buffer@5.1.2 deduped
| | |   `-- util-deprecate@1.0.2 deduped
| | +-- console-control-strings@1.1.0 deduped
| | +-- gauge@2.7.4
| | | +-- aproba@1.2.0
| | | +-- console-control-strings@1.1.0 deduped
| | | +-- has-unicode@2.0.1 deduped
| | | +-- object-assign@4.1.1 deduped
| | | +-- signal-exit@3.0.2 deduped
| | | +-- string-width@1.0.2
| | | | +-- code-point-at@1.1.0
| | | | +-- is-fullwidth-code-point@1.0.0
| | | | | `-- number-is-nan@1.0.1
| | | | `-- strip-ansi@3.0.1 deduped
| | | +-- strip-ansi@3.0.1 deduped
| | | `-- wide-align@1.1.2
| | |   `-- string-width@1.0.2
| | |     +-- code-point-at@1.1.0 deduped
| | |     +-- is-fullwidth-code-point@1.0.0 deduped
| | |     `-- strip-ansi@3.0.1 deduped
| | `-- set-blocking@2.0.0
| +-- once@1.4.0
| | `-- wrappy@1.0.2 deduped
| +-- opener@1.5.1
| +-- osenv@0.1.5
| | +-- os-homedir@1.0.2
| | `-- os-tmpdir@1.0.2
| +-- pacote@9.5.12
| | +-- bluebird@3.5.5 deduped
| | +-- cacache@12.0.3 deduped
| | +-- chownr@1.1.4 deduped
| | +-- figgy-pudding@3.5.1 deduped
| | +-- get-stream@4.1.0 deduped
| | +-- glob@7.1.6 deduped
| | +-- infer-owner@1.0.4 deduped
| | +-- lru-cache@5.1.1 deduped
| | +-- make-fetch-happen@5.0.2 deduped
| | +-- minimatch@3.0.4 deduped
| | +-- minipass@2.9.0
| | | +-- safe-buffer@5.1.2 deduped
| | | `-- yallist@3.0.3 deduped
| | +-- mississippi@3.0.0 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- normalize-package-data@2.5.0 deduped
| | +-- npm-normalize-package-bin@1.0.1 deduped
| | +-- npm-package-arg@6.1.1 deduped
| | +-- npm-packlist@1.4.8 deduped
| | +-- npm-pick-manifest@3.0.2 deduped
| | +-- npm-registry-fetch@4.0.7 deduped
| | +-- osenv@0.1.5 deduped
| | +-- promise-inflight@1.0.1 deduped
| | +-- promise-retry@1.1.1
| | | +-- err-code@1.1.2
| | | `-- retry@0.10.1
| | +-- protoduck@5.0.1
| | | `-- genfun@5.0.0
| | +-- rimraf@2.7.1 deduped
| | +-- safe-buffer@5.1.2 deduped
| | +-- semver@5.7.1 deduped
| | +-- ssri@6.0.1 deduped
| | +-- tar@4.4.13 deduped
| | +-- unique-filename@1.1.1 deduped
| | `-- which@1.3.1 deduped
| +-- path-is-inside@1.0.2
| +-- promise-inflight@1.0.1
| +-- qrcode-terminal@0.12.0
| +-- query-string@6.8.2
| | +-- decode-uri-component@0.2.0
| | +-- split-on-first@1.1.0
| | `-- strict-uri-encode@2.0.0
| +-- qw@1.0.1
| +-- read@1.0.7
| | `-- mute-stream@0.0.7
| +-- read-cmd-shim@1.0.5
| | `-- graceful-fs@4.2.4 deduped
| +-- read-installed@4.0.3
| | +-- debuglog@1.0.1 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- read-package-json@2.1.1 deduped
| | +-- readdir-scoped-modules@1.1.0 deduped
| | +-- semver@5.7.1 deduped
| | +-- slide@1.1.6 deduped
| | `-- util-extend@1.0.3
| +-- read-package-json@2.1.1
| | +-- glob@7.1.6 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- json-parse-better-errors@1.0.2 deduped
| | +-- normalize-package-data@2.5.0 deduped
| | `-- npm-normalize-package-bin@1.0.1 deduped
| +-- read-package-tree@5.3.1
| | +-- read-package-json@2.1.1 deduped
| | +-- readdir-scoped-modules@1.1.0 deduped
| | `-- util-promisify@2.1.0
| |   `-- object.getownpropertydescriptors@2.0.3
| |     +-- define-properties@1.1.3
| |     | `-- object-keys@1.0.12
| |     `-- es-abstract@1.12.0
| |       +-- es-to-primitive@1.2.0
| |       | +-- is-callable@1.1.4 deduped
| |       | +-- is-date-object@1.0.1
| |       | `-- is-symbol@1.0.2
| |       |   `-- has-symbols@1.0.0
| |       +-- function-bind@1.1.1
| |       +-- has@1.0.3
| |       | `-- function-bind@1.1.1 deduped
| |       +-- is-callable@1.1.4
| |       `-- is-regex@1.0.4
| |         `-- has@1.0.3 deduped
| +-- readable-stream@3.6.0
| | +-- inherits@2.0.4 deduped
| | +-- string_decoder@1.3.0
| | | `-- safe-buffer@5.2.0
| | `-- util-deprecate@1.0.2
| +-- readdir-scoped-modules@1.1.0
| | +-- debuglog@1.0.1 deduped
| | +-- dezalgo@1.0.3 deduped
| | +-- graceful-fs@4.2.4 deduped
| | `-- once@1.4.0 deduped
| +-- request@2.88.0
| | +-- aws-sign2@0.7.0
| | +-- aws4@1.8.0
| | +-- caseless@0.12.0
| | +-- combined-stream@1.0.6
| | | `-- delayed-stream@1.0.0
| | +-- extend@3.0.2
| | +-- forever-agent@0.6.1
| | +-- form-data@2.3.2
| | | +-- asynckit@0.4.0
| | | +-- combined-stream@1.0.6 deduped
| | | `-- mime-types@2.1.19 deduped
| | +-- har-validator@5.1.0
| | | +-- ajv@5.5.2
| | | | +-- co@4.6.0
| | | | +-- fast-deep-equal@1.1.0
| | | | +-- fast-json-stable-stringify@2.0.0
| | | | `-- json-schema-traverse@0.3.1
| | | `-- har-schema@2.0.0
| | +-- http-signature@1.2.0
| | | +-- assert-plus@1.0.0
| | | +-- jsprim@1.4.1
| | | | +-- assert-plus@1.0.0 deduped
| | | | +-- extsprintf@1.3.0
| | | | +-- json-schema@0.2.3
| | | | `-- verror@1.10.0
| | | |   +-- assert-plus@1.0.0 deduped
| | | |   +-- core-util-is@1.0.2 deduped
| | | |   `-- extsprintf@1.3.0 deduped
| | | `-- sshpk@1.14.2
| | |   +-- asn1@0.2.4
| | |   | `-- safer-buffer@2.1.2 deduped
| | |   +-- assert-plus@1.0.0 deduped
| | |   +-- bcrypt-pbkdf@1.0.2
| | |   | `-- tweetnacl@0.14.5 deduped
| | |   +-- dashdash@1.14.1
| | |   | `-- assert-plus@1.0.0 deduped
| | |   +-- ecc-jsbn@0.1.2
| | |   | +-- jsbn@0.1.1 deduped
| | |   | `-- safer-buffer@2.1.2 deduped
| | |   +-- getpass@0.1.7
| | |   | `-- assert-plus@1.0.0 deduped
| | |   +-- jsbn@0.1.1
| | |   +-- safer-buffer@2.1.2
| | |   `-- tweetnacl@0.14.5
| | +-- is-typedarray@1.0.0
| | +-- isstream@0.1.2
| | +-- json-stringify-safe@5.0.1
| | +-- mime-types@2.1.19
| | | `-- mime-db@1.35.0
| | +-- oauth-sign@0.9.0
| | +-- performance-now@2.1.0
| | +-- qs@6.5.2
| | +-- safe-buffer@5.1.2 deduped
| | +-- tough-cookie@2.4.3
| | | +-- psl@1.1.29
| | | `-- punycode@1.4.1
| | +-- tunnel-agent@0.6.0
| | | `-- safe-buffer@5.1.2 deduped
| | `-- uuid@3.3.3 deduped
| +-- retry@0.12.0
| +-- rimraf@2.7.1
| | `-- glob@7.1.6 deduped
| +-- safe-buffer@5.1.2
| +-- semver@5.7.1
| +-- sha@3.0.0
| | `-- graceful-fs@4.2.4 deduped
| +-- slide@1.1.6
| +-- sorted-object@2.0.1
| +-- sorted-union-stream@2.1.3
| | +-- from2@1.3.0
| | | +-- inherits@2.0.4 deduped
| | | `-- readable-stream@1.1.14
| | |   +-- core-util-is@1.0.2 deduped
| | |   +-- inherits@2.0.4 deduped
| | |   +-- isarray@0.0.1
| | |   `-- string_decoder@0.10.31
| | `-- stream-iterate@1.2.0
| |   +-- readable-stream@2.3.6
| |   | +-- core-util-is@1.0.2 deduped
| |   | +-- inherits@2.0.4 deduped
| |   | +-- isarray@1.0.0 deduped
| |   | +-- process-nextick-args@2.0.0 deduped
| |   | +-- safe-buffer@5.1.2 deduped
| |   | +-- string_decoder@1.1.1
| |   | | `-- safe-buffer@5.1.2 deduped
| |   | `-- util-deprecate@1.0.2 deduped
| |   `-- stream-shift@1.0.0 deduped
| +-- ssri@6.0.1
| | `-- figgy-pudding@3.5.1 deduped
| +-- stringify-package@1.0.1
| +-- tar@4.4.13
| | +-- chownr@1.1.4 deduped
| | +-- fs-minipass@1.2.7
| | | `-- minipass@2.9.0
| | |   +-- safe-buffer@5.1.2 deduped
| | |   `-- yallist@3.0.3 deduped
| | +-- minipass@2.9.0
| | | +-- safe-buffer@5.1.2 deduped
| | | `-- yallist@3.0.3 deduped
| | +-- minizlib@1.3.3
| | | `-- minipass@2.9.0
| | |   +-- safe-buffer@5.1.2 deduped
| | |   `-- yallist@3.0.3 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- safe-buffer@5.1.2 deduped
| | `-- yallist@3.0.3 deduped
| +-- text-table@0.2.0
| +-- tiny-relative-date@1.3.0
| +-- uid-number@0.0.6
| +-- umask@1.1.0
| +-- unique-filename@1.1.1
| | `-- unique-slug@2.0.0
| |   `-- imurmurhash@0.1.4 deduped
| +-- unpipe@1.0.0
| +-- update-notifier@2.5.0
| | +-- boxen@1.3.0
| | | +-- ansi-align@2.0.0
| | | | `-- string-width@2.1.1 deduped
| | | +-- camelcase@4.1.0
| | | +-- chalk@2.4.1 deduped
| | | +-- cli-boxes@1.0.0
| | | +-- string-width@2.1.1 deduped
| | | +-- term-size@1.2.0
| | | | `-- execa@0.7.0
| | | |   +-- cross-spawn@5.1.0
| | | |   | +-- lru-cache@4.1.5
| | | |   | | +-- pseudomap@1.0.2
| | | |   | | `-- yallist@2.1.2
| | | |   | +-- shebang-command@1.2.0
| | | |   | | `-- shebang-regex@1.0.0
| | | |   | `-- which@1.3.1 deduped
| | | |   +-- get-stream@3.0.0
| | | |   +-- is-stream@1.1.0
| | | |   +-- npm-run-path@2.0.2
| | | |   | `-- path-key@2.0.1
| | | |   +-- p-finally@1.0.0
| | | |   +-- signal-exit@3.0.2 deduped
| | | |   `-- strip-eof@1.0.0
| | | `-- widest-line@2.0.1
| | |   `-- string-width@2.1.1 deduped
| | +-- chalk@2.4.1
| | | +-- ansi-styles@3.2.1
| | | | `-- color-convert@1.9.1
| | | |   `-- color-name@1.1.3
| | | +-- escape-string-regexp@1.0.5
| | | `-- supports-color@5.4.0
| | |   `-- has-flag@3.0.0
| | +-- configstore@3.1.5
| | | +-- dot-prop@4.2.1
| | | | `-- is-obj@1.0.1
| | | +-- graceful-fs@4.2.4 deduped
| | | +-- make-dir@1.3.0
| | | | `-- pify@3.0.0
| | | +-- unique-string@1.0.0
| | | | `-- crypto-random-string@1.0.0
| | | +-- write-file-atomic@2.4.3 deduped
| | | `-- xdg-basedir@3.0.0 deduped
| | +-- import-lazy@2.1.0
| | +-- is-ci@1.2.1
| | | `-- ci-info@1.6.0
| | +-- is-installed-globally@0.1.0
| | | +-- global-dirs@0.1.1
| | | | `-- ini@1.3.5 deduped
| | | `-- is-path-inside@1.0.1
| | |   `-- path-is-inside@1.0.2 deduped
| | +-- is-npm@1.0.0
| | +-- latest-version@3.1.0
| | | `-- package-json@4.0.1
| | |   +-- got@6.7.1
| | |   | +-- create-error-class@3.0.2
| | |   | | `-- capture-stack-trace@1.0.0
| | |   | +-- duplexer3@0.1.4
| | |   | +-- get-stream@3.0.0
| | |   | +-- is-redirect@1.0.0
| | |   | +-- is-retry-allowed@1.2.0
| | |   | +-- is-stream@1.1.0 deduped
| | |   | +-- lowercase-keys@1.0.1
| | |   | +-- safe-buffer@5.1.2 deduped
| | |   | +-- timed-out@4.0.1
| | |   | +-- unzip-response@2.0.1
| | |   | `-- url-parse-lax@1.0.0
| | |   |   `-- prepend-http@1.0.4
| | |   +-- registry-auth-token@3.4.0
| | |   | +-- rc@1.2.8
| | |   | | +-- deep-extend@0.6.0
| | |   | | +-- ini@1.3.5 deduped
| | |   | | +-- minimist@1.2.5
| | |   | | `-- strip-json-comments@2.0.1
| | |   | `-- safe-buffer@5.1.2 deduped
| | |   +-- registry-url@3.1.0
| | |   | `-- rc@1.2.8 deduped
| | |   `-- semver@5.7.1 deduped
| | +-- semver-diff@2.1.0
| | | `-- semver@5.7.1 deduped
| | `-- xdg-basedir@3.0.0
| +-- uuid@3.3.3
| +-- validate-npm-package-license@3.0.4
| | +-- spdx-correct@3.0.0
| | | +-- spdx-expression-parse@3.0.0 deduped
| | | `-- spdx-license-ids@3.0.5
| | `-- spdx-expression-parse@3.0.0
| |   +-- spdx-exceptions@2.1.0
| |   `-- spdx-license-ids@3.0.5 deduped
| +-- validate-npm-package-name@3.0.0
| | `-- builtins@1.0.3
| +-- which@1.3.1
| | `-- isexe@2.0.0
| +-- worker-farm@1.7.0
| | `-- errno@0.1.7
| |   `-- prr@1.0.1
| `-- write-file-atomic@2.4.3
|   +-- graceful-fs@4.2.4 deduped
|   +-- imurmurhash@0.1.4 deduped
|   `-- signal-exit@3.0.2 deduped
</t>
<t tx="ekr.20201114160816.12">+-- typescript@3.9.5
`-- wasm-opt@1.1.1
  +-- node-fetch@2.6.1
  +-- ora@4.1.1
  | +-- chalk@3.0.0
  | | +-- ansi-styles@4.2.1
  | | | +-- @types/color-name@1.1.1
  | | | `-- color-convert@2.0.1
  | | |   `-- color-name@1.1.4
  | | `-- supports-color@7.2.0
  | |   `-- has-flag@4.0.0
  | +-- cli-cursor@3.1.0
  | | `-- restore-cursor@3.1.0
  | |   +-- onetime@5.1.2
  | |   | `-- mimic-fn@2.1.0
  | |   `-- signal-exit@3.0.3
  | +-- cli-spinners@2.4.0
  | +-- is-interactive@1.0.0
  | +-- log-symbols@3.0.0
  | | `-- chalk@2.4.2
  | |   +-- ansi-styles@3.2.1
  | |   | `-- color-convert@1.9.3
  | |   |   `-- color-name@1.1.3
  | |   +-- escape-string-regexp@1.0.5
  | |   `-- supports-color@5.5.0
  | |     `-- has-flag@3.0.0
  | +-- mute-stream@0.0.8
  | +-- strip-ansi@6.0.0
  | | `-- ansi-regex@5.0.0
  | `-- wcwidth@1.0.1
  |   `-- defaults@1.0.3
  |     `-- clone@1.0.4
  `-- tar@5.0.5
    +-- chownr@1.1.4
    +-- fs-minipass@2.1.0
    | `-- minipass@3.1.3 deduped
    +-- minipass@3.1.3
    | `-- yallist@4.0.0 deduped
    +-- minizlib@2.1.2
    | +-- minipass@3.1.3 deduped
    | `-- yallist@4.0.0 deduped
    +-- mkdirp@0.5.5
    | `-- minimist@1.2.5
    `-- yallist@4.0.0
</t>
<t tx="ekr.20201114160816.13">pip install jupyter_contrib_nbextensions

pip install jupyterlab

jupyterlab extensions are npm packages.

npm list -g</t>
<t tx="ekr.20201114160816.14">C:\Users\edreamleo\Python\Python37\share\jupyter\lab\staging\node_modules&gt;npm list

@jupyterlab/application-top@2.2.9 C:\Users\edreamleo\Python\Python37\share\jupyter\lab\staging

+-- @jupyterlab/docmanager-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/docmanager@2.2.4 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/documentsearch-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/documentsearch@2.2.7 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/extensionmanager-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/extensionmanager@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/settingregistry@2.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- react@16.9.0 deduped
| | +-- react-paginate@6.5.0
| | | `-- prop-types@15.7.2 deduped
| | `-- semver@6.3.0 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| `-- @jupyterlab/ui-components@2.2.4 deduped

+-- @jupyterlab/filebrowser-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/docmanager@2.2.4 deduped
| +-- @jupyterlab/filebrowser@2.2.5 deduped
| +-- @jupyterlab/launcher@2.2.6 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statedb@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/commands@1.11.3 deduped
| +-- @lumino/messaging@1.4.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/fileeditor-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/codeeditor@2.2.5 deduped
| +-- @jupyterlab/codemirror@2.2.4 deduped
| +-- @jupyterlab/console@2.2.7 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/filebrowser@2.2.5 deduped
| +-- @jupyterlab/fileeditor@2.2.4 deduped
| +-- @jupyterlab/launcher@2.2.6 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/commands@1.11.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/help-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/inspector@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/widgets@1.14.0 deduped
| `-- react@16.9.0 deduped

+-- @jupyterlab/htmlviewer-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/htmlviewer@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- react@16.9.0 deduped
| `-- @jupyterlab/ui-components@2.2.4 deduped

+-- @jupyterlab/hub-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| `-- @jupyterlab/services@5.2.5 deduped

+-- @jupyterlab/imageviewer-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| `-- @jupyterlab/imageviewer@2.2.4
|   +-- @jupyterlab/apputils@2.2.6 deduped
|   +-- @jupyterlab/coreutils@4.2.5 deduped
|   +-- @jupyterlab/docregistry@2.2.4 deduped
|   +-- @lumino/coreutils@1.5.3 deduped
|   +-- @lumino/messaging@1.4.3 deduped
|   `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/inspector-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/console@2.2.7 deduped
| +-- @jupyterlab/inspector@2.2.4 deduped
| +-- @jupyterlab/launcher@2.2.6 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| `-- @jupyterlab/ui-components@2.2.4 deduped

+-- @jupyterlab/javascript-extension@2.2.4
| +-- @jupyterlab/rendermime@2.2.4 deduped
| `-- @jupyterlab/rendermime-interfaces@2.2.1 deduped

+-- @jupyterlab/json-extension@2.2.6
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/messaging@1.4.3 deduped
| +-- @lumino/widgets@1.14.0 deduped
| +-- react@16.9.0 deduped
| +-- react-dom@16.9.0 deduped
| +-- react-highlighter@0.4.3
| | +-- blacklist@1.1.4
| | +-- create-react-class@15.7.0
| | | +-- loose-envify@1.4.0 deduped
| | | `-- object-assign@4.1.1 deduped
| | +-- escape-string-regexp@1.0.5
| | `-- prop-types@15.7.2 deduped
| `-- react-json-tree@0.11.2
|   +-- babel-runtime@6.26.0
|   | +-- core-js@2.6.11
|   | `-- regenerator-runtime@0.11.1
|   +-- prop-types@15.7.2 deduped
|   `-- react-base16-styling@0.5.3
|     +-- base16@1.0.0
|     +-- lodash.curry@4.1.1
|     +-- lodash.flow@3.5.0
|     `-- pure-color@1.3.0

+-- @jupyterlab/launcher-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/launcher@2.2.6 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/logconsole-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/logconsole@2.2.4
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/outputarea@2.2.4 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/nbformat@2.2.5
| | `-- @lumino/coreutils@1.5.3 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/signaling@1.4.3 deduped
| +-- @lumino/widgets@1.14.0 deduped
| `-- react@16.9.0 deduped

+-- @jupyterlab/mainmenu-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/markdownviewer-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/markdownviewer@2.2.6 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| `-- @jupyterlab/settingregistry@2.2.5 deduped

+-- @jupyterlab/mathjax2-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/mathjax2@2.2.1
| | +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| | `-- @lumino/coreutils@1.5.3 deduped
| `-- @jupyterlab/rendermime@2.2.4 deduped

+-- @jupyterlab/notebook-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/cells@2.2.7 deduped
| +-- @jupyterlab/codeeditor@2.2.5 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/docmanager@2.2.4 deduped
| +-- @jupyterlab/filebrowser@2.2.5 deduped
| +-- @jupyterlab/launcher@2.2.6 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/nbformat@2.2.5 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| +-- @jupyterlab/property-inspector@2.2.6 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statedb@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/commands@1.11.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| +-- @lumino/messaging@1.4.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/pdf-extension@2.2.1
| +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/rendermime-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/docmanager@2.2.4 deduped
| `-- @jupyterlab/rendermime@2.2.4 deduped

+-- @jupyterlab/running-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/running@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| `-- @lumino/algorithm@1.3.3 deduped

+-- @jupyterlab/settingeditor-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/codeeditor@2.2.5 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/settingeditor@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/inspector@2.2.4 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/settingregistry@2.2.5 deduped
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- react@16.9.0 deduped
| | `-- react-dom@16.9.0 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statedb@2.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| `-- @lumino/disposable@1.4.3 deduped

+-- @jupyterlab/shortcuts-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @lumino/commands@1.11.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| `-- @lumino/disposable@1.4.3 deduped

+-- @jupyterlab/statusbar-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/cells@2.2.7 deduped
| +-- @jupyterlab/console@2.2.7 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/fileeditor@2.2.4 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/tabmanager-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/terminal-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/launcher@2.2.6 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/running@2.2.6 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/terminal@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- xterm@4.2.0
| | `-- xterm-addon-fit@0.3.0
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/theme-dark-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| `-- @jupyterlab/apputils@2.2.6 deduped

+-- @jupyterlab/theme-light-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| `-- @jupyterlab/apputils@2.2.6 deduped

+-- @jupyterlab/toc@4.0.0 invalid
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/settingregistry@2.2.5 deduped
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/domutils@1.2.3
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/properties@1.2.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/virtualdom@1.7.3
| | | `-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- @types/react@16.9.53
| | | +-- @types/prop-types@15.7.3
| | | `-- csstype@3.0.4
| | +-- react@16.9.0 deduped
| | +-- react-dom@16.9.0 deduped
| | `-- sanitize-html@1.20.1
| |   +-- chalk@2.4.2 deduped
| |   +-- htmlparser2@3.10.1
| |   | +-- domelementtype@1.3.1
| |   | +-- domhandler@2.4.2
| |   | | `-- domelementtype@1.3.1 deduped
| |   | +-- domutils@1.5.1
| |   | | +-- dom-serializer@0.2.2
| |   | | | +-- domelementtype@2.0.2
| |   | | | `-- entities@2.1.0
| |   | | `-- domelementtype@1.3.1 deduped
| |   | +-- entities@1.1.2
| |   | +-- inherits@2.0.4 deduped
| |   | `-- readable-stream@3.6.0
| |   |   +-- inherits@2.0.4 deduped
| |   |   +-- string_decoder@1.1.1 deduped
| |   |   `-- util-deprecate@1.0.2 deduped
| |   +-- lodash.clonedeep@4.5.0
| |   +-- lodash.escaperegexp@4.1.2
| |   +-- lodash.isplainobject@4.0.6
| |   +-- lodash.isstring@4.0.1
| |   +-- lodash.mergewith@4.6.2
| |   +-- postcss@7.0.35 deduped
| |   +-- srcset@1.0.0
| |   | +-- array-uniq@1.0.3
| |   | `-- number-is-nan@1.0.1
| |   `-- xtend@4.0.2
| +-- @jupyterlab/cells@2.2.7
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/attachments@2.2.4
| | | +-- @jupyterlab/nbformat@2.2.5 deduped
| | | +-- @jupyterlab/observables@3.2.5 deduped
| | | +-- @jupyterlab/rendermime@2.2.4 deduped
| | | +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| | | +-- @lumino/disposable@1.4.3 deduped
| | | `-- @lumino/signaling@1.4.3 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/codemirror@2.2.4 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/filebrowser@2.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5
| | | +-- @lumino/algorithm@1.3.3 deduped
| | | +-- @lumino/coreutils@1.5.3 deduped
| | | +-- @lumino/disposable@1.4.3 deduped
| | | +-- @lumino/messaging@1.4.3 deduped
| | | `-- @lumino/signaling@1.4.3 deduped
| | +-- @jupyterlab/outputarea@2.2.4
| | | +-- @jupyterlab/apputils@2.2.6 deduped
| | | +-- @jupyterlab/nbformat@2.2.5 deduped
| | | +-- @jupyterlab/observables@3.2.5 deduped
| | | +-- @jupyterlab/rendermime@2.2.4 deduped
| | | +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| | | +-- @jupyterlab/services@5.2.5 deduped
| | | +-- @lumino/algorithm@1.3.3 deduped
| | | +-- @lumino/coreutils@1.5.3 deduped
| | | +-- @lumino/disposable@1.4.3 deduped
| | | +-- @lumino/messaging@1.4.3 deduped
| | | +-- @lumino/properties@1.2.3 deduped
| | | +-- @lumino/signaling@1.4.3 deduped
| | | `-- @lumino/widgets@1.14.0 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/dragdrop@1.6.4
| | | +-- @lumino/coreutils@1.5.3 deduped
| | | `-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/virtualdom@1.7.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/docmanager@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/statusbar@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/properties@1.2.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/docregistry@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/codemirror@2.2.4 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/fileeditor@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @jupyterlab/statusbar@2.2.4 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/markdownviewer@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/notebook@2.2.7
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/cells@2.2.7 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/statusbar@2.2.4 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/dragdrop@1.6.4 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/properties@1.2.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/virtualdom@1.7.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/rendermime@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codemirror@2.2.4 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- lodash.escape@4.0.1
| | `-- marked@0.8.2
| +-- @lumino/algorithm@1.3.3
| +-- @lumino/coreutils@1.5.3
| +-- @lumino/messaging@1.4.3
| | +-- @lumino/algorithm@1.3.3 deduped
| | `-- @lumino/collections@1.3.3
| |   `-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/widgets@1.14.0
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/dragdrop@1.6.4 deduped
| | +-- @lumino/keyboard@1.2.3
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/properties@1.2.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/virtualdom@1.7.3 deduped
| +-- react@16.9.0
| | +-- loose-envify@1.4.0
| | | `-- js-tokens@4.0.0
| | +-- object-assign@4.1.1 deduped
| | `-- prop-types@15.7.2
| |   +-- loose-envify@1.4.0 deduped
| |   +-- object-assign@4.1.1 deduped
| |   `-- react-is@16.13.1
| `-- react-dom@16.9.0
|   +-- loose-envify@1.4.0 deduped
|   +-- object-assign@4.1.1 deduped
|   +-- prop-types@15.7.2 deduped
|   `-- scheduler@0.15.0
|     +-- loose-envify@1.4.0 deduped
|     `-- object-assign@4.1.1 deduped

+-- @jupyterlab/tooltip-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/codeeditor@2.2.5 deduped
| +-- @jupyterlab/console@2.2.7 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/fileeditor@2.2.4 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @jupyterlab/tooltip@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/ui-components-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| `-- @jupyterlab/ui-components@2.2.4 deduped

+-- @jupyterlab/vdom-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| `-- @jupyterlab/vdom@2.2.6
|   +-- @jupyterlab/apputils@2.2.6 deduped
|   +-- @jupyterlab/docregistry@2.2.4 deduped
|   +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
|   +-- @jupyterlab/services@5.2.5 deduped
|   +-- @lumino/coreutils@1.5.3 deduped
|   +-- @lumino/messaging@1.4.3 deduped
|   +-- @lumino/widgets@1.14.0 deduped
|   +-- @nteract/transform-vdom@4.0.15
|   | `-- lodash.clonedeep@4.5.0 deduped
|   +-- react@16.9.0 deduped
|   `-- react-dom@16.9.0 deduped

+-- @jupyterlab/vega5-extension@2.2.1
| +-- @jupyterlab/rendermime-interfaces@2.2.1 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/widgets@1.14.0 deduped
| +-- vega@5.17.0
| | +-- vega-crossfilter@4.0.5
| | | +-- d3-array@2.8.0
| | | +-- vega-dataflow@5.7.3 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-dataflow@5.7.3
| | | +-- vega-format@1.0.4 deduped
| | | +-- vega-loader@4.4.0 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-encode@4.8.3
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-interpolate@2.0.1
| | | | `-- d3-color@2.0.0 deduped
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-scale@7.1.1 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-event-selector@2.0.6
| | +-- vega-expression@3.0.0
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-force@4.0.7
| | | +-- d3-force@2.1.1
| | | | +-- d3-dispatch@2.0.0
| | | | +-- d3-quadtree@2.0.0
| | | | `-- d3-timer@2.0.0 deduped
| | | +-- vega-dataflow@5.7.3 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-format@1.0.4
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-format@2.0.0
| | | +-- d3-time-format@3.0.0
| | | | `-- d3-time@2.0.0 deduped
| | | +-- vega-time@2.0.4 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-functions@5.8.0
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-color@2.0.0
| | | +-- d3-geo@2.0.1
| | | | `-- d3-array@2.8.0 deduped
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-expression@3.0.0 deduped
| | | +-- vega-scale@7.1.1 deduped
| | | +-- vega-scenegraph@4.9.2 deduped
| | | +-- vega-selections@5.1.4
| | | | +-- vega-expression@3.0.0 deduped
| | | | `-- vega-util@1.16.0 deduped
| | | +-- vega-statistics@1.7.9 deduped
| | | +-- vega-time@2.0.4 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-geo@4.3.7
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-color@2.0.0 deduped
| | | +-- d3-geo@2.0.1 deduped
| | | +-- vega-canvas@1.2.6
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-projection@1.4.5 deduped
| | | +-- vega-statistics@1.7.9 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-hierarchy@4.0.9
| | | +-- d3-hierarchy@2.0.0
| | | +-- vega-dataflow@5.7.3 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-label@1.0.0
| | | +-- vega-canvas@1.2.6 deduped
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-scenegraph@4.9.2 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-loader@4.4.0
| | | +-- d3-dsv@2.0.0
| | | | +-- commander@2.20.3 deduped
| | | | +-- iconv-lite@0.4.24 deduped
| | | | `-- rw@1.3.3
| | | +-- node-fetch@2.6.1 deduped
| | | +-- topojson-client@3.1.0
| | | | `-- commander@2.20.3 deduped
| | | +-- vega-format@1.0.4 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-parser@6.1.0
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-event-selector@2.0.6 deduped
| | | +-- vega-functions@5.8.0 deduped
| | | +-- vega-scale@7.1.1 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-projection@1.4.5
| | | +-- d3-geo@2.0.1 deduped
| | | `-- d3-geo-projection@3.0.0
| | |   +-- commander@2.20.3 deduped
| | |   +-- d3-array@2.8.0 deduped
| | |   +-- d3-geo@2.0.1 deduped
| | |   `-- resolve@1.18.1
| | |     +-- is-core-module@2.0.0
| | |     | `-- has@1.0.3 deduped
| | |     `-- path-parse@1.0.6
| | +-- vega-regression@1.0.9
| | | +-- d3-array@2.8.0 deduped
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-statistics@1.7.9 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-runtime@6.1.3
| | | +-- vega-dataflow@5.7.3 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-scale@7.1.1
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-interpolate@2.0.1 deduped
| | | +-- d3-scale@3.2.3
| | | | +-- d3-array@2.8.0 deduped
| | | | +-- d3-format@2.0.0 deduped
| | | | +-- d3-interpolate@2.0.1 deduped
| | | | +-- d3-time@2.0.0 deduped
| | | | `-- d3-time-format@3.0.0 deduped
| | | +-- vega-time@2.0.4 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-scenegraph@4.9.2
| | | +-- d3-path@2.0.0
| | | +-- d3-shape@2.0.0
| | | | `-- d3-path@2.0.0 deduped
| | | +-- vega-canvas@1.2.6 deduped
| | | +-- vega-loader@4.4.0 deduped
| | | +-- vega-scale@7.1.1 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-statistics@1.7.9
| | | `-- d3-array@2.8.0 deduped
| | +-- vega-time@2.0.4
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-time@2.0.0
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-transforms@4.9.3
| | | +-- d3-array@2.8.0 deduped
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-statistics@1.7.9 deduped
| | | +-- vega-time@2.0.4 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-typings@0.19.1
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-util@1.16.0
| | +-- vega-view@5.9.0
| | | +-- d3-array@2.8.0 deduped
| | | +-- d3-timer@2.0.0
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-format@1.0.4 deduped
| | | +-- vega-functions@5.8.0 deduped
| | | +-- vega-runtime@6.1.3 deduped
| | | +-- vega-scenegraph@4.9.2 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-view-transforms@4.5.8
| | | +-- vega-dataflow@5.7.3 deduped
| | | +-- vega-scenegraph@4.9.2 deduped
| | | `-- vega-util@1.16.0 deduped
| | +-- vega-voronoi@4.1.5
| | | +-- d3-delaunay@5.3.0
| | | | `-- delaunator@4.0.1
| | | +-- vega-dataflow@5.7.3 deduped
| | | `-- vega-util@1.16.0 deduped
| | `-- vega-wordcloud@4.1.3
| |   +-- vega-canvas@1.2.6 deduped
| |   +-- vega-dataflow@5.7.3 deduped
| |   +-- vega-scale@7.1.1 deduped
| |   +-- vega-statistics@1.7.9 deduped
| |   `-- vega-util@1.16.0 deduped
| +-- vega-embed@6.12.2
| | +-- fast-json-patch@3.0.0-1
| | +-- json-stringify-pretty-compact@2.0.0
| | +-- semver@7.3.2
| | +-- vega-schema-url-parser@2.1.0
| | +-- vega-themes@2.9.1
| | `-- vega-tooltip@0.24.2
| |   `-- vega-util@1.16.0 deduped
| `-- vega-lite@4.17.0
|   +-- @types/clone@2.1.0
|   +-- @types/fast-json-stable-stringify@2.0.0
|   +-- array-flat-polyfill@1.0.1
|   +-- clone@2.1.2
|   +-- fast-deep-equal@3.1.3
|   +-- fast-json-stable-stringify@2.1.0
|   +-- json-stringify-pretty-compact@2.0.0 deduped
|   +-- tslib@2.0.3
|   +-- vega-event-selector@2.0.6 deduped
|   +-- vega-expression@3.0.0 deduped
|   +-- vega-util@1.16.0 deduped
|   `-- yargs@16.0.3
|     +-- cliui@7.0.3
|     | +-- string-width@4.2.0 deduped
|     | +-- strip-ansi@6.0.0 deduped
|     | `-- wrap-ansi@7.0.0
|     |   +-- ansi-styles@4.3.0
|     |   | `-- color-convert@2.0.1
|     |   |   `-- color-name@1.1.4
|     |   +-- string-width@4.2.0 deduped
|     |   `-- strip-ansi@6.0.0 deduped
|     +-- escalade@3.1.1
|     +-- get-caller-file@2.0.5 deduped
|     +-- require-directory@2.1.1 deduped
|     +-- string-width@4.2.0 deduped
|     +-- y18n@5.0.4
|     `-- yargs-parser@20.2.3

+-- chokidar@3.4.3
| +-- anymatch@3.1.1
| | +-- normalize-path@3.0.0 deduped
| | `-- picomatch@2.2.2
| +-- braces@3.0.2
| | `-- fill-range@7.0.1
| |   `-- to-regex-range@5.0.1
| |     `-- is-number@7.0.0
| +-- UNMET OPTIONAL DEPENDENCY fsevents@~2.1.2
| +-- glob-parent@5.1.1
| | `-- is-glob@4.0.1 deduped
| +-- is-binary-path@2.1.0
| | `-- binary-extensions@2.1.0
| +-- is-glob@4.0.1
| | `-- is-extglob@2.1.1
| +-- normalize-path@3.0.0
| `-- readdirp@3.5.0
|   `-- picomatch@2.2.2 deduped

+-- css-loader@3.2.1
| +-- camelcase@5.3.1
| +-- cssesc@3.0.0
| +-- icss-utils@4.1.1
| | `-- postcss@7.0.35 deduped
| +-- loader-utils@1.4.0
| | +-- big.js@5.2.2
| | +-- emojis-list@3.0.0
| | `-- json5@1.0.1
| |   `-- minimist@1.2.5 deduped
| +-- normalize-path@3.0.0 deduped
| +-- postcss@7.0.35
| | +-- chalk@2.4.2 deduped
| | +-- source-map@0.6.1 deduped
| | `-- supports-color@6.1.0 deduped
| +-- postcss-modules-extract-imports@2.0.0
| | `-- postcss@7.0.35 deduped
| +-- postcss-modules-local-by-default@3.0.3
| | +-- icss-utils@4.1.1 deduped
| | +-- postcss@7.0.35 deduped
| | +-- postcss-selector-parser@6.0.4
| | | +-- cssesc@3.0.0 deduped
| | | +-- indexes-of@1.0.1
| | | +-- uniq@1.0.1
| | | `-- util-deprecate@1.0.2
| | `-- postcss-value-parser@4.1.0 deduped
| +-- postcss-modules-scope@2.2.0
| | +-- postcss@7.0.35 deduped
| | `-- postcss-selector-parser@6.0.4 deduped
| +-- postcss-modules-values@3.0.0
| | +-- icss-utils@4.1.1 deduped
| | `-- postcss@7.0.35 deduped
| +-- postcss-value-parser@4.1.0
| `-- schema-utils@2.7.1
|   +-- @types/json-schema@7.0.6
|   +-- ajv@6.12.6 deduped
|   `-- ajv-keywords@3.5.2 deduped

+-- duplicate-package-checker-webpack-plugin@3.0.0
| +-- chalk@2.4.2
| | +-- ansi-styles@3.2.1
| | | `-- color-convert@1.9.3
| | |   `-- color-name@1.1.3
| | +-- escape-string-regexp@1.0.5 deduped
| | `-- supports-color@5.5.0
| |   `-- has-flag@3.0.0 deduped
| +-- find-root@1.1.0
| +-- lodash@4.17.20
| `-- semver@5.7.1

+-- file-loader@5.0.2
| +-- loader-utils@1.4.0 deduped
| `-- schema-utils@2.7.1 deduped

+-- fs-extra@8.1.0
| +-- graceful-fs@4.2.4
| +-- jsonfile@4.0.0
| | `-- graceful-fs@4.2.4 deduped
| `-- universalify@0.1.2

+-- glob@7.1.6
| +-- fs.realpath@1.0.0
| +-- inflight@1.0.6
| | +-- once@1.4.0 deduped
| | `-- wrappy@1.0.2
| +-- inherits@2.0.4
| +-- minimatch@3.0.4
| | `-- brace-expansion@1.1.11
| |   +-- balanced-match@1.0.0
| |   `-- concat-map@0.0.1
| +-- once@1.4.0
| | `-- wrappy@1.0.2 deduped
| `-- path-is-absolute@1.0.1

+-- handlebars@4.7.6
| +-- minimist@1.2.5 deduped
| +-- neo-async@2.6.2
| +-- source-map@0.6.1
| +-- uglify-js@3.4.10
| | +-- commander@2.19.0
| | `-- source-map@0.6.1 deduped
| `-- wordwrap@1.0.0

+-- html-loader@0.5.5
| +-- es6-templates@0.2.3
| | +-- recast@0.11.23
| | | +-- ast-types@0.9.6
| | | +-- esprima@3.1.3
| | | +-- private@0.1.8
| | | `-- source-map@0.5.7
| | `-- through@2.3.8 deduped
| +-- fastparse@1.1.2
| +-- html-minifier@3.5.21
| | +-- camel-case@3.0.0
| | | +-- no-case@2.3.2
| | | | `-- lower-case@1.1.4
| | | `-- upper-case@1.1.3
| | +-- clean-css@4.2.3
| | | `-- source-map@0.6.1 deduped
| | +-- commander@2.17.1
| | +-- he@1.2.0
| | +-- param-case@2.1.1
| | | `-- no-case@2.3.2 deduped
| | +-- relateurl@0.2.7
| | `-- uglify-js@3.4.10 deduped
| +-- loader-utils@1.4.0 deduped
| `-- object-assign@4.1.1

+-- html-webpack-plugin@3.2.0
| +-- html-minifier@3.5.21 deduped
| +-- loader-utils@0.2.17
| | +-- big.js@3.2.0
| | +-- emojis-list@2.1.0
| | +-- json5@0.5.1
| | `-- object-assign@4.1.1 deduped
| +-- lodash@4.17.20 deduped
| +-- pretty-error@2.1.2
| | +-- lodash@4.17.20 deduped
| | `-- renderkid@2.0.4
| |   +-- css-select@1.2.0
| |   | +-- boolbase@1.0.0
| |   | +-- css-what@2.1.3
| |   | +-- domutils@1.5.1 deduped
| |   | `-- nth-check@1.0.2
| |   |   `-- boolbase@1.0.0 deduped
| |   +-- dom-converter@0.2.0
| |   | `-- utila@0.4.0
| |   +-- htmlparser2@3.10.1 deduped
| |   +-- lodash@4.17.20 deduped
| |   `-- strip-ansi@3.0.1
| |     `-- ansi-regex@2.1.1
| +-- tapable@1.1.3
| +-- toposort@1.0.7
| `-- util.promisify@1.0.0
|   +-- define-properties@1.1.3
|   | `-- object-keys@1.1.1
|   `-- object.getownpropertydescriptors@2.1.0
|     +-- define-properties@1.1.3 deduped
|     `-- es-abstract@1.17.7
|       +-- es-to-primitive@1.2.1
|       | +-- is-callable@1.2.2 deduped
|       | +-- is-date-object@1.0.2 deduped
|       | `-- is-symbol@1.0.3
|       |   `-- has-symbols@1.0.1 deduped
|       +-- function-bind@1.1.1
|       +-- has@1.0.3
|       | `-- function-bind@1.1.1 deduped
|       +-- has-symbols@1.0.1
|       +-- is-callable@1.2.2
|       +-- is-regex@1.1.1
|       | `-- has-symbols@1.0.1 deduped
|       +-- object-inspect@1.8.0
|       +-- object-keys@1.1.1 deduped
|       +-- object.assign@4.1.1
|       | +-- define-properties@1.1.3 deduped
|       | +-- es-abstract@1.18.0-next.1
|       | | +-- es-to-primitive@1.2.1 deduped
|       | | +-- function-bind@1.1.1 deduped
|       | | +-- has@1.0.3 deduped
|       | | +-- has-symbols@1.0.1 deduped
|       | | +-- is-callable@1.2.2 deduped
|       | | +-- is-negative-zero@2.0.0
|       | | +-- is-regex@1.1.1 deduped
|       | | +-- object-inspect@1.8.0 deduped
|       | | +-- object-keys@1.1.1 deduped
|       | | +-- object.assign@4.1.1 deduped
|       | | +-- string.prototype.trimend@1.0.2 deduped
|       | | `-- string.prototype.trimstart@1.0.2 deduped
|       | +-- has-symbols@1.0.1 deduped
|       | `-- object-keys@1.1.1 deduped
|       +-- string.prototype.trimend@1.0.2
|       | +-- define-properties@1.1.3 deduped
|       | `-- es-abstract@1.18.0-next.1
|       |   +-- es-to-primitive@1.2.1 deduped
|       |   +-- function-bind@1.1.1 deduped
|       |   +-- has@1.0.3 deduped
|       |   +-- has-symbols@1.0.1 deduped
|       |   +-- is-callable@1.2.2 deduped
|       |   +-- is-negative-zero@2.0.0 deduped
|       |   +-- is-regex@1.1.1 deduped
|       |   +-- object-inspect@1.8.0 deduped
|       |   +-- object-keys@1.1.1 deduped
|       |   +-- object.assign@4.1.1 deduped
|       |   +-- string.prototype.trimend@1.0.2 deduped
|       |   `-- string.prototype.trimstart@1.0.2 deduped
|       `-- string.prototype.trimstart@1.0.2
|         +-- define-properties@1.1.3 deduped
|         `-- es-abstract@1.18.0-next.1
|           +-- es-to-primitive@1.2.1 deduped
|           +-- function-bind@1.1.1 deduped
|           +-- has@1.0.3 deduped
|           +-- has-symbols@1.0.1 deduped
|           +-- is-callable@1.2.2 deduped
|           +-- is-negative-zero@2.0.0 deduped
|           +-- is-regex@1.1.1 deduped
|           +-- object-inspect@1.8.0 deduped
|           +-- object-keys@1.1.1 deduped
|           +-- object.assign@4.1.1 deduped
|           +-- string.prototype.trimend@1.0.2 deduped
|           `-- string.prototype.trimstart@1.0.2 deduped

+-- mini-css-extract-plugin@0.8.2
| +-- loader-utils@1.4.0 deduped
| +-- normalize-url@1.9.1
| | +-- object-assign@4.1.1 deduped
| | +-- prepend-http@1.0.4
| | +-- query-string@4.3.4
| | | +-- object-assign@4.1.1 deduped
| | | `-- strict-uri-encode@1.1.0
| | `-- sort-keys@1.1.2
| |   `-- is-plain-obj@1.1.0
| +-- schema-utils@1.0.0
| | +-- ajv@6.12.6 deduped
| | +-- ajv-errors@1.0.1
| | `-- ajv-keywords@3.5.2 deduped
| `-- webpack-sources@1.4.3
|   +-- source-list-map@2.0.1
|   `-- source-map@0.6.1 deduped

+-- raw-loader@4.0.2
| +-- loader-utils@2.0.0
| | +-- big.js@5.2.2 deduped
| | +-- emojis-list@3.0.0
| | `-- json5@2.1.3
| |   `-- minimist@1.2.5 deduped
| `-- schema-utils@3.0.0
|   +-- @types/json-schema@7.0.6 deduped
|   +-- ajv@6.12.6 deduped
|   `-- ajv-keywords@3.5.2 deduped

+-- rimraf@3.0.2
| `-- glob@7.1.6 deduped

+-- sort-package-json@1.31.0
| +-- detect-indent@6.0.0
| +-- detect-newline@3.1.0
| +-- glob@7.1.6 deduped
| `-- sort-object-keys@1.1.3

+-- source-map-loader@0.2.4
| +-- async@2.6.3
| | `-- lodash@4.17.20 deduped
| `-- loader-utils@1.4.0 deduped

+-- style-loader@1.0.2
| +-- loader-utils@1.4.0 deduped
| `-- schema-utils@2.7.1 deduped

+-- svg-url-loader@3.0.3
| +-- file-loader@4.3.0
| | +-- loader-utils@1.4.0
| | | +-- big.js@5.2.2 deduped
| | | +-- emojis-list@3.0.0
| | | `-- json5@1.0.1 deduped
| | `-- schema-utils@2.7.1 deduped
| `-- loader-utils@1.2.3
|   +-- big.js@5.2.2 deduped
|   +-- emojis-list@2.1.0 deduped
|   `-- json5@1.0.1 deduped

+-- terser-webpack-plugin@2.3.8
| +-- cacache@13.0.1
| | +-- chownr@1.1.4
| | +-- figgy-pudding@3.5.2
| | +-- fs-minipass@2.1.0
| | | `-- minipass@3.1.3 deduped
| | +-- glob@7.1.6 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- infer-owner@1.0.4
| | +-- lru-cache@5.1.1
| | | `-- yallist@3.1.1
| | +-- minipass@3.1.3
| | | `-- yallist@4.0.0
| | +-- minipass-collect@1.0.2
| | | `-- minipass@3.1.3 deduped
| | +-- minipass-flush@1.0.5
| | | `-- minipass@3.1.3 deduped
| | +-- minipass-pipeline@1.2.4
| | | `-- minipass@3.1.3 deduped
| | +-- mkdirp@0.5.5 deduped
| | +-- move-concurrently@1.0.1
| | | +-- aproba@1.2.0
| | | +-- copy-concurrently@1.0.5
| | | | +-- aproba@1.2.0 deduped
| | | | +-- fs-write-stream-atomic@1.0.10 deduped
| | | | +-- iferr@0.1.5
| | | | +-- mkdirp@0.5.5 deduped
| | | | +-- rimraf@2.7.1
| | | | | `-- glob@7.1.6 deduped
| | | | `-- run-queue@1.0.3 deduped
| | | +-- fs-write-stream-atomic@1.0.10
| | | | +-- graceful-fs@4.2.4 deduped
| | | | +-- iferr@0.1.5 deduped
| | | | +-- imurmurhash@0.1.4
| | | | `-- readable-stream@2.3.7 deduped
| | | +-- mkdirp@0.5.5 deduped
| | | +-- rimraf@2.7.1
| | | | `-- glob@7.1.6 deduped
| | | `-- run-queue@1.0.3
| | |   `-- aproba@1.2.0 deduped
| | +-- p-map@3.0.0
| | | `-- aggregate-error@3.1.0
| | |   +-- clean-stack@2.2.0
| | |   `-- indent-string@4.0.0
| | +-- promise-inflight@1.0.1
| | +-- rimraf@2.7.1
| | | `-- glob@7.1.6 deduped
| | +-- ssri@7.1.0
| | | +-- figgy-pudding@3.5.2 deduped
| | | `-- minipass@3.1.3 deduped
| | `-- unique-filename@1.1.1
| |   `-- unique-slug@2.0.2
| |     `-- imurmurhash@0.1.4 deduped
| +-- find-cache-dir@3.3.1
| | +-- commondir@1.0.1
| | +-- make-dir@3.1.0
| | | `-- semver@6.3.0 deduped
| | `-- pkg-dir@4.2.0
| |   `-- find-up@4.1.0
| |     +-- locate-path@5.0.0
| |     | `-- p-locate@4.1.0
| |     |   `-- p-limit@2.3.0 deduped
| |     `-- path-exists@4.0.0
| +-- jest-worker@25.5.0
| | +-- merge-stream@2.0.0
| | `-- supports-color@7.2.0
| |   `-- has-flag@4.0.0
| +-- p-limit@2.3.0
| | `-- p-try@2.2.0
| +-- schema-utils@2.7.1 deduped
| +-- serialize-javascript@4.0.0
| | `-- randombytes@2.1.0
| |   `-- safe-buffer@5.1.2 deduped
| +-- source-map@0.6.1 deduped
| +-- terser@4.8.0
| | +-- commander@2.20.3 deduped
| | +-- source-map@0.6.1 deduped
| | `-- source-map-support@0.5.19
| |   +-- buffer-from@1.1.1
| |   `-- source-map@0.6.1 deduped
| `-- webpack-sources@1.4.3 deduped

+-- url-loader@3.0.0
| +-- loader-utils@1.4.0 deduped
| +-- mime@2.4.6
| `-- schema-utils@2.7.1 deduped

+-- webpack@4.44.2
| +-- @webassemblyjs/ast@1.9.0
| | +-- @webassemblyjs/helper-module-context@1.9.0 deduped
| | +-- @webassemblyjs/helper-wasm-bytecode@1.9.0
| | `-- @webassemblyjs/wast-parser@1.9.0
| |   +-- @webassemblyjs/ast@1.9.0 deduped
| |   +-- @webassemblyjs/floating-point-hex-parser@1.9.0
| |   +-- @webassemblyjs/helper-api-error@1.9.0 deduped
| |   +-- @webassemblyjs/helper-code-frame@1.9.0
| |   | `-- @webassemblyjs/wast-printer@1.9.0 deduped
| |   +-- @webassemblyjs/helper-fsm@1.9.0
| |   `-- @xtuc/long@4.2.2
| +-- @webassemblyjs/helper-module-context@1.9.0
| | `-- @webassemblyjs/ast@1.9.0 deduped
| +-- @webassemblyjs/wasm-edit@1.9.0
| | +-- @webassemblyjs/ast@1.9.0 deduped
| | +-- @webassemblyjs/helper-buffer@1.9.0
| | +-- @webassemblyjs/helper-wasm-bytecode@1.9.0 deduped
| | +-- @webassemblyjs/helper-wasm-section@1.9.0
| | | +-- @webassemblyjs/ast@1.9.0 deduped
| | | +-- @webassemblyjs/helper-buffer@1.9.0 deduped
| | | +-- @webassemblyjs/helper-wasm-bytecode@1.9.0 deduped
| | | `-- @webassemblyjs/wasm-gen@1.9.0 deduped
| | +-- @webassemblyjs/wasm-gen@1.9.0
| | | +-- @webassemblyjs/ast@1.9.0 deduped
| | | +-- @webassemblyjs/helper-wasm-bytecode@1.9.0 deduped
| | | +-- @webassemblyjs/ieee754@1.9.0 deduped
| | | +-- @webassemblyjs/leb128@1.9.0 deduped
| | | `-- @webassemblyjs/utf8@1.9.0 deduped
| | +-- @webassemblyjs/wasm-opt@1.9.0
| | | +-- @webassemblyjs/ast@1.9.0 deduped
| | | +-- @webassemblyjs/helper-buffer@1.9.0 deduped
| | | +-- @webassemblyjs/wasm-gen@1.9.0 deduped
| | | `-- @webassemblyjs/wasm-parser@1.9.0 deduped
| | +-- @webassemblyjs/wasm-parser@1.9.0 deduped
| | `-- @webassemblyjs/wast-printer@1.9.0
| |   +-- @webassemblyjs/ast@1.9.0 deduped
| |   +-- @webassemblyjs/wast-parser@1.9.0 deduped
| |   `-- @xtuc/long@4.2.2 deduped
| +-- @webassemblyjs/wasm-parser@1.9.0
| | +-- @webassemblyjs/ast@1.9.0 deduped
| | +-- @webassemblyjs/helper-api-error@1.9.0
| | +-- @webassemblyjs/helper-wasm-bytecode@1.9.0 deduped
| | +-- @webassemblyjs/ieee754@1.9.0
| | | `-- @xtuc/ieee754@1.2.0
| | +-- @webassemblyjs/leb128@1.9.0
| | | `-- @xtuc/long@4.2.2 deduped
| | `-- @webassemblyjs/utf8@1.9.0
| +-- acorn@6.4.2
| +-- ajv@6.12.6
| | +-- fast-deep-equal@3.1.3 deduped
| | +-- fast-json-stable-stringify@2.1.0 deduped
| | +-- json-schema-traverse@0.4.1
| | `-- uri-js@4.4.0
| |   `-- punycode@2.1.1
| +-- ajv-keywords@3.5.2
| +-- chrome-trace-event@1.0.2
| | `-- tslib@1.13.0
| +-- enhanced-resolve@4.3.0
| | +-- graceful-fs@4.2.4 deduped
| | +-- memory-fs@0.5.0
| | | +-- errno@0.1.7 deduped
| | | `-- readable-stream@2.3.7 deduped
| | `-- tapable@1.1.3 deduped
| +-- eslint-scope@4.0.3
| | +-- esrecurse@4.3.0
| | | `-- estraverse@5.2.0
| | `-- estraverse@4.3.0
| +-- json-parse-better-errors@1.0.2
| +-- loader-runner@2.4.0
| +-- loader-utils@1.4.0 deduped
| +-- memory-fs@0.4.1
| | +-- errno@0.1.7
| | | `-- prr@1.0.1
| | `-- readable-stream@2.3.7
| |   +-- core-util-is@1.0.2
| |   +-- inherits@2.0.4 deduped
| |   +-- isarray@1.0.0
| |   +-- process-nextick-args@2.0.1
| |   +-- safe-buffer@5.1.2 deduped
| |   +-- string_decoder@1.1.1 deduped
| |   `-- util-deprecate@1.0.2 deduped
| +-- micromatch@3.1.10
| | +-- arr-diff@4.0.0
| | +-- array-unique@0.3.2
| | +-- braces@2.3.2
| | | +-- arr-flatten@1.1.0
| | | +-- array-unique@0.3.2 deduped
| | | +-- extend-shallow@2.0.1
| | | | `-- is-extendable@0.1.1
| | | +-- fill-range@4.0.0
| | | | +-- extend-shallow@2.0.1 deduped
| | | | +-- is-number@3.0.0
| | | | | `-- kind-of@3.2.2
| | | | |   `-- is-buffer@1.1.6
| | | | +-- repeat-string@1.6.1
| | | | `-- to-regex-range@2.1.1
| | | |   +-- is-number@3.0.0 deduped
| | | |   `-- repeat-string@1.6.1 deduped
| | | +-- isobject@3.0.1
| | | +-- repeat-element@1.1.3
| | | +-- snapdragon@0.8.2 deduped
| | | +-- snapdragon-node@2.1.1
| | | | +-- define-property@1.0.0
| | | | | `-- is-descriptor@1.0.2 deduped
| | | | +-- isobject@3.0.1 deduped
| | | | `-- snapdragon-util@3.0.1
| | | |   `-- kind-of@3.2.2 deduped
| | | +-- split-string@3.1.0
| | | | `-- extend-shallow@3.0.2
| | | |   +-- assign-symbols@1.0.0 deduped
| | | |   `-- is-extendable@1.0.1
| | | |     `-- is-plain-object@2.0.4 deduped
| | | `-- to-regex@3.0.2 deduped
| | +-- define-property@2.0.2
| | | +-- is-descriptor@1.0.2
| | | | +-- is-accessor-descriptor@1.0.0
| | | | | `-- kind-of@6.0.3
| | | | +-- is-data-descriptor@1.0.0
| | | | | `-- kind-of@6.0.3
| | | | `-- kind-of@6.0.3
| | | `-- isobject@3.0.1 deduped
| | +-- extend-shallow@3.0.2
| | | +-- assign-symbols@1.0.0
| | | `-- is-extendable@1.0.1
| | |   `-- is-plain-object@2.0.4
| | |     `-- isobject@3.0.1 deduped
| | +-- extglob@2.0.4
| | | +-- array-unique@0.3.2 deduped
| | | +-- define-property@1.0.0
| | | | `-- is-descriptor@1.0.2 deduped
| | | +-- expand-brackets@2.1.4
| | | | +-- debug@2.6.9 deduped
| | | | +-- define-property@0.2.5 deduped
| | | | +-- extend-shallow@2.0.1 deduped
| | | | +-- posix-character-classes@0.1.1
| | | | +-- regex-not@1.0.2 deduped
| | | | +-- snapdragon@0.8.2 deduped
| | | | `-- to-regex@3.0.2 deduped
| | | +-- extend-shallow@2.0.1 deduped
| | | +-- fragment-cache@0.2.1 deduped
| | | +-- regex-not@1.0.2 deduped
| | | +-- snapdragon@0.8.2 deduped
| | | `-- to-regex@3.0.2 deduped
| | +-- fragment-cache@0.2.1
| | | `-- map-cache@0.2.2
| | +-- kind-of@6.0.3
| | +-- nanomatch@1.2.13
| | | +-- arr-diff@4.0.0 deduped
| | | +-- array-unique@0.3.2 deduped
| | | +-- define-property@2.0.2
| | | | +-- is-descriptor@1.0.2 deduped
| | | | `-- isobject@3.0.1 deduped
| | | +-- extend-shallow@3.0.2
| | | | +-- assign-symbols@1.0.0 deduped
| | | | `-- is-extendable@1.0.1
| | | |   `-- is-plain-object@2.0.4 deduped
| | | +-- fragment-cache@0.2.1 deduped
| | | +-- is-windows@1.0.2
| | | +-- kind-of@6.0.3
| | | +-- object.pick@1.3.0 deduped
| | | +-- regex-not@1.0.2 deduped
| | | +-- snapdragon@0.8.2 deduped
| | | `-- to-regex@3.0.2 deduped
| | +-- object.pick@1.3.0
| | | `-- isobject@3.0.1 deduped
| | +-- regex-not@1.0.2
| | | +-- extend-shallow@3.0.2
| | | | +-- assign-symbols@1.0.0 deduped
| | | | `-- is-extendable@1.0.1
| | | |   `-- is-plain-object@2.0.4 deduped
| | | `-- safe-regex@1.1.0
| | |   `-- ret@0.1.15
| | +-- snapdragon@0.8.2
| | | +-- base@0.11.2
| | | | +-- cache-base@1.0.1
| | | | | +-- collection-visit@1.0.0
| | | | | | +-- map-visit@1.0.0
| | | | | | | `-- object-visit@1.0.1 deduped
| | | | | | `-- object-visit@1.0.1
| | | | | |   `-- isobject@3.0.1 deduped
| | | | | +-- component-emitter@1.3.0 deduped
| | | | | +-- get-value@2.0.6
| | | | | +-- has-value@1.0.0
| | | | | | +-- get-value@2.0.6 deduped
| | | | | | +-- has-values@1.0.0
| | | | | | | +-- is-number@3.0.0 deduped
| | | | | | | `-- kind-of@4.0.0
| | | | | | |   `-- is-buffer@1.1.6 deduped
| | | | | | `-- isobject@3.0.1 deduped
| | | | | +-- isobject@3.0.1 deduped
| | | | | +-- set-value@2.0.1
| | | | | | +-- extend-shallow@2.0.1 deduped
| | | | | | +-- is-extendable@0.1.1 deduped
| | | | | | +-- is-plain-object@2.0.4 deduped
| | | | | | `-- split-string@3.1.0 deduped
| | | | | +-- to-object-path@0.3.0
| | | | | | `-- kind-of@3.2.2 deduped
| | | | | +-- union-value@1.0.1
| | | | | | +-- arr-union@3.1.0 deduped
| | | | | | +-- get-value@2.0.6 deduped
| | | | | | +-- is-extendable@0.1.1 deduped
| | | | | | `-- set-value@2.0.1 deduped
| | | | | `-- unset-value@1.0.0
| | | | |   +-- has-value@0.3.1
| | | | |   | +-- get-value@2.0.6 deduped
| | | | |   | +-- has-values@0.1.4
| | | | |   | `-- isobject@2.1.0
| | | | |   |   `-- isarray@1.0.0 deduped
| | | | |   `-- isobject@3.0.1 deduped
| | | | +-- class-utils@0.3.6
| | | | | +-- arr-union@3.1.0
| | | | | +-- define-property@0.2.5 deduped
| | | | | +-- isobject@3.0.1 deduped
| | | | | `-- static-extend@0.1.2
| | | | |   +-- define-property@0.2.5 deduped
| | | | |   `-- object-copy@0.1.0
| | | | |     +-- copy-descriptor@0.1.1
| | | | |     +-- define-property@0.2.5 deduped
| | | | |     `-- kind-of@3.2.2 deduped
| | | | +-- component-emitter@1.3.0
| | | | +-- define-property@1.0.0
| | | | | `-- is-descriptor@1.0.2 deduped
| | | | +-- isobject@3.0.1 deduped
| | | | +-- mixin-deep@1.3.2
| | | | | +-- for-in@1.0.2
| | | | | `-- is-extendable@1.0.1
| | | | |   `-- is-plain-object@2.0.4 deduped
| | | | `-- pascalcase@0.1.1
| | | +-- debug@2.6.9 deduped
| | | +-- define-property@0.2.5
| | | | `-- is-descriptor@0.1.6
| | | |   +-- is-accessor-descriptor@0.1.6
| | | |   | `-- kind-of@3.2.2
| | | |   |   `-- is-buffer@1.1.6 deduped
| | | |   +-- is-data-descriptor@0.1.4
| | | |   | `-- kind-of@3.2.2
| | | |   |   `-- is-buffer@1.1.6 deduped
| | | |   `-- kind-of@5.1.0
| | | +-- extend-shallow@2.0.1 deduped
| | | +-- map-cache@0.2.2 deduped
| | | +-- source-map@0.5.7
| | | +-- source-map-resolve@0.5.3
| | | | +-- atob@2.1.2
| | | | +-- decode-uri-component@0.2.0
| | | | +-- resolve-url@0.2.1
| | | | +-- source-map-url@0.4.0
| | | | `-- urix@0.1.0
| | | `-- use@3.1.1
| | `-- to-regex@3.0.2
| |   +-- define-property@2.0.2
| |   | +-- is-descriptor@1.0.2 deduped
| |   | `-- isobject@3.0.1 deduped
| |   +-- extend-shallow@3.0.2
| |   | +-- assign-symbols@1.0.0 deduped
| |   | `-- is-extendable@1.0.1
| |   |   `-- is-plain-object@2.0.4 deduped
| |   +-- regex-not@1.0.2 deduped
| |   `-- safe-regex@1.1.0 deduped
| +-- mkdirp@0.5.5
| | `-- minimist@1.2.5 deduped
| +-- neo-async@2.6.2 deduped
| +-- node-libs-browser@2.2.1
| | +-- assert@1.5.0
| | | +-- object-assign@4.1.1 deduped
| | | `-- util@0.10.3 deduped
| | +-- browserify-zlib@0.2.0
| | | `-- pako@1.0.11
| | +-- buffer@4.9.2
| | | +-- base64-js@1.3.1
| | | +-- ieee754@1.1.13
| | | `-- isarray@1.0.0 deduped
| | +-- console-browserify@1.2.0
| | +-- constants-browserify@1.0.0
| | +-- crypto-browserify@3.12.0
| | | +-- browserify-cipher@1.0.1
| | | | +-- browserify-aes@1.2.0
| | | | | +-- buffer-xor@1.0.3
| | | | | +-- cipher-base@1.0.4 deduped
| | | | | +-- create-hash@1.2.0 deduped
| | | | | +-- evp_bytestokey@1.0.3 deduped
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | +-- browserify-des@1.0.2
| | | | | +-- cipher-base@1.0.4 deduped
| | | | | +-- des.js@1.0.1
| | | | | | +-- inherits@2.0.4 deduped
| | | | | | `-- minimalistic-assert@1.0.1 deduped
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | `-- evp_bytestokey@1.0.3
| | | |   +-- md5.js@1.3.5 deduped
| | | |   `-- safe-buffer@5.1.2 deduped
| | | +-- browserify-sign@4.2.1
| | | | +-- bn.js@5.1.3
| | | | +-- browserify-rsa@4.0.1
| | | | | +-- bn.js@4.11.9 deduped
| | | | | `-- randombytes@2.1.0 deduped
| | | | +-- create-hash@1.2.0 deduped
| | | | +-- create-hmac@1.1.7 deduped
| | | | +-- elliptic@6.5.3
| | | | | +-- bn.js@4.11.9 deduped
| | | | | +-- brorand@1.1.0
| | | | | +-- hash.js@1.1.7
| | | | | | +-- inherits@2.0.4 deduped
| | | | | | `-- minimalistic-assert@1.0.1 deduped
| | | | | +-- hmac-drbg@1.0.1
| | | | | | +-- hash.js@1.1.7 deduped
| | | | | | +-- minimalistic-assert@1.0.1 deduped
| | | | | | `-- minimalistic-crypto-utils@1.0.1 deduped
| | | | | +-- inherits@2.0.4 deduped
| | | | | +-- minimalistic-assert@1.0.1
| | | | | `-- minimalistic-crypto-utils@1.0.1
| | | | +-- inherits@2.0.4 deduped
| | | | +-- parse-asn1@5.1.6
| | | | | +-- asn1.js@5.4.1
| | | | | | +-- bn.js@4.11.9 deduped
| | | | | | +-- inherits@2.0.4 deduped
| | | | | | +-- minimalistic-assert@1.0.1 deduped
| | | | | | `-- safer-buffer@2.1.2 deduped
| | | | | +-- browserify-aes@1.2.0 deduped
| | | | | +-- evp_bytestokey@1.0.3 deduped
| | | | | +-- pbkdf2@3.1.1 deduped
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | +-- readable-stream@3.6.0
| | | | | +-- inherits@2.0.4 deduped
| | | | | +-- string_decoder@1.1.1 deduped
| | | | | `-- util-deprecate@1.0.2 deduped
| | | | `-- safe-buffer@5.2.1
| | | +-- create-ecdh@4.0.4
| | | | +-- bn.js@4.11.9
| | | | `-- elliptic@6.5.3 deduped
| | | +-- create-hash@1.2.0
| | | | +-- cipher-base@1.0.4
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | +-- inherits@2.0.4 deduped
| | | | +-- md5.js@1.3.5
| | | | | +-- hash-base@3.1.0
| | | | | | +-- inherits@2.0.4 deduped
| | | | | | +-- readable-stream@3.6.0
| | | | | | | +-- inherits@2.0.4 deduped
| | | | | | | +-- string_decoder@1.1.1 deduped
| | | | | | | `-- util-deprecate@1.0.2 deduped
| | | | | | `-- safe-buffer@5.2.1
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- safe-buffer@5.1.2 deduped
| | | | +-- ripemd160@2.0.2
| | | | | +-- hash-base@3.1.0 deduped
| | | | | `-- inherits@2.0.4 deduped
| | | | `-- sha.js@2.4.11
| | | |   +-- inherits@2.0.4 deduped
| | | |   `-- safe-buffer@5.1.2 deduped
| | | +-- create-hmac@1.1.7
| | | | +-- cipher-base@1.0.4 deduped
| | | | +-- create-hash@1.2.0 deduped
| | | | +-- inherits@2.0.4 deduped
| | | | +-- ripemd160@2.0.2 deduped
| | | | +-- safe-buffer@5.1.2 deduped
| | | | `-- sha.js@2.4.11 deduped
| | | +-- diffie-hellman@5.0.3
| | | | +-- bn.js@4.11.9 deduped
| | | | +-- miller-rabin@4.0.1
| | | | | +-- bn.js@4.11.9 deduped
| | | | | `-- brorand@1.1.0 deduped
| | | | `-- randombytes@2.1.0 deduped
| | | +-- inherits@2.0.4 deduped
| | | +-- pbkdf2@3.1.1
| | | | +-- create-hash@1.2.0 deduped
| | | | +-- create-hmac@1.1.7 deduped
| | | | +-- ripemd160@2.0.2 deduped
| | | | +-- safe-buffer@5.1.2 deduped
| | | | `-- sha.js@2.4.11 deduped
| | | +-- public-encrypt@4.0.3
| | | | +-- bn.js@4.11.9 deduped
| | | | +-- browserify-rsa@4.0.1 deduped
| | | | +-- create-hash@1.2.0 deduped
| | | | +-- parse-asn1@5.1.6 deduped
| | | | +-- randombytes@2.1.0 deduped
| | | | `-- safe-buffer@5.1.2 deduped
| | | +-- randombytes@2.1.0 deduped
| | | `-- randomfill@1.0.4
| | |   +-- randombytes@2.1.0 deduped
| | |   `-- safe-buffer@5.1.2 deduped
| | +-- domain-browser@1.2.0
| | +-- events@3.2.0
| | +-- https-browserify@1.0.0
| | +-- os-browserify@0.3.0
| | +-- path-browserify@0.0.1
| | +-- process@0.11.10 deduped
| | +-- punycode@1.3.2
| | +-- querystring-es3@0.2.1
| | +-- readable-stream@2.3.7 deduped
| | +-- stream-browserify@2.0.2
| | | +-- inherits@2.0.4 deduped
| | | `-- readable-stream@2.3.7 deduped
| | +-- stream-http@2.8.3
| | | +-- builtin-status-codes@3.0.0
| | | +-- inherits@2.0.4 deduped
| | | +-- readable-stream@2.3.7 deduped
| | | +-- to-arraybuffer@1.0.1
| | | `-- xtend@4.0.2 deduped
| | +-- string_decoder@1.1.1
| | | `-- safe-buffer@5.1.2 deduped
| | +-- timers-browserify@2.0.11
| | | `-- setimmediate@1.0.5
| | +-- tty-browserify@0.0.0
| | +-- url@0.11.0
| | | +-- punycode@1.3.2 deduped
| | | `-- querystring@0.2.0
| | +-- util@0.11.1
| | | `-- inherits@2.0.3
| | `-- vm-browserify@1.1.2
| +-- schema-utils@1.0.0
| | +-- ajv@6.12.6 deduped
| | +-- ajv-errors@1.0.1 deduped
| | `-- ajv-keywords@3.5.2 deduped
| +-- tapable@1.1.3 deduped
| +-- terser-webpack-plugin@1.4.5
| | +-- cacache@12.0.4
| | | +-- bluebird@3.7.2 deduped
| | | +-- chownr@1.1.4 deduped
| | | +-- figgy-pudding@3.5.2 deduped
| | | +-- glob@7.1.6 deduped
| | | +-- graceful-fs@4.2.4 deduped
| | | +-- infer-owner@1.0.4 deduped
| | | +-- lru-cache@5.1.1 deduped
| | | +-- mississippi@3.0.0
| | | | +-- concat-stream@1.6.2
| | | | | +-- buffer-from@1.1.1 deduped
| | | | | +-- inherits@2.0.4 deduped
| | | | | +-- readable-stream@2.3.7 deduped
| | | | | `-- typedarray@0.0.6
| | | | +-- duplexify@3.7.1
| | | | | +-- end-of-stream@1.4.4 deduped
| | | | | +-- inherits@2.0.4 deduped
| | | | | +-- readable-stream@2.3.7 deduped
| | | | | `-- stream-shift@1.0.1
| | | | +-- end-of-stream@1.4.4
| | | | | `-- once@1.4.0 deduped
| | | | +-- flush-write-stream@1.1.1
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- readable-stream@2.3.7 deduped
| | | | +-- from2@2.3.0
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- readable-stream@2.3.7 deduped
| | | | +-- parallel-transform@1.2.0
| | | | | +-- cyclist@1.0.1
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- readable-stream@2.3.7 deduped
| | | | +-- pump@3.0.0 deduped
| | | | +-- pumpify@1.5.1
| | | | | +-- duplexify@3.7.1 deduped
| | | | | +-- inherits@2.0.4 deduped
| | | | | `-- pump@2.0.1
| | | | |   +-- end-of-stream@1.4.4 deduped
| | | | |   `-- once@1.4.0 deduped
| | | | +-- stream-each@1.2.3
| | | | | +-- end-of-stream@1.4.4 deduped
| | | | | `-- stream-shift@1.0.1 deduped
| | | | `-- through2@2.0.5
| | | |   +-- readable-stream@2.3.7 deduped
| | | |   `-- xtend@4.0.2 deduped
| | | +-- mkdirp@0.5.5 deduped
| | | +-- move-concurrently@1.0.1 deduped
| | | +-- promise-inflight@1.0.1 deduped
| | | +-- rimraf@2.7.1
| | | | `-- glob@7.1.6 deduped
| | | +-- ssri@6.0.1
| | | | `-- figgy-pudding@3.5.2 deduped
| | | +-- unique-filename@1.1.1 deduped
| | | `-- y18n@4.0.0 deduped
| | +-- find-cache-dir@2.1.0
| | | +-- commondir@1.0.1 deduped
| | | +-- make-dir@2.1.0
| | | | +-- pify@4.0.1 deduped
| | | | `-- semver@5.7.1
| | | `-- pkg-dir@3.0.0 deduped
| | +-- is-wsl@1.1.0
| | +-- schema-utils@1.0.0 deduped
| | +-- serialize-javascript@4.0.0 deduped
| | +-- source-map@0.6.1 deduped
| | +-- terser@4.8.0 deduped
| | +-- webpack-sources@1.4.3 deduped
| | `-- worker-farm@1.7.0
| |   `-- errno@0.1.7 deduped
| +-- watchpack@1.7.4
| | +-- chokidar@3.4.3 deduped
| | +-- graceful-fs@4.2.4 deduped
| | +-- neo-async@2.6.2 deduped
| | `-- UNMET OPTIONAL DEPENDENCY watchpack-chokidar2@^2.0.0
| `-- webpack-sources@1.4.3 deduped

+-- webpack-bundle-analyzer@3.9.0
| +-- acorn@7.4.1
| +-- acorn-walk@7.2.0
| +-- bfj@6.1.2
| | +-- bluebird@3.7.2
| | +-- check-types@8.0.3
| | +-- hoopy@0.1.4
| | `-- tryer@1.0.1
| +-- chalk@2.4.2 deduped
| +-- commander@2.20.3
| +-- ejs@2.7.4
| +-- express@4.17.1
| | +-- accepts@1.3.7
| | | +-- mime-types@2.1.27
| | | | `-- mime-db@1.44.0
| | | `-- negotiator@0.6.2
| | +-- array-flatten@1.1.1
| | +-- body-parser@1.19.0
| | | +-- bytes@3.1.0
| | | +-- content-type@1.0.4 deduped
| | | +-- debug@2.6.9 deduped
| | | +-- depd@1.1.2 deduped
| | | +-- http-errors@1.7.2
| | | | +-- depd@1.1.2 deduped
| | | | +-- inherits@2.0.3
| | | | +-- setprototypeof@1.1.1 deduped
| | | | +-- statuses@1.5.0 deduped
| | | | `-- toidentifier@1.0.0
| | | +-- iconv-lite@0.4.24 deduped
| | | +-- on-finished@2.3.0 deduped
| | | +-- qs@6.7.0 deduped
| | | +-- raw-body@2.4.0
| | | | +-- bytes@3.1.0 deduped
| | | | +-- http-errors@1.7.2 deduped
| | | | +-- iconv-lite@0.4.24 deduped
| | | | `-- unpipe@1.0.0 deduped
| | | `-- type-is@1.6.18 deduped
| | +-- content-disposition@0.5.3
| | | `-- safe-buffer@5.1.2 deduped
| | +-- content-type@1.0.4
| | +-- cookie@0.4.0
| | +-- cookie-signature@1.0.6
| | +-- debug@2.6.9
| | | `-- ms@2.0.0
| | +-- depd@1.1.2
| | +-- encodeurl@1.0.2
| | +-- escape-html@1.0.3
| | +-- etag@1.8.1
| | +-- finalhandler@1.1.2
| | | +-- debug@2.6.9 deduped
| | | +-- encodeurl@1.0.2 deduped
| | | +-- escape-html@1.0.3 deduped
| | | +-- on-finished@2.3.0 deduped
| | | +-- parseurl@1.3.3 deduped
| | | +-- statuses@1.5.0 deduped
| | | `-- unpipe@1.0.0
| | +-- fresh@0.5.2
| | +-- merge-descriptors@1.0.1
| | +-- methods@1.1.2
| | +-- on-finished@2.3.0
| | | `-- ee-first@1.1.1
| | +-- parseurl@1.3.3
| | +-- path-to-regexp@0.1.7
| | +-- proxy-addr@2.0.6
| | | +-- forwarded@0.1.2
| | | `-- ipaddr.js@1.9.1
| | +-- qs@6.7.0
| | +-- range-parser@1.2.1
| | +-- safe-buffer@5.1.2
| | +-- send@0.17.1
| | | +-- debug@2.6.9 deduped
| | | +-- depd@1.1.2 deduped
| | | +-- destroy@1.0.4
| | | +-- encodeurl@1.0.2 deduped
| | | +-- escape-html@1.0.3 deduped
| | | +-- etag@1.8.1 deduped
| | | +-- fresh@0.5.2 deduped
| | | +-- http-errors@1.7.2 deduped
| | | +-- mime@1.6.0
| | | +-- ms@2.1.1
| | | +-- on-finished@2.3.0 deduped
| | | +-- range-parser@1.2.1 deduped
| | | `-- statuses@1.5.0 deduped
| | +-- serve-static@1.14.1
| | | +-- encodeurl@1.0.2 deduped
| | | +-- escape-html@1.0.3 deduped
| | | +-- parseurl@1.3.3 deduped
| | | `-- send@0.17.1 deduped
| | +-- setprototypeof@1.1.1
| | +-- statuses@1.5.0
| | +-- type-is@1.6.18
| | | +-- media-typer@0.3.0
| | | `-- mime-types@2.1.27 deduped
| | +-- utils-merge@1.0.1
| | `-- vary@1.1.2
| +-- filesize@3.6.1
| +-- gzip-size@5.1.1
| | +-- duplexer@0.1.2
| | `-- pify@4.0.1
| +-- lodash@4.17.20 deduped
| +-- mkdirp@0.5.5 deduped
| +-- opener@1.5.2
| `-- ws@6.2.1
|   `-- async-limiter@1.0.1

+-- webpack-cli@3.3.12
| +-- chalk@2.4.2 deduped
| +-- cross-spawn@6.0.5
| | +-- nice-try@1.0.5
| | +-- path-key@2.0.1
| | +-- semver@5.7.1
| | +-- shebang-command@1.2.0
| | | `-- shebang-regex@1.0.0
| | `-- which@1.3.1
| |   `-- isexe@2.0.0 deduped
| +-- enhanced-resolve@4.3.0 deduped
| +-- findup-sync@3.0.0
| | +-- detect-file@1.0.0
| | +-- is-glob@4.0.1 deduped
| | +-- micromatch@3.1.10 deduped
| | `-- resolve-dir@1.0.1
| |   +-- expand-tilde@2.0.2
| |   | `-- homedir-polyfill@1.0.3
| |   |   `-- parse-passwd@1.0.0
| |   `-- global-modules@1.0.0
| |     +-- global-prefix@1.0.2
| |     | +-- expand-tilde@2.0.2 deduped
| |     | +-- homedir-polyfill@1.0.3 deduped
| |     | +-- ini@1.3.5 deduped
| |     | +-- is-windows@1.0.2 deduped
| |     | `-- which@1.3.1 deduped
| |     +-- is-windows@1.0.2 deduped
| |     `-- resolve-dir@1.0.1 deduped
| +-- global-modules@2.0.0
| | `-- global-prefix@3.0.0
| |   +-- ini@1.3.5
| |   +-- kind-of@6.0.3
| |   `-- which@1.3.1 deduped
| +-- import-local@2.0.0
| | +-- pkg-dir@3.0.0
| | | `-- find-up@3.0.0 deduped
| | `-- resolve-cwd@2.0.0
| |   `-- resolve-from@3.0.0
| +-- interpret@1.4.0
| +-- loader-utils@1.4.0 deduped
| +-- supports-color@6.1.0
| | `-- has-flag@3.0.0
| +-- v8-compile-cache@2.1.1
| `-- yargs@13.3.2
|   +-- cliui@5.0.0
|   | +-- string-width@3.1.0
|   | | +-- emoji-regex@7.0.3
|   | | +-- is-fullwidth-code-point@2.0.0
|   | | `-- strip-ansi@5.2.0 deduped
|   | +-- strip-ansi@5.2.0
|   | | `-- ansi-regex@4.1.0
|   | `-- wrap-ansi@5.1.0
|   |   +-- ansi-styles@3.2.1 deduped
|   |   +-- string-width@3.1.0
|   |   | +-- emoji-regex@7.0.3
|   |   | +-- is-fullwidth-code-point@2.0.0
|   |   | `-- strip-ansi@5.2.0 deduped
|   |   `-- strip-ansi@5.2.0
|   |     `-- ansi-regex@4.1.0
|   +-- find-up@3.0.0
|   | `-- locate-path@3.0.0
|   |   +-- p-locate@3.0.0
|   |   | `-- p-limit@2.3.0 deduped
|   |   `-- path-exists@3.0.0
|   +-- get-caller-file@2.0.5
|   +-- require-directory@2.1.1
|   +-- require-main-filename@2.0.0
|   +-- set-blocking@2.0.0
|   +-- string-width@3.1.0
|   | +-- emoji-regex@7.0.3
|   | +-- is-fullwidth-code-point@2.0.0
|   | `-- strip-ansi@5.2.0
|   |   `-- ansi-regex@4.1.0
|   +-- which-module@2.0.0
|   +-- y18n@4.0.0
|   `-- yargs-parser@13.1.2
|     +-- camelcase@5.3.1 deduped
|     `-- decamelize@1.2.0

+-- webpack-merge@4.2.2
| `-- lodash@4.17.20 deduped

+-- whatwg-fetch@3.4.1

+-- worker-loader@2.0.0
| +-- loader-utils@1.4.0 deduped
| `-- schema-utils@0.4.7
|   +-- ajv@6.12.6 deduped
|   `-- ajv-keywords@3.5.2 deduped
`-- yarn-deduplicate@1.2.0
  +-- @yarnpkg/lockfile@1.1.0 deduped
  +-- commander@4.1.1
  `-- semver@7.1.3

npm ERR! invalid: @jupyterlab/toc@4.0.0 C:\Users\edreamleo\Python\Python37\share\jupyter\lab\staging\node_modules\@jupyterlab\toc</t>
<t tx="ekr.20201114160816.15">+-- @jupyterlab/application@2.2.6
| +-- @fortawesome/fontawesome-free@5.15.1
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/rendermime-interfaces@2.2.1
| | +-- @lumino/coreutils@1.5.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/services@5.2.5
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/settingregistry@2.2.5 deduped
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- node-fetch@2.6.1
| | `-- ws@7.3.1
| +-- @jupyterlab/statedb@2.2.5
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/properties@1.2.3 deduped
| | `-- @lumino/signaling@1.4.3 deduped
| +-- @jupyterlab/ui-components@2.2.4
| | +-- @blueprintjs/core@3.35.0
| | | +-- @blueprintjs/icons@3.22.0
| | | | +-- classnames@2.2.6 deduped
| | | | `-- tslib@1.13.0 deduped
| | | +-- @types/dom4@2.0.1
| | | +-- classnames@2.2.6
| | | +-- dom4@2.1.5
| | | +-- normalize.css@8.0.1
| | | +-- popper.js@1.16.1
| | | +-- react-lifecycles-compat@3.0.4
| | | +-- react-popper@1.3.7
| | | | +-- @babel/runtime@7.12.1
| | | | | `-- regenerator-runtime@0.13.7
| | | | +-- create-react-context@0.3.0
| | | | | +-- gud@1.0.0
| | | | | `-- warning@4.0.3 deduped
| | | | +-- deep-equal@1.1.1
| | | | | +-- is-arguments@1.0.4
| | | | | +-- is-date-object@1.0.2
| | | | | +-- is-regex@1.1.1 deduped
| | | | | +-- object-is@1.1.3
| | | | | | +-- define-properties@1.1.3 deduped
| | | | | | `-- es-abstract@1.18.0-next.1
| | | | | |   +-- es-to-primitive@1.2.1 deduped
| | | | | |   +-- function-bind@1.1.1 deduped
| | | | | |   +-- has@1.0.3 deduped
| | | | | |   +-- has-symbols@1.0.1 deduped
| | | | | |   +-- is-callable@1.2.2 deduped
| | | | | |   +-- is-negative-zero@2.0.0 deduped
| | | | | |   +-- is-regex@1.1.1 deduped
| | | | | |   +-- object-inspect@1.8.0 deduped
| | | | | |   +-- object-keys@1.1.1 deduped
| | | | | |   +-- object.assign@4.1.1 deduped
| | | | | |   +-- string.prototype.trimend@1.0.2 deduped
| | | | | |   `-- string.prototype.trimstart@1.0.2 deduped
| | | | | +-- object-keys@1.1.1 deduped
| | | | | `-- regexp.prototype.flags@1.3.0
| | | | |   +-- define-properties@1.1.3 deduped
| | | | |   `-- es-abstract@1.17.7 deduped
| | | | +-- popper.js@1.16.1 deduped
| | | | +-- prop-types@15.7.2 deduped
| | | | +-- typed-styles@0.0.7
| | | | `-- warning@4.0.3
| | | |   `-- loose-envify@1.4.0 deduped
| | | +-- react-transition-group@2.9.0
| | | | +-- dom-helpers@3.4.0
| | | | | `-- @babel/runtime@7.12.1 deduped
| | | | +-- loose-envify@1.4.0 deduped
| | | | +-- prop-types@15.7.2 deduped
| | | | `-- react-lifecycles-compat@3.0.4 deduped
| | | +-- resize-observer-polyfill@1.5.1
| | | `-- tslib@1.13.0 deduped
| | +-- @blueprintjs/select@3.14.3
| | | +-- @blueprintjs/core@3.35.0 deduped
| | | +-- classnames@2.2.6 deduped
| | | `-- tslib@1.13.0 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/virtualdom@1.7.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- react@16.9.0 deduped
| | +-- react-dom@16.9.0 deduped
| | `-- typestyle@2.1.0
| |   +-- csstype@2.6.9 deduped
| |   `-- free-style@3.1.0
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/application@1.11.0
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @lumino/commands@1.11.3
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/keyboard@1.2.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/virtualdom@1.7.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3
| | +-- @lumino/algorithm@1.3.3 deduped
| | `-- @lumino/signaling@1.4.3 deduped
| +-- @lumino/messaging@1.4.3 deduped
| +-- @lumino/polling@1.3.3
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | `-- @lumino/signaling@1.4.3 deduped
| +-- @lumino/properties@1.2.3
| +-- @lumino/signaling@1.4.3
| | `-- @lumino/algorithm@1.3.3 deduped
| `-- @lumino/widgets@1.14.0 deduped

+-- @jupyterlab/application-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/property-inspector@2.2.6
| | +-- @jupyterlab/application@2.2.6 deduped
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/settingregistry@2.2.5
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- ajv@6.12.6 deduped
| | `-- json5@2.1.3
| |   `-- minimist@1.2.5 deduped
| +-- @jupyterlab/statedb@2.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| +-- @lumino/widgets@1.14.0 deduped
| `-- react@16.9.0 deduped

+-- @jupyterlab/apputils-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/mainmenu@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statedb@2.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/commands@1.11.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| +-- @lumino/polling@1.3.3 deduped
| +-- @lumino/widgets@1.14.0 deduped
| `-- es6-promise@4.2.8

+-- @jupyterlab/buildutils@2.2.3
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @yarnpkg/lockfile@1.1.0
| +-- child_process@1.0.2
| +-- commander@4.0.1
| +-- crypto@1.0.1
| +-- dependency-graph@0.8.1
| +-- duplicate-package-checker-webpack-plugin@3.0.0 deduped
| +-- fs-extra@8.1.0 deduped
| +-- glob@7.1.6 deduped
| +-- inquirer@7.3.3
| | +-- ansi-escapes@4.3.1
| | | `-- type-fest@0.11.0
| | +-- chalk@4.1.0
| | | +-- ansi-styles@4.3.0
| | | | `-- color-convert@2.0.1
| | | |   `-- color-name@1.1.4
| | | `-- supports-color@7.2.0
| | |   `-- has-flag@4.0.0
| | +-- cli-cursor@3.1.0
| | | `-- restore-cursor@3.1.0
| | |   +-- onetime@5.1.2
| | |   | `-- mimic-fn@2.1.0
| | |   `-- signal-exit@3.0.3
| | +-- cli-width@3.0.0
| | +-- external-editor@3.1.0
| | | +-- chardet@0.7.0
| | | +-- iconv-lite@0.4.24
| | | | `-- safer-buffer@2.1.2
| | | `-- tmp@0.0.33
| | |   `-- os-tmpdir@1.0.2
| | +-- figures@3.2.0
| | | `-- escape-string-regexp@1.0.5 deduped
| | +-- lodash@4.17.20 deduped
| | +-- mute-stream@0.0.8
| | +-- run-async@2.4.1
| | +-- rxjs@6.6.3
| | | `-- tslib@1.13.0 deduped
| | +-- string-width@4.2.0
| | | +-- emoji-regex@8.0.0
| | | +-- is-fullwidth-code-point@3.0.0
| | | `-- strip-ansi@6.0.0 deduped
| | +-- strip-ansi@6.0.0
| | | `-- ansi-regex@5.0.0
| | `-- through@2.3.8
| +-- mini-css-extract-plugin@0.8.2 deduped
| +-- package-json@6.5.0
| | +-- got@9.6.0
| | | +-- @sindresorhus/is@0.14.0
| | | +-- @szmarczak/http-timer@1.1.2
| | | | `-- defer-to-connect@1.1.3
| | | +-- cacheable-request@6.1.0
| | | | +-- clone-response@1.0.2
| | | | | `-- mimic-response@1.0.1 deduped
| | | | +-- get-stream@5.2.0
| | | | | `-- pump@3.0.0 deduped
| | | | +-- http-cache-semantics@4.1.0
| | | | +-- keyv@3.1.0
| | | | | `-- json-buffer@3.0.0
| | | | +-- lowercase-keys@2.0.0
| | | | +-- normalize-url@4.5.0
| | | | `-- responselike@1.0.2
| | | |   `-- lowercase-keys@1.0.1 deduped
| | | +-- decompress-response@3.3.0
| | | | `-- mimic-response@1.0.1 deduped
| | | +-- duplexer3@0.1.4
| | | +-- get-stream@4.1.0
| | | | `-- pump@3.0.0
| | | |   +-- end-of-stream@1.4.4 deduped
| | | |   `-- once@1.4.0 deduped
| | | +-- lowercase-keys@1.0.1
| | | +-- mimic-response@1.0.1
| | | +-- p-cancelable@1.1.0
| | | +-- to-readable-stream@1.0.0
| | | `-- url-parse-lax@3.0.0
| | |   `-- prepend-http@2.0.0
| | +-- registry-auth-token@4.2.0
| | | `-- rc@1.2.8
| | |   +-- deep-extend@0.6.0
| | |   +-- ini@1.3.5 deduped
| | |   +-- minimist@1.2.5 deduped
| | |   `-- strip-json-comments@2.0.1
| | +-- registry-url@5.1.0
| | | `-- rc@1.2.8 deduped
| | `-- semver@6.3.0 deduped
| +-- path@0.12.7
| | +-- process@0.11.10
| | `-- util@0.10.3
| |   `-- inherits@2.0.1
| +-- prettier@1.19.1
| +-- semver@6.3.0
| +-- sort-package-json@1.31.0 deduped
| +-- typescript@3.7.5
| +-- webpack@4.44.2 deduped
| `-- which@2.0.2
|   `-- isexe@2.0.0</t>
<t tx="ekr.20201114160816.16">+-- @jupyterlab/celltags-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/celltags@2.2.7
| | +-- @jupyterlab/application@2.2.6 deduped
| | +-- @jupyterlab/cells@2.2.7 deduped
| | +-- @jupyterlab/notebook@2.2.7 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| `-- @jupyterlab/notebook@2.2.7 deduped</t>
<t tx="ekr.20201114160816.17">+-- @jupyterlab/codemirror-extension@2.2.6
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/codeeditor@2.2.5
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/dragdrop@1.6.4 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/codemirror@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/statusbar@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- codemirror@5.53.2 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/fileeditor@2.2.4 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/statusbar@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- csstype@2.6.9
| | +-- react@16.9.0 deduped
| | `-- typestyle@2.1.0 deduped
| +-- @lumino/widgets@1.14.0 deduped
| `-- codemirror@5.53.2</t>
<t tx="ekr.20201114160816.18">+-- @jupyterlab/completer-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/completer@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/console@2.2.7
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/cells@2.2.7 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/nbformat@2.2.5 deduped
| | +-- @jupyterlab/observables@3.2.5 deduped
| | +-- @jupyterlab/rendermime@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/dragdrop@1.6.4 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/fileeditor@2.2.4 deduped
| +-- @jupyterlab/notebook@2.2.7 deduped
| +-- @jupyterlab/services@5.2.5 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| `-- @lumino/widgets@1.14.0 deduped</t>
<t tx="ekr.20201114160816.19">+-- @jupyterlab/console-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/codeeditor@2.2.5 deduped
| +-- @jupyterlab/console@2.2.7 deduped
| +-- @jupyterlab/coreutils@4.2.5 deduped
| +-- @jupyterlab/filebrowser@2.2.5
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/docmanager@2.2.4 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @jupyterlab/services@5.2.5 deduped
| | +-- @jupyterlab/statedb@2.2.5 deduped
| | +-- @jupyterlab/statusbar@2.2.4 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/dragdrop@1.6.4 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/launcher@2.2.6
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/commands@1.11.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/properties@1.2.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @jupyterlab/rendermime@2.2.4 deduped
| +-- @jupyterlab/settingregistry@2.2.5 deduped
| +-- @jupyterlab/ui-components@2.2.4 deduped
| +-- @lumino/algorithm@1.3.3 deduped
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| +-- @lumino/properties@1.2.3 deduped
| `-- @lumino/widgets@1.14.0 deduped</t>
<t tx="ekr.20201114160816.20">+-- @jupyterlab/coreutils@4.2.5
| +-- @lumino/coreutils@1.5.3 deduped
| +-- @lumino/disposable@1.4.3 deduped
| +-- @lumino/signaling@1.4.3 deduped
| +-- minimist@1.2.5
| +-- moment@2.29.1
| +-- path-posix@1.0.0
| `-- url-parse@1.4.7
|   +-- querystringify@2.2.0
|   `-- requires-port@1.0.0</t>
<t tx="ekr.20201114160816.21">+-- @jupyterlab/csvviewer-extension@2.2.7
| +-- @jupyterlab/application@2.2.6 deduped
| +-- @jupyterlab/apputils@2.2.6 deduped
| +-- @jupyterlab/csvviewer@2.2.4
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/coreutils@4.2.5 deduped
| | +-- @jupyterlab/docregistry@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/datagrid@0.6.0 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @jupyterlab/docregistry@2.2.4 deduped
| +-- @jupyterlab/documentsearch@2.2.7
| | +-- @jupyterlab/apputils@2.2.6 deduped
| | +-- @jupyterlab/cells@2.2.7 deduped
| | +-- @jupyterlab/codeeditor@2.2.5 deduped
| | +-- @jupyterlab/codemirror@2.2.4 deduped
| | +-- @jupyterlab/fileeditor@2.2.4 deduped
| | +-- @jupyterlab/notebook@2.2.7 deduped
| | +-- @jupyterlab/ui-components@2.2.4 deduped
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/polling@1.3.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | +-- @lumino/widgets@1.14.0 deduped
| | +-- codemirror@5.53.2 deduped
| | `-- react@16.9.0 deduped
| +-- @jupyterlab/mainmenu@2.2.4 deduped
| +-- @lumino/datagrid@0.6.0
| | +-- @lumino/algorithm@1.3.3 deduped
| | +-- @lumino/coreutils@1.5.3 deduped
| | +-- @lumino/disposable@1.4.3 deduped
| | +-- @lumino/domutils@1.2.3 deduped
| | +-- @lumino/dragdrop@1.6.4 deduped
| | +-- @lumino/keyboard@1.2.3 deduped
| | +-- @lumino/messaging@1.4.3 deduped
| | +-- @lumino/signaling@1.4.3 deduped
| | `-- @lumino/widgets@1.14.0 deduped
| +-- @lumino/signaling@1.4.3 deduped
| `-- @lumino/widgets@1.14.0 deduped</t>
<t tx="ekr.20201114160816.5">- Colorize and import .tsx like .ts.

- Read the Jupyter docs! Good first issue.

- Location of jupyterlab toc packages:
    C:\leo.repo\jupyterlab-toc (study version)
    ~/AppData/local/yarn/cache/v6 (two places)
        @jupyterlab\toc
    
  - Search for the keyword jupyterlab-extension on the npm registry to find extensions
  - Search for markdownViewerTracker.
  
- Script to parse npm list into children.
  Search:  ^(\+\-\-)
  Replace: \n\1
</t>
<t tx="ekr.20201114160816.6">@language rest
@wrap

c:\leo.repo\leo-editor&gt;npm list -g

C:\Users\edreamleo\AppData\Roaming\npm




</t>
<t tx="ekr.20201114160816.7">+-- http-server@0.11.1
| +-- colors@1.0.3
| +-- corser@2.0.1
| +-- ecstatic@3.2.1
| | +-- he@1.1.1
| | +-- mime@1.6.0
| | +-- minimist@1.2.0
| | `-- url-join@2.0.5
| +-- http-proxy@1.17.0
| | +-- eventemitter3@3.1.0
| | +-- follow-redirects@1.5.7
| | | `-- debug@3.1.0
| | |   `-- ms@2.0.0 deduped
| | `-- requires-port@1.0.0
| +-- opener@1.4.3
| +-- optimist@0.6.1
| | +-- minimist@0.0.10
| | `-- wordwrap@0.0.3
| +-- portfinder@1.0.17
| | +-- async@1.5.2
| | +-- debug@2.6.9
| | | `-- ms@2.0.0
| | `-- mkdirp@0.5.1
| |   `-- minimist@0.0.8
| `-- union@0.4.6
|   `-- qs@2.3.3</t>
<t tx="ekr.20201114160816.8">+-- inspect-brk@0.1.2
| `-- find-up@2.1.0
|   `-- locate-path@2.0.0
|     +-- p-locate@2.0.0
|     | `-- p-limit@1.3.0
|     |   `-- p-try@1.0.0
|     `-- path-exists@3.0.0
</t>
<t tx="ekr.20201114160816.9">+-- node-gyp@3.6.2
| +-- fstream@1.0.11
| | +-- graceful-fs@4.1.11 deduped
| | +-- inherits@2.0.3
| | +-- mkdirp@0.5.1 deduped
| | `-- rimraf@2.6.2 deduped
| +-- glob@7.1.2
| | +-- fs.realpath@1.0.0
| | +-- inflight@1.0.6
| | | +-- once@1.4.0 deduped
| | | `-- wrappy@1.0.2
| | +-- inherits@2.0.3 deduped
| | +-- minimatch@3.0.4 deduped
| | +-- once@1.4.0
| | | `-- wrappy@1.0.2 deduped
| | `-- path-is-absolute@1.0.1
| +-- graceful-fs@4.1.11
| +-- minimatch@3.0.4
| | `-- brace-expansion@1.1.11
| |   +-- balanced-match@1.0.0
| |   `-- concat-map@0.0.1
| +-- mkdirp@0.5.1
| | `-- minimist@0.0.8
| +-- nopt@3.0.6
| | `-- abbrev@1.1.1
| +-- npmlog@4.1.2
| | +-- are-we-there-yet@1.1.5
| | | +-- delegates@1.0.0
| | | `-- readable-stream@2.3.6
| | |   +-- core-util-is@1.0.2
| | |   +-- inherits@2.0.3 deduped
| | |   +-- isarray@1.0.0
| | |   +-- process-nextick-args@2.0.0
| | |   +-- safe-buffer@5.1.2 deduped
| | |   +-- string_decoder@1.1.1
| | |   | `-- safe-buffer@5.1.2 deduped
| | |   `-- util-deprecate@1.0.2
| | +-- console-control-strings@1.1.0
| | +-- gauge@2.7.4
| | | +-- aproba@1.2.0
| | | +-- console-control-strings@1.1.0 deduped
| | | +-- has-unicode@2.0.1
| | | +-- object-assign@4.1.1
| | | +-- signal-exit@3.0.2
| | | +-- string-width@1.0.2
| | | | +-- code-point-at@1.1.0
| | | | +-- is-fullwidth-code-point@1.0.0
| | | | | `-- number-is-nan@1.0.1
| | | | `-- strip-ansi@3.0.1 deduped
| | | +-- strip-ansi@3.0.1
| | | | `-- ansi-regex@2.1.1
| | | `-- wide-align@1.1.3
| | |   `-- string-width@1.0.2 deduped
| | `-- set-blocking@2.0.0
| +-- osenv@0.1.5
| | +-- os-homedir@1.0.2
| | `-- os-tmpdir@1.0.2
| +-- request@2.88.0
| | +-- aws-sign2@0.7.0
| | +-- aws4@1.8.0
| | +-- caseless@0.12.0
| | +-- combined-stream@1.0.6
| | | `-- delayed-stream@1.0.0
| | +-- extend@3.0.2
| | +-- forever-agent@0.6.1
| | +-- form-data@2.3.2
| | | +-- asynckit@0.4.0
| | | +-- combined-stream@1.0.6 deduped
| | | `-- mime-types@2.1.19 deduped
| | +-- har-validator@5.1.0
| | | +-- ajv@5.5.2
| | | | +-- co@4.6.0
| | | | +-- fast-deep-equal@1.1.0
| | | | +-- fast-json-stable-stringify@2.0.0
| | | | `-- json-schema-traverse@0.3.1
| | | `-- har-schema@2.0.0
| | +-- http-signature@1.2.0
| | | +-- assert-plus@1.0.0
| | | +-- jsprim@1.4.1
| | | | +-- assert-plus@1.0.0 deduped
| | | | +-- extsprintf@1.3.0
| | | | +-- json-schema@0.2.3
| | | | `-- verror@1.10.0
| | | |   +-- assert-plus@1.0.0 deduped
| | | |   +-- core-util-is@1.0.2 deduped
| | | |   `-- extsprintf@1.3.0 deduped
| | | `-- sshpk@1.14.2
| | |   +-- asn1@0.2.4
| | |   | `-- safer-buffer@2.1.2 deduped
| | |   +-- assert-plus@1.0.0 deduped
| | |   +-- bcrypt-pbkdf@1.0.2
| | |   | `-- tweetnacl@0.14.5 deduped
| | |   +-- dashdash@1.14.1
| | |   | `-- assert-plus@1.0.0 deduped
| | |   +-- ecc-jsbn@0.1.2
| | |   | +-- jsbn@0.1.1 deduped
| | |   | `-- safer-buffer@2.1.2 deduped
| | |   +-- getpass@0.1.7
| | |   | `-- assert-plus@1.0.0 deduped
| | |   +-- jsbn@0.1.1
| | |   +-- safer-buffer@2.1.2
| | |   `-- tweetnacl@0.14.5
| | +-- is-typedarray@1.0.0
| | +-- isstream@0.1.2
| | +-- json-stringify-safe@5.0.1
| | +-- mime-types@2.1.19
| | | `-- mime-db@1.35.0
| | +-- oauth-sign@0.9.0
| | +-- performance-now@2.1.0
| | +-- qs@6.5.2
| | +-- safe-buffer@5.1.2
| | +-- tough-cookie@2.4.3
| | | +-- psl@1.1.29
| | | `-- punycode@1.4.1
| | +-- tunnel-agent@0.6.0
| | | `-- safe-buffer@5.1.2 deduped
| | `-- uuid@3.3.2
| +-- rimraf@2.6.2
| | `-- glob@7.1.2 deduped
| +-- semver@5.3.0
| +-- tar@2.2.1
| | +-- block-stream@0.0.9
| | | `-- inherits@2.0.3 deduped
| | +-- fstream@1.0.11 deduped
| | `-- inherits@2.0.3 deduped
| `-- which@1.3.1
|   `-- isexe@2.0.0</t>
<t tx="ekr.20201117043352.1">- Second test purchase.
- Sign in to stripe.

- Group purchases.
- Add contact page.
- Customize my-account page.
- Set tax and payment methods.
- Make Rebecca an admin.
</t>
<t tx="ekr.20201118031649.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1739

PR: https://github.com/leo-editor/leo-editor/issues/1740

@language python
@nosearch
</t>
<t tx="ekr.20201118080056.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1743

@language python
@nosearch
</t>
<t tx="ekr.20201118090108.1">@language rest
@wrap


How to create your own Leo/Leo Vue site:

Create a folder
Create a leo file in the folder (See Leo Vue for more info about Leo).
Download index.html from this repo (https://github.com/kaleguy/leo-examples) to the folder
Edit settings in index.html
Upload your folder to github pages or other server.

Installed docker for desktop.
Installed kernel update.

Run with Docker

docker build -t leovue .
docker run -p 8080:8080 leovue
</t>
<t tx="ekr.20201118194139.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1742

@language python
@nosearch
</t>
<t tx="ekr.20201118195915.1"></t>
<t tx="ekr.20201119104633.1"></t>
<t tx="ekr.20201119113415.1">************* Module leo.commands.killBufferCommands
killBufferCommands.py:297:16: E1102: self.kbiterator.next is not callable (not-callable)

************* Module leo.core.leoKeys
leoKeys.py:3135:12: E1102: handler is not callable (not-callable)

************* Module leo.core.leoRst
leoRst.py:1804:8: E1121: Too many positional arguments for method call (too-many-function-args)
leoRst.py:1991:8: E1120: No value for argument 'p' in method call (no-value-for-parameter)

************* Module leo.plugins.active_path
active_path.py:284:16: E1120: No value for argument 'a' in function call (no-value-for-parameter)

************* Module leo.plugins.bookmarks
bookmarks.py:489:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
bookmarks.py:544:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.cursesGui2
cursesGui2.py:481:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:2740:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:2974:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3122:4: W0222: Signature differs from overridden 'display' method (signature-differs)
cursesGui2.py:3128:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3134:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3298:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3756:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
cursesGui2.py:3976:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.demo
demo.py:31:8: E1101: Instance of 'LeoApp' has no 'next' member (no-member)
demo.py:39:8: E1101: Instance of 'LeoApp' has no 'prev' member (no-member)
demo.py:47:8: E1101: Instance of 'LeoApp' has no 'end' member (no-member)
demo.py:274:28: E1102: self.next is not callable (not-callable)
demo.py:276:24: E1102: self.next is not callable (not-callable)
demo.py:727:17: E1101: Instance of 'LeoApp' has no 'pane_widget' member (no-member)
demo.py:732:8: E1101: Instance of 'LeoApp' has no 'widgets' member (no-member)
demo.py:745:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:766:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:787:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:795:17: E1101: Instance of 'LeoApp' has no 'pane_widget' member (no-member)
demo.py:799:8: E1101: Instance of 'LeoApp' has no 'widgets' member (no-member)
demo.py:806:13: E1101: Instance of 'LeoApp' has no 'get_icon_fn' member (no-member)
demo.py:824:20: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:825:20: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:833:12: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:844:17: E1101: Instance of 'LeoApp' has no 'pane_widget' member (no-member)
demo.py:848:8: E1101: Instance of 'LeoApp' has no 'widgets' member (no-member)
demo.py:855:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:859:25: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:860:24: E1101: Instance of 'LeoApp' has no 'get_int' member (no-member)
demo.py:893:8: E1101: Instance of 'LeoApp' has no 'set_position' member (no-member)
demo.py:902:12: E1101: Instance of 'LeoApp' has no 'find_node' member (no-member)
demo.py:904:25: E1101: Instance of 'LeoApp' has no 'headline_geometry' member (no-member)

************* Module leo.plugins.importers.javascript
importers/javascript.py:520:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.notebook
notebook.py:74:12: E0611: No name 'QtQuick' in module 'PyQt5' (no-name-in-module)

************* Module leo.plugins.python_terminal
python_terminal.py:76:12: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
python_terminal.py:294:16: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.quicksearch
quicksearch.py:249:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)

************* Module leo.plugins.read_only_nodes
read_only_nodes.py:167:12: W0707: Consider explicitly re-raising using the 'from' keyword (raise-missing-from)
read_only_nodes.py:200:12: W0707: Consider explicitly re-raising using the 'from' keyword (raise-missing-from)
read_only_nodes.py:221:12: W0707: Consider explicitly re-raising using the 'from' keyword (raise-missing-from)

************* Module leo.plugins.screencast
screencast.py:622:16: E1102: m.next is not callable (not-callable)
screencast.py:683:12: E1102: m.next is not callable (not-callable)
screencast.py:689:12: E1102: m.next is not callable (not-callable)
screencast.py:691:12: E1102: m.next is not callable (not-callable)
screencast.py:693:12: E1102: m.prev is not callable (not-callable)

************* Module leo.plugins.stickynotes_plus
stickynotes_plus.py:184:8: R1725: Consider using Python 3 style super() without arguments (super-with-arguments)
</t>
<t tx="ekr.20201119114229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1746

@language python
@nosearch
</t>
<t tx="ekr.20201119120953.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1747

@language python
@nosearch
</t>
<t tx="ekr.20201120061256.1">c:\leo.repo&gt;cd leovue

c:\leo.repo\leovue&gt;docker build -t leovue .
[+] Building 134.7s (14/14) FINISHED
 =&gt; [internal] load .dockerignore                                                                                  0.1s
 =&gt; =&gt; transferring context: 180B                                                                                  0.0s
 =&gt; [internal] load build definition from Dockerfile                                                               0.1s
 =&gt; =&gt; transferring dockerfile: 411B                                                                               0.0s
 =&gt; [internal] load metadata for docker.io/library/node:8                                                          2.9s
 =&gt; [1/9] FROM docker.io/library/node:8@sha256:a681bf74805b80d03eb21a6c0ef168a976108a287a74167ab593fc953aac34df   30.6s
 =&gt; =&gt; resolve docker.io/library/node:8@sha256:a681bf74805b80d03eb21a6c0ef168a976108a287a74167ab593fc953aac34df    0.0s
 =&gt; =&gt; sha256:a681bf74805b80d03eb21a6c0ef168a976108a287a74167ab593fc953aac34df 1.42kB / 1.42kB                     0.0s
 =&gt; =&gt; sha256:ee25271e00572cb09d095f6b35880a284eac570c17452644bc67fd1d8dc7f9f7 2.21kB / 2.21kB                     0.0s
 =&gt; =&gt; sha256:146bd6a886182fde06fbf747470b1c89814bc8ab1c96fdf1aef6107171959fe6 45.38MB / 45.38MB                  10.3s
 =&gt; =&gt; sha256:db0efb86e80601b5bbdbb7c406426982c4202d339687c14c3941b364527e2249 4.34MB / 4.34MB                     2.3s
 =&gt; =&gt; sha256:8eeadf3757f41ffbde6fbb4bbbe14f9f5b9ce33cc1aa88bb5c0b4d6e9467509d 7.76kB / 7.76kB                     0.0s
 =&gt; =&gt; sha256:9935d0c62ace92b388be202275e222007d6cac10b9c1f2c1ea63af38c09ea7ab 10.80MB / 10.80MB                   3.1s
 =&gt; =&gt; sha256:e705a4c4fd310b96bfb3d7928428e65f0d3f5bad0cd0bda1434aee1d89418468 50.07MB / 50.07MB                  12.3s
 =&gt; =&gt; sha256:c877b722db6f4d4297c21f07162d21fa6ac6f51d03360f75e24cfa3bcaefe57d 214.84MB / 214.84MB                24.0s
 =&gt; =&gt; sha256:645c20ec82147f2bdc182280ac02b60687cfac33c4231059051bbdcf60e31035 4.16kB / 4.16kB                    11.0s
 =&gt; =&gt; extracting sha256:146bd6a886182fde06fbf747470b1c89814bc8ab1c96fdf1aef6107171959fe6                          4.1s
 =&gt; =&gt; sha256:db8fbd9db2fe6382804432552a60f85b0e292cdb34b8a5c751c4a3061f68df29 19.40MB / 19.40MB                  14.3s
 =&gt; =&gt; sha256:1c151cd1b3eabced84742529489b3c8c344181b4cbcdcfccdb1f4a7c7d0239ec 1.40MB / 1.40MB                    13.0s
 =&gt; =&gt; sha256:fbd993995f407f3681fc8399ae67c04bba8e15c7f754b1af8b37f50b35f4a11e 292B / 292B                        13.7s
 =&gt; =&gt; extracting sha256:9935d0c62ace92b388be202275e222007d6cac10b9c1f2c1ea63af38c09ea7ab                          0.8s
 =&gt; =&gt; extracting sha256:db0efb86e80601b5bbdbb7c406426982c4202d339687c14c3941b364527e2249                          0.3s
 =&gt; =&gt; extracting sha256:e705a4c4fd310b96bfb3d7928428e65f0d3f5bad0cd0bda1434aee1d89418468                          5.5s
 =&gt; =&gt; extracting sha256:c877b722db6f4d4297c21f07162d21fa6ac6f51d03360f75e24cfa3bcaefe57d                          4.9s
 =&gt; =&gt; extracting sha256:645c20ec82147f2bdc182280ac02b60687cfac33c4231059051bbdcf60e31035                          0.0s
 =&gt; =&gt; extracting sha256:db8fbd9db2fe6382804432552a60f85b0e292cdb34b8a5c751c4a3061f68df29                          0.8s
 =&gt; =&gt; extracting sha256:1c151cd1b3eabced84742529489b3c8c344181b4cbcdcfccdb1f4a7c7d0239ec                          0.1s
 =&gt; =&gt; extracting sha256:fbd993995f407f3681fc8399ae67c04bba8e15c7f754b1af8b37f50b35f4a11e                          0.0s
 =&gt; [internal] load build context                                                                                  3.4s
 =&gt; =&gt; transferring context: 98.65MB                                                                               3.3s
 =&gt; [2/9] RUN node --version                                                                                       2.8s
 =&gt; [3/9] RUN npm --version                                                                                        0.6s
 =&gt; [4/9] RUN apt-get update &amp;&amp; apt-get install -y build-essential &amp;&amp; apt-get -y install sudo                      6.0s
 =&gt; [5/9] RUN mkdir -p /usr/src/app                                                                                0.5s
 =&gt; [6/9] WORKDIR /usr/src/app                                                                                     0.0s
 =&gt; [7/9] COPY package.json /usr/src/app/                                                                          0.0s
 =&gt; [8/9] COPY . /usr/src/app                                                                                      0.5s
 =&gt; [9/9] RUN npm install                                                                                         83.2s
 =&gt; exporting to image                                                                                             7.4s
 =&gt; =&gt; exporting layers                                                                                            7.3s
 =&gt; =&gt; writing image sha256:9669cb5783882380c8ac61361b4f4d0a80645646a4b95467eca67fe95fed2359                       0.0s
 =&gt; =&gt; naming to docker.io/library/leovue                                                                          0.1s

c:\leo.repo\leovue&gt;</t>
<t tx="ekr.20201120061449.1">c:\leo.repo\leovue&gt;docker run -p 8080:8080 leovue

&gt; leo-vue@2.0.2 dev /usr/src/app
&gt; node build/dev-server.js

 wdm: wait until bundle finished:
[BABEL] Note: The code generator has deoptimised the styling of "/usr/src/app/node_modules/bootstrap-vue/esm/icons/icons.js" as it exceeds the max of "500KB".
 DONE  Compiled successfully in 36240ms12:14:37

 wdm: Hash: bceb58d1acc6117a234f
Version: webpack 3.12.0
Time: 47240ms
     Asset     Size  Chunks                    Chunk Names
    app.js  30.5 MB       0  [emitted]  [big]  app
index.html  11.3 kB          [emitted]
   [0] ./node_modules/vue-awesome/components/Icon.vue 1.65 kB {0} [built]
 [810] multi ./build/dev-client ./src/main.js 40 bytes {0} [built]
 [811] ./build/dev-client.js 254 bytes {0} [built]
 [827] ./src/main.js 6.87 kB {0} [built]
[3250] ./src/components/MathJax.vue 2.08 kB {0} [built]
[3253] ./src/components/layout/ImageLeft.vue 2.11 kB {0} [built]
[3256] ./src/components/LVTimeline.vue 2.09 kB {0} [built]
[3260] ./src/components/WordCloud.vue 2.09 kB {0} [built]
[3298] ./src/components/Kanban.vue 2.42 kB {0} [built]
[3302] ./src/components/MermaidBoard.vue 2.1 kB {0} [built]
[3306] ./src/components/D3Board.vue 2.08 kB {0} [built]
[3309] ./node_modules/vue-table-component/dist/index.js 160 kB {0} [built]
[3311] ./src/components/SummaryTable.vue 2.1 kB {0} [built]
[3314] ./src/components/TagSearch.vue 2.09 kB {0} [built]
[3318] ./node_modules/vuewordcloud/index.js 13.3 kB {0} [built]
    + 3312 hidden modules
Child html-webpack-plugin for "index.html":
         Asset     Size  Chunks  Chunk Names
    index.html  1.48 MB       0
       [0] ./node_modules/html-webpack-plugin/lib/loader.js!./index.html 12.3 kB {0} [built]
       [1] ./node_modules/lodash/lodash.js 543 kB {0} [built]
       [2] (webpack)/buildin/global.js 509 bytes {0} [built]
       [3] (webpack)/buildin/module.js 517 bytes {0} [built]
 wdm: Compiled successfully.
&gt; Listening at http://localhost:8080
</t>
<t tx="ekr.20201120061944.1">@language rest
@wrap

git clone https://github.com/kaleguy/leovue.git leovue

- Study app.js in original form.
- Compare before/after build for index.html.
- Use plain build, not docker.

- Check bit defender permissions.
- Change title to LeoVue2 and see what happens.

Download MathJax, Revealjs, Mermaid.

build-leovue:
cd c:\leo.repo\leovue
docker build -t leovue .

run-leovue:
cd c:\leo.repo\leovue
docker run -p 8080:8080 leovue

moz localhost:8080

Docker Commands:

    docker ps -a
    docker system prune
    docker kill &lt;id&gt;
    
See the main.js file in the LeoVue source for how other components are included with LeoVue.</t>
<t tx="ekr.20201121062544.1">@language rest
@wrap

From https://kaleguy.github.io/leo-examples/

How to create your own Leo/Leo Vue site:

- Create a folder
- Create a leo file in the folder (See Leo Vue for more info about Leo).
- Download index.html from this repo to the folder
- Edit settings in index.html
  The default filename is docs (docs.leo)
- Upload your folder to github pages or other server.

Note that if your Leo file contains diagrams, youll need to include Onsen and Mermaid (see the Diagram Example)</t>
<t tx="ekr.20201121085817.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1748

regex fails with replace-all

@language python
@nosearch
</t>
<t tx="ekr.20201122121724.1">@language rest
@wrap

- Fix more icons. When done, send url for ekr.com to Linda.
- Use local .js files.
- Use https instead of http for EKR.com
- Study powershell.</t>
<t tx="ekr.20201122134617.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1749

@language python
@nosearch
</t>
<t tx="ekr.20201122165543.1"></t>
<t tx="ekr.20201122165606.1"></t>
<t tx="ekr.20201123163439.1">@language rest
@wrap

This kind of error suggests that the script your browser loads is intended for nodejs scripting environment not for the browser.  In order to be used in the webpage this scripts must be transformed or repackaged.

IIRC leo-vue uses webpack as build tool. The build tool (whatever it might be) bundles all separate javascript files in one big javascript file. That file should be loaded in the webpage. It means that the script tag in your index.html needs a src attribute to be correctly set to load this big javascript which contains all separate files bundled together.

Look in the webpack configuration file to find out where the result of build process should be and then adjust `&lt;scirpt src=""&gt;` inside your index.html to the correct path.</t>
<t tx="ekr.20201123183452.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1754

w.see works for the first time ever!

@language python
@nosearch
</t>
<t tx="ekr.20201124105426.1">c:\leo.repo\leovue&gt;docker build -t leovue .
[+] Building 93.9s (14/14) FINISHED
 =&gt; [internal] load .dockerignore                                                                                  0.1s
 =&gt; =&gt; transferring context: 170B                                                                                  0.0s
 =&gt; [internal] load build definition from Dockerfile                                                               0.0s
 =&gt; =&gt; transferring dockerfile: 391B                                                                               0.0s
 =&gt; [internal] load metadata for docker.io/library/node:8                                                          1.6s
 =&gt; [1/9] FROM docker.io/library/node:8@sha256:a681bf74805b80d03eb21a6c0ef168a976108a287a74167ab593fc953aac34df    0.0s
 =&gt; [internal] load build context                                                                                  1.4s
 =&gt; =&gt; transferring context: 97.09MB                                                                               1.3s
 =&gt; CACHED [2/9] RUN node --version                                                                                0.0s
 =&gt; CACHED [3/9] RUN npm --version                                                                                 0.0s
 =&gt; CACHED [4/9] RUN apt-get update &amp;&amp; apt-get install -y build-essential &amp;&amp; apt-get -y install sudo               0.0s
 =&gt; CACHED [5/9] RUN mkdir -p /usr/src/app                                                                         0.0s
 =&gt; CACHED [6/9] WORKDIR /usr/src/app                                                                              0.0s
 =&gt; CACHED [7/9] COPY package.json /usr/src/app/                                                                   0.0s
 =&gt; [8/9] COPY . /usr/src/app                                                                                      0.5s
 =&gt; [9/9] RUN npm install                                                                                         83.3s
 =&gt; exporting to image                                                                                             6.9s
 =&gt; =&gt; exporting layers                                                                                            6.9s
 =&gt; =&gt; writing image sha256:97a641aaedb86bbdfcb0a4e20b00181cec74625f4a31dd16518211a101c74c91                       0.0s
 =&gt; =&gt; naming to docker.io/library/leovue                                                                          0.0s
</t>
<t tx="ekr.20201124191844.1">@g.commander_command('reformat-selection')
def reformatSelection(self, event=None, undoType='Reformat Paragraph'):
    """
    Reformat the selected text, as in reformat-paragraph, but without
    expanding the selection past the selected lines.
    """
    c, undoType = self, 'reformat-selection'
    p, u, w = c.p, c.undoer, c.frame.body.wrapper
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    bunch = u.beforeChangeBody(p)
    oldSel, oldYview, original, pageWidth, tabWidth = rp_get_args(c)
    head, middle, tail = c.frame.body.getSelectionLines()
    lines = g.splitLines(middle)
    if not lines:
        return
    indents, leading_ws = rp_get_leading_ws(c, lines, tabWidth)
    result = rp_wrap_all_lines(c, indents, leading_ws, lines, pageWidth)
    s = head + result + tail
    if s == original:
        return
    #
    # Update the text and the selection.
    w.setAllText(s)  # Destroys coloring.
    i = len(head)
    j = max(i, len(head) + len(result) - 1)
    j = min(j, len(s))
    w.setSelectionRange(i, j, insert=j)
    #
    # Finish.
    p.v.b = s  # p.b would cause a redraw.
    u.afterChangeBody(p, undoType, bunch)
    w.setXScrollPosition(0)  # Never scroll horizontally.
</t>
<t tx="ekr.20201125041840.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1751

File "C:\Programs\Leo\leo\plugins\quicksearch.py", line 733, in onSelectItem
    indent = len(cur.text()) - len(str(cur.text()).lstrip())
AttributeError: 'NoneType' object has no attribute 'text'

@language python
@nosearch
</t>
<t tx="ekr.20201127035748.1">def updateAfterTyping(self, p, w):
    """
    Perform all update tasks after changing body text.
    
    This is ugly, ad-hoc code, but should be done uniformly.
    """
    c = self.c
    if g.isTextWrapper(w):
        # An important, ever-present unit test.
        all = w.getAllText()
        if g.unitTesting:
            assert p.b == all, g.callers()
        elif p.b != all:
            g.trace(f"\nError:p.b != w.getAllText() p:{p.h} {g.callers()}\n")
            # g.printObj(g.splitLines(p.b), tag='p.b')
            # g.printObj(g.splitLines(all), tag='getAllText')
        p.v.insertSpot = ins = w.getInsertPoint()
        # From u.doTyping.
        newSel = w.getSelectionRange()
        if newSel is None:
            p.v.selectionStart, p.v.selectionLength = (ins, 0)
        else:
            i, j = newSel
            p.v.selectionStart, p.v.selectionLength = (i, j - i)
    else:
        if g.unitTesting:
            assert False, f"Not a text wrapper: {g.callers()}"
        g.trace('Not a text wrapper')
        p.v.insertSpot = 0
        p.v.selectionStart, p.v.selectionLength = (0, 0)
    #
    # #1749.
    if p.isDirty():
        redraw_flag = False
    else:
        p.setDirty() # Do not call p.v.setDirty!
        redraw_flag = True
    if not c.isChanged():
        c.setChanged()
    # Update editors.
    c.frame.body.updateEditors()
    # Update icons.
    val = p.computeIcon()
    if not hasattr(p.v, "iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
    #
    # Recolor the body.
    c.frame.scanForTabWidth(p)  # Calls frame.setTabWidth()
    c.recolor()
    if g.app.unitTesting:
        g.app.unitTestDict['colorized'] = True
    if redraw_flag:
        c.redraw_after_icons_changed()
    w.setFocus()
</t>
<t tx="ekr.20201127072229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1759

@language python
@nosearch
</t>
<t tx="ekr.20201127072238.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1757

k.doBinding and k.getPaneBinding fix the primary issue.

vc.vim_dot fixes a secondary issue, described in #1757.

@language python
@nosearch
</t>
<t tx="ekr.20201127143342.1">def see_more_lines(s, ins, n=4):
    """
    Extend index i within string s to include n more lines.
    """
    # Show more lines, if they exist.
    if n &gt; 0:
        for z in range(n):
            if ins &gt;= len(s):
                break
            i, j = g.getLine(s, ins)
            ins = j
    return max(0, min(ins, len(s)))
</t>
<t tx="ekr.20201128042351.1"></t>
<t tx="ekr.20201128042437.1"></t>
<t tx="ekr.20201128043237.1"></t>
<t tx="ekr.20201128045435.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1760

These seem harmless, but they are mysterious.

@language python
@nosearch


</t>
<t tx="ekr.20201128050540.1">c:\leo.repo\leo-editor&gt;python c:\leo.repo\leo-editor\launchLeo.py --no-splash --gui=qttabs leo\core\leoPy.leo

Leo 6.4-devel, ekr-undo branch, build d1ba6bc993

2020-11-27 15:02:52 -0600
wrote recent file: C:/Users/edreamleo/.leo/.leoRecentFiles.txt
pylint: leoKeys.py
pylint finished
Starting log_listener.py
About to start TCP server...
--------------------
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-line-number-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-line-number-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-md-line-number-test.md
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-md-line-number-test.md
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-section-ref-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-section-ref-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-unit-test.py
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-unit-test.py
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-org-line-number-test.org
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-org-line-number-test.org
   pr: Unexpected exception importing c:/leo.repo/leo-editor/leo/test/unittest/at-auto-otl-line-number-test.otl
   pr: Traceback (most recent call last):
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 585, in readOneAtAutoNode
   pr:     p = ic.createOutline(fileName, parent=p.copy())
   pr:   File "c:\leo.repo\leo-editor\leo\core\leoImport.py", line 662, in createOutline
   pr:     w.setInsertPoint(0)
   pr: AttributeError: 'NoneType' object has no attribute 'setInsertPoint'
   pr: errors inhibited read @auto c:/leo.repo/leo-editor/leo/test/unittest/at-auto-otl-line-number-test.otl
   pr: wrote recent file: C:/Users/edreamleo/.leo/.leoRecentFiles.txt
   pr: Saving: c:/leo.repo/leo-editor/leo/test/unitTest.leo
listener suspended
killed log listener.

c:\leo.repo\leo-editor&gt;</t>
<t tx="ekr.20201128051459.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1733

@language python
@nosearch
</t>
<t tx="ekr.20201128052211.1">@nosearch

# flattened, word, ignore-case, body

# found 22 nodes</t>
<t tx="ekr.20201128125708.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1758

**After** the sabbatical:

- Enable tests of selection range.
- Enable tests of undo/redo.
- Rename 'directives' kwarg to 'parent_b'.
- Remove tempNode.
- (Maybe): run-all-tests command.

@language python
@nosearch
</t>
<t tx="ekr.20201128132124.1"></t>
<t tx="ekr.20201128132228.1"></t>
<t tx="ekr.20201128132310.1"></t>
<t tx="ekr.20201128132526.1"></t>
<t tx="ekr.20201128133405.1"></t>
<t tx="ekr.20201128133541.1"></t>
<t tx="ekr.20201128164717.1"></t>
<t tx="ekr.20201128164717.10">first line
    line 1
        line a
            line b
    line c
last line
</t>
<t tx="ekr.20201128164717.100">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.101">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.102">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.103">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.104">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.105">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.106">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.107">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.108">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.109"></t>
<t tx="ekr.20201128164717.11">vr = c.helpCommands.helpForBindings()
if not vr:
    self.skipTest('no vr plugin')
</t>
<t tx="ekr.20201128164717.110">from leo.core import leoBeautify
from leo.commands import convertCommands
cpp = leoBeautify.CPrettyPrinter(c)
# c2p = convertCommands.C_To_Python(c)
fn = 'c tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)
aList = cpp.tokenize(p2.b)
assert aList
# c2p.convertCodeList(aList)
# s = ''.join(aList)
</t>
<t tx="ekr.20201128164717.111">@language c

static exit_values_ty indent_main_loop(void)
{
    codes_ty         hd_type         = code_eof;
    char           * t_ptr           = NULL;
    codes_ty         type_code       = start_token;
    exit_values_ty   file_exit_value = total_success;
    int              dec_ind         = 0; /* current indentation for declarations */

    BOOLEAN          scase           = false; /* true when we've just see a "case";
                                               * determines what to do with the
                                               * following colon */
    BOOLEAN          flushed_nl;              /* Used when buffering up comments to remember that
                                               * a newline was passed over */
    BOOLEAN          sp_sw           = false; /* true when in the expression part of if(...),
                                               * while(...), etc. */
    BOOLEAN          force_nl        = false;

    /* last_token_ends_sp: True if we have just encountered the end of an if (...),
     * etc. (i.e. the ')' of the if (...) was the last token).  The variable is
     * set to 2 in the middle of the main token reading loop and is decremented
     * at the beginning of the loop, so it will reach zero when the second token
     * after the ')' is read.
     */

    BOOLEAN          last_token_ends_sp = false;

    BOOLEAN          last_else = false; /* true if last keyword was an else */

    for (;;)
    {
        /* this is the main loop.  it will go until
         * we reach eof */

        BOOLEAN is_procname_definition;
        bb_code_ty can_break;

        if (type_code != newline)
        {
            can_break = parser_state_tos-&gt;can_break;
        }

        parser_state_tos-&gt;last_saw_nl = false;
        parser_state_tos-&gt;can_break = bb_none;

        type_code = lexi ();    /* lexi reads one token.  "token" points to
                                 * the actual characters. lexi returns a code
                                 * indicating the type of token */

        /* If the last time around we output an identifier or
         * a paren, then consider breaking the line here if it's
         * too long.
         *
         * A similar check is performed at the end of the loop, after
         * we've put the token on the line. */

        if ((settings.max_col &gt; 0) &amp;&amp;
            (buf_break != NULL) &amp;&amp;
            ( ( (parser_state_tos-&gt;last_token == ident) &amp;&amp;
                (type_code != comma) &amp;&amp;
                (type_code != semicolon) &amp;&amp;
                (type_code != newline) &amp;&amp;
                (type_code != form_feed) &amp;&amp;
                (type_code != rparen) &amp;&amp;
                (type_code != struct_delim)) ||
              ( (parser_state_tos-&gt;last_token == rparen) &amp;&amp;
                (type_code != comma) &amp;&amp;
                (type_code != rparen) ) ) &amp;&amp;
            (output_line_length () &gt; settings.max_col))
        {
            break_line = 1;
        }

        if (last_token_ends_sp &gt; 0)
        {
            last_token_ends_sp--;
        }

        is_procname_definition =
                (((parser_state_tos-&gt;procname[0] != '\0') &amp;&amp;
                  parser_state_tos-&gt;in_parameter_declaration) ||
                 (parser_state_tos-&gt;classname[0] != '\0'));

        /* The following code moves everything following an if (), while (),
         * else, etc. up to the start of the following stmt to a buffer. This
         * allows proper handling of both kinds of brace placement.
         */

        flushed_nl = false;

        if (!search_brace(&amp;type_code, &amp;force_nl, &amp;flushed_nl, &amp;last_else, &amp;is_procname_definition))
        {
            /* Hit EOF unexpectedly in comment. */
            return indent_punt;
        }
        
        if (type_code == code_eof)
        {
            /* we got eof */
            if (s_lab != e_lab || s_code != e_code || s_com != e_com)   /* must dump end of line */
            {
                dump_line(true, &amp;paren_target);
            }

            if (parser_state_tos-&gt;tos &gt; 1)      /* check for balanced braces */
            {
                ERROR (_("Unexpected end of file"), 0, 0);
                file_exit_value = indent_error;
            }

            if (settings.verbose)
            {
                printf (_("There were %d non-blank output lines and %d comments\n"),
                        (int) out_lines, (int) com_lines);
                if (com_lines &gt; 0 &amp;&amp; code_lines &gt; 0)
                {
                    printf (_("(Lines with comments)/(Lines with code): %6.3f\n"),
                            (1.0 * com_lines) / code_lines);
                }
            }
            flush_output ();

            return file_exit_value;                                              /* RETURN */
        }

        if ((type_code != comment) &amp;&amp;
            (type_code != cplus_comment) &amp;&amp;
            (type_code != newline) &amp;&amp;
            (type_code != preesc) &amp;&amp;
            (type_code != form_feed))
        {
            if (force_nl &amp;&amp;
                (type_code != semicolon) &amp;&amp;
                ( (type_code != lbrace) ||
                  (!parser_state_tos-&gt;in_decl &amp;&amp; !settings.btype_2) ||
                  (parser_state_tos-&gt;in_decl &amp;&amp; !settings.braces_on_struct_decl_line) ||
                  (parser_state_tos-&gt;last_token == rbrace)))
            {
                if (settings.verbose &amp;&amp; !flushed_nl)
                {
                    WARNING (_("Line broken 2"), 0, 0);
                }

                flushed_nl = false;
                dump_line(true, &amp;paren_target);
                parser_state_tos-&gt;want_blank = false;
                force_nl = false;
            }

            parser_state_tos-&gt;in_stmt = true;   /* turn on flag which causes
                                                 * an extra level of
                                                 * indentation. this is
                                                 * turned off by a ; or } */
            if (s_com != e_com)
            {
                /* the code has an embedded comment in the
                 * line. Move it from the com buffer to the
                 * code buffer.
                 *
                 * Do not add a space before the comment if it is the first
                 * thing on the line.
                 */

                if (e_code != s_code)
                {
                    set_buf_break (bb_embedded_comment_start, paren_target);
                    *e_code++ = ' ';
                    embedded_comment_on_line = 2;
                }
                else
                {
                    embedded_comment_on_line = 1;
                }

                for (t_ptr = s_com; *t_ptr; ++t_ptr)
                {
                    check_code_size();
                    *e_code++ = *t_ptr;
                }

                set_buf_break (bb_embedded_comment_end, paren_target);
                *e_code++ = ' ';
                *e_code = '\0'; /* null terminate code sect */
                parser_state_tos-&gt;want_blank = false;
                e_com = s_com;
            }
        }
        else if ((type_code != comment) &amp;&amp;
                 (type_code != cplus_comment) &amp;&amp;
                 !(settings.break_function_decl_args &amp;&amp;
                   (parser_state_tos-&gt;last_token == comma)) &amp;&amp;
                 !( (parser_state_tos-&gt;last_token == comma) &amp;&amp;
                    !settings.leave_comma))
        {
            /* preserve force_nl thru a comment but
             * cancel forced newline after newline, form feed, etc.
             * however, don't cancel if last thing seen was comma-newline
             * and -bc flag is on. */

            force_nl = false;
        }

        /* Main switch on type of token scanned */

        check_code_size();
        
        /* now, decide what to do with the token */

        handle_the_token(type_code, &amp;scase, &amp;force_nl, &amp;sp_sw, &amp;flushed_nl,
                         &amp;hd_type, &amp;dec_ind, &amp;last_token_ends_sp, &amp;file_exit_value,
                         can_break, &amp;last_else, is_procname_definition);
        
        *e_code = '\0';         /* make sure code section is null terminated */

        if ((type_code != comment) &amp;&amp;
            (type_code != cplus_comment) &amp;&amp;
            (type_code != newline) &amp;&amp;
            (type_code != preesc) &amp;&amp;
            (type_code != form_feed))
        {
            parser_state_tos-&gt;last_token = type_code;
        }

        /* Now that we've put the token on the line (in most cases),
         * consider breaking the line because it's too long.
         *
         * Don't consider the cases of `unary_op', newlines,
         * declaration types (int, etc.), if, while, for,
         * identifiers (handled at the beginning of the loop),
         * periods, or preprocessor commands. */

        if ((settings.max_col &gt; 0) &amp;&amp; (buf_break != NULL))
        {
            if ( ( (type_code == binary_op) ||
                   (type_code == postop) ||
                   (type_code == question) ||
                   ((type_code == colon) &amp;&amp; (scase || (squest &lt;= 0))) ||
                   (type_code == semicolon) ||
                   (type_code == sp_nparen) ||
                   (type_code == sp_else) ||
                   ((type_code == ident) &amp;&amp; (*token == '\"')) ||
                   (type_code == struct_delim) ||
                   (type_code == comma)) &amp;&amp;
                 (output_line_length () &gt; settings.max_col))
            {
                break_line = 1;
            }
        }
    }                           /* end of main infinite loop */
}
</t>
<t tx="ekr.20201128164717.112">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.113">first line
line 1
    Line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.114">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.115">first line
line 1
    Line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.116">@pagewidth 70 # Required for unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.117">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.118">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.119">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.12">vr = c.helpCommands.helpForFindCommands()
if not vr:
    self.skipTest('no vr plugin')
</t>
<t tx="ekr.20201128164717.120">@pagewidth 70 # Required for unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.121">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20201128164717.122">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20201128164717.123">Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
</t>
<t tx="ekr.20201128164717.124">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.125"># Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
</t>
<t tx="ekr.20201128164717.126"># Should remove all trailing whitespace.

a = 2   
    
    b = 3
    c  = 4  
d = 5
e = 6  
x
</t>
<t tx="ekr.20201128164717.127"># Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
</t>
<t tx="ekr.20201128164717.128">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.129">first line
line    line b
line c
last line
</t>
<t tx="ekr.20201128164717.13">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.130">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.131">first line
line    line b
line c
last line
</t>
<t tx="ekr.20201128164717.132">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    exec(g.findTestScript(c,'@common x-marked-nodes test code'))
    
    def test(p):
        target = p.copy()
        setup_test(p)
        c.cloneMarked()
        h = 'Clones of marked nodes'
        assert c.p.h == h,c.p.h
        c.undoer.undo()
        assert not g.findNodeAnywhere(c,h)
        c.undoer.redo()
        assert c.p.h == h, c.p.h
    try:
        test(p)
    finally:
        tear_down(p,'Clones of marked nodes')
</t>
<t tx="ekr.20201128164717.133"></t>
<t tx="ekr.20201128164717.136"></t>
<t tx="ekr.20201128164717.137"></t>
<t tx="ekr.20201128164717.138"></t>
<t tx="ekr.20201128164717.139"></t>
<t tx="ekr.20201128164717.14">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.140"></t>
<t tx="ekr.20201128164717.141">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.142">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.143">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.144">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.145"># main after
# mainto

ac = c.abbrevCommands
w = c.frame.body.wrapper
s = w.getAllText()
w.setInsertPoint(4)
# i,j = g.getWord(s,4)
# word = s[i:j]
event = g.bunch(widget=w)
ac.dynamicCompletion(event)
try:
    i = s.find('main')
    assert i == 2,i
finally:
    if 1:
        c.undoer.undo(event=event)

</t>
<t tx="ekr.20201128164717.146"># main after
# mainto

ac = c.abbrevCommands
w = c.frame.body.wrapper
s = w.getAllText()
w.setInsertPoint(4)
i,j = g.getWord(s,4)
word = s[i:j]
aList = ac.getDynamicList(w,word)
c.k.arg = aList[1]
event = g.bunch(char=None, stroke=None, widget=w)
ac.dynamicExpandHelper(event)
    # This *does* support undo.
s = w.getAllText()
try:
    i = s.find('main')
    assert i == 2,i
finally:
    if 0:
        c.undoer.undo()
</t>
<t tx="ekr.20201128164717.147">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.148">firstline
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.149">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.15">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.150">firstline
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.151">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.152">first line
line 1
last line
</t>
<t tx="ekr.20201128164717.153">first line
    line 1
last line
</t>
<t tx="ekr.20201128164717.154">first line
line 1
last line
</t>
<t tx="ekr.20201128164717.155">if g.app.isExternalUnitTest:
    self.skipTest('Can not be run externally')
else:

    exec(g.findTestScript(c,'@common x-marked-nodes test code'))
    
    def test(p):
        setup_test(p)
        c.deleteMarked()
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
        c.undoer.undo()
        n = p.numberOfChildren()
        assert n == 4,'undo: children: %s' % (n)
        c.undoer.redo()
        n = p.numberOfChildren()
        assert n == 2 ,'delete: children: %s' % (n)
    try:
        test(p)
    finally:
        tear_down(p)
</t>
<t tx="ekr.20201128164717.156">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.157">first line
line 1
line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.158">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.159">first line
line 1
line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.16">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.160">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.161">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.162">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.163">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.164">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.165">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.166">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.167">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.168">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.169">xyzzy line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.17">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.170">XYZZY line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.171">xyzzy line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.172">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.173">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.174">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.175">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.176">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.177">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.178">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.179">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.18">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.180">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.181">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.182">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.183">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.184">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.185">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.186">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.187">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.188">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.189">first line

line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.19">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.190">first line

line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.191">first line

line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.192">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.193">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.194">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.195">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.196">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.197">first line
line 1
    line a
        line b
line c
last non-blank line
 
</t>
<t tx="ekr.20201128164717.198">first line
line 1
    line a
        line b
line c
last non-blank line
 
</t>
<t tx="ekr.20201128164717.199">first line
line 1
    line a
        line b
line c
last non-blank line
 
</t>
<t tx="ekr.20201128164717.2"></t>
<t tx="ekr.20201128164717.20">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.200">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.201">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.202">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.203">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.204">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.205">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.206">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.207">first line
line 1
    line a
        line b
line c
last non-blank line
</t>
<t tx="ekr.20201128164717.208">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.209">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.21">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.210">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.211">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.212"># Test of bug 930726: expandNodeAndGoToFirstChild only expands or only goes to first child .

p.contract()
c.expandNodeAndGoToFirstChild()
assert c.p == p.firstChild()
</t>
<t tx="ekr.20201128164717.213"></t>
<t tx="ekr.20201128164717.214">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.215">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.216">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.217">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.218">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.219">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.22">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.220">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.221">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.222">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.223">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.224">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.225">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.226">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.227">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.228">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.229">first line
line 1
    line_24a a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.23">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.230">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.231">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.232">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.233">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.234">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.235">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.236">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.237">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.238">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.239">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.24">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.240">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.241">first line
line 1
    line a   
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.242"></t>
<t tx="ekr.20201128164717.245"></t>
<t tx="ekr.20201128164717.246"></t>
<t tx="ekr.20201128164717.247"></t>
<t tx="ekr.20201128164717.248"></t>
<t tx="ekr.20201128164717.249"></t>
<t tx="ekr.20201128164717.25">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.250"></t>
<t tx="ekr.20201128164717.251">@pagewidth 80
    # Required for external unit test.

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.252">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.253">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially
declared disasters are weather related,
leading to around 500 deaths per year
and nearly $14 billion in damage.
StormReady, a program
started in 1999 in Tulsa, OK,
helps arm America's
communities with the communication and
safety skills needed to save lives and
property--before and during the event.
StormReady helps community leaders and
emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.254">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.255">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.256">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.257">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.258">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.259">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.26">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.260">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.261">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.262">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.263">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.264">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.265">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.266">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.267">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.268">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.269">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.27">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.270">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.271">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.272">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.273">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.274">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.275">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.276">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.277">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.278">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.279">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.28">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.280">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.281">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.282">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.283">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.284">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.285">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.286">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.287">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.288">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.289">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.29">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.290">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.291">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.292">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.293">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.294">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.295">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.296">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.297">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.298">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.299">p = c.p.copy()
c.selectPosition(p.threadBack())
p1 = c.p
c.goPrevVisitedNode()
p2 = c.p
c.goNextVisitedNode()
p3 = c.p
</t>
<t tx="ekr.20201128164717.3">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.30">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.300">result = c.helpCommands.getBindingsForCommand('help')
if not result:
    self.skipTest('no settings')
assert result.strip().lower()=='f1', repr(result)
</t>
<t tx="ekr.20201128164717.301">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.302">first line
line 1
    line a
        line b
        line c
last line
</t>
<t tx="ekr.20201128164717.303">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.304">first line
line 1
    line a
        line b
        line c
last line
</t>
<t tx="ekr.20201128164717.305">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.306">first line
	line 1
	    line a
	        line b
	line c
last line
</t>
<t tx="ekr.20201128164717.307">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.308">first line
	line 1
	    line a
	        line b
	line c
last line
</t>
<t tx="ekr.20201128164717.309">c.editCommands.ccolumn = 4 # Set the comment column
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.31">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.310">first line
    line b
last line
</t>
<t tx="ekr.20201128164717.311">first line
line b
last line
</t>
<t tx="ekr.20201128164717.312">first line
    line b
last line
</t>
<t tx="ekr.20201128164717.313">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.314">first li
ne
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.315">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.316">first li
ne
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.317">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.318">first() line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.319">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.32">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.320">first() line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.321">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.322">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.323">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.324">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.325">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.326">This is the first sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.327">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.328">This is the first sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.329">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.33">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.330">This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.331">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.332">This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.333"># To do: use tables as in the clean-c test.
</t>
<t tx="ekr.20201128164717.334">child = g.findNodeInChildren(c, p, 'syntax-error')
assert child, 'no child'
try:
    c.goToScriptLineNumber(1, child)
finally:
    p.contract()
    c.selectPosition(p)
    c.redraw()
</t>
<t tx="ekr.20201128164717.335">@language python
def spam:
    pass
</t>
<t tx="ekr.20201128164717.336">import sys
# Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
if not sys.platform.startswith('win'):
    self.skipTest('Requires Windows')
trace = False
h = '@auto unittest/at-auto-md-line-number-test.md'
root = g.findNodeAnywhere(c, h)
assert root
s = c.gotoCommands.get_external_file_with_sentinels(root)
if trace:
    print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
for n in range(20):
    p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
    if found:
        if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
    else:
        if trace: print('not found: %s' % (n+1))
        assert n == 8, n
        break
</t>
<t tx="ekr.20201128164717.337"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-org unittest/at-auto-org-line-number-test.org'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20201128164717.338"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@auto-otl unittest/at-auto-otl-line-number-test.otl'
    root = g.findNodeAnywhere(c, h)
    assert root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % n)
            assert n == 5, n
            break
</t>
<t tx="ekr.20201128164717.339">import sys
# Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
elif sys.platform.startswith('win'):
    trace = False
    root = p.parent().parent()
    # h = '@auto unittest/at-auto-line-number-test.py'
    h = '@auto unittest/at-auto-unit-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(25):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 12, n
            if trace: print('not found: %s' % (n+1))
            break
else:
    self.skipTest('Skip on Linux')
</t>
<t tx="ekr.20201128164717.34">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.340"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.c'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    lines = g.splitLines(s)
    stripped_lines = [z for z in lines if not z.startswith('//@')]
    if trace:
        # g.printList(stripped_lines)
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(lines)]))
    table = (
        # n is the 1-based offset of the *stripped* lines.
        # Directives do not appear in @clean files.
        # (1,     '@language c'),
        # (2,     '@tabwidth -4'),
        (3,     '// before @others // line 1'),
        # (4,     '@others'),
        # spam node.
        (1,     'def spam(): // line 2'),
        (2,     '    pass'),
        # eggs node.
        (1,    'def eggs(): // line 4'),
        (2,    '    pass'),
        # resume top node.
        (5,    '// last line: line 6'),
    )
    for n, data in enumerate(table):
        offset, line = data
        p, offset2, found = c.gotoCommands.find_file_line(n+1, p=target)
        assert offset == offset2, 'expected offset %s, got %s %r' % (
            offset, offset2, p and p.h)
    p, offset, found = c.gotoCommands.find_file_line(15, p=target)
    assert not found
</t>
<t tx="ekr.20201128164717.341"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@clean unittest/at-clean-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20201128164717.342"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.c'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 10, n
            if trace: print('not found: %s' % n+1)
            break
</t>
<t tx="ekr.20201128164717.343"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    s = c.gotoCommands.get_external_file_with_sentinels(target)
    if trace:
        print(''.join(['%3s %s' % (i, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=target)
        if found:
            if trace: print('found %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            assert n == 10, n
            if trace: print('not found: %s' % n+1)
            break
</t>
<t tx="ekr.20201128164717.344"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    trace = False
    h = '@nosent unittest/at-nosent-line-number-test.py'
    root = g.findNodeAnywhere(c, h)
    assert root
    assert root.isAtNoSentFileNode(), root
    s = c.gotoCommands.get_external_file_with_sentinels(root)
    if trace:
        print(''.join(['%3s %s' % (i+1, s) for i, s in enumerate(g.splitLines(s))]))
    for n in range(20):
        p, offset, found = c.gotoCommands.find_file_line(n+1, p=root)
        if found:
            if trace: print('found: %2s %2s %s' % (n+1, offset, p and p.h))
        else:
            if trace: print('not found: %s' % (n+1))
            assert n == 6, n
            break
</t>
<t tx="ekr.20201128164717.345"># Not valid for external tests: uses @&lt;file&gt; node.
if g.app.isExternalUnitTest or g.in_bridge:
    self.skipTest('Can not be run externally')
else:
    root = p.parent().parent()
    h = '@file unittest/at-file-line-number-test.py'
    target = g.findNodeAnywhere(c, h)
    assert target, 'no target'
    gnx = target.v.fileIndex
    assert gnx
    found = c.gotoCommands.find_gnx(root, gnx, h)
    assert found, 'not found'
</t>
<t tx="ekr.20201128164717.346">c.gotoCommands.success(lines=['a', 'b'], n=3, n2=3, p=p)
c.gotoCommands.fail(lines=['a', 'b'], n=3, root=p)

</t>
<t tx="ekr.20201128164717.347"></t>
<t tx="ekr.20201128164717.348"># First, we must remove the trailing newline from the 'after' line.
h = 'after sel=3.6,3.6'
p2 = g.findNodeInTree(c,p,h)
assert p2,h
s = p2.b
if s.endswith('\n'):
    p2.b = p2.b[:-1]
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.349">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.35">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.350">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.351">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.352">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.353">line 1
line 2

</t>
<t tx="ekr.20201128164717.354">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.355">line 1
line 2

</t>
<t tx="ekr.20201128164717.356">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.357">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.358">line 1
line 2
line 3
line 4
</t>
<t tx="ekr.20201128164717.359">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.36">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.360">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.361">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.362">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.363">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.364"></t>
<t tx="ekr.20201128164717.365"># First, we must remove the trailing newline from the 'after' line.
h = 'after sel=3.6,3.6'
p2 = g.findNodeInTree(c,p,h)
assert p2,h
s = p2.b
if s.endswith('\n'):
    p2.b = p2.b[:-1]
c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.366">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.367">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.368">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.369">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.37">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.370">line 1
line 2line 3
</t>
<t tx="ekr.20201128164717.371">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.372">line 1
line 2line 3
</t>
<t tx="ekr.20201128164717.373">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.374">line 1
# The next line contains two trailing blanks.
line 3line 4
</t>
<t tx="ekr.20201128164717.375">line 1
# The next line contains two trailing blanks.
line 3  
line 4
</t>
<t tx="ekr.20201128164717.376">line 1
# The next line contains two trailing blanks.
line 3line 4
</t>
<t tx="ekr.20201128164717.377">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.378">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.379">line 1
line 2
line 3
line 4
</t>
<t tx="ekr.20201128164717.38">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.380">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.381">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.382">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.383">line 1
line 2

line 4
</t>
<t tx="ekr.20201128164717.384">line 1
line 2
line 4
</t>
<t tx="ekr.20201128164717.385">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.386">line 1
li
line 3
</t>
<t tx="ekr.20201128164717.387">line 1
line 2
line 3
</t>
<t tx="ekr.20201128164717.388">line 1
li
line 3
</t>
<t tx="ekr.20201128164717.389"></t>
<t tx="ekr.20201128164717.39">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.390">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.391">first line
line 1
line c
    line a
        line b
last line
</t>
<t tx="ekr.20201128164717.392">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.393">first line
line 1
line c
    line a
        line b
last line
</t>
<t tx="ekr.20201128164717.394">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.395">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.396">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.397">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.398"># Test of bug 799695: colorizer bug after move-lines-up into a docstring

# import os ; os.system('cls')

n = c.frame.body.colorizer.full_recolor_count

c.testManager.runEditCommandTest(p)

# Not an effective test, even though the bug fix was to call
# c.recolor_now(incremental=False)

# g.trace(n,c.frame.body.colorizer.full_recolor_count)

# assert c.frame.body.colorizer.full_recolor_count &gt; n
</t>
<t tx="ekr.20201128164717.399">@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
</t>
<t tx="ekr.20201128164717.4">first line
 line 1
     line a
 line b
last line
</t>
<t tx="ekr.20201128164717.40">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.400">@language python
def test():
    """ a
    b
    c
    """
    print 1
    
    print 2
</t>
<t tx="ekr.20201128164717.401">@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
</t>
<t tx="ekr.20201128164717.402">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.403">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.404">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.405">first (line)
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.406">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.407">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.408">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.409">first line
line 1
    (line )a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.41">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.410">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.411">first line
line 1
    
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.412">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.413">first line
line 1
    
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.414">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.415">a

b
</t>
<t tx="ekr.20201128164717.416">a

b
</t>
<t tx="ekr.20201128164717.417">a

b
</t>
<t tx="ekr.20201128164717.418">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.419">a

b
</t>
<t tx="ekr.20201128164717.42">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.420">a

b
</t>
<t tx="ekr.20201128164717.421">a

b
</t>
<t tx="ekr.20201128164717.422">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.423">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20201128164717.424">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.425">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20201128164717.426">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.427">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.428">before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
</t>
<t tx="ekr.20201128164717.429">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.43">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.430">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.431">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.432">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.433">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.434">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.435">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.436">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.437">before
aaabbb
aaabbb
aaabbb
aaabbb
after
</t>
<t tx="ekr.20201128164717.438">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.439">before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
</t>
<t tx="ekr.20201128164717.44">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.440">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.441">before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
</t>
<t tx="ekr.20201128164717.442">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.443">before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
</t>
<t tx="ekr.20201128164717.444">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.445">before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
</t>
<t tx="ekr.20201128164717.446">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.447">before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
</t>
<t tx="ekr.20201128164717.448">before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
</t>
<t tx="ekr.20201128164717.449">before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
</t>
<t tx="ekr.20201128164717.45">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.450">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.451">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.452">first line

line 1
    line a
        line b

line c
last line
</t>
<t tx="ekr.20201128164717.453">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.454">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.455">first line

line 1
   line a
       line b

line c
last line
</t>
<t tx="ekr.20201128164717.456">first line

line 1
    line a
        line b

line c
last line
</t>
<t tx="ekr.20201128164717.457">first line

line 1
   line a
       line b

line c
last line
</t>
<t tx="ekr.20201128164717.458">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.459">first line
line 1
line a
    line b
line c
last line
</t>
<t tx="ekr.20201128164717.46">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.460">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.461">first line
line 1
line a
    line b
line c
last line
</t>
<t tx="ekr.20201128164717.462">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.463">
last line
line c
        line b
    line a
line 1
first line
</t>
<t tx="ekr.20201128164717.464">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.465">
last line
line c
        line b
    line a
line 1
first line
</t>
<t tx="ekr.20201128164717.466">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.467">z
x
e
d
a
</t>
<t tx="ekr.20201128164717.468">a
d
e
z
x
</t>
<t tx="ekr.20201128164717.469">z
x
e
d
a
</t>
<t tx="ekr.20201128164717.47">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.470">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.471">z
Y
X
c
b
A
</t>
<t tx="ekr.20201128164717.472">c
A
z
X
Y
b
</t>
<t tx="ekr.20201128164717.473">z
Y
X
c
b
A
</t>
<t tx="ekr.20201128164717.474">@first # -*- coding: utf-8 -*-
@language python

try:
    ec = c.editCommands ; w = c.frame.body.wrapper
    s = w.getAllText()

    # This strings tests unicode, paren matching, and auto-indentation.
    u = '(a\u00c9\u03a9B\u3045\u4e7cz):\n' # '(aBE|cz):\n'
    u = '(pdq):\n'
    w.setInsertPoint(len(s))
    for char in u:
        binding = 'Return' if char == '\n' else char
        event = g.app.gui.create_key_event(c,char=char,binding=binding,w=w)
        ec.selfInsertCommand(event)
    result = w.getAllText()
    assert result.endswith('    '),'result:\n%s' % result
    # Test of autocompleter.
finally:
    if 1:
        w.setAllText(s)
        p.setBodyString(s)
        # g.trace(repr(s))
        c.recolor()

# end:
</t>
<t tx="ekr.20201128164717.475">@language python
@tabwidth -4

try:
    ec = c.editCommands ; w = c.frame.body.wrapper
    s = w.getAllText()
    w.setSelectionRange(len(s)-9,len(s)-6)
    event = g.app.gui.create_key_event(c, binding='Tab', char='\t', w=w)
    ec.selfInsertCommand(event)
    result = w.getAllText()
    assert result.endswith('\n    ###abcdef\n'),'result\n%s' % (repr(result))
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor_now()
    
###abcdef
</t>
<t tx="ekr.20201128164717.476"># xxxx.yyyy

s = p.b
w = c.frame.body.wrapper
w.setSelectionRange(2,11)
c.editCommands.setFillPrefix(event=None)
prefix = c.editCommands.fillPrefix
assert prefix == 'xxxx.yyyy',repr(prefix)
</t>
<t tx="ekr.20201128164717.477">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.478">        line b
    line a
first line
last line
line 1
line c
</t>
<t tx="ekr.20201128164717.479">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.48">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.480">        line b
    line a
first line
last line
line 1
line c
</t>
<t tx="ekr.20201128164717.481">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.482">first line
        line b
    line a
line 1
line c
last line
</t>
<t tx="ekr.20201128164717.483">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.484">first line
        line b
    line a
line 1
line c
last line
</t>
<t tx="ekr.20201128164717.485">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.486">A
B
c
x
z
</t>
<t tx="ekr.20201128164717.487">x
z
A
c
B
</t>
<t tx="ekr.20201128164717.488">A
B
c
x
z
</t>
<t tx="ekr.20201128164717.489">c.sortRecentFiles()
</t>
<t tx="ekr.20201128164717.49">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.490">child = p.firstChild()
assert child.h == 'b','fail 1'
try:
    c.selectPosition(child)
    c.sortSiblings()
    c.redraw_now()
    child = p.firstChild()
    assert child.h == 'a'
    child = child.next()
    assert child.h == 'b'
    child = child.next()
    assert child.h == 'c'
    assert not child.next()
finally:
    c.undoer.undo()
    p.contract()
    c.redraw(p)
</t>
<t tx="ekr.20201128164717.491"></t>
<t tx="ekr.20201128164717.492"></t>
<t tx="ekr.20201128164717.493"></t>
<t tx="ekr.20201128164717.494">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.495">first
 line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.496">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.497">first
 line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.498">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.499">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.5">first line
line 1
    line a
line b
last line
</t>
<t tx="ekr.20201128164717.50">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.500">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.501">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.502">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.503">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.504">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.505">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.506">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.507">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.508">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.509">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.51">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.510">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.511">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.512">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.513">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.514">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.515">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20201128164717.516">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.517">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20201128164717.518">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.519">frist line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.52">if a:
    b = 'xyz'
</t>
<t tx="ekr.20201128164717.520">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.521">frist line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.522">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.523">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.524">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.525">line 1
first line
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.526">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.527">first line
before foo += bar2 after
last line
</t>
<t tx="ekr.20201128164717.528">first line
before bar2 += foo after
last line
</t>
<t tx="ekr.20201128164717.529">first line
before foo += bar2 after
last line
</t>
<t tx="ekr.20201128164717.53">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.530">from leo.core import leoBeautify
cpp = leoBeautify.CPrettyPrinter(c)
# ts2p = c.convertCommands.TS_To_Python(c)
fn = 'typescript tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)
aList = cpp.tokenize(p2.b)
assert aList
# bts2p.convertCodeList(aList)
# s = ''.join(aList)
</t>
<t tx="ekr.20201128164717.531">@language javascript

public attemptIncrementalUpdateUnit(previousScript: Script,scriptId: string,newSourceText: ISourceText,editRange: ScriptEditRange): UpdateUnitResult
    self.logger.log("attemptIncrementalUpdateUnit(\"" + scriptId + "\")")
    if editRange === None:
        throw Error("editRange should be valid")
    var scope1 = self.getEnclosingScopeContextIfSingleScopeEdit(previousScript,scriptId,newSourceText,editRange)
    if scope1 === None:
        return None
    var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta
    # Heuristic: if the range to reparse is too big,bail out.
    # This is because a full parse will be faster than an incremental parse followed by all the necessary fix-ups
    if newScopeLength &gt;= newSourceText.getLength()/ 2:
        self.logger.log("  Bailing out because range of scope to reparse(" + newScopeLength + " characters)is greater than half the size of the source text")
        return None
    # Capture parsing errors so that they are part of "updateResult"
    var parseErrors: TypeScript.ErrorEntry:[] = []
    var errorCapture = function(minChar: number,charLen: number,message: string,unitIndex: number): void
        parseErrors.push(TypeScript.ErrorEntry:(unitIndex,minChar,minChar + charLen,message))
    var quickParseResult = TypeScript.quickParse(self.logger,scope1.scopeStartAST,newSourceText,scope1.scopeStartAST.minChar,scope1.scopeStartAST.minChar + newScopeLength,errorCapture)
    if quickParseResult.endLexState != TypeScript.LexState.Start:
        self.logger.log("  Bailing out because scope contains unterminated comment")
        return None
    var scriptFragment = quickParseResult.Script
    if scriptFragment.vars.members.length !== 0:
        self.logger.log("  Bailing out because new source text defines variables")
        return None
    #if(scriptFragment.scopes.members.length !== 1)
    #    logger.log("  Bailing out because new source text defines more than one scope(or none)");
    #    return null;
    #
    # This detects adding close curlies,since they have the side effect of having the parser
    # parse more members in the scope range.
    if scriptFragment.bod.members.length !== 1:
        self.logger.log("  Bailing out because new source text defines more than one scope(or none)")
        return None
    var oldScope = scope1.scopeStartAST
    var newScope = scriptFragment.bod.members[0]
    if oldScope.nodeType != newScope.nodeType:
        self.logger.log("  Bailing out because new source text does not define the same scope type as the existing scope")
        return None
    if not (&lt;any&gt;oldScope).leftCurlyCount or not (&lt;any&gt;oldScope).rightCurlyCount:
        self.logger.log("  Bailing out because sopce doesn't have left/right curly count")
        return None
    if(&lt;any&gt;oldScope).leftCurlyCount !==(&lt;any&gt;newScope).leftCurlyCount:
        self.logger.log("  Bailing out because new source text contains more(or fewer)left curly braces")
        return None
    if(&lt;any&gt;oldScope).rightCurlyCount !==(&lt;any&gt;newScope).rightCurlyCount:
        self.logger.log("  Bailing out because new source text contains more(or fewer)right curly braces")
        return None
    if newScope.minChar !== 0:
        self.logger.log("  Bailing out because new function declaration does not start at position 0")
        return None
    if newScope.limChar !== newScopeLength:
        self.logger.log("  Bailing out because new function declaration does not end at the new end position")
        return None
    return TypeScript.UpdateUnitResult.singleScopeEdits(previousScript,scriptFragment,oldScope,newScope,editRange,parseErrors)
</t>
<t tx="ekr.20201128164717.532">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.533">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.534">first line
line 1
	line a
		line b
line c
last line
</t>
<t tx="ekr.20201128164717.535">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.536">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.537">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.538">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.539">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.54">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.540">c.testManager.runEditCommandTest(p)
assert g.app.unitTestDict.get('colorized')
</t>
<t tx="ekr.20201128164717.541">first line
line 1
    LINE a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.542">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.543">first line
line 1
    LINE a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.544"></t>
<t tx="ekr.20201128164717.545"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.546">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.547">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.548">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.549"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.55">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.550">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.551">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.552">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.553"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.554">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.555">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.556">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.557"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.558">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.559">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.56">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.560">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.561"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.562">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
</t>
<t tx="ekr.20201128164717.563">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
</t>
<t tx="ekr.20201128164717.564">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
</t>
<t tx="ekr.20201128164717.565"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.566">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.567">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.568">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.569"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.57">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.570">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.571">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.572">@pagewidth 40
'''
docstring.
'''
</t>
<t tx="ekr.20201128164717.573"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.574">@pagewidth 40
'''
docstring. more docstring.
'''
</t>
<t tx="ekr.20201128164717.575">@pagewidth 40
'''
docstring.
more docstring.
'''
</t>
<t tx="ekr.20201128164717.576">@pagewidth 40
'''
docstring. more docstring.
'''
</t>
<t tx="ekr.20201128164717.577"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.578">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.579">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.58">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.580">- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.581"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.582">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.583">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.584">A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.585"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.586">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.587">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.588">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
</t>
<t tx="ekr.20201128164717.589"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.59">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.590">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.591">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.592">1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.593"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.594">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.595">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.596">2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
</t>
<t tx="ekr.20201128164717.597"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.598">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.599">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.6">first line
 line 1
     line a
 line b
last line
</t>
<t tx="ekr.20201128164717.60">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.600">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.601"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.602">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.603">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.604">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.605"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.606">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.607">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.608">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
</t>
<t tx="ekr.20201128164717.609"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.61">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.610">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.611">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.612">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.613"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.614">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.615">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.616">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
</t>
<t tx="ekr.20201128164717.617"># Required when running tests externally
@language plain
@pagewidth 40
@tabwidth 8

c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.618">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
</t>
<t tx="ekr.20201128164717.619">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.

Next Paragraph.
</t>
<t tx="ekr.20201128164717.62">first lie
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.620">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
</t>
<t tx="ekr.20201128164717.621"></t>
<t tx="ekr.20201128164717.622">ac = c.abbrevCommands
assert ac
if c.abbrev_place_start is None or c.abbrev_place_end is None:
    self.skipTest('no abbreviation settings') # #1345.
child = g.findNodeInTree(c,p,'child')
assert child
old_b = child.b
try:
    i,j,val = 0,0,child.b
    # ac.make_script_substitutions(i,j,val)
    # ac.find_place_holder(child,True)
    new_s,i,j = ac.next_place(child.b,offset=0)
    assert i == 34 and j == 40,(i,j)
    new_s2,i,j = ac.next_place(new_s,offset=40)
    assert i == 54 and j == 58,(i,j)
finally:
    child.b = old_b
</t>
<t tx="ekr.20201128164717.623">def spam ():
    """None - Return &lt;|return|&gt;
    """

    &lt;|code|&gt;
</t>
<t tx="ekr.20201128164717.624">f = c.abbrevCommands.addAbbrevHelper
d = c.abbrevCommands.abbrevs

# New in Leo 4.10: whitespace (blank,tab,newline) *is* significant in definitions.
table = (
    ('ut1','ut1=aa','aa'),
    # ('ut2','ut2 =bb','bb'),
    ('ut3','ut3=cc=dd','cc=dd'),
    ('ut4','ut4= ee',' ee'),
    ('ut5','ut5= ff = gg',' ff = gg'),
    ('ut6','ut6= hh==ii',' hh==ii'),
    ('ut7','ut7=j=k','j=k'),
    ('ut8','ut8=l==m','l==m'),
    ('@ut1','@ut1=@a','@a'),
)

for name,s,expected in table:
    for s2,kind in ((s,'(no nl)'),(s+'\n','(nl)')):
        f(s2,tag='unit-test')
        result,tag = d.get(name,(None,None),)
        assert result==expected, '%s &lt;%s&gt; expected &lt;%s&gt;, got &lt;%s&gt;' % (
            kind,s,expected,result)
</t>
<t tx="ekr.20201128164717.625"># TARGETWORD

w = c.frame.body.wrapper

for (which,result) in (('cap','Targetword'),('low','targetword'),('up','TARGETWORD')):
    w.setInsertPoint(5)
    c.editCommands.capitalizeHelper(event=None,which=which,undoType='X')
    s = w.getAllText()
    word = s[2:12]
    assert word == result, 'Expected %s, got: %s' % (result,repr(word))
    i = w.getInsertPoint()
    assert i == 5, 'Expected 5, got: %d' % i
</t>
<t tx="ekr.20201128164717.626"># A totally wimpy test.
# And it somehow prints a newline to the console.
if 0:
    c.abbrevCommands.dynamicExpandHelper(event=None,prefix='',aList=[],w=None)
</t>
<t tx="ekr.20201128164717.627">ec = c.editCommands ; w = c.frame.body.wrapper

for i,j,python in (
    # ('1.0','4.5',False),
    (5,50,True),
):
    extend = True
    ec.moveSpot = None # It's hard to init this properly.
    ec.extendHelper(w,extend,j)
    i2,j2 = w.getSelectionRange()
    #assert 0==i2, 'Expected i=%s, got %s' % (repr(i),repr(i2))
    #assert j==j2, 'Expected j=%s, got %s' % (repr(j),repr(j2))
</t>
<t tx="ekr.20201128164717.628"># start
# targetWord

e = c.editCommands
k = c.k
w = c.frame.body.wrapper
w.setInsertPoint(0)
k.arg = 't' # 'targetWord'
e.w = w
e.oneLineFlag = False
e.findWord1(event=None)
i,j = w.getSelectionRange()
assert i == 10, 'expected 10, got %s' % (i)
</t>
<t tx="ekr.20201128164717.629"># targetWord
e = c.editCommands
k = c.k
w = c.frame.body.wrapper
for val in (True,False):
    k.arg = 't' # 'targetWord'
    w.setInsertPoint(0)
    e.w = w
    e.oneLineFlag = val
    f = e.findWord1(event=None)
    i,j = w.getSelectionRange()
    assert i == 2, 'expected 2, got %s' % (i)
    # s = w.getAllText()
    # ch = s[i]
    # assert word == 'targetWord', 'got: %s' % word

</t>
<t tx="ekr.20201128164717.63">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.630">vr = c.helpCommands.helpForMinibuffer()
if not vr:
    self.skipTest('no vr plugin')
</t>
<t tx="ekr.20201128164717.631">ec = c.editCommands ; w = c.frame.body.wrapper

for i,j,python in (
    #('1.0','4.5',False),
    (5,50,True),
):
    event = None ; extend = True ; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveToHelper (event,j,extend)
    i2,j2 = w.getSelectionRange()
    assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
    assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
    w.setSelectionRange(0,0,insert=None)
</t>
<t tx="ekr.20201128164717.632">ec = c.editCommands ; w = c.frame.body.wrapper

for i,result,direction in (('5.8','4.8','up'),('5.8','6.8','down')):
    event = None ; extend = False; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveUpOrDownHelper (event,direction,extend)
    i2,j2 = w.getSelectionRange()
    if 1:
        break
    else:
        assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
        assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
        w.setSelectionRange(0,0,insert=None)
</t>
<t tx="ekr.20201128164717.633">ec = c.editCommands
w = c.frame.body.wrapper

for direction in ('up','down'):
    for distance in ('line','page','half-page'):
        event = g.app.gui.create_key_event(c,w=w)
        ec.scrollHelper(event,direction,distance)
</t>
<t tx="ekr.20201128164717.634">w = c.frame.body.wrapper
ec = c.editCommands

for spot,result in (('1.0',0),(5,5)):
    ec.setMoveCol(w,spot)
    assert ec.moveSpot == result
    assert ec.moveCol == result
</t>
<t tx="ekr.20201128164717.635"># These tests will be important when revising config code.
</t>
<t tx="ekr.20201128164717.636"># backward-find-character and find-character
# can't be tested this way because they require k.getarg.
# They pass hand tests.

&lt;&lt; define table &gt;&gt;

w = c.frame.body.wrapper
child = g.findNodeInChildren(c,p,'work')
assert child
c.selectPosition(child)

for commandName in table:
    # Put the cursor in the middle of the middle line
    # so all cursor moves will actually do something.
    w.setInsertPoint(15) # for move-past-close
    try:
        c.editCommands.extendMode = True
        c.keyHandler.simulateCommand(commandName)
        i,j = w.getSelectionRange()
        assert i != j,'i == j: %s %s' % (i,commandName)
    finally:
        c.editCommands.extendMode = False

</t>
<t tx="ekr.20201128164717.637"># Cursor movement commands affected by extend mode.
# The x-extend-selection commands are not so affected.
table = (
    'back-to-indentation',
    'back-to-home',
    'back-char',
    'back-page',
    'back-paragraph',
    'back-sentence',
    'back-word',
    'beginning-of-buffer',
    'beginning-of-line',
    'end-of-buffer',
    'end-of-line',
    'forward-char',
    'forward-page',
    'forward-paragraph',
    'forward-sentence',
    'forward-end-word',
    'forward-word',
    'move-past-close',
    'next-line',
    'previous-line',
)
</t>
<t tx="ekr.20201128164717.638">line 1.
line 2(xxx).
line 3.
</t>
<t tx="ekr.20201128164717.639">if g.app.inBridge:
    self.skipTest('in bridge')
k = c.k
colorizer = c.frame.body.getColorizer()
ed = c.editCommands
# These don't set ivars
    # 'toggle-active-pane'),
    # 'toggle-angle-brackets',
    # 'toggle-input-state'),
    # 'toggle-mini-buffer'),
    # 'toggle-split-direction'),
table = [
    (k,'abbrevOn','toggle-abbrev-mode'),
    (ed,'extendMode','toggle-extend-mode'),
]
# Not valid for external tests.
table2 = [
    (k,'enable_autocompleter','toggle-autocompleter'),
    (k,'enable_calltips','toggle-calltips'),
    (c,'sparse_find','toggle-find-collapses-nodes'),
    (colorizer,'showInvisibles','toggle-invisibles'),
    (c,'sparse_move','toggle-sparse-move'),
]
if not g.app.isExternalUnitTest:
    table.extend(table2)
for obj,ivar,command in table:
    val1 = getattr(obj,ivar)
    try:
        k.simulateCommand(command)
        val2 = getattr(obj,ivar)
        assert val2 == (not val1),'failed 1 %s' % command
        k.simulateCommand(command)
        val3 = getattr(obj,ivar)
        assert val3 == val1,'failed 2 %s' % command
    finally:
        setattr(obj,ivar,val1)
</t>
<t tx="ekr.20201128164717.64">first lie
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.640"># These are mysteriously fragile tests, so they go first
</t>
<t tx="ekr.20201128164717.641">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
s = 'ABC'
c.setBodyString(p,s)
try:
    c.bodyWantsFocus()
    w = c.frame.body.wrapper
    w.setInsertPoint(2)
    c.outerUpdate() # This fixed the problem.
    if 1:
        c.k.simulateCommand('delete-char')
    else:
        # This fails unless Delete is bound to delete-char
        g.app.gui.event_generate(c,'Delete','Delete',w) # Calls c.outerUpdate()
    assert p.b == s[:-1],'oops1: expected "AB", got %s' % p.b
    c.selectPosition(p.threadBack())
    c.selectPosition(p)
    assert p.b == s[:-1],'oops2: expected "AB", got %s' % p.b
finally:
    if 0:
        c.setBodyString(p,'')
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.642">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w
    w.setSelectionRange('end','end')
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.643">u = c.undoer
assert u
c.insertHeadline()
assert u.undoMenuLabel == 'Undo Insert Node',repr(u.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node',repr(u.undoMenuLabel)
</t>
<t tx="ekr.20201128164717.644">u = c.undoer
assert u
c.insertHeadlineBefore()
assert u.undoMenuLabel == 'Undo Insert Node Before',repr(u.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node Before',repr(u.undoMenuLabel)
</t>
<t tx="ekr.20201128164717.645">n = c.frame.tree.redrawCount
c.insertHeadline()
c.outerUpdate() # Not actually needed, but should not matter.
try:
    n2 = c.frame.tree.redrawCount
    if g.app.isExternalUnitTest:
        self.skipTest('Can not be run externally')
    else:
        assert n2 == n + 1,'redraws: %d' % (n2 - n)
finally:
    c.undoer.undo()
</t>
<t tx="ekr.20201128164717.646">import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
frame = c.frame
tree = frame.tree
canvas = tree.canvas
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        stroke = k.getStrokeForCommandName('paste-text')
        if stroke is None:
            self.skipTest('no binding for paste-text') # #1345
        k.manufactureKeyPressForCommandName(w, 'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + paste, 'oops2 got: %s' % p.h
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h, f"oops3 expected {h} got: {p.h}"
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.647">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
else:
    k = c.keyHandler
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w, 'Null w'
        paste = 'ABC'
        g.app.gui.replaceClipboardWith(paste)
        w.setSelectionRange('1.1','1.2')
        if g.app.gui.guiName() == 'curses':
            c.frame.pasteText(event=g.Bunch(widget=w))
        else:
            stroke = k.getStrokeForCommandName('paste-text')
            if stroke is None:
                self.skipTest('no binding for paste-text') # #1345
            k.manufactureKeyPressForCommandName(w,'paste-text')
            g.app.gui.event_generate(c,'\n','Return',w)
        assert p.h == h[0] + paste + h[2:]
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h, 'head mismatch'
    finally:
        if 1:
            c.setHeadString(p,h) # Essential
            c.redraw(p)
</t>
<t tx="ekr.20201128164717.648">import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
g.app.gui.set_focus(c,w)
w2 = g.app.gui.get_focus(c)
try:
    assert w
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        stroke = k.getStrokeForCommandName('paste-text')
        if stroke is None:
            self.skipTest('no binding for paste-text') # #1345
        k.manufactureKeyPressForCommandName(w,'paste-text')
        g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + paste,'Expected: %s, got %s' % (
        h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.649">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
w.setSelectionRange('end','end',insert='end')
paste = 'ABC'
g.app.gui.replaceClipboardWith(paste)
event = g.app.gui.create_key_event(c,w=w)
c.frame.pasteText(event)
# Move around and and make sure it doesn't change.
try:
    # g.trace('before select',w,w.getAllText())
    c.selectPosition(p.threadBack())
    assert p.h == h + paste,'oops1: expected: %s, got %s' % (h + paste,p.h)
    c.selectPosition(p)
    assert p.h == h + paste,'oops2: expected: %s, got %s' % (h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.65">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.650">h = '@test return ends editing of headline'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
guiName = g.app.gui.guiName()
wName = g.app.gui.widget_name(w)
assert wName.startswith('head'),'w.name:%s' % wName
g.app.gui.event_generate(c,'\n','Return',w)
c.outerUpdate()
assert w != c.get_focus(),'oops2: focus in headline'
</t>
<t tx="ekr.20201128164717.651">if g.in_bridge:
    self.skipTest('Not for TravisCI')
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    if g.app.gui.guiName() == 'curses':
        c.frame.pasteText(event=g.Bunch(widget=w))
    else:
        k.manufactureKeyPressForCommandName(w,'paste-text')
    c.selectPosition(p.visBack(c))
    assert p.h == h + paste
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h,'expected: %s, got: %s' % (
        h,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.652">if g.in_bridge:
    self.skipTest('Not for TravisCI')
import sys
if sys.platform.startswith('linux'):
    self.skipTest('Not for Linux')
if g.app.gui.guiName() == 'curses':
    self.skipTest('Not for curses gui')

k = c.k
if k.defaultUnboundKeyAction == 'insert':
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = c.testManager.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w
        w.setSelectionRange('end','end')
        # char, shortcut.
        g.app.gui.event_generate(c,'X','Shift+X',w)
        g.app.gui.event_generate(c,'Y','Shift+Y',w)
        g.app.gui.event_generate(c,'Z','Shift+Z',w)
        g.app.gui.event_generate(c,'\n','Return',w)
        expected = h + 'XYZ'
        assert p.h == expected, f"oops 1: expected {expected!r} got {p.h!r}"
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h, f"oops 2: expected {h!r} got {p.h!r}"
    finally:
        if 1:
            c.setHeadString(p, h) # Essential
            c.redraw(p)
</t>
<t tx="ekr.20201128164717.653">import sys
if sys.platform.startswith('linux'):
    self.skipTest('skip headline test')
if g.app.gui.guiName() == 'curses':
    # This could be adapted, but not now.
    self.skipTest('Not for curses gui')
k = c.k
if k.defaultUnboundKeyAction != 'insert':
    self.skipTest('defaultUnboundKeyAction != insert')
if not k.getStrokeForCommandName('undo'):
    self.skipTest('no settings')

frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make the node visible.
w = c.edit_widget(p)
try:
    assert w, 'oops1'
    wName = g.app.gui.widget_name(w)
    assert wName.startswith('head'),'w.name:%s' % wName
    w.setSelectionRange('end','end')
    g.app.gui.event_generate(c,'X','Shift+X',w)
    g.app.gui.event_generate(c,'Y','Shift+Y',w)
    g.app.gui.event_generate(c,'Z','Shift+Z',w)
    g.app.gui.event_generate(c,'\n','Return',w)
    assert p.h == h + 'XYZ',(
        'oops2: expected: %s, got: %s' % (
            h + 'XYZ',p.h))
    if g.app.gui.guiName() != 'nullGui':
        assert c.undoer.undoMenuLabel == 'Undo Typing','oops3: %s' % (
            c.undoer.undoMenuLabel)
    k.manufactureKeyPressForCommandName(w,'undo')
    if g.app.gui.guiName() != 'nullGui':
        assert c.undoer.redoMenuLabel == 'Redo Typing','oops4'
    assert p.h == h,'oops5 got: %s, expected: %s' % (
        p.h,h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.654">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.setBodyString(p,'a')
c.redraw(p) # To make node visible
c.bodyWantsFocus()
n = c.frame.tree.redrawCount
try:
    w = c.frame.body.wrapper
    g.app.gui.event_generate(c,'a','a',w)
    n2 = c.frame.tree.redrawCount
    assert n2 == n,'too many redraws: %d' % (n2-n)
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)
</t>
<t tx="ekr.20201128164717.655">h = 'Test headline abc'
p = c.testManager.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
body = 'This is a test'
c.setBodyString(p,body)

try:
    assert p.b == body
    c.insertHeadline()
    c.undoer.undo()
    assert p.b == body
finally:
    c.setBodyString(p,'')
</t>
<t tx="ekr.20201128164717.656"># Print does not work: it is redirected.
g.pr('\nEnd of typing tests')
</t>
<t tx="ekr.20201128164717.657"># Print does not work: it is redirected.
g.pr('\nEnd of leoEditCommands tests.')
</t>
<t tx="ekr.20201128164717.66">firstline
last line
</t>
<t tx="ekr.20201128164717.67">first line
last line
</t>
<t tx="ekr.20201128164717.68">firstline
last line
</t>
<t tx="ekr.20201128164717.69">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.7">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.70">first line
last lin
</t>
<t tx="ekr.20201128164717.71">first line
last line
</t>
<t tx="ekr.20201128164717.72">first line
last lin
</t>
<t tx="ekr.20201128164717.73">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.74">aaaa cccc dddd
</t>
<t tx="ekr.20201128164717.75">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20201128164717.76">aaaa cccc dddd
</t>
<t tx="ekr.20201128164717.77">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.78">aaaa bbcc dddd
</t>
<t tx="ekr.20201128164717.79">aaaa bbbb cccc dddd
</t>
<t tx="ekr.20201128164717.8">first line
    line 1
        line a
            line b
    line c
last line
</t>
<t tx="ekr.20201128164717.80">aaaa bbcc dddd
</t>
<t tx="ekr.20201128164717.81">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.82">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.83">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.84">Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
</t>
<t tx="ekr.20201128164717.85">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.86">This is the first sentence.  This
is the second sentence.
</t>
<t tx="ekr.20201128164717.87">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.88">This is the first sentence.  This
is the second sentence.
</t>
<t tx="ekr.20201128164717.89">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.9">first line
line 1
    line a
        line b
line c
last line
</t>
<t tx="ekr.20201128164717.90">This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
</t>
<t tx="ekr.20201128164717.91">This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
</t>
<t tx="ekr.20201128164717.92">This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
</t>
<t tx="ekr.20201128164717.93">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.94">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.95">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.96">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.97">c.testManager.runEditCommandTest(p)
</t>
<t tx="ekr.20201128164717.98">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128164717.99">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
</t>
<t tx="ekr.20201128165500.1">"""Convert old-style tests to new-style tests"""
g.cls()
import importlib
from leo.core import leoTest2
importlib.reload(leoTest2)

root = g.findTopLevelNode(c, 'unit-tests: leoEditCommands')
target = g.findTopLevelNode(c, 'new-tests')
if root and target:
    leoTest2.convert_leoEditCommands_tests(c, root, target)
else:
    print('Error: root and target nodes must be top-level nodes.')</t>
<t tx="ekr.20201128171127.1"></t>
<t tx="ekr.20201129092548.1">- Why is noscript interfering with leoflexx.py?

- Build Leovue.
</t>
<t tx="ekr.20201129132149.1"></t>
<t tx="ekr.20201130074836.1">def convert_leoEditCommands_tests(c, root, target):
    """
    Convert @test nodes to new-style tests.
    
    root:   A node containing (a copy of) tests from unitTest.leo.
    target: A node whose children will be the resulting tests.
            These nodes can then be copied to be children of a test class.
    """
    if not root or not target:
        print('Error: root and target nodes must be top-level nodes.', color='red')
        return
    # Be safe.
    if target.hasChildren():
        print('Please delete children of ', target.h, color='red')
        return
    converter = ConvertEditCommandsTests()
    count = 0
    for p in root.subtree():
        if p.h.startswith('@test') and 'runEditCommandTest' in p.b:
            converter.convert(p, target)
            count += 1
    c.redraw()
    print(f"converted {count} @test nodes", color='blue')
</t>
<t tx="ekr.20201202085332.1">def test_add_space_to_lines(self):
    """Test case for add-space-to-lines"""
    before_b = """\
first line
line 1
    line a
line b
last line
"""
    after_b = """\
first line
 line 1
     line a
 line b
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "4.6"),
        after_sel=("2.0", "4.7"),
        command_name="add-space-to-lines",
    )
</t>
<t tx="ekr.20201202085332.10">def test_back_to_home_at_start_of_line(self):
    """Test case for back-to-home (at start of line)"""
    before_b = """\
if a:
    b = 'xyz'
"""
    after_b = """\
if a:
    b = 'xyz'
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("2.4", "2.4"),
        command_name="back-to-home",
    )
</t>
<t tx="ekr.20201202085332.100">def test_rectangle_yank(self):
    """Test case for rectangle-yank"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.6"),
        command_name="rectangle-yank",
    )
</t>
<t tx="ekr.20201202085332.101">def test_remove_blank_lines(self):
    """Test case for remove-blank-lines"""
    before_b = """\
first line

line 1
    line a
        line b

line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "9.0"),
        after_sel=("1.0", "6.9"),
        command_name="remove-blank-lines",
    )
</t>
<t tx="ekr.20201202085332.102">def test_remove_space_from_lines(self):
    """Test case for remove-space-from-lines"""
    before_b = """\
first line

line 1
    line a
        line b

line c
last line
"""
    after_b = """\
first line

line 1
   line a
       line b

line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "9.0"),
        after_sel=("1.0", "9.0"),
        command_name="remove-space-from-lines",
    )
</t>
<t tx="ekr.20201202085332.103">def test_remove_tab_from_lines(self):
    """Test case for remove-tab-from-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
line a
    line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("1.0", "7.0"),
        command_name="remove-tab-from-lines",
    )
</t>
<t tx="ekr.20201202085332.104">def test_reverse_region(self):
    """Test case for reverse-region"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\

last line
line c
        line b
    line a
line 1
first line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("7.10", "7.10"),
        command_name="reverse-region",
    )
</t>
<t tx="ekr.20201202085332.105">def test_reverse_sort_lines(self):
    """Test case for reverse-sort-lines"""
    before_b = """\
a
d
e
z
x
"""
    after_b = """\
z
x
e
d
a
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "5.1"),
        after_sel=("1.0", "5.1"),
        command_name="reverse-sort-lines",
    )
</t>
<t tx="ekr.20201202085332.106">def test_reverse_sort_lines_ignoring_case(self):
    """Test case for reverse-sort-lines-ignoring-case"""
    before_b = """\
c
A
z
X
Y
b
"""
    after_b = """\
z
Y
X
c
b
A
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "6.1"),
        after_sel=("1.0", "6.1"),
        command_name="reverse-sort-lines-ignoring-case",
    )
</t>
<t tx="ekr.20201202085332.107">def test_sort_columns(self):
    """Test case for sort-columns"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
        line b
    line a
first line
last line
line 1
line c
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "6.2"),
        after_sel=("1.0", "7.0"),
        command_name="sort-columns",
    )
</t>
<t tx="ekr.20201202085332.108">def test_sort_lines(self):
    """Test case for sort-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
        line b
    line a
line 1
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "5.6"),
        after_sel=("2.0", "5.6"),
        command_name="sort-lines",
    )
</t>
<t tx="ekr.20201202085332.109">def test_sort_lines_ignoring_case(self):
    """Test case for sort-lines-ignoring-case"""
    before_b = """\
x
z
A
c
B
"""
    after_b = """\
A
B
c
x
z
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "5.1"),
        after_sel=("1.0", "5.1"),
        command_name="sort-lines-ignoring-case",
    )
</t>
<t tx="ekr.20201202085332.11">def test_back_to_home_at_indentation(self):
    """Test case for back-to-home (at indentation"""
    before_b = """\
if a:
    b = 'xyz'
"""
    after_b = """\
if a:
    b = 'xyz'
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.4", "2.4"),
        after_sel=("2.0", "2.0"),
        command_name="back-to-home",
    )
</t>
<t tx="ekr.20201202085332.110">def test_split_line(self):
    """Test case for split-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first
 line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.5", "1.5"),
        after_sel=("2.0", "2.0"),
        command_name="split-line",
    )
</t>
<t tx="ekr.20201202085332.111">def test_start_of_line(self):
    """Test case for start-of-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.4", "3.4"),
        command_name="start-of-line",
    )
</t>
<t tx="ekr.20201202085332.112">def test_start_of_line_2(self):
    """Test case for start-of-line (2)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.4", "3.4"),
        command_name="start-of-line",
    )
</t>
<t tx="ekr.20201202085332.113">def test_start_of_line_extend_selection(self):
    """Test case for start-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.4", "3.10"),
        command_name="start-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.114">def test_start_of_line_extend_selection_2(self):
    """Test case for start-of-line-extend-selection (2)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.1", "3.4"),
        command_name="start-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.115">def test_tabify(self):
    """Test case for tabify"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
	line a
		line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="tabify",
    )
</t>
<t tx="ekr.20201202085332.116">def test_transpose_chars(self):
    """Test case for transpose-chars"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
frist line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.2", "1.2"),
        after_sel=("1.2", "1.2"),
        command_name="transpose-chars",
    )
</t>
<t tx="ekr.20201202085332.117">def test_transpose_lines(self):
    """Test case for transpose-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
line 1
first line
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("2.10", "2.10"),
        command_name="transpose-lines",
    )
</t>
<t tx="ekr.20201202085332.118">def test_transpose_words(self):
    """Test case for transpose-words"""
    before_b = """\
first line
before bar2 += foo after
last line
"""
    after_b = """\
first line
before foo += bar2 after
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.9", "2.9"),
        after_sel=("2.11", "2.11"),
        command_name="transpose-words",
    )
</t>
<t tx="ekr.20201202085332.119">def test_untabify(self):
    """Test case for untabify"""
    before_b = """\
first line
line 1
	line a
		line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="untabify",
    )
</t>
<t tx="ekr.20201202085332.12">def test_back_to_home_at_end_of_line(self):
    """Test case for back-to-home (at end of line)"""
    before_b = """\
if a:
    b = 'xyz'
"""
    after_b = """\
if a:
    b = 'xyz'
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.12", "2.12"),
        after_sel=("2.4", "2.4"),
        command_name="back-to-home",
    )
</t>
<t tx="ekr.20201202085332.120">def test_upcase_region(self):
    """Test case for upcase-region"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "4.0"),
        after_sel=("3.0", "4.0"),
        command_name="upcase-region",
    )
</t>
<t tx="ekr.20201202085332.121">def test_upcase_word(self):
    """Test case for upcase-word"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    LINE a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.7", "3.7"),
        after_sel=("3.7", "3.7"),
        command_name="upcase-word",
    )
</t>
<t tx="ekr.20201202085332.122">def test_reformat_paragraph_list_1_of_5(self):
    """Test case for reformat-paragraph list 1 of 5"""
    before_b = """\
This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("4.0", "4.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.123">def test_reformat_paragraph_list_2_of_5(self):
    """Test case for reformat-paragraph list 2 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.0", "4.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.124">def test_reformat_paragraph_list_3_of_5(self):
    """Test case for reformat-paragraph list 3 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("10.0", "10.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.125">def test_reformat_paragraph_list_4_of_5(self):
    """Test case for reformat-paragraph list 4 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("10.0", "10.0"),
        after_sel=("13.0", "13.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.126">def test_reformat_paragraph_list_5_of_5(self):
    """Test case for reformat-paragraph list 5 of 5"""
    before_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
"""
    after_b = """\
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("13.0", "13.0"),
        after_sel=("15.1", "15.1"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.127">def test_reformat_paragraph_new_code_1_of_8(self):
    """Test case for reformat-paragraph new code 1 of 8"""
    before_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    after_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("2.0", "2.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.128">def test_reformat_paragraph_new_code_2_of_8(self):
    """Test case for reformat-paragraph new code 2 of 8"""
    before_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    after_b = """\
@pagewidth 40
'''
docstring.
'''
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.129">def test_reformat_paragraph_new_code_3_of_8(self):
    """Test case for reformat-paragraph new code 3 of 8"""
    before_b = """\
@pagewidth 40
'''
docstring.
more docstring.
'''
"""
    after_b = """\
@pagewidth 40
'''
docstring. more docstring.
'''
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "4.1"),
        after_sel=("4.0", "4.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.13">def test_back_word(self):
    """Test case for back-word"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.183", "1.183"),
        after_sel=("1.178", "1.178"),
        command_name="back-word",
    )
</t>
<t tx="ekr.20201202085332.130">def test_reformat_paragraph_new_code_4_of_8(self):
    """Test case for reformat-paragraph new code 4 of 8"""
    before_b = """\
- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    after_b = """\
- Point 1. xxxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 11.
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.131">def test_reformat_paragraph_new_code_5_of_8(self):
    """Test case for reformat-paragraph new code 5 of 8"""
    before_b = """\
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
  Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    after_b = """\
A. Point 2. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 22.
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "2.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.132">def test_reformat_paragraph_new_code_6_of_8(self):
    """Test case for reformat-paragraph new code 6 of 8"""
    before_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    after_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4  xxxxxxxxxxxxxxxxxxxxxxxxxxx
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("4.0", "4.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.133">def test_reformat_paragraph_new_code_7_of_8(self):
    """Test case for reformat-paragraph new code 7 of 8"""
    before_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    after_b = """\
1. Point 3. xxxxxxxxxxxxxxxxxxxxxxxxxxx
   Line 32.

2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.11", "2.11"),
        after_sel=("3.1", "3.1"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.134">def test_reformat_paragraph_new_code_8_of_8(self):
    """Test case for reformat-paragraph new code 8 of 8"""
    before_b = """\
2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    after_b = """\
2. Point 4 xxxxxxxxxxxxxxxxxxxxxxxxxxx
        Line 41.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("3.0", "3.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.135">def test_reformat_paragraph_paragraph_1_of_3(self):
    """Test case for reformat-paragraph paragraph 1 of 3"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    after_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("13.0", "13.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.136">def test_reformat_paragraph_paragraph_2_of_3(self):
    """Test case for reformat-paragraph paragraph 2 of 3"""
    before_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    after_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("13.0", "13.0"),
        after_sel=("25.0", "25.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.137">def test_reformat_paragraph_paragraph_3_of_3(self):
    """Test case for reformat-paragraph paragraph 3 of 3"""
    before_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?

Last paragraph.
"""
    after_b = """\
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?

Last paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("25.10", "25.10"),
        after_sel=("34.0", "34.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.138">def test_reformat_paragraph_simple_hanging_indent(self):
    """Test case for reformat-paragraph simple hanging indent"""
    before_b = """\
Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
"""
    after_b = """\
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.139">def test_reformat_paragraph_simple_hanging_indent_2(self):
    """Test case for reformat-paragraph simple hanging indent 2"""
    before_b = """\
Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.

Next paragraph.
"""
    after_b = """\
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.14">def test_back_word_extend_selection(self):
    """Test case for back-word-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.342", "3.342"),
        after_sel=("3.332", "3.342"),
        command_name="back-word-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.140">def test_reformat_paragraph_simple_hanging_indent_3(self):
    """Test case for reformat-paragraph simple hanging indent 3"""
    before_b = """\
Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.

Next Paragraph.
"""
    after_b = """\
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.

Next Paragraph.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("7.0", "7.0"),
        command_name="reformat-paragraph",
    )
</t>
<t tx="ekr.20201202085332.15">def test_backward_delete_char(self):
    """Test case for backward-delete-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first lie
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.9", "1.9"),
        after_sel=("1.8", "1.8"),
        command_name="backward-delete-char",
    )
</t>
<t tx="ekr.20201202085332.16">def test_backward_delete_char__middle_of_line(self):
    """Test case for backward-delete-char  (middle of line)"""
    before_b = """\
first line
last line
"""
    after_b = """\
firstline
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.6", "1.6"),
        after_sel=("1.5", "1.5"),
        command_name="backward-delete-char",
    )
</t>
<t tx="ekr.20201202085332.17">def test_backward_delete_char_last_char(self):
    """Test case for backward-delete-char (last char)"""
    before_b = """\
first line
last line
"""
    after_b = """\
first line
last lin
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.9", "2.9"),
        after_sel=("2.8", "2.8"),
        command_name="backward-delete-char",
    )
</t>
<t tx="ekr.20201202085332.18">def test_backward_delete_word_no_selection(self):
    """Test case for backward-delete-word (no selection)"""
    before_b = """\
aaaa bbbb cccc dddd
"""
    after_b = """\
aaaa cccc dddd
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.10", "1.10"),
        after_sel=("1.5", "1.5"),
        command_name="backward-delete-word",
    )
</t>
<t tx="ekr.20201202085332.19">def test_backward_delete_word_selection(self):
    """Test case for backward-delete-word (selection)"""
    before_b = """\
aaaa bbbb cccc dddd
"""
    after_b = """\
aaaa bbcc dddd
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.7", "1.12"),
        after_sel=("1.7", "1.7"),
        command_name="backward-delete-word",
    )
</t>
<t tx="ekr.20201202085332.2">def test_add_tab_to_lines(self):
    """Test case for add-tab-to-lines"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
    line 1
        line a
            line b
    line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "5.6"),
        after_sel=("2.0", "5.10"),
        command_name="add-tab-to-lines",
    )
</t>
<t tx="ekr.20201202085332.20">def test_backward_kill_paragraph(self):
    """Test case for backward-kill-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("7.0", "7.0"),
        command_name="backward-kill-paragraph",
    )
</t>
<t tx="ekr.20201202085332.21">def test_backward_kill_sentence(self):
    """Test case for backward-kill-sentence"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  This
is the second sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.2", "3.2"),
        after_sel=("2.23", "2.23"),
        command_name="backward-kill-sentence",
    )
</t>
<t tx="ekr.20201202085332.22">def test_backward_kill_word(self):
    """Test case for backward-kill-word"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.7", "3.7"),
        after_sel=("3.5", "3.5"),
        command_name="backward-kill-word",
    )
</t>
<t tx="ekr.20201202085332.23">def test_beginning_of_buffer(self):
    """Test case for beginning-of-buffer"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("5.56", "5.56"),
        after_sel=("1.0", "1.0"),
        command_name="beginning-of-buffer",
    )
</t>
<t tx="ekr.20201202085332.24">def test_beginning_of_buffer_extend_selection(self):
    """Test case for beginning-of-buffer-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.423", "3.423"),
        after_sel=("1.0", "3.423"),
        command_name="beginning-of-buffer-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.25">def test_beginning_of_line(self):
    """Test case for beginning-of-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.0", "3.0"),
        command_name="beginning-of-line",
    )
</t>
<t tx="ekr.20201202085332.26">def test_beginning_of_line_extend_selection(self):
    """Test case for beginning-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.10", "4.10"),
        after_sel=("4.0", "4.10"),
        command_name="beginning-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.27">def test_capitalize_word(self):
    """Test case for capitalize-word"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    Line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.6", "3.6"),
        after_sel=("3.6", "3.6"),
        command_name="capitalize-word",
    )
</t>
<t tx="ekr.20201202085332.28">def test_center_line(self):
    """Test case for center-line"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "9.0"),
        after_sel=("3.0", "9.0"),
        command_name="center-line",
    )
</t>
<t tx="ekr.20201202085332.29">def test_center_region(self):
    """Test case for center-region"""
    before_b = """\
Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
"""
    after_b = """\
Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "7.0"),
        after_sel=("1.0", "7.0"),
        command_name="center-region",
    )
</t>
<t tx="ekr.20201202085332.3">def test_back_char(self):
    """Test case for back-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.8", "3.8"),
        after_sel=("3.7", "3.7"),
        command_name="back-char",
    )
</t>
<t tx="ekr.20201202085332.30">def test_clean_lines(self):
    """Test case for clean-lines"""
    before_b = """\
# Should remove all trailing whitespace.

a = 2   
    
    b = 3
    c  = 4  
d = 5
e = 6  
x
"""
    after_b = """\
# Should remove all trailing whitespace.

a = 2

    b = 3
    c  = 4
d = 5
e = 6
x
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.0", "1.0"),
        command_name="clean-lines",
    )
</t>
<t tx="ekr.20201202085332.31">def test_clear_selected_text(self):
    """Test case for clear-selected-text"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line    line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.4", "4.4"),
        after_sel=("2.4", "2.4"),
        command_name="clear-selected-text",
    )
</t>
<t tx="ekr.20201202085332.32">def test_count_region(self):
    """Test case for count-region"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.4", "4.8"),
        after_sel=("2.4", "4.8"),
        command_name="count-region",
    )
</t>
<t tx="ekr.20201202085332.33">def test_delete_char(self):
    """Test case for delete-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
firstline
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.5", "1.5"),
        after_sel=("1.5", "1.5"),
        command_name="delete-char",
    )
</t>
<t tx="ekr.20201202085332.34">def test_delete_indentation(self):
    """Test case for delete-indentation"""
    before_b = """\
first line
    line 1
last line
"""
    after_b = """\
first line
line 1
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.8", "2.8"),
        after_sel=("2.4", "2.4"),
        command_name="delete-indentation",
    )
</t>
<t tx="ekr.20201202085332.35">def test_delete_spaces(self):
    """Test case for delete-spaces"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.2", "3.2"),
        after_sel=("3.0", "3.0"),
        command_name="delete-spaces",
    )
</t>
<t tx="ekr.20201202085332.36">def test_do_nothing(self):
    """Test case for do-nothing"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.0", "1.0"),
        command_name="do-nothing",
    )
</t>
<t tx="ekr.20201202085332.37">def test_downcase_region(self):
    """Test case for downcase-region"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "4.0"),
        after_sel=("3.0", "4.0"),
        command_name="downcase-region",
    )
</t>
<t tx="ekr.20201202085332.38">def test_downcase_word(self):
    """Test case for downcase-word"""
    before_b = """\
XYZZY line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
xyzzy line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.4", "1.4"),
        after_sel=("1.4", "1.4"),
        command_name="downcase-word",
    )
</t>
<t tx="ekr.20201202085332.39">def test_end_of_buffer(self):
    """Test case for end-of-buffer"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.3", "1.3"),
        after_sel=("7.0", "7.0"),
        command_name="end-of-buffer",
    )
</t>
<t tx="ekr.20201202085332.4">def test_back_char_extend_selection(self):
    """Test case for back-char-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.12", "4.12"),
        after_sel=("4.11", "4.12"),
        command_name="back-char-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.40">def test_end_of_buffer_extend_selection(self):
    """Test case for end-of-buffer-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.0", "7.0"),
        command_name="end-of-buffer-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.41">def test_end_of_line(self):
    """Test case for end-of-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.0"),
        after_sel=("1.10", "1.10"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.42">def test_end_of_line_2(self):
    """Test case for end-of-line 2"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("6.0", "6.0"),
        after_sel=("6.9", "6.9"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.43">def test_end_of_line_internal_blank_line(self):
    """Test case for end-of-line (internal blank line)"""
    before_b = """\
first line

line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line

line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("2.0", "2.0"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.44">def test_end_of_line_blank_last_line(self):
    """Test case for end-of-line (blank last line)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.45">def test_end_of_line_single_char_last_line(self):
    """Test case for end-of-line (single char last line)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
 
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
 
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("7.1", "7.1"),
        command_name="end-of-line",
    )
</t>
<t tx="ekr.20201202085332.46">def test_end_of_line_extend_selection(self):
    """Test case for end-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.10"),
        command_name="end-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.47">def test_end_of_line_extend_selection_blank_last_line(self):
    """Test case for end-of-line-extend-selection (blank last line)"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last non-blank line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.0", "7.0"),
        after_sel=("7.0", "7.0"),
        command_name="end-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.48">def test_exchange_point_mark(self):
    """Test case for exchange-point-mark"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.0", "1.10"),
        after_sel=("1.0", "1.10"),
        command_name="exchange-point-mark",
    )
</t>
<t tx="ekr.20201202085332.49">def test_extend_to_line(self):
    """Test case for extend-to-line"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.3", "3.3"),
        after_sel=("3.0", "3.10"),
        command_name="extend-to-line",
    )
</t>
<t tx="ekr.20201202085332.5">def test_back_paragraph(self):
    """Test case for back-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("6.7", "6.7"),
        command_name="back-paragraph",
    )
</t>
<t tx="ekr.20201202085332.50">def test_extend_to_paragraph(self):
    """Test case for extend-to-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("8.0", "13.33"),
        command_name="extend-to-paragraph",
    )
</t>
<t tx="ekr.20201202085332.51">def test_extend_to_sentence(self):
    """Test case for extend-to-sentence"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.5", "3.5"),
        after_sel=("1.395", "3.142"),
        command_name="extend-to-sentence",
    )
</t>
<t tx="ekr.20201202085332.52">def test_extend_to_word(self):
    """Test case for extend-to-word"""
    before_b = """\
first line
line 1
    line_24a a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line_24a a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.10", "3.10"),
        after_sel=("3.4", "3.12"),
        command_name="extend-to-word",
    )
</t>
<t tx="ekr.20201202085332.53">def test_finish_of_line(self):
    """Test case for finish-of-line"""
    before_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.12", "3.12"),
        after_sel=("3.9", "3.9"),
        command_name="finish-of-line",
    )
</t>
<t tx="ekr.20201202085332.54">def test_finish_of_line_2(self):
    """Test case for finish-of-line (2)"""
    before_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.9", "3.9"),
        command_name="finish-of-line",
    )
</t>
<t tx="ekr.20201202085332.55">def test_finish_of_line_extend_selection(self):
    """Test case for finish-of-line-extend-selection"""
    before_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a   
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.1", "3.1"),
        after_sel=("3.1", "3.9"),
        command_name="finish-of-line-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.56">def test_fill_paragraph(self):
    """Test case for fill-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially
declared disasters are weather related,
leading to around 500 deaths per year
and nearly $14 billion in damage.
StormReady, a program
started in 1999 in Tulsa, OK,
helps arm America's
communities with the communication and
safety skills needed to save lives and
property--before and during the event.
StormReady helps community leaders and
emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property--before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.7"),
        after_sel=("10.0", " 10.0"),
        command_name="fill-paragraph",
    )
</t>
<t tx="ekr.20201202085332.57">def test_forward_char(self):
    """Test case for forward-char"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.2", "1.2"),
        after_sel=("1.3", "1.3"),
        command_name="forward-char",
    )
</t>
<t tx="ekr.20201202085332.58">def test_forward_char_extend_selection(self):
    """Test case for forward-char-extend-selection"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.1", "1.1"),
        after_sel=("1.1", "1.2"),
        command_name="forward-char-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.59">def test_forward_end_word_end_of_line(self):
    """Test case for forward-end-word (end of line)"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.395", "1.395"),
        after_sel=("3.4", "3.4"),
        command_name="forward-end-word",
    )
</t>
<t tx="ekr.20201202085332.6">def test_back_paragraph_extend_selection(self):
    """Test case for back-paragraph-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.5"),
        after_sel=("6.7", "9.5"),
        command_name="back-paragraph-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.60">def test_forward_end_word_start_of_word(self):
    """Test case for forward-end-word (start of word)"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.310", "1.310"),
        after_sel=("1.317", "1.317"),
        command_name="forward-end-word",
    )
</t>
<t tx="ekr.20201202085332.61">def test_forward_end_word_extend_selection(self):
    """Test case for forward-end-word-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.20", "3.20"),
        after_sel=("3.20", "3.30"),
        command_name="forward-end-word-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.62">def test_forward_paragraph(self):
    """Test case for forward-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("15.0", "15.0"),
        command_name="forward-paragraph",
    )
</t>
<t tx="ekr.20201202085332.63">def test_forward_paragraph_extend_selection(self):
    """Test case for forward-paragraph-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("10.0", "10.0"),
        after_sel=("10.0", "15.0"),
        command_name="forward-paragraph-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.64">def test_forward_sentence(self):
    """Test case for forward-sentence"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.17", "3.17"),
        after_sel=("3.142", "3.142"),
        command_name="forward-sentence",
    )
</t>
<t tx="ekr.20201202085332.65">def test_forward_sentence_extend_selection(self):
    """Test case for forward-sentence-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.264", "1.264"),
        after_sel=("1.264", "1.395"),
        command_name="forward-sentence-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.66">def test_forward_word(self):
    """Test case for forward-word"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.261", "1.261"),
        after_sel=("1.272", "1.272"),
        command_name="forward-word",
    )
</t>
<t tx="ekr.20201202085332.67">def test_forward_word_extend_selection(self):
    """Test case for forward-word-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.395", "1.395"),
        after_sel=("1.395", "3.4"),
        command_name="forward-word-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.68">def test_indent_relative(self):
    """Test case for indent-relative"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
        line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("5.0", "5.0"),
        after_sel=("5.8", "5.8"),
        command_name="indent-relative",
    )
</t>
<t tx="ekr.20201202085332.69">def test_indent_rigidly(self):
    """Test case for indent-rigidly"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
	line 1
	    line a
	        line b
	line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "5.0"),
        after_sel=("2.0", "5.1"),
        command_name="indent-rigidly",
    )
</t>
<t tx="ekr.20201202085332.7">def test_back_sentence(self):
    """Test case for back-sentence"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.169", "3.169"),
        after_sel=("3.143", "3.143"),
        command_name="back-sentence",
    )
</t>
<t tx="ekr.20201202085332.70">def test_indent_to_comment_column(self):
    """Test case for indent-to-comment-column"""
    before_b = """\
first line
line b
last line
"""
    after_b = """\
first line
    line b
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.0", "2.0"),
        after_sel=("2.4", "2.4"),
        command_name="indent-to-comment-column",
    )
</t>
<t tx="ekr.20201202085332.71">def test_insert_newline(self):
    """Test case for insert-newline"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first li
ne
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.8", "1.8"),
        after_sel=("2.0", "2.0"),
        command_name="insert-newline",
    )
</t>
<t tx="ekr.20201202085332.72">def test_insert_parentheses(self):
    """Test case for insert-parentheses"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first() line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.5", "1.5"),
        after_sel=("1.6", "1.6"),
        command_name="insert-parentheses",
    )
</t>
<t tx="ekr.20201202085332.73">def test_kill_paragraph(self):
    """Test case for kill-paragraph"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Services StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("9.0", "9.0"),
        after_sel=("8.0", "8.0"),
        command_name="kill-paragraph",
    )
</t>
<t tx="ekr.20201202085332.74">def test_kill_sentence(self):
    """Test case for kill-sentence"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  And
this is the last sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("1.27", "1.27"),
        command_name="kill-sentence",
    )
</t>
<t tx="ekr.20201202085332.75">def test_kill_word(self):
    """Test case for kill-word"""
    before_b = """\
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
"""
    after_b = """\
This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.6", "2.6"),
        after_sel=("2.7", "2.7"),
        command_name="kill-word",
    )
</t>
<t tx="ekr.20201202085332.76">def test_kill_line_end_body_text(self):
    """Test case for kill-line end-body-text"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2
line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.1", "4.1"),
        after_sel=("3.6", "3.6"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.77">def test_kill_line_end_line_text(self):
    """Test case for kill-line end-line-text"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2

"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.5", "3.5"),
        after_sel=("3.0", "3.0"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.78">def test_kill_line_start_line(self):
    """Test case for kill-line start-line"""
    before_b = """\
line 1
line 2
line 3
line 4
"""
    after_b = """\
line 1
line 2

line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.79">def test_kill_line_start_blank_line(self):
    """Test case for kill-line start-blank-line"""
    before_b = """\
line 1
line 2

line 4
"""
    after_b = """\
line 1
line 2
line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-line",
    )
</t>
<t tx="ekr.20201202085332.8">def test_back_sentence_extend_selection(self):
    """Test case for back-sentence-extend-selection"""
    before_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    after_b = """\
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.208", "3.208"),
        after_sel=("3.143", "3.208"),
        command_name="back-sentence-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.80">def test_kill_to_end_of_line_end_body_text(self):
    """Test case for kill-to-end-of-line end-body-text"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2
line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.1", "4.1"),
        after_sel=("3.6", "3.6"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.81">def test_kill_to_end_of_line_end_line(self):
    """Test case for kill-to-end-of-line end-line"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
line 2line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.6", "2.6"),
        after_sel=("2.6", "2.6"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.82">def test_kill_to_end_of_line_after_last_visible_char(self):
    """Test case for kill-to-end-of-line after last visible char"""
    before_b = """\
line 1
# The next line contains two trailing blanks.
line 3  
line 4
"""
    after_b = """\
line 1
# The next line contains two trailing blanks.
line 3line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.6", "3.6"),
        after_sel=("3.6", "3.6"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.83">def test_kill_to_end_of_line_start_line(self):
    """Test case for kill-to-end-of-line start-line"""
    before_b = """\
line 1
line 2
line 3
line 4
"""
    after_b = """\
line 1
line 2

line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.84">def test_kill_to_end_of_line_start_blank_line(self):
    """Test case for kill-to-end-of-line start-blank-line"""
    before_b = """\
line 1
line 2

line 4
"""
    after_b = """\
line 1
line 2
line 4
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("3.0", "3.0"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.85">def test_kill_to_end_of_line_middle_line(self):
    """Test case for kill-to-end-of-line middle-line"""
    before_b = """\
line 1
line 2
line 3
"""
    after_b = """\
line 1
li
line 3
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("2.2", "2.2"),
        command_name="kill-to-end-of-line",
    )
</t>
<t tx="ekr.20201202085332.86">def test_move_lines_down(self):
    """Test case for move-lines-down"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
line c
    line a
        line b
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.3", "4.3"),
        after_sel=("4.3", "5.3"),
        command_name="move-lines-down",
    )
</t>
<t tx="ekr.20201202085332.87">def test_move_lines_up(self):
    """Test case for move-lines-up"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
line 1
first line
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.2", "2.2"),
        after_sel=("1.2", "1.2"),
        command_name="move-lines-up",
    )
</t>
<t tx="ekr.20201202085332.88">def test_move_lines_up_into_docstring(self):
    """Test case for move-lines-up (into docstring)"""
    before_b = '''\
@language python
def test():
    """ a
    b
    c
    """
    print 1
    
    print 2
'''
    after_b = '''\
@language python
def test():
    """ a
    b
    c
    print 1
    """
    
    print 2
'''
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("7.1", "7.1"),
        after_sel=("6.1", "6.1"),
        command_name="move-lines-up",
    )
</t>
<t tx="ekr.20201202085332.89">def test_move_past_close(self):
    """Test case for move-past-close"""
    before_b = """\
first (line)
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first (line)
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.10", "1.10"),
        after_sel=("1.12", "1.12"),
        command_name="move-past-close",
    )
</t>
<t tx="ekr.20201202085332.9">def test_back_to_indentation(self):
    """Test case for back-to-indentation"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("4.13", "4.13"),
        after_sel=("4.8", "4.8"),
        command_name="back-to-indentation",
    )
</t>
<t tx="ekr.20201202085332.90">def test_move_past_close_extend_selection(self):
    """Test case for move-past-close-extend-selection"""
    before_b = """\
first line
line 1
    (line )a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    (line )a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.7", "3.7"),
        after_sel=("3.7", "3.11"),
        command_name="move-past-close-extend-selection",
    )
</t>
<t tx="ekr.20201202085332.91">def test_newline_and_indent(self):
    """Test case for newline-and-indent"""
    before_b = """\
first line
line 1
    line a
        line b
line c
last line
"""
    after_b = """\
first line
line 1
    
    line a
        line b
line c
last line
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.6", "2.6"),
        after_sel=("3.4", "3.4"),
        command_name="newline-and-indent",
    )
</t>
<t tx="ekr.20201202085332.92">def test_next_line(self):
    """Test case for next-line"""
    before_b = """\
a

b
"""
    after_b = """\
a

b
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("1.1", "1.1"),
        after_sel=("2.0", "2.0"),
        command_name="next-line",
    )
</t>
<t tx="ekr.20201202085332.93">def test_previous_line(self):
    """Test case for previous-line"""
    before_b = """\
a

b
"""
    after_b = """\
a

b
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("3.0", "3.0"),
        after_sel=("2.0", "2.0"),
        command_name="previous-line",
    )
</t>
<t tx="ekr.20201202085332.94">def test_rectangle_clear(self):
    """Test case for rectangle-clear"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.6"),
        command_name="rectangle-clear",
    )
</t>
<t tx="ekr.20201202085332.95">def test_rectangle_close(self):
    """Test case for rectangle-close"""
    before_b = """\
before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
"""
    after_b = """\
before
aaabbb
aaabbb
aaabbb
aaabbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.3"),
        command_name="rectangle-close",
    )
</t>
<t tx="ekr.20201202085332.96">def test_rectangle_delete(self):
    """Test case for rectangle-delete"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaabbb
aaabbb
aaabbb
aaabbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.3"),
        command_name="rectangle-delete",
    )
</t>
<t tx="ekr.20201202085332.97">def test_rectangle_kill(self):
    """Test case for rectangle-kill"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaabbb
aaabbb
aaabbb
aaabbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("5.3", "5.3"),
        command_name="rectangle-kill",
    )
</t>
<t tx="ekr.20201202085332.98">def test_rectangle_open(self):
    """Test case for rectangle-open"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.6"),
        command_name="rectangle-open",
    )
</t>
<t tx="ekr.20201202085332.99">def test_rectangle_string(self):
    """Test case for rectangle-string"""
    before_b = """\
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
"""
    after_b = """\
before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
"""
    self.run_test(
        before_b=before_b,
        after_b=after_b,
        before_sel=("2.3", "5.6"),
        after_sel=("2.3", "5.8"),
        command_name="rectangle-string",
    )
</t>
<t tx="ekr.20201202112206.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1763

@language python
@nosearch
</t>
<t tx="ekr.20201202144529.1"></t>
<t tx="ekr.20201203045146.1">import os
g.cls()
cwd = os.getcwd()
os.system('leo-unittest')
os.chdir(cwd)</t>
<t tx="ekr.20201203081649.1"></t>
<t tx="ekr.20201203114411.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1766

@language python
@nosearch
</t>
<t tx="ekr.20201204104619.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1768

@language python
@nosearch

</t>
<t tx="ekr.20201204172235.1">leo_cursor_width = 0

leo_vim_mode = None

def paintEvent(self, event):
    """
    LeoQTextBrowser.paintEvent.
    
    New in Leo 6.4: Draw a box around the cursor in command mode.
                    This is as close as possible to vim's look.
    """
    c, vc, w = self.leo_c, self.leo_c.vimCommands, self
    #
    # First, call the base class paintEvent.
    QtWidgets.QTextBrowser.paintEvent(self, event)
    
    def set_cursor_width(width):
        """Set the cursor width, but only if necessary."""
        if self.leo_cursor_width != width:
            self.leo_cursor_width = width
            w.setCursorWidth(width)
    
    #
    # Are we in vim mode?
    if self.leo_vim_mode is None:
        self.leo_vim_mode = c.config.getBool('vim-mode', default=False)
    #
    # Are we in command mode?
    if self.leo_vim_mode:
        in_command = vc and vc.state == 'normal'  # vim mode.
    else:
        in_command = c.k.unboundKeyAction == 'command'  # vim emulation.
    #
    # Draw the box only in command mode, when w is the body pane, with focus.
    if (
        not in_command
        or w != c.frame.body.widget
        or w != g.app.gui.get_focus()
    ):
        set_cursor_width(c.config.getInt('qt-cursor-width') or 1)
        return
    #
    # Set the width of the cursor.
    font = w.currentFont()
    cursor_width = QtGui.QFontMetrics(font).averageCharWidth()
    set_cursor_width(cursor_width)
    #
    # Draw a box around the cursor.
    qp = QtGui.QPainter()
    qp.begin(self.viewport())
    qp.drawRect(w.cursorRect())
    qp.end()
</t>
<t tx="ekr.20201205182226.1"></t>
<t tx="ekr.20201205203155.1"></t>
<t tx="ekr.20201207055200.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1240

@language python
@nosearch
</t>
<t tx="ekr.20201207055713.1">def idle_check_leo_file(self, c):
    """Check c's .leo file for external changes."""
    path = c.fileName()
    if not self.has_changed(path):
        return
    #
    # Always update the path &amp; time to prevent future warnings.
    self.set_time(path)
    self.checksum_d[path] = self.checksum(path)
    if self.ask(c, path):
        # Do a complete restart of Leo.
        g.es_print('restarting Leo...')
        c.restartLeo()
</t>
<t tx="ekr.20201207084531.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1772

Added gdc.diff_pull_request.

@language python
@nosearch
</t>
<t tx="ekr.20201208114431.1">def diff_pull_request(self, branch_name, base_branch_name='devel', directory=None):
    """
    Create a Leonine version of the diffs that would be
    produced by a pull request between two branches.
    """
    if not directory:
        directory = os.path.join(g.app.loadDir, '..', '..')
    aList = g.execGitCommand(f"git rev-parse devel", directory)
    if aList:
        devel_rev = aList[0]
        devel_rev = devel_rev[:8]
        self.diff_two_revs(
            rev1=devel_rev,  # Before: Latest devel commit.
            rev2='HEAD',     # After: Lastest branch commit
            directory=directory,
        )
    else:
        g.es_print('FAIL: git rev-parse devel')
</t>
<t tx="ekr.20201208114843.1"># No longer needed. Use the git-diff-pr command.
import leo.commands.editFileCommands as efc
x = efc.GitDiffController(c)
x.diff_pull_request()
</t>
<t tx="ekr.20201210081319.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1775

Just remove the branch_name arg to gdc.diff_pull_request

@language python
@nosearch
</t>
<t tx="ekr.20201210120346.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1777

@language python
@nosearch
</t>
<t tx="ekr.20201210123153.1"></t>
<t tx="ekr.20201211164320.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1780

@language python
@nosearch
</t>
<t tx="ekr.20201211182659.1">def standard_timestamp():
    """Return a reasonable timestamp."""
    return time.strftime("%Y%m%d-%H%M%S")
</t>
<t tx="ekr.20201211182722.1"></t>
<t tx="ekr.20201211183100.1">def get_backup_path(sub_directory):
    """
    Return the full path to the subdirectory of the main backup directory.
    
    The main backup directory is computed as follows:
        
    1. os.environ['LEO_BACKUP']
    2. ~/Backup
    """
    # Transcrypt does not support Python's pathlib module.
    # __pragma__ ('skip')

    from pathlib import Path
    # Compute the main backup directory.
    # First, try the LEO_BACKUP directory.
    backup = None
    try:
        backup = os.environ['LEO_BACKUP']
        if not os.path.exists(backup):
            backup = None
    except KeyError:
        pass
    except Exception:
        g.es_exception()
    # Second, try ~/Backup.
    if not backup:
        backup = os.path.join(str(Path.home()), 'Backup')
        if not os.path.exists(backup):
            backup = None
    if not backup:
        return None
    # Compute the path to backup/sub_directory
    directory = os.path.join(backup, sub_directory)
    return directory if os.path.exists(directory) else None
</t>
<t tx="ekr.20201212090129.1"></t>
<t tx="ekr.20201212091359.1">@language rest
@wrap

Leonine diffs of .leo files
https://github.com/leo-editor/leo-editor/issues/1781

@language python
@nosearch
</t>
<t tx="ekr.20201212175532.1"></t>
<t tx="ekr.20201213055506.1">@nosearch

# flattened, word, ignore-case, head, body

# found 5 nodes</t>
<t tx="ekr.20201213172138.1">@language rest
@wrap

https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging

Stage 1 is the common ancestor,
stage 2 is your version 
stage 3 is from the MERGE_HEAD, the version youre merging in (theirs).

You can extract a copy of each of these versions of the conflicted file with the git show command:

$ git show :1:hello.rb &gt; hello.common.rb
$ git show :2:hello.rb &gt; hello.ours.rb
$ git show :3:hello.rb &gt; hello.theirs.rb

</t>
<t tx="ekr.20201214173524.1"></t>
<t tx="ekr.20201214185152.1"># https://github.com/leo-editor/leo-editor/issues/1781
# g.cls()
from leo.commands import editFileCommands
import importlib
importlib.reload(efc)
fn = 'git_diff_test.leo'
rev1, rev2 = '1ae08a66', 'HEAD'  # 'HEAD@{1}', 'HEAD@{0}'
x = efc.GitDiffController(c)
x.set_directory(None)
x.root = x.create_root(rev1, rev2)
x.diff_file(fn, rev1=rev1, rev2=rev2)
c.redraw()
</t>
<t tx="ekr.20201215050832.1">def make_leo_outline(self, fn, path, s, rev):
    """Create a hidden temp outline for the .leo file in s."""
    hidden_c = leoCommands.Commands(fn, gui=g.app.nullGui)
    hidden_c.frame.createFirstTreeNode()
    root = hidden_c.rootPosition()
    root.h = fn + ':' + rev if rev else fn
    hidden_c.fileCommands.getLeoFile(
        theFile=g.FileLikeObject(fromString=s),
        fileName=path,
        readAtFileNodesFlag=False,
        silent=False,
        checkOpenFiles=False,
    )
    return hidden_c
</t>
<t tx="ekr.20201215093414.1">@cmd('git-diff-pull-request')
@cmd('git-diff-pr')
def gitDiffPullRequest(self, event=None):
    """
    Produce a Leonine diff of pull request in the current branch.
    """
    GitDiffController(c=self.c).diff_pull_request()
</t>
<t tx="ekr.20201215145115.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1783

@font-size-tree

@language python
@nosearch
</t>
<t tx="ekr.20201216061006.1">@nosearch

# flattened, ignore-case, head, body

# found 4 nodes</t>
<t tx="ekr.20201216061211.1"></t>
<t tx="ekr.20201216114709.1">@language rest
@wrap

FAIL: javaScripthon: (pj -h)
- Created ekr-no-fstrings branch for this.
- Doesn't handle f-strings.
- Assertion fails in leoNodes.py without explanation.

rapydscript: npm package. Command-line shell.

transcrypt:  (note spelling) pip install transcript.
- -a annotated code.
- -m Source maps.
- -n Suppresses minimization.
- Fails on Python's copy module. There are workarounds.
- Produces good error messages.

@language python

# Transcrypt does not support Python's copy module.
# __pragma__ ('skip')


# __pragma__ ('noskip')
</t>
<t tx="ekr.20201217144708.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1788

@language python
@nosearch
</t>
<t tx="ekr.20201218161308.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1790

@language python
@nosearch
</t>
<t tx="ekr.20201221061215.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1792

@language python
@nosearch
</t>
<t tx="ekr.20201221065401.1">gnx: ekr.20201012111338.2
unl: Declarations (leo_cloud.py)
gnx: ekr.20201012111338.3
unl: init (leo_cloud.py)
gnx: ekr.20201012111338.4
unl: onCreate (leo_cloud.py)
gnx: ekr.20201012111338.5
unl: onSave (leo_cloud.py)
gnx: ekr.20201012111338.6
unl: lc_read_current (leo_cloud.py)
gnx: ekr.20201012111338.7
unl: lc_write_current (leo_cloud.py)
gnx: ekr.20201012111338.8
unl: class LeoCloudIOBase
gnx: ekr.20201012111338.9
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.__init__
gnx: ekr.20201012111338.10
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.get_subtree
gnx: ekr.20201012111338.11
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.put_subtree
gnx: ekr.20201012111338.12
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)
gnx: ekr.20201012111338.13
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).__init__
gnx: ekr.20201012111338.14
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).get_data
gnx: ekr.20201012111338.15
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).put_data
gnx: ekr.20201012111338.16
unl: class LeoCloudIOGit(LeoCloudIOBase)
gnx: ekr.20201012111338.17
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).__init__
gnx: ekr.20201012111338.18
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase)._run_git
gnx: ekr.20201012111338.19
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).get_data
gnx: ekr.20201012111338.20
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).put_data
gnx: ekr.20201012111338.21
unl: class LeoCloud
gnx: ekr.20201012111338.22
unl: class LeoCloud--&gt;LeoCloud.__init__
gnx: ekr.20201012111338.23
unl: class LeoCloud--&gt;LeoCloud.bg_check
gnx: ekr.20201012111338.24
unl: class LeoCloud--&gt;LeoCloud.bg_post_process
gnx: ekr.20201012111338.25
unl: class LeoCloud--&gt;LeoCloud.find_at_leo_cloud
gnx: ekr.20201012111338.26
unl: class LeoCloud--&gt;LeoCloud._find_clouds_recursive
gnx: ekr.20201012111338.27
unl: class LeoCloud--&gt;LeoCloud.find_clouds
gnx: ekr.20201012111338.28
unl: class LeoCloud--&gt;LeoCloud._from_dict_recursive
gnx: ekr.20201012111338.29
unl: class LeoCloud--&gt;LeoCloud.from_dict
gnx: ekr.20201012111338.30
unl: class LeoCloud--&gt;LeoCloud.io_from_node
gnx: ekr.20201012111338.31
unl: class LeoCloud--&gt;LeoCloud.kw_from_node
gnx: ekr.20201012111338.32
unl: class LeoCloud--&gt;LeoCloud.load_clouds
gnx: ekr.20201012111338.33
unl: class LeoCloud--&gt;LeoCloud.read_current
gnx: ekr.20201012111338.34
unl: class LeoCloud--&gt;LeoCloud.recursive_hash
gnx: ekr.20201012111338.35
unl: class LeoCloud--&gt;LeoCloud.save_clouds
gnx: ekr.20201012111338.36
unl: class LeoCloud--&gt;LeoCloud.subtree_changed
gnx: ekr.20201012111338.37
unl: class LeoCloud--&gt;LeoCloud._to_json_serial
gnx: ekr.20201012111338.38
unl: class LeoCloud--&gt;LeoCloud.to_json
gnx: ekr.20201012111338.39
unl: class LeoCloud--&gt;LeoCloud._to_dict_recursive
gnx: ekr.20201012111338.40
unl: class LeoCloud--&gt;LeoCloud.to_dict
gnx: ekr.20201012111338.41
unl: class LeoCloud--&gt;LeoCloud._ua_clean
gnx: ekr.20201012111338.42
unl: class LeoCloud--&gt;LeoCloud.write_current
</t>
<t tx="ekr.20201221071542.1"></t>
<t tx="ekr.20201222095250.1">g.cls()
import glob
import os
efc = c.editFileCommands
theme_dir = os.path.join(g.app.loadDir, '..', 'themes')
assert os.path.exists(theme_dir), repr(theme_dir)
paths = glob.glob(f"{theme_dir}{os.sep}*.leo")

def clean(s):
    return s.strip().replace('-','').replace('_','').replace(' ','')
    
for path in paths:
    d = {}
    c = efc.createHiddenCommander(path)
    sfn = c.shortFileName()
    if sfn == 'old_themes.leo':
        continue
    print('checking ', sfn)
    for p in c.all_unique_positions():
        h = clean(p.h)
        if h.startswith('@'):
            if h in d:
                print(f"  {sfn:20}: duplicate {h}")
            else:
                d [h] = True
print('done')</t>
<t tx="ktenney.20041211072654.14">def processDirectory(self, path, node):

    """
    create child nodes for each member of the directory

    @path is a path object for a directory
    @node is the node to work with
    """
    # delete all nodes before creating, to avoid duplicates
    while node.firstChild():
        node.firstChild().doDelete(node)

    for file in path.files():
        child = node.insertAsLastChild()
        child.h = '@view %s' % file.name

    for file in path.dirs():
        child = node.insertAsLastChild()
        child.h = '@view %s' % file.name
</t>
<t tx="tbrown.20080613095157.10">def openDir(c,parent,d):
    """
    Expand / refresh an existing folder

    Note: With the addition of per folder inclusion/exclusion a check is done
    against both the current list of nodes and against the files/folders as
    they exist on the system. This check must be done in both places to keep
    the node list in sync with the file system while respecting the inc/exc
    lists - John Lunzer
    """

    # compare folder content to children
    try:
        path, dirs, files = next(os.walk(d))
    except StopIteration:
        # directory deleted?
        c.setHeadString(parent,'*'+parent.h.strip('*')+'*')
        return

    # parent.expand()  # why?

    oldlist = set()
    toRemove = set()
    newlist = []

    bodySplit = parent.b.splitlines()

    excdirs = False
    excfiles = False
    regEx = False
    if re.search('^excdirs', parent.b, flags=re.MULTILINE):
        excdirs = True
    if re.search('^excfiles', parent.b, flags=re.MULTILINE):
        excfiles = True
    if re.search('^re', parent.b, flags=re.MULTILINE):
        regEx = True

    inc = [line.replace('inc=','') for line in bodySplit if line.startswith('inc=')]
    exc = [line.replace('exc=','') for line in bodySplit if line.startswith('exc=')]

    #flatten lists if using comma separations
    inc = [item for line in inc for item in line.strip(' ').split(',')]
    exc = [item for line in exc for item in line.strip(' ').split(',')]

    # get children info
    for p in flattenOrganizers(parent):
        entry = p.h.strip('/*')
        if entry.startswith('@'):  # remove only the @part
            directive = entry.split(None,1)
            if len(directive) &gt; 1:
                entry = entry[len(directive[0]):].strip()
        #find existing inc/exc nodes to remove
        #using p.h allows for example exc=/ to remove all directories
        if not checkIncExc(p.h,inc,exc, regEx) or \
               (excdirs and entry in dirs) or \
               (excfiles and entry in files):
            toRemove.add(p.h) #must not strip '/', so nodes can be removed
        else:
            oldlist.add(entry)

    # remove existing found inc/exc nodes
    for headline in toRemove:
        found = g.findNodeInChildren(c,parent,headline)
        if found:
            found.doDelete()

    # dirs trimmed by toRemove to remove redundant checks
    for d2 in set(dirs)-set([h.strip('/') for h in toRemove]):
        if d2 in oldlist:
            oldlist.discard(d2)
        else:
            if checkIncExc(d2,
                           [i.strip('/') for i in inc],
                           [e.strip('/') for e in exc],
                           regEx) and not excdirs:
                newlist.append('/'+d2+'/')

    # files trimmed by toRemove, retains original functionality of plugin
    for f in set(files)-toRemove:
        if f in oldlist:
            oldlist.discard(f)
        else:
            if checkIncExc(f, inc, exc, regEx) and not excfiles:
                newlist.append(f)

    # insert newlist
    newlist.sort()
    ignored = 0
    newlist.reverse()  # un-reversed by the following loop
    for name in newlist:
        if inReList(name, c.__active_path['ignore']):
            ignored += 1
            continue

        p = parent.insertAsNthChild(0)
        c.setChanged()
        p.h = name
        if name.startswith('/'):
            # sufficient test of dirness as we created newlist
            p.b = '@path '+name.strip('/')
        elif (c.__active_path['do_autoload'] and
              inReList(name, c.__active_path['autoload'])):
            openFile(c, p, os.path.join(d, p.h), autoload=True)
        elif (c.__active_path['do_autoload'] and
              c.__active_path['load_docstring'] and
              name.lower().endswith(".py")):
            # do_autoload suppresses doc string loading because turning
            # autoload off is supposed to address situations where autoloading
            # causes problems, so don't still do some form of autoloading
            p.b = c.__active_path['DS_SENTINEL']+"\n\n"+loadDocstring(os.path.join(d, p.h))
        p.setMarked()
        p.contract()

    if ignored:
        g.es('Ignored %d files in directory' % ignored)

    # warn / mark for orphan oldlist
    for p in flattenOrganizers(parent):
        h = p.h.strip('/*')  # strip / and *
        if (h not in oldlist or
            (p.hasChildren() and not isDirNode(p))
        ):  # clears bogus '*' marks
            nh = p.h.strip('*')  # strip only *
        else:
            nh = '*'+p.h.strip('*')+'*'
            if isDirNode(p):
                for orphan in p.subtree():
                    c.setHeadString(orphan, '*'+orphan.h.strip('*')+'*')
        if p.h != nh:  # don't dirty node unless we must
            p.h = nh

    c.selectPosition(parent)
</t>
<t tx="tbrown.20080613095157.8">def createFile(c,parent,d):
    """Ask if we should create a new file"""
    directory = os.path.dirname(d)
    if not os.path.isdir(directory):
        g.error('Create parent directories first')
        return False

    d = os.path.basename(d)
    atType = c.config.getString('active-path-attype') or 'auto'
    ok = g.app.gui.runAskYesNoDialog(c, 'Create / load file?',
        'Create file @'+atType+' '+d+'?')
    if ok == 'no':
        return False
    parent.h = '@'+atType+' '+d
    c.bodyWantsFocus()
    return True
</t>
<t tx="tbrown.20090119215428.11">def __init__ (self,c):
    '''ctor for todoController class.'''
    self.c = c
    c.cleo = self
    self.donePriority = 100
    self.menuicons = {}  # menu icon cache
    self.recentIcons = []
    #X self.smiley = None
    self.redrawLevels = 0
    self._widget_to_style = None  # see updateStyle()
    self.reloadSettings()
    self.handlers = [
       ("close-frame",self.close),
       ('select3', self.updateUI),
       ('save2', self.loadAllIcons),
       ('idle', self.updateStyle),
    ]
    # chdir so the Icons can be located, needed for uic resources
    owd = os.getcwd()
    os.chdir(g.os_path_join(g.app.loadDir, '..', 'plugins'))
    self.ui = todoQtUI(self)
    os.chdir(owd)
    for i in self.handlers:
        g.registerHandler(i[0], i[1])
    self.loadAllIcons()
    # correct spinTime suffix:
    self.ui.UI.spinTime.setSuffix(" " + self.time_name)
    # #1591: patch labels if necessary.
    self.patch_1591()
</t>
<t tx="tbrown.20090119215428.12">def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    self.time_name = c.config.getString('todo-time-name') or 'days'
    self.icon_location = c.config.getString('todo-icon-location') or 'beforeHeadline'
    self.prog_location = c.config.getString('todo-prog-location') or 'beforeHeadline'
    self.icon_order = c.config.getString('todo-icon-order') or 'pri-first'
</t>
<t tx="tbrown.20090119215428.34">@redrawer
def show_times(self, p=None, show=False):

    def rnd(x):
        return re.sub('.0$', '', '%.1f' % x)

    if p is None:
        p = self.c.currentPosition()

    for nd in p.self_and_subtree():
        p.h = re.sub(' &lt;[^&gt;]*&gt;$', '', nd.headString())
        tr = self.getat(nd.v, 'time_req')
        pr = self.getat(nd.v, 'progress')
        try: pr = float(pr)
        except Exception: pr = ''
        if tr != '' or pr != '':
            ans = ' &lt;'
            if tr != '':
                if pr == '' or pr == 0 or pr == 100:
                    ans += rnd(tr) + ' ' + self.time_name
                else:
                    ans += '%s+%s=%s %s' % (rnd(pr/100.*tr), rnd((1-pr/100.)*tr), rnd(tr), self.time_name)
                if pr != '': ans += ', '
            if pr != '':
                ans += rnd(pr) + '%'  # pr may be non-integer if set by recalc_time
            ans += '&gt;'

            if show:
                nd.h = nd.h+ans
            self.loadIcons(nd)  # update progress icon

</t>
<t tx="tbrown.20090119215428.49">def updateUI(self,tag=None,k=None):

    if k and k['c'] != self.c:
        return  # wrong number

    v = self.c.currentPosition().v

    # check work date &lt; due date and do stylesheet re-evaluation stuff
    nwd = self.getat(v, 'nextworkdate')
    due = self.getat(v, 'duedate')
    w = self.ui.UI.frmDates
    if nwd and due and str(nwd) &gt; str(due):
        w.setProperty('style_class', 'tododate_error')
    else:
        w.setProperty('style_class', '')
    # update style on this widget on idle, see updateStyle()
    self._widget_to_style = (w, time.time())

    self.ui.setProgress(int(self.getat(v, 'progress') or 0 ))
    self.ui.setTime(float(self.getat(v, 'time_req') or 0 ))

    self.ui.setDueDate(self.getat(v, 'duedate'))
    # default is "", which is understood by setDueDate()
    self.ui.setDueTime(self.getat(v, 'duetime'))
    # ditto

    self.ui.setDueDate(self.getat(v, 'duedate'))
    self.ui.setDueTime(self.getat(v, 'duetime'))
    self.ui.setNextWorkDate(self.getat(v, 'nextworkdate'))
    self.ui.setNextWorkTime(self.getat(v, 'nextworktime'))
    # pylint: disable=maybe-no-member
    created = self.getat(v,'created')
    if created and isinstance(created, datetime.datetime) and created.year &gt;= 1900:
        self.ui.UI.createdTxt.setText(created.strftime("%d %b %y"))
        self.ui.UI.createdTxt.setToolTip(created.strftime("Created %H:%M %d %b %Y"))
    else:
        # .strftime doesn't work here! This has has happened...
        try:
            gdate = self.c.p.v.gnx.split('.')[1][:12]
            created = datetime.datetime.strptime(gdate, '%Y%m%d%H%M')
            if created.year &lt; 1900:
                created = None
        except Exception:
            created = None
        if created:
            self.ui.UI.createdTxt.setText(created.strftime("Created %d %b %Y"))
            self.ui.UI.createdTxt.setToolTip(created.strftime("gnx created %H:%M %d %b %Y"))
        else:
            self.ui.UI.createdTxt.setText("")

    # Update the label.
    h = self.c and self.c.p and self.c.p.h
    due = self.getat(v, 'duedate')
    ago = (datetime.date.today()-created.date()).days if created else 0
    if due:
        days = (due - datetime.date.today()).days
        txt = f"{h}\nCreated {ago} days ago, due in {days}"
    else:
        txt = f"{h}\nCreated {ago} days ago"
    self.ui.UI.txtDetails.setText(txt)
    prisetdate = self.getat(v, 'prisetdate')
    self.ui.UI.txtDetails.setToolTip("Priority set %s" %
        (str(prisetdate).strip() or '?')
    )
</t>
<t tx="tbrown.20111011094944.27031">def tab_callback(self):
    """Called when user hits tab on an item in the QListWidget."""
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper  # 2014/09/19
    if w is None: return
    # Replace the tail of the prefix with the completion.
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &lt; 2:
        return
    i = j = w.getInsertPoint()
    s = w.getAllText()
    while (0 &lt;= i &lt; len(s) and s[i] != '.'):
        i -= 1
    i += 1
    if j &gt; i:
        w.delete(i, j)
    w.setInsertPoint(i)
    c.k.autoCompleter.compute_completion_list()
</t>
<t tx="tbrown.20130411145310.18855">def wheelEvent(self, event):
    """Handle a wheel event."""
    if QtCore.Qt.ControlModifier &amp; event.modifiers():
        d = {'c': self.leo_c}
        if isQt5:
            point = event.angleDelta()
            delta = point.y() or point.x()
        else:
            delta = event.delta()
        if delta &lt; 0:
            zoom_out(d)
        else:
            zoom_in(d)
        event.accept()
        return
    QtWidgets.QTextBrowser.wheelEvent(self, event)
</t>
<t tx="tbrown.20150807090639.1">def declutter_node(self, c, p, item):
    """declutter_node - change the appearance of a node

    :param commander c: commander containing node
    :param position p: position of node
    :param QWidgetItem item: tree node widget item
    
    returns composite icon for this node
    """
    dd = self.declutter_data
    iconVal = p.v.computeIcon()
    iconName = f'box{iconVal:02d}.png'
    loaded_images = self.loaded_images
    @others
    if (p.h, iconVal) in dd:
        text, new_icons = dd[(p.h, iconVal)]
        item.setText(0, text)
        new_icons = sorted_icons(p) + new_icons
    else:
        text = p.h
        new_icons = []
        for pattern, cmds in self.get_declutter_patterns():
            m = pattern.match(text) or pattern.search(text)
            if m:
                apply_declutter_rules(cmds)
        dd[(p.h, iconVal)] = item.text(0), new_icons
        new_icons = sorted_icons(p) + new_icons
        preload_images()
    self.nodeIconsDict[p.gnx] = new_icons
    h = ':'.join(new_icons)
    icon = g.app.gui.iconimages.get(h)
    if not icon:
        preload_images()
        images = [loaded_images.get(x) for x in new_icons]
        icon = self.make_composite_icon(images)
        g.app.gui.iconimages[h] = icon
    return icon
</t>
<t tx="ville.20090614224528.8141">def auto_walk(c, directory, parent=None, isroot=True):
    """
    source: http://leo.zwiki.org/CreateShadows

    (create @auto files instead)
    """
    from os import listdir
    from os.path import join, abspath, basename, normpath, isfile
    from fnmatch import fnmatch
    # import os

    RELATIVE_PATHS = False
    patterns_to_ignore = ['*.pyc', '*.leo', '*.gif', '*.png', '*.jpg', '*.json']
    patterns_to_import = ['*.py','*.c', '*.cpp']
    match = lambda s: any(fnmatch(s, p) for p in patterns_to_ignore)

    is_ignorable = lambda s: any([ s.startswith('.'), match(s) ])

    p = c.currentPosition()

    if not RELATIVE_PATHS: directory = abspath(directory)
    if isroot:
        p.h = "@path %s" % normpath(directory)
    for name in listdir(directory):

        if is_ignorable(name):
            continue

        path = join(directory, name)

        if isfile(path) and not any(fnmatch(name, p) for p in patterns_to_import):
            continue

        if isfile(path):
            g.es('file:', path)
            headline = '@auto %s' % basename(path)
            if parent:
                node = parent
            else:
                node = p
            child = node.insertAsLastChild()
            child.initHeadString(headline)
        else:
            g.es('dir:', path)
            headline = basename(path)
            body = "@path %s" % normpath(path)
            if parent:
                node = parent
            else:
                node = p
            child = node.insertAsLastChild()
            child.initHeadString(headline)
            child.initBodyString(body)
            auto_walk(c,path, parent=child, isroot=False)

@g.command('project-wizard')
def project_wizard(event):
    """ Launch project wizard """
    import os
    c = event['c']
    table = [("All files","*"),
        ("Python files","*.py"),]

    fname = g.app.gui.runOpenFileDialog(c,
        title = "Open",filetypes = table,defaultextension = ".leo")

    pth = os.path.dirname(os.path.abspath(fname))

    g.es(pth)
    tgt = c.currentPosition().insertAsLastChild()
    c.selectPosition(tgt)
    auto_walk(c, pth, tgt)
    g.es('Import ok. Do read-at-auto-nodes to parse')
    c.redraw()


#project_wizard()
</t>
<t tx="vitalije.20170708161511.1">def handleInputShortcut(self, event, stroke):
    c, k, p, u = self.c, self, self.c.p, self.c.undoer
    k.clearState()
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body.wrapper
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        assert m  # edit-shortcut was invoked on a malformed body line
        sel = f"{m.group(0)} {stroke.s}"
        udata = u.beforeChangeNodeContents(p)
        pos = w.getYScrollPosition()
        i = len(before)
        j = max(i, len(before) + len(sel) - 1)
        w.setAllText(before + sel + after)
        w.setSelectionRange(i, j, insert=j)
        w.setYScrollPosition(pos)
        u.afterChangeNodeContents(p, 'change shortcut', udata)
        cmdname = m.group(0).rstrip('= ')
        k.editShortcut_do_bind_helper(stroke, cmdname)
        return
    if p.h.startswith(('@command', '@button')):
        udata = u.beforeChangeNodeContents(p)
        cmd = p.h.split('@key', 1)[0]
        p.h = f"{cmd} @key={stroke.s}"
        u.afterChangeNodeContents(p, 'change shortcut', udata)
        try:
            cmdname = cmd.split(' ', 1)[1].strip()
            k.editShortcut_do_bind_helper(stroke, cmdname)
        except IndexError:
            pass
        return
    # this should never happen
    g.error('not in settings node shortcut')
</t>
<t tx="vitalije.20170709151653.1">_cmd_handle_input_pattern = re.compile(r'[A-Za-z0-9_\-]+\s*=')

def isInShortcutBodyLine(self):
    k = self; c = k.c; p = c.p
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        return bool(m)
    return p.h.startswith(('@command', '@button'))
</t>
<t tx="vitalije.20170709151658.1">def isEditShortcutSensible(self):
    k = self; c = k.c; p = c.p
    return p.h.startswith(('@command', '@button')) or k.isInShortcutBodyLine()
</t>
<t tx="vitalije.20170709202924.1">def editShortcut_do_bind_helper(self, stroke, cmdname):
    k = self; c = k.c
    cmdfunc = c.commandsDict.get(cmdname)
    if cmdfunc:
        k.bindKey('all', stroke, cmdfunc, cmdname)
        g.es('bound', stroke, 'to command', cmdname)
</t>
<t tx="vitalije.20200327163522.1">def apply_declutter_rules(cmds):
    """Applies all commands for the matched rule."""
    for cmd, arg in cmds:
        if not declutter_replace(arg, cmd):
            declutter_style(arg, cmd)
</t>
<t tx="vitalije.20200329153148.1">def icon_filenames_for_node(self, p, val):
    '''Prepares and returns a list of icon filenames
       related to this node.
    '''
    nicon = f'box{val:02d}.png'
    fnames = self.nodeIconsDict.get(p.gnx)
    if not fnames:
        icons = self.c.editCommands.getIconList(p)
        fnames = [x['file'] for x in icons if x['where'] == 'beforeIcon']
        fnames.append(nicon)
        fnames.extend(x['file'] for x in icons if x['where'] == 'beforeHeadline')
        self.nodeIconsDict[p.gnx] = fnames
    pat = re.compile(r'^box\d\d\.png$')
    loaded_images = self.loaded_images
    for i, f in enumerate(fnames):
        if pat.match(f):
            fnames[i] = nicon
            self.nodeIconsDict[p.gnx] = fnames
            f = nicon
        if f not in loaded_images:
            loaded_images[f] = g.app.gui.getImageImage(f)
    return fnames
</t>
<t tx="vitalije.20200329153154.1">def make_composite_icon(self, images):
    hsep = self.c.config.getInt('tree-icon-separation') or 0
    images = [x for x in images if x]
    height = max([i.height() for i in images])
    images = [i.scaledToHeight(height) for i in images]
    width = sum([i.width() for i in images]) + hsep * (len(images) - 1)
    pix = QtGui.QImage(width, height, QtGui.QImage.Format_ARGB32_Premultiplied)
    pix.fill(QtGui.QColor(0, 0, 0, 0).rgba())  # transparent fill, rgbA
    # .rgba() call required for Qt4.7, later versions work with straight color
    painter = QtGui.QPainter()
    if not painter.begin(pix):
        print("Failed to init. painter for icon")
        # don't return, the code still makes an icon for the cache
        # which stops this being called again and again
    x = 0
    for i in images:
        painter.drawPixmap(x, 0, i)
        x += i.width() + hsep
    painter.end()
    return QtGui.QIcon(QtGui.QPixmap.fromImage(pix))
</t>
<t tx="vitalije.20200329153544.1">def sorted_icons(p):
    '''
    Returns a list of icon filenames for this node.
    The list is sorted to owner the 'where' key of image dicts.
    '''
    icons = c.editCommands.getIconList(p)
    a = [x['file'] for x in icons if x['where'] == 'beforeIcon']
    a.append(iconName)
    a.extend(x['file'] for x in icons if x['where'] == 'beforeHeadline')
    return a
</t>
<t tx="vitalije.20200329162015.1">def preload_images():
    for f in new_icons:
        if f not in loaded_images:
            loaded_images[f] = g.app.gui.getImageImage(f)
</t>
</tnodes>
</leo_file>
