<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20140920064112.17946"><vh>@int fts_max_hits = 100</vh></v>
<v t="ekr.20140919093158.17876"><vh>@int max-pre-loaded-body-chars = 0</vh></v>
<v t="ekr.20140916101314.19538"><vh>@string target_language = python</vh></v>
<v t="ekr.20140902155015.18674"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20131111060930.18010"><vh>@shortcuts</vh></v>
<v t="ekr.20131121084830.16362"><vh>@button toggle-debug</vh></v>
</v>
<v t="ekr.20140103105930.16446"><vh>@views</vh>
<v t="ekr.20140102162014.16438"><vh>@view added strip_comments keyword arg to two config.getData methods</vh></v>
</v>
<v t="ekr.20140808103117.18035"><vh>@persistence</vh>
<v t="ekr.20140808103117.18036"><vh>@data:@auto ../test/qtui_generate.py</vh>
<v t="ekr.20141010071140.31027"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18038"><vh>@data:@auto ../plugins/qt_main.py</vh>
<v t="ekr.20141010071140.31028"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18040"><vh>@data:@auto ../plugins/qt_main.ui</vh>
<v t="ekr.20141010071140.31029"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18042"><vh>@data:@auto ../plugins/qt_quicksearch.py</vh>
<v t="ekr.20141010071140.31030"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18044"><vh>@data:@auto ../plugins/qt_quicksearch.ui</vh>
<v t="ekr.20141010071140.31031"><vh>@gnxs</vh></v>
</v>
</v>
<v t="ekr.20140923085942.17943"><vh>Recent scripts</vh>
<v t="ekr.20140905060158.18560"><vh>Script: change body.x to body.wrapper.x</vh>
<v t="ekr.20140905060158.18561"><vh>test</vh></v>
</v>
<v t="ekr.20140918124632.19450"><vh>Script: print Qt color names</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@file ../doc/leoNotes.txt</vh></v>
</v>
<v t="ekr.20100120072650.6088"><vh>Projects</vh>
<v t="ekr.20100120072650.6089"><vh>@file ../doc/leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20100119205347.6015"><vh>@file ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20140917180536.19478"><vh>Stashed to-do</vh>
<v t="ekr.20140917154740.17918"><vh>* To do: Leo 5.0a1</vh>
<v t="ekr.20131220065609.16590"><vh>Add docstrings for all commands in leoSessions.py.</vh></v>
<v t="ekr.20140824043305.18300"><vh>Bugs for a1</vh>
<v t="ekr.20131027064821.18715"><vh>Autocompleter ? usually doesn't work</vh></v>
<v t="ekr.20131004191204.16078"><vh>cycle-all-focus doesn't work</vh></v>
<v t="ekr.20131103054650.16527"><vh>fill-region &amp; format-body can hang</vh></v>
<v t="ekr.20131025044901.17146"><vh>Clone-to-last-node</vh></v>
</v>
<v t="ekr.20141011053251.18205"><vh>Installer for a1</vh>
<v t="ekr.20050328093147.1"><vh>Report: improving installer (old??)</vh></v>
<v t="ekr.20130806072439.20732"><vh>** Runnable Leo in one .zip file w/ virtual machine</vh>
<v t="ekr.20130806072439.20736"><vh>Re: Runnable Leo in one .zip file.</vh></v>
<v t="ekr.20130806072439.20744"><vh>Re: Runnable Leo in one .zip file.</vh></v>
</v>
<v t="ekr.20130807203905.16594"><vh>Wishlist for newbies (Fidel)</vh></v>
<v t="ekr.20130806072439.20650"><vh>Wishlist: brew install leo</vh></v>
<v t="ekr.20130807203905.16596"><vh>PortableFileAssociator</vh></v>
</v>
</v>
<v t="ekr.20141011053251.18205"></v>
<v t="ekr.20141015084905.18441"><vh>** Fix Find-Tab scroll bug</vh></v>
<v t="ekr.20141006073719.17938"><vh>** Fix import bugs</vh></v>
<v t="ekr.20140923144655.17926"><vh>** Fix find bugs</vh>
<v t="ekr.20140919052413.17945"><vh>Fix suboutline only find bug</vh>
<v t="ekr.20031218072017.3077"><vh>find.search &amp; helpers</vh>
<v t="ekr.20060526140328"><vh>passedWrapPoint</vh></v>
<v t="ekr.20060526081931"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20060526092203"><vh>regexHelper</vh></v>
<v t="ekr.20060526140744"><vh>backwardsHelper</vh></v>
<v t="ekr.20060526093531"><vh>plainHelper</vh></v>
<v t="ekr.20060526140744.1"><vh>matchWord</vh></v>
<v t="ekr.20070105165924"><vh>replaceBackSlashes</vh></v>
</v>
</v>
</v>
<v t="ekr.20140921180304.17919"><vh>Find command *sometimes* doesn't scroll</vh></v>
</v>
<v t="ekr.20140922124047.19514"><vh>Later...</vh>
<v t="ekr.20140919145841.17947"><vh>** Remove klass hack</vh>
<v t="ekr.20061031131434.28"><vh>compute_completion_list &amp; helper</vh>
<v t="ekr.20110514051607.14524"><vh>get_cached_options</vh></v>
</v>
</v>
<v t="ekr.20140921132351.17921"><vh>** Review all important plugins</vh></v>
<v t="ekr.20140920041848.17923"><vh>** Fix help-for-command and improve docs</vh></v>
<v t="ekr.20140919052413.17946"><vh>** Revise leoBridge docs</vh>
<v t="ekr.20140922043414.17947"><vh>Solution 1</vh>
<v t="ekr.20140921072018.17943"><vh>leo_bridge_test.py (defined in ekr.leo)</vh></v>
</v>
<v t="ekr.20140922043414.17948"><vh>Solution 2 (test)</vh></v>
<v t="ekr.20140922043414.17949"><vh>Solution 0 (already documented)</vh></v>
</v>
<v t="ekr.20140921072018.17937"><vh>** New separate-process commands</vh>
<v t="ekr.20140921072018.17938"><vh>** Settings for at-produce plugin?</vh></v>
</v>
</v>
<v t="ekr.20141012064706.18243"><vh>** Priority 1: bugs affecting stability</vh></v>
<v t="ekr.20141012064706.18244"><vh>** Priority 2: distro projects</vh></v>
<v t="ekr.20141012064706.18245"><vh>** Priority 3: newbie improvements</vh></v>
<v t="ekr.20141012064706.18533"><vh>** Buy two fitbits</vh></v>
</v>
<v t="ekr.20140907201613.18661"><vh>Recent files</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
</v>
<v t="ekr.20140903025053.18625"><vh>Recent code</vh>
<v t="ekr.20131016032805.16721"><vh>g.execute_shell_commands</vh></v>
<v t="ekr.20141015035853.18305"><vh>Simplifying gnx scan logic</vh>
<v t="ekr.20060919110638.7"><vh>fc.createSaxVnode &amp; helpers</vh>
<v t="ekr.20060919110638.8"><vh>fc.handleTnodeSaxAttributes</vh></v>
<v t="ekr.20061004053644"><vh>fc.handleVnodeSaxAttributes</vh></v>
</v>
<v t="ekr.20031218072017.1997"><vh>ni.scanGnx</vh></v>
<v t="ekr.20031218072017.1998"><vh>ni.setTimeStamp</vh></v>
<v t="ekr.20141015035853.18304"><vh>ni.tupleToString</vh></v>
</v>
<v t="ekr.20141012064706.18240"><vh>Bug 35</vh>
<v t="ekr.20031218072017.1991"><vh>class NodeIndices</vh>
<v t="ekr.20031218072017.1992"><vh>NodeIndices.__init__</vh></v>
<v t="ekr.20031218072017.1994"><vh>ni.get/setDefaultId</vh></v>
<v t="ekr.20031218072017.1995"><vh>ni.getNewIndex</vh></v>
<v t="ekr.20031218072017.1997"></v>
<v t="ekr.20031218072017.1998"></v>
<v t="ekr.20031218072017.1999"><vh>ni.toString</vh></v>
<v t="ekr.20141015035853.18304"></v>
</v>
<v t="ekr.20031218072017.1553"><vh>fc.getLeoFile &amp; helpers</vh>
<v t="ekr.20090526081836.5841"><vh>fc.getLeoFileHelper</vh></v>
<v t="ekr.20100205060712.8314"><vh>fc.handleNodeConflicts &amp; helper</vh>
<v t="ekr.20100701112151.5959"><vh>getDiff</vh></v>
</v>
<v t="ekr.20100124110832.6212"><vh>fc.propegateDirtyNodes</vh></v>
<v t="ekr.20120212220616.10537"><vh>fc.readExternalFiles</vh></v>
<v t="ekr.20141012064706.18242"><vh>fc.setMaxNodeIndex</vh></v>
<v t="ekr.20031218072017.1554"><vh>fc.warnOnReadOnlyFiles</vh></v>
</v>
<v t="ekr.20141012064706.18242"></v>
<v t="ekr.20120217070122.10470"><vh>c.initObjects</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20140902032918.18591"><vh> About this file</vh>
<v t="ekr.20140831085423.18639"><vh>&lt;&lt; about widgets and wrappers &gt;&gt;</vh></v>
<v t="ekr.20140831085423.18630"><vh>&lt;&lt; terminology &gt;&gt;</vh></v>
<v t="ekr.20140831085423.18631"><vh>&lt;&lt; official ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"></v>
<v t="ekr.20141012064706.18389"><vh>@file leoAst.py</vh></v>
<v t="ekr.20041005105605.1"></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20140827092102.18574"><vh>@file leoColorizer.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20130925160837.11429"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20050710142719"><vh>@file leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d71005506302e31352e3071017d71025808000000616e6e6f7461746571037d710473732e"
marks="ekr.20130111185820.10194,"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20120401063816.10072"><vh>@file leoIPython.py</vh></v>
<v t="ekr.20031218072017.3320"></v>
<v t="ekr.20140821055201.18331"><vh>@file leoPersistence.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20140810053602.18074"><vh>@file leoQt.py</vh></v>
<v t="ekr.20140526082700.18440"><vh>@file leoRope.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20120420054855.14241" descendentVnodeUnknownAttributes="7d7100285505302e332e3271017d71022858090000007374725f6374696d657103580c000000313331393436303438332e30710458090000007374725f6d74696d657105580d000000313331393436373035302e3438710658090000007374725f6174696d657107580d000000313331393436373035302e34387108755505302e332e3371097d710a2858090000007374725f6374696d65710b580c000000313331393436303438332e30710c58090000007374725f6d74696d65710d580d000000313332303432323639302e3534710e58090000007374725f6174696d65710f580d000000313332303433343235372e33367110755505302e332e3071117d71122858090000007374725f6374696d657113580c000000313331393439313330362e30711458090000007374725f6d74696d657115580d000000313331393439323330312e3532711658090000007374725f6174696d657117580d000000313331393534393339302e38397118755505302e332e3171197d711a2858090000007374725f6374696d65711b580c000000313331393436303438332e30711c58090000007374725f6d74696d65711d580d000000313331393436373033382e3235711e58090000007374725f6174696d65711f580c000000313332303432323637302e397120755505302e332e3471217d71222858090000007374725f6374696d657123580c000000313331393633383634382e30712458090000007374725f6d74696d657125580d000000313331393634313038352e3038712658090000007374725f6174696d657127580c000000313331393634353330362e327128755505302e332e3571297d712a2858090000007374725f6374696d65712b580c000000313331393633383634382e30712c58090000007374725f6d74696d65712d580c000000313331393634313131372e39712e58090000007374725f6174696d65712f580d000000313331393634313435352e3937713075752e"><vh>@file leoSessions.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@file leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
<v t="ekr.20131109170017.16504"><vh>@file leoVim.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20120419093256.10048"><vh>@file ../plugins/free_layout.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20140919181357.24956"><vh>@file ../plugins/qt_big_text.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qt_commands.py</vh></v>
<v t="ekr.20140907103315.18766"><vh>@file ../plugins/qt_events.py</vh></v>
<v t="ekr.20140907123524.18774"><vh>@file ../plugins/qt_frame.py</vh></v>
<v t="ekr.20140907085654.18699"><vh>@file ../plugins/qt_gui.py</vh></v>
<v t="ekr.20140907103315.18777"><vh>@file ../plugins/qt_idle_time.py</vh></v>
<v t="ekr.20140907123524.18777"><vh>@file ../plugins/qt_quickheadlines.py</vh></v>
<v t="ekr.20140831085423.18598"><vh>@file ../plugins/qt_text.py</vh></v>
<v t="ekr.20140907131341.18707"><vh>@file ../plugins/qt_tree.py</vh></v>
<v t="ekr.20110605121601.18002"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20110605121601.18695"><vh>QDesigner files</vh>
<v t="ekr.20110605121601.18696"><vh>@auto ../test/qtui_generate.py</vh></v>
<v t="ekr.20110605121601.18698"><vh>@auto ../plugins/qt_main.py</vh></v>
<v t="ekr.20110605121601.18703"><vh>@auto ../plugins/qt_main.ui</vh></v>
<v t="ekr.20110605121601.18704"><vh>@auto ../plugins/qt_quicksearch.py</vh></v>
<v t="ekr.20110605121601.18709"><vh>@auto ../plugins/qt_quicksearch.ui</vh></v>
</v>
</v>
<v t="ekr.20090802181029.5989"><vh>Startup &amp; external files</vh>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ekr.20130805134749.12436"><vh>@file ../external/edb.py</vh></v>
<v t="ekr.20120519121124.9919"><vh>@file ../external/leosax.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20141010141310.18627"><vh>@file ../external/PythonTidy.py</vh></v>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py </vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904" descendentVnodeUnknownAttributes="7d710055013071017d71025808000000616e6e6f746174657103285808000000616e6e6f7461746571047d710574710673732e"><vh>@file leoTest.py</vh></v>
</v>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="ekr.20031218072017.1553">def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):
    '''
        Read a .leo file.
        The caller should follow this with a call to c.redraw().
    '''
    fc,c = self,self.c
    c.setChanged(False) # May be set when reading @file nodes.
    fc.warnOnReadOnlyFiles(fileName)
    fc.checking = False
    fc.mFileName = c.mFileName
    fc.initReadIvars()
    try:
        c.loading = True # disable c.changed
        ok = True if silent else g.app.checkForOpenFile(c,fileName)
        if ok:
            ok = fc.getLeoFileHelper(theFile,fileName,silent)
                # Read the .leo file and create the outline.
            g.app.rememberOpenFile(fileName)
                # Remember the open file.
        else:
            fc.mFileName = c.mFileName = None
                # Bug fix. Clear the fileName so forgetOpenFile doesn't remove it.
        if ok:
            fc.resolveTnodeLists()
                # Do this before reading external files.
            c.setFileTimeStamp(fileName)
            if readAtFileNodesFlag:
                # Redraw before reading the @file nodes so the screen isn't blank.
                # This is important for big files like LeoPy.leo.
                c.redraw()
                fc.readExternalFiles(fileName)
            if c.config.getBool('check_outline_after_read'):
                c.checkOutline(event=None,verbose=True,unittest=False,full=True)
            fc.setMaxNodeIndex()
                # Fix bug https://github.com/leo-editor/leo-editor/issues/35
    finally:
        c.loading = False # reenable c.changed
        theFile.close()
            # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1208942
            # Leo holding directory/file handles after file close?
    if c.changed:
        fc.propegateDirtyNodes()
    c.setChanged(c.changed) # Refresh the changed marker.
    fc.initReadIvars()
    return ok, c.frame.ratio
</t>
<t tx="ekr.20031218072017.1554">def warnOnReadOnlyFiles (self,fileName):

    # os.access may not exist on all platforms.

    try:
        self.read_only = not os.access(fileName,os.W_OK)
    except AttributeError:
        self.read_only = False
    except UnicodeError:
        self.read_only = False

    if self.read_only and not g.unitTesting:
        g.error("read only:",fileName)
</t>
<t tx="ekr.20031218072017.1991"># Indices are Python dicts containing 'id','loc','time' and 'n' keys.

class NodeIndices (object):

    """A class to implement global node indices (gnx's)."""

    @others
</t>
<t tx="ekr.20031218072017.1992">def __init__ (self,id_):

    """ctor for NodeIndices class"""

    self.userId = id_
    self.defaultId = id_
    self.lastIndex = 0
    self.timeString = '' # Set by setTimeStamp.

    # A Major simplification: Only assign the timestamp once.
    self.setTimeStamp()
    self.lastIndex = 0
</t>
<t tx="ekr.20031218072017.1994"># These are used by the FileCommands read/write code.

def getDefaultId (self):
    """Return the id to be used by default in all gnx's"""
    return self.defaultId

def setDefaultId (self,theId):
    """Set the id to be used by default in all gnx's"""
    self.defaultId = theId
</t>
<t tx="ekr.20031218072017.1995">def getNewIndex (self):
    '''Create a new gnx.'''
    self.lastIndex += 1
    d = (self.userId,self.timeString,self.lastIndex)
    # new gnxs:
    return g.toUnicode("%s.%s.%d" % d)
    # old gnxs: retain for reference:
    # return d
</t>
<t tx="ekr.20031218072017.1997">def scanGnx (self,s,i=0):
    """Create a gnx from its string representation."""
    if not g.isString(s):
        g.error("scanGnx: unexpected index type:",type(s),'',s)
        return None,None,None
    s = s.strip()
    theId,t,n = None,None,None
    i,theId = g.skip_to_char(s,i,'.')
    if g.match(s,i,'.'):
        i,t = g.skip_to_char(s,i+1,'.')
        if g.match(s,i,'.'):
            i,n = g.skip_to_char(s,i+1,'.')
    # Use self.defaultId for missing id entries.
    if not theId:
        theId = self.defaultId
    # Convert n to int.
    # if n:
        # try: n = int(n)
        # except Exception: pass
    return theId,t,n
</t>
<t tx="ekr.20031218072017.1998">def setTimestamp (self):

    """Set the timestamp string to be used by getNewIndex until further notice"""

    self.timeString = time.strftime(
        "%Y%m%d%H%M%S", # Help comparisons; avoid y2k problems.
        time.localtime())

    # g.trace(self.timeString,self.lastIndex,g.callers(4))

setTimeStamp = setTimestamp
</t>
<t tx="ekr.20031218072017.1999">if 0:
    def toString (self,index):
        '''
        Convert a tuple, string or None to its string representation.
        *Important* the present sax code and earlier versions of Leo
        use various kinds of tuples.  Do *not* change the tuple-related code!
        '''
        if g.isString(index): # new gnxs:
            return g.toUnicode(index)
        elif index is None: # new gnxs:
            return self.getNewIndex() 
        try:
            theId,t,n = index
            if n in (None,0,'',):
                s = "%s.%s" % (theId,t)
            else:
                s = "%s.%s.%s" % (theId,t,n)
        except Exception:
            if not g.app.unitTesting:
                g.trace('unusual gnx',repr(index),g.callers()) 
            try:
                theId,t,n = self.getNewIndex()
                if n in (None,0,'',):
                    s = "%s.%s" % (theId,t)
                else:
                    s = "%s.%s.%d" % (theId,t,n)
            except Exception:
                s = repr(index)
                g.trace('double exception: returning repr(index)',s)
        return g.toUnicode(s)
</t>
<t tx="ekr.20031218072017.2406" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e">@tabwidth -4
@pagewidth 70

# This file contains almost all of Leo's sources.
# See the "About this file" node for important notes.
</t>
<t tx="ekr.20031218072017.2604">
</t>
<t tx="ekr.20031218072017.3077">def search (self):
    """
    Search s_ctrl for self.find_text with present options.
    Returns (pos, newpos) or (None,None).
    """
    trace = False and not g.unitTesting
    c = self.c
    p = self.p or c.p.copy()
    w = self.s_ctrl
    index = w.getInsertPoint()
    s = w.getAllText()
    if sys.platform.lower().startswith('win'):
        s = s.replace('\r','')
            # Ignore '\r' characters, which may appear in @edit nodes.
            # Fixes this bug: https://groups.google.com/forum/#!topic/leo-editor/yR8eL5cZpi4
            # This hack would be dangerous on MacOs: it uses '\r' instead of '\n' (!)
    if s:
        if trace: g.trace('=====',index,repr(s[max(0,index-10):index+40]))
    else:
        if trace: g.trace('returning: no text',p.h)
        return None,None
    stopindex = 0 if self.reverse else len(s)
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text)
    if trace: g.trace('pos,newpos',pos,newpos)
    # Bug fix: 2013/11/23.
    if self.in_headline and not self.search_headline:
        if trace: g.trace('not searching headlines')
        return None,None
    if not self.in_headline and not self.search_body:
        if trace: g.trace('not searching bodies')
        return None,None
    if pos == -1:
        if trace: g.trace('Returning: pos is -1')
        return None,None
    if self.passedWrapPoint(p,pos,newpos):
        if trace:
            kind = 'reverse ' if self.reverse else ''
            g.trace("** %swrap done",kind,pos,newpos)
        self.wrapPosition = None # Reset.
        return None,None
    ins = min(pos,newpos) if self.reverse else max(pos,newpos)
    w.setSelectionRange(pos,newpos,insert=ins)
    if trace: g.trace('** returns',pos,newpos)
    return pos,newpos
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20050328093147.1">@language rest

http://sourceforge.net/forum/message.php?msg_id=3064212
By: djsg  David 

The following applies to Leo 4.3, which is in alpha as I write this. It describes
the LeoSetup routine that I submitted to Edward to solve the "can't find Python"
problem, and which Edward cleaned up for distribution.

I think a few further issues need attention. I noticed them while working on
the "can't find Python" problem, and deferred dealing with them. This appears
to me to be a good time to pick them up.

Before I start work on them, I would like to lay them out for your comment.
Are they pains in the first place? Are my proposals good enough, and do they
make sense?

===== Proposal (General)

While LeoSetup should allow all accounts to share the Python code for core
Leo and its plug-ins, my guess is that we don't want to enforce that, since
Leo is a programmer's tool and the individual programmer will wish to
modify Leo and its pieces for the programmer's use.

===== Issue 1. LeoSetup still thinks Leo's user is an Administrator who owns the whole
machine.

For explanation, let's say that I log on as David to Windows 2000 or Windows
XP and install Leo 4.3. You then log out. You log in as Edward, and click Start,
pick Programs... you have no visible entry for Leo!

The current Setup routine allows no one but David to use Leo on this computer.
To make things worse, when I go to use Leo, I have to log in to Windows using
the account under which I installed it, which has Administrator rights to the
computer. In other words, I can't use Leo without operating the computer in
a mode that leaves it needlessly vulnerable to security violations.

===== Proposal Option 1.

Setup should ask whether to install Leo for everyone or for the installer's
account only. If the answer to that question is "yes," Setup should give
the user a private copy of everything that comes with Leo -- the only
application shared should be the current Python, assuming that it is
installed for all users.

Python.org's installer for Python 2.4 allows the installed Python to work only
for the account that installed it. I found this in December and wrote code to
handle it, which I then commented out since the issue wasn't critical. I can
check a computer with a single-account installation of Python in order to figure
out how a single-account installation of Leo would have to handle the click-to-open
behavior.

===== Issue 2. LeoSetup allows only one copy of Leo on a given computer. 

LeoSetup assumes that you want Leo in C:\Program Files\Leo. The installer can
override that already. LeoSetup also goes to some trouble to set up the usual
click-to-open behavior for .leo files. That behavior is tied to the copy of
Python that was current when I ran LeoSetup, and tied to the copy of Leo that
was installed most recently.

===== Proposal Option 2.

When LeoSetup finds Python installed for that single user, it should ask
whether to install Leo for the installer's account only. If the answer to
that question is "yes," Setup should give the user a private copy of
everything that comes with Leo and use the single-user installation of
Python. Why does this matter. If you need to test your plug-ins with
different versions of Python, this would make that easier.

===== Issue 3. LeoSetup does not run without human intervention. This complicates
deploying Leo in multi-computer sites.

The message box that displays the path of the Python installation found is one
issue. I put it in to allow the installer to cross-check Setup's behavior. Since
nobody has complained about problems with the code I wrote to fix the problem
installing with Python 2.4 and Active Python, Setup need no longer force the
installer to review the message box's contents.

===== Proposal: The message box needs to time out after, say, 15 seconds. 

I last looked at the installer three months ago so I would have to look at the
rest of it for other barriers to automated installation.
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily. 

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass. 

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.
  
- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction. 
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20060526081931">def searchHelper (self,s,i,j,pattern):
    '''Dispatch the proper search method based on settings.'''
    trace = False and not g.unitTesting
    backwards=self.reverse
    nocase=self.ignore_case
    regexp=self.pattern_match
    word=self.whole_word
    if backwards: i,j = j,i
    if trace: g.trace('entry',i,j,repr(s[min(i,j):max(i,j)]))
    if not s[i:j] or not pattern:
        if trace: g.trace('empty',i,j,'len(s)',len(s),'pattern',pattern)
        return -1,-1
    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)
    if trace: g.trace('returns',pos,newpos)
    return pos,newpos
</t>
<t tx="ekr.20060526092203">def regexHelper (self,s,i,j,pattern,backwards,nocase):
    trace = False and not g.unitTesting
    re_obj = self.re_obj # Use the pre-compiled object
    if not re_obj:
        g.trace('can not happen: no re_obj')
        return -1,-1
    if backwards:
        # Scan to the last match using search here.
        last_mo = None ; i = 0
        while i &lt; len(s):
            mo = re_obj.search(s,i,j)
            if not mo: break
            i += 1
            last_mo = mo
        mo = last_mo
    else:
        mo = re_obj.search(s,i,j)
    if trace: g.trace('backwards',backwards,'pattern',pattern,
        i,j,'s[i:j]',repr(s[i:j]),
        'mo.start/end',mo and mo.start(),mo and mo.end())
    while mo and 0 &lt;= i &lt;= len(s):
        # Bug fix: 2013/12/27: must be 0 &lt;= i &lt;= len(s)
        if mo.start() == mo.end():
            if backwards:
                # Search backward using match instead of search.
                i -= 1
                while 0 &lt;= i &lt; len(s):
                    mo = re_obj.match(s,i,j)
                    if mo: break
                    i -= 1
            else:
                i += 1 ; mo = re_obj.search(s,i,j)
        else:
            self.match_obj = mo
            return mo.start(),mo.end()
    self.match_obj = None
    return -1,-1
</t>
<t tx="ekr.20060526093531">def plainHelper (self,s,i,j,pattern,nocase,word):
    '''Do a plain search.'''
    trace = False and not g.unitTesting
    if trace: g.trace(i,j,repr(s[i:i+20]))
    if nocase:
        s = s.lower() ; pattern = pattern.lower()
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1:
                if trace: g.trace('no match word',i)
                return -1, -1
            elif self.matchWord(s,k,pattern):
                if trace: g.trace('match word',k)
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            if trace: g.trace('no match word',i)
            return -1, -1
        else:
            if trace: g.trace('match', k)
            return k, k + n
</t>
<t tx="ekr.20060526140328">def passedWrapPoint(self,p,pos,newpos):
    '''Return True if the search has gone beyond the wrap point.'''
    return (
        self.wrapping and
        self.wrapPosition is not None and
        p == self.wrapPosition and
            (self.reverse and pos &lt; self.wrapPos or
            not self.reverse and newpos &gt; self.wrapPos)
    )
</t>
<t tx="ekr.20060526140744">debugIndices = []

@
rfind(sub [,start [,end]])

Return the highest index in the string where substring sub is found, such that
sub is contained within s[start,end]. Optional arguments start and end are
interpreted as in slice notation. Return -1 on failure.
@c
def backwardsHelper (self,s,i,j,pattern,nocase,word):

    trace = False and not g.unitTesting
    if nocase:
        s = s.lower()
        pattern = pattern.lower()
            # Bug fix: 10/5/06: At last the bug is found!
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    # 2014/09/18: Put the indices in range.  Indices can get out of range
    # because the search code strips '\r' characters when searching @edit nodes.
    i = max(0,i)
    j = min(len(s),j)
    # Old code:
        # if i &lt; 0 or i &gt; len(s) or j &lt; 0 or j &gt; len(s):
            # g.trace('bad index: i = %s, j = %s' % (i,j))
            # i = 0 ; j = len(s)
    if trace and (s and i == 0 and j == 0):
        g.trace('two zero indices')
    # short circuit the search: helps debugging.
    if s.find(pattern) == -1:
        return -1,-1
    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            if trace: g.trace('**word** %3s %3s %5s -&gt; %s %s' % (
                i,j,'(end)' if j==len(s) else '',k,self.p.h))
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        if trace: g.trace('%3s %3s %5s -&gt; %s %s' % (
            i,j,'(end)' if j==len(s) else '',k,self.p.h))
        if k == -1:
            return -1, -1
        else:
            return k,k+n
</t>
<t tx="ekr.20060526140744.1">def matchWord(self,s,i,pattern):
    '''Do a whole-word search.'''
    trace = False and not g.unitTesting
    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        if trace: g.trace('empty')
        return False
    pat1,pat2 = pattern[0],pattern[-1]
    n = len(pattern)
    ch1 = 0 &lt;= i-1 &lt; len(s) and s[i-1] or '.'
    ch2 = 0 &lt;= i+n &lt; len(s) and s[i+n] or '.'
    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)
    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))
    inWord = isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2
    if trace: g.trace('returns',not inWord)
    return not inWord

</t>
<t tx="ekr.20060919110638.7">def createSaxVnode (self,sax_node,parent_v,v=None):

    c = self.c
    trace = False and not g.unitTesting and c.shortFileName().find('test') &gt; -1
    verbose = False
    h = sax_node.headString
    b = sax_node.bodyString
    if v:
        # The body of the later node overrides the earlier.
        # Don't set t.h: h is always empty.
        # This may be an internal error.
        if v.b == b:
            if trace and verbose: g.trace(
                '***no update\nold: %s\nnew: %s' % (v.b,b))
        else:
            if trace: g.trace(
                '***update\nold: %s\nnew: %s' % (v.b,b))
            v.b = b 
    else:
        v = leoNodes.VNode(context=c)
        v.setBodyString(b)
        v.setHeadString(h)
        if sax_node.tnx:
            x = g.app.nodeIndices
            # new gnxs:
            # Important: this should retain compatibility with old .leo files.
            v.fileIndex = x.tupleToString(x.scanGnx(sax_node.tnx))
            # old gnxs: retain for reference.
            # v.fileIndex = x.scanGnx(sax_node.tnx,0)
    index = self.canonicalTnodeIndex(sax_node.tnx)
    # new gnxs:
    index = g.toUnicode(index)
    self.gnxDict [index] = v
    if g.trace_gnxDict: g.trace(c.shortFileName(),index,v)
    if trace and verbose: g.trace(
        'tnx','%-22s' % (index),'v',id(v),
        'len(body)','%-4d' % (len(b)),h)
    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,v)
    return v
</t>
<t tx="ekr.20060919110638.8">def handleTnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.tnodeAttributes
    if trace and d: g.trace(sax_node,list(d.keys()))

    aDict = {}
    for key in d:
        val = g.toUnicode(d.get(key)) # 2011/02/22
        val2 = self.getSaxUa(key,val)
        # g.trace(key,val,val2)
        aDict[key] = val2

    if aDict:
        if trace: g.trace('uA',v,list(aDict.keys()))
        v.unknownAttributes = aDict
</t>
<t tx="ekr.20061004053644"># The native attributes of &lt;v&gt; elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnodeUnknownAttributes.
# New in Leo 4.5: added descendentVnodeUnknownAttributes to native attributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.attributes

    s = d.get('a')
    if s:
        if trace and 'E' in s: g.trace('expand',v)
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.red('handleVnodeSaxAttributes: setting currentVnode',v)
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnodeList will be resolved later.
        if trace: g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentTnodeUaDictList',aDict)
            self.descendentTnodeUaDictList.append(aDict)

    s = d.get('descendentVnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentVnodeUaDictList',aDict)
            self.descendentVnodeUaDictList.append((v,aDict),)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d:
        if key in self.nativeVnodeAttributes:
            # This is not a bug.
            if False and trace: g.trace(
                '****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # if trace: g.trace('uA',v,aDict)
        v.unknownAttributes = aDict
</t>
<t tx="ekr.20061031131434.28">def compute_completion_list (self):

    trace = False and not g.unitTesting
    verbose = False
        # True: report hits and misses.
        # False: report misses.

    if self.klass:
        prefix = ''
        # something later on eats the first char, not sure what
        options = ['^'+i for i in self.lookup_methods([str(self.klass)],None)]
        g.es("%s: %d options" % (self.klass, len(options)))
        self.klass = None
    else:
        prefix = self.get_autocompleter_prefix()
        key,options = self.get_cached_options(prefix)
        if options:
            if trace and verbose: g.trace('**prefix hit: %s, %s' % (prefix,key))
        else:
            if trace: g.trace('**prefix miss: %s, %s' % (prefix,key))
            options = self.get_completions(prefix)

    tabList,common_prefix = g.itemsMatchingPrefixInList(
        prefix,options,matchEmptyPrefix=False)

    if not common_prefix:
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            prefix,options,matchEmptyPrefix=True)

    if trace and verbose:
        g.trace('prefix: %s, common: %s, len(tabList): %s' % (
            repr(prefix),repr(common_prefix),len(tabList)))
        # if verbose: g.trace('options[:10]...\n',
            # g.listToString(options[:10],sort=True))

    if tabList:
        self.show_completion_list(common_prefix,prefix,tabList)

    return common_prefix,prefix,tabList
</t>
<t tx="ekr.20070105165924">def replaceBackSlashes (self,s):
    '''Carefully replace backslashes in a search pattern.'''
    # This is NOT the same as:
    # s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.
    i = 0
    while i + 1 &lt; len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1
    return s
</t>
<t tx="ekr.20080412053100.5">
























@language python</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20090526081836.5841">def getLeoFileHelper(self,theFile,fileName,silent):

    '''Read the .leo file and create the outline.'''

    c,fc = self.c,self
    try:
        ok = True
        v = fc.readSaxFile(theFile,fileName,silent,inClipboard=False,reassignIndices=False)
        if v: # v is None for minimal .leo files.
            c.setRootVnode(v)
            fc.rootVnode = v
        else:
            v = leoNodes.VNode(context=c)
            v.setHeadString('created root node')
            p = leoNodes.Position(v)
            p._linkAsRoot(oldRoot=None)
            fc.rootVnode = v
            # c.setRootPosition()
            c.changed = False
    except BadLeoFile:
        junk, message, junk = sys.exc_info()
        if not silent:
            g.es_exception()
            c.alert(fc.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    return ok
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20090802181029.5989"></t>
<t tx="ekr.20100120072650.6088"></t>
<t tx="ekr.20100124110832.6212">def propegateDirtyNodes (self):

    fc = self ; c = fc.c

    aList = [z.copy() for z in c.all_positions() if z.isDirty()]
    for p in aList:
        p.setAllAncestorAtFileNodesDirty()
</t>
<t tx="ekr.20100205060712.8314">def handleNodeConflicts (self):

    c = self.c
    if not c.nodeConflictList: return

    # Find the last top-level node.
    sib = c.rootPosition()
    while sib.hasNext():
        sib.moveToNext()

    # Create the 'Recovered Nodes' node.
    root = sib.insertAfter()
    root.setHeadString('Recovered Nodes')
    root.expand()

    # For each conflict, create one child and two grandchildren.
    for bunch in c.nodeConflictList:
        tag = bunch.get('tag') or ''
        gnx = bunch.get('gnx') or ''
        fn  = bunch.get('fileName') or ''
        b1,h1 = bunch.get('b_old'),bunch.get('h_old')
        b2,h2 = bunch.get('b_new'),bunch.get('h_new')
        child = root.insertAsLastChild()
        h = 'Recovered node "%s from %s' % (h1,g.shortFileName(fn))
        child.setHeadString(h)
        # child.setBodyString('%s %s' % (tag,gnx))
        line1 = '%s %s\nDiff...\n' % (tag,gnx)
        d = difflib.Differ().compare(g.splitLines(b2),g.splitLines(b1))
        # d = difflib.unified_diff(g.splitLines(b2),g.splitLines(b1))
        diffLines = [z for z in d]
        lines = [line1]
        lines.extend(diffLines)
        # There is less need to show trailing newlines because
        # we don't report changes involving only trailing newlines.
        child.setBodyString(''.join(lines)) # .replace('\n','\\n\n'))
        n1 = child.insertAsNthChild(0)
        n2 = child.insertAsNthChild(1)
        n1.setHeadString('old:'+h1)
        n1.setBodyString(b1)
        n2.setHeadString('new:'+h2)
        n2.setBodyString(b2)

    return root
</t>
<t tx="ekr.20100701112151.5959">def getDiff (self,s1,s2):

    # pylint: disable=E1120
    # E1120:getDiff: No value passed for parameter 'b' in function call

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    diffLines = difflib.Differ.compare(lines1,lines2)
    return diffLines
</t>
<t tx="ekr.20110514051607.14524">def get_cached_options(self,prefix):

    trace = False and not g.unitTesting
    d = self.completionsDict

    # Search the completions Dict for shorter and shorter prefixes.
    i = len(prefix)

    while i &gt; 0:
        key = prefix[:i]
        i -= 1
        # Make sure we report hits only of real objects.
        if key.endswith('.'):
            if trace: g.trace('== period: %s' % (key))
            return key,[]
        options = d.get(key)
        if options:
            if trace: g.trace('== hit: %s len: %s' % (
                key,len(options)))
            return key,options
        else:
            if trace: g.trace('== miss: %s' % (key))

    return None,[]
</t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.</t>
<t tx="ekr.20110605121601.18695"></t>
<t tx="ekr.20120212220616.10537">def readExternalFiles(self,fileName):

    c,fc = self.c,self

    c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
    recoveryNode = fc.handleNodeConflicts()

    # Do this after reading external files.
    # The descendent nodes won't exist unless we have read the @thin nodes!
    fc.restoreDescendentAttributes()

    fc.setPositionsFromVnodes()
    c.selectVnode(recoveryNode or c.p) # load body pane
</t>
<t tx="ekr.20120217070122.10470">def initObjects(self,gui):

    trace = (False or g.trace_startup) and not g.unitTesting
    c = self
    if trace:
        print('g.initObjects %s %s' % (c.shortFileName(),g.app.gui))
    self.hiddenRootNode = leoNodes.VNode(context=c)
    self.hiddenRootNode.setHeadString('&lt;hidden root VNode&gt;')
    # g.trace(c.hiddenRootNode.fileIndex,c.shortFileName())
    self.hiddenRootNode.fileIndex = 'hidden-root-vnode-gnx'
    # Create the gui frame.
    title = c.computeWindowTitle(c.mFileName)
    if not g.app.initing:
        g.doHook("before-create-leo-frame",c=c)
    self.frame = gui.createLeoFrame(c,title)
    assert self.frame
    assert self.frame.c == c
    self.NodeHistory = NodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.
    # Break circular import dependencies by importing here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoCache as leoCache
    import leo.core.leoChapters as leoChapters
    import leo.core.leoEditCommands as leoEditCommands
    import leo.core.leoFind as leoFind # Leo 4.11.1
    import leo.core.leoKeys as leoKeys
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoPersistence as leoPersistence
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoTest as leoTest
    import leo.core.leoUndo as leoUndo
    # import leo.core.leoViews as leoViews
    import leo.core.leoVim as leoVim
    self.keyHandler = self.k = leoKeys.KeyHandlerClass(c)
    self.chapterController  = leoChapters.ChapterController(c)
    self.shadowController   = leoShadow.ShadowController(c)
    self.fileCommands       = leoFileCommands.FileCommands(c)
    self.findCommands       = leoFind.LeoFind(c)
    self.atFileCommands     = leoAtFile.AtFile(c)
    self.importCommands     = leoImport.LeoImportCommands(c)
    self.persistenceController = leoPersistence.PersistenceDataController(c)
    self.rstCommands        = leoRst.RstCommands(c)
    self.tangleCommands     = leoTangle.TangleCommands(c)
    self.testManager        = leoTest.TestManager(c)
    # self.viewController     = leoViews.ViewController(c)
    self.vimCommands        = leoVim.VimCommands(c)
    self.editCommandsManager = leoEditCommands.EditCommandsManager(c)
    self.editCommandsManager.createEditCommanders()
    self.cacher = leoCache.Cacher(c)
    self.cacher.initFileDB(self.mFileName)
    self.undoer = leoUndo.Undoer(self)
    import leo.plugins.free_layout as free_layout
    self.free_layout = free_layout.FreeLayoutController(c)
    if hasattr(g.app.gui,'styleSheetManagerClass'):
        self.styleSheetManager = g.app.gui.styleSheetManagerClass(c)
    else:
        self.styleSheetManager = None
</t>
<t tx="ekr.20130806072439.20650">From: Winn Dixie &lt;incredible0n3@gmail.com&gt;

Would be stellar to have a brew install leo (for Mac OSX 10.7.X) with
possible built in options to install vim bindings.

http://brew.sh/
Homebrew formulae are simple Ruby scripts:

require "formula"

class Wget &lt; Formula
  homepage "http://www.gnu.org/software/wget/"
  url "http://ftp.gnu.org/gnu/wget/wget-1.15.tar.gz"
  sha1 "f3c925f19dfe5ed386daae4f339175c108c50574"

  def install
    system "./configure", "--prefix=#{prefix}"
    system "make", "install"
  end
end


To install homebrew, paste this in a terminal:

ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"

The script explains what it will do and then pauses before it does it.
There are more installation options here (needed on 10.5).
</t>
<t tx="ekr.20130806072439.20732">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Summary - it's easy to make a .zip file containing Leo and all it's
dependencies.

Inspired by Matt's recipe, using VirtualBox throw away 1GB Windows XP
32 bit machines, I tried the following.

Install Python (installer from python.org) 2.7.2 to 

  C:\Docouments and Settings\someuser\Desktop\leo\python27

Install PyQt (installer from Riverbank) 4.9 into the same folder (it
goes there by default)

Unzip http://www.greygreen.org/leo/leo-editor-latest.zip into

  C:\Docouments and Settings\someuser\Desktop\leo\leo-editor-latest

Make leo.zip from C:\Docouments and Settings\someuser\Desktop\leo

Delete the virtual machine, purging any registry entries etc. created
by the two installers.

On a fresh machine, searched the registry for 'python' just to be sure,
found nothing.

Unzip the .zip file, then

  cd C:\Docouments and Settings\someuser\Desktop\leo
  python27\python.exe leo-editor-latest\launchLeo.py

And Leo opens a blank outline, after asking for an ID, as it's supposed
to.  Didn't test it beyond that.

So, the .zip file contains all Leo needs to run, and obviously
runLeo.bat could be added in the top level to actually launch it.

Of course this is for Windows, so I think it's an improvement over
asking people to install Python and PyQt first, but neither of those
steps was that hard in Windows anyway.

===== EKR

Is this a technique that we could use for official Windows releases?
If so, what exactly would we do?

===== Terry

I guess, perhaps as an all-in-one option with a system integrated
option for those who want to use system python/qt.  Don't know if it
violates and licensing on Python / Qt, everything's being distributed
unaltered, so I wouldn't think so.

So basically you'd give people a large .zip file and tell them to
extract it to a folder and run the batchfile at the top level.  If they
can't do that, they might not be ready for Leo :-)  I guess you could
make it a self-extracting .zip, for that matter.

Also, the daily snapshot could be made this way, seeing once Python and
Qt are installed in the folder the Leo version can just be copied in.

It's not uncommon for FLOSS to be distributed this way, both Blender
and Inkscape use this approach, particularly for recent builds.

===== From: HansBKK &lt;hansbkk@gmail.com&gt;

If something like this **is** done, it should IMO be packaged as an
alternative to the normal installation procedure.

You would definitely get marketing exposure by getting the specs from
PortableApps.com and let them host it there as  "Portable Leo", tracking
the "official" Portable Python (currently 2.7.2) as a dependency, obviously
including QT etc as well. But it would need to be kept up to date. . .

Most Windows users would be better served by following the normal
installation procedure and ending up with a
registry-and-environment-variables-complete install of Python et al which
they can use for other things beyond Leo. Ending up with multiple instances
of Python to maintain is likely to cause more problems.

And the normal Windows install just isn't that hard, really! Improving the
current instructions, by providing a step-by-step "cookbook" with direct
links to the download packages etc might make it a **little** easier (IMO
only for the clueless), but then of course that would be a doc that would
need pretty frequent updates, which if I may be so bold doesn't seem to
happen too quickly on the doc side.
</t>
<t tx="ekr.20130806072439.20736">From: Matt Wilkie &lt;maphew@gmail.com&gt;

Since this topical today, almost a year later, I thought I'd take a run at 
repeating this using Portable Python (http://www.portablepython.com) as a 
base. It didn't work, but I think it should. Maybe someone else knows why. 

I ran the installer for 2.7.3 since 3.2 doesn't include PyQt4. At install 
time I selected only the Python and PyQt4 packages. Then from a fresh 
command shell:

{{{
path=c:\windows;c:\windows\system32
pushd x:\portapy27\App
path=%cd%;%cd%\Scripts;%cd%\Lib\site-packages\PyQt4;%path%
set pythonhome=%cd%
set pythonpath=%cd%\Lib

popd

python --version
Python 2.7.3

python -c "import PyQt4"
:: no error returned, we're good.

python c:\apps\leo-editor-latest\launchLeo.py
Leo requires Qt to be installed.
}}}

oh well.
</t>
<t tx="ekr.20130806072439.20744">From: HansBKK &lt;hansbkk@gmail.com&gt;

&gt; PortableApps version would be FANTASTIC!!

A couple of versions have been posted here already, including Terry's very
simple sequence in the first message of this thread. Of course, we're only
talking about Windows, but note that it works equally well either syncing
with whatever tool (I favor Unison over SSH) or carrying around on an
arbitrary-path'd external device, including flash drives (but they can be
slow).

Here's my more robust (hence more complex) version, xx indicating your 
python version (mine is 27):

Use the normal .MSI, setup.exe etc processes to Install a clean "canonical" 
version of your "python dev stack" to say C:\PythonXX, reboot if needed, 
test thoroughly. Note any new environment variables pointing to your new 
binary locations.

Now create a corresponding PythonXX folder in your "PortableApps" location 
(I put it under "CommonFiles" along with GTK and Java) and copy everything 
from your installed location to the portable one.

You can then use the project-provided tools on the "master" computer to 
keep your binaries updated, and they will see any local Registry entries 
and the environment variables they created and operate normally wrt your 
installed location (e.g. C:\PythonXX).

If you have a local folder sync tool (I use Unison and WinMerge) you can 
add to/remove from/configure your Python environment from either location, 
otherwise just keep your installed location as the "master" and just copy 
the whole stack over each time you do so.

The whole PortableApps tree can then be sync'd/copied to any other 
desktop(s) you like, either over the wire or via an external device, and 
the latter can be carried for use in say an Internet cafe or client-site 
situation.

====================

For use on those other computers, for running in portable mode, I use a
"portable start menu" (PStart) which allows for its own "autolaunch" batch
files, where I set some global environment variables to be used by
app-specific launch batch files, including :

%Path% (I add my batch folder and a general utility/tools folder)
%HOME% (usually "E:\aasync\Data\H_HOME"
and a custom one called %h_pa%, which points to the root of my PortableApps 
parent (usually "D:\aasync\PortableApps")

Then for each environment that requires its own custom settings, I create a 
launch batch file that builds on that base. In the case of Python apps, 
here's an example that opens a CMD console window:

@ECHO OFF
set 
PATH=%PATH%;%h_pa%\CommonFiles\Python27;%h_pa%\CommonFiles\Python27\Lib\site-packages\PyQt4;%h_pa%\CommonFiles\Python27\Lib\idlelib;%h_pa%\CommonFiles\Python27\Scripts;
set PROMPT=$p_python$g
E:
cd \aasync
CMD.exe

I'm not sure which if any of the environment stuff Leo requires, but I 
figure it might as well have the same environment as my Python CLI, since 
I'll be testing shell integration, including iPython. In my leo-win.bat, 
the last three lines above are replaced with:

D:
cd \aasync\PortableApps\leo-editor
start "" "..\CommonFiles\Python27\pythonw.exe" 
"..\CommonFiles\Python27\Lib\site-packages\leo-editor4\launchLeo.py" %*

====================

Note this is more than the minimum you need to just run Leo - you could of 
course simplify it; for example, only set the environment variables Leo 
requires, or you could just set the master computer' installation routines 
to use a single location under PortableApps, but I prefer to keep them 
separate for testing purposes.

I hope you (and others googling this later) find this useful.
</t>
<t tx="ekr.20130807203905.16594">@language rest

From the thread: "Associate .Leo files to open with Leo when double click"
https://groups.google.com/d/msg/leo-editor/KOXSm8crU1I/qCLYzZCJuc4J

From: &lt;fidelperez@gmail.com&gt;

1. Include a small file within the Quickstart guide which would associate
   files automatically. (Or maybe asking for imput, which can be done
   through a Leo node and this way the user learns about its
   functionality).

2. More buttons or scripts in quick start guide, preferably before the
   "programming" section, so when a new user opens it, he has had the
   opportunity to do Ctrl+B on several scripts (for instance, showing in
   the log the name of all the nodes within the selected one, having some
   subnodes with numbers and doing math on them and showing the result on
   the log pane, and as much "silly" but visual functions as possible so
   the user, by going pressing ctrl+b on each, gets a bigger chance to
   understand what is Leo. In my oppinion some users will just stop in the
   quickguide if they are not presented with such a thing before going to
   docs.leo etc.

3. The description of the plugins is not as accessible as it should be. A
   script for activating them easier, been a week using Leo and still cant
   quite activate, find the descriptions or use them freely... And if each
   plugin or script had an example of use that would be priceless, for
   instance, including them all in quickstart (both scripts, plugins
   branchs) and then the new user could just go through all clicking on the
   examples and just seeing Leo work and show its potential. I know some of
   those are done but as I said, after a week or so I still am very
   confused...

4. Quickstart should be open by default (instead of current Leo workbook)
   at least until the user changes some config and prevents that from
   happening. Is there any "load previous tabs" functionality? (IE open the
   Leo files which where open when it was closed the last time)
</t>
<t tx="ekr.20130807203905.16596">From the thread: Cannot open Leo files by double-click in Windows Explorer?
https://groups.google.com/d/msg/leo-editor/KwrqYGMH20Q/z1uc-99vsnsJ

From: HansBKK &lt;hansbkk@gmail.com&gt;

For those like me who work in "portable" mode, there's a very cool tool
called "PortableFileAssociator" that allows you to create a set of windows
file associations, icons etc and enable/disable the whole profile at one
time, without messing with the local system's registry.

Also handy for those not in portable mode, but working on different windows
boxes and bored with having to tweak each one separately.
</t>
<t tx="ekr.20131004191204.16078"># Use table?
</t>
<t tx="ekr.20131016032805.16721" annotate="7d71002e">def execute_shell_commands(commands,trace = False):
    '''
    Execute each shell command in a separate process.
    Wait for each command to complete, except those starting with '&amp;'
    '''
    if g.isString(commands): commands = [commands]
    for command in commands:
        wait = not command.startswith('&amp;')
        if command.startswith('&amp;'): command = command[1:].strip()
        if trace: print('\n&gt;%s%s\n' % ('' if wait else '&amp;',command))
        proc = subprocess.Popen(command,shell=True)
        if wait: proc.communicate()
</t>
<t tx="ekr.20131025044901.17146"># Don't change selected node!
</t>
<t tx="ekr.20131027064821.18715">https://groups.google.com/forum/#!topic/leo-editor/rTN1S9u74RQ

 It works for me, but only in special cases.

The reason the *exact* example above works is that:

a) c.atFileCommands.write is *already* a valid completion and
b) c.atFileCommands.write is *also* a prefix of other at.fileCommands methods.

In that case, 
 
auto_completer_state_handler is still active, and the '?' characters works.

Obviously, there are many other situations where you have typed a unique method name, which causes auto_completer_state_handler to exit.  In those more common cases, the '?' character won't work.

There is no quick fix for this.  Probably a new command is needed.
</t>
<t tx="ekr.20131103054650.16527"></t>
<t tx="ekr.20131111060930.18010"># Standard bindings...
# run-selected-unit-tests-externally = Alt-4 
# run-marked-unit-tests-externally = Alt-5
# run-marked-unit-tests-locally = Alt-6
run-selected-unit-tests-locally = Alt-4
do-nothing = Alt-5
run-marked-unit-tests-locally = Alt-6
</t>
<t tx="ekr.20131121084830.16362"># Toggle the settings.
g.app.debug_app = not g.app.debug_app
g.app.debug_widgets = not g.app.debug_widgets
# Report the new settings.
print('g.app.debug_app: %s' % g.app.debug_app)
print('g.app.debug_widgets: %s' % g.app.debug_widgets)
</t>
<t tx="ekr.20131220065609.16590"></t>
<t tx="ekr.20140102162014.16438">unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class LocalConfigManager--&gt;c.config.Getters--&gt;c.config.Getters--&gt;c.config.getData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class GlobalConfigManager--&gt;gcm.Getters...--&gt;gcm.getData &amp; getOutlineData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;&lt;&lt; class ParserBaseClass &gt;&gt;--&gt;kind handlers (ParserBaseClass)--&gt;doData
@language rest
The parser for @data nodes, doData, no longer strips *anything*.</t>
<t tx="ekr.20140103105930.16446"></t>
<t tx="ekr.20140808103117.18035"></t>
<t tx="ekr.20140808103117.18036">gnx: ekr.20110605121601.18696
</t>
<t tx="ekr.20140808103117.18038">gnx: ekr.20110605121601.18698
</t>
<t tx="ekr.20140808103117.18040">gnx: ekr.20110605121601.18703
</t>
<t tx="ekr.20140808103117.18042">gnx: ekr.20110605121601.18704
</t>
<t tx="ekr.20140808103117.18044">gnx: ekr.20110605121601.18709
</t>
<t tx="ekr.20140824043305.18300">All bugs must be fixed for b1.
I'll fix as many bugs as I can for a1.

Fix all git bugs:
https://github.com/leo-editor/leo-editor/labels/bug

- @data qt-scintilla-styles *only* works in leoSetting.leo, not myLeoSettings.leo.

- Vim borders don't work with my standard settings and python3.4 and Qt5
</t>
<t tx="ekr.20140831085423.18630">@language rest

This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:
    
si:     a g.ShortcutInfo object.
ks:     a g.KeyStroke object
stroke: a KeyStroke object.

btw:    leoFrame.BaseTextWrapper
stw:    leoFrame.StringTextWrapper

bqtw:   qt_text.BaseQTextWrapper
lqtb:   qt_text.LeoQTextBrowser
qhlw:   qt_text.QHeadlineWrapper
qmbw:   qt_text.QMinibufferWrapper
qlew:   qt_text.QLineEditWrapper
qsciw:  qt_text.QScintiallaWrapper
qtew:   qt_text.QTextEditWrapper</t>
<t tx="ekr.20140831085423.18631">@language rest

The following are 'official' ivars that will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.widget     The gui widget for the body pane.
c.frame.body.wrapper    The high level interface for the body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.log.widget      The gui widget for the log pane.
c.frame.log.wrapper     The high-level inteface for the log pane.
c.frame.tree            The tree pane.

The following ivars no longer exist:

c.frame.body.bodyCtrl   Use c.frame.body.wrapper instead.
c.frame.log.logCtrl     Use c.frame.log.wrapper instead.</t>
<t tx="ekr.20140831085423.18639">@language rest

Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly.  Instead...

2. A **wrapper class** defines a standard api that hides the details
   of the underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code
treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases.
All wrapper classes define an official "widget" ivar, so core or
plugin code can gain access to the real Qt widget using
wrapper.widget. Searching for wrapper.widget will (or soon will) find
all gui-dependent snippets of code in Leo's core.
</t>
<t tx="ekr.20140902032918.18591">@
&lt;&lt; about widgets and wrappers &gt;&gt;
&lt;&lt; terminology &gt;&gt;
&lt;&lt; official ivars &gt;&gt;
</t>
<t tx="ekr.20140902155015.18674"></t>
<t tx="ekr.20140903025053.18625"></t>
<t tx="ekr.20140905060158.18560">'''
A script to replace body.x with body.wrapper.x for all x in the WrapperAPI.

It is *not undoable* to save massive amounts of memory.
Please run on an already-saved .leo file, and take all other reasonable precautions.

If replace is False, it will just report the changes to be made.
'''
import leo.core.leoFrame as leoFrame
replace = False
aList = sorted([z for z in dir(leoFrame.WrapperAPI) if not z.startswith('__')])
nodes = 0
for p in c.all_unique_positions():
    s = p.b
    nodes += 1
    found = False
    for target in aList:
        i = 0
        pattern = 'body.' + target
        while True:
            i = s.find(pattern,i)
            if i == -1:
                break
            if g.match_word(s,i,pattern):
                if not found:
                    print('In node: %s' % p.h)
                    found = True
                i1,i2 = g.getLine(s,i)
                if replace:
                    j = i + len('body.')
                    s = s[:j] + 'wrapper.' + s[j:]
                    print(s[i1:i2+len('wrapper.')].rstrip())
                    i += len('wrapper.') + len(pattern)
                else:
                    print(s[i1:i2].rstrip())
                    i += len(pattern)
            else:
                i += len(pattern)
    if found and replace:
        p.b = s
print('searched %s nodes' % nodes)
</t>
<t tx="ekr.20140905060158.18561">a = c.frame.body.getInsertPoint()

aBody.getInsertPoint()

if 1:
    c.frame.body.setInsertPoint(0)</t>
<t tx="ekr.20140907201613.18661"></t>
<t tx="ekr.20140916101314.19538">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20140917154740.17918">@language rest

For a1:

1. Fixing all bugs that could have a major impact on Leo's stability.

For example, issue #35 re duplicate gnx's. I'll review all outstanding bugs
for their effects on stability.

I am dithering about what to do about #28 re large nodes. This must either
become completely solid before a1 or it must be removed entirely from the
5.0 release.

2. Making the install process as easy as possible.

The to-do list contains several good ideas, such as supporting homebrew
install and making Leo a portable app. I'll do as many as possible.

3. Making Leo as easy as possible for newbies.

For example, Fidel made several good suggestions:
https://groups.google.com/d/msg/leo-editor/KOXSm8crU1I/qCLYzZCJuc4J

Fidel suggests quickstart guide should open by default instead of the
user's workbook.

4. Refine the "fit and finish" items as much as possible.

Seemingly small issues such as focus issues are surprisingly important and
difficult to test.

5. Resolving *all* outstanding documentation issues, including summarizing
   many previous conversations. This could take several days.
</t>
<t tx="ekr.20140917180536.19478">@language rest
</t>
<t tx="ekr.20140918124632.19450"># This script prints the list of known Qt names. Qt seems to ignore case.
from leo.core.leoQt import QtGui
aList = sorted([g.u(z) for z in QtGui.QColor().colorNames()])
print('\n'.join(aList))
</t>
<t tx="ekr.20140919052413.17945">@language rest

https://groups.google.com/d/msg/leo-editor/ujDqUI68Sx4/EwTYCw7O38cJ

In the "Find" tab, check the "suboutline only"

Select an outline, and search for any text on its subtree, for instance
"a". This outline shouldnt have "a" within its text.

Now select another outline (that should have "a" within its text), then
click "Find next" or just do "F3"

It should make the search again, this time within the subtree of the
selected node, but instead, it will give you "not found 'a'"

It will only work if you change the search. So if you want to search for
the same term within another outline, you have to change that twice.

I think this bug also interferes with searches not limited to the
sub-outline, but still wouldn't be able to pinpoint it.


</t>
<t tx="ekr.20140919052413.17946">Do this after the new run-script commands</t>
<t tx="ekr.20140919093158.17876"></t>
<t tx="ekr.20140919145841.17947"></t>
<t tx="ekr.20140920041848.17923">@language rest

1. Improve docstring for bigdash.py:
- Mention global-search command
- Say that the inner "help" command is the way to restore the original
  appearance of the dashboard.

2. Add bigdash to listing of plugins at http://leoeditor.com/plugins.html

3. Fix focus problem with F11 &amp; help-for-command

4. Add modules/plugins to help-for-command.
</t>
<t tx="ekr.20140920064112.17946"></t>
<t tx="ekr.20140921072018.17937">@language rest

run-script-from-bridge
run-script-externally
    * Specify which version of python to use.
    
*** The at_produce plugin now has technology for reporting progress using the IdleTime class.

This technology should become part of g.execute_shell_commands.  New settings will control whether, and how often, to report progress.

*** There will soon be two new functions for running both Leo and non-Leo scripts externally.

- g.run_python_script_externally would simply create an external file containing the script and then run python on that file.

- g.run_leo_script_externally would do something similar using the Leo bridge.

Both functions would be controlled by new settings, including (Kent will be glad) what version of Python.


*** Revise http://leoeditor.com/leoBridge.html

There are several ways to run code externally:

- Using leo.core.leoBridgeTest.
- (When ready) using g.run_leo_script_externally.
- Using the full-blown method that Terry discusses in that chapter.
</t>
<t tx="ekr.20140921072018.17938">* Why not just improve g.execute_shell_commands ?
    - It could report too.
    - And it could use settings too.

- time-between-notifications: 0 means disable notifications.
- Decrease time between calls to idle-time handler.</t>
<t tx="ekr.20140921072018.17943">'''A minimal Leo bridge application'''
# This can not be run locally!
import leo.core.leoBridge as leoBridge
b = leoBridge.controller(
    gui='nullGui',loadPlugins=True,
    silent=False,tracePlugins=True,verbose=False)
g = b.globals()
path = g.os_path_finalize_join(g.app.loadDir,'..','doc','LeoDocs.leo')
assert g.os_path_exists(path)
c = b.openLeoFile(path)
assert c
assert c.rootPosition()
</t>
<t tx="ekr.20140921132351.17921"></t>
<t tx="ekr.20140921180304.17919"></t>
<t tx="ekr.20140922043414.17947"># http://leoeditor.com/leoBridge.html#running-leobridge-from-within-leo

import sys
import subprocess
path = r'c:\Users\edreamleo\test\leo_bridge_test.py'
    ### Create file containing script
assert g.os_path_exists(path)
proc = subprocess.Popen([sys.executable,path])
proc.communicate()
</t>
<t tx="ekr.20140922043414.17948"># From within the bridge, do:
import leo.core.leoTest as leoTest
helper = leoTest.RunTestExternallyHelperClass(c,all=True,marked=False)
helper.runUnitTestLeoFile(
    path='unitTest.leo',
        # The path, relative to leo/test.  The full path will be:
        # g.os_path_finalize_join(g.app.loadDir,'..','test',relative_path)
    gui=None, # Use a Null gui.
    loadPlugins=True,
    readSettings=True,
    silent=True,
    tracePlugins=True,
    verbose=True,
)
</t>
<t tx="ekr.20140922043414.17949">import leo.core.leoBridgeTest as leoBridgeTest

leoBridgeTest.main()</t>
<t tx="ekr.20140922124047.19514"></t>
<t tx="ekr.20140923085942.17943"></t>
<t tx="ekr.20140923144655.17926"></t>
<t tx="ekr.20141006073719.17938"></t>
<t tx="ekr.20141010071140.31027">gnx: ekr.20140225224703.8169
unl: qtui_generate declarations
</t>
<t tx="ekr.20141010071140.31028">gnx: ekr.20140225224703.8170
unl: qt_main declarations
gnx: ekr.20140225224703.8171
unl: class Ui_MainWindow
gnx: ekr.20140902074657.9511
unl: class Ui_MainWindow--&gt;setupUi
gnx: ekr.20140225224703.8173
unl: class Ui_MainWindow--&gt;retranslateUi
</t>
<t tx="ekr.20141010071140.31029"></t>
<t tx="ekr.20141010071140.31030">gnx: ekr.20140225224703.8174
unl: qt_quicksearch declarations
gnx: ekr.20140225224703.8175
unl: class Ui_LeoQuickSearchWidget
gnx: ekr.20140225224703.8176
unl: class Ui_LeoQuickSearchWidget--&gt;setupUi
gnx: ekr.20140225224703.8177
unl: class Ui_LeoQuickSearchWidget--&gt;retranslateUi
</t>
<t tx="ekr.20141010071140.31031"></t>
<t tx="ekr.20141011053251.18205">@language rest

Explore:

- Virtual machines
- PortableFileAssociator
- Homebrew install for Mac.
</t>
<t tx="ekr.20141012064706.18240">https://github.com/leo-editor/leo-editor/issues/35</t>
<t tx="ekr.20141012064706.18242">def setMaxNodeIndex(self):
    '''
        Ensure that g.app.nodeIndices.lastIndex can collide with gnx.
        Fixes bug https://github.com/leo-editor/leo-editor/issues/35
    '''
    trace = False and not g.unitTesting
    if trace:
        import time
        t = time.clock()
    c,ni = self.c,g.app.nodeIndices
    max_n,n,stamp = ni.lastIndex,0,ni.timeString
    for v in c.all_unique_nodes():
        stamp2,id2,n2 = ni.scanGnx(v.fileIndex)
        if stamp == stamp2 and isinstance(n2,(int,long)) and n2 &gt; max_n:
            if trace: g.trace(stamp,n2)
            max_n = n
        n += 1
    ni.lastIndex = max_n
    if trace:
        g.trace('%20s hidden gnx: %s max_n: %s' % (
            c.shortFileName(),c.hiddenRootNode.fileIndex,max_n))
        # g.trace('nodes: %s stamp0: %s max_n %s %4.2f sec.' % (
            # n,stamp,max_n,time.clock()-t))
</t>
<t tx="ekr.20141012064706.18243">Bug #69 re collisions.</t>
<t tx="ekr.20141012064706.18244"></t>
<t tx="ekr.20141012064706.18245"></t>
<t tx="ekr.20141012064706.18533"></t>
<t tx="ekr.20141015035853.18304">def tupleToString (self,aTuple):
    '''
    Convert a gnx tuple returned by scanGnx
    to its string representation.
    '''
    theId,t,n = aTuple
    # This logic must match the existing logic so that
    # previously written gnx's can be found.
    if n in (None,0,'',):
        s = "%s.%s" % (theId,t)
    else:
        s = "%s.%s.%s" % (theId,t,n)
    return g.toUnicode(s)
</t>
<t tx="ekr.20141015035853.18305">@language rest

1. createSaxVnode now does::
    
    v.fileIndex = ni.tupleToString(x.scanGnx(sax_node.tnx))
    
ni.tupleToString is substantially simpler than ni.toString.

2. ni.scanGnx no longer converts n to an int.  It's going to become a string again anyway.

@language python
</t>
<t tx="ekr.20141015084905.18441">It should always scroll left when selected.</t>
</tnodes>
</leo_file>
