<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="http://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20221129012213.1"><vh>@bool run-flake8-on-write = False</vh></v>
<v t="ekr.20140902155015.18674"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20210530065000.2"><vh>@data exec-script-commands</vh></v>
<v t="ekr.20210530065000.3"><vh>@data exec-script-patterns</vh></v>
<v t="ekr.20150425145248.1"><vh>@data history-list</vh></v>
<v t="ekr.20220904210247.1"><vh>@enabled-plugins</vh></v>
<v t="ekr.20140916101314.19538"><vh>@string target_language = python</vh></v>
<v t="ekr.20200212095937.1"><vh>Beautify command settings</vh>
<v t="ekr.20200212095937.2"><vh>@bool beautify-allow-joined-strings = False</vh></v>
<v t="ekr.20200212095937.3"><vh>@bool beautify-keep-comment-indentation = True</vh></v>
<v t="ekr.20200212095937.5"><vh>@int beautify-max-join-line-length = 0</vh></v>
<v t="ekr.20200212095937.6"><vh>@int beautify-max-split-line-length = 0</vh></v>
</v>
<v t="ekr.20160122104332.1"><vh>Buttons &amp; commands</vh>
<v t="ekr.20150502050609.1"><vh>@button backup</vh></v>
<v t="ekr.20170811173924.1"><vh>@button backup-repo</vh></v>
<v t="ekr.20220823130338.1"><vh>@button check-leoPy.leo</vh></v>
<v t="ekr.20230508145335.1"><vh>@command slow-tests</vh></v>
<v t="ekr.20220306092217.1"><vh>@command test-one</vh>
<v t="ekr.20230511074046.1"><vh>&lt;&lt; prefixes &gt;&gt;</vh></v>
<v t="ekr.20230724084617.1"><vh>&lt;&lt; old tests &gt;&gt;</vh></v>
</v>
<v t="ekr.20201013034659.1"><vh>@ignore Unused buttons and commands</vh>
<v t="ekr.20211020091540.1"><vh>@@command b</vh></v>
<v t="ekr.20220527065937.1"><vh>@command json-to-outline</vh></v>
<v t="ekr.20150413091056.1"><vh>@@button check-clones</vh></v>
<v t="ekr.20180324065741.1"><vh>@@button copy-to-next</vh></v>
<v t="ekr.20150507170849.1"><vh>@@button create decorators</vh>
<v t="ekr.20150508063538.1"><vh>create_d</vh></v>
<v t="ekr.20150508071622.1"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150508063412.1"><vh>create_decorators</vh></v>
<v t="ekr.20150508074623.1"><vh>create_fixups</vh></v>
<v t="ekr.20150508063926.1"><vh>find_class</vh></v>
<v t="ekr.20150507174711.1"><vh>find_next_clone</vh></v>
<v t="ekr.20150507175246.1"><vh>munge_lines</vh></v>
<v t="ekr.20150508062944.1"><vh>run</vh></v>
</v>
<v t="ekr.20211011090013.1"><vh>@@button cvt-comments</vh>
<v t="ekr.20220425184232.1"><vh>compute_lws</vh></v>
<v t="ekr.20220425052306.1"><vh>convert</vh></v>
</v>
<v t="ekr.20150509183433.1"><vh>@@button make-decorators2</vh>
<v t="ekr.20150509183433.2"><vh>create_d</vh></v>
<v t="ekr.20150509183433.3"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150509183433.4"><vh>create_decorators V2</vh></v>
<v t="ekr.20150509183433.8"><vh>munge_lines</vh></v>
<v t="ekr.20150509183433.9"><vh>run V2</vh></v>
</v>
<v t="ekr.20201013034742.2"><vh>@@button make-importer</vh>
<v t="ekr.20201013034742.3"><vh>&lt;&lt; define run &amp; helpers &gt;&gt;</vh>
<v t="ekr.20201013034742.4"><vh>copy_tree (make-importer)</vh></v>
<v t="ekr.20201013034742.5"><vh>make_substitutions</vh></v>
<v t="ekr.20201013034742.6"><vh>run</vh></v>
<v t="ekr.20201013034742.7"><vh>substitue</vh></v>
</v>
<v t="ekr.20201013034742.8"><vh>@@file importers/{{name}}.py</vh>
<v t="ekr.20201013034742.9"><vh>class {{cap_name}}_Importer</vh>
<v t="ekr.20201013034742.10"><vh>{{name}}.Overrides</vh>
<v t="ekr.20201013034742.11"><vh>{{name}}.clean_headline</vh></v>
<v t="ekr.20201013034742.12"><vh>{{name}}.clean_nodes</vh></v>
</v>
</v>
<v t="ekr.20201013034742.13"><vh>class {{cap_name}}_ScanState</vh></v>
</v>
</v>
<v t="ekr.20190406154306.1"><vh>@@button open-pyzo</vh></v>
<v t="ekr.20201013034742.16"><vh>@@button pep8 @key=Ctrl-5</vh>
<v t="ekr.20201013034742.17"><vh>class Pep8</vh>
<v t="ekr.20201013034742.18"><vh>change_all &amp; helpers</vh>
<v t="ekr.20201013034742.19"><vh>change_body</vh></v>
<v t="ekr.20201013034742.20"><vh>change_headline</vh></v>
</v>
<v t="ekr.20201013034742.21"><vh>get_name</vh></v>
<v t="ekr.20201013034742.22"><vh>run</vh></v>
<v t="ekr.20201013034742.23"><vh>to_pep8</vh></v>
</v>
<v t="ekr.20201013034742.24"><vh>clear</vh></v>
</v>
<v t="ekr.20150703061709.1"><vh>@@button run-pylint</vh></v>
<v t="ekr.20180824065751.1"><vh>@@button show-gnx</vh></v>
<v t="ekr.20131121084830.16362"><vh>@@button toggle-debug</vh></v>
<v t="ekr.20201018062305.1"><vh>@@button write-leoPyRef</vh>
<v t="ekr.20201018065757.1"><vh>check_file_names</vh></v>
<v t="ekr.20201018065921.1"><vh>check_nodes</vh></v>
<v t="ekr.20201018070822.1"><vh>main</vh></v>
<v t="ekr.20201018072911.1"><vh>oops</vh></v>
<v t="ekr.20201018063747.1"><vh>put_content</vh></v>
<v t="ekr.20210510071427.1"><vh>put_prolog</vh></v>
<v t="ekr.20210510071812.1"><vh>put_tnodes</vh></v>
</v>
</v>
</v>
<v t="ekr.20210110092457.1"><vh>leojs buttons</vh>
<v t="ekr.20210110092457.5"><vh>@@@button cov @key=ctrl-6</vh></v>
<v t="ekr.20210110092457.6"><vh>@@@button moz @key=ctrl-7</vh></v>
<v t="ekr.20210110092457.7"><vh>@@@button unit</vh></v>
</v>
</v>
<v t="ekr.20170427114412.1"><vh>scripts</vh>
<v t="ekr.20170427112302.1"><vh>check leoPy.leo</vh></v>
<v t="ekr.20170428084123.1"><vh>Recursive import script</vh></v>
<v t="ekr.20201222095250.1"><vh>script: check for duplicate settings in theme files</vh></v>
<v t="ekr.20200308193719.1"><vh>script: check gnx's</vh></v>
<v t="ekr.20210429045101.1"><vh>script: check gnxDict</vh></v>
<v t="ekr.20210118013157.1"><vh>script: convert-LeoFind</vh>
<v t="ekr.20210118024739.1"><vh>convert</vh></v>
<v t="ekr.20210118013807.1"><vh>main</vh></v>
<v t="ekr.20210118020530.1"><vh>new_name</vh></v>
<v t="ekr.20210118021337.1"><vh>exists</vh></v>
</v>
<v t="ekr.20210829132319.1"><vh>script: cvt-tests</vh></v>
<v t="ekr.20190402091335.1"><vh>script: diff-branches/revs (all files)</vh></v>
<v t="ekr.20180816105258.1"><vh>script: diff-branches/revs (one file)</vh></v>
<v t="ekr.20201208114843.1"><vh>script: diff-pr</vh></v>
<v t="ekr.20220319145807.1"><vh>script: diff-two-revs-wo-comments</vh>
<v t="ekr.20220319151900.1"><vh>function: make_diff_outlines_ignoring_comments</vh></v>
<v t="ekr.20220319152417.1"><vh>function: strip_comments</vh></v>
</v>
<v t="ekr.20220318085657.1"><vh>script: find trailing comments</vh></v>
<v t="ekr.20220503081113.1"><vh>script: find-non-calls</vh>
<v t="ekr.20220503193901.1"><vh>old suppressions</vh></v>
<v t="ekr.20220503084900.1"><vh>&lt;&lt; init core_p, command_p and globals_p &gt;&gt;</vh></v>
<v t="ekr.20220503084230.1"><vh>function: check</vh></v>
<v t="ekr.20220503084045.1"><vh>function: scan</vh></v>
</v>
<v t="ekr.20201015145257.1"><vh>script: import legacy file</vh></v>
<v t="ekr.20230720115916.1"><vh>script: node-history</vh></v>
<v t="ekr.20210630070717.1"><vh>script: restore gnxs in leoserver.py (full version)</vh>
<v t="ekr.20210701044426.1"><vh>&lt;&lt; setup &gt;&gt;</vh></v>
<v t="ekr.20210701044513.1"><vh>&lt;&lt; read into a1_s, b1_s &gt;&gt;</vh></v>
</v>
<v t="ekr.20210630103405.1"><vh>script: restore gnxs in leoserver.py (simple version)</vh></v>
<v t="ekr.20200222083959.1"><vh>script: start loggin</vh></v>
<v t="ekr.20211014103433.1"><vh>script: web-to-outline</vh>
<v t="ekr.20211014112513.1"><vh>Handlers</vh></v>
<v t="ekr.20211014120710.1"><vh>new_node</vh></v>
</v>
<v t="ekr.20200222151754.1"><vh>script: yoton "other end"</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20170302123956.1"><vh>@file ../doc/leoAttic.txt</vh></v>
</v>
<v t="ekr.20221204070905.1"><vh>Script files</vh>
<v t="ekr.20221204072456.1"><vh>@clean ../scripts/beautify-leo.cmd</vh></v>
<v t="ekr.20230115020533.1"><vh>@clean ../scripts/blacken-leo.cmd</vh></v>
<v t="ekr.20221204074235.1"><vh>@clean ../scripts/flake8-leo.cmd</vh></v>
<v t="ekr.20221204071554.1"><vh>@clean ../scripts/full-test-leo.cmd</vh></v>
<v t="ekr.20230206004301.1"><vh>@clean ../scripts/make-leo.cmd</vh></v>
<v t="ekr.20221204071146.1"><vh>@clean ../scripts/mypy-leo.cmd</vh></v>
<v t="ekr.20221204071056.1"><vh>@clean ../scripts/pylint-leo.cmd</vh></v>
<v t="ekr.20221204072154.1"><vh>@clean ../scripts/reindent-leo.cmd</vh></v>
<v t="ekr.20230628105236.1"><vh>@clean ../scripts/ruff-leo.cmd</vh></v>
<v t="ekr.20221201043917.1"><vh>@clean ../scripts/test-leo.cmd</vh></v>
<v t="ekr.20221204071220.1"><vh>@clean ../scripts/test-one-leo.cmd</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20140902032918.18591"><vh>About this file</vh>
<v t="ekr.20140831085423.18639"><vh>About widgets and wrappers</vh></v>
<v t="ekr.20140831085423.18630"><vh>Terminology</vh></v>
<v t="ekr.20140831085423.18631"><vh>Official ivars</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20141012064706.18389"><vh>@file leoAst.py</vh></v>
<v t="ekr.20150323150718.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20161026193447.1"><vh>@file leoBackground.py</vh></v>
<v t="ekr.20150521115018.1"><vh>@file leoBeautify.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20140827092102.18574"><vh>@file leoColorizer.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20180212072657.2"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20130925160837.11429"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20130302121602.10208"><vh>@file leoDebugger.py</vh></v>
<v t="ekr.20160306114544.1"><vh>@file leoExternalFiles.py</vh></v>
<v t="ekr.20181202062518.1"><vh>@file leoFastRedraw.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20150514154159.1"><vh>@file leoHistory.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20120401063816.10072"><vh>@file leoIPython.py</vh></v>
<v t="ekr.20190515070742.1"><vh>@file leoMarkup.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
<v t="ekr.20140821055201.18331"><vh>@file leoPersistence.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20150419124739.1"><vh>@file leoPrinting.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20140810053602.18074"><vh>@file leoQt.py</vh></v>
<v t="ekr.20210407010914.1"><vh>@file leoQt5.py</vh></v>
<v t="ekr.20210407011013.1"><vh>@file leoQt6.py</vh></v>
<v t="ekr.20140526082700.18440"><vh>@file leoRope.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20120420054855.14241"><vh>@file leoSessions.py</vh></v>
<v t="ekr.20120420054855.14241"></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20180121041003.1"><vh>@file leoTips.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
<v t="ekr.20131109170017.16504"><vh>@file leoVim.py</vh></v>
</v>
<v t="ekr.20150514035207.1"><vh>Command classes</vh>
<v t="ekr.20150514035236.1"><vh>@file ../commands/abbrevCommands.py</vh></v>
<v t="ekr.20150514035943.1"><vh>@file ../commands/baseCommands.py</vh></v>
<v t="ekr.20150514035559.1"><vh>@file ../commands/bufferCommands.py</vh></v>
<v t="ekr.20161021090740.1"><vh>@file ../commands/checkerCommands.py</vh></v>
<v t="ekr.20171123135539.1"><vh>@file ../commands/commanderEditCommands.py</vh></v>
<v t="ekr.20171123095353.1"><vh>@file ../commands/commanderFileCommands.py</vh></v>
<v t="ekr.20171124073126.1"><vh>@file ../commands/commanderHelpCommands.py</vh></v>
<v t="ekr.20171124080430.1"><vh>@file ../commands/commanderOutlineCommands.py</vh></v>
<v t="ekr.20150514040100.1"><vh>@file ../commands/controlCommands.py</vh></v>
<v t="ekr.20160316095222.1"><vh>@file ../commands/convertCommands.py</vh></v>
<v t="ekr.20150514040118.1"><vh>@file ../commands/debugCommands.py</vh></v>
<v t="ekr.20150514035813.1"><vh>@file ../commands/editCommands.py</vh></v>
<v t="ekr.20150514041209.1"><vh>@file ../commands/editFileCommands.py</vh></v>
<v t="ekr.20150624112334.1"><vh>@file ../commands/gotoCommands.py</vh></v>
<v t="ekr.20150514040138.1"><vh>@file ../commands/helpCommands.py</vh></v>
<v t="ekr.20150514040140.1"><vh>@file ../commands/keyCommands.py</vh></v>
<v t="ekr.20150514040142.1"><vh>@file ../commands/killBufferCommands.py</vh></v>
<v t="ekr.20150514040146.1"><vh>@file ../commands/rectangleCommands.py</vh></v>
<v t="ekr.20150514040239.1"><vh>@file ../commands/spellCommands.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20180225010644.1"><vh>Other files</vh>
<v t="ekr.20180225010707.1"><vh>In leo-editor directory</vh>
<v t="ekr.20220222130955.1"><vh>@edit ../../.mypy.ini</vh></v>
<v t="ekr.20230702120645.1"><vh>@@edit ../../.dmypy.ini</vh></v>
<v t="ekr.20210302164046.1"><vh>@edit ../../launchLeo.py</vh></v>
<v t="ekr.20150304125314.4"><vh>@file ../../leo_to_html.xsl</vh></v>
<v t="ekr.20181014073705.1"><vh>@file ../../run_pytest_tests.py</vh></v>
<v t="ekr.20181009072707.1"><vh>@file ../../run_travis_unit_tests.py</vh></v>
<v t="maphew.20180224170853.1"><vh>@file ../../setup.py</vh></v>
<v t="ekr.20221129164042.1"><vh>@edit ../../setup.cfg</vh></v>
<v t="ekr.20150304130753.4"><vh>leo-viewer/leo_to_html.xsl</vh></v>
<v t="ekr.20221201080228.1"><vh>To be deleted ../../blacken_leo.py</vh></v>
</v>
<v t="ekr.20230717210524.1"><vh>In leo/docs</vh>
<v t="ekr.20230716154653.1"><vh>@edit ../../docs/load-leo.html</vh></v>
</v>
<v t="ekr.20180225010913.1"><vh>In leo/core</vh>
<v t="ekr.20210202110241.1"><vh>@file leoclient.py</vh></v>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py</vh></v>
<v t="felix.20210621233316.1"><vh>@file leoserver.py</vh></v>
<v t="ekr.20230203163544.1"><vh>@file tracing_utils.py</vh></v>
</v>
<v t="ekr.20180225010743.1"><vh>In leo/external</vh>
<v t="ekr.20190607124533.1"><vh>@nopylint</vh>
<v t="ekr.20220823195205.1"><vh>@clean ../external/leoftsindex.py</vh></v>
<v t="ekr.20160123142722.1"><vh>@clean ../external/make_stub_files.cfg</vh></v>
<v t="ekr.20180708145905.1"><vh>@clean ../external/py2cs_theory.md</vh>
<v t="ekr.20180708152000.1"><vh>The problem</vh></v>
<v t="ekr.20180708152018.1"><vh>Design</vh></v>
<v t="ekr.20180708145905.6"><vh>Using TokenSync class</vh></v>
<v t="ekr.20180708145905.7"><vh>Summary</vh></v>
</v>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ekr.20130805134749.12436"><vh>@file ../external/edb.py</vh></v>
<v t="ekr.20120519121124.9919"><vh>@file ../external/leosax.py</vh></v>
<v t="ekr.20170429161422.1"><vh>@file ../external/log_broadcast.py</vh></v>
<v t="ekr.20170429153135.1"><vh>@file ../external/log_listener.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20160317054700.1"><vh>@file ../external/make_stub_files.py</vh></v>
<v t="ekr.20180628055640.1"><vh>@file ../external/pdb_listener.py</vh></v>
<v t="ekr.20160316091132.1"><vh>@file ../external/py2cs.py</vh></v>
<v t="ekr.20220823195753.1"><vh>@file ../external/stringlist.py</vh></v>
<v t="ekr.20170428085201.1"><vh>npyscreen</vh>
<v t="ekr.20170428084207.3"><vh>@file ../external/npyscreen/apNPSApplication.py</vh></v>
<v t="ekr.20170428084207.11"><vh>@file ../external/npyscreen/apNPSApplicationAdvanced.py</vh></v>
<v t="ekr.20170428084207.15"><vh>@file ../external/npyscreen/apNPSApplicationEvents.py</vh></v>
<v t="ekr.20170428084207.29"><vh>@file ../external/npyscreen/apNPSApplicationManaged.py</vh></v>
<v t="ekr.20170428084207.50"><vh>@file ../external/npyscreen/apOptions.py</vh></v>
<v t="ekr.20170428084207.111"><vh>@file ../external/npyscreen/eveventhandler.py</vh></v>
<v t="ekr.20170428084207.121"><vh>@file ../external/npyscreen/fmActionForm.py</vh></v>
<v t="ekr.20170428084207.131"><vh>@file ../external/npyscreen/fmActionFormV2.py</vh></v>
<v t="ekr.20170428084207.153"><vh>@file ../external/npyscreen/fmFileSelector.py</vh></v>
<v t="ekr.20170428084207.174"><vh>@file ../external/npyscreen/fmForm.py</vh></v>
<v t="ekr.20170428084207.223"><vh>@file ../external/npyscreen/fmFormMultiPage.py</vh></v>
<v t="ekr.20170428084207.248"><vh>@file ../external/npyscreen/fmFormMutt.py</vh></v>
<v t="ekr.20170428084207.258"><vh>@file ../external/npyscreen/fmFormMuttActive.py</vh></v>
<v t="ekr.20170428084207.285"><vh>@file ../external/npyscreen/fmFormWithMenus.py</vh></v>
<v t="ekr.20170428084207.303"><vh>@file ../external/npyscreen/fmPopup.py</vh></v>
<v t="ekr.20170428084207.311"><vh>@file ../external/npyscreen/fm_form_edit_loop.py</vh></v>
<v t="ekr.20170428084207.322"><vh>@file ../external/npyscreen/globals.py</vh></v>
<v t="ekr.20170428084207.324"><vh>@file ../external/npyscreen/muMenu.py</vh></v>
<v t="ekr.20170428084207.332"><vh>@file ../external/npyscreen/muNewMenu.py</vh></v>
<v t="ekr.20170428084207.351"><vh>@file ../external/npyscreen/npysGlobalOptions.py</vh></v>
<v t="ekr.20170428084207.353"><vh>@file ../external/npyscreen/npysNPSFilteredData.py</vh></v>
<v t="ekr.20170428084207.364"><vh>@file ../external/npyscreen/npyspmfuncs.py</vh></v>
<v t="ekr.20170428084207.370"><vh>@file ../external/npyscreen/npyssafewrapper.py</vh></v>
<v t="ekr.20170428084207.377"><vh>@file ../external/npyscreen/npysThemeManagers.py</vh></v>
<v t="ekr.20170428084207.390"><vh>@file ../external/npyscreen/npysThemes.py</vh></v>
<v t="ekr.20170428084207.399"><vh>@file ../external/npyscreen/npysTree.py</vh></v>
<v t="ekr.20170428084207.422"><vh>@file ../external/npyscreen/proto_fm_screen_area.py</vh></v>
<v t="ekr.20170428084207.434"><vh>@file ../external/npyscreen/stdfmemail.py</vh></v>
<v t="ekr.20170428084207.464"><vh>@file ../external/npyscreen/utilNotify.py</vh></v>
<v t="ekr.20170428084207.477"><vh>@file ../external/npyscreen/util_viewhelp.py</vh></v>
<v t="ekr.20170428084207.480"><vh>@file ../external/npyscreen/wgannotatetextbox.py</vh></v>
<v t="ekr.20170428084207.494"><vh>@file ../external/npyscreen/wgautocomplete.py</vh></v>
<v t="ekr.20170428084207.503"><vh>@file ../external/npyscreen/wgboxwidget.py</vh></v>
<v t="ekr.20170428084207.524"><vh>@file ../external/npyscreen/wgbutton.py</vh></v>
<v t="ekr.20170428084207.536"><vh>@file ../external/npyscreen/wgcheckbox.py</vh></v>
<v t="ekr.20170428084207.561"><vh>@file ../external/npyscreen/wgcombobox.py</vh></v>
<v t="ekr.20170428084207.575"><vh>@file ../external/npyscreen/wgdatecombo.py</vh></v>
<v t="ekr.20170428084207.586"><vh>@file ../external/npyscreen/wgeditmultiline.py</vh></v>
<v t="ekr.20170428084207.611"><vh>@file ../external/npyscreen/wgfilenamecombo.py</vh></v>
<v t="ekr.20170428084207.618"><vh>@file ../external/npyscreen/wgFormControlCheckbox.py</vh></v>
<v t="ekr.20170428084208.1"><vh>@file ../external/npyscreen/wggrid.py</vh></v>
<v t="ekr.20170428084208.36"><vh>@file ../external/npyscreen/wggridcoltitles.py</vh></v>
<v t="ekr.20170428084208.43"><vh>@file ../external/npyscreen/wgmonthbox.py</vh></v>
<v t="ekr.20170428084208.68"><vh>@file ../external/npyscreen/wgmultiline.py</vh></v>
<v t="ekr.20170428084208.157"><vh>@file ../external/npyscreen/wgmultilineeditable.py</vh></v>
<v t="ekr.20170428084208.173"><vh>@file ../external/npyscreen/wgmultilinetree.py</vh></v>
<v t="ekr.20170428084208.213"><vh>@file ../external/npyscreen/wgmultilinetreeselectable.py</vh></v>
<v t="ekr.20170428084208.225"><vh>@file ../external/npyscreen/wgmultiselect.py</vh></v>
<v t="ekr.20170428084208.245"><vh>@file ../external/npyscreen/wgmultiselecttree.py</vh></v>
<v t="ekr.20170428084208.253"><vh>@file ../external/npyscreen/wgNMenuDisplay.py</vh></v>
<v t="ekr.20170428084208.285"><vh>@file ../external/npyscreen/wgpassword.py</vh></v>
<v t="ekr.20170428084208.290"><vh>@file ../external/npyscreen/wgselectone.py</vh></v>
<v t="ekr.20170428084208.297"><vh>@file ../external/npyscreen/wgslider.py</vh></v>
<v t="ekr.20170428084208.318"><vh>@file ../external/npyscreen/wgtextbox.py</vh></v>
<v t="ekr.20170428084208.354"><vh>@file ../external/npyscreen/wgtextboxunicode.py</vh></v>
<v t="ekr.20170428084208.359"><vh>@file ../external/npyscreen/wgtextbox_controlchrs.py</vh></v>
<v t="ekr.20170428084208.366"><vh>@file ../external/npyscreen/wgtexttokens.py</vh></v>
<v t="ekr.20170428084208.381"><vh>@file ../external/npyscreen/wgtitlefield.py</vh></v>
<v t="ekr.20170428084208.398"><vh>@file ../external/npyscreen/wgwidget.py</vh></v>
<v t="ekr.20170428084208.436"><vh>@file ../external/npyscreen/wgwidget_proto.py</vh></v>
<v t="ekr.20170428084208.443"><vh>@@file ../external/npyscreen/__init__.py</vh>
<v t="ekr.20170428084208.444"><vh>Declarations</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20180225010850.1"><vh>In leo/modes</vh>
<v t="ekr.20221129095254.1"><vh>@file ../modes/batch.py</vh></v>
<v t="ekr.20150326145530.1"><vh>@file ../modes/forth.py</vh></v>
<v t="ekr.20230419050031.1"><vh>@file ../modes/html.py</vh></v>
<v t="ekr.20230419052236.1"><vh>@file ../modes/javascript.py</vh></v>
<v t="ekr.20210223151922.1"><vh>@file ../modes/julia.py</vh></v>
<v t="ekr.20210219115553.109"><vh>@file ../modes/python.py</vh></v>
</v>
</v>
<v t="ekr.20201012111545.1"><vh>Plugins</vh>
<v t="ekr.20090430075506.3"><vh>@file ../plugins/leoPluginNotes.txt</vh></v>
<v t="EKR.20040517090508"><vh>Enable plugins using @enabled-plugins nodes</vh></v>
<v t="ekr.20050303051035"><vh>Templates</vh>
<v t="ekr.20041114102139"><vh>Notes for plugin writers</vh></v>
<v t="ekr.20050306071629"><vh>Template for plugins that override commander methods</vh>
<v t="ekr.20050306071629.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050306071629.3"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050306071629.4"><vh>init</vh></v>
<v t="ekr.20050306071540"><vh>onStart2</vh></v>
</v>
<v t="ekr.20050303051035.2"><vh>Template for plugins with per-commander controller class</vh>
<v t="ekr.20050303051035.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050303051101"><vh>init</vh></v>
<v t="ekr.20050303051150"><vh>onCreate</vh></v>
<v t="ekr.20050303051222"><vh>class pluginController</vh>
<v t="ekr.20050303051222.1"><vh>__init__</vh></v>
</v>
</v>
</v>
<v t="ekr.20100103093121.5365"><vh>Auto completion</vh>
<v t="ekr.20091118065749.5261"><vh>@file ../plugins/ctagscompleter.py</vh></v>
</v>
<v t="edream.110203113231.667"><vh>Commands &amp; directives</vh>
<v t="edream.110203113231.741"><vh>@file ../plugins/add_directives.py</vh></v>
<v t="ekr.20101110084839.5682"><vh>@file ../plugins/bzr_qcommands.py</vh></v>
<v t="EKR.20040517080049.1"><vh>@file ../plugins/empty_leo_file.py</vh></v>
<v t="edream.110203113231.669"><vh>@file ../plugins/import_cisco_config.py</vh></v>
<v t="ekr.20101110092851.5812"><vh>@file ../plugins/initinclass.py</vh></v>
<v t="ekr.20101110091234.5700"><vh>@file ../plugins/leo_interface.py</vh></v>
<v t="ekr.20040419105219"><vh>@file ../plugins/lineNumbers.py</vh></v>
<v t="ekr.20040916084945"><vh>@file ../plugins/macros.py</vh></v>
<v t="edream.110203113231.724"><vh>@file ../plugins/mod_autosave.py</vh></v>
<v t="ekr.20050301083306"><vh>@file ../plugins/mod_read_dir_outline.py</vh></v>
<v t="edream.110203113231.727"><vh>@file ../plugins/mod_timestamp.py</vh></v>
<v t="TL.20090225102340.32"><vh>@file ../plugins/nodeActions.py</vh></v>
<v t="edream.110203113231.720"><vh>@file ../plugins/outline_export.py</vh></v>
<v t="danr7.20060912105041.1"><vh>@file ../plugins/paste_as_headlines.py</vh></v>
<v t="ekr.20081214160729.1"><vh>@file ../plugins/setHomeDirectory.py</vh></v>
<v t="ajones.20070122160142"><vh>@file ../plugins/textnode.py</vh></v>
<v t="danr7.20061010105952.1"><vh>@file ../plugins/word_count.py</vh></v>
</v>
<v t="edream.110203113231.729"><vh>Debugging</vh>
<v t="ekr.20101110091234.5689"><vh>@file ../plugins/debugger_pudb.py</vh></v>
<v t="edream.110203113231.730"><vh>@file ../plugins/dump_globals.py</vh></v>
<v t="edream.110203113231.732"><vh>@file ../plugins/enable_gc.py</vh></v>
<v t="edream.110203113231.734"><vh>@file ../plugins/quit_leo.py</vh></v>
<v t="edream.110203113231.735"><vh>@file ../plugins/trace_gc_plugin.py</vh></v>
<v t="edream.110203113231.738"><vh>@file ../plugins/trace_tags.py</vh></v>
</v>
<v t="ekr.20041030092101"><vh>Dyna plugins by e</vh></v>
<v t="ekr.20040722141148"><vh>Examples</vh>
<v t="ekr.20040828105233"><vh>@file ../plugins/examples/chinese_menu.py</vh></v>
<v t="EKR.20040517080202.3"><vh>@file ../plugins/examples/french_fm.py</vh></v>
<v t="edream.110203113231.916"><vh>@file ../plugins/examples/override_classes.py</vh></v>
<v t="edream.110203113231.919"><vh>@file ../plugins/examples/override_commands.py</vh></v>
<v t="ekr.20060621123339"><vh>@file ../plugins/examples/print_cp.py</vh></v>
<v t="edream.110203113231.921"><vh>@file ../plugins/examples/redefine_put.py</vh></v>
<v t="ekr.20180119164431.1"><vh>@file ../plugins/patch_python_colorizer.py</vh></v>
<v t="ekr.20210329114352.1"><vh>@file ../plugins/example_rst_filter.py</vh></v>
</v>
<v t="ekr.20101110150056.9457"><vh>Experimental/Obsolete</vh>
<v t="tbrown.20081223111325.3"><vh>@file ../plugins/backlink.py</vh></v>
<v t="ekr.20090704103932.5160"><vh>@file ../plugins/leo_pdf.py</vh></v>
<v t="danr7.20060902083957"><vh>@file ../plugins/leo_to_rtf.py</vh></v>
<v t="ekr.20040205071616"><vh>@file ../plugins/mnplugins.py</vh></v>
<v t="ekr.20101110094759.5843"><vh>@file ../plugins/mod_speedups.py</vh></v>
<v t="tbrown.20070117104409"><vh>@file ../plugins/quickMove.py</vh></v>
<v t="ekr.20040910070811.1"><vh>@file ../plugins/run_nodes.py</vh></v>
<v t="ekr.20100103093121.5339"><vh>@file ../plugins/stickynotes_plus.py</vh></v>
<v t="ekr.20040331071919"><vh>Leo to AsciiDoc</vh>
<v t="ekr.20101110093449.5822"><vh>@file ../plugins/mod_leo2ascd.py</vh></v>
<v t="ekr.20101110150056.9445"><vh>@file ../plugins/mod_leo2ascd.txt</vh></v>
</v>
</v>
<v t="EKR.20040517075715"><vh>External programs</vh>
<v t="ekr.20110125103904.12504"><vh>@file ../plugins/gitarchive.py</vh></v>
<v t="EKR.20040517080049.4"><vh>@file ../plugins/open_shell.py</vh></v>
<v t="ville.20090503124249.1"><vh>@file ../plugins/tomboy_import.py</vh></v>
<v t="EKR.20040517075715.10"><vh>@file ../plugins/vim.py</vh></v>
<v t="EKR.20040517075715.12"><vh>@file ../plugins/xemacs.py</vh></v>
<v t="EKR.20040517075715.13"><vh>Word export</vh>
<v t="EKR.20040517075715.14"><vh>@file ../plugins/word_export.py</vh></v>
<v t="EKR.20040517075715.20"><vh>@file-nosent ../plugins/word_export.ini</vh></v>
</v>
</v>
<v t="edream.110203113231.872"><vh>Files and nodes</vh>
<v t="tbrown.20080613095157.2"><vh>@file ../plugins/active_path.py</vh></v>
<v t="edream.110203113231.873"><vh>@file ../plugins/at_folder.py</vh></v>
<v t="ekr.20040915085351"><vh>@file ../plugins/at_produce.py</vh></v>
<v t="ktenney.20041211072654.1"><vh>@file ../plugins/at_view.py</vh></v>
<v t="ekr.20170619151859.2"><vh>@file ../plugins/auto_colorize2_0.py</vh></v>
<v t="tbrown.20070322113635"><vh>@file ../plugins/bookmarks.py</vh></v>
<v t="ekr.20060807103814.1"><vh>@file ../plugins/datenodes.py</vh></v>
<v t="ajones.20070122153625"><vh>@file ../plugins/expfolder.py</vh></v>
<v t="ekr.20040915105758.13"><vh>@file ../plugins/FileActions.py</vh></v>
<v t="ekr.20110110105526.5463"><vh>@file ../plugins/ftp.py</vh></v>
<v t="tbrown.20091214233510.5347"><vh>@file ../plugins/geotag.py</vh></v>
<v t="tbrown.20100228141752.5691"><vh>@file ../plugins/leocursor.py</vh></v>
<v t="ville.20120503224623.3574"><vh>@file ../plugins/leomylyn.py</vh></v>
<v t="ekr.20101110092851.5742"><vh>@file ../plugins/leoOPML.py</vh></v>
<v t="dan.20090217132953.1"><vh>@file ../plugins/mime.py</vh></v>
<v t="mork.20041018204908.1"><vh>@file ../plugins/multifile.py</vh></v>
<v t="ekr.20040331151007"><vh>@file ../plugins/niceNosent.py</vh></v>
<v t="edream.110203113231.876"><vh>@file ../plugins/read_only_nodes.py</vh></v>
<v t="ekr.20040828103325"><vh>@file ../plugins/startfile.py</vh></v>
<v t="ekr.20130808211520.15893"><vh>@file ../plugins/timestamp.py</vh></v>
<v t="tbrown.20110428144124.29061"><vh>@file ../plugins/xml_edit.py</vh></v>
<v t="mork.20041010095009"><vh>@file ../plugins/xsltWithNodes.py</vh></v>
</v>
<v t="ekr.20181030041436.1"><vh>Gui</vh>
<v t="ekr.20150107090324.1"><vh>@file ../plugins/cursesGui.py</vh></v>
<v t="ekr.20170419092835.1"><vh>@file ../plugins/cursesGui2.py</vh></v>
<v t="ekr.20181103094900.1"><vh>@file ../plugins/leoflexx.py</vh></v>
<v t="peckj.20150428142633.1"><vh>@file ../plugins/python_terminal.py</vh></v>
</v>
<v t="ekr.20140723122936.17925"><vh>Importer plugins</vh>
<v t="ekr.20140723122936.18139"><vh>@file ../plugins/importers/__init__.py</vh></v>
<v t="ekr.20230529075138.1"><vh>@file ../plugins/importers/base_importer.py</vh></v>
<v t="ekr.20140723122936.17926"><vh>@file ../plugins/importers/c.py</vh></v>
<v t="ekr.20160505094722.1"><vh>@file ../plugins/importers/coffeescript.py</vh></v>
<v t="ekr.20140723122936.18140"><vh>@file ../plugins/importers/csharp.py</vh></v>
<v t="tbrown.20140801105909.47549"><vh>@file ../plugins/importers/ctext.py</vh></v>
<v t="ekr.20200619141135.1"><vh>@file ../plugins/importers/cython.py</vh></v>
<v t="ekr.20141116100154.1"><vh>@file ../plugins/importers/dart.py</vh></v>
<v t="ekr.20140723122936.18141"><vh>@file ../plugins/importers/elisp.py</vh></v>
<v t="ekr.20140723122936.18138"><vh>@file ../plugins/importers/html.py</vh></v>
<v t="ekr.20140723122936.18142"><vh>@file ../plugins/importers/ini.py</vh></v>
<v t="ekr.20140723122936.18143"><vh>@file ../plugins/importers/java.py</vh></v>
<v t="ekr.20140723122936.18144"><vh>@file ../plugins/importers/javascript.py</vh></v>
<v t="ekr.20140723122936.18151"><vh>@file ../plugins/importers/leo_rst.py</vh></v>
<v t="ekr.20170530024520.2"><vh>@file ../plugins/importers/lua.py</vh></v>
<v t="ekr.20140725190808.18066"><vh>@file ../plugins/importers/markdown.py</vh></v>
<v t="ekr.20140723122936.18146"><vh>@file ../plugins/importers/org.py</vh></v>
<v t="ekr.20140723122936.18150"><vh>@file ../plugins/importers/otl.py</vh></v>
<v t="ekr.20140723122936.18147"><vh>@file ../plugins/importers/pascal.py</vh></v>
<v t="ekr.20161027100313.1"><vh>@file ../plugins/importers/perl.py</vh></v>
<v t="ekr.20140723122936.18148"><vh>@file ../plugins/importers/php.py</vh></v>
<v t="ekr.20211209153303.1"><vh>@file ../plugins/importers/python.py</vh></v>
<v t="ekr.20200316100818.1"><vh>@file ../plugins/importers/rust.py</vh></v>
<v t="ekr.20170615153639.2"><vh>@file ../plugins/importers/tcl.py</vh></v>
<v t="ekr.20180201203240.2"><vh>@file ../plugins/importers/treepad.py</vh></v>
<v t="ekr.20140723122936.18152"><vh>@file ../plugins/importers/typescript.py</vh></v>
<v t="ekr.20140723122936.18137"><vh>@file ../plugins/importers/xml.py</vh></v>
</v>
<v t="ekr.20180504192522.1"><vh>leo_babel</vh>
<v t="ekr.20230624114517.1"><vh>@clean ../plugins/leo_babel/__init__.py</vh></v>
<v t="ekr.20180504191650.36"><vh>examples</vh>
<v t="bob.20170716135108.2"><vh>@file ../plugins/leo_babel/examples/slowOut.py</vh></v>
<v t="bob.20170716135108.3"><vh>@file ../plugins/leo_babel/examples/slowOutNoFlush.py</vh></v>
</v>
<v t="ekr.20180504191650.42"><vh>tests</vh>
<v t="ekr.20180504191650.68"><vh>@clean ../plugins/leo_babel/tests/__init__.py</vh></v>
<v t="bob.20180206123613.1"><vh>@file ../plugins/leo_babel/tests/idle_time.py</vh></v>
<v t="bob.20180205135005.1"><vh>@file ../plugins/leo_babel/tests/lib_test.py</vh></v>
<v t="bob.20180125160225.1"><vh>@file ../plugins/leo_babel/tests/tests.py</vh></v>
</v>
</v>
<v t="ekr.20041001210557"><vh>Scripting</vh>
<v t="tbrown.20100226095909.12777"><vh>@file ../plugins/leoscreen.py</vh></v>
<v t="tbrown.20140806084727.30174"><vh>@file ../plugins/livecode.py</vh></v>
<v t="ekr.20060328125248"><vh>@file ../plugins/mod_scripting.py</vh></v>
<v t="edream.110203113231.925"><vh>@file ../plugins/script_io_to_body.py</vh></v>
</v>
<v t="ekr.20120309073937.9878"><vh>Searching</vh>
<v t="ekr.20220823200700.1"><vh>@file ../plugins/leofts.py</vh></v>
<v t="ekr.20120309073748.9872"><vh>@file ../plugins/bigdash.py</vh></v>
<v t="peckj.20140804114520.9427"><vh>@file ../plugins/nodetags.py</vh></v>
<v t="peckj.20131130132659.5964"><vh>@file ../plugins/nodewatch.py</vh></v>
</v>
<v t="ekr.20050111122605"><vh>Servers &amp; web stuff</vh>
<v t="ekr.20170925083314.1"><vh>@file ../plugins/leo_cloud.py</vh></v>
<v t="ekr.20170925083853.1"><vh>@file ../plugins/leo_cloud_server.py</vh></v>
<v t="ville.20110206142055.10640"><vh>@file ../plugins/leofeeds.py</vh></v>
<v t="ville.20110125222411.10536"><vh>@file ../plugins/leomail.py</vh></v>
<v t="ville.20091009202416.10040"><vh>@file ../plugins/leoremote.py</vh></v>
<v t="EKR.20040517080250.1"><vh>@file ../plugins/mod_http.py</vh></v>
<v t="ekr.20131004162848.11444"><vh>@file ../plugins/rss.py</vh></v>
<v t="peckj.20140811080604.9496"><vh>@file ../plugins/sftp.py</vh></v>
<v t="ekr.20210223152423.1"><vh>@file ../plugins/anki.py</vh></v>
</v>
<v t="ekr.20101004082701.5674"><vh>Slideshows, screencasts &amp; screenshots</vh>
<v t="ekr.20170128213103.1"><vh>@file ../plugins/demo.py</vh></v>
<v t="ekr.20211021200745.1"><vh>@file ../scripts/picture_viewer.py</vh></v>
<v t="ekr.20220126054240.1"><vh>@file ../scripts/remove_duplicate_pictures.py</vh></v>
<v t="ekr.20120913110135.10579"><vh>@file ../plugins/screencast.py</vh></v>
<v t="ekr.20101121031443.5330"><vh>@file ../plugins/screenshots.py</vh></v>
<v t="ekr.20060831165821"><vh>@file ../plugins/slideshow.py</vh></v>
</v>
<v t="ekr.20071113084440"><vh>Testing</vh>
<v t="ekr.20080214092357"><vh>@file ../plugins/test/ekr_test.py</vh></v>
<v t="ekr.20050130120433"><vh>@@file ../plugins/test/failed_import.py</vh></v>
<v t="ekr.20071113085315"><vh>@file ../plugins/test/failed_to_load_plugin.py</vh></v>
<v t="ekr.20051016160700"><vh>@file ../plugins/testRegisterCommand.py</vh></v>
</v>
<v t="ekr.20050306081349"><vh>Text formatting</vh>
<v t="timo.20050213160555"><vh>@file ../plugins/bibtex.py</vh></v>
<v t="ekr.20070119094733.1"><vh>@file ../plugins/dtest.py</vh></v>
<v t="ville.20110409151021.5699"><vh>@file ../plugins/jinjarender.py</vh></v>
<v t="danr7.20060902215215.1"><vh>@file ../plugins/leo_to_html.py</vh></v>
<v t="tbrown.20130930160706.23451"><vh>@file ../plugins/markup_inline.py</vh></v>
<v t="vitalije.20180804172140.1"><vh>@file ../plugins/md_docer.py</vh></v>
<v t="peckj.20140113150237.7083"><vh>@file ../plugins/nodediff.py</vh></v>
<v t="tbrown.20130813134319.11942"><vh>@file ../plugins/richtext.py</vh></v>
<v t="ekr.20170217164004.1"><vh>@file ../plugins/tables.py</vh></v>
</v>
<v t="ekr.20121126102050.10134"><vh>Threading</vh>
<v t="ekr.20121126095734.12418"><vh>@file ../plugins/threadutil.py</vh></v>
</v>
<v t="ekr.20040915073259"><vh>User interface</vh>
<v t="ekr.20101110150056.9453"><vh>Qt only plugins</vh>
<v t="tbrown.20091029123555.5319"><vh>@file ../plugins/attrib_edit.py</vh></v>
<v t="ville.20090310191936.10"><vh>@file ../plugins/colorize_headlines.py</vh></v>
<v t="ekr.20090701111504.5294"><vh>@file ../plugins/contextmenu.py</vh></v>
<v t="tom.20210613135525.1"><vh>@file ../plugins/freewin.py</vh></v>
<v t="tbrown.20090206153748.1"><vh>@file ../plugins/graphcanvas.py</vh></v>
<v t="ville.20090518182905.5419"><vh>@file ../plugins/nav_qt.py</vh></v>
<v t="ville.20120604212857.4215"><vh>@file ../plugins/notebook.py</vh></v>
<v t="ekr.20090622063842.5264"><vh>@file ../plugins/projectwizard.py</vh></v>
<v t="ekr.20160928073518.1"><vh>@file ../plugins/pyplot_backend.py</vh></v>
<v t="ville.20090314215508.4"><vh>@file ../plugins/quicksearch.py</vh></v>
<v t="tbrown.20130420091241.44181"><vh>@file ../plugins/screen_capture.py</vh></v>
<v t="ville.20090815203828.5235"><vh>@file ../plugins/spydershell.py</vh></v>
<v t="ekr.20100103093121.5329"><vh>@file ../plugins/stickynotes.py</vh></v>
<v t="tbrown.20090119215428.2"><vh>@file ../plugins/todo.py</vh></v>
<v t="ville.20110403115003.10348"><vh>@file ../plugins/valuespace.py</vh></v>
<v t="tbrown.20100318101414.5990"><vh>@file ../plugins/viewrendered.py</vh></v>
<v t="TomP.20191215195433.1"><vh>@file ../plugins/viewrendered3.py</vh></v>
</v>
<v t="ekr.20060328125925"><vh>@file ../plugins/chapter_hoist.py</vh></v>
<v t="ville.20110115234843.8742"><vh>@file ../plugins/dragdropgoodies.py</vh></v>
<v t="vitalije.20190928154420.1"><vh>@file ../plugins/history_tracer.py</vh></v>
<v t="tbrown.20090513125417.5244"><vh>@file ../plugins/interact.py</vh></v>
<v t="vitalije.20170727201534.1"><vh>@file ../plugins/line_numbering.py</vh></v>
<v t="ekr.20040915073259.1"><vh>@file ../plugins/maximizeNewWindows.py</vh></v>
<v t="ekr.20101110093301.5818"><vh>@file ../plugins/mod_framesize.py</vh></v>
<v t="EKR.20040517080555.2"><vh>@file ../plugins/plugins_menu.py</vh></v>
<v t="ekr.20160519123329.1"><vh>@file ../plugins/QNCalendarWidget.py</vh></v>
<v t="edream.110203113231.924"><vh>@file ../plugins/redirect_to_log.py</vh></v>
<v t="tom.20230424140347.1"><vh>@file ../plugins/rpcalc.py</vh></v>
<v t="ville.20110304230157.6513"><vh>@file ../plugins/systray.py</vh></v>
<v t="tbrown.20141101114322.1"><vh>@file ../plugins/wikiview.py</vh></v>
<v t="ekr.20181004143535.1"><vh>@file ../plugins/xdb_pane.py</vh></v>
<v t="ekr.20101110095202.5882"><vh>@file ../plugins/zenity_file_dialogs.py</vh></v>
</v>
<v t="ekr.20140726091031.18071"><vh>Writer plugins</vh>
<v t="ekr.20140726091031.18152"><vh>@file ../plugins/writers/__init__.py</vh></v>
<v t="ekr.20140726091031.18143"><vh>@file ../plugins/writers/basewriter.py</vh></v>
<v t="tbrown.20140804103545.29975"><vh>@file ../plugins/writers/ctext.py</vh></v>
<v t="ekr.20141116100154.2"><vh>@file ../plugins/writers/dart.py</vh></v>
<v t="ekr.20140726091031.18080"><vh>@file ../plugins/writers/leo_rst.py</vh></v>
<v t="ekr.20140726091031.18073"><vh>@file ../plugins/writers/markdown.py</vh></v>
<v t="ekr.20140726091031.18079"><vh>@file ../plugins/writers/org.py</vh></v>
<v t="ekr.20140726091031.18078"><vh>@file ../plugins/writers/otl.py</vh></v>
<v t="ekr.20180202053206.1"><vh>@file ../plugins/writers/treepad.py</vh></v>
</v>
</v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20171031111403.1"><vh>Leo Edit Pane</vh>
<v t="tbrown.20171029210211.1"><vh>@file ../plugins/editpane/clicky_splitter.py</vh></v>
<v t="ekr.20211210102459.1"><vh>@file ../plugins/editpane/csvedit.py</vh></v>
<v t="tbrown.20171028115144.6"><vh>@file ../plugins/editpane/editpane.py</vh></v>
<v t="tbrown.20171028115144.5"><vh>@file ../plugins/editpane/leotextedit.py</vh></v>
<v t="tbrown.20171028115144.4"><vh>@file ../plugins/editpane/markdownview.py</vh></v>
<v t="tbrown.20171028115144.3"><vh>@file ../plugins/editpane/pandownview.py</vh></v>
<v t="tbrown.20171028115144.2"><vh>@file ../plugins/editpane/plaintextedit.py</vh></v>
<v t="tbrown.20171028115144.1"><vh>@file ../plugins/editpane/plaintextview.py</vh></v>
<v t="tbrown.20171028115143.3"><vh>@file ../plugins/editpane/vanillascintilla.py</vh></v>
<v t="tbrown.20171028115143.2"><vh>@file ../plugins/editpane/webengineview.py</vh></v>
<v t="tbrown.20171028115143.1"><vh>@file ../plugins/editpane/webkitview.py</vh></v>
<v t="tbrown.20171028115144.8"><vh>@file ../plugins/editpane/__init__.py</vh></v>
<v t="tbrown.20171028115541.1"><vh>@file signal_manager.py</vh></v>
</v>
<v t="ekr.20120419093256.10048"><vh>@file ../plugins/free_layout.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20221019064053.1"><vh>@file ../plugins/pane_commands.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qt_commands.py</vh></v>
<v t="ekr.20140907103315.18766"><vh>@file ../plugins/qt_events.py</vh></v>
<v t="ekr.20140907123524.18774"><vh>@file ../plugins/qt_frame.py</vh></v>
<v t="ekr.20140907085654.18699"><vh>@file ../plugins/qt_gui.py</vh></v>
<v t="ekr.20140907103315.18777"><vh>@file ../plugins/qt_idle_time.py</vh></v>
<v t="ekr.20140907123524.18777"><vh>@file ../plugins/qt_quickheadlines.py</vh></v>
<v t="ekr.20140831085423.18598"><vh>@file ../plugins/qt_text.py</vh></v>
<v t="ekr.20140907131341.18707"><vh>@file ../plugins/qt_tree.py</vh></v>
<v t="ekr.20110605121601.18002"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20161223152017.1"><vh>@edit ../plugins/qt_quicksearch.py</vh></v>
<v t="ekr.20161223152353.1"><vh>@edit ../plugins/qt_quicksearch_sub.py</vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20201129023817.1"><vh>@file leoTest2.py</vh></v>
</v>
<v t="ekr.20201202144529.1"><vh>leo/unittests</vh>
<v t="ekr.20230506095312.1"><vh>@file ../unittests/test_design.py</vh></v>
<v t="ekr.20210926044012.1"><vh>@file ../unittests/test_doctests.py</vh></v>
<v t="ekr.20210910084607.1"><vh>@file ../unittests/test_gui.py</vh></v>
<v t="ekr.20210904064440.2"><vh>@file ../unittests/test_importers.py</vh></v>
<v t="ekr.20210907081548.1"><vh>@file ../unittests/test_plugins.py</vh></v>
<v t="ekr.20210901140718.1"><vh>@file ../unittests/test_syntax.py</vh></v>
<v t="ekr.20220812224747.1"><vh>@file ../unittests/test_writers.py</vh></v>
<v t="ekr.20210912064148.1"><vh>in unittests/commands</vh>
<v t="ekr.20221113062857.1"><vh>@file ../unittests/commands/test_outlineCommands.py</vh></v>
<v t="ekr.20201202144422.1"><vh>@file ../unittests/commands/test_editCommands.py</vh></v>
<v t="ekr.20230705083159.1"><vh>@file ../unittests/commands/test_editFileCommands.py</vh></v>
<v t="ekr.20210904022712.2"><vh>@file ../unittests/commands/test_checkerCommands.py</vh></v>
<v t="ekr.20211013081056.1"><vh>@file ../unittests/commands/test_convertCommands.py</vh></v>
<v t="ekr.20230710105542.1"><vh>@file ../unittests/commands/test_commanderFileCommands.py</vh></v>
</v>
<v t="ekr.20210912064205.1"><vh>in unittests/core</vh>
<v t="ekr.20210901170451.1"><vh>@file ../unittests/core/test_leoApp.py</vh></v>
<v t="ekr.20210902073413.1"><vh>@file ../unittests/core/test_leoAst.py</vh></v>
<v t="ekr.20210901172411.1"><vh>@file ../unittests/core/test_leoAtFile.py</vh></v>
<v t="ekr.20210903153138.1"><vh>@file ../unittests/core/test_leoBridge.py</vh></v>
<v t="ekr.20210905151702.1"><vh>@file ../unittests/core/test_leoColorizer.py</vh></v>
<v t="ekr.20210903162431.1"><vh>@file ../unittests/core/test_leoCommands.py</vh></v>
<v t="ekr.20230714131540.1"><vh>@file ../unittests/core/test_leoCompare.py</vh></v>
<v t="ekr.20210910073303.1"><vh>@file ../unittests/core/test_leoConfig.py</vh></v>
<v t="ekr.20210911052754.1"><vh>@file ../unittests/core/test_leoExternalFiles.py</vh></v>
<v t="ekr.20210910065135.1"><vh>@file ../unittests/core/test_leoFileCommands.py</vh></v>
<v t="ekr.20210829124658.1"><vh>@file ../unittests/core/test_leoFind.py</vh></v>
<v t="ekr.20210903161742.1"><vh>@file ../unittests/core/test_leoFrame.py</vh></v>
<v t="ekr.20210902164946.1"><vh>@file ../unittests/core/test_leoGlobals.py</vh></v>
<v t="ekr.20220822082042.1"><vh>@file ../unittests/core/test_leoImport.py</vh></v>
<v t="ekr.20210903155556.1"><vh>@file ../unittests/core/test_leoKeys.py</vh></v>
<v t="ekr.20201203042030.1"><vh>@file ../unittests/core/test_leoNodes.py</vh></v>
<v t="ekr.20210908171733.1"><vh>@file ../unittests/core/test_leoPersistence.py</vh></v>
<v t="ekr.20220911163718.1"><vh>@file ../unittests/core/test_leoQt6.py</vh></v>
<v t="ekr.20210902055206.1"><vh>@file ../unittests/core/test_leoRst.py</vh></v>
<v t="ekr.20210820203000.1"><vh>@file ../unittests/core/test_leoserver.py</vh></v>
<v t="ekr.20210902092024.1"><vh>@file ../unittests/core/test_leoShadow.py</vh></v>
<v t="ekr.20230722095455.1"><vh>@file ../unittests/core/test_leoTest2.py</vh></v>
<v t="ekr.20210906141410.1"><vh>@file ../unittests/core/test_leoUndo.py</vh></v>
<v t="ekr.20210910072917.1"><vh>@file ../unittests/core/test_leoVim.py</vh></v>
</v>
</v>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
</v>
<v t="ekr.20230704211058.1"><vh>*** To do</vh>
<v t="ekr.20230705050235.1"><vh>*** post: About transitions</vh></v>
<v t="ekr.20230705174359.1"><vh>Documentation: Links to resources</vh></v>
<v t="ekr.20230717220528.1"><vh>--- ChatGpt</vh>
<v t="ekr.20230717145150.1"><vh>ChatGpt</vh></v>
<v t="ekr.20230717151135.1"><vh>Example file</vh></v>
<v t="ekr.20230717151112.1"><vh>Reply</vh></v>
</v>
</v>
<v t="ekr.20180606035619.1"><vh>Recent files</vh>
<v t="ville.20090518182905.5419"></v>
<v t="ekr.20221113062857.1"></v>
<v t="ekr.20150323150718.1"></v>
<v t="ekr.20150514154159.1"></v>
<v t="ekr.20031218072017.3320"></v>
<v t="ekr.20031218072017.3603"></v>
<v t="ekr.20201202144529.1"></v>
</v>
<v t="ekr.20201012114516.1"><vh>Recent code</vh>
<v t="ekr.20230508145335.1"></v>
<v t="ekr.20230717040958.1"><vh>6.7.4: Distribution checklist</vh>
<v t="ekr.20230717040958.2"><vh>(Done) Pre-testing (in release branch)</vh></v>
<v t="ekr.20230717040958.3"><vh>(Done) LeoSettings.leo</vh></v>
<v t="ekr.20230717040958.4"><vh>(Done) LeoPyRef.leo</vh></v>
<v t="ekr.20230717040958.5"><vh>(Done) LeoDocs.leo</vh></v>
<v t="ekr.20230717040958.6"><vh>(Done) LeoDist.leo</vh></v>
<v t="ekr.20230717040958.7"><vh>(Done) Web docs</vh></v>
<v t="ekr.20230717040958.8"><vh>(Done) Update versions.py in release branch</vh></v>
<v t="ekr.20230717040958.9"><vh>Merge release branch into master</vh></v>
<v t="ekr.20230717040958.10"><vh>After-merge testing in master</vh></v>
<v t="ekr.20230717040958.11"><vh>Create git tag in master</vh></v>
<v t="ekr.20230717040958.12"><vh>Publish release</vh></v>
<v t="ekr.20230717040958.13"><vh>Create pypi distro</vh></v>
<v t="ekr.20230717040958.14"><vh>Update version in devel</vh></v>
<v t="ekr.20230717040958.15"><vh>Update this checklist</vh></v>
<v t="ekr.20230717040958.16"><vh>Announcements</vh></v>
</v>
<v t="ekr.20220920202642.1"><vh>Later or no milestone</vh>
<v t="ekr.20220920120550.1"><vh>=== #2886: qt6.1+</vh></v>
<v t="ekr.20230619123102.1"><vh>=== #3230: icon bar</vh>
<v t="ekr.20230619123122.1"><vh>Chat code</vh></v>
<v t="ekr.20230619124256.1"><vh>answer</vh></v>
<v t="ekr.20230619124346.1"><vh>Found 8:addRow</vh>
<v t="ekr.20230619124519.1"><vh> --- not relevant</vh>
<v t="ekr.20140906065955.18802"><vh>createBBox</vh></v>
<v t="ekr.20230619124410.1"><vh>table.py</vh>
<v t="ekr.20140906065955.18794"><vh>addRow</vh></v>
</v>
<v t="tbrown.20091028100922.1493"><vh>updateEditorInt</vh></v>
</v>
<v t="ekr.20230619124457.1"><vh>--- do nothings: to be deleted</vh>
<v t="ekr.20070301165343"><vh> NullIconBarClass.Do nothing</vh></v>
<v t="ekr.20110605121601.18264"><vh> QtIconBar.do-nothings</vh></v>
<v t="ekr.20140904043623.18552"><vh>class IconBarAPI</vh></v>
<v t="ekr.20061119120006"><vh>LeoFrame.Icon area convenience methods</vh></v>
<v t="ekr.20110605121601.18266"><vh>QtIconBar.addRowIfNeeded (not used)</vh></v>
</v>
</v>
<v t="ekr.20110605121601.18137"><vh>class  DynamicWindow (QMainWindow)</vh>
<v t="ekr.20110605121601.18138"><vh> dw.ctor &amp; reloadSettings</vh></v>
<v t="ekr.20110605121601.18172"><vh>dw.do_leo_spell_btn_*</vh></v>
<v t="ekr.20110605121601.18140"><vh>dw.closeEvent</vh></v>
<v t="ekr.20110605121601.18139"><vh>dw.construct &amp; helpers</vh>
<v t="ekr.20140915062551.19519"><vh>dw.set_icon_bar_orientation</vh></v>
</v>
<v t="ekr.20110605121601.18141"><vh>dw.createMainWindow &amp; helpers</vh>
<v t="ekr.20110605121601.18142"><vh>dw.top-level</vh>
<v t="ekr.20190118150859.10"><vh>dw.addNewEditor</vh></v>
<v t="ekr.20110605121601.18143"><vh>dw.createBodyPane</vh></v>
<v t="ekr.20110605121601.18144"><vh>dw.createCentralWidget</vh></v>
<v t="ekr.20110605121601.18145"><vh>dw.createLogPane &amp; helpers</vh>
<v t="ekr.20131118172620.16858"><vh>dw.finishCreateLogPane</vh></v>
</v>
<v t="ekr.20110605121601.18146"><vh>dw.createMainLayout</vh></v>
<v t="ekr.20110605121601.18147"><vh>dw.createMenuBar</vh></v>
<v t="ekr.20110605121601.18148"><vh>dw.createMiniBuffer (class VisLineEdit)</vh></v>
<v t="ekr.20110605121601.18149"><vh>dw.createOutlinePane</vh></v>
<v t="ekr.20110605121601.18150"><vh>dw.createStatusBar</vh></v>
<v t="ekr.20110605121601.18212"><vh>dw.packLabel</vh></v>
<v t="ekr.20110605121601.18151"><vh>dw.setMainWindowOptions</vh></v>
</v>
<v t="ekr.20110605121601.18152"><vh>dw.widgets</vh>
<v t="ekr.20110605121601.18153"><vh>dw.createButton</vh></v>
<v t="ekr.20110605121601.18154"><vh>dw.createCheckBox</vh></v>
<v t="ekr.20110605121601.18155"><vh>dw.createFrame</vh></v>
<v t="ekr.20110605121601.18156"><vh>dw.createGrid</vh></v>
<v t="ekr.20110605121601.18157"><vh>dw.createHLayout &amp; createVLayout</vh></v>
<v t="ekr.20110605121601.18158"><vh>dw.createLabel</vh></v>
<v t="ekr.20110605121601.18159"><vh>dw.createLineEdit</vh></v>
<v t="ekr.20110605121601.18160"><vh>dw.createRadioButton</vh></v>
<v t="ekr.20110605121601.18161"><vh>dw.createStackedWidget</vh></v>
<v t="ekr.20110605121601.18162"><vh>dw.createTabWidget</vh></v>
<v t="ekr.20110605121601.18163"><vh>dw.createText (creates QTextBrowser)</vh></v>
<v t="ekr.20110605121601.18164"><vh>dw.createTreeWidget</vh></v>
</v>
<v t="ekr.20110605121601.18165"><vh>dw.log tabs</vh>
<v t="ekr.20110605121601.18167"><vh>dw.createSpellTab</vh></v>
<v t="ekr.20110605121601.18166"><vh>dw.createFindTab &amp; helpers</vh>
<v t="ekr.20131118152731.16847"><vh>dw.create_find_grid</vh></v>
<v t="ekr.20131118152731.16849"><vh>dw.create_find_header</vh></v>
<v t="ekr.20131118152731.16848"><vh>dw.create_find_findbox</vh></v>
<v t="ekr.20131118152731.16850"><vh>dw.create_find_replacebox</vh></v>
<v t="ekr.20131118152731.16851"><vh>dw.create_find_checkboxes</vh></v>
<v t="ekr.20131118152731.16853"><vh>dw.create_help_row</vh></v>
<v t="ekr.20131118152731.16852"><vh>dw.create_find_buttons</vh></v>
<v t="ekr.20150618072619.1"><vh>dw.create_find_status</vh></v>
<v t="ekr.20131118172620.16891"><vh>dw.override_events</vh>
<v t="ekr.20131118172620.16892"><vh>class EventWrapper</vh>
<v t="ekr.20131120054058.16281"><vh>EventWrapper.create_d</vh></v>
<v t="ekr.20131118172620.16893"><vh>EventWrapper.wrapper</vh></v>
<v t="ekr.20131118172620.16894"><vh>EventWrapper.keyPress</vh></v>
<v t="ekr.20131118172620.16895"><vh>EventWrapper.keyRelease</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20110605121601.18168"><vh>dw.utils</vh>
<v t="ekr.20110605121601.18169"><vh>dw.setName</vh></v>
<v t="ekr.20110605121601.18170"><vh>dw.setSizePolicy</vh></v>
<v t="ekr.20110605121601.18171"><vh>dw.tr</vh></v>
</v>
</v>
<v t="ekr.20110605121601.18173"><vh>dw.select</vh></v>
<v t="ekr.20110605121601.18178"><vh>dw.setGeometry</vh></v>
<v t="ekr.20110605121601.18177"><vh>dw.setLeoWindowIcon</vh></v>
<v t="ekr.20110605121601.18174"><vh>dw.setSplitDirection</vh></v>
<v t="ekr.20130804061744.12425"><vh>dw.setWindowTitle</vh></v>
</v>
<v t="ekr.20060328125248.17"><vh>sc.createIconButton (creates all buttons)</vh></v>
<v t="ekr.20110605121601.18262"><vh>class QtIconBarClass</vh>
<v t="ekr.20110605121601.18263"><vh> QtIconBar.ctor &amp; reloadSettings</vh></v>
<v t="ekr.20110605121601.18264"></v>
<v t="ekr.20110605121601.18265"><vh>QtIconBar.add</vh></v>
<v t="ekr.20110605121601.18266"></v>
<v t="ekr.20110605121601.18267"><vh>QtIconBar.addWidget</vh></v>
<v t="ekr.20110605121601.18268"><vh>QtIconBar.clear</vh></v>
<v t="ekr.20110605121601.18269"><vh>QtIconBar.createChaptersIcon</vh></v>
<v t="ekr.20110605121601.18270"><vh>QtIconBar.deleteButton</vh></v>
<v t="ekr.20141031053508.14"><vh>QtIconBar.goto_command</vh></v>
<v t="ekr.20110605121601.18271"><vh>QtIconBar.setCommandForButton (@rclick nodes) &amp; helper</vh>
<v t="ekr.20141031053508.15"><vh>add_rclick_menu (QtIconBarClass)</vh></v>
</v>
</v>
<v t="ekr.20110605121601.18265"></v>
<v t="ville.20090518182905.5425"><vh>class NavController</vh>
<v t="ville.20090518182905.5427"><vh>NavController.makeButtons</vh></v>
<v t="ekr.20220922085357.1"><vh>NavController.removeButtons</vh></v>
</v>
</v>
<v t="ekr.20230706124802.1"><vh>=== #3429: (Won't do) paste retains gnxs</vh>
<v t="ekr.20230706125050.1"><vh>--- helpers</vh>
<v t="ekr.20230706132550.1"><vh>fc.preReadLeoOutlineFromClipboard</vh></v>
<v t="ekr.20180709205603.1"><vh>fc.getLeoOutlineFromClipBoard</vh></v>
<v t="ekr.20180709205640.1"><vh>fc.getLeoOutlineFromClipBoardRetainingClones</vh></v>
<v t="ekr.20230706125618.1"><vh>function: anyGnxClashes</vh></v>
</v>
<v t="ekr.20230706125038.1"><vh>--- top level</vh>
<v t="ekr.20031218072017.1551"><vh>c_oc.pasteOutline</vh></v>
<v t="EKR.20040610130943"><vh>c_oc.pasteOutlineRetainingClones &amp; helpers</vh>
<v t="ekr.20050418084539.2"><vh>def computeCopiedBunchList</vh></v>
<v t="ekr.20050418084539"><vh>def computeVnodeInfoDict</vh></v>
</v>
<v t="ekr.20230706192145.1"><vh>c_oc.pasteOutlineAllocatingGnxs</vh></v>
</v>
</v>
<v t="ekr.20230702160250.1"><vh>=== #3442: Info item: hot to get dmypy working</vh>
<v t="ekr.20220222130955.1"></v>
<v t="ekr.20230716092124.1"><vh>@edit c:\scripts\dmypy-help.cmd</vh></v>
<v t="ekr.20230716073159.1"><vh>@edit c:\scripts\dmypy-start.cmd</vh></v>
<v t="ekr.20230716075621.1"><vh>@edit c:\scripts\dmypy-check.cmd</vh></v>
<v t="ekr.20230716073222.1"><vh>@edit c:\scripts\dmypy-stop.cmd</vh></v>
<v t="ekr.20230716093221.1"><vh>warning</vh></v>
</v>
</v>
<v t="ekr.20230708162329.1"><vh>6.7.5</vh>
<v t="ekr.20230708161215.1"><vh>=== PR #3432: simplify g.findUnl</vh>
<v t="ekr.20230708161435.1"><vh>--- no longer used</vh>
<v t="ekr.20230626064652.2"><vh>function: convert_unl_list</vh></v>
</v>
<v t="ekr.20230626064652.1"><vh>g.findUnl &amp; helpers (legacy unls)</vh>
<v t="ekr.20230626064652.2"></v>
<v t="ekr.20230626064652.3"><vh>function: full_match</vh></v>
</v>
</v>
</v>
<v t="ekr.20230514135259.1"><vh>6.7.4: Completed</vh>
<v t="ekr.20230715061355.1"><vh>--- ekr-suppress-git-messages</vh>
<v t="ekr.20230714143451.1"><vh>TestEditFileCommands.test_diff_two_branches</vh></v>
<v t="ekr.20230714154706.1"><vh>TestEditFileCommands.verbose_test_git_diff</vh></v>
<v t="ekr.20230714160049.1"><vh>TestEditFileCommands.test_diff_two_revs</vh></v>
</v>
<v t="ekr.20230709055224.1"><vh>=== #3403: macos events (can't fix)</vh>
<v t="ekr.20230709055736.1"><vh>--- event handlers</vh>
<v t="ekr.20110605121601.18223"><vh>LeoQtBody.Event handlers</vh>
<v t="ekr.20110930174206.15472"><vh>LeoQtBody.onFocusIn</vh></v>
<v t="ekr.20110930174206.15473"><vh>LeoQtBody.onFocusOut</vh></v>
<v t="ekr.20110605121601.18224"><vh>LeoQtBody.qtBody.onFocusColorHelper (revised)</vh></v>
</v>
<v t="ekr.20110605121601.18285"><vh>qtFrame.Event handlers</vh>
<v t="ekr.20110605121601.18286"><vh>qtFrame.OnCloseLeoEvent</vh></v>
<v t="ekr.20110605121601.18287"><vh>qtFrame.OnControlKeyUp/Down</vh></v>
<v t="ekr.20110605121601.18290"><vh>qtFrame.OnActivateTree</vh></v>
</v>
<v t="ekr.20110607182447.16456"><vh>qt_gui.Event handlers</vh>
<v t="ekr.20190824094650.1"><vh>qt_gui.close_event</vh></v>
<v t="ekr.20110605121601.18481"><vh>qt_gui.onDeactiveEvent</vh></v>
<v t="ekr.20110605121601.18480"><vh>qt_gui.onActivateEvent</vh></v>
<v t="ekr.20130921043420.21175"><vh>qt_gui.setFilter</vh></v>
</v>
</v>
<v t="ekr.20110605121601.18480"></v>
</v>
<v t="ekr.20230318040137.1"><vh>=== PR #3215: mypy links</vh>
<v t="ekr.20230704070426.2"><vh>diff: leo/core/leoGlobals.py</vh>
<v t="ekr.20230704070426.7"><vh>diff: Added</vh>
<v t="ekr.20230704030847.1"><vh>g.pad</vh></v>
<v t="ekr.20230624100622.1"><vh>&lt;&lt; About clickable links &gt;&gt;</vh></v>
<v t="ekr.20230628072620.1"><vh>g.findAnyUnl</vh></v>
<v t="ekr.20230624015529.1"><vh>g.findGnx (new unls)</vh></v>
<v t="ekr.20230628072109.1"><vh>g.isValidUnl</vh></v>
<v t="ekr.20230627143007.1"><vh>g: file part utils</vh>
<v t="ekr.20230630132339.1"><vh>g.getUNLFilePart</vh></v>
<v t="ekr.20230630132340.1"><vh>g.openUNLFile</vh></v>
<v t="ekr.20230630132341.1"><vh>g.parsePathData</vh></v>
</v>
<v t="ekr.20230630132339.1"></v>
<v t="ekr.20230630132340.1"></v>
<v t="ekr.20230630132341.1"></v>
</v>
<v t="ekr.20230704070458.1"><vh>diff: changed (new nodes)</vh>
<v t="ekr.20230704070426.9"><vh>OLD:g.findUNL &amp; helpers</vh>
<v t="ekr.20230704070426.10"><vh>function: convert_unl_list</vh></v>
<v t="ekr.20230704070426.11"><vh>function: full_match</vh></v>
</v>
<v t="ekr.20230626064652.1"></v>
</v>
<v t="ekr.20230704070426.12"><vh>diff: Changed</vh>
<v t="ekr.20230704070426.19"><vh>diff: g.objToString &amp; aliases</vh>
<v t="ekr.20230704070426.20"><vh>Old:g.objToString &amp; aliases</vh></v>
<v t="ekr.20050819064157"><vh>g.objToString &amp; aliases</vh></v>
</v>
<v t="ekr.20230704070426.25"><vh>diff: g.handleUnl</vh>
<v t="ekr.20230704070426.26"><vh>Old:g.handleUnl</vh></v>
<v t="ekr.20170221063527.1"><vh>g.handleUnl</vh></v>
</v>
<v t="ekr.20230704070426.27"><vh>diff: g.handleUrl &amp; helpers</vh>
<v t="ekr.20230704070426.28"><vh>Old:g.handleUrl &amp; helpers</vh></v>
<v t="tbrown.20090219095555.63"><vh>g.handleUrl &amp; helpers</vh>
<v t="ekr.20170226054459.1"><vh>g.handleUrlHelper</vh></v>
<v t="ekr.20170226060816.1"><vh>g.traceUrl</vh></v>
</v>
</v>
<v t="ekr.20230704070426.29"><vh>diff: g.handleUrlHelper</vh>
<v t="ekr.20230704070426.30"><vh>Old:g.handleUrlHelper</vh></v>
<v t="ekr.20170226054459.1"></v>
</v>
<v t="ekr.20230704070426.33"><vh>diff: g.isValidUrl</vh>
<v t="ekr.20230704070426.34"><vh>Old:g.isValidUrl</vh></v>
<v t="ekr.20120311151914.9918"><vh>g.isValidUrl</vh></v>
</v>
</v>
</v>
<v t="ekr.20230629185140.1"><vh>--- workbook related</vh>
<v t="ekr.20120219154958.10452"><vh>LM.load &amp; helpers</vh>
<v t="ekr.20150225133846.7"><vh>LM.doDiff</vh></v>
<v t="ekr.20120219154958.10487"><vh>LM.doPostPluginsInit &amp; helpers</vh>
<v t="ekr.20131028155339.17098"><vh>LM.openWorkBook</vh></v>
</v>
<v t="ekr.20120219154958.10477"><vh>LM.doPrePluginsInit &amp; helpers</vh>
<v t="ekr.20170302093006.1"><vh>LM.createAllImporterData &amp; helpers</vh>
<v t="ekr.20140724064952.18037"><vh>LM.createImporterData &amp; helper</vh>
<v t="ekr.20140723140445.18076"><vh>LM.parse_importer_dict</vh></v>
</v>
<v t="ekr.20140728040812.17990"><vh>LM.createWritersData &amp; helper</vh>
<v t="ekr.20140728040812.17991"><vh>LM.parse_writer_dict</vh></v>
</v>
</v>
<v t="ekr.20120219154958.10478"><vh>LM.createGui</vh></v>
<v t="ekr.20120219154958.10479"><vh>LM.createSpecialGui</vh></v>
<v t="ekr.20120219154958.10482"><vh>LM.getDefaultFile</vh></v>
<v t="ekr.20120219154958.10484"><vh>LM.initApp</vh></v>
<v t="ekr.20210927034148.1"><vh>LM.scanOptions &amp; helpers</vh>
<v t="ekr.20210927034148.3"><vh>function: computeFilesList</vh></v>
<v t="ekr.20230615062931.1"><vh>function: defineUsage</vh></v>
<v t="ekr.20210927034148.4"><vh>function: doGuiOption</vh></v>
<v t="ekr.20210927034148.5"><vh>function: doLoadTypeOption</vh></v>
<v t="ekr.20210927034148.7"><vh>function: doScriptOption</vh></v>
<v t="ekr.20230615055158.1"><vh>function: doSelectOption</vh></v>
<v t="ekr.20230615034517.1"><vh>function: doSimpleOptions</vh>
<v t="ekr.20230615053133.1"><vh>&lt;&lt; define scanArgv helpers &gt;&gt;</vh></v>
</v>
<v t="ekr.20230615060055.1"><vh>function: doThemeOption</vh></v>
<v t="ekr.20230615075314.1"><vh>function: doTraceOptions</vh></v>
<v t="ekr.20210927034148.10"><vh>function: doWindowSizeOption</vh></v>
<v t="ekr.20210927034148.9"><vh>function: doWindowSpotOption</vh></v>
</v>
<v t="ekr.20160718072648.1"><vh>LM.setStdStreams</vh>
<v t="ekr.20160718091844.1"><vh>class LeoStdOut</vh>
<v t="ekr.20160718102306.1"><vh>LeoStdOut.write</vh></v>
</v>
</v>
</v>
<v t="ekr.20120219154958.10491"><vh>LM.isValidPython</vh></v>
<v t="ekr.20120223062418.10393"><vh>LM.loadLocalFile &amp; helpers</vh>
<v t="ekr.20220318033804.1"><vh>LM.openEmptyLeoFile</vh></v>
<v t="ekr.20120223062418.10394"><vh>LM.openFileByName &amp; helpers</vh>
<v t="ekr.20120223062418.10405"><vh>LM.createMenu</vh></v>
<v t="ekr.20120223062418.10406"><vh>LM.findOpenFile</vh></v>
<v t="ekr.20120223062418.10407"><vh>LM.finishOpen</vh></v>
<v t="ekr.20120223062418.10408"><vh>LM.initWrapperLeoFile</vh></v>
<v t="ekr.20120223062418.10419"><vh>LM.isLeoFile &amp; LM.isZippedFile</vh></v>
<v t="ekr.20120224161905.10030"><vh>LM.openAnyLeoFile</vh></v>
<v t="ekr.20120223062418.10416"><vh>LM.openLeoFile</vh></v>
<v t="ekr.20120223062418.10410"><vh>LM.openZipFile</vh></v>
<v t="ekr.20120223062418.10412"><vh>LM.readOpenedLeoFile</vh></v>
</v>
</v>
</v>
<v t="ekr.20120223062418.10393"></v>
<v t="ekr.20120211121736.10772"><vh>LM.computeWorkbookFileName</vh></v>
<v t="ekr.20131028155339.17098"></v>
</v>
<v t="ekr.20230624014959.1"><vh>--- changed/new</vh>
<v t="ekr.20140829053801.18460"><vh>5. LeoTree.set_status_line</vh></v>
<v t="ekr.20230624100622.1"></v>
<v t="ekr.20191010112910.1"><vh>@g.command('show-clone-ancestors')</vh></v>
<v t="ekr.20191007034723.1"><vh>@g.command('show-clone-parents')</vh></v>
<v t="tbnorth.20170616105931.1"><vh>bc.handleURL</vh></v>
<v t="ekr.20230625185133.1"><vh>ccc.convert-unls</vh></v>
<v t="ekr.20210311154956.1"><vh>ec.copyGnx</vh></v>
<v t="ekr.20120320053907.9776"><vh>g.computeFileUrl</vh></v>
<v t="ekr.20230628072620.1"></v>
<v t="ekr.20230624015529.1"></v>
<v t="ekr.20230626064652.1"></v>
<v t="ekr.20230630132339.1"></v>
<v t="ekr.20170221063527.1"></v>
<v t="tbrown.20090219095555.63"></v>
<v t="ekr.20170226054459.1"></v>
<v t="ekr.20230628072109.1"></v>
<v t="ekr.20230628072109.1"></v>
<v t="ekr.20230630132340.1"></v>
<v t="ekr.20170216091704.1"><vh>g.openUrlHelper</vh>
<v t="tom.20220328141455.1"><vh>&lt;&lt; look for section ref &gt;&gt;</vh></v>
<v t="tom.20220328141544.1"><vh>&lt;&lt; look for url  &gt;&gt;</vh></v>
<v t="ekr.20220704211851.1"><vh>&lt;&lt; look for unl &gt;&gt;</vh></v>
<v t="tom.20220328142302.1"><vh>&lt;&lt; look for gnx &gt;&gt;</vh></v>
<v t="tom.20230130102836.1"><vh>&lt;&lt; look for filename or import &gt;&gt;</vh></v>
</v>
<v t="ekr.20100216141722.5622"><vh>goto.find_file_line &amp; helper</vh>
<v t="ekr.20230727074847.1"><vh>goto.find_file_line_helper</vh></v>
</v>
<v t="ekr.20220410180439.1"><vh>LeoLog.put_html_links &amp; helpers</vh>
<v t="ekr.20220420100806.1"><vh>function: find_match</vh></v>
<v t="ekr.20220412084258.1"><vh>function: find_at_file_node</vh></v>
</v>
<v t="tbnorth.20171220123648.1"><vh>LeoQtLog.linkClicked</vh></v>
<v t="ekr.20110605121601.18322"><vh>LeoQtLog.put &amp; helper</vh>
<v t="ekr.20220411085334.1"><vh>LeoQtLog.to_html</vh></v>
</v>
<v t="ekr.20120219154958.10487"></v>
<v t="ekr.20230628173526.1"><vh>p.get_UNL and related methods</vh>
<v t="ekr.20230628174317.1"><vh>p.get_full_gnx_UNL</vh></v>
<v t="tbrown.20111010104549.26758"><vh>p.get_full_legacy_UNL</vh></v>
<v t="ekr.20230628173542.1"><vh>p.get_legacy_UNL</vh></v>
<v t="ekr.20230628175148.1"><vh>p.get_short_gnx_UNL</vh></v>
<v t="ekr.20230628174804.1"><vh>p.get_short_legacy_UNL</vh></v>
<v t="ekr.20230624171452.1"><vh>p.get_UNL</vh></v>
</v>
<v t="ekr.20120420054855.14245"><vh>SessionManager.get_session</vh></v>
<v t="ekr.20120420054855.14247"><vh>SessionManager.load_session</vh></v>
<v t="ekr.20201127035748.1"><vh>u.updateAfterTyping</vh></v>
</v>
<v t="ekr.20230703041152.1"><vh>--- shutdown logic</vh>
<v t="ekr.20161028035755.1"><vh>&lt;&lt; LeoApp: command-line arguments &gt;&gt;</vh></v>
<v t="ekr.20200422075655.1"><vh>c_file.restartLeo</vh></v>
<v t="ekr.20120219154958.10487"></v>
<v t="ekr.20210927034148.1"></v>
<v t="ekr.20190824094650.1"></v>
<v t="ekr.20230703100758.1"><vh>app.saveSession</vh></v>
</v>
<v t="ekr.20230704035519.1"><vh>--- Testing</vh>
<v t="ekr.20230701044111.1"><vh>--- Do *not* test</vh>
<v t="ekr.20170221063527.1"></v>
<v t="tbrown.20090219095555.63"></v>
</v>
<v t="ekr.20230703142942.1"><vh>--- test helpers</vh>
<v t="ekr.20230703181745.1"><vh>==== infrastructure </vh></v>
<v t="ekr.20220805071838.1"><vh>LeoUnitTest.dump_headlines</vh></v>
<v t="ekr.20230703103458.1"><vh>LeoUnitTest._set_setting</vh></v>
<v t="ekr.20230330042647.1"><vh>TestGlobals._make_tree</vh></v>
<v t="ekr.20230702165040.1"><vh>TestGlobals._patch_at_data_unl_path_prefixes</vh></v>
</v>
<v t="ekr.20230424051945.1"><vh>--- test classes</vh>
<v t="ekr.20210902014907.1"><vh>class LeoUnitTest(unittest.TestCase)</vh>
<v t="ekr.20210901140855.2"><vh> LeoUnitTest.setUp &amp; tearDown</vh></v>
<v t="ekr.20230703103458.1"></v>
<v t="ekr.20210830151601.1"><vh>LeoUnitTest.create_test_outline</vh></v>
<v t="ekr.20230720210931.1"><vh>LeoUnitTest.dump_clone_info</vh></v>
<v t="ekr.20230724174102.1"><vh>LeoUnitTest.dump_bodies</vh></v>
<v t="ekr.20220805071838.1"></v>
<v t="ekr.20220806170537.1"><vh>LeoUnitTest.dump_string</vh></v>
<v t="ekr.20211129062220.1"><vh>LeoUnitTest.dump_tree</vh></v>
</v>
<v t="ekr.20210902165045.1"><vh>class TestGlobals(LeoUnitTest)</vh>
<v t="ekr.20230701083715.1"><vh>&lt;&lt; TestGlobals: declare all data &gt;&gt;</vh></v>
<v t="ekr.20230701083918.1"><vh>&lt;&lt; TestGlboals: define unchanging data &gt;&gt;</vh>
<v t="ekr.20230701060241.1"><vh>&lt;&lt; define files data &gt;&gt;</vh></v>
<v t="ekr.20230701060854.1"><vh>&lt;&lt; define error_patterns &gt;&gt;</vh></v>
<v t="ekr.20230701071240.1"><vh>&lt;&lt; define error_templates &gt;&gt;</vh></v>
<v t="ekr.20230701084458.1"><vh>&lt;&lt; define invalid_unls &gt;&gt;</vh></v>
<v t="ekr.20230701090956.1"><vh>&lt;&lt; define missing_unls &gt;&gt;</vh></v>
<v t="ekr.20230701090956.2"><vh>&lt;&lt; define valid_unl_templates &gt;&gt;</vh></v>
</v>
<v t="ekr.20230701061343.1"><vh> TestGlobals: setup helpers and related tests</vh>
<v t="ekr.20230701065318.1"><vh>TestGlobals._define_per_commander_data</vh></v>
<v t="ekr.20230701061355.1"><vh>TestGlobals._test_per_commander_data</vh></v>
<v t="ekr.20230330042647.1"></v>
<v t="ekr.20230702165040.1"></v>
<v t="ekr.20230701084035.1"><vh>TestGlobals.test_per_commander_data</vh></v>
<v t="ekr.20230702165813.1"><vh>TestGlobals.test_patch_at_data_unl_path_prefixes</vh></v>
</v>
<v t="ekr.20230701085717.1"><vh>--- legacy tests</vh>
<v t="ekr.20210905203541.4"><vh>TestGlobals.test_g_checkVersion</vh></v>
<v t="ekr.20210905203541.5"><vh>TestGlobals.test_g_CheckVersionToInt</vh></v>
<v t="ekr.20210905203541.6"><vh>TestGlobals.test_g_comment_delims_from_extension</vh></v>
<v t="ekr.20210905203541.7"><vh>TestGlobals.test_g_convertPythonIndexToRowCol</vh></v>
<v t="ekr.20210905203541.8"><vh>TestGlobals.test_g_convertRowColToPythonIndex</vh></v>
<v t="ekr.20210905203541.9"><vh>TestGlobals.test_g_create_temp_file</vh></v>
<v t="ekr.20210905203541.10"><vh>TestGlobals.test_g_ensureLeadingNewlines</vh></v>
<v t="ekr.20210905203541.11"><vh>TestGlobals.test_g_ensureTrailingNewlines</vh></v>
<v t="ekr.20210905203541.12"><vh>TestGlobals.test_g_find_word</vh></v>
<v t="ekr.20210905203541.14"><vh>TestGlobals.test_g_fullPath</vh></v>
<v t="ekr.20210905203541.16"><vh>TestGlobals.test_g_get_directives_dict</vh></v>
<v t="ekr.20210905203541.17"><vh>TestGlobals.test_g_getDocString</vh></v>
<v t="ekr.20210905203541.18"><vh>TestGlobals.test_g_getLine</vh></v>
<v t="ekr.20210905203541.20"><vh>TestGlobals.test_g_getWord</vh></v>
<v t="ekr.20210905203541.21"><vh>TestGlobals.test_g_guessExternalEditor</vh></v>
<v t="ekr.20230221153849.1"><vh>TestGlobals.test_g_handleScriptException</vh></v>
<v t="ekr.20210905203541.23"><vh>TestGlobals.test_g_import_module</vh></v>
<v t="ekr.20210905203541.24"><vh>TestGlobals.test_g_isDirective</vh></v>
<v t="ekr.20210905203541.25"><vh>TestGlobals.test_g_match_word</vh></v>
<v t="ekr.20230131234527.1"><vh>TestGlobals.test_g_objToString</vh>
<v t="ekr.20230131234637.1"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
<v t="ekr.20230131234648.1"><vh>&lt;&lt; define class TestClass &gt;&gt;</vh></v>
</v>
<v t="ekr.20230617065929.1"><vh>TestGlobals.test_g_OptionsUtils</vh></v>
<v t="ekr.20210905203541.26"><vh>TestGlobals.test_g_os_path_finalize_join_with_thumb_drive</vh></v>
<v t="ekr.20210905203541.28"><vh>TestGlobals.test_g_removeBlankLines</vh></v>
<v t="ekr.20210905203541.30"><vh>TestGlobals.test_g_removeLeadingBlankLines</vh></v>
<v t="ekr.20210905203541.31"><vh>TestGlobals.test_g_removeTrailing</vh></v>
<v t="ekr.20210905203541.32"><vh>TestGlobals.test_g_sanitize_filename</vh></v>
<v t="ekr.20210905203541.33"><vh>TestGlobals.test_g_scanAtHeaderDirectives_header</vh></v>
<v t="ekr.20210905203541.35"><vh>TestGlobals.test_g_scanAtHeaderDirectives_noheader</vh></v>
<v t="ekr.20210905203541.36"><vh>TestGlobals.test_g_scanAtLineendingDirectives_cr</vh></v>
<v t="ekr.20210905203541.37"><vh>TestGlobals.test_g_scanAtLineendingDirectives_crlf</vh></v>
<v t="ekr.20210905203541.38"><vh>TestGlobals.test_g_scanAtLineendingDirectives_lf</vh></v>
<v t="ekr.20210905203541.39"><vh>TestGlobals.test_g_scanAtLineendingDirectives_nl</vh></v>
<v t="ekr.20210905203541.40"><vh>TestGlobals.test_g_scanAtLineendingDirectives_platform</vh></v>
<v t="ekr.20210905203541.42"><vh>TestGlobals.test_g_scanAtPagewidthDirectives_40</vh></v>
<v t="ekr.20210905203541.41"><vh>TestGlobals.test_g_scanAtPagewidthDirectives_minus_40</vh></v>
<v t="ekr.20210905203541.43"><vh>TestGlobals.test_g_scanAtTabwidthDirectives_6</vh></v>
<v t="ekr.20210905203541.44"><vh>TestGlobals.test_g_scanAtTabwidthDirectives_minus_6</vh></v>
<v t="ekr.20210905203541.45"><vh>TestGlobals.test_g_scanAtWrapDirectives_nowrap</vh></v>
<v t="ekr.20210905203541.46"><vh>TestGlobals.test_g_scanAtWrapDirectives_wrap_with_wrap_</vh></v>
<v t="ekr.20210905203541.47"><vh>TestGlobals.test_g_scanAtWrapDirectives_wrap_without_nowrap_</vh></v>
<v t="ekr.20210905203541.48"><vh>TestGlobals.test_g_set_delims_from_language</vh></v>
<v t="ekr.20210905203541.49"><vh>TestGlobals.test_g_set_delims_from_string</vh></v>
<v t="ekr.20210905203541.50"><vh>TestGlobals.test_g_skip_blank_lines</vh></v>
<v t="ekr.20210905203541.51"><vh>TestGlobals.test_g_skip_line</vh></v>
<v t="ekr.20210905203541.52"><vh>TestGlobals.test_g_skip_to_end_of_line</vh></v>
<v t="ekr.20210905203541.53"><vh>TestGlobals.test_g_skip_to_start_of_line</vh></v>
<v t="ekr.20210905203541.54"><vh>TestGlobals.test_g_splitLongFileName</vh></v>
<v t="ekr.20210905203541.55"><vh>TestGlobals.test_g_stripPathCruft</vh></v>
<v t="ekr.20210905203541.56"><vh>TestGlobals.test_g_warnOnReadOnlyFile</vh></v>
<v t="ekr.20210901140645.19"><vh>TestGlobals.test_getLastTracebackFileAndLineNumber</vh></v>
</v>
<v t="ekr.20230325055810.1"><vh>TestGlobals.test_g_findGnx</vh></v>
<v t="ekr.20230703175743.1"><vh>TestGlobals.test_g_findUnl (legacy)</vh></v>
<v t="ekr.20230701085746.1"><vh>TestGlobals.test_g_isValidUnl</vh></v>
<v t="ekr.20230701171707.1"><vh>TestGlobals.test_g_getUNLFilePart</vh></v>
<v t="ekr.20230701101300.1"><vh>TestGlobals.test_g_isValidUrl</vh></v>
<v t="ekr.20230701095636.1"><vh>TestGlobals.test_g_findAnyUnl</vh></v>
<v t="ekr.20230701113123.1"><vh>TestGlobals.test_p_get_star_UNL</vh></v>
<v t="ekr.20230701103509.1"><vh>TestGlobals.test_g_parsePathData</vh></v>
<v t="ekr.20230703175447.1"><vh>TestGlobals.test_g_openUNLFile</vh></v>
</v>
<v t="ekr.20041118104831.1"><vh>class LocalConfigManager</vh>
<v t="ekr.20041118104831.2"><vh> c.config.ctor</vh></v>
<v t="ekr.20190831030206.1"><vh>c.config.createActivesSettingsOutline (new: #852)</vh></v>
<v t="ekr.20190901181116.1"><vh>c.config.getSource</vh></v>
<v t="ekr.20120215072959.12471"><vh>c.config.Getters</vh>
<v t="ekr.20041123092357"><vh>c.config.findSettingsPosition &amp; helper</vh>
<v t="ekr.20041120074536"><vh>c.config.settingsRoot</vh></v>
</v>
<v t="ekr.20120215072959.12515"><vh>c.config.Getters</vh>
<v t="ekr.20120215072959.12519"><vh>c.config.get &amp; allies</vh>
<v t="ekr.20120215072959.12520"><vh>c.config.getValFromDict</vh></v>
<v t="ekr.20120215072959.12521"><vh>c.config.typesMatch</vh></v>
</v>
<v t="ekr.20120215072959.12522"><vh>c.config.getAbbrevDict</vh></v>
<v t="ekr.20120215072959.12523"><vh>c.config.getBool</vh></v>
<v t="ekr.20120215072959.12525"><vh>c.config.getColor</vh></v>
<v t="ekr.20120215072959.12527"><vh>c.config.getData</vh></v>
<v t="ekr.20131114051702.16542"><vh>c.config.getOutlineData</vh></v>
<v t="ekr.20120215072959.12528"><vh>c.config.getDirectory</vh></v>
<v t="ekr.20120215072959.12530"><vh>c.config.getFloat</vh></v>
<v t="ekr.20120215072959.12531"><vh>c.config.getFontFromParams</vh></v>
<v t="ekr.20120215072959.12532"><vh>c.config.getInt</vh></v>
<v t="ekr.20120215072959.12533"><vh>c.config.getLanguage</vh></v>
<v t="ekr.20120215072959.12534"><vh>c.config.getMenusList</vh></v>
<v t="ekr.20120215072959.12535"><vh>c.config.getOpenWith</vh></v>
<v t="ekr.20120215072959.12536"><vh>c.config.getRatio</vh></v>
<v t="ekr.20120215072959.12538"><vh>c.config.getSettingSource</vh></v>
<v t="ekr.20120215072959.12539"><vh>c.config.getShortcut</vh></v>
<v t="ekr.20120215072959.12540"><vh>c.config.getString</vh></v>
</v>
<v t="ekr.20120215072959.12543"><vh>c.config.Getters: redirect to g.app.config</vh></v>
<v t="ekr.20140114145953.16691"><vh>c.config.isLocalSetting</vh></v>
<v t="ekr.20171119222458.1"><vh>c.config.isLocalSettingsFile</vh></v>
<v t="ekr.20120224140548.10528"><vh>c.exists</vh></v>
</v>
<v t="ekr.20230306104439.1"><vh>c.config.printColorSettings</vh></v>
<v t="ekr.20230306104456.1"><vh>c.config.printFontSettings</vh></v>
<v t="ekr.20070418073400"><vh>c.config.printSettings</vh></v>
<v t="ekr.20120215072959.12475"><vh>c.config.set</vh></v>
<v t="ekr.20190905082644.1"><vh>c.config.settingIsActiveInPath</vh></v>
<v t="ekr.20180121135120.1"><vh>c.config.setUserSetting</vh></v>
</v>
</v>
<v t="ekr.20230701070151.1"><vh>--- completed tests &amp; related methods</vh>
<v t="ekr.20230701102939.1"><vh>--- 16 tested </vh>
<v t="ekr.20230628072620.1"></v>
<v t="ekr.20230624015529.1"></v>
<v t="ekr.20230626064652.1"></v>
<v t="ekr.20230630132339.1"></v>
<v t="ekr.20230628072109.1"></v>
<v t="ekr.20120311151914.9918"></v>
<v t="ekr.20050819064157"></v>
<v t="ekr.20230630132340.1"></v>
<v t="ekr.20230630132341.1"></v>
<v t="ekr.20220410180439.1"></v>
<v t="ekr.20230628174317.1"></v>
<v t="ekr.20230628173542.2"><vh>p.get_full_legacy_UNL</vh></v>
<v t="ekr.20230628173542.1"></v>
<v t="ekr.20230628175148.1"></v>
<v t="ekr.20230628174804.1"></v>
<v t="ekr.20230624171452.1"></v>
</v>
<v t="ekr.20230701102932.1"><vh>--- 14 tests</vh>
<v t="ekr.20230703103514.1"><vh>TestTest2.test_set_setting</vh></v>
<v t="ekr.20230701095636.1"></v>
<v t="ekr.20230325055810.1"></v>
<v t="ekr.20230703175743.1"></v>
<v t="ekr.20230701171707.1"></v>
<v t="ekr.20230701085746.1"></v>
<v t="ekr.20230701101300.1"></v>
<v t="ekr.20230131234527.1"></v>
<v t="ekr.20230703175447.1"></v>
<v t="ekr.20230617065929.1"></v>
<v t="ekr.20230701103509.1"></v>
<v t="ekr.20230701113123.1"></v>
<v t="ekr.20230702165813.1"></v>
<v t="ekr.20220411165627.1"><vh>TestQtGui.test_put_html_links</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20230507080042.1"><vh>=== PR #3319: design tests</vh>
<v t="ekr.20230507122715.1"><vh>--- testing</vh>
<v t="ekr.20230508145335.1"></v>
<v t="ekr.20230506095516.1"><vh>class TestAnnotations(unittest.TestCase)</vh>
<v t="ekr.20230508150535.1"><vh>TestAnnotations.slow_test_all_paths</vh></v>
</v>
<v t="ekr.20230506095648.1"><vh>class TestChains(unittest.TestCase)</vh>
<v t="ekr.20230507170833.1"><vh>function: dump_chains</vh></v>
<v t="ekr.20230507122923.1"><vh>TestChains.slow_test_all_paths</vh></v>
<v t="ekr.20230507171657.1"><vh>TestChains.test_bare_chain</vh></v>
<v t="ekr.20230507122925.1"><vh>TestChains.test_one_chain</vh></v>
</v>
<v t="ekr.20230506123402.1"><vh>test_annotation</vh></v>
<v t="ekr.20230507122923.1"></v>
</v>
<v t="ekr.20230508085817.1"><vh>--- traversers</vh>
<v t="ekr.20230506111649.1"><vh>class AnnotationsTraverser(NodeVisitor)</vh>
<v t="ekr.20230506123402.1"></v>
<v t="ekr.20230506111649.3"><vh>visit_AnnAssign</vh></v>
<v t="ekr.20230506111649.4"><vh>visit_FunctionDef</vh></v>
</v>
<v t="ekr.20230506111927.1"><vh>class ChainsTraverser(NodeVisitor)</vh></v>
</v>
</v>
<v t="ekr.20230509205648.1"><vh>=== PR #3330: c++ importer</vh></v>
<v t="ekr.20230514135132.1"><vh>=== PR #3345: new importers</vh>
<v t="ekr.20230515074705.1"><vh>--- deleted tests</vh>
<v t="vitalije.20211207185708.1"><vh>TestPython: test_only_docs</vh></v>
<v t="vitalije.20211213125307.1"><vh>TestPython: test_large_class_under_indented</vh></v>
<v t="ekr.20211126055349.1"><vh>TestPython.test_short_file</vh></v>
<v t="ekr.20230514223556.1"><vh>TestPython.test_basic</vh></v>
<v t="ekr.20210904065459.63"><vh>TestPython.test_short_classes</vh></v>
<v t="vitalije.20211213125810.1"><vh>TestPython: test_nested_classes_with_async</vh></v>
<v t="vitalije.20211208210459.1"><vh>TestPython: test_strange_indentation_with...</vh></v>
</v>
</v>
<v t="ekr.20230515172316.1"><vh>=== PR #3347: finish importers</vh>
<v t="ekr.20230529075138.4"><vh>class Importer</vh>
<v t="ekr.20230529075138.5"><vh>i.__init__</vh></v>
<v t="ekr.20230529075640.1"><vh>i: Generic methods: may be overridden</vh>
<v t="ekr.20230529075138.36"><vh>i.check_blanks_and_tabs</vh></v>
<v t="ekr.20230529075138.13"><vh>i.compute_headline</vh></v>
<v t="ekr.20230612170928.1"><vh>i.create_preamble</vh></v>
<v t="ekr.20230529075138.10"><vh>i.find_blocks</vh></v>
<v t="ekr.20230529075138.11"><vh>i.find_end_of_block</vh></v>
<v t="ekr.20230529075138.14"><vh>i.gen_block</vh></v>
<v t="ekr.20230529075138.15"><vh>i.gen_lines (top level)</vh></v>
<v t="ekr.20230529075138.37"><vh>i.import_from_string (driver)</vh></v>
<v t="ekr.20230529075138.12"><vh>i.make_guide_lines</vh></v>
<v t="ekr.20230529075138.38"><vh>i.preprocess_lines</vh></v>
<v t="ekr.20230529075138.39"><vh>i.regularize_whitespace</vh></v>
</v>
<v t="ekr.20230529075138.7"><vh>i: Utils</vh>
<v t="ekr.20230529075138.8"><vh>i.compute_common_lws</vh></v>
<v t="ekr.20230529075138.34"><vh>i.create_placeholders</vh></v>
<v t="ekr.20230529075138.9"><vh>i.delete_comments_and_strings</vh></v>
<v t="ekr.20230529075138.42"><vh>i.get_str_lws</vh></v>
<v t="ekr.20230529075138.16"><vh>i.remove_common_lws</vh></v>
<v t="ekr.20230529075138.17"><vh>i.trace_blocks</vh></v>
</v>
</v>
</v>
<v t="ekr.20230607163543.1"><vh>=== PR #3362: c++ importer</vh>
<v t="ekr.20140723122936.17928"><vh>class C_Importer(Importer)</vh>
<v t="ekr.20220728055719.1"><vh>c_i.find_blocks</vh></v>
</v>
<v t="ekr.20230607164309.1"><vh>TestC.test_struct</vh></v>
</v>
<v t="ekr.20230608053503.1"><vh>=== PR #3363: recursive import path</vh>
<v t="ekr.20230613094743.1"><vh>--- changed/new</vh>
<v t="ekr.20130823083943.12615"><vh>ric.ctor</vh></v>
<v t="ekr.20130823083943.12611"><vh>ric.minimize_headline</vh></v>
<v t="ekr.20130823083943.12607"><vh>ric.post_process &amp; helpers</vh>
<v t="ekr.20180524100258.1"><vh>ric.add_class_names</vh></v>
<v t="ekr.20130823083943.12608"><vh>ric.clear_dirty_bits</vh></v>
<v t="ekr.20130823083943.12609"><vh>ric.dump_headlines</vh></v>
<v t="ekr.20130823083943.12610"><vh>ric.fix_back_slashes</vh></v>
<v t="ekr.20130823083943.12611"></v>
<v t="ekr.20130823083943.12612"><vh>ric.remove_empty_nodes</vh></v>
</v>
<v t="ekr.20130823083943.12612"></v>
<v t="ekr.20230613235653.1"><vh>TestLeoImport.test_ric_minimize_headlines</vh></v>
</v>
<v t="ekr.20230613092343.1"><vh>--- ref</vh>
<v t="ekr.20130823083943.12596"><vh>class RecursiveImportController</vh>
<v t="ekr.20130823083943.12615"></v>
<v t="ekr.20130823083943.12613"><vh>ric.run &amp; helpers</vh>
<v t="ekr.20130823083943.12597"><vh>ric.import_dir</vh></v>
<v t="ekr.20170404103953.1"><vh>ric.import_one_file</vh></v>
<v t="ekr.20130823083943.12607"></v>
</v>
</v>
<v t="ekr.20170428084123.1"></v>
<v t="ekr.20130823083943.12559"><vh>c.recursiveImport</vh>
<v t="ekr.20130823083943.12614"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20230608160541.1"><vh>=== PR #3365: simplify mypy annotations</vh></v>
<v t="ekr.20230609122845.1"><vh>=== PR #3367: from collections.abc import callable</vh></v>
<v t="ekr.20230611110204.1"><vh>=== PR #3372: g.isValidLanuge</vh>
<v t="ekr.20200810074755.1"><vh>g.isValidLanguage</vh></v>
</v>
<v t="ekr.20230610154229.1"><vh>=== PR #3373: remove unit test</vh></v>
<v t="ekr.20230612071030.1"><vh>=== PR #3376: improve python importer</vh>
<v t="ekr.20230612072809.1"><vh>--- classes</vh>
<v t="ekr.20210904064440.3"><vh>class BaseTestImporter(LeoUnitTest)</vh>
<v t="ekr.20230526135305.1"><vh>BaseTestImporter.check_outline</vh></v>
<v t="ekr.20220809054555.1"><vh>BaseTestImporter.check_round_trip</vh></v>
<v t="ekr.20211108044605.1"><vh>BaseTestImporter.compute_unit_test_kind</vh></v>
<v t="ekr.20230527075112.1"><vh>BaseTestImporter.new_round_trip_test</vh></v>
<v t="ekr.20230526124600.1"><vh>BaseTestImporter.new_run_test</vh></v>
<v t="ekr.20211127042843.1"><vh>BaseTestImporter.run_test</vh></v>
</v>
<v t="ekr.20230529075138.4"></v>
<v t="ekr.20220720043557.1"><vh>class Python_Importer</vh>
<v t="ekr.20230612171619.1"><vh>python_i.create_preamble</vh></v>
<v t="ekr.20230514140918.1"><vh>python_i.find_blocks</vh></v>
<v t="ekr.20230514140918.4"><vh>python_i.find_end_of_block</vh></v>
</v>
<v t="ekr.20211108063520.1"><vh>class TestCoffeescript (BaseTextImporter)</vh>
<v t="ekr.20210904065459.15"><vh>TestCoffeescript.test_1</vh></v>
<v t="ekr.20210904065459.16"><vh>TestCoffeescript.test_2</vh></v>
<v t="ekr.20211108085023.1"><vh>TestCoffeescript.test_get_leading_indent</vh></v>
<v t="ekr.20210904065459.126"><vh>TestCoffeescript.test_scan_line</vh></v>
</v>
<v t="ekr.20211108063908.1"><vh>class TestCython (BaseTestImporter)</vh>
<v t="ekr.20210904065459.11"><vh>TestCython.test_importer</vh></v>
</v>
<v t="ekr.20211108082509.1"><vh>class TestPython (BaseTestImporter)</vh>
<v t="ekr.20230514195224.1"><vh>TestPython.test_delete_comments_and_strings</vh></v>
<v t="vitalije.20211206201240.1"><vh>TestPython.test_general_test_1</vh></v>
<v t="ekr.20230612072414.1"><vh>TestPython.test_long_declaration</vh></v>
<v t="ekr.20211202064822.1"><vh>TestPython.test_nested_classes</vh></v>
<v t="vitalije.20211207200701.1"><vh>TestPython.test_no_methods</vh></v>
<v t="vitalije.20211206212507.1"><vh>TestPython.test_oneliners</vh></v>
<v t="ekr.20230612085239.1"><vh>TestPython.test_preamble</vh></v>
<v t="vitalije.20211207183645.1"><vh>TestPython.test_strange_indentation</vh></v>
</v>
</v>
<v t="ekr.20230612081544.1"><vh>----- recent tests</vh>
<v t="ekr.20210904065459.11"></v>
<v t="ekr.20221104065722.1"><vh>TestLeoImport.test_parse_body</vh></v>
<v t="vitalije.20211206201240.1"></v>
<v t="ekr.20230612072414.1"></v>
<v t="vitalije.20211206212507.1"></v>
</v>
<v t="ekr.20230612084311.1"><vh>--- changed/new</vh>
<v t="ekr.20230526135305.1"></v>
<v t="ekr.20230526124600.1"></v>
<v t="ekr.20230612170928.1"></v>
<v t="ekr.20230529075138.14"></v>
<v t="ekr.20230612171619.1"></v>
<v t="ekr.20230514140918.4"></v>
<v t="ekr.20230612085239.1"></v>
</v>
</v>
<v t="ekr.20230612071112.1"><vh>=== PR #3377: annotate leoAst.py</vh>
<v t="ekr.20230612204810.1"><vh>--- improved annotations</vh>
<v t="ekr.20191222102831.7"><vh>fs.change_quotes</vh></v>
<v t="ekr.20191225054848.1"><vh>fs.replace</vh></v>
<v t="ekr.20191222104224.1"><vh>fs.scan_rhs</vh></v>
<v t="ekr.20191226155316.1"><vh>fs.substitute_values</vh></v>
<v t="ekr.20191223053324.1"><vh>function: tokens_for_node</vh></v>
<v t="ekr.20200101030236.1"><vh>function: tokens_to_string</vh></v>
<v t="ekr.20200107165250.2"><vh>orange.ctor</vh></v>
<v t="ekr.20191204105506.1"><vh>tog.handle_call_arguments</vh></v>
<v t="ekr.20191110165235.2"><vh>tokenizer.add_token</vh></v>
<v t="ekr.20191110165235.4"><vh>tokenizer.do_token (the gem)</vh></v>
</v>
</v>
<v t="ekr.20230614100733.1"><vh>=== PR #3379: ekr-recursive-path-improvements2</vh>
<v t="ekr.20230614124415.1"><vh>--- changed</vh>
<v t="ekr.20130823083943.12611"></v>
<v t="ekr.20230613235653.1"></v>
</v>
</v>
<v t="ekr.20230607170737.1"><vh>=== PR #3380: git-diff</vh>
<v t="ekr.20170806094320.13"><vh>class GitDiffController</vh>
<v t="ekr.20180510095544.1"><vh>gdc.Entries...</vh>
<v t="ekr.20170806094320.6"><vh>gdc.diff_file</vh></v>
<v t="ekr.20201208115447.1"><vh>gdc.diff_pull_request</vh></v>
<v t="ekr.20180506064102.10"><vh>gdc.diff_two_branches</vh></v>
<v t="ekr.20180507212821.1"><vh>gdc.diff_two_revs</vh></v>
<v t="ekr.20170806094320.12"><vh>gdc.git_diff &amp; helper</vh>
<v t="ekr.20170820082125.1"><vh>gdc.diff_revs</vh></v>
</v>
<v t="ekr.20230705082614.1"><vh>gdc.node_history &amp; helpers</vh>
<v t="ekr.20230719161306.1"><vh>gdc._get_action</vh></v>
<v t="ekr.20230719170046.1"><vh>gdc._find_node</vh></v>
<v t="ekr.20230720085415.1"><vh>gdc._generate_nodes</vh></v>
<v t="ekr.20230705085430.1"><vh>gdc._get_contents_for_revs</vh></v>
<v t="ekr.20230719122859.1"><vh>gdc._get_diff_list</vh></v>
<v t="ekr.20230705084709.1"><vh>gdc._get_revs_for_path</vh></v>
<v t="ekr.20230720085122.1"><vh>gdc._trace_diff_list</vh></v>
<v t="ekr.20230720091027.1"><vh>gdc._trace_kind</vh></v>
</v>
</v>
<v t="ekr.20180510095801.1"><vh>gdc.Utils</vh>
<v t="ekr.20170806191942.2"><vh>gdc.create_compare_node</vh></v>
<v t="ekr.20170806094321.1"><vh>gdc.create_file_node</vh></v>
<v t="ekr.20170806094320.18"><vh>gdc.create_root</vh></v>
<v t="ekr.20170806094320.7"><vh>gdc.find_file</vh></v>
<v t="ekr.20170806094321.3"><vh>gdc.find_git_working_directory</vh></v>
<v t="ekr.20170819132219.1"><vh>gdc.find_gnx</vh></v>
<v t="ekr.20170806094321.5"><vh>gdc.finish</vh></v>
<v t="ekr.20210819080657.1"><vh>gdc.get_parent_of_git_directory</vh></v>
<v t="ekr.20180506064102.11"><vh>gdc.get_file_from_branch</vh></v>
<v t="ekr.20170806094320.15"><vh>gdc.get_file_from_rev</vh></v>
<v t="ekr.20170806094320.9"><vh>gdc.get_files</vh></v>
<v t="ekr.20170821052348.1"><vh>gdc.get_revno</vh></v>
<v t="ekr.20170820084258.1"><vh>gdc.make_at_clean_outline</vh></v>
<v t="ekr.20170806094321.7"><vh>gdc.make_at_file_outline</vh></v>
<v t="ekr.20170806125535.1"><vh>gdc.make_diff_outlines &amp; helper</vh>
<v t="ekr.20170806191707.1"><vh>gdc.compute_dicts</vh></v>
</v>
<v t="ekr.20201215050832.1"><vh>gdc.make_leo_outline</vh></v>
</v>
</v>
<v t="ekr.20230607171025.1"><vh>--- calling sequence (diff_two_revs)</vh>
<v t="ekr.20180507212821.1"></v>
<v t="ekr.20170806094320.6"></v>
<v t="ekr.20170806094320.15"></v>
</v>
<v t="ekr.20230609081427.1"><vh>--- calling sequence (git-diff)</vh>
<v t="ekr.20170819035801.90"><vh>efc.gitDiff (gd &amp; git-diff)</vh></v>
<v t="ekr.20170806094320.6"></v>
<v t="ekr.20170820082125.1"></v>
<v t="ekr.20170806094320.9"></v>
<v t="ekr.20170806094320.12"></v>
<v t="ekr.20170806094320.15"></v>
</v>
</v>
<v t="ekr.20230615031918.1"><vh>=== PR #3382 replace argparse</vh>
<v t="ekr.20120209051836.10242"><vh>class LoadManager</vh>
<v t="ekr.20120214060149.15851"><vh> LM.ctor</vh></v>
<v t="ekr.20120211121736.10812"><vh>LM.Directory &amp; file utils</vh>
<v t="ekr.20120219154958.10481"><vh>LM.completeFileName</vh></v>
<v t="ekr.20120209051836.10372"><vh>LM.computeLeoSettingsPath</vh></v>
<v t="ekr.20120209051836.10373"><vh>LM.computeMyLeoSettingsPath</vh></v>
<v t="ekr.20120209051836.10252"><vh>LM.computeStandardDirectories &amp; helpers</vh>
<v t="ekr.20120209051836.10253"><vh>LM.computeGlobalConfigDir</vh></v>
<v t="ekr.20120209051836.10254"><vh>LM.computeHomeDir</vh></v>
<v t="ekr.20120209051836.10260"><vh>LM.computeHomeLeoDir</vh></v>
<v t="ekr.20120209051836.10255"><vh>LM.computeLeoDir</vh></v>
<v t="ekr.20120209051836.10256"><vh>LM.computeLoadDir</vh>
<v t="ekr.20120209051836.10257"><vh>&lt;&lt; resolve symlinks &gt;&gt;</vh></v>
</v>
<v t="ekr.20120213164030.10697"><vh>LM.computeMachineName</vh></v>
</v>
<v t="ekr.20180318120148.1"><vh>LM.computeThemeDirectories</vh></v>
<v t="ekr.20180318133620.1"><vh>LM.computeThemeFilePath &amp; helper</vh>
<v t="ekr.20180321124503.1"><vh>LM.resolve_theme_path</vh></v>
</v>
<v t="ekr.20120211121736.10772"></v>
<v t="ekr.20120219154958.10485"><vh>LM.reportDirectories</vh></v>
</v>
<v t="ekr.20120215062153.10740"><vh>LM.Settings</vh>
<v t="ekr.20120130101219.10182"><vh>LM.computeBindingLetter</vh></v>
<v t="ekr.20120223062418.10421"><vh>LM.computeLocalSettings</vh></v>
<v t="ekr.20121126202114.3"><vh>LM.createDefaultSettingsDicts</vh></v>
<v t="ekr.20120214165710.10726"><vh>LM.createSettingsDicts</vh></v>
<v t="ekr.20120223062418.10414"><vh>LM.getPreviousSettings</vh></v>
<v t="ekr.20120214132927.10723"><vh>LM.mergeShortcutsDicts &amp; helpers</vh>
<v t="ekr.20220820162604.1"><vh>&lt;&lt; trace the binding &gt;&gt;</vh></v>
<v t="ekr.20120311070142.9904"><vh>LM.checkForDuplicateShortcuts</vh></v>
<v t="ekr.20120214132927.10724"><vh>LM.invert</vh></v>
<v t="ekr.20120214132927.10725"><vh>LM.uninvert</vh></v>
</v>
<v t="ekr.20120222103014.10312"><vh>LM.openSettingsFile</vh></v>
<v t="ekr.20120213081706.10382"><vh>LM.readGlobalSettingsFiles</vh></v>
<v t="ekr.20120214165710.10838"><vh>LM.traceSettingsDict</vh></v>
<v t="ekr.20120214165710.10822"><vh>LM.traceShortcutsDict</vh></v>
</v>
<v t="ekr.20120219154958.10452"></v>
<v t="ekr.20160430063406.1"><vh>LM.revertCommander</vh></v>
</v>
<v t="ekr.20210927034148.1"></v>
</v>
<v t="ekr.20230614204314.1"><vh>=== PR #3383: TryStar (python 3.11)</vh>
<v t="ekr.20191113063144.1"><vh>class TokenOrderGenerator</vh>
<v t="ekr.20200103174914.1"><vh>tog: Init...</vh>
<v t="ekr.20191228184647.1"><vh>tog.balance_tokens</vh></v>
<v t="ekr.20191113063144.4"><vh>tog.create_links (inits all ivars)</vh></v>
<v t="ekr.20191229071733.1"><vh>tog.init_from_file</vh></v>
<v t="ekr.20191229071746.1"><vh>tog.init_from_string</vh></v>
</v>
<v t="ekr.20220402052020.1"><vh>tog: synchronizer...</vh>
<v t="ekr.20200110162044.1"><vh>tog.find_next_significant_token</vh></v>
<v t="ekr.20191125120814.1"><vh>tog.set_links</vh></v>
<v t="ekr.20191124083124.1"><vh>tog.sync_name (aka name)</vh></v>
<v t="ekr.20220402052102.1"><vh>tog.sync_op (aka op)</vh></v>
<v t="ekr.20191113063144.7"><vh>tog.sync_token (aka token)</vh></v>
</v>
<v t="ekr.20191223052749.1"><vh>tog: Traversal...</vh>
<v t="ekr.20191113063144.3"><vh>tog.enter_node</vh></v>
<v t="ekr.20200104032811.1"><vh>tog.leave_node</vh></v>
<v t="ekr.20191113081443.1"><vh>tog.visit</vh></v>
</v>
<v t="ekr.20191113063144.13"><vh>tog: Visitors...</vh>
<v t="ekr.20191113063144.32"><vh> tog.keyword: not called!</vh></v>
<v t="ekr.20191113063144.14"><vh>tog: Contexts</vh>
<v t="ekr.20191113063144.28"><vh> tog.arg</vh></v>
<v t="ekr.20191113063144.27"><vh> tog.arguments</vh></v>
<v t="ekr.20191113063144.15"><vh>tog.AsyncFunctionDef</vh></v>
<v t="ekr.20191113063144.16"><vh>tog.ClassDef</vh></v>
<v t="ekr.20191113063144.17"><vh>tog.FunctionDef</vh></v>
<v t="ekr.20191113063144.18"><vh>tog.Interactive</vh></v>
<v t="ekr.20191113063144.20"><vh>tog.Lambda</vh></v>
<v t="ekr.20191113063144.19"><vh>tog.Module</vh></v>
</v>
<v t="ekr.20191113063144.21"><vh>tog: Expressions</vh>
<v t="ekr.20191113063144.22"><vh>tog.Expr</vh></v>
<v t="ekr.20191113063144.23"><vh>tog.Expression</vh></v>
<v t="ekr.20191113063144.24"><vh>tog.GeneratorExp</vh></v>
<v t="ekr.20210321171703.1"><vh>tog.NamedExpr</vh></v>
</v>
<v t="ekr.20191113063144.26"><vh>tog: Operands</vh>
<v t="ekr.20191113063144.29"><vh>tog.Attribute</vh></v>
<v t="ekr.20191113063144.30"><vh>tog.Bytes</vh></v>
<v t="ekr.20191113063144.33"><vh>tog.comprehension</vh></v>
<v t="ekr.20191113063144.34"><vh>tog.Constant</vh></v>
<v t="ekr.20191113063144.35"><vh>tog.Dict</vh></v>
<v t="ekr.20191113063144.36"><vh>tog.DictComp</vh></v>
<v t="ekr.20191113063144.37"><vh>tog.Ellipsis</vh></v>
<v t="ekr.20191113063144.38"><vh>tog.ExtSlice</vh></v>
<v t="ekr.20191113063144.40"><vh>tog.Index</vh></v>
<v t="ekr.20191113063144.39"><vh>tog.FormattedValue: not called!</vh></v>
<v t="ekr.20191113063144.41"><vh>tog.JoinedStr &amp; helpers</vh></v>
<v t="ekr.20191113063144.42"><vh>tog.List</vh></v>
<v t="ekr.20191113063144.43"><vh>tog.ListComp</vh></v>
<v t="ekr.20191113063144.44"><vh>tog.Name &amp; NameConstant</vh></v>
<v t="ekr.20191113063144.45"><vh>tog.Num</vh></v>
<v t="ekr.20191113063144.47"><vh>tog.Set</vh></v>
<v t="ekr.20191113063144.48"><vh>tog.SetComp</vh></v>
<v t="ekr.20191113063144.49"><vh>tog.Slice</vh></v>
<v t="ekr.20191113063144.50"><vh>tog.Str &amp; helper</vh>
<v t="ekr.20200111083914.1"><vh>tog.get_concatenated_tokens</vh></v>
</v>
<v t="ekr.20191113063144.51"><vh>tog.Subscript</vh></v>
<v t="ekr.20191113063144.52"><vh>tog.Tuple</vh></v>
</v>
<v t="ekr.20191113063144.53"><vh>tog: Operators</vh>
<v t="ekr.20191113063144.55"><vh>tog.BinOp</vh></v>
<v t="ekr.20191113063144.56"><vh>tog.BoolOp</vh></v>
<v t="ekr.20191113063144.57"><vh>tog.Compare</vh></v>
<v t="ekr.20191113063144.58"><vh>tog.UnaryOp</vh></v>
<v t="ekr.20191113063144.59"><vh>tog.IfExp (ternary operator)</vh></v>
</v>
<v t="ekr.20191113063144.60"><vh>tog: Statements</vh>
<v t="ekr.20191113063144.83"><vh> tog.Starred</vh></v>
<v t="ekr.20191113063144.61"><vh>tog.AnnAssign</vh></v>
<v t="ekr.20191113063144.62"><vh>tog.Assert</vh></v>
<v t="ekr.20191113063144.63"><vh>tog.Assign</vh></v>
<v t="ekr.20191113063144.64"><vh>tog.AsyncFor</vh></v>
<v t="ekr.20191113063144.65"><vh>tog.AsyncWith</vh></v>
<v t="ekr.20191113063144.66"><vh>tog.AugAssign</vh></v>
<v t="ekr.20191113063144.67"><vh>tog.Await</vh></v>
<v t="ekr.20191113063144.68"><vh>tog.Break</vh></v>
<v t="ekr.20191113063144.31"><vh>tog.Call &amp; helpers</vh>
<v t="ekr.20191204114930.1"><vh>tog.arg_helper</vh></v>
<v t="ekr.20191204105506.1"></v>
</v>
<v t="ekr.20191113063144.69"><vh>tog.Continue</vh></v>
<v t="ekr.20191113063144.70"><vh>tog.Delete</vh></v>
<v t="ekr.20191113063144.71"><vh>tog.ExceptHandler</vh></v>
<v t="ekr.20191113063144.73"><vh>tog.For</vh></v>
<v t="ekr.20191113063144.74"><vh>tog.Global</vh></v>
<v t="ekr.20191113063144.75"><vh>tog.If &amp; helpers</vh>
<v t="ekr.20191122222412.1"><vh>&lt;&lt; do_If docstring &gt;&gt;</vh></v>
</v>
<v t="ekr.20191113063144.76"><vh>tog.Import &amp; helper</vh></v>
<v t="ekr.20191113063144.77"><vh>tog.ImportFrom</vh></v>
<v t="ekr.20220401034726.1"><vh>tog.Match* (Python 3.10+)</vh>
<v t="ekr.20220401034726.2"><vh>tog.match_case</vh></v>
<v t="ekr.20220401034726.3"><vh>tog.MatchAs</vh></v>
<v t="ekr.20220401034726.4"><vh>tog.MatchClass</vh></v>
<v t="ekr.20220401034726.5"><vh>tog.MatchMapping</vh></v>
<v t="ekr.20220401034726.6"><vh>tog.MatchOr</vh></v>
<v t="ekr.20220401034726.7"><vh>tog.MatchSequence</vh></v>
<v t="ekr.20220401034726.8"><vh>tog.MatchSingleton</vh></v>
<v t="ekr.20220401034726.9"><vh>tog.MatchStar</vh></v>
<v t="ekr.20220401034726.10"><vh>tog.MatchValue</vh></v>
</v>
<v t="ekr.20191113063144.78"><vh>tog.Nonlocal</vh></v>
<v t="ekr.20191113063144.79"><vh>tog.Pass</vh></v>
<v t="ekr.20191113063144.81"><vh>tog.Raise</vh></v>
<v t="ekr.20191113063144.82"><vh>tog.Return</vh></v>
<v t="ekr.20191113063144.85"><vh>tog.Try</vh></v>
<v t="ekr.20230615211005.1"><vh>tog.TryStar</vh></v>
<v t="ekr.20191113063144.88"><vh>tog.While</vh></v>
<v t="ekr.20191113063144.89"><vh>tog.With</vh></v>
<v t="ekr.20191113063144.90"><vh>tog.Yield</vh></v>
<v t="ekr.20191113063144.91"><vh>tog.YieldFrom</vh></v>
</v>
</v>
</v>
<v t="ekr.20230616025129.1"><vh>--- testing</vh>
<v t="ekr.20191227154302.1"><vh>class BaseTest (TestCase)</vh>
<v t="ekr.20200110103036.1"><vh>BaseTest.adjust_expected</vh></v>
<v t="ekr.20200110092217.1"><vh>BaseTest.check_roundtrip</vh></v>
<v t="ekr.20191227054856.1"><vh>BaseTest.make_data</vh></v>
<v t="ekr.20191227103533.1"><vh>BaseTest.make_file_data</vh></v>
<v t="ekr.20191228101601.1"><vh>BaseTest: passes...</vh>
<v t="ekr.20191228095945.11"><vh>0.1: BaseTest.make_tokens</vh></v>
<v t="ekr.20191228102101.1"><vh>0.2: BaseTest.make_tree</vh></v>
<v t="ekr.20191228185201.1"><vh>0.3: BaseTest.balance_tokens</vh></v>
<v t="ekr.20191228101437.1"><vh>1.1: BaseTest.create_links</vh></v>
<v t="ekr.20191228095945.10"><vh>2.1: BaseTest.fstringify</vh></v>
<v t="ekr.20200107175223.1"><vh>2.2: BaseTest.beautify</vh></v>
</v>
<v t="ekr.20191228095945.1"><vh>BaseTest: stats...</vh>
<v t="ekr.20191228095945.12"><vh>BaseTest.dump_stats &amp; helpers</vh>
<v t="ekr.20191228154757.1"><vh>BaseTest.dump_counts</vh></v>
<v t="ekr.20191228154801.1"><vh>BaseTest.dump_times</vh></v>
</v>
<v t="ekr.20191228181624.1"><vh>BaseTest.update_counts &amp; update_times</vh></v>
</v>
</v>
<v t="ekr.20191227051737.1"><vh>class TestTOG (BaseTest)</vh>
<v t="ekr.20210318213945.1"><vh>TestTOG.Recent bugs &amp; features</vh>
<v t="ekr.20210321172902.1"><vh>test_bug_1851</vh></v>
<v t="ekr.20210914161519.1"><vh>test_bug_2171</vh></v>
<v t="ekr.20210318213133.1"><vh>test_full_grammar</vh></v>
<v t="ekr.20210318214057.1"><vh>test_line_315</vh></v>
<v t="ekr.20210320095504.8"><vh>test_line_337</vh></v>
<v t="ekr.20210320065202.1"><vh>test_line_483</vh></v>
<v t="ekr.20210320065344.1"><vh>test_line_494</vh></v>
<v t="ekr.20210319130349.1"><vh>test_line_875</vh></v>
<v t="ekr.20210319130616.1"><vh>test_line_898</vh></v>
<v t="ekr.20210320085705.1"><vh>test_walrus_operator</vh></v>
</v>
<v t="ekr.20191227052446.10"><vh>TestTOG.Contexts...</vh>
<v t="ekr.20191227052446.11"><vh>test_ClassDef</vh></v>
<v t="ekr.20191227052446.12"><vh>test_ClassDef2</vh></v>
<v t="ekr.20191227052446.13"><vh>test_FunctionDef</vh></v>
<v t="ekr.20200111171738.1"><vh>test_FunctionDef_with_annotations</vh></v>
<v t="ekr.20210802162650.1"><vh>test_FunctionDef_with_posonly_args</vh></v>
</v>
<v t="ekr.20191227052446.14"><vh>TestTOG.Expressions &amp; operators...</vh>
<v t="ekr.20191227052446.15"><vh>test_attribute</vh></v>
<v t="ekr.20191227052446.16"><vh>test_CompareOp</vh></v>
<v t="ekr.20191227052446.17"><vh>test_Dict_1</vh></v>
<v t="ekr.20200111191153.1"><vh>test_Dict_2</vh></v>
<v t="ekr.20191227052446.18"><vh>test_DictComp</vh></v>
<v t="ekr.20200112042410.1"><vh>test_ExtSlice</vh></v>
<v t="ekr.20191227052446.19"><vh>test_ListComp</vh></v>
<v t="ekr.20191227052446.20"><vh>test_NameConstant</vh></v>
<v t="ekr.20191227052446.21"><vh>test_Operator: semicolon</vh></v>
<v t="ekr.20191227052446.22"><vh>test_Operator: semicolon between statements</vh></v>
<v t="ekr.20200111194454.1"><vh>test_Set</vh></v>
<v t="ekr.20200111195654.1"><vh>test_SetComp</vh></v>
<v t="ekr.20191227052446.23"><vh>test_UnaryOp</vh></v>
</v>
<v t="ekr.20191227052446.65"><vh>TestTOG.f-strings....</vh>
<v t="ekr.20191227052446.66"><vh>test_fstring01: complex Call</vh></v>
<v t="ekr.20191227052446.67"><vh>test_fstring02: Ternary</vh></v>
<v t="ekr.20191227052446.68"><vh>test_fstring03: single f-string</vh></v>
<v t="ekr.20191227052446.69"><vh>test_fstring04: f-string + plain</vh></v>
<v t="ekr.20191227052446.70"><vh>test_fstring05: plain + f-string</vh></v>
<v t="ekr.20191227052446.71"><vh>test_fstring06: f-string + fstring</vh></v>
<v t="ekr.20191227052446.72"><vh>test_fstring07: many</vh></v>
<v t="ekr.20191227052446.73"><vh>test_fstring08: ternary op</vh></v>
<v t="ekr.20191227052446.74"><vh>test_fstring09: leoFind.py line 856</vh></v>
<v t="ekr.20191227052446.75"><vh>test_fstring10: leoFind.py: line 861</vh></v>
<v t="ekr.20191227052446.76"><vh>test_fstring11: joins</vh>
<v t="ekr.20191227052446.77"><vh>more</vh></v>
</v>
<v t="ekr.20191227052446.78"><vh>test_fstring12: joins + 1 f-expr</vh></v>
<v t="ekr.20191227052446.79"><vh>test_fstring13: joins + 2 f-exprs</vh></v>
<v t="ekr.20191227052446.80"><vh>test_fstring14: complex, with commas</vh></v>
<v t="ekr.20191227052446.81"><vh>test_fstring15</vh></v>
<v t="ekr.20191227052446.83"><vh>test_fstring16: simple</vh></v>
<v t="ekr.20191227052446.82"><vh>test_regex_fstring</vh></v>
</v>
<v t="ekr.20191227052446.32"><vh>TestTOG.If...</vh>
<v t="ekr.20191227052446.33"><vh>test_from leoTips.py</vh></v>
<v t="ekr.20191227052446.34"><vh>test_if + tuple</vh></v>
<v t="ekr.20191227052446.35"><vh>test_if + unary op</vh></v>
<v t="ekr.20191227052446.36"><vh>test_if, elif</vh></v>
<v t="ekr.20191227052446.37"><vh>test_if, elif + 2</vh></v>
<v t="ekr.20191227052446.38"><vh>test_if, elif, else</vh></v>
<v t="ekr.20191227052446.39"><vh>test_if, else</vh></v>
<v t="ekr.20191227052446.40"><vh>test_if, else, if</vh></v>
<v t="ekr.20191227052446.41"><vh>test_Nested If's</vh></v>
<v t="ekr.20191227052446.42"><vh>test_ternary + if</vh></v>
</v>
<v t="ekr.20191227145620.1"><vh>TestTOG.Miscellaneous...</vh>
<v t="ekr.20200206041753.1"><vh>test_comment_in_set_links</vh></v>
<v t="ekr.20200112065944.1"><vh>test_ellipsis_1</vh></v>
<v t="ekr.20200112070228.1"><vh>test_ellipsis_2</vh></v>
<v t="ekr.20191227075951.1"><vh>test_end_of_line</vh></v>
</v>
<v t="ekr.20191227052446.50"><vh>TestTOG.Plain Strings...</vh>
<v t="ekr.20191227052446.52"><vh>test_\x and \o escapes</vh></v>
<v t="ekr.20191227052446.53"><vh>test_backslashes in docstring</vh></v>
<v t="ekr.20191227052446.54"><vh>test_bs/nl</vh></v>
<v t="ekr.20191227052446.55"><vh>test_bytes bs-x</vh></v>
<v t="ekr.20191227052446.56"><vh>test_empty string</vh></v>
<v t="ekr.20191227052446.57"><vh>test_escaped string delims</vh></v>
<v t="ekr.20191227052446.58"><vh>test_escaped strings</vh></v>
<v t="ekr.20191227052446.59"><vh>test_f-string join</vh></v>
<v t="ekr.20191227052446.64"><vh>test_potential_fstring</vh></v>
<v t="ekr.20191227052446.60"><vh>test_raw docstring</vh></v>
<v t="ekr.20191227052446.61"><vh>test_raw escaped strings</vh></v>
<v t="ekr.20191227052446.62"><vh>test_single quote</vh></v>
<v t="ekr.20191227052446.63"><vh>test_string concatenation_1</vh></v>
<v t="ekr.20200111042825.1"><vh>test_string_concatenation_2</vh></v>
</v>
<v t="ekr.20191227052446.43"><vh>TestTOG.Statements...</vh>
<v t="ekr.20200112075707.1"><vh>test_AnnAssign</vh></v>
<v t="ekr.20200112071833.1"><vh>test_AsyncFor</vh></v>
<v t="ekr.20200111175043.1"><vh>test_AsyncFunctionDef</vh></v>
<v t="ekr.20200112073151.1"><vh>test_AsyncWith</vh></v>
<v t="ekr.20191227052446.44"><vh>test_Call</vh></v>
<v t="ekr.20200206040732.1"><vh>test_Delete</vh></v>
<v t="ekr.20200111175335.1"><vh>test_For</vh></v>
<v t="ekr.20191227052446.45"><vh>test_Global</vh></v>
<v t="ekr.20200111200424.1"><vh>test_ImportFrom</vh></v>
<v t="ekr.20210318174705.1"><vh>test_ImportFromStar</vh></v>
<v t="ekr.20200206040424.1"><vh>test_Lambda</vh></v>
<v t="ekr.20220329095904.1"><vh>test_Match</vh></v>
<v t="ekr.20200111200640.1"><vh>test_Nonlocal</vh></v>
<v t="ekr.20220224120239.1"><vh>test_Raise</vh></v>
<v t="ekr.20191227052446.46"><vh>test_Try</vh></v>
<v t="ekr.20230616015533.1"><vh>test_TryStar</vh></v>
<v t="ekr.20191227052446.47"><vh>test_TryExceptElse</vh></v>
<v t="ekr.20200206041336.1"><vh>test_While</vh></v>
<v t="ekr.20191227052446.48"><vh>test_With</vh></v>
<v t="ekr.20200206041611.1"><vh>test_Yield</vh></v>
<v t="ekr.20191227052446.49"><vh>test_YieldFrom</vh></v>
</v>
<v t="ekr.20191228193740.1"><vh>TestTOG.test_aa &amp;&amp; zz</vh></v>
</v>
<v t="ekr.20230616015533.1"></v>
</v>
<v t="ekr.20230616025136.1"><vh>--- changed &amp; new</vh>
<v t="ekr.20191113063144.71"></v>
<v t="ekr.20191113063144.85"></v>
<v t="ekr.20230615211005.1"></v>
</v>
</v>
<v t="ekr.20230616032729.1"><vh>=== PR #3384: requests.get timeout</vh>
<v t="ekr.20180325024334.1"><vh>git.get_all_issues</vh></v>
<v t="ekr.20180126043719.3"><vh>git.get_one_issue</vh></v>
<v t="ekr.20180121045646.1"><vh>make_tips (leoTips.py)</vh></v>
</v>
<v t="ekr.20230616034015.1"><vh>=== PR #3385: option typo</vh>
<v t="ekr.20210927034148.1"></v>
</v>
<v t="ekr.20230616073628.1"><vh>=== PR #3388: option check</vh>
<v t="ekr.20210927034148.1"></v>
</v>
<v t="ekr.20230616170306.1"><vh>=== PR #3389: more options</vh>
<v t="ekr.20210927034148.1"></v>
<v t="ekr.20230616134732.1"><vh>class g.OptionsUtils</vh>
<v t="ekr.20230615034937.1"><vh>OptionsUtils.check_options</vh></v>
<v t="ekr.20230615062610.1"><vh>OptionsUtils.compute_valid_options</vh></v>
<v t="ekr.20230615084117.1"><vh>OptionsUtils.find_complex_option</vh></v>
<v t="ekr.20230616075049.1"><vh>OptionsUtils.option_error</vh></v>
</v>
</v>
<v t="ekr.20230616184953.1"><vh>=== PR #3390: repackage options</vh>
<v t="ekr.20230616134732.1"></v>
<v t="ekr.20210927034148.1"></v>
<v t="ekr.20230617065356.1"><vh>TestApp.test_LM_scanOptions</vh></v>
<v t="ekr.20230617065929.1"></v>
</v>
<v t="ekr.20230618022117.1"><vh>=== PR #3393: fix ric.minimize_headline</vh>
<v t="ekr.20130823083943.12596"></v>
<v t="ekr.20230613235653.1"></v>
<v t="ekr.20130823083943.12611"></v>
</v>
<v t="ekr.20230618072327.1"><vh>=== PR #3397: --screen-shot crash</vh>
<v t="ekr.20230618112927.1"><vh>--- no longer used</vh>
<v t="ekr.20210927034148.6"><vh>LM.doScreenShotOption</vh></v>
<v t="ekr.20120219154958.10489"><vh>LM.make_screen_shot</vh></v>
</v>
<v t="ekr.20230618073516.1"><vh>--- changed</vh>
<v t="ekr.20100908110845.5606"><vh> init (screenshots.py)</vh></v>
<v t="ekr.20100908115707.5554"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20100914090933.5770"><vh>g.command(take-local/global-screen-shot)</vh></v>
<v t="ekr.20120219154958.10487"></v>
<v t="ekr.20120219154958.10487"></v>
<v t="ekr.20120219154958.10452"></v>
<v t="ekr.20210927034148.1"></v>
</v>
</v>
<v t="ekr.20230618195419.1"><vh>=== PR #3398: fix unit test</vh>
<v t="ekr.20230616015533.1"></v>
<v t="ekr.20230613235653.1"></v>
</v>
<v t="ekr.20230619075952.1"><vh>=== PR #3399: diff-leo-files</vh>
<v t="ekr.20180213104627.1"><vh>diff_leo_files_helper</vh></v>
</v>
<v t="ekr.20230622051358.1"><vh>=== PR #3401: edit-settings</vh>
<v t="ekr.20170324143944.3"><vh>qt: show-fonts</vh></v>
<v t="ekr.20171229131953.1"><vh>parseFont (leoConfig.py)</vh></v>
</v>
<v t="ekr.20230702040714.1"><vh>=== PR #3418: annotations for console gui</vh>
<v t="ekr.20220415013957.1"><vh>&lt;&lt; leoFrame annotations &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3679"><vh>LeoFrame.__init__ &amp; reloadSettings</vh>
<v t="ekr.20051009045404"><vh>frame.createFirstTreeNode</vh></v>
</v>
<v t="ekr.20041223105114.1"><vh>LeoFrame.Status line convenience methods</vh></v>
</v>
<v t="ekr.20230703055934.1"><vh>=== PR #3421: insert-headline-time</vh></v>
<v t="ekr.20230702154838.1"><vh>=== PR #3422: save/restore sessions to global cache</vh>
<v t="ekr.20120420054855.14248"><vh>SessionManager.load_snapshot</vh></v>
<v t="ekr.20120420054855.14249"><vh>SessionManager.save_snapshot</vh></v>
</v>
<v t="ekr.20230704183625.1"><vh>=== PR #3424: unl tweaks</vh>
<v t="ekr.20230705103504.1"><vh>--- changed</vh>
<v t="ekr.20230630132340.1"></v>
<v t="ekr.20230624171452.1"></v>
</v>
<v t="ekr.20230706110602.1"><vh>--- restore gnx</vh>
<v t="ekr.20230624171452.1"></v>
<v t="ekr.20230706110947.1"><vh>from master</vh></v>
<v t="ekr.20230628173542.2"></v>
</v>
</v>
<v t="ekr.20230704130731.1"><vh>=== PR #3426: git-node-history</vh>
<v t="ekr.20230720120523.1"><vh>--- ref</vh>
<v t="ekr.20170806094320.12"></v>
<v t="ekr.20170806094320.6"></v>
<v t="ekr.20170806094320.13"></v>
</v>
<v t="ekr.20230705082614.1"></v>
<v t="ekr.20230720114553.1"><vh>--- testing</vh>
<v t="ekr.20230720115916.1"></v>
<v t="ekr.20230714143317.3"><vh>TestEditFileCommands.slow_test_gdc_node_history</vh></v>
</v>
<v t="ekr.20230720165209.1"><vh>node_history: leoGlobals.py</vh>
<v t="ekr.20230720165209.2"><vh>   0 diff</vh>
<v t="ekr.20230720165209.3"><vh>old</vh></v>
<v t="ekr.20230720165209.4"><vh>new</vh></v>
</v>
<v t="ekr.20230720165209.5"><vh>   3 diff</vh>
<v t="ekr.20230720165209.6"><vh>old</vh></v>
<v t="ekr.20230720165209.7"><vh>new</vh></v>
</v>
<v t="ekr.20230720165209.8"><vh>  20 diff</vh>
<v t="ekr.20230720165209.9"><vh>old</vh></v>
<v t="ekr.20230720165209.10"><vh>new</vh></v>
</v>
<v t="ekr.20230720165209.11"><vh>  26 diff</vh>
<v t="ekr.20230720165209.12"><vh>old</vh></v>
<v t="ekr.20230720165209.13"><vh>new</vh></v>
</v>
<v t="ekr.20230720165209.14"><vh>  40 diff</vh>
<v t="ekr.20230720165209.15"><vh>old</vh></v>
<v t="ekr.20230720165209.16"><vh>new</vh></v>
</v>
<v t="ekr.20230720165209.17"><vh>  41 delete</vh></v>
<v t="ekr.20230720165209.18"><vh>  48 add</vh></v>
<v t="ekr.20230720165209.19"><vh>  49 diff</vh>
<v t="ekr.20230720165209.20"><vh>old</vh></v>
<v t="ekr.20230720165209.21"><vh>new</vh></v>
</v>
<v t="ekr.20230720165209.22"><vh>  51 diff</vh>
<v t="ekr.20230720165209.23"><vh>old</vh></v>
<v t="ekr.20230720165209.24"><vh>new</vh></v>
</v>
<v t="ekr.20230720165209.25"><vh>  52 diff</vh>
<v t="ekr.20230720165209.26"><vh>old</vh></v>
<v t="ekr.20230720165209.27"><vh>new</vh></v>
</v>
<v t="ekr.20230720165209.28"><vh>  53 diff</vh>
<v t="ekr.20230720165209.29"><vh>old</vh></v>
<v t="ekr.20230720165209.30"><vh>new</vh></v>
</v>
<v t="ekr.20230720165209.31"><vh>  58 diff</vh>
<v t="ekr.20230720165209.32"><vh>old</vh></v>
<v t="ekr.20230720165209.33"><vh>new</vh></v>
</v>
</v>
</v>
<v t="ekr.20230702154511.1"><vh>=== PR #3433: quirp in refresh-from-disk</vh>
<v t="ekr.20230709034733.1"><vh>--- changed</vh>
<v t="ekr.20140717074441.17772"><vh>c_file.refreshFromDisk</vh></v>
<v t="ekr.20090225080846.3"><vh>at.readOneAtEditNode</vh></v>
<v t="ekr.20190201104956.1"><vh>at.readOneAtAsisNode</vh></v>
</v>
<v t="ekr.20230709035419.1"><vh>--- ref</vh>
<v t="ekr.20230402232100.1"><vh>c.fullPath</vh></v>
<v t="ekr.20230709033411.1"><vh>--- p.anyAtFileNodeName</vh>
<v t="ekr.20031218072017.3350"><vh>v.anyAtFileNodeName</vh></v>
<v t="ekr.20140729162415.18086"><vh>app.init_at_auto_names</vh></v>
<v t="ekr.20140729162415.18091"><vh>app.init_at_file_names</vh></v>
</v>
</v>
<v t="ekr.20140717074441.17772"></v>
</v>
<v t="ekr.20230709120116.1"><vh>=== PR #3436: Improve docstrings</vh>
<v t="ekr.20230624171452.1"></v>
<v t="ekr.20230624015529.1"></v>
<v t="ekr.20230626064652.1"></v>
<v t="ekr.20090502071837.4"><vh>&lt;&lt; leoRst docstring &gt;&gt;</vh></v>
</v>
<v t="ekr.20230710054912.1"><vh>=== PR #3437: quirps in commands.editFileCommands</vh>
<v t="ekr.20210307060752.2"><vh>atRoot.convert_file</vh></v>
<v t="ekr.20170806094319.3"><vh>efc.compareTrees</vh>
<v t="ekr.20170806094318.18"><vh>ct.compare</vh></v>
<v t="ekr.20170806094318.19"><vh>ct.run</vh></v>
<v t="ekr.20170806094319.2"><vh>ct.scan</vh></v>
</v>
<v t="ekr.20170806094318.7"><vh>efc.insertFile</vh></v>
</v>
<v t="ekr.20230710055039.1"><vh>=== PR #3438: refresh-from-disk undo</vh>
<v t="ekr.20230713075025.1"><vh>--- retired undo methods</vh>
<v t="ekr.20050315134017.3"><vh>u.afterChangeTree</vh></v>
<v t="ekr.20050315134017.6"><vh>u.beforeChangeTree</vh></v>
<v t="ekr.20050318085432.8"><vh>u.redoTree</vh></v>
<v t="EKR.20040530121329"><vh>u.restoreTree &amp; helpers</vh>
<v t="ekr.20050415170737.2"><vh>u.restoreVnodeUndoInfo</vh></v>
<v t="ekr.20050415170812.2"><vh>u.restoreTnodeUndoInfo</vh></v>
</v>
<v t="EKR.20040528075307"><vh>u.saveTree &amp; helpers</vh>
<v t="EKR.20040530114124"><vh>&lt;&lt; about u.saveTree &gt;&gt;</vh></v>
<v t="ekr.20050415170737.1"><vh>u.createVnodeUndoInfo</vh></v>
</v>
<v t="ekr.20050408100042"><vh>u.undoRedoTree</vh></v>
<v t="ekr.20050318085713.2"><vh>u.undoTree</vh></v>
</v>
<v t="ekr.20230713080301.1"><vh>--- changed/new undo code</vh>
<v t="ekr.20230713170902.1"><vh>--- no longer undoable</vh>
<v t="ekr.20070806105721.1"><vh>c_file.readAtAutoNodes</vh></v>
<v t="ekr.20031218072017.1839"><vh>c_file.readAtFileNodes</vh></v>
<v t="ekr.20080801071227.4"><vh>c_file.readAtShadowNodes</vh></v>
<v t="ekr.20140717074441.17772"></v>
<v t="ekr.20170806094319.10"><vh>efc.cleanAtCleanTree</vh></v>
<v t="ekr.20150514043850.11"><vh>abbrev.expandAbbrev &amp; helpers (entry point)</vh>
<v t="ekr.20161121121636.1"><vh>abbrev.exec_content</vh></v>
<v t="ekr.20150514043850.12"><vh>abbrev.expand_text</vh></v>
<v t="ekr.20150514043850.13"><vh>abbrev.expand_tree (entry) &amp; helpers</vh>
<v t="ekr.20150514043850.17"><vh>abbrev.paste_tree</vh></v>
</v>
<v t="ekr.20150514043850.14"><vh>abbrev.find_place_holder</vh></v>
<v t="ekr.20150514043850.15"><vh>abbrev.make_script_substitutions</vh></v>
<v t="ekr.20161121102113.1"><vh>abbrev.make_script_substitutions_in_headline</vh></v>
<v t="ekr.20161121112837.1"><vh>abbrev.match_prefix</vh></v>
<v t="ekr.20150514043850.16"><vh>abbrev.next_place</vh></v>
<v t="ekr.20161121114504.1"><vh>abbrev.post_pass</vh></v>
<v t="ekr.20150514043850.18"><vh>abbrev.replace_selection</vh></v>
<v t="ekr.20161121111502.1"><vh>abbrev_get_ch</vh></v>
<v t="ekr.20161121112346.1"><vh>abbrev_get_prefixes</vh></v>
</v>
</v>
<v t="ekr.20230713152722.1"><vh>--- make parse-body undoable again</vh>
<v t="ekr.20140531104908.18833"><vh>ic.parse_body</vh></v>
<v t="ekr.20230713151537.1"><vh>u.afterParseBody</vh></v>
<v t="ekr.20230713145834.1"><vh>u.beforeParseBody</vh></v>
<v t="ekr.20230713150847.1"><vh>u.redoParseBody</vh></v>
<v t="ekr.20230713150109.1"><vh>u.undoParseBody</vh></v>
</v>
</v>
<v t="ekr.20230714094011.1"><vh>--- add unit tests for 7 commands</vh>
<v t="ekr.20160331191740.1"><vh>@g.command(diff-marked-nodes)</vh></v>
<v t="ekr.20180506064102.10"></v>
<v t="ekr.20180507212821.1"></v>
<v t="ekr.20170806094320.12"></v>
<v t="ekr.20140531104908.18833"></v>
<v t="ekr.20180211170333.2"><vh>loc.diff_list_of_files (entry)</vh></v>
<v t="ekr.20130823083943.12613"></v>
<v t="ekr.20230714160900.1"><vh>TestCompare.test_diff_list_of_files</vh></v>
<v t="ekr.20230714131540.3"><vh>TestCompare.test_diff_marked_nodes</vh></v>
<v t="ekr.20230714143451.1"></v>
<v t="ekr.20230714160049.1"></v>
<v t="ekr.20230714154706.1"></v>
<v t="ekr.20230715004610.1"><vh>TestLeoImport.slow_test_ric_run</vh></v>
<v t="ekr.20221104065722.1"></v>
</v>
</v>
<v t="ekr.20230716044824.1"><vh>=== PR #3440: quirps re clean-at-clean</vh>
<v t="ekr.20170806094319.10"></v>
<v t="ekr.20170806094319.8"><vh>efc.cleanAtCleanNode</vh></v>
<v t="ekr.20170806094319.5"><vh>efc.cleanAtCleanFiles</vh></v>
</v>
<v t="ekr.20230716154607.1"><vh>=== PR #3441: load-leo.html</vh></v>
<v t="ekr.20230716182220.1"><vh>=== PR #3444: quirps2: commands.editFileCommands</vh>
<v t="ekr.20210307060752.1"><vh>class ConvertAtRoot</vh>
<v t="ekr.20210308044128.1"><vh>atRoot.check_move</vh></v>
<v t="ekr.20210307060752.2"></v>
<v t="ekr.20210308045306.1"><vh>atRoot.dump</vh></v>
<v t="ekr.20210307075117.1"><vh>atRoot.do_root</vh></v>
<v t="ekr.20210307085034.1"><vh>atRoot.find_all_units</vh></v>
<v t="ekr.20210307082125.1"><vh>atRoot.find_section</vh></v>
<v t="ekr.20210307075325.1"><vh>atRoot.make_clones</vh></v>
<v t="ekr.20210307080500.1"><vh>atRoot.make_clone</vh></v>
</v>
</v>
<v t="ekr.20230718063545.1"><vh>=== PR #3445: quirps 7-18-2023</vh>
<v t="ekr.20031218072017.3605"><vh>class Undoer</vh>
<v t="ekr.20150509193307.1"><vh>u.Birth</vh>
<v t="ekr.20031218072017.3606"><vh>u.__init__</vh></v>
<v t="ekr.20191213085126.1"><vh>u.reloadSettings</vh></v>
</v>
<v t="ekr.20050416092908.1"><vh>u.Internal helpers</vh>
<v t="ekr.20031218072017.3607"><vh>u.clearOptionalIvars</vh></v>
<v t="ekr.20060127052111.1"><vh>u.cutStack</vh></v>
<v t="ekr.20080623083646.10"><vh>u.dumpBead</vh></v>
<v t="EKR.20040526150818"><vh>u.getBead</vh></v>
<v t="EKR.20040526150818.1"><vh>u.peekBead</vh></v>
<v t="ekr.20060127113243"><vh>u.pushBead</vh></v>
<v t="ekr.20031218072017.3613"><vh>u.redoMenuName, undoMenuName</vh></v>
<v t="ekr.20060127070008"><vh>u.setIvarsFromBunch</vh></v>
<v t="ekr.20031218072017.3614"><vh>u.setRedoType</vh></v>
<v t="ekr.20091221145433.6381"><vh>u.setUndoType</vh></v>
<v t="ekr.20031218072017.3616"><vh>u.setUndoTypes</vh></v>
<v t="ekr.20050525151449"><vh>u.trace</vh></v>
<v t="ekr.20050410095424"><vh>u.updateMarks</vh></v>
</v>
<v t="ekr.20031218072017.3608"><vh>u.Externally visible entries</vh>
<v t="ekr.20050318085432.4"><vh>u.afterX...</vh>
<v t="ekr.20201109075104.1"><vh>u.afterChangeBody</vh></v>
<v t="ekr.20050315134017.4"><vh>u.afterChangeGroup</vh></v>
<v t="ekr.20050315134017.2"><vh>u.afterChangeNodeContents</vh></v>
<v t="ekr.20201107145642.1"><vh>u.afterChangeHeadline</vh></v>
<v t="felix.20230326225405.1"><vh>u.afterChangeMultiHeadline</vh></v>
<v t="ekr.20230721130238.1"><vh>u.afterChangeTree</vh></v>
<v t="ekr.20050424161505"><vh>u.afterClearRecentFiles</vh></v>
<v t="ekr.20111006060936.15639"><vh>u.afterCloneMarkedNodes</vh></v>
<v t="ekr.20160502175451.1"><vh>u.afterCopyMarkedNodes</vh></v>
<v t="ekr.20050411193627.5"><vh>u.afterCloneNode</vh></v>
<v t="ekr.20050411193627.8"><vh>u.afterDeleteNode</vh></v>
<v t="ekr.20111005152227.15555"><vh>u.afterDeleteMarkedNodes</vh></v>
<v t="ekr.20080425060424.8"><vh>u.afterDemote</vh></v>
<v t="ekr.20050411193627.9"><vh>u.afterInsertNode</vh></v>
<v t="ekr.20050526124257"><vh>u.afterMark</vh></v>
<v t="ekr.20050410110343"><vh>u.afterMoveNode</vh></v>
<v t="ekr.20230713151537.1"></v>
<v t="ekr.20080425060424.12"><vh>u.afterPromote</vh></v>
<v t="ekr.20080425060424.2"><vh>u.afterSort</vh></v>
</v>
<v t="ekr.20050318085432.3"><vh>u.beforeX...</vh>
<v t="ekr.20201109074740.1"><vh>u.beforeChangeBody</vh></v>
<v t="ekr.20050315134017.7"><vh>u.beforeChangeGroup</vh></v>
<v t="ekr.20201107145859.1"><vh>u.beforeChangeHeadline</vh></v>
<v t="felix.20230326230839.1"><vh>u.beforeChangeMultiHeadline</vh></v>
<v t="ekr.20050315133212.2"><vh>u.beforeChangeNodeContents</vh></v>
<v t="ekr.20230721130319.1"><vh>u.beforeChangeTree</vh></v>
<v t="ekr.20050424161505.1"><vh>u.beforeClearRecentFiles</vh></v>
<v t="ekr.20050412080354"><vh>u.beforeCloneNode</vh></v>
<v t="ekr.20050411193627.3"><vh>u.beforeDeleteNode</vh></v>
<v t="ekr.20050411193627.4"><vh>u.beforeInsertNode</vh></v>
<v t="ekr.20050526131252"><vh>u.beforeMark</vh></v>
<v t="ekr.20050410110215"><vh>u.beforeMoveNode</vh></v>
<v t="ekr.20230713145834.1"></v>
<v t="ekr.20080425060424.3"><vh>u.beforeSort</vh></v>
<v t="ekr.20050318085432.2"><vh>u.createCommonBunch</vh></v>
</v>
<v t="ekr.20031218072017.3610"><vh>u.canRedo &amp; canUndo</vh></v>
<v t="ekr.20230714012821.1"><vh>u.clearAndWarn</vh></v>
<v t="ekr.20031218072017.3609"><vh>u.clearUndoState</vh></v>
<v t="ekr.20031218072017.1490"><vh>u.doTyping &amp; helper</vh>
<v t="ekr.20040324061854"><vh>&lt;&lt; return if there is nothing to do &gt;&gt;</vh></v>
<v t="ekr.20040324061854.1"><vh>&lt;&lt; init the undo params &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1491"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1492"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
<v t="ekr.20040324061854.2"><vh>&lt;&lt; save the selection and scrolling position &gt;&gt;</vh></v>
<v t="ekr.20040324061854.3"><vh>&lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;</vh>
<v t="ekr.20050125220613"><vh>&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;</vh>
<v t="ekr.20050125203937"><vh>&lt;&lt; set newBead if the change does not continue a word &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050126081529"><vh>u.recognizeStartOfTypingWord</vh></v>
</v>
<v t="ekr.20031218072017.3611"><vh>u.enableMenuItems</vh></v>
<v t="ekr.20110519074734.6094"><vh>u.onSelect &amp; helpers</vh>
<v t="ekr.20110519074734.6096"><vh>u.putIvarsToVnode</vh></v>
<v t="ekr.20110519074734.6095"><vh>u.setIvarsFromVnode</vh></v>
</v>
<v t="ekr.20201127035748.1"></v>
<v t="ekr.20230722062645.1"><vh>u.restoreFromCopiedTree</vh>
<v t="ekr.20230722062838.1"><vh>&lt;&lt; docstring: restoreFromCopiedTree &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2030"><vh>u.redo</vh></v>
<v t="ekr.20110519074734.6092"><vh>u.redo helpers</vh>
<v t="ekr.20191213085226.1"><vh> u.reloadHelper (do nothing)</vh></v>
<v t="ekr.20201109080732.1"><vh>u.redoChangeBody</vh></v>
<v t="ekr.20201107150619.1"><vh>u.redoChangeHeadline</vh></v>
<v t="felix.20230326231408.1"><vh>u.redoChangeMultiHeadline</vh></v>
<v t="ekr.20230721131611.1"><vh>u.redoChangeTree (to do)</vh></v>
<v t="ekr.20050424170219"><vh>u.redoClearRecentFiles</vh></v>
<v t="ekr.20111005152227.15558"><vh>u.redoCloneMarkedNodes</vh></v>
<v t="ekr.20160502175557.1"><vh>u.redoCopyMarkedNodes</vh></v>
<v t="ekr.20050412083057"><vh>u.redoCloneNode</vh></v>
<v t="ekr.20111005152227.15559"><vh>u.redoDeleteMarkedNodes</vh></v>
<v t="EKR.20040526072519.2"><vh>u.redoDeleteNode</vh></v>
<v t="ekr.20080425060424.9"><vh>u.redoDemote</vh></v>
<v t="ekr.20050318085432.6"><vh>u.redoGroup</vh></v>
<v t="ekr.20050412085138.1"><vh>u.redoHoistNode &amp; redoDehoistNode</vh></v>
<v t="ekr.20050412084532"><vh>u.redoInsertNode</vh></v>
<v t="ekr.20050526125801"><vh>u.redoMark</vh></v>
<v t="ekr.20050411111847"><vh>u.redoMove</vh></v>
<v t="ekr.20050318085432.7"><vh>u.redoNodeContents</vh></v>
<v t="ekr.20230713150847.1"></v>
<v t="ekr.20080425060424.13"><vh>u.redoPromote</vh></v>
<v t="ekr.20080425060424.4"><vh>u.redoSort</vh></v>
<v t="EKR.20040526075238.5"><vh>u.redoTyping</vh></v>
</v>
<v t="ekr.20031218072017.2039"><vh>u.undo</vh></v>
<v t="ekr.20110519074734.6093"><vh>u.undo helpers</vh>
<v t="ekr.20191213085246.1"><vh> u.undoHelper</vh></v>
<v t="ekr.20201109080631.1"><vh>u.undoChangeBody</vh></v>
<v t="ekr.20201107150041.1"><vh>u.undoChangeHeadline</vh></v>
<v t="felix.20230326231543.1"><vh>u.undoChangeMultiHeadline</vh></v>
<v t="ekr.20050424170219.1"><vh>u.undoClearRecentFiles</vh></v>
<v t="ekr.20111005152227.15560"><vh>u.undoCloneMarkedNodes</vh></v>
<v t="ekr.20050412083057.1"><vh>u.undoCloneNode</vh></v>
<v t="ekr.20160502175653.1"><vh>u.undoCopyMarkedNodes</vh></v>
<v t="ekr.20111005152227.15557"><vh>u.undoDeleteMarkedNodes</vh></v>
<v t="ekr.20050412084055"><vh>u.undoDeleteNode</vh></v>
<v t="ekr.20080425060424.10"><vh>u.undoDemote</vh></v>
<v t="ekr.20050318085713"><vh>u.undoGroup</vh></v>
<v t="ekr.20050412083244"><vh>u.undoHoistNode &amp; undoDehoistNode</vh></v>
<v t="ekr.20050412085112"><vh>u.undoInsertNode</vh></v>
<v t="ekr.20050526124906"><vh>u.undoMark</vh></v>
<v t="ekr.20050411112033"><vh>u.undoMove</vh></v>
<v t="ekr.20050318085713.1"><vh>u.undoNodeContents</vh></v>
<v t="ekr.20230721131446.1"><vh>u.undoChangeTree</vh></v>
<v t="ekr.20230713150109.1"></v>
<v t="ekr.20080425060424.14"><vh>u.undoPromote</vh></v>
<v t="ekr.20031218072017.1493"><vh>u.undoRedoText</vh>
<v t="ekr.20061106105812.1"><vh>&lt;&lt; Compute the result using p's body text &gt;&gt;</vh></v>
</v>
<v t="ekr.20080425060424.5"><vh>u.undoSort</vh></v>
<v t="EKR.20040526090701.4"><vh>u.undoTyping</vh></v>
</v>
<v t="ekr.20191213092304.1"><vh>u.update_status</vh></v>
</v>
<v t="ekr.20230718093415.1"><vh>--- not changed</vh>
<v t="ekr.20091221145433.6381"></v>
</v>
<v t="ekr.20230718075224.1"><vh>--- changed</vh>
<v t="ekr.20230714012821.1"></v>
<v t="ekr.20031218072017.3609"></v>
<v t="ekr.20031218072017.3616"></v>
<v t="ekr.20031218072017.3613"></v>
<v t="ekr.20050318085432.3"></v>
</v>
</v>
<v t="ekr.20230718190545.1"><vh>=== PR #3449: (closed) paste-retaining-clones</vh></v>
<v t="ekr.20230721130054.1"><vh>=== PR #3454: (closed) tree undo</vh></v>
<v t="ekr.20230727042339.1"><vh>=== PR #3455: (unified) make checks faster</vh>
<v t="ekr.20031218072017.2072"><vh>c.checkOutline</vh></v>
<v t="ekr.20230723031540.1"><vh>c.checkVnodeLinks &amp; helpers</vh>
<v t="ekr.20230728005934.1"><vh>find_errors</vh></v>
<v t="ekr.20230728010156.1"><vh>fix_errors</vh></v>
<v t="ekr.20230728010753.1"><vh>undelete_nodes</vh></v>
<v t="ekr.20230728011151.1"><vh>recheck</vh></v>
</v>
</v>
</v>
<v t="ekr.20230722093357.1"><vh>=== #3447: show-file-line</vh>
<v t="ekr.20180517041303.1"><vh>show-file-line</vh></v>
</v>
<v t="ekr.20230726180501.1"><vh>=== #3463: node history</vh>
<v t="ekr.20230726182849.1"><vh>--- classes</vh>
<v t="ville.20090518182905.5425"></v>
<v t="ekr.20160514120255.1"><vh>class NodeHistory</vh>
<v t="ekr.20160426061203.1"><vh>NodeHistory.dump</vh></v>
<v t="ekr.20070615134813"><vh>NodeHistory.goNext</vh></v>
<v t="ekr.20130915111638.11288"><vh>NodeHistory.goPrev</vh></v>
<v t="ekr.20130915111638.11294"><vh>NodeHistory.select</vh></v>
<v t="ville.20090724234020.14676"><vh>NodeHistory.update</vh></v>
</v>
</v>
<v t="ekr.20230726185713.1"><vh>--- commands</vh>
<v t="ekr.20110402084740.14490"><vh>c_ec.goToNext/PrevHistory</vh></v>
<v t="ekr.20031218072017.1628"><vh>c_oc.goNextVisitedNode</vh></v>
<v t="ekr.20031218072017.1627"><vh>c_oc.goPrevVisitedNode</vh></v>
</v>
<v t="ekr.20230727073322.1"><vh>links</vh></v>
<v t="ekr.20230726191706.1"><vh>--- changed</vh>
<v t="ekr.20100216141722.5622"></v>
<v t="ekr.20160426061203.1"></v>
<v t="ekr.20130915111638.11294"></v>
<v t="ville.20090724234020.14676"></v>
</v>
</v>
</v>
<v t="ekr.20220306092217.1"></v>
<v t="ekr.20230727100619.1"><vh>--- checkVnodeLinks searches</vh>
<v t="ekr.20230727094921.1"><vh>cff: children.append</vh>
<v t="ekr.20230727095204.1"><vh>--- not v.children</vh>
<v t="edream.110203113231.674"><vh>&lt;&lt; process custom line &gt;&gt; (import_cisco_config.py)</vh></v>
<v t="edream.110203113231.675"><vh>&lt;&lt; process indented block &gt;&gt; (import_cisco_config.py)</vh></v>
<v t="ekr.20101110092416.5709"><vh>add_child</vh></v>
<v t="EKR.20040517080250.21"><vh>add_leo_links (mod_http.py)</vh></v>
<v t="ekr.20210316085413.2"><vh>fc.leojs_vnodes</vh></v>
<v t="ekr.20201012111338.28"><vh>LeoCloud._from_dict_recursive</vh></v>
<v t="ekr.20060917190349"><vh>startOutline (leoOpml)</vh>
<v t="ekr.20060904141220.34"><vh>doOutlineAttributes</vh></v>
</v>
<v t="ekr.20191113063144.3"></v>
</v>
<v t="ekr.20230727095339.1"><vh>--- symmetric change v.children</vh>
<v t="ekr.20060914171659.2"><vh>oc.createChildren</vh></v>
<v t="felix.20220618174639.1"><vh>scanJsonVnodes &amp; helper</vh></v>
<v t="ekr.20180605102822.1"><vh>&lt;&lt; define v_element_visitor &gt;&gt;</vh>
<v t="ekr.20180605075042.1"><vh>&lt;&lt; Make a new vnode, linked to the parent &gt;&gt;</vh></v>
<v t="ekr.20180605075113.1"><vh>&lt;&lt; handle all other v attributes &gt;&gt;</vh></v>
</v>
<v t="ekr.20180605075042.1"></v>
<v t="vitalije.20200529115539.1"><vh>do_paste (pasteAsTemplate)</vh></v>
</v>
<v t="ekr.20230727095448.1"><vh>--- assymetric change v.children</vh>
<v t="ekr.20160502100151.1"><vh>v.copyTree</vh></v>
<v t="ekr.20180602103135.19"><vh>&lt;&lt; handle node_start &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20230727094834.1"><vh>cff: .parents.append</vh>
<v t="ekr.20180602103135.19"></v>
<v t="ekr.20180605102822.1"></v>
<v t="ekr.20180605075042.1"></v>
<v t="felix.20220618174639.1"></v>
<v t="ekr.20180424123010.1"><vh>fc.linkChildrenToParents</vh></v>
<v t="ekr.20131219220412.16582"><vh>p._relinkAsCloneOf</vh></v>
<v t="ekr.20180123062833.1"><vh>p.promote</vh></v>
<v t="ekr.20180709175203.1"><vh>v._addCopiedLink</vh></v>
<v t="ekr.20090706110836.6135"><vh>v._addLink &amp; _addParentLinks</vh>
<v t="ekr.20090804184658.6129"><vh>v._addParentLinks</vh></v>
</v>
<v t="ekr.20090804184658.6129"></v>
<v t="ekr.20080425060424.9"></v>
<v t="ekr.20050411111847"></v>
<v t="ekr.20080425060424.13"></v>
<v t="ekr.20080425060424.10"></v>
<v t="ekr.20050411112033"></v>
<v t="ekr.20080425060424.14"></v>
<v t="vitalije.20200529120537.1"><vh>redoHelper</vh></v>
<v t="ekr.20031218072017.1767"><vh>c_oc.demote</vh></v>
<v t="ekr.20060914171659.2"></v>
</v>
</v>
<v t="ekr.20230727061724.1"><vh>--- tests</vh>
<v t="ekr.20230727044355.1"><vh>TestCommands.test_c_check_links</vh></v>
<v t="ekr.20210906075242.6"><vh>TestCommands.test_c_demote_illegal_clone_demote</vh></v>
<v t="ekr.20210830095545.52"><vh>TestNodes.test_paste_retaining_clones</vh></v>
<v t="ekr.20230722104508.1"><vh>TestOutlineCommands.test_paste_retaining_clones</vh>
<v t="ekr.20230723160812.1"><vh>function: test_tree (test_paste_retaining_clones)</vh></v>
</v>
</v>
<v t="ekr.20230727053247.1"><vh>--- new/changed</vh>
<v t="ekr.20220820051212.1"><vh>&lt;&lt; leoCommands annotations &gt;&gt;</vh></v>
<v t="ekr.20150318131947.7"><vh>c.checkLinks &amp; helpers</vh>
<v t="ekr.20040314035615.2"><vh>c.checkParentAndChildren</vh></v>
<v t="ekr.20040314035615.1"><vh>c.checkSiblings</vh></v>
<v t="ekr.20040314035615"><vh>c.checkThreadLinks</vh></v>
<v t="ekr.20230723031540.1"></v>
</v>
<v t="ekr.20031218072017.2072"></v>
<v t="ekr.20230723031540.1"></v>
<v t="ekr.20031218072017.1765"><vh>c.validateOutline (compatibility only)</vh></v>
<v t="ekr.20031218072017.1762"><vh>c_oc.clone</vh></v>
<v t="ekr.20150630152607.1"><vh>c_oc.cloneToAtSpot</vh></v>
<v t="ekr.20040303175026.13"><vh>p.validateOutlineWithParent (compatibility only)</vh></v>
</v>
<v t="ekr.20031218072017.2072"></v>
<v t="ekr.20230723031540.1"></v>
<v t="ekr.20230728060514.1"><vh>json archive</vh></v>
<v t="ekr.20230726013411.1"><vh>--- archiving data</vh>
<v t="ekr.20230726065751.1"><vh>--- archive ref</vh>
<v t="ekr.20080416161551.190"><vh> p.__init__</vh></v>
<v t="ekr.20060904165452.1"><vh>&lt;&lt; leoNodes imports &amp; annotations &gt;&gt;</vh></v>
<v t="ekr.20031218072017.889"><vh>class Position</vh>
<v t="ekr.20031218072017.890"><vh>&lt;&lt; about the position class &gt;&gt;</vh></v>
<v t="ekr.20040228094013"><vh> p.ctor &amp; other special methods...</vh>
<v t="ekr.20080920052058.3"><vh>p.__eq__ &amp; __ne__</vh></v>
<v t="ekr.20080416161551.190"></v>
<v t="ekr.20091210082012.6230"><vh>p.__ge__ &amp; __le__&amp; __lt__</vh></v>
<v t="ekr.20091210082012.6233"><vh>p.__gt__</vh></v>
<v t="ekr.20040117173448"><vh>p.__nonzero__ &amp; __bool__</vh></v>
<v t="ekr.20040301205720"><vh>p.__str__ and p.__repr__</vh></v>
<v t="ekr.20230726063237.1"><vh>p.archive</vh></v>
<v t="ekr.20061006092649"><vh>p.archivedPosition</vh></v>
<v t="ekr.20040310153624"><vh>p.dump</vh></v>
<v t="ekr.20080416161551.191"><vh>p.key &amp; p.sort_key &amp; __hash__</vh></v>
</v>
<v t="ekr.20040315023430"><vh>p.File Conversion</vh>
<v t="ekr.20040315023430.1"><vh>p.convertTreeToString</vh></v>
<v t="ekr.20040315023430.2"><vh>p.moreHead</vh></v>
<v t="ekr.20040315023430.3"><vh>p.moreBody</vh></v>
</v>
<v t="ekr.20091001141621.6060"><vh>p.generators</vh>
<v t="ekr.20091001141621.6055"><vh>p.children</vh></v>
<v t="ekr.20091002083910.6102"><vh>p.following_siblings</vh></v>
<v t="ekr.20161120105707.1"><vh>p.nearest_roots</vh></v>
<v t="ekr.20161120163203.1"><vh>p.nearest_unique_roots (aka p.nearest)</vh></v>
<v t="ekr.20091002083910.6104"><vh>p.nodes</vh></v>
<v t="ekr.20091001141621.6058"><vh>p.parents</vh></v>
<v t="ekr.20091002083910.6099"><vh>p.self_and_parents</vh></v>
<v t="ekr.20091001141621.6057"><vh>p.self_and_siblings</vh></v>
<v t="ekr.20091001141621.6066"><vh>p.self_and_subtree</vh></v>
<v t="ekr.20091001141621.6056"><vh>p.subtree</vh></v>
<v t="ekr.20091002083910.6105"><vh>p.unique_nodes</vh></v>
<v t="ekr.20091002083910.6103"><vh>p.unique_subtree</vh></v>
</v>
<v t="ekr.20040306212636"><vh>p.Getters</vh>
<v t="ekr.20040306210951"><vh>p.VNode proxies</vh>
<v t="ekr.20040306211032"><vh>p.Comparisons</vh></v>
<v t="ekr.20040306220230"><vh>p.Headline &amp; body strings</vh></v>
<v t="ekr.20040306214401"><vh>p.Status bits</vh></v>
</v>
<v t="ekr.20040306214240.2"><vh>p.children &amp; parents</vh>
<v t="ekr.20040326064330"><vh>p.childIndex</vh></v>
<v t="ekr.20040323160302"><vh>p.directParents</vh></v>
<v t="ekr.20040306214240.3"><vh>p.hasChildren &amp; p.numberOfChildren</vh></v>
</v>
<v t="ekr.20031218072017.915"><vh>p.getX &amp; VNode compatibility traversal routines</vh></v>
<v t="ekr.20230628173526.1"></v>
<v t="ekr.20080416161551.192"><vh>p.hasBack/Next/Parent/ThreadBack</vh>
<v t="ekr.20080416161551.193"><vh>p.hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="ekr.20060920203352"><vh>p.findRootPosition</vh></v>
<v t="ekr.20080416161551.194"><vh>p.isAncestorOf</vh></v>
<v t="ekr.20040306215056"><vh>p.isCloned</vh></v>
<v t="ekr.20040307104131.2"><vh>p.isRoot</vh></v>
<v t="ekr.20080416161551.196"><vh>p.isVisible</vh></v>
<v t="ekr.20080416161551.197"><vh>p.level &amp; simpleLevel</vh></v>
<v t="ekr.20111005152227.15566"><vh>p.positionAfterDeletedTree</vh></v>
<v t="shadow.20080825171547.2"><vh>p.textOffset</vh></v>
</v>
<v t="ekr.20080423062035.1"><vh>p.Low level methods</vh>
<v t="ekr.20080427062528.4"><vh>p._adjustPositionBeforeUnlink</vh></v>
<v t="ekr.20080416161551.214"><vh>p._linkAfter</vh></v>
<v t="ekr.20180709181718.1"><vh>p._linkCopiedAfter</vh></v>
<v t="ekr.20080416161551.215"><vh>p._linkAsNthChild</vh></v>
<v t="ekr.20180709180140.1"><vh>p._linkCopiedAsNthChild</vh></v>
<v t="ekr.20080416161551.216"><vh>p._linkAsRoot</vh></v>
<v t="ekr.20080416161551.212"><vh>p._parentVnode</vh></v>
<v t="ekr.20131219220412.16582"></v>
<v t="ekr.20080416161551.217"><vh>p._unlink</vh>
<v t="ekr.20090706171333.6226"><vh>p.badUnlink</vh></v>
</v>
</v>
<v t="ekr.20080416161551.199"><vh>p.moveToX</vh>
<v t="ekr.20080416161551.200"><vh>p.moveToBack</vh></v>
<v t="ekr.20080416161551.201"><vh>p.moveToFirstChild</vh></v>
<v t="ekr.20080416161551.202"><vh>p.moveToLastChild</vh></v>
<v t="ekr.20080416161551.203"><vh>p.moveToLastNode</vh></v>
<v t="ekr.20080416161551.204"><vh>p.moveToNext</vh></v>
<v t="ekr.20080416161551.205"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20080416161551.206"><vh>p.moveToNthChild</vh></v>
<v t="ekr.20080416161551.207"><vh>p.moveToParent</vh></v>
<v t="ekr.20080416161551.208"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20080416161551.209"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20080416161551.210"><vh>p.moveToVisBack &amp; helper</vh>
<v t="ekr.20090715145956.6166"><vh>checkVisBackLimit</vh></v>
</v>
<v t="ekr.20080416161551.211"><vh>p.moveToVisNext &amp; helper</vh>
<v t="ekr.20090715145956.6167"><vh>checkVisNextLimit</vh></v>
</v>
</v>
<v t="ekr.20040303175026"><vh>p.Moving, Inserting, Deleting, Cloning, Sorting</vh>
<v t="ekr.20040303175026.8"><vh>p.clone</vh></v>
<v t="ekr.20040117171654"><vh>p.copy</vh></v>
<v t="ekr.20040303175026.9"><vh>p.copyTreeAfter, copyTreeTo</vh></v>
<v t="ekr.20160502095354.1"><vh>p.copyWithNewVnodes</vh></v>
<v t="peckj.20131023115434.10115"><vh>p.createNodeHierarchy</vh></v>
<v t="ekr.20131230090121.16552"><vh>p.deleteAllChildren</vh></v>
<v t="ekr.20040303175026.2"><vh>p.doDelete</vh></v>
<v t="ekr.20040303175026.3"><vh>p.insertAfter</vh></v>
<v t="ekr.20040303175026.4"><vh>p.insertAsLastChild</vh></v>
<v t="ekr.20040303175026.5"><vh>p.insertAsNthChild</vh></v>
<v t="ekr.20130923111858.11572"><vh>p.insertBefore</vh></v>
<v t="ekr.20040310062332.1"><vh>p.invalidOutline</vh></v>
<v t="ekr.20040303175026.10"><vh>p.moveAfter</vh></v>
<v t="ekr.20040306060312"><vh>p.moveToFirst/LastChildOf</vh></v>
<v t="ekr.20040303175026.11"><vh>p.moveToNthChildOf</vh></v>
<v t="ekr.20040303175026.6"><vh>p.moveToRoot</vh></v>
<v t="ekr.20180123062833.1"></v>
<v t="ekr.20040303175026.13"></v>
</v>
<v t="ekr.20090128083459.74"><vh>p.Properties</vh>
<v t="ekr.20090128083459.75"><vh>p.b property</vh></v>
<v t="ekr.20090128083459.76"><vh>p.h property</vh></v>
<v t="ekr.20090215165030.3"><vh>p.gnx property</vh></v>
<v t="ekr.20140203082618.15486"><vh>p.script property</vh></v>
<v t="ekr.20140218040104.16761"><vh>p.nosentinels property</vh></v>
<v t="ekr.20160129073222.1"><vh>p.u Property</vh></v>
</v>
<v t="ekr.20040305222924"><vh>p.Setters</vh>
<v t="ekr.20040306220634"><vh>p.VNode proxies</vh>
<v t="ekr.20131222112420.16371"><vh>p.contract/expand/isExpanded</vh></v>
<v t="ekr.20040306220634.9"><vh>p.Status bits</vh></v>
<v t="ekr.20040306220634.8"><vh>p.computeIcon &amp; p.setIcon</vh></v>
<v t="ekr.20040306220634.29"><vh>p.setSelection</vh></v>
<v t="ekr.20100303074003.5637"><vh>p.restore/saveCursorAndScroll</vh></v>
</v>
<v t="ekr.20040315034158"><vh>p.setBodyString &amp; setHeadString</vh></v>
<v t="ekr.20040312015908"><vh>p.Visited bits</vh>
<v t="ekr.20040306220634.17"><vh>p.clearVisitedInTree</vh></v>
<v t="ekr.20031218072017.3388"><vh>p.clearAllVisitedInTree</vh></v>
</v>
<v t="ekr.20040305162628"><vh>p.Dirty bits</vh>
<v t="ekr.20040311113514"><vh>p.clearDirty</vh></v>
<v t="ekr.20040702104823"><vh>p.inAtIgnoreRange</vh></v>
<v t="ekr.20040303214038"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20040303163330"><vh>p.setDirty</vh></v>
</v>
</v>
<v t="ekr.20160225153333.1"><vh>p.Predicates</vh>
<v t="ekr.20160225153414.1"><vh>p.is_at_all &amp; is_at_all_tree</vh></v>
<v t="ekr.20160225153430.1"><vh>p.is_at_ignore &amp; in_at_ignore_tree</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3341"><vh>class VNode</vh>
<v t="ekr.20031218072017.951"><vh>&lt;&lt; VNode constants &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3342"><vh>v.Birth &amp; death</vh>
<v t="ekr.20031218072017.3344"><vh>v.__init__</vh></v>
<v t="ekr.20031218072017.3345"><vh>v.__repr__ &amp; v.__str__</vh></v>
<v t="ekr.20040312145256"><vh>v.dump</vh></v>
<v t="ekr.20230728062638.1"><vh>v.archive_uas</vh></v>
</v>
<v t="ekr.20031218072017.3346"><vh>v.Comparisons</vh>
<v t="ekr.20040705201018"><vh>v.findAtFileName</vh></v>
<v t="ekr.20031218072017.3350"></v>
<v t="ekr.20031218072017.3348"><vh>v.at...FileNodeName</vh></v>
<v t="EKR.20040430152000"><vh>v.isAtAllNode</vh></v>
<v t="ekr.20040326031436"><vh>v.isAnyAtFileNode</vh></v>
<v t="ekr.20040325073709"><vh>v.isAt...FileNode</vh></v>
<v t="ekr.20031218072017.3351"><vh>v.isAtIgnoreNode</vh></v>
<v t="ekr.20031218072017.3352"><vh>v.isAtOthersNode</vh></v>
<v t="ekr.20031218072017.3353"><vh>v.matchHeadline</vh></v>
</v>
<v t="ekr.20160502100151.1"></v>
<v t="ekr.20031218072017.3359"><vh>v.Getters</vh>
<v t="ekr.20031218072017.3378"><vh>v.bodyString</vh></v>
<v t="ekr.20031218072017.3360"><vh>v.Children</vh>
<v t="ekr.20031218072017.3362"><vh>v.firstChild</vh></v>
<v t="ekr.20040307085922"><vh>v.hasChildren &amp; hasFirstChild</vh></v>
<v t="ekr.20031218072017.3364"><vh>v.lastChild</vh></v>
<v t="ekr.20031218072017.3365"><vh>v.nthChild</vh></v>
<v t="ekr.20031218072017.3366"><vh>v.numberOfChildren</vh></v>
</v>
<v t="ekr.20040323100443"><vh>v.directParents</vh></v>
<v t="ekr.20080429053831.6"><vh>v.hasBody</vh></v>
<v t="ekr.20031218072017.1581"><vh>v.headString</vh></v>
<v t="ekr.20131223064351.16351"><vh>v.isNthChildOf</vh></v>
<v t="ekr.20031218072017.3367"><vh>v.Status Bits</vh>
<v t="ekr.20031218072017.3368"><vh>v.isCloned</vh></v>
<v t="ekr.20031218072017.3369"><vh>v.isDirty</vh></v>
<v t="ekr.20031218072017.3371"><vh>v.isMarked</vh></v>
<v t="ekr.20031218072017.3372"><vh>v.isOrphan</vh></v>
<v t="ekr.20031218072017.3373"><vh>v.isSelected</vh></v>
<v t="ekr.20031218072017.3376"><vh>v.isVisited</vh></v>
<v t="ekr.20080429053831.10"><vh>v.isWriteBit</vh></v>
<v t="ekr.20031218072017.3377"><vh>v.status</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3384"><vh>v.Setters</vh>
<v t="ekr.20031218072017.3386"><vh> v.Status bits</vh>
<v t="ekr.20031218072017.3390"><vh>v.clearDirty</vh></v>
<v t="ekr.20031218072017.3391"><vh>v.clearMarked</vh></v>
<v t="ekr.20031218072017.3392"><vh>v.clearOrphan</vh></v>
<v t="ekr.20031218072017.3393"><vh>v.clearVisited</vh></v>
<v t="ekr.20080429053831.8"><vh>v.clearWriteBit</vh></v>
<v t="ekr.20031218072017.3395"><vh>v.contract/expand/initExpandedBit/isExpanded</vh></v>
<v t="ekr.20031218072017.3396"><vh>v.initStatus</vh></v>
<v t="ekr.20080429053831.12"><vh>v.setDirty</vh></v>
<v t="ekr.20031218072017.3398"><vh>v.setMarked &amp; initMarkedBit</vh></v>
<v t="ekr.20031218072017.3399"><vh>v.setOrphan</vh></v>
<v t="ekr.20031218072017.3400"><vh>v.setSelected</vh></v>
<v t="ekr.20031218072017.3401"><vh>v.setVisited</vh></v>
<v t="ekr.20080429053831.9"><vh>v.setWriteBit</vh></v>
</v>
<v t="ville.20120502221057.7499"><vh>v.childrenModified</vh></v>
<v t="ekr.20031218072017.3385"><vh>v.computeIcon &amp; setIcon</vh></v>
<v t="ekr.20220905044353.1"><vh>v.updateIcon</vh></v>
<v t="ville.20120502221057.7498"><vh>v.contentModified</vh></v>
<v t="ekr.20100303074003.5636"><vh>v.restoreCursorAndScroll</vh></v>
<v t="ekr.20100303074003.5638"><vh>v.saveCursorAndScroll</vh></v>
<v t="ekr.20191213161023.1"><vh>v.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20040315032144"><vh>v.setBodyString &amp; v.setHeadString</vh></v>
<v t="ekr.20031218072017.3402"><vh>v.setSelection</vh></v>
</v>
<v t="ekr.20130524063409.10700"><vh>v.Inserting &amp; cloning</vh></v>
<v t="ekr.20080427062528.9"><vh>v.Low level methods</vh>
<v t="ekr.20180709175203.1"></v>
<v t="ekr.20090706110836.6135"></v>
<v t="ekr.20090804184658.6128"><vh>v._cutLink &amp; _cutParentLinks</vh>
<v t="ekr.20090804190529.6133"><vh>v._cutParentLinks</vh></v>
</v>
<v t="ekr.20180709064515.1"><vh>v._deleteAllChildren</vh></v>
<v t="ekr.20031218072017.3425"><vh>v._linkAsNthChild</vh></v>
</v>
<v t="ekr.20090130065000.1"><vh>v.Properties</vh>
<v t="ekr.20090130114732.5"><vh>v.b Property</vh></v>
<v t="ekr.20090130125002.1"><vh>v.h property</vh></v>
<v t="ekr.20090130114732.6"><vh>v.u Property</vh></v>
<v t="ekr.20090215165030.1"><vh>v.gnx Property</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3344"></v>
<v t="ekr.20031218072017.1573"><vh>fc.outline_to_clipboard_string</vh></v>
</v>
<v t="ekr.20230725084746.1"><vh>functions: save/restore_data (never used)</vh></v>
<v t="ekr.20230725111522.1"><vh>TestOutlineCommands.test_p_v_archive</vh></v>
<v t="ekr.20160304054950.1"><vh>c.setCloneFindByPredicateIcon</vh></v>
<v t="ekr.20230726063237.1"></v>
<v t="ekr.20180602062323.7"><vh>fast.readWithElementTree &amp; helpers</vh>
<v t="ekr.20180624125321.1"><vh>fast.handleBits (reads c.db)</vh></v>
<v t="ekr.20180606041211.1"><vh>fast.resolveUa</vh></v>
<v t="ekr.20180605062300.1"><vh>fast.scanGlobals &amp; helper</vh>
<v t="ekr.20180708060437.1"><vh>fast.getGlobalData</vh></v>
</v>
<v t="ekr.20180602062323.8"><vh>fast.scanTnodes</vh></v>
<v t="ekr.20180602062323.9"><vh>fast.scanVnodes &amp; helper</vh>
<v t="ekr.20180605102822.1"></v>
</v>
<v t="ekr.20230724092804.1"><vh>fast.updateBodies</vh></v>
</v>
</v>
<v t="ekr.20230726014624.1"><vh>--- Delgated to felix: undo/redo paste-retaining-clones</vh>
<v t="ekr.20031218072017.1573"></v>
<v t="EKR.20040610130943"></v>
<v t="ekr.20031218072017.3605"></v>
<v t="ekr.20050412084532"></v>
<v t="ekr.20050412085112"></v>
</v>
<v t="ekr.20230722101720.1"><vh>=== PR #3455: unified PR</vh>
<v t="ekr.20230722192350.1"><vh>--- no longer used</vh>
<v t="ekr.20150316175921.5"><vh>c.safe_all_positions</vh></v>
<v t="ekr.20150316175921.6"><vh>p.safeMoveToThreadNext</vh>
<v t="ekr.20150316175921.7"><vh>p.checkChild</vh></v>
</v>
</v>
<v t="ekr.20230726182331.1"><vh>------ most recent</vh>
<v t="ekr.20230723123619.1"><vh>--- commands</vh>
<v t="ekr.20031218072017.1550"><vh>c_oc.copyOutline</vh></v>
<v t="ekr.20031218072017.1549"><vh>c_oc.cutOutline</vh></v>
<v t="ekr.20171124081846.1"><vh>c_oc.fullCheckOutline</vh></v>
<v t="vitalije.20200529105105.1"><vh>c_oc.pasteAsTemplate</vh>
<v t="vitalije.20200529112224.1"><vh>skip_root</vh></v>
<v t="vitalije.20200529112459.1"><vh>translate_gnx</vh></v>
<v t="vitalije.20200529115141.1"><vh>viter</vh></v>
<v t="vitalije.20200529114857.1"><vh>getv</vh></v>
<v t="vitalije.20200529115539.1"></v>
<v t="vitalije.20200529120440.1"><vh>undoHelper</vh></v>
<v t="vitalije.20200529120537.1"></v>
<v t="vitalije.20200529111500.1"><vh>&lt;&lt; prepare destination data &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1551"></v>
<v t="EKR.20040610130943"></v>
</v>
<v t="ekr.20230722104048.1"><vh>--- tests &amp; testing</vh>
<v t="ekr.20230724174102.1"></v>
<v t="ekr.20230720210931.1"></v>
<v t="ekr.20220805071838.1"></v>
<v t="ekr.20230701103509.1"></v>
<v t="ekr.20230724130924.1"><vh>TestOutlineCommands.test_paste_as_template</vh>
<v t="ekr.20230724130959.5"><vh>function: test_tree (test_paste_as_template)</vh></v>
</v>
<v t="ekr.20230724064558.1"><vh>TestOutlineCommands.test_paste_node</vh>
<v t="ekr.20230724064558.5"><vh>function: test_tree (test_paste_node)</vh></v>
</v>
<v t="ekr.20230722104508.1"></v>
</v>
<v t="ekr.20230722194025.1"><vh>--- changed &amp; new</vh>
<v t="ekr.20230726105058.1"><vh>changed commands</vh>
<v t="vitalije.20200529105105.1"></v>
<v t="EKR.20040610130943"></v>
</v>
<v t="ekr.20230726104947.1"><vh>changed c methods</vh>
<v t="ekr.20091001141621.6044"><vh>c.all_positions</vh></v>
<v t="ekr.20141024211256.22"><vh>c.checkGnxs</vh></v>
<v t="ekr.20150318131947.7"></v>
<v t="ekr.20031218072017.2072"></v>
<v t="ekr.20040803140033.1"><vh>c.setCurrentPosition</vh></v>
</v>
<v t="ekr.20230726105021.1"><vh>changed FastRead methods</vh>
<v t="ekr.20180602062323.7"></v>
<v t="felix.20220618165345.1"><vh>fast.readWithJsonTree &amp; helpers</vh>
<v t="felix.20220618181309.1"><vh>fast.scanJsonGlobals</vh></v>
<v t="felix.20220618174623.1"><vh>fast.scanJsonTnodes</vh></v>
<v t="felix.20220618174639.1"></v>
</v>
<v t="ekr.20230724092804.1"></v>
</v>
<v t="ekr.20230726105038.1"><vh>changed FileCommands methods</vh>
<v t="ekr.20080410115129.1"><vh>fc.checkPaste</vh></v>
<v t="ekr.20180709205603.1"></v>
<v t="ekr.20180709205640.1"></v>
<v t="ekr.20180424123010.1"></v>
</v>
<v t="ekr.20230726105303.1"><vh>changed git methods</vh>
<v t="ekr.20170806094320.15"></v>
</v>
<v t="ekr.20230726105114.1"><vh>changed/new test helpers</vh>
<v t="ekr.20230724141139.1"><vh>TestOutlineCommands.copy_node</vh></v>
<v t="ekr.20230724140451.1"><vh>TestOutlineCommands.create_test_paste_outline</vh></v>
</v>
<v t="ekr.20230726105140.1"><vh>changed VNode methods</vh>
<v t="ekr.20031218072017.3345"></v>
<v t="ekr.20040312145256"></v>
</v>
</v>
<v t="ekr.20230726091431.1"><vh>--- fc.outline_to_clipboard_string &amp; helpers</vh>
<v t="ekr.20031218072017.1573"></v>
<v t="ekr.20031218072017.1579"><vh>fc.put_v_elements &amp; helper</vh>
<v t="ekr.20190328160622.1"><vh>fc.setCachedBits</vh></v>
</v>
<v t="ekr.20031218072017.1863"><vh>fc.put_v_element &amp; helper</vh>
<v t="ekr.20031218072017.1865"><vh>fc.compute_attribute_bits</vh></v>
</v>
<v t="ekr.20031218072017.1865"></v>
<v t="ekr.20080805071954.2"><vh>fc.putDescendentVnodeUas &amp; helper</vh>
<v t="ekr.20080805085257.1"><vh>fc.createUaList</vh></v>
</v>
<v t="ekr.20080805085257.2"><vh>fc.pickle</vh></v>
</v>
<v t="ekr.20230726014755.1"><vh>--- recent test</vh></v>
<v t="ekr.20230726180323.1"><vh>--- Links</vh></v>
</v>
</v>
<v t="ekr.20230723044517.1"><vh>--- new undoer methods (in unified PR)</vh>
<v t="ekr.20031218072017.3606"></v>
<v t="ekr.20230721131446.1"></v>
</v>
<v t="ekr.20031218072017.3605"></v>
<v t="ekr.20230728081210.1"><vh>--- removed methods</vh>
<v t="ekr.20230722083123.1"><vh>TestOutlineCommands.test_restoreFromCopiedTree</vh>
<v t="ekr.20230724210028.1"><vh>function: test_tree (test_restoreFromCopiedTree)</vh></v>
</v>
<v t="ekr.20230722062645.1"></v>
<v t="ekr.20230721131611.1"></v>
<v t="ekr.20230721130319.1"></v>
<v t="ekr.20230721130238.1"></v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430152000">def isAtAllNode(self) -&gt; bool:
    """Returns True if the receiver contains @others in its body at the start of a line."""
    flag, i = g.is_special(self._bodyString, "@all")
    return flag
</t>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040517075715"></t>
<t tx="EKR.20040517075715.13"></t>
<t tx="EKR.20040517075715.20">[Main]
use_styles = Yes
use_section_numbers = Yes
use_current_document = Yes
max_headings = 6
header_style = Heading
</t>
<t tx="EKR.20040517080250.21">def add_leo_links(self, window, node, f):
    """
    Given a node 'node', add links to:
        The next sibling, if any.
        the next node.
        the parent.
        The children, if any.
    """
    # Collecting the navigational links.
    if node:
        nodename = node.h
        threadNext = node.threadNext()
        sibling = node.next()
        parent = node.parent()
        f.write("&lt;p&gt;\n")
        children = []
        firstChild = node.firstChild()
        if firstChild:
            child = firstChild
            while child:
                children.append(child)
                child = child.next()
        if threadNext is not None:
            self.create_leo_reference(window, threadNext, "next", f)
        f.write("&lt;br /&gt;")
        if sibling is not None:
            self.create_leo_reference(window, sibling, "next Sibling", f)
        f.write("&lt;br /&gt;")
        if parent is None:
            self.create_href("/", "Top level", f)
        else:
            self.create_leo_reference(window, parent, "Up", f)
        f.write("&lt;br /&gt;")
        f.write("\n&lt;/p&gt;\n")
    else:
        # top level
        child = window.c.rootPosition()
        children = [child]
        next = child.next()
        while next:
            child = next
            children.append(child)
            next = child.next()
        nodename = window.shortFileName()
    if children:
        f.write("\n&lt;h2&gt;")
        f.write("Children of ")
        f.write(escape(nodename))
        f.write("&lt;/h2&gt;\n")
        f.write("&lt;ol&gt;\n")
        for child in children:
            f.write("&lt;li&gt;\n")
            self.create_leo_reference(window, child, child.h, f)
            f.write("&lt;/li&gt;\n")
        f.write("&lt;/ol&gt;\n")
</t>
<t tx="EKR.20040517090508">@nocolor-node

Enable plugins by creating@enabled-plugins nodes in leoSettings files,
typically myLeoSettings.leo.See the node

Users Guide-- &gt; Chapter 8: Customizing Leo-- &gt;@rst
html\customizing.html-- &gt; Specifying settings-- &gt; Complex settings nodes

in LeoDocs.leo for full details.

**Important**: Leo no longer uses pluginsManager.txt to enable or disable plugins.
</t>
<t tx="EKR.20040526072519.2">def redoDeleteNode(self) -&gt; None:
    c, u = self.c, self
    c.selectPosition(u.p)
    c.deleteOutline()
    c.selectPosition(u.newP)
</t>
<t tx="EKR.20040526075238.5">def redoTyping(self) -&gt; None:
    c, u = self.c, self
    current = c.p
    w = c.frame.body.wrapper
    # selectPosition causes recoloring, so avoid if possible.
    if current != u.p:
        c.selectPosition(u.p)
    u.p.setDirty()
    self.undoRedoText(
        u.p, u.leading, u.trailing,
        u.newMiddleLines, u.oldMiddleLines,
        u.newNewlines, u.oldNewlines,
        tag="redo", undoType=u.undoType)
    u.updateMarks('new')
    if u.newSel:
        c.bodyWantsFocus()
        i, j = u.newSel
        w.setSelectionRange(i, j, insert=j)
    if u.yview:
        c.bodyWantsFocus()
        w.setYScrollPosition(u.yview)
</t>
<t tx="EKR.20040526090701.4">def undoTyping(self) -&gt; None:
    c, u = self.c, self
    w = c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:
        c.selectPosition(u.p)
    u.p.setDirty()
    u.undoRedoText(
        u.p, u.leading, u.trailing,
        u.oldMiddleLines, u.newMiddleLines,
        u.oldNewlines, u.newNewlines,
        tag="undo", undoType=u.undoType)
    u.updateMarks('old')
    if u.oldSel:
        c.bodyWantsFocus()
        i, j = u.oldSel
        w.setSelectionRange(i, j, insert=j)
    if u.yview:
        c.bodyWantsFocus()
        w.setYScrollPosition(u.yview)
</t>
<t tx="EKR.20040526150818">def getBead(self, n: int) -&gt; g.Bunch:
    """Set Undoer ivars from the bunch at the top of the undo stack."""
    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return None  # pragma: no cover
    bunch = u.beads[n]
    self.setIvarsFromBunch(bunch)
    if 'undo' in g.app.debug:  # pragma: no cover
        print(f" u.getBead: {n:3} of {len(u.beads)}")
    return bunch
</t>
<t tx="EKR.20040526150818.1">def peekBead(self, n: int) -&gt; g.Bunch:

    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return None
    return u.beads[n]
</t>
<t tx="EKR.20040528075307">def saveTree(self, p: Position, treeInfo: List[g.Bunch] = None) -&gt; List[g.Bunch]:
    """Return a list of tuples with all info needed to handle a general undo operation."""
    # WARNING: read this before doing anything "clever"
    &lt;&lt; about u.saveTree &gt;&gt;
    u = self
    topLevel = (treeInfo is None)
    if topLevel:
        treeInfo = []
    # Add info for p.v.  Duplicate info is harmless.
    data = u.createVnodeUndoInfo(p.v)
    treeInfo.append(data)
    # Recursively add info for the subtree.
    child = p.firstChild()
    while child:
        self.saveTree(child, treeInfo)
        child = child.next()
    return treeInfo
</t>
<t tx="EKR.20040530114124">@language rest
@
The old code made a free-standing copy of the tree using v.copy and
t.copy. This looks "elegant" and is WRONG. The problem is that it can
not handle clones properly, especially when some clones were in the
"undo" tree and some were not. Moreover, it required complex
adjustments to t.vnodeLists.

Instead of creating new nodes, the new code creates all information needed
to properly restore the vnodes. It creates a list of tuples, on tuple for
each VNode in the tree. Each tuple has the form (v, vnodeInfo), where
vnodeInfo is a dict containing all info needed to recreate the nodes. The
v.createUndoInfoDict method corresponds to the old v.copy method.

Aside: Prior to 4.2 Leo used a scheme that was equivalent to the
createUndoInfoDict info, but quite a bit uglier.
</t>
<t tx="EKR.20040530121329">def restoreTree(self, treeInfo: List[g.Bunch]) -&gt; None:
    """Use the tree info to restore all VNode data, including all links."""
    u = self
    # This effectively relinks all vnodes.
    for vInfo in treeInfo:
        u.restoreVnodeUndoInfo(vInfo)
</t>
<t tx="EKR.20040610130943">@g.commander_command('paste-retaining-clones')
def pasteOutlineRetainingClones(
    self: Cmdr, event: Event = None, s: str = None,
) -&gt; Optional[Position]:
    """
    Paste an outline into the present outline from the clipboard.
    Nodes *retain* their original identify.
    """
    c = self
    if s is None:
        s = g.app.gui.getTextFromClipboard()
    c.endEditing()
    if not s or not c.canPasteOutline(s):
        return None  # This should never happen.
    # Get *position* to be pasted.
    pasted = c.fileCommands.getLeoOutlineFromClipboardRetainingClones(s)
    if not pasted:
        # Leo no longer supports MORE outlines. Use import-MORE-files instead.
        return None
    # Validate.
    c.checkOutline()
    errors = c.checkOutline()
    if errors &gt; 0:
        return None
    # Handle the "before" data for undo.
    if True:  ### undoFlag:
        vnodeInfoDict = computeVnodeInfoDict(c)
        undoData = c.undoer.beforeInsertNode(c.p,
            pasteAsClone=True,
            copiedBunchList=computeCopiedBunchList(c, pasted, vnodeInfoDict),
        )
    # Paste the node into the outline.
    c.selectPosition(pasted)
    pasted.setDirty()
    c.setChanged()
    back = pasted.back()
    if back and back.hasChildren() and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
        pasted.setDirty()
    # Set dirty bits for ancestors of *all* pasted nodes.
    for p in pasted.self_and_subtree():
        p.setAllAncestorAtFileNodesDirty()
    # Finish the command.
    if True:  ### undoFlag:
        c.undoer.afterInsertNode(pasted, 'Paste As Clone', undoData)
    c.redraw(pasted)
    c.recolor()
    return pasted
</t>
<t tx="edream.110203113231.667"></t>
<t tx="edream.110203113231.674">if customLine not in blocks:
    blocks[customLine] = []
    out.append(g.angleBrackets(customLine))
    # create first-level child
    child = p.insertAsNthChild(0)
    child.h = g.angleBrackets(customLine)
    children.append(child)

blocks[customLine].append(linelist[i])
</t>
<t tx="edream.110203113231.675">space = linelist[i].find(' ')
if space == -1:
    space = len(linelist[i])
key = linelist[i][:space]
if key in blocks:
    blocks[key] = []
    out.append(g.angleBrackets(key))
    # create first-level child
    child = p.insertAsNthChild(0)
    child.h = g.angleBrackets(key)
    children.append(child)

value = [linelist[i]]
# loop through the indented lines
i = i + 1
try:
    while linelist[i].startswith(' '):
        value.append(linelist[i])
        i = i + 1
except Exception:
    # EOF
    pass
i = i - 1  # restore index
# now add the value to the dictionary
blocks[key].append(value)
</t>
<t tx="edream.110203113231.729"></t>
<t tx="edream.110203113231.872">@nocolor-node

These plugins create new kinds of nodes, some of which affect the file system.</t>
<t tx="ekr.20031218072017.1490">def doTyping(
    self,
    p: Position,
    undo_type: str,
    oldText: str,
    newText: str,
    newInsert: int = None,
    oldSel: tuple[int, int] = None,
    newSel: tuple[int, int] = None,
    oldYview: int = None,
) -&gt; None:
    """
    Save enough information to undo or redo a typing operation efficiently,
    that is, with the proper granularity.

    Do nothing when called from the undo/redo logic because the Undo
    and Redo commands merely reset the bead pointer.

    **Important**: Code should call this method *only* when the user has
    actually typed something. Commands should use u.beforeChangeBody and
    u.afterChangeBody.

    Only qtm.onTextChanged and ec.selfInsertCommand now call this method.
    """
    c, u, w = self.c, self, self.c.frame.body.wrapper
    # Leo 6.4: undo_type must be 'Typing'.
    undo_type = undo_type.capitalize()
    assert undo_type == 'Typing', (repr(undo_type), g.callers())
    &lt;&lt; return if there is nothing to do &gt;&gt;
    &lt;&lt; init the undo params &gt;&gt;
    &lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
    &lt;&lt; save undo text info &gt;&gt;
    &lt;&lt; save the selection and scrolling position &gt;&gt;
    &lt;&lt; adjust the undo stack, clearing all forward entries &gt;&gt;
    if 'undo' in g.app.debug and 'verbose' in g.app.debug:
        print(f"u.doTyping: {len(oldText)} =&gt; {len(newText)}")
    if u.per_node_undo:
        u.putIvarsToVnode(p)
    #
    # Finish updating the text.
    p.v.setBodyString(newText)
    u.updateAfterTyping(p, w)

# Compatibility

setUndoTypingParams = doTyping
</t>
<t tx="ekr.20031218072017.1491">@ Incremental undo typing is similar to incremental syntax coloring. We compute
the number of leading and trailing lines that match, and save both the old and
new middle lines. NB: the number of old and new middle lines may be different.
@c
old_lines = oldText.split('\n')
new_lines = newText.split('\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len, new_len)
i = 0
while i &lt; min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i
if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i &lt; min_len - leading:
        if old_lines[old_len - i - 1] != new_lines[new_len - i - 1]:
            break
        i += 1
    trailing = i
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading : -trailing]
    new_middle_lines = new_lines[leading : -trailing]
# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1
old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1
i = len(newText) - 1
new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1
</t>
<t tx="ekr.20031218072017.1492">u.oldText = None
u.newText = None
u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
</t>
<t tx="ekr.20031218072017.1493">def undoRedoText(
    self,
    p: Position,
    leading: int,
    trailing: int,  # Number of matching leading &amp; trailing lines.
    oldMidLines: list[str],
    newMidLines: list[str],  # Lists of unmatched lines.
    oldNewlines: list[str],
    newNewlines: list[str],  # Number of trailing newlines.
    tag: str = "undo",  # "undo" or "redo"
    undoType: str = None,
) -&gt; None:
    """Handle text undo and redo: converts _new_ text into _old_ text."""
    # newNewlines is unused, but it has symmetry.
    c, u = self.c, self
    w = c.frame.body.wrapper
    &lt;&lt; Compute the result using p's body text &gt;&gt;
    p.setBodyString(result)
    p.setDirty()
    w.setAllText(result)
    sel = u.oldSel if tag == 'undo' else u.newSel
    if sel:
        i, j = sel
        w.setSelectionRange(i, j, insert=j)
    c.frame.body.recolor(p)
    w.seeInsertPoint()  # 2009/12/21
</t>
<t tx="ekr.20031218072017.1549">@g.commander_command('cut-node')
def cutOutline(self: Cmdr, event: Event = None) -&gt; None:
    """Delete the selected outline and send it to the clipboard."""
    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline(op_name="Cut Node")
        c.recolor()
</t>
<t tx="ekr.20031218072017.1550">@g.commander_command('copy-node')
def copyOutline(self: Cmdr, event: Event = None) -&gt; str:
    """Copy the selected outline to the clipboard."""
    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    s = c.fileCommands.outline_to_clipboard_string()
    g.app.paste_c = c
    if g.app.inBridge:
        return s
    g.app.gui.replaceClipboardWith(s)
    return s
</t>
<t tx="ekr.20031218072017.1551">@g.commander_command('paste-node')
def pasteOutline(
    self: Cmdr,
    event: Event = None,
    s: str = None,
    undoFlag: bool = True,  # A hack for abbrev.paste_tree.
) -&gt; Optional[Position]:
    """
    Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.
    """
    c = self
    if s is None:
        s = g.app.gui.getTextFromClipboard()
    c.endEditing()
    if not s or not c.canPasteOutline(s):
        return None  # This should never happen.
    isLeo = s.lstrip().startswith("{") or g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        return None
    # Get *position* to be pasted.
    pasted = c.fileCommands.getLeoOutlineFromClipboard(s)
    if not pasted:
        # Leo no longer supports MORE outlines. Use import-MORE-files instead.
        return None
    # Validate.
    c.checkOutline()
    errors = c.checkOutline()
    if errors &gt; 0:
        return None
    # Handle the "before" data for undo.
    if undoFlag:
        undoData = c.undoer.beforeInsertNode(c.p,
            pasteAsClone=False,
            copiedBunchList=[],
        )
    # Paste the node into the outline.
    c.selectPosition(pasted)
    pasted.setDirty()
    c.setChanged()
    back = pasted.back()
    if back and back.hasChildren() and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # Finish the command.
    if undoFlag:
        c.undoer.afterInsertNode(pasted, 'Paste Node', undoData)
    c.redraw(pasted)
    c.recolor()
    return pasted
</t>
<t tx="ekr.20031218072017.1573">def outline_to_clipboard_string(self, p: Position = None) -&gt; str:
    """
    Return a string suitable for pasting to the clipboard.
    """
    # Save
    tua = self.descendentTnodeUaDictList
    vua = self.descendentVnodeUaDictList
    gnxDict = self.gnxDict
    vnodesDict = self.vnodesDict
    try:
        self.usingClipboard = True
        if self.c.config.getBool('json-outline-clipboard', default=False):
            d = self.leojs_outline_dict(p or self.c.p)
            s = json.dumps(d, indent=2, cls=SetJSONEncoder)
        else:
            self.outputFile = io.StringIO()
            self.putProlog()
            self.putHeader()
            self.put_v_elements(p or self.c.p)
            self.put_t_elements()
            self.putPostlog()
            s = self.outputFile.getvalue()
            self.outputFile = None
    finally:  # Restore
        self.descendentTnodeUaDictList = tua
        self.descendentVnodeUaDictList = vua
        self.gnxDict = gnxDict
        self.vnodesDict = vnodesDict
        self.usingClipboard = False
    return s
</t>
<t tx="ekr.20031218072017.1579">def put_v_elements(self, p: Position = None) -&gt; None:
    """Puts all &lt;v&gt; elements in the order in which they appear in the outline."""
    c = self.c
    c.clearAllVisited()
    self.put("&lt;vnodes&gt;\n")
    # Make only one copy for all calls.
    self.currentPosition = p or c.p
    self.rootPosition = c.rootPosition()
    self.vnodesDict = {}
    if self.usingClipboard:
        self.put_v_element(self.currentPosition)  # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings():
            self.put_v_element(p, isIgnore=p.isAtIgnoreNode())
        # #1018: scan *all* nodes.
        self.setCachedBits()
    self.put("&lt;/vnodes&gt;\n")
</t>
<t tx="ekr.20031218072017.1581">def headString(self) -&gt; str:
    """Return the headline string."""
    # pylint: disable=no-else-return
    if isinstance(self._headString, str):
        return self._headString
    else:  # pragma: no cover
        # This message should never be printed and we want to avoid crashing here!
        g.internalError(f"headline not unicode: {self._headString!r}")
        return g.toUnicode(self._headString)
</t>
<t tx="ekr.20031218072017.1627">@g.commander_command('go-back')
def goPrevVisitedNode(self: Cmdr, event: Event = None) -&gt; None:
    """Select the previously visited node."""
    c = self
    p = c.nodeHistory.goPrev()
    if p:
        c.nodeHistory.skipBeadUpdate = True
        try:
            c.selectPosition(p)
        finally:
            c.nodeHistory.skipBeadUpdate = False
            c.redraw_after_select(p)
</t>
<t tx="ekr.20031218072017.1628">@g.commander_command('go-forward')
def goNextVisitedNode(self: Cmdr, event: Event = None) -&gt; None:
    """Select the next visited node."""
    c = self
    p = c.nodeHistory.goNext()
    if p:
        c.nodeHistory.skipBeadUpdate = True
        try:
            c.selectPosition(p)
        finally:
            c.nodeHistory.skipBeadUpdate = False
            c.redraw_after_select(p)
</t>
<t tx="ekr.20031218072017.1762">@g.commander_command('clone-node')
def clone(self: Cmdr, event: Event = None) -&gt; Optional[Position]:
    """Create a clone of the selected outline."""
    c, p, u = self, self.p, self.undoer
    if not p:
        return None
    undoData = c.undoer.beforeCloneNode(p)
    c.endEditing()  # Capture any changes to the headline.
    clone = p.clone()
    clone.setDirty()
    c.setChanged()
    if c.checkOutline() == 0:
        u.afterCloneNode(clone, 'Clone Node', undoData)
        c.redraw(clone)
        c.treeWantsFocus()
        return clone  # For mod_labels and chapters plugins.
    clone.doDelete()
    c.setCurrentPosition(p)
    return None
</t>
<t tx="ekr.20031218072017.1765"># Makes sure all nodes are valid.

def validateOutline(self, event: Event = None) -&gt; bool:
    """
    A legacy outline checker, retained only for compatibility.

    Not used in Leo's core or unit tests.
    """
    c = self
    return c.checkOutline() == 0


</t>
<t tx="ekr.20031218072017.1767">@g.commander_command('demote')
def demote(self: Cmdr, event: Event = None) -&gt; None:
    """Make all following siblings children of the selected node."""
    c, p, u = self, self.p, self.undoer
    if not p or not p.hasNext():
        c.treeFocusHelper()
        return
    # Make sure all the moves will be valid.
    next = p.next()
    while next:
        if not c.checkMoveWithParentWithWarning(next, p, True):
            c.treeFocusHelper()
            return
        next.moveToNext()
    c.endEditing()
    parent_v = p._parentVnode()
    n = p.childIndex()
    followingSibs = parent_v.children[n + 1 :]
    # Remove the moved nodes from the parent's children.
    parent_v.children = parent_v.children[: n + 1]
    # Add the moved nodes to p's children
    p.v.children.extend(followingSibs)
    # Adjust the parent links in the moved nodes.
    # There is no need to adjust descendant links.
    for child in followingSibs:
        child.parents.remove(parent_v)
        child.parents.append(p.v)
    p.expand()
    p.setDirty()
    c.setChanged()
    u.afterDemote(p, followingSibs)
    c.redraw(p)
    c.updateSyntaxColorer(p)  # Moving can change syntax coloring.
</t>
<t tx="ekr.20031218072017.1839">@g.commander_command('read-at-file-nodes')
def readAtFileNodes(self: Self, event: Event = None) -&gt; None:
    """
    Read all @file nodes in the presently selected outline.

    This command is not undoable.
    """
    c, p = self, self.p
    c.endEditing()
    c.endEditing()
    c.atFileCommands.readAllSelected(p)

    # Force an update of the body pane.
    c.setBodyString(p, p.b)  # Not a do-nothing!
    c.redraw()
    c.undoer.clearAndWarn('read-at-file-nodes')
</t>
<t tx="ekr.20031218072017.1863">def put_v_element(self, p: Position, isIgnore: bool = False) -&gt; None:
    """Write a &lt;v&gt; element corresponding to a VNode."""
    fc = self
    v = p.v
    # Precompute constants.
    # Write the entire @edit tree if it has children.
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip() and not p.hasChildren()
    isFile = p.isAtFileNode()
    isShadow = p.isAtShadowFileNode()
    isThin = p.isAtThinFileNode()
    # Set forcewrite.
    if isIgnore or p.isAtIgnoreNode():
        forceWrite = True
    elif isAuto or isEdit or isFile or isShadow or isThin:
        forceWrite = False
    else:
        forceWrite = True
    # Set the write bit if necessary.
    gnx = v.fileIndex
    if forceWrite or self.usingClipboard:
        v.setWriteBit()  # 4.2: Indicate we wrote the body text.

    attrs = fc.compute_attribute_bits(forceWrite, p)
    # Write the node.
    v_head = f'&lt;v t="{gnx}"{attrs}&gt;'
    if gnx in fc.vnodesDict:
        fc.put(v_head + '&lt;/v&gt;\n')
    else:
        fc.vnodesDict[gnx] = True
        v_head += f"&lt;vh&gt;{xml.sax.saxutils.escape(p.v.headString() or '')}&lt;/vh&gt;"
        # New in 4.2: don't write child nodes of @file-thin trees
        # (except when writing to clipboard)
        if p.hasChildren() and (forceWrite or self.usingClipboard):
            fc.put(f"{v_head}\n")
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.put_v_element(p, isIgnore)
                if p.hasNext():
                    p.moveToNext()
                else:
                    break
            p.moveToParent()  # Restore p in the caller.
            fc.put('&lt;/v&gt;\n')
        else:
            fc.put(f"{v_head}&lt;/v&gt;\n")  # Call put only once.
</t>
<t tx="ekr.20031218072017.1865">def compute_attribute_bits(self, forceWrite: Any, p: Position) -&gt; str:
    """Return the initial values of v's attributes."""
    attrs = []
    if p.hasChildren() and not forceWrite and not self.usingClipboard:
        # Fix #526: do this for @auto nodes as well.
        attrs.append(self.putDescendentVnodeUas(p))
    return ''.join(attrs)
</t>
<t tx="ekr.20031218072017.2030">@cmd('redo')
def redo(self, event: Event = None) -&gt; None:
    """Redo the operation undone by the last undo."""
    c, u = self.c, self
    if not c.p:
        return
    # End editing *before* getting state.
    c.endEditing()
    if not u.canRedo():
        return
    if not u.getBead(u.bead + 1):
        return
    #
    # Init status.
    u.redoing = True
    u.groupCount = 0
    if u.redoHelper:
        u.redoHelper()
    else:
        g.trace(f"no redo helper for {u.kind} {u.undoType}")
    #
    # Finish.
    c.checkOutline()
    u.update_status()
    u.redoing = False
    u.bead += 1
    u.setUndoTypes()
</t>
<t tx="ekr.20031218072017.2039">@cmd('undo')
def undo(self, event: Event = None) -&gt; None:
    """Undo the operation described by the undo parameters."""
    c, u = self.c, self
    if not c.p:
        g.trace('no current position')
        return
    # End editing *before* getting state.
    c.endEditing()
    if u.per_node_undo:  # 2011/05/19
        u.setIvarsFromVnode(c.p)
    if not u.canUndo():
        return
    if not u.getBead(u.bead):
        return
    #
    # Init status.
    u.undoing = True
    u.groupCount = 0
    #
    # Dispatch.
    if u.undoHelper:
        u.undoHelper()
    else:
        g.trace(f"no undo helper for {u.kind} {u.undoType}")
    #
    # Finish.
    c.checkOutline()
    u.update_status()
    u.undoing = False
    u.bead -= 1
    u.setUndoTypes()
</t>
<t tx="ekr.20031218072017.2072">def checkOutline(self) -&gt; int:
    """
    Check for errors in the outline.
    Return the number of errors.
    """
    c = self
    errors = 0
    t1 = time.process_time()
    for f in (c.checkVnodeLinks, c.checkGnxs):
        errors += f()
    t2 = time.process_time()
    if t2 - t1 &gt; 0.01 and not g.unitTesting:  # pylint: disable=simplifiable-condition
        g.trace(f"{t2 - t1:4.2f} sec. {c.shortFileName()} {g.caller()}")
    return errors
</t>
<t tx="ekr.20031218072017.2406" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e"># This file contains almost all of Leo's sources.

# See the "About this file" node for important notes.
</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.3341">@nobeautify

class VNode:

    __slots__ = [
        '_bodyString', '_headString', '_p_changed',
        'children', 'fileIndex', 'iconVal', 'parents', 'statusBits',
        'unknownAttributes',
        # Injected by read code.
        'at_read', 'tempAttributes',
        # Not written to any file.
        'context', 'expandedPositions', 'insertSpot',
        'scrollBarSpot', 'selectionLength', 'selectionStart',
    ]
    &lt;&lt; VNode constants &gt;&gt;
    @others
vnode = VNode  # compatibility.

@beautify
</t>
<t tx="ekr.20031218072017.3342"></t>
<t tx="ekr.20031218072017.3344">def __init__(self, context: Cmdr, gnx: Optional[str] = None):
    """
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = True whenever
    v.unknownAttributes or any mutable VNode object changes.
    """
    self._headString = 'newHeadline'  # Headline.
    self._bodyString = ''  # Body Text.
    self._p_changed = False  # For zodb.
    self.children: list[VNode] = []  # Ordered list of all children of this node.
    self.parents: list[VNode] = []  # Unordered list of all parents of this node.
    # The immutable fileIndex (gnx) for this node. Set below.
    self.fileIndex: Optional[str] = None
    self.iconVal = 0  # The present value of the node's icon.
    self.statusBits = 0  # status bits

    # Information that is never written to any file...

    # The context containing context.hiddenRootNode.
    # Required so we can compute top-level siblings.
    # It is named .context rather than .c to emphasize its limited usage.
    self.context: Cmdr = context
    self.expandedPositions: list[Position] = []  # Positions that should be expanded.
    self.insertSpot: Optional[int] = None  # Location of previous insert point.
    self.scrollBarSpot: Optional[int] = None  # Previous value of scrollbar position.
    self.selectionLength = 0  # The length of the selected body text.
    self.selectionStart = 0  # The start of the selected body text.

    # For at.read logic.
    self.at_read: dict[str, set] = {}

    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
</t>
<t tx="ekr.20031218072017.3345">def __repr__(self) -&gt; str:  # pragma: no cover
    return (
        '&lt;VNode: hidden root&gt;' if self.gnx == 'hidden-root-vnode-gnx'
        else f"&lt;VNode {self.gnx} {self.headString()}&gt;"
    )

__str__ = __repr__
</t>
<t tx="ekr.20031218072017.3346"></t>
<t tx="ekr.20031218072017.3348"># These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atAutoNodeName(self, h: Optional[str] = None) -&gt; str:
    return self.findAtFileName(g.app.atAutoNames, h=h)

# Retain this special case as part of the "escape hatch".
# That is, we fall back on code in leoRst.py if no
# importer or writer for reStructuredText exists.

def atAutoRstNodeName(self, h: Optional[str] = None) -&gt; str:
    names = ("@auto-rst",)
    return self.findAtFileName(names, h=h)

def atCleanNodeName(self) -&gt; str:
    names = ("@clean",)
    return self.findAtFileName(names)

def atEditNodeName(self) -&gt; str:
    names = ("@edit",)
    return self.findAtFileName(names)

def atFileNodeName(self) -&gt; str:
    names = ("@file", "@thin")  # Fix #403.
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName(self) -&gt; str:
    names = ("@nosent", "@file-nosent",)
    return self.findAtFileName(names)

def atRstFileNodeName(self) -&gt; str:
    names = ("@rst",)
    return self.findAtFileName(names)

def atShadowFileNodeName(self) -&gt; str:
    names = ("@shadow",)
    return self.findAtFileName(names)

def atSilentFileNodeName(self) -&gt; str:
    names = ("@asis", "@file-asis",)
    return self.findAtFileName(names)

def atThinFileNodeName(self) -&gt; str:
    names = ("@thin", "@file-thin",)
    return self.findAtFileName(names)

# New names, less confusing

atNoSentFileNodeName = atNoSentinelsFileNodeName
atAsisFileNodeName = atSilentFileNodeName
</t>
<t tx="ekr.20031218072017.3350">def anyAtFileNodeName(self) -&gt; str:
    """Return the file name following an @file node or an empty string."""
    return (
        self.findAtFileName(g.app.atAutoNames) or
        self.findAtFileName(g.app.atFileNames))
</t>
<t tx="ekr.20031218072017.3351">def isAtIgnoreNode(self) -&gt; bool:
    """
    Returns True if:

    - the vnode' body contains @ignore at the start of a line or

    - the vnode's headline starts with @ignore.
    """
    # v = self
    if g.match_word(self._headString, 0, '@ignore'):
        return True
    flag, i = g.is_special(self._bodyString, "@ignore")
    return flag
</t>
<t tx="ekr.20031218072017.3352">def isAtOthersNode(self) -&gt; bool:
    """Returns True if the receiver contains @others in its body at the start of a line."""
    flag, i = g.is_special(self._bodyString, "@others")
    return flag
</t>
<t tx="ekr.20031218072017.3353">def matchHeadline(self, pattern: str) -&gt; bool:
    """
    Returns True if the headline matches the pattern ignoring whitespace and case.

    The headline may contain characters following the successfully matched pattern.
    """
    v = self
    h = g.toUnicode(v.headString())
    h = h.lower().replace(' ', '').replace('\t', '')
    h = h.lstrip('.')  # 2013/04/05. Allow leading period before section names.
    pattern = g.toUnicode(pattern)
    pattern = pattern.lower().replace(' ', '').replace('\t', '')
    return h.startswith(pattern)
</t>
<t tx="ekr.20031218072017.3359"></t>
<t tx="ekr.20031218072017.3360"></t>
<t tx="ekr.20031218072017.3362">def firstChild(self) -&gt; Optional[VNode]:
    v = self
    return v.children[0] if v.children else None
</t>
<t tx="ekr.20031218072017.3364">def lastChild(self) -&gt; Optional[VNode]:
    v = self
    return v.children[-1] if v.children else None
</t>
<t tx="ekr.20031218072017.3365"># childIndex and nthChild are zero-based.

def nthChild(self, n: int) -&gt; Optional[VNode]:
    v = self
    if 0 &lt;= n &lt; len(v.children):
        return v.children[n]
    return None
</t>
<t tx="ekr.20031218072017.3366">def numberOfChildren(self) -&gt; int:
    v = self
    return len(v.children)
</t>
<t tx="ekr.20031218072017.3367"></t>
<t tx="ekr.20031218072017.3368">def isCloned(self) -&gt; bool:
    return len(self.parents) &gt; 1
</t>
<t tx="ekr.20031218072017.3369">def isDirty(self) -&gt; bool:
    return (self.statusBits &amp; self.dirtyBit) != 0
</t>
<t tx="ekr.20031218072017.3371">def isMarked(self) -&gt; bool:
    return (self.statusBits &amp; VNode.markedBit) != 0
</t>
<t tx="ekr.20031218072017.3372">def isOrphan(self) -&gt; bool:
    return (self.statusBits &amp; VNode.orphanBit) != 0
</t>
<t tx="ekr.20031218072017.3373">def isSelected(self) -&gt; bool:
    return (self.statusBits &amp; VNode.selectedBit) != 0
</t>
<t tx="ekr.20031218072017.3376">def isVisited(self) -&gt; bool:
    return (self.statusBits &amp; VNode.visitedBit) != 0
</t>
<t tx="ekr.20031218072017.3377">def status(self) -&gt; int:
    return self.statusBits
</t>
<t tx="ekr.20031218072017.3378">def bodyString(self) -&gt; str:
    # pylint: disable=no-else-return
    if isinstance(self._bodyString, str):
        return self._bodyString
    else:  # pragma: no cover
        # This message should never be printed and we want to avoid crashing here!
        g.internalError(f"body not unicode: {self._bodyString!r}")
        return g.toUnicode(self._bodyString)
</t>
<t tx="ekr.20031218072017.3384"></t>
<t tx="ekr.20031218072017.3385">def computeIcon(self) -&gt; int:  # pragma: no cover
    v = self
    val = 0
    if v.hasBody():
        val += 1
    if v.isMarked():
        val += 2
    if v.isCloned():
        val += 4
    if v.isDirty():
        val += 8
    return val

def setIcon(self) -&gt; None:  # pragma: no cover
    pass  # Compatibility routine for old scripts
</t>
<t tx="ekr.20031218072017.3386"></t>
<t tx="ekr.20031218072017.3388">def clearAllVisitedInTree(self) -&gt; None:
    for p in self.self_and_subtree(copy=False):
        p.v.clearVisited()
        p.v.clearWriteBit()
</t>
<t tx="ekr.20031218072017.3390">def clearDirty(self) -&gt; None:
    """Clear the vnode dirty bit."""
    v = self
    v.statusBits &amp;= ~v.dirtyBit
    v.updateIcon()
</t>
<t tx="ekr.20031218072017.3391">def clearMarked(self) -&gt; None:
    v = self
    v.statusBits &amp;= ~v.markedBit
    v.updateIcon()
</t>
<t tx="ekr.20031218072017.3392">def clearOrphan(self) -&gt; None:
    self.statusBits &amp;= ~self.orphanBit
</t>
<t tx="ekr.20031218072017.3393">def clearVisited(self) -&gt; None:
    self.statusBits &amp;= ~self.visitedBit
</t>
<t tx="ekr.20031218072017.3395">def contract(self) -&gt; None:
    """Contract the node."""
    self.statusBits &amp;= ~self.expandedBit

def expand(self) -&gt; None:
    """Expand the node."""
    self.statusBits |= self.expandedBit

def initExpandedBit(self) -&gt; None:
    """Init self.statusBits."""
    self.statusBits |= self.expandedBit

def isExpanded(self) -&gt; bool:
    """Return True if the VNode expansion bit is set."""
    return (self.statusBits &amp; self.expandedBit) != 0
</t>
<t tx="ekr.20031218072017.3396">def initStatus(self, status: int) -&gt; None:
    self.statusBits = status
</t>
<t tx="ekr.20031218072017.3398">def setMarked(self) -&gt; None:
    v = self
    v.statusBits |= v.markedBit
    v.updateIcon()

def initMarkedBit(self) -&gt; None:
    self.statusBits |= self.markedBit
</t>
<t tx="ekr.20031218072017.3399">def setOrphan(self) -&gt; None:
    """Set the vnode's orphan bit."""
    self.statusBits |= self.orphanBit
</t>
<t tx="ekr.20031218072017.3400"># This only sets the selected bit.

def setSelected(self) -&gt; None:
    self.statusBits |= self.selectedBit
</t>
<t tx="ekr.20031218072017.3401"># Compatibility routine for scripts

def setVisited(self) -&gt; None:
    self.statusBits |= self.visitedBit
</t>
<t tx="ekr.20031218072017.3402">def setSelection(self, start: int, length: int) -&gt; None:
    v = self
    v.selectionStart = start
    v.selectionLength = length
</t>
<t tx="ekr.20031218072017.3425">def _linkAsNthChild(self, parent_v: VNode, n: int) -&gt; None:
    """Links self as the n'th child of VNode pv"""
    v = self  # The child node.
    v._addLink(n, parent_v)
</t>
<t tx="ekr.20031218072017.3605">class Undoer:
    """A class that implements unlimited undo and redo."""
    # pylint: disable=not-an-iterable
    # pylint: disable=unsubscriptable-object
    # So that ivars can be inited to None rather than [].
    @others
</t>
<t tx="ekr.20031218072017.3606">def __init__(self, c: Cmdr) -&gt; None:
    self.c = c
    self.p: Position = None  # The position/node being operated upon for undo and redo.
    self.granularity = None  # Set in reloadSettings.
    self.max_undo_stack_size = c.config.getInt('max-undo-stack-size') or 0
    # State ivars...
    self.beads = []  # List of undo nodes.
    self.bead = -1  # Index of the present bead: -1:len(beads)
    self.undoType = "Can't Undo"
    # These must be set here, _not_ in clearUndoState.
    self.last_undoable_command_name = None  # Name of last undoable command.
    self.redoMenuLabel = "Can't Redo"
    self.undoMenuLabel = "Can't Undo"
    self.realRedoMenuLabel = "Can't Redo"
    self.realUndoMenuLabel = "Can't Undo"
    self.undoing = False  # True if executing an Undo command.
    self.redoing = False  # True if executing a Redo command.
    self.per_node_undo = False  # True: v may contain undo_info ivar.
    # New in 4.2...
    self.optionalIvars = []
    # Set the following ivars to keep pylint happy.
    # mypy doesn't care about these.
    self.afterTree = None
    self.beforeTree = None
    self.children = None
    self.deleteMarkedNodesData: g.Bunch = None
    self.followingSibs: list[VNode] = None
    self.headlines: dict[str, tuple[str, str]]
    self.inHead: bool = None
    self.kind: str = None
    self.newBack = None
    self.newBody = None
    self.newChildren = None
    self.newHead = None
    self.newIns = None
    self.newMarked = None
    self.newN = None
    self.newP = None
    self.newParent = None
    self.newPastedTree = None
    self.newParent_v = None
    self.newRecentFiles = None
    self.newSel = None
    self.newTree = None
    self.newYScroll = None
    self.oldBack = None
    self.oldBody = None
    self.oldChildren = None
    self.oldHead = None
    self.oldIns = None
    self.oldMarked = None
    self.oldN = None
    self.oldParent = None
    self.oldParent_v = None
    self.oldPastedTree = None
    self.oldRecentFiles = None
    self.oldSel = None
    self.oldSiblings = None
    self.oldTree = None
    self.oldYScroll = None
    self.pasteAsClone = None
    self.prevSel = None
    self.sortChildren = None
    self.verboseUndoGroup = None
    self.reloadSettings()
</t>
<t tx="ekr.20031218072017.3607">def clearOptionalIvars(self) -&gt; None:
    u = self
    u.p = None  # The position/node being operated upon for undo and redo.
    for ivar in u.optionalIvars:
        setattr(u, ivar, None)
</t>
<t tx="ekr.20031218072017.3608"></t>
<t tx="ekr.20031218072017.3609">def clearUndoState(self) -&gt; None:
    """Clears the entire Undo state."""
    u = self
    u.clearOptionalIvars()  # Do this first.
    u.setRedoType("Can't Redo")
    if u.last_undoable_command_name:
        undoType = f"Can't Undo {u.last_undoable_command_name}"
    else:
        undoType = "Can't Undo"
    u.setUndoType(undoType)
    u.beads = []  # List of undo nodes.
    u.bead = -1  # Index of the present bead: -1:len(beads)
</t>
<t tx="ekr.20031218072017.3610"># Translation does not affect these routines.

def canRedo(self) -&gt; None:
    u = self
    return u.redoMenuLabel != "Can't Redo"

def canUndo(self) -&gt; None:
    u = self
    return u.undoMenuLabel != "Can't Undo"
</t>
<t tx="ekr.20031218072017.3611">def enableMenuItems(self) -&gt; None:
    u = self
    frame = u.c.frame
    menu = frame.menu.getMenu("Edit")
    if menu:
        frame.menu.enableMenu(menu, u.redoMenuLabel, u.canRedo())
        frame.menu.enableMenu(menu, u.undoMenuLabel, u.canUndo())
</t>
<t tx="ekr.20031218072017.3613">def redoMenuName(self, name: str) -&gt; str:
    if name == "Can't Redo":
        return name
    return "Redo " + name

def undoMenuName(self, name: str) -&gt; str:
    if name.startswith("Can't Undo"):
        return name
    return "Undo " + name
</t>
<t tx="ekr.20031218072017.3614"># These routines update both the ivar and the menu label.

def setRedoType(self, theType: str) -&gt; None:

    u = self
    frame = u.c.frame
    if not isinstance(theType, str):  # pragma: no cover
        g.trace(f"oops: expected string for command, got {theType!r}")
        g.trace(g.callers())
        theType = '&lt;unknown&gt;'
    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline = -1 if g.match(name, 0, "Can't") else 0
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;", "")
        frame.menu.setMenuLabel(
            menu, u.realRedoMenuLabel, realLabel, underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel
</t>
<t tx="ekr.20031218072017.3616">def setUndoTypes(self) -&gt; None:
    u = self
    # Set the undo type and undo menu label.
    bunch = u.peekBead(u.bead)
    if bunch:
        u.setUndoType(bunch.undoType)
    else:
        if u.last_undoable_command_name:
            undoType = f"Can't Undo {u.last_undoable_command_name}"
        else:
            undoType = "Can't Undo"
        u.setUndoType(undoType)
    # Set only the redo menu label.
    bunch = u.peekBead(u.bead + 1)
    if bunch:
        u.setRedoType(bunch.undoType)
    else:
        u.setRedoType("Can't Redo")
    u.cutStack()
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.3679">def __init__(self, c: Cmdr, gui: LeoGui) -&gt; None:
    self.c = c
    self.gui = gui
    # Types...
    self.iconBarClass = NullIconBarClass
    self.statusLineClass = NullStatusLineClass
    # Objects attached to this frame...
    self.body: Union[LeoBody, NullBody, LeoQtBody] = None
    self.iconBar: Union[NullIconBarClass, QtIconBarClass] = None
    self.log: Union[LeoLog, NullLog, LeoQtLog] = None
    self.menu: Union[LeoMenu, LeoQtMenu, NullMenu] = None
    self.miniBufferWidget: Widget = None
    self.statusLine: Union[NullStatusLineClass, g.NullObject] = g.NullObject()
    self.top: DynamicWindow = None
    self.tree: Union[LeoTree, NullTree, LeoQtTree] = None
    self.useMiniBufferWidget = False
    # Other ivars...
    self.cursorStay = True  # May be overridden in subclass.reloadSettings.
    self.es_newlines = 0  # newline count for this log stream.
    self.isNullFrame = False
    self.openDirectory = ""
    self.saved = False  # True if ever saved
    self.splitVerticalFlag = True  # Set by initialRatios later.
    self.stylesheet: str = None  # The contents of &lt;?xml-stylesheet...?&gt; line.
    self.tab_width = 0  # The tab width in effect in this pane.
    self.title: str = None  # Must be created by subclasses.
</t>
<t tx="ekr.20031218072017.889">&lt;&lt; about the position class &gt;&gt;
# Positions should *never* be saved by the ZOBD.

class Position:

    __slots__ = ['_childIndex', 'stack', 'v']

    @others

position = Position  # compatibility.
</t>
<t tx="ekr.20031218072017.890">@language rest
@
A position marks the spot in a tree traversal. A position p consists of a VNode
p.v, a child index p._childIndex, and a stack of tuples (v,childIndex), one for
each ancestor **at the spot in tree traversal. Positions p has a unique set of
parents.

The p.moveToX methods may return a null (invalid) position p with p.v = None.

The tests "if p" or "if not p" are the _only_ correct way to test whether a
position p is valid. In particular, tests like "if p is None" or "if p is not
None" will not work properly.
</t>
<t tx="ekr.20031218072017.915"># These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack(self) -&gt; Position:
    return self.copy().moveToBack()

def getFirstChild(self) -&gt; Position:
    return self.copy().moveToFirstChild()

def getLastChild(self) -&gt; Position:
    return self.copy().moveToLastChild()

def getLastNode(self) -&gt; Position:
    return self.copy().moveToLastNode()

def getNext(self) -&gt; Position:
    return self.copy().moveToNext()

def getNodeAfterTree(self) -&gt; Position:
    return self.copy().moveToNodeAfterTree()

def getNthChild(self, n: int) -&gt; Position:
    return self.copy().moveToNthChild(n)

def getParent(self) -&gt; Position:
    return self.copy().moveToParent()

def getThreadBack(self) -&gt; Position:
    return self.copy().moveToThreadBack()

def getThreadNext(self) -&gt; Position:
    return self.copy().moveToThreadNext()

# New in Leo 4.4.3 b2: add c args.

def getVisBack(self, c: Cmdr) -&gt; Position:
    return self.copy().moveToVisBack(c)

def getVisNext(self, c: Cmdr) -&gt; Position:
    return self.copy().moveToVisNext(c)
# These are efficient enough now that iterators are the normal way to traverse the tree!
back = getBack
firstChild = getFirstChild
lastChild = getLastChild
lastNode = getLastNode
# lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next = getNext
nodeAfterTree = getNodeAfterTree
nthChild = getNthChild
parent = getParent
threadBack = getThreadBack
threadNext = getThreadNext
visBack = getVisBack
visNext = getVisNext
# New in Leo 4.4.3:
hasVisBack = visBack
hasVisNext = visNext
</t>
<t tx="ekr.20031218072017.951">@nobeautify

# Define the meaning of status bits in new vnodes.

# Unused bits.
# 0x01: was clonedBit
# 0x02
# 0x10
# 0x40: was topBit
# 0x010

# Archived bits...
expandedBit = 0x04  # True: VNode is expanded.
markedBit   = 0x08  # True: VNode is marked
selectedBit = 0x20  # True: VNode is current vnode.

# Not archived...
richTextBit = 0x080  # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit  = 0x100
dirtyBit    = 0x200
writeBit    = 0x400
orphanBit   = 0x800  # True: error in @&lt;file&gt; tree prevented it from being written.
</t>
<t tx="ekr.20040117171654">def copy(self) -&gt; Position:
    """"Return an independent copy of a position."""
    return Position(self.v, self._childIndex, self.stack)
</t>
<t tx="ekr.20040117173448">def __bool__(self) -&gt; bool:
    """
    Return True if a position is valid.

    The tests 'if p' or 'if not p' are the _only_ correct ways to test
    whether a position p is valid.

    Tests like 'if p is None' or 'if p is not None' will not work properly.
    """
    return self.v is not None
</t>
<t tx="ekr.20040228094013"></t>
<t tx="ekr.20040301205720">def __str__(self) -&gt; str:  # pragma: no cover
    p = self
    if p.v:
        return (
            "&lt;"
            f"pos {id(p)} "
            f"childIndex: {p._childIndex} "
            f"lvl: {p.level()} "
            f"key: {p.key()} "
            f"{p.h}"
            "&gt;"
        )
    return f"&lt;pos {id(p)} [{len(p.stack)}] None&gt;"

__repr__ = __str__
</t>
<t tx="ekr.20040303163330">def setDirty(self) -&gt; None:
    """
    Mark a node and all ancestor @file nodes dirty.

    p.setDirty() is no longer expensive.
    """
    p = self
    p.v.setAllAncestorAtFileNodesDirty()
    p.v.setDirty()
</t>
<t tx="ekr.20040303175026"></t>
<t tx="ekr.20040303175026.10">def moveAfter(self, a: Position) -&gt; Position:
    """Move a position after position a."""
    p = self  # Do NOT copy the position!
    a._adjustPositionBeforeUnlink(p)
    p._unlink()
    p._linkAfter(a)
    return p
</t>
<t tx="ekr.20040303175026.11">def moveToNthChildOf(self, parent: Position, n: int) -&gt; Position:
    """Move a position to the nth child of parent."""
    p = self  # Do NOT copy the position!
    parent._adjustPositionBeforeUnlink(p)
    p._unlink()
    p._linkAsNthChild(parent, n)
    return p
</t>
<t tx="ekr.20040303175026.13"># This routine checks the structure of the receiver's tree.
def validateOutlineWithParent(self, pv: Position) -&gt; bool:
    """
    A helper for the legacy version of c.validateOutline.

    No longer used in Leo's core or unit tests.
    """
    p = self
    result = True  # optimists get only unpleasant surprises.
    parent = p.getParent()
    childIndex = p._childIndex
    if parent != pv:
        p.invalidOutline("Invalid parent link: " + repr(parent))  # pragma: no cover
    if pv:
        if childIndex &lt; 0:
            p.invalidOutline(f"missing childIndex: {childIndex!r}")  # pragma: no cover
        elif childIndex &gt;= pv.numberOfChildren():
            p.invalidOutline("missing children entry for index: {childIndex!r}")  # pragma: no cover
    elif childIndex &lt; 0:
        p.invalidOutline("negative childIndex: {childIndex!r}")  # pragma: no cover
    if not p.v and pv:
        self.invalidOutline("Empty p.v")  # pragma: no cover
    # Recursively validate all the children.
    for child in p.children():
        r = child.validateOutlineWithParent(p)
        if not r:
            result = False  # pragma: no cover
    return result
</t>
<t tx="ekr.20040303175026.2">def doDelete(self, newNode: Optional[Position] = None) -&gt; None:
    """
    Deletes position p from the outline.

    This is the main delete routine.
    It deletes the receiver's entire tree from the screen.
    Because of the undo command we never actually delete vnodes.
    """
    p = self
    p.setDirty()  # Mark @file nodes dirty!
    sib = p.copy()
    while sib.hasNext():
        sib.moveToNext()
        if sib == newNode:
            # Adjust newNode._childIndex if newNode is a following sibling of p.
            newNode._childIndex -= 1
            break
    p._unlink()
</t>
<t tx="ekr.20040303175026.3">def insertAfter(self) -&gt; Position:
    """
    Inserts a new position after self.

    Returns the newly created position.
    """
    p = self
    context = p.v.context
    p2 = self.copy()
    p2.v = VNode(context=context)
    p2.v.iconVal = 0
    p2._linkAfter(p)
    return p2
</t>
<t tx="ekr.20040303175026.4">def insertAsLastChild(self) -&gt; Position:
    """
    Insert a new VNode as the last child of self.

    Return the newly created position.
    """
    p = self
    n = p.numberOfChildren()
    return p.insertAsNthChild(n)
</t>
<t tx="ekr.20040303175026.5">def insertAsNthChild(self, n: int) -&gt; Position:
    """
    Inserts a new node as the the nth child of self.
    self must have at least n-1 children.

    Returns the newly created position.
    """
    p = self
    context = p.v.context
    p2 = self.copy()
    p2.v = VNode(context=context)
    p2.v.iconVal = 0
    p2._linkAsNthChild(p, n)
    return p2
</t>
<t tx="ekr.20040303175026.6">def moveToRoot(self) -&gt; Position:
    """Move self to the root position."""
    p = self  # Do NOT copy the position!
    #
    # #1631. The old root can not possibly be affected by unlinking p.
    p._unlink()
    p._linkAsRoot()
    return p
</t>
<t tx="ekr.20040303175026.8">def clone(self) -&gt; Position:
    """Create a clone of back.

    Returns the newly created position."""
    p = self
    p2 = p.copy()  # Do *not* copy the VNode!
    p2._linkAfter(p)  # This should "just work"
    return p2
</t>
<t tx="ekr.20040303175026.9"># These used by unit tests, by the group_operations plugin,
# and by the files-compare-leo-files command.

# To do: use v.copyTree instead.

def copyTreeAfter(self, copyGnxs: bool = False) -&gt; Position:
    """Copy p and insert it after itself."""
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2, copyGnxs=copyGnxs)
    return p2


def copyTreeFromSelfTo(self, p2: Position, copyGnxs: bool = False) -&gt; None:
    p = self
    p2.v._headString = g.toUnicode(p.h, reportErrors=True)  # 2017/01/24
    p2.v._bodyString = g.toUnicode(p.b, reportErrors=True)  # 2017/01/24
    #
    # #1019794: p.copyTreeFromSelfTo, should deepcopy p.v.u.
    p2.v.u = copy.deepcopy(p.v.u)
    if copyGnxs:
        p2.v.fileIndex = p.v.fileIndex
    # 2009/10/02: no need to copy arg to iter
    for child in p.children():
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2, copyGnxs=copyGnxs)
</t>
<t tx="ekr.20040303214038">def setAllAncestorAtFileNodesDirty(self) -&gt; None:
    """
    Set all ancestor @&lt;file&gt; nodes dirty, including ancestors of all clones of p.
    """
    p = self
    p.v.setAllAncestorAtFileNodesDirty()
</t>
<t tx="ekr.20040305162628"></t>
<t tx="ekr.20040305222924"></t>
<t tx="ekr.20040306060312">def moveToFirstChildOf(self, parent: Position) -&gt; Position:
    """Move a position to the first child of parent."""
    p = self  # Do NOT copy the position!
    return p.moveToNthChildOf(parent, 0)  # Major bug fix: 2011/12/04

def moveToLastChildOf(self, parent: Position) -&gt; Position:
    """Move a position to the last child of parent."""
    p = self  # Do NOT copy the position!
    n = parent.numberOfChildren()
    if p.parent() == parent:
        n -= 1  # 2011/12/10: Another bug fix.
    return p.moveToNthChildOf(parent, n)  # Major bug fix: 2011/12/04
</t>
<t tx="ekr.20040306210951"></t>
<t tx="ekr.20040306211032">def anyAtFileNodeName(self) -&gt; str:
    return self.v.anyAtFileNodeName()

def atAutoNodeName(self) -&gt; str:
    return self.v.atAutoNodeName()

def atCleanNodeName(self) -&gt; str:
    return self.v.atCleanNodeName()

def atEditNodeName(self) -&gt; str:
    return self.v.atEditNodeName()

def atFileNodeName(self) -&gt; str:
    return self.v.atFileNodeName()

def atNoSentinelsFileNodeName(self) -&gt; str:
    return self.v.atNoSentinelsFileNodeName()

def atShadowFileNodeName(self) -&gt; str:
    return self.v.atShadowFileNodeName()

def atSilentFileNodeName(self) -&gt; str:
    return self.v.atSilentFileNodeName()

def atThinFileNodeName(self) -&gt; str:
    return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName = atNoSentinelsFileNodeName
atAsisFileNodeName = atSilentFileNodeName

def isAnyAtFileNode(self) -&gt; bool:
    return self.v.isAnyAtFileNode()

def isAtAllNode(self) -&gt; bool:
    return self.v.isAtAllNode()

def isAtAutoNode(self) -&gt; bool:
    return self.v.isAtAutoNode()

def isAtAutoRstNode(self) -&gt; bool:
    return self.v.isAtAutoRstNode()

def isAtCleanNode(self) -&gt; bool:
    return self.v.isAtCleanNode()

def isAtEditNode(self) -&gt; bool:
    return self.v.isAtEditNode()

def isAtFileNode(self) -&gt; bool:
    return self.v.isAtFileNode()

def isAtIgnoreNode(self) -&gt; bool:
    return self.v.isAtIgnoreNode()

def isAtNoSentinelsFileNode(self) -&gt; bool:
    return self.v.isAtNoSentinelsFileNode()

def isAtOthersNode(self) -&gt; bool:
    return self.v.isAtOthersNode()

def isAtRstFileNode(self) -&gt; bool:
    return self.v.isAtRstFileNode()

def isAtSilentFileNode(self) -&gt; bool:
    return self.v.isAtSilentFileNode()

def isAtShadowFileNode(self) -&gt; bool:
    return self.v.isAtShadowFileNode()

def isAtThinFileNode(self) -&gt; bool:
    return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtAsisFileNode = isAtSilentFileNode

# Utilities.

def matchHeadline(self, pattern: str) -&gt; bool:
    return self.v.matchHeadline(pattern)
</t>
<t tx="ekr.20040306212636"></t>
<t tx="ekr.20040306214240.2"></t>
<t tx="ekr.20040306214240.3">def hasChildren(self) -&gt; bool:
    p = self
    return len(p.v.children) &gt; 0

hasFirstChild = hasChildren

def numberOfChildren(self) -&gt; int:
    p = self
    return len(p.v.children)
</t>
<t tx="ekr.20040306214401">def isDirty(self) -&gt; bool:
    return self.v.isDirty()

def isMarked(self) -&gt; bool:
    return self.v.isMarked()

def isOrphan(self) -&gt; bool:
    return self.v.isOrphan()

def isSelected(self) -&gt; bool:
    return self.v.isSelected()

def isVisited(self) -&gt; bool:
    return self.v.isVisited()

def status(self) -&gt; int:
    return self.v.status()
</t>
<t tx="ekr.20040306215056">def isCloned(self) -&gt; bool:
    p = self
    return p.v.isCloned()
</t>
<t tx="ekr.20040306220230">def bodyString(self) -&gt; str:
    return self.v.bodyString()

def headString(self) -&gt; str:
    return self.v.headString()
</t>
<t tx="ekr.20040306220634"></t>
<t tx="ekr.20040306220634.17"># Compatibility routine for scripts.

def clearVisitedInTree(self) -&gt; None:
    for p in self.self_and_subtree(copy=False):
        p.clearVisited()
</t>
<t tx="ekr.20040306220634.29">def setSelection(self, start: int, length: int) -&gt; None:
    self.v.setSelection(start, length)
</t>
<t tx="ekr.20040306220634.8">def computeIcon(self) -&gt; int:
    return self.v.computeIcon()

def setIcon(self) -&gt; None:
    pass  # Compatibility routine for old scripts
</t>
<t tx="ekr.20040306220634.9"># Clone bits are no longer used.
# Dirty bits are handled carefully by the position class.

def clearMarked(self) -&gt; None:
    self.v.clearMarked()

def clearOrphan(self) -&gt; None:
    self.v.clearOrphan()

def clearVisited(self) -&gt; None:
    self.v.clearVisited()

def initExpandedBit(self) -&gt; None:
    self.v.initExpandedBit()

def initMarkedBit(self) -&gt; None:
    self.v.initMarkedBit()

def initStatus(self, status: int) -&gt; None:
    self.v.initStatus(status)

def setMarked(self) -&gt; None:
    self.v.setMarked()

def setOrphan(self) -&gt; None:
    self.v.setOrphan()

def setSelected(self) -&gt; None:
    self.v.setSelected()

def setVisited(self) -&gt; None:
    self.v.setVisited()
</t>
<t tx="ekr.20040307085922">def hasChildren(self) -&gt; bool:
    v = self
    return len(v.children) &gt; 0

hasFirstChild = hasChildren
</t>
<t tx="ekr.20040307104131.2">def isRoot(self) -&gt; bool:
    p = self
    return not p.hasParent() and not p.hasBack()
</t>
<t tx="ekr.20040310062332.1">def invalidOutline(self, message: str) -&gt; None:  # pragma: no cover
    p = self
    if p.hasParent():
        node = p.parent()
    else:
        node = p
    p.v.context.alert(f"invalid outline: {message}\n{node}")
</t>
<t tx="ekr.20040310153624">def dumpLink(self, link: Optional[str]) -&gt; str:  # pragma: no cover
    return link if link else "&lt;none&gt;"

def dump(self, label: str = "") -&gt; None:  # pragma: no cover
    p = self
    if p.v:
        p.v.dump()  # Don't print a label
</t>
<t tx="ekr.20040311113514">def clearDirty(self) -&gt; None:
    """(p) Set p.v dirty."""
    p = self
    p.v.clearDirty()
</t>
<t tx="ekr.20040312015908"></t>
<t tx="ekr.20040312145256">def dumpLink(self, link: Optional[str]) -&gt; str:  # pragma: no cover
    return link if link else "&lt;none&gt;"

def dump(self, label: str = "") -&gt; None:  # pragma: no cover
    v = self
    # s = '-' * 10
    print('')
    print(f"dump of vnode: {label} {v}")
    # print('gnx: %s' % v.gnx)
    print(f"len(parents): {len(v.parents)} len(children): {len(v.children)}")
    if v.parents:
        print(f"parents: {g.listToString(v.parents)}")
    if v.children:
        print(f"children: {g.listToString(v.children)}")
</t>
<t tx="ekr.20040314035615">def checkThreadLinks(self, p: Position) -&gt; bool:
    """Check consistency of threadNext &amp; threadBack links."""
    threadBack = p.threadBack()
    threadNext = p.threadNext()
    if threadBack:
        if not g._assert(p == threadBack.threadNext()):
            g.trace("p!=p.threadBack().threadNext()")
            return False
    if threadNext:
        if not g._assert(p == threadNext.threadBack()):
            g.trace("p!=p.threadNext().threadBack()")
            return False
    return True
</t>
<t tx="ekr.20040314035615.1">def checkSiblings(self, p: Position) -&gt; bool:
    """Check the consistency of next and back links."""
    back = p.back()
    next = p.next()
    if back:
        if not g._assert(p == back.next()):
            g.trace(
                f"p!=p.back().next()\n"
                f"     back: {back}\n"
                f"back.next: {back.next()}")
            return False
    if next:
        if not g._assert(p == next.back()):
            g.trace(
                f"p!=p.next().back\n"
                f"     next: {next}\n"
                f"next.back: {next.back()}")
            return False
    return True
</t>
<t tx="ekr.20040314035615.2">def checkParentAndChildren(self, p: Position) -&gt; bool:
    """Check consistency of parent and child data structures."""
    c = self

    def _assert(condition: Any) -&gt; bool:
        return g._assert(condition, show_callers=False)

    def dump(p: Position) -&gt; None:
        if p and p.v:
            p.v.dump()
        elif p:
            print('&lt;no p.v&gt;')
        else:
            print('&lt;no p&gt;')

    if p.hasParent():
        n = p.childIndex()
        if not _assert(p == p.parent().moveToNthChild(n)):
            g.trace(f"p != parent().moveToNthChild({n})")
            dump(p)
            dump(p.parent())
            return False
    if p.level() &gt; 0 and not _assert(p.v.parents):
        g.trace("no parents")
        dump(p)
        return False
    for child in p.children():
        if not c.checkParentAndChildren(child):
            return False
        if not _assert(p == child.parent()):
            g.trace("p != child.parent()")
            dump(p)
            dump(child.parent())
            return False
    if p.hasNext():
        if not _assert(p.next().parent() == p.parent()):
            g.trace("p.next().parent() != p.parent()")
            dump(p.next().parent())
            dump(p.parent())
            return False
    if p.hasBack():
        if not _assert(p.back().parent() == p.parent()):
            g.trace("p.back().parent() != parent()")
            dump(p.back().parent())
            dump(p.parent())
            return False
    # Check consistency of parent and children arrays.
    # Every nodes gets visited, so a strong test need only check consistency
    # between p and its parent, not between p and its children.
    parent_v = p._parentVnode()
    n = p.childIndex()
    if not _assert(parent_v.children[n] == p.v):
        g.trace("parent_v.children[n] != p.v")
        parent_v.dump()
        p.v.dump()
        return False
    return True
</t>
<t tx="ekr.20040315023430"># - convertTreeToString and moreHead can't be VNode methods because they use level().
# - moreBody could be anywhere: it may as well be a position method.
</t>
<t tx="ekr.20040315023430.1">def convertTreeToString(self) -&gt; str:
    """Convert a positions suboutline to a string in MORE format."""
    p = self
    level1 = p.level()
    array = []
    for p in p.self_and_subtree(copy=False):
        array.append(p.moreHead(level1) + '\n')
        body = p.moreBody()
        if body:
            array.append(body + '\n')
    return ''.join(array)
</t>
<t tx="ekr.20040315023430.2">def moreHead(self, firstLevel: int, useVerticalBar: bool = False) -&gt; str:
    """Return the headline string in MORE format."""
    # useVerticalBar is unused, but it would be useful in over-ridden methods.
    p = self
    level = self.level() - firstLevel
    plusMinus = "+" if p.hasChildren() else "-"
    pad = '\t' * level
    return f"{pad}{plusMinus} {p.h}"
</t>
<t tx="ekr.20040315023430.3">@language rest
@
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c
@language python

def moreBody(self) -&gt; str:
    """Returns the body string in MORE format.

    Inserts a backslash before any leading plus, minus or backslash."""
    p = self
    array = []
    lines = p.b.split('\n')
    for s in lines:
        i = g.skip_ws(s, 0)
        if i &lt; len(s) and s[i] in ('+', '-', '\\'):
            s = s[:i] + '\\' + s[i:]
        array.append(s)
    return '\n'.join(array)
</t>
<t tx="ekr.20040315032144">def setBodyString(self, s: Any) -&gt; None:
    # pylint: disable=no-else-return
    v = self
    if isinstance(s, str):
        v._bodyString = s
        v.updateIcon()
        return
    else:  # pragma: no cover
        v._bodyString = g.toUnicode(s, reportErrors=True)
        self.contentModified()  # #1413.
        signal_manager.emit(self.context, 'body_changed', self)
        v.updateIcon()

def setHeadString(self, s: Any) -&gt; None:
    # pylint: disable=no-else-return
    # Fix bug: https://bugs.launchpad.net/leo-editor/+bug/1245535
    # API allows headlines to contain newlines.
    v = self
    if isinstance(s, str):
        v._headString = s.replace('\n', '')
        v.updateIcon()
        return
    else:  # pragma: no cover
        s = g.toUnicode(s, reportErrors=True)
        v._headString = s.replace('\n', '')  # type:ignore
        self.contentModified()  # #1413.
        v.updateIcon()

initBodyString = setBodyString
initHeadString = setHeadString
setHeadText = setHeadString
setTnodeText = setBodyString
</t>
<t tx="ekr.20040315034158">def setBodyString(self, s: str) -&gt; None:
    p = self
    return p.v.setBodyString(s)

initBodyString = setBodyString
setTnodeText = setBodyString
scriptSetBodyString = setBodyString

def initHeadString(self, s: str) -&gt; None:
    p = self
    p.v.initHeadString(s)

def setHeadString(self, s: str) -&gt; None:
    p = self
    p.v.initHeadString(s)
    p.setDirty()
</t>
<t tx="ekr.20040323100443">def directParents(self) -&gt; list[VNode]:
    """(New in 4.2) Return a list of all direct parent vnodes of a VNode.

    This is NOT the same as the list of ancestors of the VNode."""
    v = self
    return v.parents
</t>
<t tx="ekr.20040323160302">def directParents(self) -&gt; list[VNode]:
    return self.v.directParents()
</t>
<t tx="ekr.20040324061854">if u.redoing or u.undoing:
    return  # pragma: no cover
if undo_type is None:
    return  # pragma: no cover
if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes()  # Must still recalculate the menu labels.
    return  # pragma: no cover
if oldText == newText:
    u.setUndoTypes()  # Must still recalculate the menu labels.
    return  # pragma: no cover
</t>
<t tx="ekr.20040324061854.1">u.clearOptionalIvars()
# Set the params.
u.undoType = undo_type
u.p = p.copy()
</t>
<t tx="ekr.20040324061854.2"># Remember the selection.
u.oldSel = oldSel
u.newSel = newSel
# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.wrapper.getYScrollPosition()
</t>
<t tx="ekr.20040324061854.3">@
New in Leo 4.3. Instead of creating a new bead on every character, we
may adjust the top bead:
word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c
granularity = u.granularity
old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')
&lt;&lt; set newBead if we can't share the previous bead &gt;&gt;
# Save end selection as new "previous" selection
u.prevSel = u.newSel
if newBead:
    # Push params on undo stack, clearing all forward entries.
    bunch = g.Bunch(
        p=p.copy(),
        kind='typing',  # lowercase.
        undoType=undo_type,  # capitalized.
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldMarked=old_p.isMarked() if old_p else p.isMarked(),  # #1694
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
    u.pushBead(bunch)
else:
    bunch = old_d
bunch.leading = u.leading
bunch.trailing = u.trailing
bunch.newMarked = p.isMarked()  # #1694
bunch.newNewlines = u.newNewlines
bunch.newMiddleLines = u.newMiddleLines
bunch.newSel = u.newSel
bunch.newText = u.newText
bunch.yview = u.yview
</t>
<t tx="ekr.20040325073709">def isAtAutoNode(self) -&gt; bool:
    return bool(self.atAutoNodeName())

def isAtAutoRstNode(self) -&gt; bool:
    return bool(self.atAutoRstNodeName())

def isAtCleanNode(self) -&gt; bool:
    return bool(self.atCleanNodeName())

def isAtEditNode(self) -&gt; bool:
    return bool(self.atEditNodeName())

def isAtFileNode(self) -&gt; bool:
    return bool(self.atFileNodeName())

def isAtRstFileNode(self) -&gt; bool:
    return bool(self.atRstFileNodeName())

def isAtNoSentinelsFileNode(self) -&gt; bool:
    return bool(self.atNoSentinelsFileNodeName())

def isAtSilentFileNode(self) -&gt; bool:
    return bool(self.atSilentFileNodeName())

def isAtShadowFileNode(self) -&gt; bool:
    return bool(self.atShadowFileNodeName())

def isAtThinFileNode(self) -&gt; bool:
    return bool(self.atThinFileNodeName())

# New names, less confusing:

isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtAsisFileNode = isAtSilentFileNode
</t>
<t tx="ekr.20040326031436">def isAnyAtFileNode(self) -&gt; bool:
    """Return True if v is any kind of @file or related node."""
    return bool(self.anyAtFileNodeName())
</t>
<t tx="ekr.20040326064330"># This used to be time-critical code.

def childIndex(self) -&gt; int:
    p = self
    return p._childIndex
</t>
<t tx="ekr.20040331071919"></t>
<t tx="ekr.20040702104823">def inAtIgnoreRange(self) -&gt; bool:
    """Returns True if position p or one of p's parents is an @ignore node."""
    p = self
    for p in p.self_and_parents(copy=False):
        if p.isAtIgnoreNode():
            return True
    return False
</t>
<t tx="ekr.20040705201018">def findAtFileName(self, names: tuple, h: Optional[str] = None) -&gt; str:
    """Return the name following one of the names in nameList or """
    # Allow h argument for unit testing.
    if not h:
        h = self.headString()
    if not g.match(h, 0, '@'):
        return ""
    i = g.skip_id(h, 1, '-')
    word = h[:i]
    if word in names and g.match_word(h, 0, word):
        name = h[i:].strip()
        return name
    return ""
</t>
<t tx="ekr.20040722141148">@nocolor-node
@

You would typically not enable any of the following "plugins".

These plugins contain example code only.
</t>
<t tx="ekr.20040803140033.1">_currentCount = 0

def setCurrentPosition(self, p: Position) -&gt; None:
    """
    Set the presently selected position. For internal use only.
    Client code should use c.selectPosition instead.
    """
    c = self
    if not p:
        g.trace('===== no p', g.callers())
        return
    if c.positionExists(p):
        if c._currentPosition and p == c._currentPosition:
            pass  # We have already made a copy.
        else:  # Make a copy _now_
            c._currentPosition = p.copy()
    else:
        if g.unitTesting:
            # New in Leo 6.7.4: *Do* raise an exception.
            raise ValueError(f"Invalid position: {p!r}")
        c._currentPosition = c.rootPosition()
        g.trace('Invalid position', repr(p), repr(c))
        g.trace(g.callers())

# For compatibility with old scripts.

setCurrentVnode = setCurrentPosition
</t>
<t tx="ekr.20040915073259">@nocolor-node

These plugins add buttons and other widgets to the icon area or
affect Leo's panes and windows in various ways.

</t>
<t tx="ekr.20041001210557"></t>
<t tx="ekr.20041030092101">@Notes by EKR: The dyna plugin is a remarkable body of work by 'e'. Have fun with it.

You may download the latest version at: http: // rclick.netfirms.com / dyna_menu.py.html
</t>
<t tx="ekr.20041114102139">@nocolor

Comments
--------

Most of the comments in the style guide are comments*about*the style guide.
You would replace these comments with your own, or eliminate them entirely in
your plugin.

Docstrings
----------

Several plugins show the docstring, so please take care to do a good job of
describing what the plugin does and how to use it.

Directives
----------

Please put the following at the end of the plugin's top-level node.

    @language python
    @tabwidth-4

Imports
-------

-Do* not*assume that modules like Qt are always available.

-Do* not*use from m import*

-Your code should test whether modules have been imported only if those modules
  may not be available on all platforms.

-To fail gracefully if the Qt gui is not in effect, put the following at
  the top level::

      #
      # Fail fast, right after all imports.
      g.assertUi('qt')  # May raise g.UiTypeException, caught by the plugins manager.

Exceptions
----------

It is usually best* not*to catch exceptions in plugins: doHook catches all
exceptions and disables further calls to plugins.

If a plugin catches exceptions during startup it should do either raise the
exception again or provide an init function at the top level that reports the
failure by returning False.

Use separate nodes
------------------

**Please**define each class, function or method in a separate node!To
make this work, just put@others in the root of your plugin as shown.Note
that@others may be nested, as shown in class myClass.
</t>
<t tx="ekr.20041118104831.1">class LocalConfigManager:
    """A class to hold config settings for commanders."""
    @others
</t>
<t tx="ekr.20041118104831.2">def __init__(self, c: Cmdr, previousSettings: "PreviousSettings" = None) -&gt; None:
    self.c = c
    lm = g.app.loadManager
    if previousSettings:
        self.settingsDict = previousSettings.settingsDict
        self.shortcutsDict = previousSettings.shortcutsDict
        assert isinstance(self.settingsDict, g.SettingsDict), self.settingsDict.__class__.__name__
        assert isinstance(self.shortcutsDict, g.SettingsDict), self.shortcutsDict.__class__.__name__
    else:
        self.settingsDict = d1 = lm.globalSettingsDict
        self.shortcutsDict = d2 = lm.globalBindingsDict
        assert d1 is None or isinstance(d1, g.SettingsDict), d1.__class__.__name__
        assert d2 is None or isinstance(d2, g.SettingsDict), d2.__class__.__name__
    # Default encodings.
    self.default_at_auto_file_encoding = 'utf-8'
    self.default_derived_file_encoding = 'utf-8'
    self.new_leo_file_encoding = 'utf-8'
    # Default fonts.
    self.defaultBodyFontSize = 12  # 9 if sys.platform == "win32" else 12
    self.defaultLogFontSize = 12  # 8 if sys.platform == "win32" else 12
    self.defaultMenuFontSize = 12  # 9 if sys.platform == "win32" else 12
    self.defaultTreeFontSize = 12  # 9 if sys.platform == "win32" else 12
</t>
<t tx="ekr.20041120074536">def settingsRoot(self) -&gt; Position:
    """Return the position of the @settings tree."""
    c = self.c
    for p in c.all_unique_positions():
        # #1792: Allow comments after @settings.
        if g.match_word(p.h.rstrip(), 0, "@settings"):
            return p.copy()
    return None
</t>
<t tx="ekr.20041123092357"># This was not used prior to Leo 4.5.

def findSettingsPosition(self, setting: str) -&gt; Position:
    """Return the position for the setting in the @settings tree for c."""
    munge = g.app.config.munge
    root = self.settingsRoot()
    if not root:
        return None
    setting = munge(setting)
    for p in root.subtree():
        # BJ munge will return None if a headstring is empty
        h = munge(p.h) or ''
        if h.startswith(setting):
            return p.copy()
    return None
</t>
<t tx="ekr.20041223105114.1">def createStatusLine(self) -&gt; Union[NullStatusLineClass, g.NullObject]:
    if not self.statusLine:
        self.statusLine = self.statusLineClass(self.c, None)
    return self.statusLine

def clearStatusLine(self) -&gt; None:
    if self.statusLine:
        self.statusLine.clear()

def disableStatusLine(self, background: str = None) -&gt; None:
    if self.statusLine:
        self.statusLine.disable(background)

def enableStatusLine(self, background: str = "white") -&gt; None:
    if self.statusLine:
        self.statusLine.enable(background)

def getStatusLine(self) -&gt; Union[NullStatusLineClass, g.NullObject]:
    return self.statusLine

getStatusObject = getStatusLine

def putStatusLine(self, s: str, bg: str = None, fg: str = None) -&gt; None:
    if self.statusLine:
        self.statusLine.put(s, bg, fg)

def setFocusStatusLine(self) -&gt; None:
    if self.statusLine:
        self.statusLine.setFocus()

def statusLineIsEnabled(self) -&gt; bool:
    if self.statusLine:
        return self.statusLine.isEnabled()
    return False

def updateStatusLine(self) -&gt; None:
    if self.statusLine:
        self.statusLine.update()
</t>
<t tx="ekr.20050111122605"></t>
<t tx="ekr.20050125203937"># Fix #653: undoer problem: be wary of the ternary operator here.
old_start = old_end = new_start = new_end = 0
if oldSel is not None:
    old_start, old_end = oldSel
if newSel is not None:
    new_start, new_end = newSel
if u.prevSel is None:
    prev_start, prev_end = 0, 0
else:
    prev_start, prev_end = u.prevSel
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    # 2011/04/01: Patch by Sam Hartsfield
    old_row, old_col = g.convertPythonIndexToRowCol(
        oldText, old_start)
    new_row, new_col = g.convertPythonIndexToRowCol(
        newText, new_start)
    prev_row, prev_col = g.convertPythonIndexToRowCol(
        oldText, prev_start)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col - new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        # py-lint: disable=W0511
        # W0511:1362: TODO
        # TODO this is not true, we might as well just have entered a
        # char at the beginning of an existing line
        pass  # We have just inserted a line.
    else:
        # 2011/04/01: Patch by Sam Hartsfield
        old_s = old_lines[old_row]
        new_s = new_lines[new_row]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col - 1 &gt;= len(old_s) or new_col - 1 &gt;= len(new_s):
            newBead = True
        else:
            old_ch = old_s[old_col - 1]
            new_ch = new_s[new_col - 1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines, old_row, old_col, old_ch,
                new_lines, new_row, new_col, new_ch,
                prev_row, prev_col)
</t>
<t tx="ekr.20050125220613"># Set newBead to True if undo_type is not 'Typing' so that commands that
# get treated like typing don't get lumped with 'real' typing.
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True  # We can't share the previous node.
elif granularity == 'char':
    newBead = True  # This was the old way.
elif granularity == 'node':
    newBead = False  # Always replace previous bead.
else:
    assert granularity in ('line', 'word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading', 0) != u.leading or
        old_d.get('trailing', 0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            &lt;&lt; set newBead if the change does not continue a word &gt;&gt;
        except Exception:
            g.error('Unexpected exception...')
            g.es_exception()
            newBead = True
</t>
<t tx="ekr.20050126081529">def recognizeStartOfTypingWord(
    self,
    old_lines: list[str],
    old_row: int,
    old_col: int,
    old_ch: str,
    new_lines: list[str],
    new_row: int,
    new_col: int,
    new_ch: str,
    prev_row: int,
    prev_col: int,
) -&gt; bool:
    """
    A potentially user-modifiable method that should return True if the
    typing indicated by the params starts a new 'word' for the purposes of
    undo with 'word' granularity.

    u.doTyping calls this method only when the typing could possibly
    continue a previous word. In other words, undo will work safely regardless
    of the value returned here.

    old_ch is the char at the given (Tk) row, col of old_lines.
    new_ch is the char at the given (Tk) row, col of new_lines.

    The present code uses only old_ch and new_ch. The other arguments are given
    for use by more sophisticated algorithms.
    """
    # Start a word if new_ch begins whitespace + word
    new_word_started = not old_ch.isspace() and new_ch.isspace()
    # Start a word if the cursor has been moved since the last change
    moved_cursor = new_row != prev_row or new_col != prev_col + 1
    return new_word_started or moved_cursor
</t>
<t tx="ekr.20050130120433">"""A plugin to test import problems."""

from leo.core import leoGlobals as g

def onStart(tag,keywords):
    pass

# pylint: disable=unused-import
try:
    import xyzzy
except ImportError:
    g.cantImport('xyzzy',pluginName='failed_import')

def init():
    """Return True if the plugin has loaded successfully."""
    g.registerHandler("start2", onStart)
    g.plugin_signon(__name__)
    return True
</t>
<t tx="ekr.20050303051035">@nocolor-node

The following nodes show recommended style when writing plugins.</t>
<t tx="ekr.20050303051035.2">"""
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
"""
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4
</t>
<t tx="ekr.20050303051035.5">from leo.core import leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050303051101">def init():
    """Return True if the plugin has loaded successfully."""
    ok=g.app.gui.guiName() in('qt','qttabs')
    if ok:
        if 1: # Use this if you want to create the commander class before the frame is fully created.
            g.registerHandler('before-create-leo-frame',onCreate)
        else: # Use this if you want to create the commander class after the frame is fully created.
            g.registerHandler('after-create-leo-frame',onCreate)
    return ok</t>
<t tx="ekr.20050303051150">def onCreate(tag, keys):

    c=keys.get('c')
    if not c: return

    thePluginController=pluginController(c)
</t>
<t tx="ekr.20050303051222">class pluginController:

    @others</t>
<t tx="ekr.20050303051222.1">def __init__(self,c):

    self.c=c
    # Warning: hook handlers must use keywords.get('c'), NOT self.c.
</t>
<t tx="ekr.20050306071540">def onStart2(tag, keywords):
    """
    A global hook that affects all commanders.
    """

    log=c.frame.log.__class__

    # Replace frame.put with newPut (not shown).
    g.funcToMethod(newPut,log,"put")</t>
<t tx="ekr.20050306071629">"""
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
"""
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4</t>
<t tx="ekr.20050306071629.1">"""
This docstring should be a clear, concise description of what the plugin does
and how to use it.
"""
</t>
<t tx="ekr.20050306071629.3">from leo.core import leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050306071629.4">def init():
    """Return True if the plugin has loaded successfully."""
    ok=True # This might depend on imports, etc.
    if ok:
        g.registerHandler('start2',onStart2)
    return ok</t>
<t tx="ekr.20050306081349"></t>
<t tx="ekr.20050315133212.2">def beforeChangeNodeContents(self, p: Position) -&gt; g.Bunch:
    """Return data that gets passed to afterChangeNode."""
    c, u = self.c, self
    w = c.frame.body.wrapper
    bunch = u.createCommonBunch(p)
    bunch.oldBody = p.b
    bunch.oldHead = p.h
    # #1413: Always restore yScroll if possible.
    bunch.oldYScroll = w.getYScrollPosition() if w else 0
    return bunch
</t>
<t tx="ekr.20050315134017.2">def afterChangeNodeContents(self, p: Position, command: str, bunch: g.Bunch) -&gt; None:
    """Create an undo node using d created by beforeChangeNode."""
    u = self
    c = self.c
    w = c.frame.body.wrapper
    if u.redoing or u.undoing:
        return
    # Set the type &amp; helpers.
    bunch.kind = 'node'
    bunch.undoType = command
    bunch.undoHelper = u.undoNodeContents
    bunch.redoHelper = u.redoNodeContents
    bunch.inHead = False  # 2013/08/26
    bunch.newBody = p.b
    bunch.newHead = p.h
    bunch.newMarked = p.isMarked()
    # Bug fix 2017/11/12: don't use ternary operator.
    if w:
        bunch.newSel = w.getSelectionRange()
    else:
        bunch.newSel = 0, 0  # pragma: no cover
    bunch.newYScroll = w.getYScrollPosition() if w else 0
    u.pushBead(bunch)
</t>
<t tx="ekr.20050315134017.3">def afterChangeTree(self, p: Position, command: str, bunch: g.Bunch) -&gt; None:
    """Create an undo node for general tree operations using d created by beforeChangeTree"""
    u = self
    c = self.c
    w = c.frame.body.wrapper
    if u.redoing or u.undoing:
        return  # pragma: no cover
    # Set the types &amp; helpers.
    bunch.kind = 'tree'
    bunch.undoType = command
    bunch.undoHelper = u.undoTree
    bunch.redoHelper = u.redoTree
    # Set by beforeChangeTree: changed, oldSel, oldText, oldTree, p
    bunch.newSel = w.getSelectionRange()
    bunch.newText = w.getAllText()
    bunch.newTree = u.saveTree(p)
    u.pushBead(bunch)
</t>
<t tx="ekr.20050315134017.4">def afterChangeGroup(self,
    p: Position,
    undoType: str,
    reportFlag: bool = False,  # unused: retained for compatibility with existing scripts.
) -&gt; None:
    """
    Create an undo node for general tree operations using d created by
    beforeChangeGroup
    """
    c, u = self.c, self
    w = c.frame.body.wrapper
    if p != c.p:  # Prepare to ignore p argument.
        if not u.changeGroupWarning:
            u.changeGroupWarning = True
            g.trace("Position mismatch", g.callers())
    if u.redoing or u.undoing:
        return  # pragma: no cover
    bunch = u.beads[u.bead]
    if not u.beads:  # pragma: no cover
        g.trace('oops: empty undo stack.')
        return
    if bunch.kind == 'beforeGroup':
        bunch.kind = 'afterGroup'
    else:  # pragma: no cover
        g.trace(f"oops: expecting beforeGroup, got {bunch.kind}")
    # Set the types &amp; helpers.
    bunch.kind = 'afterGroup'
    bunch.undoType = undoType
    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    bunch.newP = p.copy()
    bunch.newSel = w.getSelectionRange()
    # Tells whether to report the number of separate changes undone/redone.
    if 0:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]
    # Recalculate the menu labels.
    u.setUndoTypes()
</t>
<t tx="ekr.20050315134017.6">def beforeChangeTree(self, p: Position) -&gt; None:
    c, u = self.c, self
    w = c.frame.body.wrapper
    bunch = u.createCommonBunch(p)
    bunch.oldSel = w.getSelectionRange()
    bunch.oldText = w.getAllText()
    bunch.oldTree = u.saveTree(p)
    return bunch
</t>
<t tx="ekr.20050315134017.7">changeGroupWarning = False

def beforeChangeGroup(self, p: Position, command: str, verboseUndoGroup: bool = False) -&gt; None:
    """Prepare to undo a group of undoable operations."""
    c, u = self.c, self
    if p != c.p:  # Prepare to ignore p argument.
        if not u.changeGroupWarning:
            u.changeGroupWarning = True
            g.trace("Position mismatch", g.callers())
    bunch = u.createCommonBunch(p)
    # Set types.
    bunch.kind = 'beforeGroup'
    bunch.undoType = command
    bunch.verboseUndoGroup = verboseUndoGroup
    # Set helper only for redo:
    # The bead pointer will point to an 'afterGroup' bead for undo.
    bunch.undoHelper = u.undoGroup
    bunch.redoHelper = u.redoGroup
    bunch.items = []
    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
</t>
<t tx="ekr.20050318085432.2">def createCommonBunch(self, p: Position) -&gt; g.Bunch:
    """Return a bunch containing all common undo info.
    This is mostly the info for recreating an empty node at position p."""
    c = self.c
    w = c.frame.body.wrapper
    return g.Bunch(
        oldMarked=p and p.isMarked(),
        oldSel=w.getSelectionRange() if w else None,
        p=p.copy() if p else None,
    )
</t>
<t tx="ekr.20050318085432.3"></t>
<t tx="ekr.20050318085432.4"></t>
<t tx="ekr.20050318085432.6">def redoGroup(self) -&gt; None:
    """Process beads until the matching 'afterGroup' bead is seen."""
    c, u = self.c, self
    # Remember these values.
    newSel = u.newSel
    p = u.p.copy()  # Exists now, but may not exist later.
    newP = u.newP.copy()  # May not exist now, but must exist later.
    if g.unitTesting:
        assert c.positionExists(p), repr(p)
    u.groupCount += 1
    bunch = u.beads[u.bead + 1]
    count = 0
    if not hasattr(bunch, 'items'):
        g.trace(f"oops: expecting bunch.items. got bunch.kind = {bunch.kind}")
        g.trace(bunch)
    else:
        for z in bunch.items:
            self.setIvarsFromBunch(z)
            if z.redoHelper:
                z.redoHelper()
                count += 1
            else:
                g.trace(f"oops: no redo helper for {u.undoType} {p.h}")
    u.groupCount -= 1
    u.updateMarks('new')  # Bug fix: Leo 4.4.6.
    if not g.unitTesting and u.verboseUndoGroup:
        g.es("redo", count, "instances")
    # Helpers set dirty bits.
    # Set c.p, independently of helpers.
    if g.unitTesting:
        assert c.positionExists(newP), repr(newP)
    c.selectPosition(newP)
    # Set the selection, independently of helpers.
    if newSel:
        i, j = newSel
        c.frame.body.wrapper.setSelectionRange(i, j)
</t>
<t tx="ekr.20050318085432.7">def redoNodeContents(self) -&gt; None:
    c, u = self.c, self
    w = c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    # Restore the body.
    u.p.setBodyString(u.newBody)
    w.setAllText(u.newBody)
    c.frame.body.recolor(u.p)
    # Restore the headline.
    u.p.initHeadString(u.newHead)
    # This is required so.  Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.newHead)  # New in 4.4b2.
    if u.groupCount == 0 and u.newSel:
        i, j = u.newSel
        w.setSelectionRange(i, j)
    if u.groupCount == 0 and u.newYScroll is not None:
        w.setYScrollPosition(u.newYScroll)
    u.updateMarks('new')
    u.p.setDirty()
</t>
<t tx="ekr.20050318085432.8">def redoTree(self) -&gt; None:
    """Redo replacement of an entire tree."""
    c, u = self.c, self
    u.p = self.undoRedoTree(u.oldTree, u.newTree)
    u.p.setDirty()
    c.selectPosition(u.p)  # Does full recolor.
    if u.newSel:
        i, j = u.newSel
        c.frame.body.wrapper.setSelectionRange(i, j)
</t>
<t tx="ekr.20050318085713">def undoGroup(self) -&gt; None:
    """Process beads until the matching 'beforeGroup' bead is seen."""
    c, u = self.c, self
    # Remember these values.
    oldSel = u.oldSel
    p = u.p.copy()  # May not exist now, but must exist later.
    newP = u.newP.copy()  # Must exist now, but may not exist later.
    if g.unitTesting:
        assert c.positionExists(newP), repr(newP)
    u.groupCount += 1
    bunch = u.beads[u.bead]
    count = 0
    if not hasattr(bunch, 'items'):
        g.trace(f"oops: expecting bunch.items. got bunch.kind = {bunch.kind}")
        g.trace(bunch)
    else:
        # Important bug fix: 9/8/06: reverse the items first.
        reversedItems = bunch.items[:]
        reversedItems.reverse()
        for z in reversedItems:
            self.setIvarsFromBunch(z)
            if z.undoHelper:
                z.undoHelper()
                count += 1
            else:
                g.trace(f"oops: no undo helper for {u.undoType} {p.v}")
    u.groupCount -= 1
    u.updateMarks('old')  # Bug fix: Leo 4.4.6.
    if not g.unitTesting and u.verboseUndoGroup:
        g.es("undo", count, "instances")
    # Helpers set dirty bits.
    # Set c.p, independently of helpers.
    if g.unitTesting:
        assert c.positionExists(p), repr(p)
    c.selectPosition(p)
    # Restore the selection, independently of helpers.
    if oldSel:
        i, j = oldSel
        c.frame.body.wrapper.setSelectionRange(i, j)
</t>
<t tx="ekr.20050318085713.1">def undoNodeContents(self) -&gt; None:
    """
    Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    """
    c, u = self.c, self
    w = c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    u.p.b = u.oldBody
    w.setAllText(u.oldBody)
    c.frame.body.recolor(u.p)
    u.p.h = u.oldHead
    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.oldHead)
    if u.groupCount == 0 and u.oldSel:
        i, j = u.oldSel
        w.setSelectionRange(i, j)
    if u.groupCount == 0 and u.oldYScroll is not None:
        w.setYScrollPosition(u.oldYScroll)
    u.updateMarks('old')
</t>
<t tx="ekr.20050318085713.2">def undoTree(self) -&gt; None:
    """Redo replacement of an entire tree."""
    c, u = self.c, self
    u.p = self.undoRedoTree(u.newTree, u.oldTree)
    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)  # Does full recolor.
    if u.oldSel:
        i, j = u.oldSel
        c.frame.body.wrapper.setSelectionRange(i, j)
</t>
<t tx="ekr.20050408100042">def undoRedoTree(self, new_data: g.Bunch, old_data: g.Bunch) -&gt; Position:
    """Replace p and its subtree using old_data during undo."""
    # Same as undoReplace except uses g.Bunch.
    c, p, u = self.c, self.c.p, self
    if new_data is None:
        # This is the first time we have undone the operation.
        # Put the new data in the bead.
        bunch = u.beads[u.bead]
        bunch.newTree = u.saveTree(p.copy())
        u.beads[u.bead] = bunch
    # Replace data in tree with old data.
    u.restoreTree(old_data)
    c.setBodyString(p, p.b)  # This is not a do-nothing.
    return p  # Nothing really changes.
</t>
<t tx="ekr.20050410095424">def updateMarks(self, oldOrNew: str) -&gt; None:
    """Update dirty and marked bits."""
    c, u = self.c, self
    if oldOrNew not in ('new', 'old'):  # pragma: no cover
        g.trace("can't happen")
        return
    isOld = oldOrNew == 'old'
    marked = u.oldMarked if isOld else u.newMarked
    # Note: c.set/clearMarked call a hook.
    if marked:
        c.setMarked(u.p)
    else:
        c.clearMarked(u.p)
    # Undo/redo always set changed/dirty bits because the file may have been saved.
    u.p.setDirty()
    u.c.setChanged()
</t>
<t tx="ekr.20050410110215">def beforeMoveNode(self, p: Position) -&gt; g.Bunch:
    u = self
    bunch = u.createCommonBunch(p)
    bunch.oldN = p.childIndex()
    bunch.oldParent_v = p._parentVnode()
    return bunch
</t>
<t tx="ekr.20050410110343">def afterMoveNode(self, p: Position, command: str, bunch: g.Bunch) -&gt; None:
    u = self
    if u.redoing or u.undoing:
        return
    # Set the types &amp; helpers.
    bunch.kind = 'move'
    bunch.undoType = command
    # Set helper only for undo:
    # The bead pointer will point to an 'beforeGroup' bead for redo.
    bunch.undoHelper = u.undoMove
    bunch.redoHelper = u.redoMove
    bunch.newMarked = p.isMarked()
    bunch.newN = p.childIndex()
    bunch.newParent_v = p._parentVnode()
    bunch.newP = p.copy()
    u.pushBead(bunch)
</t>
<t tx="ekr.20050411111847">def redoMove(self) -&gt; None:
    c, u = self.c, self
    cc = c.chapterController
    v = u.p.v
    assert u.oldParent_v
    assert u.newParent_v
    assert v
    if cc:
        cc.selectChapterByName('main')
    # Adjust the children arrays of the old parent.
    assert u.oldParent_v.children[u.oldN] == v
    del u.oldParent_v.children[u.oldN]
    u.oldParent_v.setDirty()
    # Adjust the children array of the new parent.
    parent_v = u.newParent_v
    parent_v.children.insert(u.newN, v)
    v.parents.append(u.newParent_v)
    v.parents.remove(u.oldParent_v)
    u.newParent_v.setDirty()
    #
    u.updateMarks('new')
    u.newP.setDirty()
    c.selectPosition(u.newP)
</t>
<t tx="ekr.20050411112033">def undoMove(self) -&gt; None:
    c, u = self.c, self
    cc = c.chapterController
    if cc:
        cc.selectChapterByName('main')
    v = u.p.v
    assert u.oldParent_v
    assert u.newParent_v
    assert v
    # Adjust the children arrays.
    assert u.newParent_v.children[u.newN] == v
    del u.newParent_v.children[u.newN]
    u.oldParent_v.children.insert(u.oldN, v)
    # Recompute the parent links.
    v.parents.append(u.oldParent_v)
    v.parents.remove(u.newParent_v)
    u.updateMarks('old')
    u.p.setDirty()
    c.selectPosition(u.p)
</t>
<t tx="ekr.20050411193627.3">def beforeDeleteNode(self, p: Position) -&gt; g.Bunch:
    u = self
    bunch = u.createCommonBunch(p)
    bunch.oldBack = p.back()
    bunch.oldParent = p.parent()
    return bunch
</t>
<t tx="ekr.20050411193627.4">def beforeInsertNode(self,
    p: Position,
    pasteAsClone: bool = False,
    copiedBunchList: list[g.Bunch] = None,
) -&gt; g.Bunch:
    u = self
    if copiedBunchList is None:
        copiedBunchList = []
    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone
    if pasteAsClone:
        # Save the list of bunched.
        bunch.beforeTree = copiedBunchList
    return bunch
</t>
<t tx="ekr.20050411193627.5">def afterCloneNode(self, p: Position, command: str, bunch: g.Bunch) -&gt; None:
    u = self
    if u.redoing or u.undoing:
        return  # pragma: no cover
    # Set types &amp; helpers
    bunch.kind = 'clone'
    bunch.undoType = command
    # Set helpers
    bunch.undoHelper = u.undoCloneNode
    bunch.redoHelper = u.redoCloneNode
    bunch.newBack = p.back()  # 6/15/05
    bunch.newParent = p.parent()  # 6/15/05
    bunch.newP = p.copy()
    bunch.newMarked = p.isMarked()
    u.pushBead(bunch)
</t>
<t tx="ekr.20050411193627.8">def afterDeleteNode(self, p: Position, command: str, bunch: g.Bunch) -&gt; None:
    u = self
    if u.redoing or u.undoing:
        return
    # Set types &amp; helpers
    bunch.kind = 'delete'
    bunch.undoType = command
    # Set helpers
    bunch.undoHelper = u.undoDeleteNode
    bunch.redoHelper = u.redoDeleteNode
    bunch.newP = p.copy()
    bunch.newMarked = p.isMarked()
    u.pushBead(bunch)
</t>
<t tx="ekr.20050411193627.9">def afterInsertNode(self, p: Position, command: str, bunch: g.Bunch) -&gt; None:
    u = self
    if u.redoing or u.undoing:
        return
    # Set types &amp; helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode
    bunch.newP = p.copy()
    bunch.newBack = p.back()
    bunch.newParent = p.parent()
    bunch.newMarked = p.isMarked()
    if bunch.pasteAsClone:
        beforeTree = bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            v = bunch2.v
            afterTree.append(g.Bunch(v=v, head=v.h[:], body=v.b[:]))
        bunch.afterTree = afterTree
    u.pushBead(bunch)
</t>
<t tx="ekr.20050412080354">def beforeCloneNode(self, p: Position) -&gt; g.Bunch:
    u = self
    bunch = u.createCommonBunch(p)
    return bunch
</t>
<t tx="ekr.20050412083057">def redoCloneNode(self) -&gt; None:
    c, u = self.c, self
    cc = c.chapterController
    if cc:
        cc.selectChapterByName('main')
    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent, 0)
    else:
        u.newP._linkAsRoot()
    c.selectPosition(u.newP)
    u.newP.setDirty()
</t>
<t tx="ekr.20050412083057.1">def undoCloneNode(self) -&gt; None:
    c, u = self.c, self
    cc = c.chapterController
    if cc:
        cc.selectChapterByName('main')
    c.selectPosition(u.newP)
    c.deleteOutline()
    u.p.setDirty()
    c.selectPosition(u.p)
</t>
<t tx="ekr.20050412083244">def undoHoistNode(self) -&gt; None:
    c, u = self.c, self
    u.p.setDirty()
    c.selectPosition(u.p)
    c.dehoist()

def undoDehoistNode(self) -&gt; None:
    c, u = self.c, self
    u.p.setDirty()
    c.selectPosition(u.p)
    c.hoist()
</t>
<t tx="ekr.20050412084055">def undoDeleteNode(self) -&gt; None:
    c, u = self.c, self
    if u.oldBack:
        u.p._linkAfter(u.oldBack)
    elif u.oldParent:
        u.p._linkAsNthChild(u.oldParent, 0)
    else:
        u.p._linkAsRoot()
    u.p.setDirty()
    c.selectPosition(u.p)
</t>
<t tx="ekr.20050412084532">def redoInsertNode(self) -&gt; None:
    c, u = self.c, self
    cc = c.chapterController
    if cc:
        cc.selectChapterByName('main')
    if u.newBack:
        u.newP._linkAfter(u.newBack)
    elif u.newParent:
        u.newP._linkAsNthChild(u.newParent, 0)
    else:
        u.newP._linkAsRoot()
    if u.pasteAsClone:
        for bunch in u.afterTree:
            v = bunch.v
            if u.newP.v == v:
                u.newP.b = bunch.body
                u.newP.h = bunch.head
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
    u.newP.setDirty()
    c.selectPosition(u.newP)
</t>
<t tx="ekr.20050412085112">def undoInsertNode(self) -&gt; None:
    c, u = self.c, self
    cc = c.chapterController
    if cc:
        cc.selectChapterByName('main')
    u.newP.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.newP)
    # Bug fix: 2016/03/30.
    # This always selects the proper new position.
    # c.selectPosition(u.p)
    c.deleteOutline()
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            v = bunch.v
            if u.p.v == v:
                u.p.b = bunch.body
                u.p.h = bunch.head
            else:
                v.setBodyString(bunch.body)
                v.setHeadString(bunch.head)
</t>
<t tx="ekr.20050412085138.1">def redoHoistNode(self) -&gt; None:
    c, u = self.c, self
    u.p.setDirty()
    c.selectPosition(u.p)
    c.hoist()

def redoDehoistNode(self) -&gt; None:
    c, u = self.c, self
    u.p.setDirty()
    c.selectPosition(u.p)
    c.dehoist()
</t>
<t tx="ekr.20050415170737.1">def createVnodeUndoInfo(self, v: VNode) -&gt; g.Bunch:
    """Create a bunch containing all info needed to recreate a VNode for undo."""
    bunch = g.Bunch(
        v=v,
        statusBits=v.statusBits,
        parents=v.parents[:],
        children=v.children[:],
    )
    if hasattr(v, 'unknownAttributes'):
        bunch.unknownAttributes = v.unknownAttributes
    return bunch
</t>
<t tx="ekr.20050415170737.2">def restoreVnodeUndoInfo(self, bunch: g.Bunch) -&gt; None:
    """Restore all ivars saved in the bunch."""
    v = bunch.v
    v.statusBits = bunch.statusBits
    v.children = bunch.children
    v.parents = bunch.parents
    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = True
</t>
<t tx="ekr.20050415170812.2">def restoreTnodeUndoInfo(self, bunch: g.Bunch) -&gt; None:
    v = bunch.v
    v.h = bunch.headString
    v.b = bunch.bodyString
    v.statusBits = bunch.statusBits
    uA = bunch.get('unknownAttributes')
    if uA is not None:
        v.unknownAttributes = uA
        v._p_changed = True
</t>
<t tx="ekr.20050416092908.1"></t>
<t tx="ekr.20050418084539">def computeVnodeInfoDict(c: Cmdr) -&gt; dict[VNode, Any]:
    """
    We don't know yet which nodes will be affected by the paste, so we remember
    everything. This is expensive, but foolproof.

    The alternative is to try to remember the 'before' values of nodes in the
    FileCommands read logic. Several experiments failed, and the code is very ugly.
    In short, it seems wise to do things the foolproof way.
    """
    d = {}
    for v in c.all_unique_nodes():
        if v not in d:
            d[v] = g.Bunch(v=v, head=v.h, body=v.b)
    return d
</t>
<t tx="ekr.20050418084539.2">def computeCopiedBunchList(
    c: Cmdr,
    pasted: Position,
    vnodeInfoDict: dict[VNode, Any],
) -&gt; list[Any]:
    """Create a dict containing only copied vnodes."""
    d = {}
    for p in pasted.self_and_subtree(copy=False):
        d[p.v] = p.v
    aList = []
    for v in vnodeInfoDict:
        if d.get(v):
            bunch = vnodeInfoDict.get(v)
            aList.append(bunch)
    return aList
</t>
<t tx="ekr.20050424161505">def afterClearRecentFiles(self, bunch: g.Bunch) -&gt; None:
    u = self
    bunch.newRecentFiles = g.app.config.recentFiles[:]
    bunch.undoType = 'Clear Recent Files'
    bunch.undoHelper = u.undoClearRecentFiles
    bunch.redoHelper = u.redoClearRecentFiles
    u.pushBead(bunch)
    return bunch
</t>
<t tx="ekr.20050424161505.1">def beforeClearRecentFiles(self) -&gt; g.Bunch:
    u = self
    p = u.c.p
    bunch = u.createCommonBunch(p)
    bunch.oldRecentFiles = g.app.config.recentFiles[:]
    return bunch
</t>
<t tx="ekr.20050424170219">def redoClearRecentFiles(self) -&gt; None:
    c, u = self.c, self
    rf = g.app.recentFilesManager
    rf.setRecentFiles(u.newRecentFiles[:])
    rf.createRecentFilesMenuItems(c)
</t>
<t tx="ekr.20050424170219.1">def undoClearRecentFiles(self) -&gt; None:
    c, u = self.c, self
    rf = g.app.recentFilesManager
    rf.setRecentFiles(u.oldRecentFiles[:])
    rf.createRecentFilesMenuItems(c)
</t>
<t tx="ekr.20050525151449">def trace(self) -&gt; None:  # pragma: no cover
    ivars = ('kind', 'undoType')
    for ivar in ivars:
        g.pr(ivar, getattr(self, ivar))
</t>
<t tx="ekr.20050526124257">def afterMark(self, p: Position, command: str, bunch: g.Bunch) -&gt; None:
    """Create an undo node for mark and unmark commands."""
    # 'command' unused, but present for compatibility with similar methods.
    u = self
    if u.redoing or u.undoing:
        return  # pragma: no cover
    # Set the type &amp; helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark
    bunch.newMarked = p.isMarked()
    u.pushBead(bunch)
</t>
<t tx="ekr.20050526124906">def undoMark(self) -&gt; None:
    c, u = self.c, self
    u.updateMarks('old')
    if u.groupCount == 0:
        u.p.setDirty()
        c.selectPosition(u.p)
</t>
<t tx="ekr.20050526125801">def redoMark(self) -&gt; None:
    c, u = self.c, self
    u.updateMarks('new')
    if u.groupCount == 0:
        u.p.setDirty()
        c.selectPosition(u.p)
</t>
<t tx="ekr.20050526131252">def beforeMark(self, p: Position, command: str) -&gt; g.Bunch:
    u = self
    bunch = u.createCommonBunch(p)
    bunch.kind = 'mark'
    bunch.undoType = command
    return bunch
</t>
<t tx="ekr.20050721093241">@nobeautify
@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1.

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.

- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20050819064157">def objToString(obj: Any, *, indent: int = 0, tag: str = None, width: int = 120) -&gt; str:
    """Pretty print any Python object to a string."""
    if isinstance(obj, dict):
        result_list = ['{\n']
        pad = max([len(key) for key in obj])
        for key in sorted(obj):
            pad_s = ' ' * max(0, pad - len(key))
            result_list.append(f"  {pad_s}{key}: {obj.get(key)}\n")
        result_list.append('}')
        result = ''.join(result_list)
    elif isinstance(obj, (list, tuple)):
        # Return the enumerated lines of the list.
        result_list = ['[\n' if isinstance(obj, list) else '(\n']
        for i, z in enumerate(obj):
            result_list.append(f"  {i:4}: {z!r}\n")
        result_list.append(']\n' if isinstance(obj, list) else ')\n')
        result = ''.join(result_list)
    elif not isinstance(obj, str):
        result = pprint.pformat(obj, indent=indent, width=width)
        # Put opening/closing delims on separate lines.
        if result.count('\n') &gt; 0 and result[0] in '([{' and result[-1] in ')]}':
            result = f"{result[0]}\n{result[1:-2]}\n{result[-1]}"
    elif '\n' not in obj:
        result = repr(obj)
    else:
        # Return the enumerated lines of the string.
        lines = ''.join([
            f"  {i:4}: {z!r}\n" for i, z in enumerate(g.splitLines(obj))
        ])
        result = f"[\n{lines}]\n"
    return f"{tag.strip()}: {result}" if tag and tag.strip() else result

toString = objToString
dictToString = objToString
listToString = objToString
tupleToString = objToString
</t>
<t tx="ekr.20051009045404">def createFirstTreeNode(self) -&gt; VNode:
    c = self.c
    #
    # #1631: Initialize here, not in p._linkAsRoot.
    c.hiddenRootNode.children = []
    #
    # #1817: Clear the gnxDict.
    c.fileCommands.gnxDict = {}
    #
    # Create the first node.
    v = leoNodes.VNode(context=c)
    p = leoNodes.Position(v)
    v.initHeadString("newHeadline")
    #
    # New in Leo 4.5: p.moveToRoot would be wrong:
    #                 the node hasn't been linked yet.
    p._linkAsRoot()
    return v
</t>
<t tx="ekr.20051031040240" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032302d31312d31307103752e"></t>
<t tx="ekr.20060127052111.1">def cutStack(self) -&gt; None:
    u = self
    n = u.max_undo_stack_size
    if u.bead &gt;= n &gt; 0 and not g.unitTesting:
        # Do nothing if we are in the middle of creating a group.
        i = len(u.beads) - 1
        while i &gt;= 0:
            bunch = u.beads[i]
            if hasattr(bunch, 'kind') and bunch.kind == 'beforeGroup':
                return
            i -= 1
        # This work regardless of how many items appear after bead n.
            # g.trace('Cutting undo stack to %d entries' % (n))
        u.beads = u.beads[-n :]
        u.bead = n - 1
    if 'undo' in g.app.debug and 'verbose' in g.app.debug:  # pragma: no cover
        print(f"u.cutStack: {len(u.beads):3}")
</t>
<t tx="ekr.20060127070008">def setIvarsFromBunch(self, bunch: g.Bunch) -&gt; None:
    u = self
    u.clearOptionalIvars()
    if False and not g.unitTesting:  # Debugging. # pragma: no cover
        print('-' * 40)
        for key in list(bunch.keys()):
            g.trace(f"{key:20} {bunch.get(key)!r}")
        print('-' * 20)
    # bunch is not a dict, so bunch.keys() is required.
    for key in list(bunch.keys()):
        val = bunch.get(key)
        setattr(u, key, val)
        if key not in u.optionalIvars:
            u.optionalIvars.append(key)
</t>
<t tx="ekr.20060127113243">def pushBead(self, bunch: g.Bunch) -&gt; None:
    u = self
    # New in 4.4b2:  Add this to the group if it is being accumulated.
    bunch2 = u.bead &gt;= 0 and u.bead &lt; len(u.beads) and u.beads[u.bead]
    if bunch2 and hasattr(bunch2, 'kind') and bunch2.kind == 'beforeGroup':
        # Just append the new bunch the group's items.
        bunch2.items.append(bunch)
    else:
        # Push the bunch.
        u.bead += 1
        u.beads[u.bead:] = [bunch]
        # Recalculate the menu labels.
        u.setUndoTypes()
    if 'undo' in g.app.debug:  # pragma: no cover
        print(f"u.pushBead: {len(u.beads):3} {bunch.undoType}")
</t>
<t tx="ekr.20060328125248.17">def createIconButton(self,
    args: Any,
    text: str,
    command: Callable,
    statusLine: str,
    bg: str=None,
    kind: str=None,
) -&gt; Wrapper:
    """
    Create one icon button.
    This method creates all scripting icon buttons.

    - Creates the actual button and its balloon.
    - Adds the button to buttonsDict.
    - Registers command with the shortcut.
    - Creates x amd delete-x-button commands, where x is the cleaned button name.
    - Binds a right-click in the button to a callback that deletes the button.
    """
    c = self.c
    # Create the button and add it to the buttons dict.
    commandName = self.cleanButtonText(text)
    # Truncate only the text of the button, not the command name.
    truncatedText = self.truncateButtonText(commandName)
    if not truncatedText.strip():
        g.error('%s ignored: no cleaned text' % (text.strip() or ''))
        return None
    # Command may be None.
    b = self.iconBar.add(text=truncatedText, command=command, kind=kind)
    if not b:
        return None
    self.setButtonColor(b, bg)
    self.buttonsDict[b] = truncatedText
    if statusLine:
        self.createBalloon(b, statusLine)
    if command:
        self.registerAllCommands(
            args=args,
            func=command,
            h=text,
            pane='button',
            source_c=c,
            tag='icon button')

    def deleteButtonCallback(event: Event=None, self: Any=self, b: Widget=b) -&gt; None:
        self.deleteButton(b, event=event)

    # Register the delete-x-button command.
    deleteCommandName = 'delete-%s-button' % commandName
    c.k.registerCommand(
        # allowBinding=True,
        commandName=deleteCommandName,
        func=deleteButtonCallback,
        pane='button',
        shortcut=None,
    )
    # Reporting this command is way too annoying.
    return b
</t>
<t tx="ekr.20060904141220.34">def doOutlineAttributes(self, attrs):
    node = self.node
    for bunch in self.attrsToList(attrs):
        name, val = bunch.name, bunch.val
        if name == 'text':  # Text is the 'official' opml attribute for headlines.
            node.headString = val
        elif name in ('_note', 'leo:body'):
            # Android outliner uses _note.
            node.bodyString = val
        elif name == 'leo:v':
            node.gnx = val
        else:
            node.attributes[name] = val
</t>
<t tx="ekr.20060904165452.1">from __future__ import annotations
from collections.abc import Callable
import copy
import os
import time
import uuid
from typing import Any, Generator, Optional, TYPE_CHECKING
from leo.core import leoGlobals as g
from leo.core import signal_manager

# Third party.
try:
    import ksuid  # pylint: disable=import-error
except Exception:
    ksuid = None

if TYPE_CHECKING:  # pragma: no cover
    from leo.core.leoCommands import Commands as Cmdr
</t>
<t tx="ekr.20060914171659.2"># node is a NodeClass object, parent_v is a VNode.

def createChildren(self, c, node, parent_v):
    children = []
    for child in node.children:
        gnx = child.gnx
        v = gnx and self.generated_gnxs.get(gnx)
        if not v:
            v = self.createVnode(c, child, v)
            self.createChildren(c, child, v)
        children.append(v)
    parent_v.children = children
    for child in children:
        child.parents.append(parent_v)
    return children
</t>
<t tx="ekr.20060917190349">def startOutline(self, attrs):
    if self.inElement('head'):
        self.error('&lt;outline&gt; inside &lt;head&gt;')
    if not self.inElement('body'):
        self.error('&lt;outline&gt; outside &lt;body&gt;')
    self.level += 1
    if self.rootNode:
        parent = self.node
    else:
        self.rootNode = parent = NodeClass()  # The dummy parent node.
        parent.headString = 'dummyNode'
    self.node = NodeClass()
    parent.children.append(self.node)
    self.doOutlineAttributes(attrs)
    self.nodeStack.append(parent)
</t>
<t tx="ekr.20060920203352">def findRootPosition(self) -&gt; Position:
    # 2011/02/25: always use c.rootPosition
    p = self
    c = p.v.context
    return c.rootPosition()
</t>
<t tx="ekr.20061006092649">def archivedPosition(self, root_p: Optional[Position] = None) -&gt; list[int]:
    """Return a representation of a position suitable for use in .leo files."""
    p = self
    if root_p is None:
        aList = [z._childIndex for z in p.self_and_parents()]
    else:
        aList = []
        for z in p.self_and_parents(copy=False):
            if z == root_p:
                aList.append(0)
                break
            else:
                aList.append(z._childIndex)
    aList.reverse()
    return aList
</t>
<t tx="ekr.20061106105812.1"># Recreate the text using the present body text.
body = p.b
body = g.checkUnicode(body)
body_lines = body.split('\n')
s = []
if leading &gt; 0:
    s.extend(body_lines[:leading])
if oldMidLines:
    s.extend(oldMidLines)
if trailing &gt; 0:
    s.extend(body_lines[-trailing :])
s = '\n'.join(s)
# Remove trailing newlines in s.
while s and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines &gt; 0:
    s = s + '\n' * oldNewlines
result = s
</t>
<t tx="ekr.20061119120006">def addIconButton(self, *args: str, **keys: str) -&gt; None:
    if self.iconBar:
        return self.iconBar.add(*args, **keys)
    return None

def addIconRow(self) -&gt; None:
    if self.iconBar:
        return self.iconBar.addRow()
    return None

def addIconWidget(self, w: Wrapper) -&gt; None:
    if self.iconBar:
        return self.iconBar.addWidget(w)
    return None

def clearIconBar(self) -&gt; None:
    if self.iconBar:
        return self.iconBar.clear()
    return None

def createIconBar(self) -&gt; Union[NullIconBarClass, QtIconBarClass]:
    c = self.c
    if not self.iconBar:
        self.iconBar = self.iconBarClass(c, None)
    return self.iconBar

def getIconBar(self) -&gt; Union[NullIconBarClass, QtIconBarClass]:
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c, None)
    return self.iconBar

getIconBarObject = getIconBar

def getNewIconFrame(self) -&gt; None:
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c, None)
    return self.iconBar.getNewFrame()

def hideIconBar(self) -&gt; None:
    if self.iconBar:
        self.iconBar.hide()

def showIconBar(self) -&gt; None:
    if self.iconBar:
        self.iconBar.show()
</t>
<t tx="ekr.20070301165343">def addRow(self, height: str = None) -&gt; None:
    pass

def addRowIfNeeded(self) -&gt; None:
    pass

def addWidget(self, w: Wrapper) -&gt; None:
    pass

def createChaptersIcon(self) -&gt; None:
    pass

def deleteButton(self, w: Wrapper) -&gt; None:
    pass

def getNewFrame(self) -&gt; None:
    return None

def hide(self) -&gt; None:
    pass

def show(self) -&gt; None:
    pass
</t>
<t tx="ekr.20070418073400">def printSettings(self) -&gt; None:
    """
    Print the value of every setting, except key bindings, commands, and
    open-with tables.

    The following shows where the each setting comes from:

    -     leoSettings.leo,
    -  @  @button, @command, @mode.
    - [D] default settings.
    - [F] indicates the file being loaded,
    - [M] myLeoSettings.leo,
    - [T] theme .leo file.
    """
    legend = '''\
legend:
    leoSettings.leo
 @  @button, @command, @mode
[D] default settings
[F] loaded .leo File
[M] myLeoSettings.leo
[T] theme .leo file.
'''
    c = self.c
    if g.unitTesting:
        return
    legend = textwrap.dedent(legend)
    result = []
    for name, val, _c, letter in g.app.config.config_iter(c):
        kind = '   ' if letter == ' ' else f"[{letter}]"
        result.append(f"{kind} {name} = {val}\n")
    # Use a single g.es statement.
    result.append('\n' + legend)
    g.es_print('', ''.join(result), tabName='Settings')
</t>
<t tx="ekr.20070615134813">def goNext(self) -&gt; Optional[Position]:
    """Select the next node, if possible."""
    if self.beadPointer + 1 &lt; len(self.beadList):
        self.beadPointer += 1
        p, chapter = self.beadList[self.beadPointer]
        self.select(p, chapter)
        return p
    return None
</t>
<t tx="ekr.20070806105721.1">@g.commander_command('read-at-auto-nodes')
def readAtAutoNodes(self: Self, event: Event = None) -&gt; None:
    """
    Read all @auto nodes in the presently selected outline.

    This command is not undoable.
    """
    c = self
    c.endEditing()
    c.init_error_dialogs()
    c.importCommands.readAtAutoNodes()
    c.redraw()
    c.raise_error_dialogs(kind='read')
    c.undoer.clearAndWarn('read-at-auto-nodes')
</t>
<t tx="ekr.20071113084440"># These plugins are for testing Leo's own plugin loading logic.
# There is no reason ever to enable these plugins.</t>
<t tx="ekr.20080410115129.1">def checkPaste(self, parent: Position, p: Position) -&gt; bool:
    """Return True if p may be pasted as a child of parent."""
    if not parent:
        return True
    parents = list(parent.self_and_parents())
    for p in p.self_and_subtree(copy=False):
        for z in parents:
            if p.v == z.v:
                g.warning('Invalid paste: nodes may not descend from themselves')
                return False
    return True
</t>
<t tx="ekr.20080412053100.5">@language rest
</t>
<t tx="ekr.20080416161551.190">def __init__(self, v: VNode, childIndex: int = 0, stack: Optional[list] = None) -&gt; None:
    """Create a new position with the given childIndex and parent stack."""
    self._childIndex = childIndex
    self.v = v
    # Stack entries are tuples (v, childIndex).
    if stack:
        self.stack = stack[:]  # Creating a copy here is safest and best.
    else:
        self.stack = []
    g.app.positions += 1
</t>
<t tx="ekr.20080416161551.191">def key(self) -&gt; str:
    p = self
    # For unified nodes we must include a complete key,
    # so we can distinguish between clones.
    result = []
    for z in p.stack:
        v, childIndex = z
        result.append(f"{id(v)}:{childIndex}")
    result.append(f"{id(p.v)}:{p._childIndex}")
    return '.'.join(result)

def sort_key(self, p: Position) -&gt; list[int]:
    """Used as a sort function, which explains "redundant" argument."""
    return [int(s.split(':')[1]) for s in p.key().split('.')]

# Positions should *not* be hashable.
#
# From https://docs.python.org/3/reference/datamodel.html#object.__hash__
#
# If a class defines mutable objects and implements an __eq__() method, it
# should not implement __hash__(), since the implementation of hashable
# collections requires that a key’s hash value is immutable (if the object’s
# hash value changes, it will be in the wrong hash bucket).

# #1557: To keep mypy happy, don't define __hash__ at all.
# __hash__ = None
</t>
<t tx="ekr.20080416161551.192">def hasBack(self) -&gt; bool:
    p = self
    return bool(p.v and p._childIndex &gt; 0)

def hasNext(self) -&gt; bool:
    p = self
    try:
        parent_v = p._parentVnode()  # Returns None if p.v is None.
        return bool(p.v and parent_v and p._childIndex + 1 &lt; len(parent_v.children))
    except Exception:  # pragma: no cover
        g.trace('*** Unexpected exception')
        g.es_exception()
        return None

def hasParent(self) -&gt; bool:
    p = self
    return bool(p.v and p.stack)

def hasThreadBack(self) -&gt; bool:
    p = self
    # Much cheaper than computing the actual value.
    return bool(p.hasParent() or p.hasBack())
</t>
<t tx="ekr.20080416161551.193">def hasThreadNext(self) -&gt; bool:
    p = self
    if not p.v:
        return False
    if p.hasChildren() or p.hasNext():
        return True
    n = len(p.stack) - 1
    while n &gt;= 0:
        v, childIndex = p.stack[n]
        # See how many children v's parent has.
        if n == 0:
            parent_v = v.context.hiddenRootNode
        else:
            parent_v, junk = p.stack[n - 1]
        if len(parent_v.children) &gt; childIndex + 1:
            # v has a next sibling.
            return True
        n -= 1
    return False
</t>
<t tx="ekr.20080416161551.194">def isAncestorOf(self, p2: Position) -&gt; bool:
    """Return True if p is one of the direct ancestors of p2."""
    p = self
    c = p.v.context
    if not c.positionExists(p2):
        return False
    for z in p2.stack:
        # 2013/12/25: bug fix: test childIndices.
        # This is required for the new per-position expansion scheme.
        parent_v, parent_childIndex = z
        if parent_v == p.v and parent_childIndex == p._childIndex:
            return True
    return False
</t>
<t tx="ekr.20080416161551.196">def isVisible(self, c: Cmdr) -&gt; bool:  # pragma: no cover
    """Return True if p is visible in c's outline."""
    p = self

    def visible(p: Position, root: Optional[Position] = None) -&gt; bool:
        for parent in p.parents(copy=False):
            if parent and parent == root:
                # #12.
                return True
            if not c.shouldBeExpanded(parent):
                return False
        return True

    if c.hoistStack:  # Chapters are a form of hoist.
        root = c.hoistStack[-1].p
        if p == root:
            # #12.
            return True
        return root.isAncestorOf(p) and visible(p, root=root)
    for root in c.rootPosition().self_and_siblings(copy=False):
        if root == p or root.isAncestorOf(p):
            return visible(p)
    return False
</t>
<t tx="ekr.20080416161551.197">def level(self) -&gt; int:
    """Return the number of p's parents."""
    p = self
    return len(p.stack) if p.v else 0

simpleLevel = level
</t>
<t tx="ekr.20080416161551.199">@ These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()
</t>
<t tx="ekr.20080416161551.200">def moveToBack(self) -&gt; Position:
    """Move self to its previous sibling."""
    p = self
    n = p._childIndex
    parent_v = p._parentVnode()  # Returns None if p.v is None.
    # Do not assume n is in range: this is used by positionExists.
    if parent_v and p.v and 0 &lt; n &lt;= len(parent_v.children):
        p._childIndex -= 1
        p.v = parent_v.children[n - 1]
    else:
        p.v = None
    return p
</t>
<t tx="ekr.20080416161551.201">def moveToFirstChild(self) -&gt; Position:
    """Move a position to it's first child's position."""
    p = self
    if p.v and p.v.children:
        p.stack.append((p.v, p._childIndex),)
        p.v = p.v.children[0]
        p._childIndex = 0
    else:
        p.v = None
    return p
</t>
<t tx="ekr.20080416161551.202">def moveToLastChild(self) -&gt; Position:
    """Move a position to it's last child's position."""
    p = self
    if p.v and p.v.children:
        p.stack.append((p.v, p._childIndex),)
        n = len(p.v.children)
        p.v = p.v.children[n - 1]
        p._childIndex = n - 1
    else:
        p.v = None  # pragma: no cover
    return p
</t>
<t tx="ekr.20080416161551.203">def moveToLastNode(self) -&gt; Position:
    """Move a position to last node of its tree.

    N.B. Returns p if p has no children."""
    p = self
    # Huge improvement for 4.2.
    while p.hasChildren():
        p.moveToLastChild()
    return p
</t>
<t tx="ekr.20080416161551.204">def moveToNext(self) -&gt; Position:
    """Move a position to its next sibling."""
    p = self
    n = p._childIndex
    parent_v = p._parentVnode()  # Returns None if p.v is None.
    if p and not p.v:
        g.trace('no p.v:', p, g.callers())  # pragma: no cover
    if p.v and parent_v and len(parent_v.children) &gt; n + 1:
        p._childIndex = n + 1
        p.v = parent_v.children[n + 1]
    else:
        p.v = None
    return p
</t>
<t tx="ekr.20080416161551.205">def moveToNodeAfterTree(self) -&gt; Position:
    """Move a position to the node after the position's tree."""
    p = self
    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()
    return p
</t>
<t tx="ekr.20080416161551.206">def moveToNthChild(self, n: int) -&gt; Position:
    p = self
    if p.v and len(p.v.children) &gt; n:
        p.stack.append((p.v, p._childIndex),)
        p.v = p.v.children[n]
        p._childIndex = n
    else:
        # mypy rightly doesn't like setting p.v to None.
        # Leo's code must use the test `if p:` as appropriate.
        p.v = None  # type:ignore   # pragma: no cover
    return p
</t>
<t tx="ekr.20080416161551.207">def moveToParent(self) -&gt; Position:
    """Move a position to its parent position."""
    p = self
    if p.v and p.stack:
        p.v, p._childIndex = p.stack.pop()
    else:
        # mypy rightly doesn't like setting p.v to None.
        # Leo's code must use the test `if p:` as appropriate.
        p.v = None  # type:ignore
    return p
</t>
<t tx="ekr.20080416161551.208">def moveToThreadBack(self) -&gt; Position:
    """Move a position to it's threadBack position."""
    p = self
    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()
    return p
</t>
<t tx="ekr.20080416161551.209">def moveToThreadNext(self) -&gt; Position:
    """Move a position to threadNext position."""
    p = self
    if p.v:
        if p.v.children:
            p.moveToFirstChild()
        elif p.hasNext():
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.hasNext():
                    p.moveToNext()
                    break  #found
                p.moveToParent()
            # not found.
    return p
</t>
<t tx="ekr.20080416161551.210">def moveToVisBack(self, c: Cmdr) -&gt; Position:
    """Move a position to the position of the previous visible node."""
    p = self
    limit, limitIsVisible = c.visLimit()
    while p:
        # Short-circuit if possible.
        back = p.back()
        if back and back.hasChildren() and back.isExpanded():
            p.moveToThreadBack()
        elif back:
            p.moveToBack()
        else:
            p.moveToParent()  # Same as p.moveToThreadBack()
        if p:
            if limit:
                done, val = self.checkVisBackLimit(limit, limitIsVisible, p)
                if done:
                    return val  # A position or None
            if p.isVisible(c):
                return p
    return p
</t>
<t tx="ekr.20080416161551.211">def moveToVisNext(self, c: Cmdr) -&gt; Position:
    """Move a position to the position of the next visible node."""
    p = self
    limit, limitIsVisible = c.visLimit()
    while p:
        if p.hasChildren():
            if p.isExpanded():
                p.moveToFirstChild()
            else:
                p.moveToNodeAfterTree()
        elif p.hasNext():
            p.moveToNext()
        else:
            p.moveToThreadNext()
        if p:
            if limit and self.checkVisNextLimit(limit, p):
                return None  # pragma: no cover
            if p.isVisible(c):
                return p
    return p
</t>
<t tx="ekr.20080416161551.212">def _parentVnode(self) -&gt; VNode:
    """
    Return the parent VNode.
    Return the hiddenRootNode if there is no other parent.
    """
    p = self
    if p.v:
        data = p.stack and p.stack[-1]
        if data:
            v, junk = data
            return v
        return p.v.context.hiddenRootNode
    return None  # pragma: no cover
</t>
<t tx="ekr.20080416161551.214">def _linkAfter(self, p_after: Position) -&gt; None:
    """Link self after p_after."""
    p = self
    parent_v = p_after._parentVnode()
    p.stack = p_after.stack[:]
    p._childIndex = p_after._childIndex + 1
    child = p.v
    n = p_after._childIndex + 1
    child._addLink(n, parent_v)
</t>
<t tx="ekr.20080416161551.215">def _linkAsNthChild(self, parent: Position, n: int) -&gt; None:
    """Link self as the n'th child of the parent."""
    p = self
    parent_v = parent.v
    p.stack = parent.stack[:]
    p.stack.append((parent_v, parent._childIndex),)
    p._childIndex = n
    child = p.v
    child._addLink(n, parent_v)
</t>
<t tx="ekr.20080416161551.216">def _linkAsRoot(self) -&gt; Position:
    """Link self as the root node."""
    p = self
    assert p.v
    parent_v = p.v.context.hiddenRootNode
    assert parent_v, g.callers()
    #
    # Make p the root position.
    p.stack = []
    p._childIndex = 0
    #
    # Make p.v the first child of parent_v.
    p.v._addLink(0, parent_v)
    return p
</t>
<t tx="ekr.20080416161551.217">def _unlink(self) -&gt; None:
    """Unlink the receiver p from the tree."""
    p = self
    n = p._childIndex
    parent_v = p._parentVnode()  # returns None if p.v is None
    child = p.v
    assert p.v
    assert parent_v
    # Delete the child.
    if (0 &lt;= n &lt; len(parent_v.children) and
        parent_v.children[n] == child
    ):
        # This is the only call to v._cutlink.
        child._cutLink(n, parent_v)
    else:
        self.badUnlink(parent_v, n, child)  # pragma: no cover
</t>
<t tx="ekr.20080423062035.1"># These methods are only for the use of low-level code
# in leoNodes.py, leoFileCommands.py and leoUndo.py.
</t>
<t tx="ekr.20080425060424.10">def undoDemote(self) -&gt; None:
    c, u = self.c, self
    parent_v = u.p._parentVnode()
    n = len(u.followingSibs)
    # Remove the demoted nodes from p's children.
    u.p.v.children = u.p.v.children[: -n]
    # Add the demoted nodes to the parent's children.
    parent_v.children.extend(u.followingSibs)
    # Adjust the parent links.
    # There is no need to adjust descendant links.
    parent_v.setDirty()
    for sib in u.followingSibs:
        sib.parents.remove(u.p.v)
        sib.parents.append(parent_v)
    u.p.setAllAncestorAtFileNodesDirty()
    c.setCurrentPosition(u.p)
</t>
<t tx="ekr.20080425060424.12">def afterPromote(self, p: Position, children: list[VNode]) -&gt; None:
    """Create an undo node for demote operations."""
    u = self
    bunch = u.createCommonBunch(p)
    # Set types.
    bunch.kind = 'promote'
    bunch.undoType = 'Promote'
    bunch.undoHelper = u.undoPromote
    bunch.redoHelper = u.redoPromote
    bunch.children = children
    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
    # Recalculate the menu labels.
    u.setUndoTypes()
</t>
<t tx="ekr.20080425060424.13">def redoPromote(self) -&gt; None:
    c, u = self.c, self
    parent_v = u.p._parentVnode()
    # Add the children to parent_v's children.
    n = u.p.childIndex() + 1
    old_children = parent_v.children[:]
    # Add children up to the promoted nodes.
    parent_v.children = old_children[:n]
    # Add the promoted nodes.
    parent_v.children.extend(u.children)
    # Add the children up to the promoted nodes.
    parent_v.children.extend(old_children[n:])
    # Remove the old children.
    u.p.v.children = []
    # Adjust the parent links in the moved children.
    # There is no need to adjust descendant links.
    for child in u.children:
        child.parents.remove(u.p.v)
        child.parents.append(parent_v)
    u.p.setDirty()
    c.setCurrentPosition(u.p)
</t>
<t tx="ekr.20080425060424.14">def undoPromote(self) -&gt; None:
    c, u = self.c, self
    parent_v = u.p._parentVnode()  # The parent of the all the *promoted* nodes.
    # Remove the promoted nodes from parent_v's children.
    n = u.p.childIndex() + 1
    # Adjust the old parents children
    old_children = parent_v.children
    # Add the nodes before the promoted nodes.
    parent_v.children = old_children[:n]
    # Add the nodes after the promoted nodes.
    parent_v.children.extend(old_children[n + len(u.children) :])
    # Add the demoted nodes to v's children.
    u.p.v.children = u.children[:]
    # Adjust the parent links.
    # There is no need to adjust descendant links.
    parent_v.setDirty()
    for child in u.children:
        child.parents.remove(parent_v)
        child.parents.append(u.p.v)
    u.p.setAllAncestorAtFileNodesDirty()
    c.setCurrentPosition(u.p)
</t>
<t tx="ekr.20080425060424.2">def afterSort(self, p: Position, bunch: g.Bunch) -&gt; None:
    """Completes bead for sort operations, which was added to u.beads in beforeSort"""
    u = self
    # c = self.c
    if u.redoing or u.undoing:
        return  # pragma: no cover
    # Recalculate the menu labels.
    u.setUndoTypes()
</t>
<t tx="ekr.20080425060424.3">def beforeSort(self,
    p: Position,
    undoType: str,
    oldChildren: list[VNode],
    newChildren: list[VNode],
    sortChildren: bool,
) -&gt; g.Bunch:
    """Create an undo node for sort operations."""
    u = self
    if sortChildren:
        bunch = u.createCommonBunch(p.parent())
    else:
        bunch = u.createCommonBunch(p)
    # Set types.
    bunch.kind = 'sort'
    bunch.undoType = undoType
    bunch.undoHelper = u.undoSort
    bunch.redoHelper = u.redoSort
    bunch.oldChildren = oldChildren
    bunch.newChildren = newChildren
    bunch.sortChildren = sortChildren  # A bool
    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
    return bunch
</t>
<t tx="ekr.20080425060424.4">def redoSort(self) -&gt; None:
    c, u = self.c, self
    p = u.p
    if u.sortChildren:
        p.v.children = u.newChildren[:]
    else:
        parent_v = p._parentVnode()
        parent_v.children = u.newChildren[:]
        # Only the child index of new position changes!
        for i, v in enumerate(parent_v.children):
            if v.gnx == p.v.gnx:
                p._childIndex = i
                break
    p.setAllAncestorAtFileNodesDirty()
    c.setCurrentPosition(p)
</t>
<t tx="ekr.20080425060424.5">def undoSort(self) -&gt; None:
    c, u = self.c, self
    p = u.p
    if u.sortChildren:
        p.v.children = u.oldChildren[:]
    else:
        parent_v = p._parentVnode()
        parent_v.children = u.oldChildren[:]
        # Only the child index of new position changes!
        for i, v in enumerate(parent_v.children):
            if v.gnx == p.v.gnx:
                p._childIndex = i
                break
    p.setAllAncestorAtFileNodesDirty()
    c.setCurrentPosition(p)
</t>
<t tx="ekr.20080425060424.8">def afterDemote(self, p: Position, followingSibs: list[VNode]) -&gt; None:
    """Create an undo node for demote operations."""
    u = self
    bunch = u.createCommonBunch(p)
    # Set types.
    bunch.kind = 'demote'
    bunch.undoType = 'Demote'
    bunch.undoHelper = u.undoDemote
    bunch.redoHelper = u.redoDemote
    bunch.followingSibs = followingSibs
    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
    # Recalculate the menu labels.
    u.setUndoTypes()
</t>
<t tx="ekr.20080425060424.9">def redoDemote(self) -&gt; None:
    c, u = self.c, self
    parent_v = u.p._parentVnode()
    n = u.p.childIndex()
    # Move the demoted nodes from the old parent to the new parent.
    parent_v.children = parent_v.children[: n + 1]
    u.p.v.children.extend(u.followingSibs)
    # Adjust the parent links of the moved nodes.
    # There is no need to adjust descendant links.
    for v in u.followingSibs:
        v.parents.remove(parent_v)
        v.parents.append(u.p.v)
    u.p.setDirty()
    c.setCurrentPosition(u.p)
</t>
<t tx="ekr.20080427062528.4">def _adjustPositionBeforeUnlink(self, p2: Position) -&gt; None:
    """Adjust position p before unlinking p2."""
    # p will change if p2 is a previous sibling of p or
    # p2 is a previous sibling of any ancestor of p.
    p = self
    sib = p.copy()
    # A special case for previous siblings.
    # Adjust p._childIndex, not the stack's childIndex.
    while sib.hasBack():
        sib.moveToBack()
        if sib == p2:
            p._childIndex -= 1
            return
    # Adjust p's stack.
    stack: list[tuple[VNode, int]] = []
    changed, i = False, 0
    while i &lt; len(p.stack):
        v, childIndex = p.stack[i]
        p3 = Position(v=v, childIndex=childIndex, stack=stack[:i])
        while p3:
            if p2 == p3:
                # 2011/02/25: compare full positions, not just vnodes.
                # A match with the to-be-moved node.
                stack.append((v, childIndex - 1),)
                changed = True
                break  # terminate only the inner loop.
            p3.moveToBack()
        else:
            stack.append((v, childIndex),)
        i += 1
    if changed:
        p.stack = stack
</t>
<t tx="ekr.20080427062528.9"></t>
<t tx="ekr.20080429053831.10">def isWriteBit(self) -&gt; bool:
    v = self
    return (v.statusBits &amp; v.writeBit) != 0
</t>
<t tx="ekr.20080429053831.12">def setDirty(self) -&gt; None:
    """
    Set the vnode dirty bit.

    This method is fast, but dangerous. Unlike p.setDirty, this method does
    not call v.setAllAncestorAtFileNodesDirty.
    """
    v = self
    v.statusBits |= v.dirtyBit
    v.updateIcon()
</t>
<t tx="ekr.20080429053831.6">def hasBody(self) -&gt; bool:
    """Return True if this VNode contains body text."""
    s = self._bodyString
    return bool(s) and len(s) &gt; 0
</t>
<t tx="ekr.20080429053831.8">def clearWriteBit(self) -&gt; None:
    self.statusBits &amp;= ~self.writeBit
</t>
<t tx="ekr.20080429053831.9">def setWriteBit(self) -&gt; None:
    self.statusBits |= self.writeBit
</t>
<t tx="ekr.20080623083646.10">def dumpBead(self, n: int) -&gt; str:  # pragma: no cover
    u = self
    if n &lt; 0 or n &gt;= len(u.beads):
        return 'no bead: n = ', n
    # bunch = u.beads[n]
    result = []
    result.append('-' * 10)
    result.append(f"len(u.beads): {len(u.beads)}, n: {n}")
    for ivar in ('kind', 'newP', 'newN', 'p', 'oldN', 'undoHelper'):
        result.append(f"{ivar} = {getattr(self, ivar)}")
    return '\n'.join(result)

def dumpTopBead(self) -&gt; str:  # pragma: no cover
    u = self
    n = len(u.beads)
    if n &gt; 0:
        return self.dumpBead(n - 1)
    return '&lt;no top bead&gt;'
</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20080801071227.4">@g.commander_command('read-at-shadow-nodes')
def readAtShadowNodes(self: Self, event: Event = None) -&gt; None:
    """
    Read all @shadow nodes in the presently selected outline.

    This command is not undoable.
    """
    c, p = self, self.p
    c.endEditing()
    c.init_error_dialogs()
    c.atFileCommands.readAtShadowNodes(p)
    c.redraw()
    c.raise_error_dialogs(kind='read')
    c.undoer.clearAndWarn('read-at-shadow-nodes')
</t>
<t tx="ekr.20080805071954.2">def putDescendentVnodeUas(self, p: Position) -&gt; str:
    """
    Return the a uA field for descendent VNode attributes,
    suitable for reconstituting uA's for anonymous vnodes.
    """
    # z
    # Create aList of tuples (p,v) having a valid unknownAttributes dict.
    # Create dictionary: keys are vnodes, values are corresponding archived positions.
    aList = []
    pDict = {}
    for p2 in p.self_and_subtree(copy=False):
        if hasattr(p2.v, "unknownAttributes"):
            aList.append((p2.copy(), p2.v),)
            pDict[p2.v] = p2.archivedPosition(root_p=p)
    # Create aList of pairs (v,d) where d contains only pickleable entries.
    if aList:
        aList = self.createUaList(aList)
    if not aList:
        return ''
    # Create d, an enclosing dict to hold all the inner dicts.
    d = {}
    for v, d2 in aList:
        aList2 = [str(z) for z in pDict.get(v)]
        key = '.'.join(aList2)
        d[key] = d2
    # Pickle and hexlify d
    if not d:
        return ''
    return self.pickle(torv=p.v, val=d, tag='descendentVnodeUnknownAttributes')
</t>
<t tx="ekr.20080805085257.1">def createUaList(self, aList: list) -&gt; list[tuple[Any, dict]]:
    """
    Given aList of pairs (p,torv), return a list of pairs (torv,d)
    where d contains all picklable items of torv.unknownAttributes.
    """
    result = []
    for p, torv in aList:
        if isinstance(torv.unknownAttributes, dict):
            # Create a new dict containing only entries that can be pickled.
            d = dict(torv.unknownAttributes)  # Copy the dict.
            for key in d:
                # Just see if val can be pickled.  Suppress any error.
                ok = self.pickle(torv=torv, val=d.get(key), tag=None)
                if not ok:
                    del d[key]
                    g.warning("ignoring bad unknownAttributes key", key, "in", p.h)
            if d:
                result.append((torv, d),)
        else:
            g.warning("ignoring non-dictionary uA for", p)
    return result
</t>
<t tx="ekr.20080805085257.2">def pickle(self, torv: Any, val: Any, tag: str) -&gt; str:
    """Pickle val and return the hexlified result."""
    try:
        s = pickle.dumps(val, protocol=1)
        s2 = binascii.hexlify(s)
        s3 = g.toUnicode(s2, 'utf-8')
        field = f' {tag}="{s3}"'
        return field
    except pickle.PicklingError:
        if tag:  # The caller will print the error if tag is None.
            g.warning("ignoring non-pickleable value", val, "in", torv)
        return ''
    except Exception:
        g.error("fc.pickle: unexpected exception in", torv)
        g.es_exception()
        return ''
</t>
<t tx="ekr.20080920052058.3">def __eq__(self, p2: Any) -&gt; bool:  # Use Any, not Position.
    """Return True if two positions are equivalent."""
    p1 = self
    # Don't use g.trace: it might call p.__eq__ or p.__ne__.
    if not isinstance(p2, Position):
        return False
    if p2 is None or p2.v is None:
        return p1.v is None
    return (p1.v == p2.v and
        p1._childIndex == p2._childIndex and
        p1.stack == p2.stack)

def __ne__(self, p2: Any) -&gt; bool:  # Use Any, not Position.
    """Return True if two positions are not equivalent."""
    return not self.__eq__(p2)
</t>
<t tx="ekr.20090128083459.74"></t>
<t tx="ekr.20090128083459.75">def __get_b(self) -&gt; str:
    """Return the body text of a position."""
    p = self
    return p.bodyString()

def __set_b(self, val: str) -&gt; None:
    """
    Set the body text of a position.

    **Warning: the p.b = whatever is *expensive* because it calls
    c.setBodyString().

    Usually, code *should* use this setter, despite its cost, because it
    update's Leo's outline pane properly. Calling c.redraw() is *not*
    enough.

    This performance gotcha becomes important for repetitive commands, like
    cff, replace-all and recursive import. In such situations, code should
    use p.v.b instead of p.b.
    """
    p = self
    c = p.v and p.v.context
    if c:
        c.setBodyString(p, val)
        # Warning: c.setBodyString is *expensive*.

b = property(
    __get_b, __set_b,
    doc="position body string property")
</t>
<t tx="ekr.20090128083459.76">def __get_h(self) -&gt; str:
    p = self
    return p.headString()

def __set_h(self, val: str) -&gt; None:
    """
    Set the headline text of a position.

    **Warning: the p.h = whatever is *expensive* because it calls
    c.setHeadString().

    Usually, code *should* use this setter, despite its cost, because it
    update's Leo's outline pane properly. Calling c.redraw() is *not*
    enough.

    This performance gotcha becomes important for repetitive commands, like
    cff, replace-all and recursive import. In such situations, code should
    use p.v.h instead of p.h.
    """
    p = self
    c = p.v and p.v.context
    if c:
        c.setHeadString(p, val)
        # Warning: c.setHeadString is *expensive*.

h = property(
    __get_h, __set_h,
    doc="position property returning the headline string")
</t>
<t tx="ekr.20090130065000.1"></t>
<t tx="ekr.20090130114732.5">def __get_b(self) -&gt; str:
    v = self
    return v.bodyString()

def __set_b(self, val: str) -&gt; None:
    v = self
    v.setBodyString(val)

b = property(
    __get_b, __set_b,
    doc="VNode body string property")
</t>
<t tx="ekr.20090130114732.6">def __get_u(self) -&gt; dict:
    v = self
    # Wrong: return getattr(v, 'unknownAttributes', {})
    # It is does not set v.unknownAttributes, which can cause problems.
    if not hasattr(v, 'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self, val: Any) -&gt; None:
    v = self
    if val is None:
        if hasattr(v, 'unknownAttributes'):
            delattr(v, 'unknownAttributes')
    elif isinstance(val, dict):
        v.unknownAttributes = val
    else:
        raise ValueError  # pragma: no cover

u = property(
    __get_u, __set_u,
    doc="VNode u property")
</t>
<t tx="ekr.20090130125002.1">def __get_h(self) -&gt; str:
    v = self
    return v.headString()

def __set_h(self, val: str) -&gt; None:
    v = self
    v.setHeadString(val)

h = property(
    __get_h, __set_h,
    doc="VNode headline string property")
</t>
<t tx="ekr.20090215165030.1">def __get_gnx(self) -&gt; str:
    v = self
    return v.fileIndex

gnx = property(
    __get_gnx,  # __set_gnx,
    doc="VNode gnx property")
</t>
<t tx="ekr.20090215165030.3">def __get_gnx(self) -&gt; str:
    p = self
    return p.v.fileIndex

gnx = property(
    __get_gnx,  # __set_gnx,
    doc="position gnx property")
</t>
<t tx="ekr.20090225080846.3">def readOneAtEditNode(self, p: Position) -&gt; None:  # pragma: no cover
    at = self
    c = at.c
    ic = c.importCommands
    fn = c.fullPath(p)
    junk, ext = g.os_path_splitext(fn)
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fn, p)
    # if not g.unitTesting: g.es("reading: @edit %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None:
        return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    head = ''
    ext = ext.lower()
    if ext in ('.html', '.htm'):
        head = '@language html\n'
    elif ext in ('.txt', '.text'):
        head = '@nocolor\n'
    else:
        language = ic.languageForExtension(ext)
        if language and language != 'unknown_language':
            head = f"@language {language}\n"
        else:
            head = '@nocolor\n'
    p.b = head + g.toUnicode(s, encoding=encoding, reportErrors=True)
    g.doHook('after-edit', p=p)
</t>
<t tx="ekr.20090502071837.4">"""
Support for restructured text (rST).

Documentation: https://leo-editor.github.io/leo-editor/tutorial-rst3.html

Requires python's docutils_ module to generate documents from rST files.
https://pypi.org/project/docutils/
"""
</t>
<t tx="ekr.20090706110836.6135">def _addLink(self, childIndex: int, parent_v: VNode) -&gt; None:
    """Adjust links after adding a link to v."""
    v = self
    v.context.frame.tree.generation += 1
    parent_v.childrenModified()  # For a plugin.
    # Update parent_v.children &amp; v.parents.
    parent_v.children.insert(childIndex, v)
    v.parents.append(parent_v)
    # Set zodb changed flags.
    v._p_changed = True
    parent_v._p_changed = True
    # If v has only one parent, we adjust all
    # the parents links in the descendant tree.
    # This handles clones properly when undoing a delete.
    if len(v.parents) == 1:
        for child in v.children:
            child._addParentLinks(parent=v)
</t>
<t tx="ekr.20090706171333.6226">def badUnlink(self, parent_v: VNode, n: int, child: VNode) -&gt; None:  # pragma: no cover

    if 0 &lt;= n &lt; len(parent_v.children):
        g.trace(f"**can not happen: children[{n}] != p.v")
        g.trace('parent_v.children...\n',
            g.listToString(parent_v.children))
        g.trace('parent_v', parent_v)
        g.trace('parent_v.children[n]', parent_v.children[n])
        g.trace('child', child)
        g.trace('** callers:', g.callers())
        if g.unitTesting:
            assert False, 'children[%s] != p.v'  # noqa
    else:
        g.trace(
            f"**can not happen: bad child index: {n}, "
            f"len(children): {len(parent_v.children)}")
        g.trace('parent_v.children...\n',
            g.listToString(parent_v.children))
        g.trace('parent_v', parent_v, 'child', child)
        g.trace('** callers:', g.callers())
        if g.unitTesting:
            assert False, f"bad child index: {n}"  # noqa
</t>
<t tx="ekr.20090715145956.6166">def checkVisBackLimit(self,
    limit: Position,
    limitIsVisible: bool,
    p: Position,
) -&gt; tuple[bool, Optional[Position]]:
    """Return done, p or None"""
    c = p.v.context
    if limit == p:
        if limitIsVisible and p.isVisible(c):
            return True, p
        return True, None
    if limit.isAncestorOf(p):
        return False, None
    return True, None
</t>
<t tx="ekr.20090715145956.6167">def checkVisNextLimit(self, limit: Position, p: Position) -&gt; bool:  # pragma: no cover
    """Return True is p is outside limit of visible nodes."""
    return limit != p and not limit.isAncestorOf(p)
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20090804184658.6128">def _cutLink(self, childIndex: int, parent_v: VNode) -&gt; None:
    """Adjust links after cutting a link to v."""
    v = self
    v.context.frame.tree.generation += 1
    parent_v.childrenModified()
    assert parent_v.children[childIndex] == v
    del parent_v.children[childIndex]
    if parent_v in v.parents:
        try:
            v.parents.remove(parent_v)
        except ValueError:  # pragma: no cover
            g.internalError(f"{parent_v} not in parents of {v}")
            g.trace('v.parents:')
            g.printObj(v.parents)
    v._p_changed = True
    parent_v._p_changed = True
    # If v has no more parents, we adjust all
    # the parent links in the descendant tree.
    # This handles clones properly when deleting a tree.
    if not v.parents:
        for child in v.children:
            child._cutParentLinks(parent=v)
</t>
<t tx="ekr.20090804184658.6129">def _addParentLinks(self, parent: VNode) -&gt; None:

    v = self
    v.parents.append(parent)
    if len(v.parents) == 1:
        for child in v.children:
            child._addParentLinks(parent=v)
</t>
<t tx="ekr.20090804190529.6133">def _cutParentLinks(self, parent: VNode) -&gt; None:

    v = self
    v.parents.remove(parent)
    if not v.parents:
        for child in v.children:
            child._cutParentLinks(parent=v)
</t>
<t tx="ekr.20091001141621.6044">def all_positions(self, copy: bool = True) -&gt; Generator:
    """A generator return all positions of the outline, in outline order."""
    c = self
    p = c.rootPosition()
    while p:
        yield p.copy() if copy else p
        p.moveToThreadNext()

# Compatibility with old code...

all_positions_iter = all_positions
allNodes_iter = all_positions
safe_all_positions = all_positions
</t>
<t tx="ekr.20091001141621.6055">def children(self, copy: bool = True) -&gt; Generator:
    """Yield all child positions of p."""
    p = self
    p = p.firstChild()
    while p:
        yield p.copy() if copy else p
        p.moveToNext()

# Compatibility with old code...

children_iter = children
</t>
<t tx="ekr.20091001141621.6056">def subtree(self, copy: bool = True) -&gt; Generator:
    """Yield all positions in p's subtree, but not p."""
    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    while p and p != after:
        yield p.copy() if copy else p
        p.moveToThreadNext()

# Compatibility with old code...

subtree_iter = subtree
</t>
<t tx="ekr.20091001141621.6057">def self_and_siblings(self, copy: bool = True) -&gt; Generator:
    """Yield all sibling positions of p including p."""
    p = self
    p = p.copy()
    while p.hasBack():
        p.moveToBack()
    while p:
        yield p.copy() if copy else p
        p.moveToNext()

# Compatibility with old code...

self_and_siblings_iter = self_and_siblings
</t>
<t tx="ekr.20091001141621.6058">def parents(self, copy: bool = True) -&gt; Generator:
    """Yield all parent positions of p."""
    p = self
    p = p.parent()
    while p:
        yield p.copy() if copy else p
        p.moveToParent()

# Compatibility with old code...

parents_iter = parents
</t>
<t tx="ekr.20091001141621.6060"></t>
<t tx="ekr.20091001141621.6066">def self_and_subtree(self, copy: bool = True) -&gt; Generator:
    """Yield p and all positions in p's subtree."""
    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after:
        yield p.copy() if copy else p
        p.moveToThreadNext()

# Compatibility with old code...

self_and_subtree_iter = self_and_subtree
</t>
<t tx="ekr.20091002083910.6099">def self_and_parents(self, copy: bool = True) -&gt; Generator:
    """Yield p and all parent positions of p."""
    p = self
    p = p.copy()
    while p:
        yield p.copy() if copy else p
        p.moveToParent()

# Compatibility with old code...

self_and_parents_iter = self_and_parents
</t>
<t tx="ekr.20091002083910.6102">def following_siblings(self, copy: bool = True) -&gt; Generator:
    """Yield all siblings positions that follow p, not including p."""
    p = self
    p = p.next()  # pylint: disable=not-callable
    while p:
        yield p.copy() if copy else p
        p.moveToNext()

# Compatibility with old code...

following_siblings_iter = following_siblings
</t>
<t tx="ekr.20091002083910.6103">def unique_subtree(self) -&gt; Generator:
    """Yield p and all other unique positions in p's subtree."""
    p = self
    seen = set()
    for p in p.subtree():
        if p.v not in seen:
            seen.add(p.v)
            # Fixed bug 1255208: p.unique_subtree returns vnodes, not positions.
            yield p.copy() if copy else p

# Compatibility with old code...

subtree_with_unique_vnodes_iter = unique_subtree
</t>
<t tx="ekr.20091002083910.6104">def nodes(self) -&gt; Generator:
    """Yield p.v and all vnodes in p's subtree."""
    p = self
    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after:  # bug fix: 2013/10/12
        yield p.v
        p.moveToThreadNext()

# Compatibility with old code.

vnodes_iter = nodes
</t>
<t tx="ekr.20091002083910.6105">def unique_nodes(self) -&gt; Generator:
    """Yield p.v and all unique vnodes in p's subtree."""
    p = self
    seen = set()
    for p in p.self_and_subtree(copy=False):
        if p.v not in seen:
            seen.add(p.v)
            yield p.v

# Compatibility with old code.

unique_vnodes_iter = unique_nodes
</t>
<t tx="ekr.20091210082012.6230">def __ge__(self, other: Any) -&gt; bool:
    return self.__eq__(other) or self.__gt__(other)

def __le__(self, other: Any) -&gt; bool:
    return self.__eq__(other) or self.__lt__(other)

def __lt__(self, other: Any) -&gt; bool:
    return not self.__eq__(other) and not self.__gt__(other)
</t>
<t tx="ekr.20091210082012.6233">def __gt__(self, other: Any) -&gt; bool:
    """Return True if self appears after other in outline order."""
    stack1, stack2 = self.stack, other.stack
    n1, n2 = len(stack1), len(stack2)
    n = min(n1, n2)
    # Compare the common part of the stacks.
    for item1, item2 in zip(stack1, stack2):
        v1, x1 = item1
        v2, x2 = item2
        if x1 &gt; x2:
            return True
        if x1 &lt; x2:
            return False
    # Finish the comparison.
    if n1 == n2:
        x1, x2 = self._childIndex, other._childIndex
        return x1 &gt; x2
    if n1 &lt; n2:
        x1 = self._childIndex
        v2, x2 = other.stack[n]
        return x1 &gt; x2
    # n1 &gt; n2
    # 2011/07/28: Bug fix suggested by SegundoBob.
    x1 = other._childIndex
    v2, x2 = self.stack[n]
    return x2 &gt;= x1
</t>
<t tx="ekr.20091221145433.6381">def setUndoType(self, theType: str) -&gt; None:

    u = self
    frame = u.c.frame
    if not isinstance(theType, str):
        g.trace(f"oops: expected string for command, got {repr(theType)}")
        g.trace(g.callers())
        theType = '&lt;unknown&gt;'
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline = -1 if g.match(name, 0, "Can't") else 0
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;", "")
        frame.menu.setMenuLabel(
            menu, u.realUndoMenuLabel, realLabel, underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel
</t>
<t tx="ekr.20100103093121.5365"># These are experimental plugins.
</t>
<t tx="ekr.20100216141722.5622">def find_file_line(self, n: int, p: Position = None) -&gt; tuple[Position, int]:
    """
    Place the cursor on the n'th line (one-based) of an external file.

    Return (p, offset) if found or (None, -1) if not found.
    """
    c = self.c
    # Don't add an item in the history list here!
    if c.nodeHistory:
        c.nodeHistory.skipBeadUpdate = True
        try:
            p, offset = self.find_file_line_helper(n, p)
        finally:
            c.nodeHistory.skipBeadUpdate = False
        return p, offset
    p, offset = self.find_file_line_helper(n, p)
    return p, offset
</t>
<t tx="ekr.20100303074003.5636"># Called only by LeoTree.selectHelper.

def restoreCursorAndScroll(self) -&gt; None:
    """Restore the cursor position and scroll so it is visible."""
    v = self
    ins = v.insertSpot
    # start, n = v.selectionStart, v.selectionLength
    spot = v.scrollBarSpot
    body = self.context.frame.body
    w = body.wrapper
    # Fix bug 981849: incorrect body content shown.
    if ins is None:
        ins = 0
    # This is very expensive for large text.
    if hasattr(body.wrapper, 'setInsertPoint'):
        w.setInsertPoint(ins)
    # Override any changes to the scrollbar setting that might
    # have been done above by w.setSelectionRange or w.setInsertPoint.
    if spot is not None:  # pragma: no cover
        w.setYScrollPosition(spot)
        v.scrollBarSpot = spot
    # Never call w.see here.
</t>
<t tx="ekr.20100303074003.5637">def restoreCursorAndScroll(self) -&gt; None:
    self.v.restoreCursorAndScroll()

def saveCursorAndScroll(self) -&gt; None:
    self.v.saveCursorAndScroll()
</t>
<t tx="ekr.20100303074003.5638">def saveCursorAndScroll(self) -&gt; None:  # pragma: no cover

    v = self
    c = v.context
    w = c.frame.body
    if not w:
        return
    try:
        v.scrollBarSpot = w.getYScrollPosition()
        v.insertSpot = w.getInsertPoint()
    except AttributeError:
        # 2011/03/21: w may not support the high-level interface.
        pass
</t>
<t tx="ekr.20100908110845.5606">def init():
    """Return True if the plugin has loaded successfully."""
    g.plugin_signon(__name__)
    return True
</t>
<t tx="ekr.20100908115707.5554">@pagewidth 80
r""" Creates stand-alone slideshows containing screenshots.

This plugin defines the following commands:
    
- **help-for-screenshots**: print this message to Leo's log pane.
- **take-local-screen-shot**: take a screenshot of Leo's main window.
- **take-global-screen-shot**: take a screenshot of the entire screen.
- **slide-show-info**: print the settings in effect.
- **make-slide** and **make-slide-show**, collectively called **slide
  commands**, create collections of slides from **@slideshow** trees containing
  **@slide** nodes.
  
Slides may link to screenshots. The slide commands can generate screenshots from
**@screenshot-tree** nodes, but this feature has proven to be clumsy and
inflexible. It is usually more convenient to use screenshots taken with a
program such as Wink. The **meld-slides** command creates references to
externally-generated screenshots within @slide nodes.

\@slide nodes may contain **@url nodes**:
- @url nodes allow you to see various files (slides, initial screenshots,
  working files and final screenshots).
- @url nodes guide the meld script and the commands defined by this plugin By
  inserting or deleting these @url nodes you (or your scripts) can customize how
  the commands (and meld) work. In effect, the @url nodes become per-slide
  settings.

**Prerequisites**

Inkscape (Required)
  An SVG editor: http://www.inkscape.org/
  Allows the user to edit screenshots.
  Required to create final output (PNG) files.

PIL, aka pillow (Optional but highly recommended)
  pip install pillow
  https://python-pillow.org/

Wink (Optional)
  A program that creates slideshows and slides.
  http://www.debugmode.com/wink/

**Summary**

@slideshow &lt;slideshow-name&gt;
  Creates the folder:
  &lt;sphinx_path&gt;/slides/&lt;slideshow-name&gt;

@slide &lt;ignored text&gt;
  Creates slide-&lt;slide-number&gt;.html
  (in the sphinx _build directory).
  **Note**: the plugin skips any @slide nodes
  with empty body text.

@screenshot
  Specifies the contents of the screenshot.

**Options** are child nodes of @slideshow or
\@slide nodes that control the make-slide and
make-slide-show commands. See the Options section
below.

The make-slide and make-slide-show commands
create the following @url nodes as children
of each @slide node:

@url built slide
  Contains the absolute path to the final slide in
  the _build/html subfolder of the slideshow
  folder. If present, this @url node completely
  disables rebuilding the slide.

@url screenshot
  Contains the absolute path to the original
  screenshot file. If present, this @url node
  inhibits taking the screenshot.

@url working file
  Contains the absolute path to the working file.
  If present, this @url node disables taking the
  screenshot, creating the working file. The final
  output file will be regenerated if the working
  file is newer than the final output file.

@url final output file
  Contains the absolute path to the final output
  file.

Thus, to completely recreate an @slide node, you
must delete any of the following nodes that appear
as its children::

    @url screenshot
    @url working file
    @url built slide

**Making slides**

For each slide, the make-slide and make-slide-show
commands do the following:

1. Create a slide.

  If the @slide node contains an @screenshot tree,
  the plugin appends an ``.. image::`` directive
  referring to the screenshot to the body text of
  the @slide node. The plugin also creates a child
  @image node referring to the screenshot.

2. (Optional) Create a screenshot.

  The plugin creates a screenshot for an @slide
  node only if the @slide node contains an
  @screenshot node as a direct child.

  **Important**: this step has largely been
  superseded by the ``@button meld`` script in
  LeoDocs.leo.

  Taking a screenshot involves the following steps:

  A. Create the **target outline**: screenshot-setup.leo.

    The target outline contains consists of all
    the children (and their descendants) of the
    @screenshot node.

  B. Create the **screenshot**, a bitmap (PNG) file.

    The slide commands take a screen shot of the
    target outline. The @pause option opens the
    target outline but does *not* take the
    screenshot. The user must take the screenshot
    manually. For more details, see the the
    options section below.

  C. Convert the screenshot file to a **work file**.

    The work file is an SVG (Scalable Vector
    Graphics) file: http://www.w3.org/Graphics/SVG/.

  D. (Optional) Edit the work file.

    If the @slide node has a child @edit node, the
    plugin opens Inkscape so that the user can
    edit the work file.

  E. Render the **final output file**.

    The plugin calls Inkscape non-interactively to
    render the final output file (a PNG image)
    from the work file. If the Python Imaging
    Library (PIL) is available, this step will use
    PIL to improve the quality of the final output
    file.

3. Build the slide using Sphinx.

  After making all files, the plugins runs Sphinx
  by running 'make html' in the slideshow folder.
  This command creates the final .html files in the
  _build/html subfolder of the slideshow folder.

4. Create url nodes.

  Depending on options, and already-existing @url
  nodes, the make-slide and make-slide-show
  commands may create one or more of the following
  \@url nodes::

    @url built slide
    @url screenshot
    @url working file
    @url final output file

**Options and settings**

You specify options in the headlines of nodes.
**Global options** appear as direct children of
\@slideshow nodes and apply to all @slide nodes
unless overridden by a local option. **Local
options** appear as direct children of an @slide
node and apply to only to that @slide node.

**Global options nodes**

The following nodes may appear *either* as a
direct child of the @slideshow node or as the
direct child of an @slide node.

@sphinx_path = &lt;path&gt;
  This directory contains the slides directory,
  and the following files: 'conf.py',
  'Leo4-80-border.jpg', 'Makefile' and 'make.bat'.

@screenshot_height = &lt;int&gt;
  The height in pixels of screenshots.

@screenshot_width = &lt;int&gt;
  The height in pixels of screenshots.

@template_fn = &lt;path&gt;
  The absolute path to inkscape-template.svg

@title = &lt;any text&gt;
  The title to use for one slide or the entire
  slideshow.

@title_pattern = &lt;pattern&gt;
  The pattern used to generate patterns for one
  slide or the entire slideshow. The title is
  computed as follows::

    d = {
        'slideshow_name':slideshow_name,
        'slide_name':    slide_name,
        'slide_number':  sc.slide_number,
    }
    title = (pattern % (d)).title()

  If neither an @title or @title_pattern option
  node applies, the title is the headline of the
  \@slide node. If this is empty, the default
  pattern is::

    '%(slideshow_name)s:%(slide_number)s'

\@verbose = True/False
  True (or true or 1):  generate informational message.
  False (or false or 0): suppress informational messages.

\@wink_path = &lt;path&gt;
  This path contains screenshots created by wink.
  This is used only by the meld-slides command.

**Local options nodes**

The following nodes are valid only as the direct
child of an @slide node.

@callout &lt;any text&gt;
  Generates a text callout in the working .svg file.
  An @slide node may have several @callout children.

@edit = True/False
  If True (or true or 1) the plugin enters
  Inkscape interactively after taking a
  screenshot.

@markers = &lt;list of integers&gt;
  Generates 'numbered balls' in the working .svg file.

@pause = True/False
  If True (or true or 1) the user must take the
  screenshot manually. Otherwise, the plugin takes
  the screenshot automatically.

  If the slide node contains an @pause node as one
  of its directive children, the slide commands
  open the target node, but do *not* take a screen
  shot.

  The user may adjust the screen as desired, for
  example by selecting menus or showing dialogs.
  The *user* must then take the screen shot
  manually. **Important**: the screenshot need not
  be of Leo--it could be a screenshot of anything
  on the screen.

  As soon as the user closes the target
  outline, the slide commands look for the screen
  shot on the clipboard. If found, the slide
  commands save the screenshot to the screenshot
  file.

@screenshot
  The root of a tree that becomes the entire
  contents of screenshot. No screenshot is taken
  if this node does not exist.

@select &lt;headline&gt;
  Causes the given headline in the @screenshot
  outline to be selected before taking the screenshot.

**Settings**

@string screenshot-bin = &lt;path to inkscape.exe&gt;
  The full path to the Inkscape program.

**File names**

Suppose the @slide node is the n'th @slide node in
the @slideshow tree whose sanitized name is
'name'. The following files will be created in
(relative to) the slideshow directory::

    slide-n.html.txt:   the slide's rST source.
    screenshot-n.png:   the original screenshot.
    screenshot-n.svg:   the working file.
    slide-n.png:        the final output file.
    _build/html/slide-n.html: the final slide.

"""
@pagewidth 50
</t>
<t tx="ekr.20100914090933.5770">@g.command('take-screen-shot')
@g.command('take-local-screen-shot')
def start_local_screenshot(event):
    """Wait 5 seconds, then take a screen shot of Leo's main window."""
    start_screenshot('local', take_local_screenshot)

@g.command('take-global-screen-shot')
def start_global_screen_shot(event):
    """Wait 5 seconds, then take a screen shot of the entire screen."""
    start_screenshot('global', take_global_screenshot)

def start_screenshot(kind, callback):
    """Call the callback after 5 seconds."""
    global screenshot_number
    screenshot_number += 1
    print(f"I'll take a {kind} screenshot number {screenshot_number} in 5 seconds")
    QtCore.QTimer.singleShot(5000, callback)

def take_global_screenshot():
    screenshot_helper(0)

def take_local_screenshot():
    app = g.app.gui.qtApp
    screenshot_helper(app.activeWindow().winId())  # Only Leo's main window.

def screenshot_helper(window_id):
    """Take a screenshot of the given window."""
    global screenshot_number
    app = g.app.gui.qtApp
    screen = app.primaryScreen()
    if screen is not None:
        # Save to the home directory.
        file_name = os.path.normpath(os.path.expanduser(
            f"~/.leo/screenshot-{screenshot_number}.png"))
        pixmap = screen.grabWindow(window_id)
        pixmap.save(file_name, 'png')
        print(f"Screenshot saved in {file_name}")
</t>
<t tx="ekr.20101004082701.5674"></t>
<t tx="ekr.20101110092416.5709">def add_child(self, child):
    self.children.append(child)
    child.set_parent(self)
</t>
<t tx="ekr.20101110150056.9453"># Some of the most important recent plugins work only with the Qt gui.
</t>
<t tx="ekr.20101110150056.9457"></t>
<t tx="ekr.20110402084740.14490">@g.commander_command('goto-next-history-node')
def goToNextHistory(self: Self, event: Event = None) -&gt; None:
    """Go to the next node in the history list."""
    c = self
    c.nodeHistory.goNext()

@g.commander_command('goto-prev-history-node')
def goToPrevHistory(self: Self, event: Event = None) -&gt; None:
    """Go to the previous node in the history list."""
    c = self
    c.nodeHistory.goPrev()
</t>
<t tx="ekr.20110519074734.6092"></t>
<t tx="ekr.20110519074734.6093"></t>
<t tx="ekr.20110519074734.6094">def onSelect(self, old_p: Position, p: Position) -&gt; None:

    u = self
    if u.per_node_undo:
        if old_p and u.beads:
            u.putIvarsToVnode(old_p)
        u.setIvarsFromVnode(p)
        u.setUndoTypes()
</t>
<t tx="ekr.20110519074734.6095">def setIvarsFromVnode(self, p: Position) -&gt; None:
    u = self
    v = p.v
    assert self.per_node_undo
    u.clearUndoState()
    if hasattr(v, 'undo_info'):
        u.setIvarsFromBunch(v.undo_info)
</t>
<t tx="ekr.20110519074734.6096">def putIvarsToVnode(self, p: Position) -&gt; None:

    u, v = self, p.v
    assert self.per_node_undo
    bunch = g.bunch()
    for key in self.optionalIvars:
        bunch[key] = getattr(u, key)
    # Put these ivars by hand.
    for key in ('bead', 'beads', 'undoType',):
        bunch[key] = getattr(u, key)
    v.undo_info = bunch
</t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.
</t>
<t tx="ekr.20110605121601.18137">class DynamicWindow(QtWidgets.QMainWindow):  # type:ignore
    """
    A class representing all parts of the main Qt window.

    c.frame.top is a DynamicWindow.
    c.frame.top.leo_master is a LeoTabbedTopLevel.
    c.frame.top.parent() is a QStackedWidget()

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    """
    @others
</t>
<t tx="ekr.20110605121601.18138">def __init__(self, c: Cmdr, parent: "LeoQtFrame"=None) -&gt; None:
    """Ctor for the DynamicWindow class.  The main window is c.frame.top"""
        # Called from LeoQtFrame.finishCreate.
        # parent is a LeoTabbedTopLevel.
    super().__init__(parent)
    self.leo_c = c
    self.leo_master: "LeoTabbedTopLevel" = None  # Set in construct.
    self.leo_menubar = None  # Set in createMenuBar.
    c._style_deltas = defaultdict(lambda: 0)  # for adjusting styles dynamically
    self.reloadSettings()

def reloadSettings(self) -&gt; None:
    c = self.leo_c
    c.registerReloadSettings(self)
    self.bigTree = c.config.getBool('big-outline-pane')
    self.show_iconbar = c.config.getBool('show-iconbar', default=True)
    self.toolbar_orientation = c.config.getString('qt-toolbar-location') or ''
    self.use_gutter = c.config.getBool('use-gutter', default=False)
    if getattr(self, 'iconBar', None):
        if self.show_iconbar:
            self.iconBar.show()
        else:
            self.iconBar.hide()
</t>
<t tx="ekr.20110605121601.18139">def construct(self, master: "LeoTabbedTopLevel"=None) -&gt; None:
    """ Factor 'heavy duty' code out from the DynamicWindow ctor """
    c = self.leo_c
    self.leo_master = master
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    self.reloadSettings()
    main_splitter, secondary_splitter = self.createMainWindow()
    self.iconBar = self.addToolBar("IconBar")
    self.iconBar.setObjectName('icon-bar')  # Required for QMainWindow.saveState().
    self.set_icon_bar_orientation(c)
    # #266 A setting to hide the icon bar.
    # Calling reloadSettings again would also work.
    if not self.show_iconbar:
        self.iconBar.hide()
    self.leo_menubar = self.menuBar()
    self.statusBar = QtWidgets.QStatusBar()
    self.setStatusBar(self.statusBar)
    orientation = c.config.getString('initial-split-orientation')
    self.setSplitDirection(main_splitter, secondary_splitter, orientation)
    if hasattr(c, 'styleSheetManager'):
        c.styleSheetManager.set_style_sheets(top=self, all=True)
</t>
<t tx="ekr.20110605121601.18140">def closeEvent(self, event: Event) -&gt; None:
    """Handle a close event in the Leo window."""
    c = self.leo_c
    if not c.exists:
        # Fixes double-prompt bug on Linux.
        event.accept()
        return
    if c.inCommand:
        c.requestCloseWindow = True
        return
    ok = g.app.closeLeoWindow(c.frame)
    if ok:
        event.accept()
    else:
        event.ignore()
</t>
<t tx="ekr.20110605121601.18141">def createMainWindow(self) -&gt; tuple[LeoQtFrame, LeoQtFrame]:
    """
    Create the component ivars of the main window.
    Copied/adapted from qt_main.py.
    Called instead of uic.loadUi(ui_description_file, self)
    """
    self.setMainWindowOptions()
    # Legacy code: will not go away.
    self.createCentralWidget()
    # Create .verticalLayout
    main_splitter, secondary_splitter = self.createMainLayout(self.centralwidget)
    if self.bigTree:
        # Top pane contains only outline.  Bottom pane contains body and log panes.
        self.createBodyPane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        treeFrame = self.createOutlinePane(main_splitter)
        main_splitter.addWidget(treeFrame)
        main_splitter.addWidget(secondary_splitter)
    else:
        # Top pane contains outline and log panes.
        self.createOutlinePane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        self.createBodyPane(main_splitter)
    self.createMiniBuffer(self.centralwidget)
    self.createMenuBar()
    self.createStatusBar(self)
    # Signals...
    QtCore.QMetaObject.connectSlotsByName(self)
    return main_splitter, secondary_splitter
</t>
<t tx="ekr.20110605121601.18142"></t>
<t tx="ekr.20110605121601.18143">def createBodyPane(self, parent: LeoQtFrame) -&gt; LeoQtFrame:
    """
    Create the *pane* for the body, not the actual QTextBrowser.
    """
    c = self.leo_c
    #
    # Create widgets.
    bodyFrame = self.createFrame(parent, 'bodyFrame')
    innerFrame = self.createFrame(bodyFrame, 'innerBodyFrame')
    sw = self.createStackedWidget(innerFrame, 'bodyStackedWidget',
         hPolicy=Policy.Expanding, vPolicy=Policy.Expanding)
    page2 = QtWidgets.QWidget()
    self.setName(page2, 'bodyPage2')
    body = self.createText(page2, 'richTextEdit')  # A LeoQTextBrowser
    #
    # Pack.
    vLayout = self.createVLayout(page2, 'bodyVLayout', spacing=0)
    grid = self.createGrid(bodyFrame, 'bodyGrid')
    innerGrid = self.createGrid(innerFrame, 'bodyInnerGrid')
    if self.use_gutter:
        lineWidget = qt_text.LeoLineTextWidget(c, body)
        vLayout.addWidget(lineWidget)
    else:
        vLayout.addWidget(body)
    sw.addWidget(page2)
    innerGrid.addWidget(sw, 0, 0, 1, 1)
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    self.verticalLayout.addWidget(parent)
    #
    # Official ivars
    self.text_page = page2
    self.stackedWidget = sw  # used by LeoQtBody
    self.richTextEdit = body
    self.leo_body_frame = bodyFrame
    self.leo_body_inner_frame = innerFrame
    return bodyFrame

</t>
<t tx="ekr.20110605121601.18144">def createCentralWidget(self) -&gt; LeoQtFrame:
    """Create the central widget."""
    dw = self
    w = QtWidgets.QWidget(dw)
    w.setObjectName("centralwidget")
    dw.setCentralWidget(w)
    # Official ivars.
    self.centralwidget = w
    return w
</t>
<t tx="ekr.20110605121601.18145">def createLogPane(self, parent: Any) -&gt; None:
    """Create all parts of Leo's log pane."""
    c = self.leo_c
    #
    # Create the log frame.
    logFrame = self.createFrame(parent, 'logFrame', vPolicy=Policy.Minimum)
    innerFrame = self.createFrame(logFrame, 'logInnerFrame',
        hPolicy=Policy.Preferred, vPolicy=Policy.Expanding)
    tabWidget = self.createTabWidget(innerFrame, 'logTabWidget')
    #
    # Pack.
    innerGrid = self.createGrid(innerFrame, 'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame, 'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)
    #
    # Create the Find tab, embedded in a QScrollArea.
    findScrollArea = QtWidgets.QScrollArea()
    findScrollArea.setObjectName('findScrollArea')
    # Find tab.
    findTab = QtWidgets.QWidget()
    findTab.setObjectName('findTab')
    #
    # #516 and #1507: Create a Find tab unless we are using a dialog.
    #
    # Careful: @bool minibuffer-ding-mode overrides @bool use-find-dialog.
    use_minibuffer = c.config.getBool('minibuffer-find-mode', default=False)
    use_dialog = c.config.getBool('use-find-dialog', default=False)
    if use_minibuffer or not use_dialog:
        tabWidget.addTab(findScrollArea, 'Find')
    # Complete the Find tab in LeoFind.finishCreate.
    self.findScrollArea = findScrollArea
    self.findTab = findTab
    #
    # Spell tab.
    spellTab = QtWidgets.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab, 'Spell')
    self.createSpellTab(spellTab)
    tabWidget.setCurrentIndex(1)
    #
    # Official ivars
    self.tabWidget = tabWidget  # Used by LeoQtLog.
</t>
<t tx="ekr.20110605121601.18146">def createMainLayout(self, parent: LeoQtFrame) -&gt; tuple[LeoQtFrame, LeoQtFrame]:
    """Create the layout for Leo's main window."""
    # c = self.leo_c
    vLayout = self.createVLayout(parent, 'mainVLayout', margin=3)
    main_splitter = NestedSplitter(parent)
    main_splitter.setObjectName('main_splitter')
    main_splitter.setOrientation(Orientation.Vertical)
    secondary_splitter = NestedSplitter(main_splitter)
    secondary_splitter.setObjectName('secondary_splitter')
    secondary_splitter.setOrientation(Orientation.Horizontal)
    # Official ivar:
    self.verticalLayout = vLayout
    self.setSizePolicy(secondary_splitter)
    self.verticalLayout.addWidget(main_splitter)
    return main_splitter, secondary_splitter
</t>
<t tx="ekr.20110605121601.18147">def createMenuBar(self) -&gt; None:
    """Create Leo's menu bar."""
    dw = self
    w = QtWidgets.QMenuBar(dw)
    w.setNativeMenuBar(platform.system() == 'Darwin')
    w.setGeometry(QtCore.QRect(0, 0, 957, 22))
    w.setObjectName("menubar")
    dw.setMenuBar(w)
    # Official ivars.
    self.leo_menubar = w
</t>
<t tx="ekr.20110605121601.18148">def createMiniBuffer(self, parent: LeoQtFrame) -&gt; LeoQtFrame:
    """Create the widgets for Leo's minibuffer area."""
    # Create widgets.
    frame = self.createFrame(parent, 'minibufferFrame',
        hPolicy=Policy.MinimumExpanding, vPolicy=Policy.Fixed)
    frame.setMinimumSize(QtCore.QSize(100, 0))
    label = self.createLabel(frame, 'minibufferLabel', 'Minibuffer:')


    class VisLineEdit(QtWidgets.QLineEdit):  # type:ignore
        """In case user has hidden minibuffer with gui-minibuffer-hide"""

        def focusInEvent(self, event: Event) -&gt; None:
            self.parent().show()
            super().focusInEvent(event)  # Call the base class method.

        def focusOutEvent(self, event: Event) -&gt; None:
            self.store_selection()
            super().focusOutEvent(event)

        def restore_selection(self) -&gt; None:
            w = self
            i, j, ins = self._sel_and_insert
            if i == j:
                w.setCursorPosition(i)
            else:
                length = j - i
                # Set selection is a QLineEditMethod
                if ins &lt; j:
                    w.setSelection(j, -length)
                else:
                    w.setSelection(i, length)

        def store_selection(self) -&gt; None:
            w = self
            ins = w.cursorPosition()
            if w.hasSelectedText():
                i = w.selectionStart()
                s = w.selectedText()
                j = i + len(s)
            else:
                i = j = ins
            w._sel_and_insert = (i, j, ins)

    lineEdit = VisLineEdit(frame)
    lineEdit._sel_and_insert = (0, 0, 0)
    lineEdit.setObjectName('lineEdit')  # name important.
    # Pack.
    hLayout = self.createHLayout(frame, 'minibufferHLayout', spacing=4)
    hLayout.setContentsMargins(3, 2, 2, 0)
    hLayout.addWidget(label)
    hLayout.addWidget(lineEdit)
    self.verticalLayout.addWidget(frame)
    # Transfers focus request from label to lineEdit.
    label.setBuddy(lineEdit)
    #
    # Official ivars.
    self.lineEdit = lineEdit
    # self.leo_minibuffer_frame = frame
    # self.leo_minibuffer_layout = layout
    return frame
</t>
<t tx="ekr.20110605121601.18149">def createOutlinePane(self, parent: LeoQtFrame) -&gt; LeoQtFrame:
    """Create the widgets and ivars for Leo's outline."""
    # Create widgets.
    treeFrame = self.createFrame(parent, 'outlineFrame', vPolicy=Policy.Expanding)
    innerFrame = self.createFrame(treeFrame, 'outlineInnerFrame', hPolicy=Policy.Preferred)
    treeWidget = self.createTreeWidget(innerFrame, 'treeWidget')
    grid = self.createGrid(treeFrame, 'outlineGrid')
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    innerGrid = self.createGrid(innerFrame, 'outlineInnerGrid')
    innerGrid.addWidget(treeWidget, 0, 0, 1, 1)
    # Official ivars...
    self.treeWidget = treeWidget
    return treeFrame
</t>
<t tx="ekr.20110605121601.18150">def createStatusBar(self, parent: LeoQtFrame) -&gt; None:
    """Create the widgets and ivars for Leo's status area."""
    w = QtWidgets.QStatusBar(parent)
    w.setObjectName("statusbar")
    parent.setStatusBar(w)
    # Official ivars.
    self.statusBar = w
</t>
<t tx="ekr.20110605121601.18151">def setMainWindowOptions(self) -&gt; None:
    """Set default options for Leo's main window."""
    dw = self
    dw.setObjectName("MainWindow")
    dw.resize(691, 635)
</t>
<t tx="ekr.20110605121601.18152"></t>
<t tx="ekr.20110605121601.18153">def createButton(self, parent: LeoQtFrame, name: str, label: str) -&gt; LeoQtFrame:
    w = QtWidgets.QPushButton(parent)
    w.setObjectName(name)
    w.setText(self.tr(label))
    return w
</t>
<t tx="ekr.20110605121601.18154">def createCheckBox(self, parent: LeoQtFrame, name: str, label: str) -&gt; LeoQtFrame:
    w = QtWidgets.QCheckBox(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
</t>
<t tx="ekr.20110605121601.18155">def createFrame(
    self,
    parent: LeoQtFrame,
    name: str,
    hPolicy: Policy=None,
    vPolicy: Policy=None,
    lineWidth: int=1,
    shadow: Shadow=None,
    shape: Shape=None,
) -&gt; LeoQtFrame:
    """Create a Qt Frame."""
    if shadow is None:
        shadow = Shadow.Plain
    if shape is None:
        shape = Shape.NoFrame
    #
    w = QtWidgets.QFrame(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setFrameShape(shape)
    w.setFrameShadow(shadow)
    w.setLineWidth(lineWidth)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18156">def createGrid(self,
    parent: LeoQtFrame, name: str, margin: int=0, spacing: int=0,
) -&gt; LeoQtFrame:
    w = QtWidgets.QGridLayout(parent)
    w.setContentsMargins(QtCore.QMargins(margin, margin, margin, margin))
    w.setSpacing(spacing)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18157">def createHLayout(self, parent: LeoQtFrame, name: str, margin: int=0, spacing: int=0) -&gt; Any:
    hLayout = QtWidgets.QHBoxLayout(parent)
    hLayout.setSpacing(spacing)
    hLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(hLayout, name)
    return hLayout

def createVLayout(self, parent: LeoQtFrame, name: str, margin: int=0, spacing: int=0) -&gt; Any:
    vLayout = QtWidgets.QVBoxLayout(parent)
    vLayout.setSpacing(spacing)
    vLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(vLayout, name)
    return vLayout
</t>
<t tx="ekr.20110605121601.18158">def createLabel(self, parent: LeoQtFrame, name: str, label: str) -&gt; LeoQtFrame:
    w = QtWidgets.QLabel(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
</t>
<t tx="ekr.20110605121601.18159">def createLineEdit(self, parent: LeoQtFrame, name: str, disabled: bool=True) -&gt; LeoQtFrame:

    w = QtWidgets.QLineEdit(parent)
    w.setObjectName(name)
    w.leo_disabled = disabled  # Inject the ivar.
    return w
</t>
<t tx="ekr.20110605121601.18160">def createRadioButton(self,
    parent: LeoQtFrame, name: str, label: str,
) -&gt; Widget:  # QtWidgets.QRadioButton:
    w = QtWidgets.QRadioButton(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
</t>
<t tx="ekr.20110605121601.18161">def createStackedWidget(
    self,
    parent: LeoQtFrame,
    name: str,
    lineWidth: int=1,
    hPolicy: Policy=None,
    vPolicy: Policy=None,
) -&gt; Widget:  # QtWidgets.QStackedWidget
    w = QtWidgets.QStackedWidget(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setAcceptDrops(True)
    w.setLineWidth(1)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18162">def createTabWidget(self,
    parent: LeoQtFrame, name: str, hPolicy: Policy=None, vPolicy: Policy=None,
) -&gt; LeoQtFrame:
    w = QtWidgets.QTabWidget(parent)
    # tb = w.tabBar()
    # tb.setTabsClosable(True)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18163">def createText(
    self,
    parent: LeoQtFrame,
    name: str,
    lineWidth: int=0,
    shadow: Shadow=None,
    shape: Shape=None,
) -&gt; LeoQtFrame:
    # Create a text widget.
    c = self.leo_c
    if name == 'richTextEdit' and self.useScintilla and Qsci:
        # Do this in finishCreate, when c.frame.body exists.
        w = Qsci.QsciScintilla(parent)
        self.scintilla_widget = w
    else:
        if shadow is None:
            shadow = Shadow.Plain
        if shape is None:
            shape = Shape.NoFrame
        #
        w = qt_text.LeoQTextBrowser(parent, c, None)
        w.setFrameShape(shape)
        w.setFrameShadow(shadow)
        w.setLineWidth(lineWidth)
        self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18164">def createTreeWidget(self, parent: LeoQtFrame, name: str) -&gt; LeoQtFrame:
    c = self.leo_c
    w = LeoQTreeWidget(c, parent)
    self.setSizePolicy(w)
    # 12/01/07: add new config setting.
    multiple_selection = c.config.getBool('qt-tree-multiple-selection', default=True)
    if multiple_selection:
        w.setSelectionMode(SelectionMode.ExtendedSelection)
        w.setSelectionBehavior(SelectionBehavior.SelectRows)
    else:
        w.setSelectionMode(SelectionMode.SingleSelection)
        w.setSelectionBehavior(SelectionBehavior.SelectItems)
    w.setContextMenuPolicy(ContextMenuPolicy.CustomContextMenu)
    w.setHeaderHidden(False)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18165"></t>
<t tx="ekr.20110605121601.18166">def createFindTab(self, parent: LeoQtFrame, tab_widget: LeoQtFrame) -&gt; None:
    """Create a Find Tab in the given parent."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    assert not fc.ftm
    fc.ftm = ftm = FindTabManager(c)
    grid = self.create_find_grid(parent)
    row = 0  # The index for the present row.
    row = dw.create_find_header(grid, parent, row)
    row = dw.create_find_findbox(grid, parent, row)
    row = dw.create_find_replacebox(grid, parent, row)
    max_row2 = 1
    max_row2 = dw.create_find_checkboxes(grid, parent, max_row2, row)
    row = dw.create_find_buttons(grid, parent, max_row2, row)
    row = dw.create_help_row(grid, parent, row)
    dw.override_events()
    # Last row: Widgets that take all additional vertical space.
    w = QtWidgets.QWidget()
    grid.addWidget(w, row, 0)
    grid.addWidget(w, row, 1)
    grid.addWidget(w, row, 2)
    grid.setRowStretch(row, 100)
    # Official ivars (in addition to checkbox ivars).
    self.leo_find_widget = tab_widget  # A scrollArea.
    ftm.init_widgets()
</t>
<t tx="ekr.20110605121601.18167">def createSpellTab(self, parent: LeoQtFrame) -&gt; None:
    # dw = self
    vLayout = self.createVLayout(parent, 'spellVLayout', margin=2)
    spellFrame = self.createFrame(parent, 'spellFrame')
    vLayout2 = self.createVLayout(spellFrame, 'spellVLayout')
    grid = self.createGrid(None, 'spellGrid', spacing=2)
    table = (
        ('Add', 'Add', 2, 1),
        ('Find', 'Find', 2, 0),
        ('Change', 'Change', 3, 0),
        ('FindChange', 'Change,Find', 3, 1),
        ('Ignore', 'Ignore', 4, 0),
        ('Hide', 'Hide', 4, 1),
    )
    for (ivar, label, row, col) in table:
        name = f"spell_{label}_button"
        button = self.createButton(spellFrame, name, label)
        grid.addWidget(button, row, col)
        func = getattr(self, f"do_leo_spell_btn_{ivar}")
        button.clicked.connect(func)
        # This name is significant.
        setattr(self, f"leo_spell_btn_{ivar}", button)
    self.leo_spell_btn_Hide.setCheckable(False)
    spacerItem = QtWidgets.QSpacerItem(20, 40, Policy.Minimum, Policy.Expanding)
    grid.addItem(spacerItem, 5, 0, 1, 1)
    listBox = QtWidgets.QListWidget(spellFrame)
    self.setSizePolicy(listBox, kind1=Policy.MinimumExpanding, kind2=Policy.Expanding)
    listBox.setMinimumSize(QtCore.QSize(0, 0))
    listBox.setMaximumSize(QtCore.QSize(150, 150))
    listBox.setObjectName("leo_spell_listBox")
    grid.addWidget(listBox, 1, 0, 1, 2)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20, Policy.Expanding, Policy.Minimum)
    grid.addItem(spacerItem1, 2, 2, 1, 1)
    lab = self.createLabel(spellFrame, 'spellLabel', 'spellLabel')
    grid.addWidget(lab, 0, 0, 1, 2)
    vLayout2.addLayout(grid)
    vLayout.addWidget(spellFrame)
    listBox.itemDoubleClicked.connect(self.do_leo_spell_btn_FindChange)
    # Official ivars.
    self.spellFrame = spellFrame
    self.spellGrid = grid
    self.leo_spell_widget = parent  # 2013/09/20: To allow bindings to be set.
    self.leo_spell_listBox = listBox  # Must exist
    self.leo_spell_label = lab  # Must exist (!!)
</t>
<t tx="ekr.20110605121601.18168"></t>
<t tx="ekr.20110605121601.18169">def setName(self, widget: LeoQtFrame, name: str) -&gt; None:
    if name:
        # if not name.startswith('leo_'):
            # name = 'leo_' + name
        widget.setObjectName(name)
</t>
<t tx="ekr.20110605121601.18170">def setSizePolicy(self, widget: LeoQtFrame, kind1: Policy=None, kind2: Policy=None) -&gt; None:
    if kind1 is None:
        kind1 = Policy.Ignored
    if kind2 is None:
        kind2 = Policy.Ignored
    sizePolicy = QtWidgets.QSizePolicy(kind1, kind2)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(widget.sizePolicy().hasHeightForWidth())
    widget.setSizePolicy(sizePolicy)
</t>
<t tx="ekr.20110605121601.18171">def tr(self, s: str) -&gt; str:
    return QtWidgets.QApplication.translate('MainWindow', s, None)

</t>
<t tx="ekr.20110605121601.18172">def doSpellBtn(self, btn: Any) -&gt; None:
    """Execute btn, a button handler."""
    # Make *sure* this never crashes.
    try:
        tab = self.leo_c.spellCommands.handler.tab
        button = getattr(tab, btn)
        button()
    except Exception:
        g.es_exception()

def do_leo_spell_btn_Add(self) -&gt; None:
    self.doSpellBtn('onAddButton')

def do_leo_spell_btn_Change(self) -&gt; None:
    self.doSpellBtn('onChangeButton')

def do_leo_spell_btn_Find(self) -&gt; None:
    self.doSpellBtn('onFindButton')

def do_leo_spell_btn_FindChange(self) -&gt; None:
    self.doSpellBtn('onChangeThenFindButton')

def do_leo_spell_btn_Hide(self) -&gt; None:
    self.doSpellBtn('onHideButton')

def do_leo_spell_btn_Ignore(self) -&gt; None:
    self.doSpellBtn('onIgnoreButton')
</t>
<t tx="ekr.20110605121601.18173">def select(self, c: Cmdr) -&gt; None:
    """Select the window or tab for c."""
    # Called from the save commands.
    self.leo_master.select(c)
</t>
<t tx="ekr.20110605121601.18174">def setSplitDirection(self,
    main_splitter: LeoQtFrame,
    secondary_splitter: LeoQtFrame,
    orientation: Orientation,
) -&gt; None:
    """Set the orientations of the splitters in the Leo main window."""
    # c = self.leo_c
    vert = orientation and orientation.lower().startswith('v')
    h, v = Orientation.Horizontal, Orientation.Vertical
    orientation1 = v if vert else h
    orientation2 = h if vert else v
    main_splitter.setOrientation(orientation1)
    secondary_splitter.setOrientation(orientation2)
</t>
<t tx="ekr.20110605121601.18177">def setLeoWindowIcon(self) -&gt; None:
    """ Set icon visible in title bar and task bar """
    # self.setWindowIcon(QtGui.QIcon(g.app.leoDir + "/Icons/leoapp32.png"))
    g.app.gui.attachLeoIcon(self)
</t>
<t tx="ekr.20110605121601.18178">def setGeometry(self, rect: Any) -&gt; None:
    """Set the window geometry, but only once when using the qt gui."""
    m = self.leo_master
    assert self.leo_master
    # Only set the geometry once, even for new files.
    if not hasattr(m, 'leo_geom_inited'):
        m.leo_geom_inited = True
        self.leo_master.setGeometry(rect)
        super().setGeometry(rect)

</t>
<t tx="ekr.20110605121601.18212">def packLabel(self, w: Wrapper, n: int=None) -&gt; None:
    """
    Pack w into the body frame's QVGridLayout.

    The type of w does not affect the following code. In fact, w is a
    QTextBrowser possibly packed inside a LeoLineTextWidget.
    """
    c = self.leo_c
    #
    # Reuse the grid layout in the body frame.
    grid = self.leo_body_frame.layout()
    # Pack the label and the text widget.
    label = QtWidgets.QLineEdit(None)
    label.setObjectName('editorLabel')
    label.setText(c.p.h)
    if n is None:
        n = c.frame.body.numberOfEditors
    n = max(0, n - 1)
    # mypy error: grid is a QGridLayout, not a QLayout.
    grid.addWidget(label, 0, n)  # type:ignore
    grid.addWidget(w, 1, n)  # type:ignore
    grid.setRowStretch(0, 0)  # Don't grow the label vertically.
    grid.setRowStretch(1, 1)  # Give row 1 as much as vertical room as possible.
    # Inject the ivar.
    w.leo_label = label
</t>
<t tx="ekr.20110605121601.18223"></t>
<t tx="ekr.20110605121601.18224">def onFocusColorHelper(self, kind: str, obj: Any) -&gt; None:
    """Handle changes of style when focus changes."""
    c, vc = self.c, self.c.vimCommands
    if vc and c.vim_mode:
        try:
            assert kind in ('focus-in', 'focus-out')
            w = c.frame.body.wrapper.widget
            vc.set_border(w=w, activeFlag=kind == 'focus-in')
        except Exception:
            # g.es_exception()
            pass
</t>
<t tx="ekr.20110605121601.18262">class QtIconBarClass:
    """A class representing the singleton Icon bar"""
    @others
</t>
<t tx="ekr.20110605121601.18263">def __init__(self, c: Cmdr, parentFrame: LeoQtFrame) -&gt; None:
    """Ctor for QtIconBarClass."""
    # Copy ivars
    self.c = c
    self.parentFrame = parentFrame
    # Status ivars.
    self.actions: list[Any] = []
    self.chapterController = None
    self.toolbar = self
    self.w = c.frame.top.iconBar  # A QToolBar.
    self.reloadSettings()

def reloadSettings(self) -&gt; None:
    c = self.c
    c.registerReloadSettings(self)
    self.buttonColor = c.config.getString('qt-button-color')
    self.toolbar_orientation = c.config.getString('qt-toolbar-location')
</t>
<t tx="ekr.20110605121601.18264"># These *are* called from Leo's core.

def addRow(self, height: int=None) -&gt; None:
    pass  # To do.

def getNewFrame(self) -&gt; None:
    return None  # To do
</t>
<t tx="ekr.20110605121601.18265">def add(self, *args: Any, **keys: Any) -&gt; Any:
    """Add a button to the icon bar."""
    c = self.c
    if not self.w:
        return None
    command: Callable = keys.get('command')
    text: str = keys.get('text')
    # able to specify low-level QAction directly (QPushButton not forced)
    qaction: Any = keys.get('qaction')
    if not text and not qaction:
        g.es('bad toolbar item')
    kind: str = keys.get('kind') or 'generic-button'
    # imagefile = keys.get('imagefile')
    # image = keys.get('image')


    class leoIconBarButton(QtWidgets.QWidgetAction):  # type:ignore

        def __init__(self, parent: LeoQtFrame, text: str, toolbar: "QtIconBarClass") -&gt; None:
            super().__init__(parent)
            self.button: Widget = None  # A QPushButton
            self.text = text
            self.toolbar = toolbar

        def createWidget(self, parent: LeoQtFrame) -&gt; None:
            self.button = QtWidgets.QPushButton(self.text, parent)
            self.button.setProperty('button_kind', kind)  # for styling
            return self.button

    action: Any
    if qaction is None:
        action = leoIconBarButton(parent=self.w, text=text, toolbar=self)
        button_name = text
    else:
        action = qaction
        button_name = action.text()
    self.w.addAction(action)
    self.actions.append(action)
    b = self.w.widgetForAction(action)
    # Set the button's object name so we can use the stylesheet to color it.
    if not button_name:
        button_name = 'unnamed'
    button_name = button_name + '-button'
    b.setObjectName(button_name)
    b.setContextMenuPolicy(ContextMenuPolicy.ActionsContextMenu)

    def delete_callback(checked: str, action: str=action) -&gt; None:
        self.w.removeAction(action)

    b.leo_removeAction = rb = QAction('Remove Button', b)
    b.addAction(rb)
    rb.triggered.connect(delete_callback)
    if command:

        def button_callback(event: Event, c: Cmdr=c, command: Callable=command) -&gt; None:
            val = command()
            if c.exists:
                # c.bodyWantsFocus()
                c.outerUpdate()
            return val

        b.clicked.connect(button_callback)
    return action
</t>
<t tx="ekr.20110605121601.18266">def addRowIfNeeded(self) -&gt; None:
    """Add a new icon row if there are too many widgets."""
    # n = g.app.iconWidgetCount
    # if n &gt;= self.widgets_per_row:
        # g.app.iconWidgetCount = 0
        # self.addRow()
    # g.app.iconWidgetCount += 1
</t>
<t tx="ekr.20110605121601.18267">def addWidget(self, w: LeoQtFrame) -&gt; None:
    self.w.addWidget(w)
</t>
<t tx="ekr.20110605121601.18268">def clear(self) -&gt; None:
    """Destroy all the widgets in the icon bar"""
    self.w.clear()
    self.actions = []
    g.app.iconWidgetCount = 0
</t>
<t tx="ekr.20110605121601.18269">def createChaptersIcon(self) -&gt; "LeoQtTreeTab":

    c = self.c
    f = c.frame
    if f.use_chapters and f.use_chapter_tabs:
        return LeoQtTreeTab(c, f.iconBar)
    return None
</t>
<t tx="ekr.20110605121601.18270">def deleteButton(self, w: LeoQtFrame) -&gt; None:
    """ w is button """
    self.w.removeAction(w)
    self.c.bodyWantsFocus()
    self.c.outerUpdate()
</t>
<t tx="ekr.20110605121601.18271"># qtFrame.QtIconBarClass.setCommandForButton
# Controller is a ScriptingController.

def setCommandForButton(self,
    button: Any, command: Callable, command_p: Position, controller: Cmdr, gnx: str, script: str,
) -&gt; None:
    """
    Set the "Goto Script" rlick item of an @button button.
    Called from mod_scripting.py plugin.

    button is a leoIconBarButton.
    command is a callback, defined in mod_scripting.py.
    command_p exists only if the @button node exists in the local .leo file.
    gnx is the gnx of the @button node.
    script is a static script for common @button nodes.
    """
    if not command:
        return
    b = button.button
    b.clicked.connect(command)

    def goto_callback(checked: str, controller: Cmdr=controller, gnx: str=gnx) -&gt; None:
        self.goto_command(controller, gnx)

    b.goto_script = gts = QAction('Goto Script', b)
    b.addAction(gts)
    gts.triggered.connect(goto_callback)
    rclicks = build_rclick_tree(command_p, top_level=True)
    self.add_rclick_menu(b, rclicks, controller, script=script)
</t>
<t tx="ekr.20110605121601.18285"></t>
<t tx="ekr.20110605121601.18286"># Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self) -&gt; None:
    f = self
    c = f.c
    if c.inCommand:
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)
</t>
<t tx="ekr.20110605121601.18287">def OnControlKeyDown(self, event: Event=None) -&gt; None:
    self.controlKeyIsDown = True

def OnControlKeyUp(self, event: Event=None) -&gt; None:
    self.controlKeyIsDown = False
</t>
<t tx="ekr.20110605121601.18290">def OnActivateTree(self, event: Event=None) -&gt; None:
    pass
</t>
<t tx="ekr.20110605121601.18322">def put(self,
    s: str,
    color: str=None,
    tabName: str='Log',
    from_redirect: bool=False,
    nodeLink: str=None,
) -&gt; None:
    """
    Put s to the Qt Log widget, converting to html.
    All output to the log stream eventually comes here.

    The from_redirect keyword argument is no longer used.
    """
    c = self.c
    if g.app.quitting or not c or not c.exists:
        return
    #
    # *Note*: For reasons that I don't fully understand,
    #         all lines sent to the log must now end in a newline.
    #
    s = s.rstrip() + '\n'
    color = self.resolve_color(color)
    self.selectTab(tabName or 'Log')
    # Must be done after the call to selectTab.
    wrapper = self.logCtrl
    if not isinstance(wrapper, qt_text.QTextEditWrapper):
        g.trace('BAD wrapper', wrapper.__class__.__name__)
        return
    w = wrapper.widget
    if not isinstance(w, QtWidgets.QTextEdit):
        g.trace('BAD widget', w.__class__.__name__)
        return
    sb = w.horizontalScrollBar()
    s = self.to_html(color, s)
    if nodeLink:
        link = urllib.parse.quote(nodeLink)
        s = f'&lt;a href="{link}" title="{link}"&gt;{s}&lt;/a&gt;'
    w.insertHtml(s)
    w.moveCursor(MoveOperation.End)
    sb.setSliderPosition(0)  # Force the slider to the initial position.
    w.repaint()  # Slow, but essential.
</t>
<t tx="ekr.20110605121601.18480"># Called from eventFilter

def onActivateEvent(self, event: Event, c: Cmdr, obj: Any, tag: str) -&gt; None:
    """
    Restore the focus when the Leo window is activated.
    Called several times for each window activation.
    """
    trace = 'focus' in g.app.debug
    w = self.get_focus() or self.deactivated_widget
    self.deactivated_widget = None
    w_name = w and w.objectName()
    # Fix #270: Vim keys don't always work after double Alt+Tab.
    # Fix #359: Leo hangs in LeoQtEventFilter.eventFilter
    # #1273: add teest on c.vim_mode.
    if c.exists and c.vim_mode and c.vimCommands and not self.active and not g.app.killed:
        c.vimCommands.on_activate()
    self.active = True  # Used only by c.idle_focus_helper.
    if g.isMac:
        pass  # Fix #757: MacOS: replace-then-find does not work in headlines.
    else:
        # Leo 5.6: Recover from missing focus.
        # c.idle_focus_handler can't do this.
        if w and w_name in ('log-widget', 'richTextEdit', 'treeWidget'):
            # Restore focus **only** to body or tree
            if trace:
                g.trace('==&gt;', w_name)
            c.widgetWantsFocusNow(w)
        else:
            if trace:
                g.trace(repr(w_name), '==&gt; BODY')
            c.bodyWantsFocusNow()
    # Cause problems elsewhere.
        # if c.exists and self.deactivated_name:
            # self.active = True
            # w_name = self.deactivated_name
            # self.deactivated_name = None
            # if c.p.v:
                # c.p.v.restoreCursorAndScroll()
            # if w_name.startswith('tree') or w_name.startswith('head'):
                # c.treeWantsFocusNow()
            # else:
                # c.bodyWantsFocusNow()
    g.doHook('activate', c=c, p=c.p, v=c.p, event=event)
</t>
<t tx="ekr.20110605121601.18481"># deactivated_name = ''

deactivated_widget = None

def onDeactivateEvent(self, event: Event, c: Cmdr, obj: Any, tag: str) -&gt; None:
    """
    Gracefully deactivate the Leo window.
    Called several times for each window activation.
    """
    w = self.get_focus()
    w_name = w and w.objectName()
    if 'focus' in g.app.debug:
        g.trace(repr(w_name))
    self.active = False  # Used only by c.idle_focus_helper.
    # Careful: never save headline widgets.
    if w_name == 'headline':
        self.deactivated_widget = c.frame.tree.treeWidget
    else:
        self.deactivated_widget = w if w_name else None
    # Causes problems elsewhere...
        # if c.exists and not self.deactivated_name:
            # self.deactivated_name = self.widget_name(self.get_focus())
            # self.active = False
            # c.k.keyboardQuit(setFocus=False)
    g.doHook('deactivate', c=c, p=c.p, v=c.p, event=event)
</t>
<t tx="ekr.20110607182447.16456"></t>
<t tx="ekr.20110930174206.15472">def onFocusIn(self, obj: Any) -&gt; None:
    """Handle a focus-in event in the body pane."""
    trace = 'select' in g.app.debug and not g.unitTesting
    tag = 'qt_body.onFocusIn'
    if obj.objectName() == 'richTextEdit':
        wrapper = getattr(obj, 'leo_wrapper', None)
        if trace:
            print(f"{tag:&gt;30}: {wrapper}")
        if wrapper and wrapper != self.wrapper:
            self.selectEditor(wrapper)
        self.onFocusColorHelper('focus-in', obj)
        if hasattr(obj, 'leo_copy_button') and obj.leo_copy_button:
            obj.setReadOnly(True)
        else:
            obj.setReadOnly(False)
        obj.setFocus()  # Weird, but apparently necessary.
</t>
<t tx="ekr.20110930174206.15473">def onFocusOut(self, obj: Any) -&gt; None:
    """Handle a focus-out event in the body pane."""
    # Apparently benign.
    if obj.objectName() == 'richTextEdit':
        self.onFocusColorHelper('focus-out', obj)
        if hasattr(obj, 'setReadOnly'):
            obj.setReadOnly(True)
</t>
<t tx="ekr.20111005152227.15555">def afterDeleteMarkedNodes(self, data: g.Bunch, p: Position) -&gt; None:
    u = self
    if u.redoing or u.undoing:
        return
    bunch = u.createCommonBunch(p)
    # Set types &amp; helpers
    bunch.kind = 'delete-marked-nodes'
    bunch.undoType = 'delete-marked-nodes'
    # Set helpers
    bunch.undoHelper = u.undoDeleteMarkedNodes
    bunch.redoHelper = u.redoDeleteMarkedNodes
    bunch.newP = p.copy()
    bunch.deleteMarkedNodesData = data
    bunch.newMarked = p.isMarked()
    u.pushBead(bunch)
</t>
<t tx="ekr.20111005152227.15557">def undoDeleteMarkedNodes(self) -&gt; None:
    c, u = self.c, self
    # Undo the deletes in reverse order
    aList = u.deleteMarkedNodesData[:]
    aList.reverse()
    for p in aList:
        if p.stack:
            parent_v, junk = p.stack[-1]
        else:
            parent_v = c.hiddenRootNode
        p.v._addLink(p._childIndex, parent_v)
        p.v.setDirty()
    u.p.setAllAncestorAtFileNodesDirty()
    c.selectPosition(u.p)
</t>
<t tx="ekr.20111005152227.15558">def redoCloneMarkedNodes(self) -&gt; None:
    c, u = self.c, self
    c.selectPosition(u.p)
    c.cloneMarked()
    u.newP = c.p
</t>
<t tx="ekr.20111005152227.15559">def redoDeleteMarkedNodes(self) -&gt; None:
    c, u = self.c, self
    c.selectPosition(u.p)
    c.deleteMarked()
    c.selectPosition(u.newP)
</t>
<t tx="ekr.20111005152227.15560">def undoCloneMarkedNodes(self) -&gt; None:
    u = self
    next = u.p.next()
    assert next.h == 'Clones of marked nodes', (u.p, next.h)
    next.doDelete()
    u.p.setAllAncestorAtFileNodesDirty()
    u.c.selectPosition(u.p)
</t>
<t tx="ekr.20111005152227.15566">def positionAfterDeletedTree(self) -&gt; Position:  # pragma: no cover
    """Return the position corresponding to p.nodeAfterTree() after this node is
    deleted. This will be p.nodeAfterTree() unless p.next() exists.

    This method allows scripts to traverse an outline, deleting nodes during the
    traversal. The pattern is::

        p = c.rootPosition()
        while p:
        if &lt;delete p?&gt;:
            next = p.positionAfterDeletedTree()
            p.doDelete()
            p = next
        else:
            p.moveToThreadNext()

    This method also allows scripts to *move* nodes during a traversal, **provided**
    that nodes are moved to a "safe" spot so that moving a node does not change the
    position of any other nodes.

    For example, the move-marked-nodes command first creates a **move node**, called
    'Clones of marked nodes'. All moved nodes become children of this move node.
    **Inserting** these nodes as children of the "move node" does not change the
    positions of other nodes. **Deleting** these nodes *may* change the position of
    nodes, but the pattern above handles this complication cleanly.
    """
    p = self
    next = p.next()  # pylint: disable=not-callable
    if next:
        # The new position will be the same as p, except for p.v.
        p = p.copy()
        p.v = next.v
        return p
    return p.nodeAfterTree()
</t>
<t tx="ekr.20111006060936.15639">def afterCloneMarkedNodes(self, p: Position) -&gt; None:
    u = self
    if u.redoing or u.undoing:
        return
    # createCommonBunch sets:
    #   oldDirty = p.isDirty()
    #   oldMarked = p.isMarked()
    #   oldSel = w and w.getSelectionRange() or None
    #   p = p.copy()
    bunch = u.createCommonBunch(p)
    # Set types.
    bunch.kind = 'clone-marked-nodes'
    bunch.undoType = 'clone-marked-nodes'
    # Set helpers.
    bunch.undoHelper = u.undoCloneMarkedNodes
    bunch.redoHelper = u.redoCloneMarkedNodes
    bunch.newP = p.next()
    bunch.newMarked = p.isMarked()
    u.pushBead(bunch)
</t>
<t tx="ekr.20120130101219.10182">def computeBindingLetter(self, c: Cmdr, path: str) -&gt; str:
    lm = self
    if not path:
        return 'D'
    path = path.lower()
    table = (
        ('M', 'myLeoSettings.leo'),
        (' ', 'leoSettings.leo'),
        ('F', c.shortFileName()),
    )
    for letter, path2 in table:
        if path2 and path.endswith(path2.lower()):
            return letter
    if lm.theme_path and path.endswith(lm.theme_path.lower()):
        return 'T'
    tag = 'register-command:'
    if path.startswith(tag):
        return self.computeBindingLetter(c, path=path[len(tag) :])
    if path.endswith('-mode'):
        return '@'
    return 'D'
</t>
<t tx="ekr.20120209051836.10242">class LoadManager:
    """A class to manage loading .leo files, including configuration files."""
    LM_NOTHEME_FLAG = 'lm_theme_use_none'
    @others
</t>
<t tx="ekr.20120209051836.10252">def computeStandardDirectories(self) -&gt; None:
    """
    Compute the locations of standard directories and
    set the corresponding ivars.
    """
    lm = self
    join = os.path.join
    g.app.loadDir = lm.computeLoadDir()
    g.app.globalConfigDir = lm.computeGlobalConfigDir()
    g.app.homeDir = lm.computeHomeDir()
    g.app.homeLeoDir = lm.computeHomeLeoDir()
    g.app.leoDir = lm.computeLeoDir()
    # These use g.app.loadDir...
    g.app.extensionsDir = join(g.app.loadDir, '..', 'extensions')
    g.app.leoEditorDir = join(g.app.loadDir, '..', '..')
    g.app.testDir = join(g.app.loadDir, '..', 'test')
</t>
<t tx="ekr.20120209051836.10253">def computeGlobalConfigDir(self) -&gt; Optional[str]:
    leo_config_dir = getattr(sys, 'leo_config_directory', None)
    if leo_config_dir:
        theDir = leo_config_dir
    else:
        theDir = os.path.join(g.app.loadDir, "..", "config")
    if theDir:
        theDir = os.path.abspath(theDir)
    if not theDir or not g.os_path_exists(theDir) or not g.os_path_isdir(theDir):
        theDir = None
    return theDir
</t>
<t tx="ekr.20120209051836.10254">def computeHomeDir(self) -&gt; Optional[str]:
    """Returns the user's home directory."""
    # Windows searches the HOME, HOMEPATH and HOMEDRIVE
    # environment vars, then gives up.
    home = os.path.expanduser("~")
    if home and len(home) &gt; 1 and home[0] == '%' and home[-1] == '%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1], default=None)
    if home:
        # Important: This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.finalize(home)
        if (not g.os_path_exists(home) or not g.os_path_isdir(home)):
            home = None
    return home
</t>
<t tx="ekr.20120209051836.10255">def computeLeoDir(self) -&gt; str:
    # lm = self
    loadDir = g.app.loadDir
    # We don't want the result in sys.path
    return g.os_path_dirname(loadDir)
</t>
<t tx="ekr.20120209051836.10256">def computeLoadDir(self) -&gt; str:
    """Returns the directory containing leo.py."""
    try:
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = g.__file__  # was leo.__file__
        if path:
            # Possible fix for bug 735938:
            # Do the following only if path exists.
            &lt;&lt; resolve symlinks &gt;&gt;
            if sys.platform == 'win32':
                if len(path) &gt; 2 and path[1] == ':':
                    # Convert the drive name to upper case.
                    path = path[0].upper() + path[1:]
            path = g.finalize(path)
            loadDir = g.os_path_dirname(path)
        else:
            loadDir = None
        if (
            not loadDir or
            not g.os_path_exists(loadDir) or
            not g.os_path_isdir(loadDir)
        ):
            loadDir = os.getcwd()
            # From Marc-Antoine Parent.
            if loadDir.endswith("Contents/Resources"):
                loadDir += "/leo/plugins"
            else:
                g.pr("Exception getting load directory")
        loadDir = g.finalize(loadDir)
        return loadDir
    except Exception:
        print("Exception getting load directory")
        raise
</t>
<t tx="ekr.20120209051836.10257">if path.endswith('pyc'):
    srcfile = path[:-1]
    if os.path.islink(srcfile):
        path = os.path.realpath(srcfile)
</t>
<t tx="ekr.20120209051836.10260">def computeHomeLeoDir(self) -&gt; str:
    # lm = self
    homeLeoDir = g.finalize_join(g.app.homeDir, '.leo')
    if g.os_path_exists(homeLeoDir):
        return homeLeoDir
    ok = g.makeAllNonExistentDirectories(homeLeoDir)
    return homeLeoDir if ok else ''  # #1450
</t>
<t tx="ekr.20120209051836.10372">def computeLeoSettingsPath(self) -&gt; Optional[str]:
    """Return the full path to leoSettings.leo."""
    # lm = self
    join = g.finalize_join
    settings_fn = 'leoSettings.leo'
    table = (
        # First, leoSettings.leo in the home directories.
        join(g.app.homeDir, settings_fn),
        join(g.app.homeLeoDir, settings_fn),
        # Last, leoSettings.leo in leo/config directory.
        join(g.app.globalConfigDir, settings_fn)
    )
    for path in table:
        if g.os_path_exists(path):
            break
    else:
        path = None
    return path
</t>
<t tx="ekr.20120209051836.10373">def computeMyLeoSettingsPath(self) -&gt; Optional[str]:
    """
    Return the full path to myLeoSettings.leo.

    The "footnote": Get the local directory from lm.files[0]
    """
    lm = self
    join = g.finalize_join
    settings_fn = 'myLeoSettings.leo'
    # This seems pointless: we need a machine *directory*.
    # For now, however, we'll keep the existing code as is.
    machine_fn = lm.computeMachineName() + settings_fn
    # First, compute the directory of the first loaded file.
    # All entries in lm.files are full, absolute paths.
    localDir = g.os_path_dirname(lm.files[0]) if lm.files else ''
    table = (
        # First, myLeoSettings.leo in the local directory
        join(localDir, settings_fn),
        # Next, myLeoSettings.leo in the home directories.
        join(g.app.homeDir, settings_fn),
        join(g.app.homeLeoDir, settings_fn),
        # Next, &lt;machine-name&gt;myLeoSettings.leo in the home directories.
        join(g.app.homeDir, machine_fn),
        join(g.app.homeLeoDir, machine_fn),
        # Last, leoSettings.leo in leo/config directory.
        join(g.app.globalConfigDir, settings_fn),
    )
    for path in table:
        if g.os_path_exists(path):
            break
    else:
        path = None
    return path
</t>
<t tx="ekr.20120211121736.10772">def computeWorkbookFileName(self) -&gt; Optional[str]:
    """
    Return full path to the workbook.

    Return None if testing, or in batch mode, or if the containing
    directory does not exist.
    """
    # lm = self
    # Never create a workbook during unit tests or in batch mode.
    if g.unitTesting or g.app.batchMode:
        return None
    fn = g.app.config.getString(setting='default_leo_file') or '~/.leo/workbook.leo'
    fn = g.finalize(fn)
    directory = g.finalize(os.path.dirname(fn))

    return fn if os.path.exists(directory) else None
</t>
<t tx="ekr.20120211121736.10812"></t>
<t tx="ekr.20120213081706.10382">def readGlobalSettingsFiles(self) -&gt; None:
    """
    Read leoSettings.leo and myLeoSettings.leo using a null gui.

    New in Leo 6.1: this sets ivars for the ActiveSettingsOutline class.
    """
    trace = 'themes' in g.app.debug
    lm = self
    # Open the standard settings files with a nullGui.
    # Important: their commanders do not exist outside this method!
    old_commanders = g.app.commanders()
    lm.leo_settings_path = lm.computeLeoSettingsPath()
    lm.my_settings_path = lm.computeMyLeoSettingsPath()
    lm.leo_settings_c = lm.openSettingsFile(self.leo_settings_path)
    lm.my_settings_c = lm.openSettingsFile(self.my_settings_path)
    commanders = [lm.leo_settings_c, lm.my_settings_c]
    commanders = [z for z in commanders if z]
    settings_d, bindings_d = lm.createDefaultSettingsDicts()
    for c in commanders:
        # Merge the settings dicts from c's outline into
        # *new copies of* settings_d and bindings_d.
        settings_d, bindings_d = lm.computeLocalSettings(
            c, settings_d, bindings_d, localFlag=False)
    # Adjust the name.
    bindings_d.setName('lm.globalBindingsDict')
    lm.globalSettingsDict = settings_d
    lm.globalBindingsDict = bindings_d
    # Add settings from --theme or @string theme-name files.
    # This must be done *after* reading myLeoSettigns.leo.
    lm.theme_path = lm.computeThemeFilePath()
    if lm.theme_path and lm.theme_path != LoadManager.LM_NOTHEME_FLAG:
        lm.theme_c = lm.openSettingsFile(lm.theme_path)
        if lm.theme_c:
            # Merge theme_c's settings into globalSettingsDict.
            settings_d, junk_shortcuts_d = lm.computeLocalSettings(
                lm.theme_c, settings_d, bindings_d, localFlag=False)
            lm.globalSettingsDict = settings_d
            # Set global var used by the StyleSheetManager.
            g.app.theme_directory = g.os_path_dirname(lm.theme_path)
            if trace:
                g.trace('g.app.theme_directory', g.app.theme_directory)
    # Clear the cache entries for the commanders.
    # This allows this method to be called outside the startup logic.
    for c in commanders:
        if c not in old_commanders:
            g.app.forgetOpenFile(c.fileName())
</t>
<t tx="ekr.20120213164030.10697">def computeMachineName(self) -&gt; str:
    """Return the name of the current machine, i.e, HOSTNAME."""
    # This is prepended to leoSettings.leo or myLeoSettings.leo
    # to give the machine-specific setting name.
    # How can this be worth doing??
    try:
        name = os.getenv('HOSTNAME')
        if not name:
            name = os.getenv('COMPUTERNAME')
        if not name:
            import socket
            name = socket.gethostname()
    except Exception:
        name = ''
    return name
</t>
<t tx="ekr.20120214060149.15851">def __init__(self) -&gt; None:

    # Global settings &amp; shortcuts dicts...
    # The are the defaults for computing settings and shortcuts for all loaded files.

    # A g.SettingsDict: the join of settings in leoSettings.leo &amp; myLeoSettings.leo
    self.globalSettingsDict: g.SettingsDict = None
    # A g.SettingsDict: the join of shortcuts in leoSettings.leo &amp; myLeoSettings.leo.
    self.globalBindingsDict: g.SettingsDict = None

    # LoadManager ivars corresponding to user options...

    self.files: list[str] = []  # List of files to be loaded.
    self.options: dict[str, Any] = {}  # Keys are option names; values are user options.
    self.old_argv: list[str] = []  # A copy of sys.argv for debugging.

    # True when more files remain on the command line to be loaded.
    # If the user is answering "No" to each file as Leo asks
    # "file already open, open again".
    # This must be False for a complete exit to be appropriate
    # (finish_quit=True param for closeLeoWindow())
    self.more_cmdline_files = False

    # Themes...
    self.leo_settings_c: Cmdr = None
    self.leo_settings_path: str = None
    self.my_settings_c: Cmdr = None
    self.my_settings_path: str = None
    self.theme_c: Cmdr = None  # #1374.
    self.theme_path: str = None
</t>
<t tx="ekr.20120214132927.10723">def mergeShortcutsDicts(self,
    c: Cmdr,
    old_d: g.SettingsDict,
    new_d: g.SettingsDict,
    localFlag: bool,
) -&gt; g.SettingsDict:
    """
    Create a new dict by overriding all shortcuts in old_d by shortcuts in new_d.

    Both old_d and new_d remain unchanged.
    """
    lm = self
    if not old_d:
        return new_d
    if not new_d:
        return old_d
    inverted_old_d = lm.invert(old_d)
    inverted_new_d = lm.invert(new_d)
    # #510 &amp; #327: always honor --trace-binding here.
    if g.app.trace_binding:
        &lt;&lt; trace the binding &gt;&gt;
    # Check for duplicate shortcuts only in the new file.
    lm.checkForDuplicateShortcuts(c, inverted_new_d)
    inverted_old_d.update(inverted_new_d)  # Updates inverted_old_d in place.
    result = lm.uninvert(inverted_old_d)
    return result
</t>
<t tx="ekr.20120214132927.10724">def invert(self, d: dict) -&gt; g.SettingsDict:
    """
    Invert a shortcut dict whose keys are command names,
    returning a dict whose keys are strokes.
    """
    if d is None:
        d = {}
    result = g.SettingsDict(f"inverted {d.name()}")
    for commandName in d.keys():
        for bi in d.get(commandName, []):
            stroke = bi.stroke  # This is canonicalized.
            bi.commandName = commandName  # Add info.
            assert stroke
            result.add_to_list(stroke, bi)
    return result
</t>
<t tx="ekr.20120214132927.10725">def uninvert(
    self,
    d: g.SettingsDict) -&gt; g.SettingsDict:
    """
    Uninvert an inverted shortcut dict whose keys are strokes,
    returning a dict whose keys are command names.
    """
    result = g.SettingsDict(f"uninverted {d.name()}")
    for stroke in d.keys():
        for bi in d.get(stroke, []):
            commandName = bi.commandName
            assert commandName
            result.add_to_list(commandName, bi)
    return result
</t>
<t tx="ekr.20120214165710.10726">def createSettingsDicts(self, c: Cmdr, localFlag: bool) -&gt; Optional[tuple[g.SettingsDict, g.SettingsDict]]:

    from leo.core import leoConfig
    if c:
        # returns the *raw* shortcutsDict, not a *merged* shortcuts dict.
        parser = leoConfig.SettingsTreeParser(c, localFlag)
        shortcutsDict, settingsDict = parser.traverse()
        return shortcutsDict, settingsDict
    return None, None
</t>
<t tx="ekr.20120214165710.10822">def traceShortcutsDict(self, d: dict[str, str], verbose: bool = False) -&gt; None:
    if verbose:
        print(d)
        for key in sorted(list(d.keys())):
            val = d.get(key)
            # print('%20s %s' % (key,val.dump()))
            print(f"{key:35} {[z.stroke for z in val]}")
        if d:
            print('')
    else:
        print(d)
</t>
<t tx="ekr.20120214165710.10838">def traceSettingsDict(self, d: dict[str, str], verbose: bool = False) -&gt; None:
    if verbose:
        print(d)
        for key in sorted(list(d.keys())):
            gs = d.get(key)
            print(f"{key:35} {g.shortFileName(gs.path):17} {gs.val}")
        if d:
            print('')
    else:
        print(f"{d.name()} {len(d.keys())}")
</t>
<t tx="ekr.20120215062153.10740"></t>
<t tx="ekr.20120215072959.12471"></t>
<t tx="ekr.20120215072959.12475">def set(self, p: Position, kind: str, name: str, val: Any, warn: bool = True) -&gt; None:
    """
    Init the setting for name to val.

    The "p" arg is not used.
    """
    c = self.c
    # Note: when kind is 'shortcut', name is a command name.
    key = g.app.config.munge(name)
    d = self.settingsDict
    assert isinstance(d, g.SettingsDict), repr(d)
    gs = d.get(key)
    if gs:
        assert isinstance(gs, g.GeneralSetting), repr(gs)
        path = gs.path
        if warn and g.finalize(c.mFileName) != g.finalize(path):
            g.trace("over-riding setting:", name, "from", path)
    d[key] = g.GeneralSetting(
        kind,
        path=c.mFileName,
        source=p.h if p else '',
        val=val,
        tag='setting',
    )
</t>
<t tx="ekr.20120215072959.12515">@nocolor-node
@ Only the following need to be defined.
    get (self,setting,theType)
    getAbbrevDict (self)
    getBool (self,setting,default=None)
    getButtons (self)
    getColor (self,setting)
    getData (self,setting)
    getDirectory (self,setting)
    getFloat (self,setting)
    getFontFromParams (self,family,size,slant,weight,defaultSize=12)
    getInt (self,setting)
    getLanguage (self,setting)
    getMenusList (self)
    getOutlineData (self)
    getOpenWith (self)
    getRatio (self,setting)
    getShortcut (self,commandName)
    getString (self,setting)
</t>
<t tx="ekr.20120215072959.12519">def get(self, setting: str, kind: str) -&gt; Any:
    """Get the setting and make sure its type matches the expected type."""
    d = self.settingsDict
    if d:
        assert isinstance(d, g.SettingsDict), repr(d)
        val, junk = self.getValFromDict(d, setting, kind)
        return val
    return None
</t>
<t tx="ekr.20120215072959.12520">def getValFromDict(self,
    d: Any, setting: str, requestedType: str, warn: bool = True,
) -&gt; tuple[Any, bool]:
    """
    Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)
    """
    tag = 'c.config.getValFromDict'
    gs = d.get(g.app.config.munge(setting))
    if not gs:
        return None, False
    assert isinstance(gs, g.GeneralSetting), repr(gs)
    val = gs.val
    isNone = val in ('None', 'none', '')
    if not self.typesMatch(gs.kind, requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            g.error(
                f"{tag}: ignoring '{setting}' setting.\n"
                f"{tag}: '@{gs.kind}' is not '@{requestedType}'.\n"
                f"{tag}: there may be conflicting settings!")
        return None, False
    if isNone:
        return '', True  # 2011/10/24: Exists, a *user-defined* empty value.
    return val, True
</t>
<t tx="ekr.20120215072959.12521">def typesMatch(self, type1: str, type2: str) -&gt; bool:
    """
    Return True if type1, the actual type, matches type2, the requested type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything *except* shortcuts.
    - Shortcut matches shortcuts.
    """
    # The shortcuts logic no longer uses the get/set code.
    shortcuts = ('shortcut', 'shortcuts',)
    if type1 in shortcuts or type2 in shortcuts:
        g.trace('oops: type in shortcuts')
    return (
        type1 is None
        or type2 is None
        or type1.startswith('string') and type2 not in shortcuts
        or type1 == 'language' and type2 == 'string'
        or type1 == 'int' and type2 == 'size'
        or (type1 in shortcuts and type2 in shortcuts)
        or type1 == type2
    )
</t>
<t tx="ekr.20120215072959.12522">def getAbbrevDict(self) -&gt; dict[str, Any]:
    """Search all dictionaries for the setting &amp; check it's type"""
    d = self.get('abbrev', 'abbrev')
    return d or {}
</t>
<t tx="ekr.20120215072959.12523">def getBool(self, setting: str, default: bool = None) -&gt; bool:
    """Return the value of @bool setting, or the default if the setting is not found."""
    val = self.get(setting, "bool")
    if val in (True, False):
        return val
    return default
</t>
<t tx="ekr.20120215072959.12525">def getColor(self, setting: str) -&gt; str:
    """Return the value of @color setting."""
    col = self.get(setting, "color")
    while col and col.startswith('@'):
        col = self.get(col[1:], "color")
    return col
</t>
<t tx="ekr.20120215072959.12527">def getData(self,
    setting: str,
    strip_comments: bool = True,
    strip_data: bool = True,
) -&gt; list[str]:
    """Return a list of non-comment strings in the body text of @data setting."""
    # 904: Add local abbreviations to global settings.
    append = setting == 'global-abbreviations'
    if append:
        data0 = g.app.config.getData(setting,
            strip_comments=strip_comments,
            strip_data=strip_data,
        )
    data = self.get(setting, "data")
    # New in Leo 4.11: parser.doData strips only comments now.
    # New in Leo 4.12: parser.doData strips *nothing*.
    if isinstance(data, str):
        data = [data]
    if data and strip_comments:
        data = [z for z in data if not z.strip().startswith('#')]
    if data and strip_data:
        data = [z.strip() for z in data if z.strip()]
    if append and data != data0:
        if data:
            data.extend(data0)
        else:
            data = data0
    return data
</t>
<t tx="ekr.20120215072959.12528">def getDirectory(self, setting: str) -&gt; str:
    """Return the value of @directory setting, or None if the directory does not exist."""
    # Fix https://bugs.launchpad.net/leo-editor/+bug/1173763
    theDir = self.get(setting, 'directory')
    if g.os_path_exists(theDir) and g.os_path_isdir(theDir):
        return theDir
    return None
</t>
<t tx="ekr.20120215072959.12530">def getFloat(self, setting: str) -&gt; float:
    """Return the value of @float setting."""
    val = self.get(setting, "float")
    try:
        val = float(val)
        return val
    except TypeError:
        return None
</t>
<t tx="ekr.20120215072959.12531">def getFontFromParams(self,
    family: str, size: str, slant: str, weight: str, defaultSize: int = 12, tag: str = '',
) -&gt; Any:
    """
    Compute a font from font parameters. This should be used *only*
    by the syntax coloring code.  Otherwise, use Leo's style sheets.

    Arguments are the names of settings to be use.
    Default to size=12, slant="roman", weight="normal".

    Return None if there is no family setting so we can use system default fonts.
    """
    family = self.get(family, "family")
    size = self.get(size, "size")
    if size in (None, 0):
        size = str(defaultSize)  # type:ignore
    slant = self.get(slant, "slant")
    if slant in (None, ""):
        slant = "roman"
    weight = self.get(weight, "weight")
    if weight in (None, ""):
        weight = "normal"
    return g.app.gui.getFontFromParams(family, size, slant, weight)
</t>
<t tx="ekr.20120215072959.12532">def getInt(self, setting: str) -&gt; int:
    """Return the value of @int setting."""
    val = self.get(setting, "int")
    try:
        val = int(val)
        return val
    except TypeError:
        return None
</t>
<t tx="ekr.20120215072959.12533">def getLanguage(self, setting: str) -&gt; str:
    """Return the setting whose value should be a language known to Leo."""
    language = self.getString(setting)
    return language
</t>
<t tx="ekr.20120215072959.12534">def getMenusList(self) -&gt; list:
    """Return the list of entries for the @menus tree."""

    # Typically empty, unless there is an @menuat setting.
    aList = self.get('menus', 'menus')

    # Leo calls this method twice when loading an outline.
    if not hasattr(self.c, 'menulist_pass'):
        self.c.menulist_pass = 0
    self.c.menulist_pass += 1

    # Remove this outline's "doMenuat" settings so later outlines won't use them.
    if self.c.menulist_pass == 2:
        lm = g.app.loadManager
        lm.globalSettingsDict['menus'] = None
        self.set(None, 'menus', 'menus', None)
        self.c.menulist_pass = 0

    return aList or g.app.config.menusList
</t>
<t tx="ekr.20120215072959.12535">def getOpenWith(self) -&gt; list[dict[str, Any]]:
    """Return a list of dictionaries corresponding to @openwith nodes."""
    val = self.get('openwithtable', 'openwithtable')
    return val
</t>
<t tx="ekr.20120215072959.12536">def getRatio(self, setting: str) -&gt; float:
    """
    Return the value of @float setting.

    Warn if the value is less than 0.0 or greater than 1.0.
    """
    val = self.get(setting, "ratio")
    try:
        val = float(val)
        if 0.0 &lt;= val &lt;= 1.0:
            return val
    except TypeError:
        pass
    return None
</t>
<t tx="ekr.20120215072959.12538">def getSettingSource(self, setting: str) -&gt; tuple[str, Any]:
    """return the name of the file responsible for setting."""
    d = self.settingsDict
    if d:
        assert isinstance(d, g.SettingsDict), repr(d)
        bi = d.get(setting)
        if bi is None:
            return 'unknown setting', None
        return bi.path, bi.val
    #
    # lm.readGlobalSettingsFiles is opening a settings file.
    # lm.readGlobalSettingsFiles has not yet set lm.globalSettingsDict.
    assert d is None
    return None
</t>
<t tx="ekr.20120215072959.12539">no_menu_dict: dict[Cmdr, bool] = {}

def getShortcut(self, commandName: str) -&gt; tuple[str, list]:
    """Return rawKey,accel for shortcutName"""
    c = self.c
    d = self.shortcutsDict
    if not c.frame.menu:
        if c not in self.no_menu_dict:
            self.no_menu_dict[c] = True
            g.trace(f"no menu: {c.shortFileName()}:{commandName}")
        return None, []
    if d:
        assert isinstance(d, g.SettingsDict), repr(d)  # was TypedDictOfLists.
        key = c.frame.menu.canonicalizeMenuName(commandName)
        key = key.replace('&amp;', '')  # Allow '&amp;' in names.
        aList = d.get(commandName, [])
        if aList:  # A list of g.BindingInfo objects.
            # It's important to filter empty strokes here.
            aList = [z for z in aList
                if z.stroke and z.stroke.lower() != 'none']
        return key, aList
    #
    # lm.readGlobalSettingsFiles is opening a settings file.
    # lm.readGlobalSettingsFiles has not yet set lm.globalSettingsDict.
    return None, []
</t>
<t tx="ekr.20120215072959.12540">def getString(self, setting: str) -&gt; str:
    """Return the value of @string setting."""
    return self.get(setting, "string")
</t>
<t tx="ekr.20120215072959.12543">def getButtons(self) -&gt; list[tuple[str, str]]:
    """Return a list of tuples (x,y) for common @button nodes."""
    return g.app.config.atCommonButtonsList  # unusual.

def getCommands(self) -&gt; list[tuple[str, str]]:
    """Return the list of tuples (headline,script) for common @command nodes."""
    return g.app.config.atCommonCommandsList  # unusual.

def getEnabledPlugins(self) -&gt; str:
    """Return the body text of the @enabled-plugins node."""
    return g.app.config.enabledPluginsString  # unusual.

def getRecentFiles(self) -&gt; list[str]:
    """Return the list of recently opened files."""
    return g.app.config.getRecentFiles()  # unusual
</t>
<t tx="ekr.20120219154958.10452">def load(self, fileName: str = None, pymacs: bool = None) -&gt; None:
    """This is Leo's main startup method."""
    lm = self
    #
    # Phase 1: before loading plugins.
    # Scan options, set directories and read settings.
    t1 = time.process_time()
    if not lm.isValidPython():
        return
    lm.doPrePluginsInit(fileName, pymacs)  # sets lm.options and lm.files
    g.app.computeSignon()
    g.app.printSignon()
    if lm.options.get('version'):
        return
    if not g.app.gui:
        return
    # Disable redraw until all files are loaded.
    g.app.disable_redraw = True
    #
    # Phase 2: load plugins: the gui has already been set.
    t2 = time.process_time()
    g.doHook("start1")
    t3 = time.process_time()
    if g.app.killed:
        return
    g.app.idleTimeManager.start()
    #
    # Phase 3: after loading plugins. Create one or more frames.
    t4 = time.process_time()
    if lm.options.get('script') and not self.files:
        ok = True
    else:
        ok = lm.doPostPluginsInit()
        # Fix #579: Key bindings don't take for commands defined in plugins
        g.app.makeAllBindings()
        if ok and g.app.diff:
            lm.doDiff()
    if not ok:
        # --screen-shot causes an immediate exit.
        if 'shutdown' in g.app.debug or 'startup' in g.app.debug:
            print('Can not create a commander')
        g.app.forceShutdown()
        return
    g.es('')  # Clears horizontal scrolling in the log pane.
    if g.app.listen_to_log_flag:
        g.app.listenToLog()
    if 'startup' in g.app.debug:
        t5 = time.process_time()
        print('')
        g.es_print(f"settings:{t2 - t1:5.2f} sec")
        g.es_print(f" plugins:{t3 - t2:5.2f} sec")
        g.es_print(f"   files:{t4 - t3:5.2f} sec")
        g.es_print(f"  frames:{t5 - t4:5.2f} sec")
        g.es_print(f"   total:{t5 - t1:5.2f} sec")
        print('')
    # -- quit
    if g.app.quit_after_load:
        if 'shutdown' in g.app.debug or 'startup' in g.app.debug:
            print('--quit')
        g.app.forceShutdown()
        return
    # #1128: support for restart-leo.
    if not g.app.start_minimized:
        try:  # Careful: we may be unit testing.
            g.app.log.c.frame.bringToFront()
        except Exception:
            pass
    g.app.gui.runMainLoop()
    # For scripts, the gui is a nullGui.
    # and the gui.setScript has already been called.
</t>
<t tx="ekr.20120219154958.10477">def doPrePluginsInit(self, fileName: str, pymacs: bool) -&gt; None:
    """ Scan options, set directories and read settings."""
    lm = self
    lm.computeStandardDirectories()
    # Scan the options as early as possible.
    lm.options = options = lm.scanOptions(fileName, pymacs)  # also sets lm.files.
    if options.get('version'):
        return
    script = options.get('script')
    verbose = script is None
    # Init the app.
    lm.initApp(verbose)
    g.app.setGlobalDb()
    if verbose:
        lm.reportDirectories()
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    if g.app.quit_after_load:
        localConfigFile = None
    else:
        # Read only standard settings files, using a null gui.
        # uses lm.files[0] to compute the local directory
        # that might contain myLeoSettings.leo.
        lm.readGlobalSettingsFiles()
        # Read the recent files file.
        localConfigFile = lm.files[0] if lm.files else None
        g.app.recentFilesManager.readRecentFiles(localConfigFile)
    # Create the gui after reading options and settings.
    lm.createGui(pymacs)
    # We can't print the signon until we know the gui.
    g.app.computeSignon()  # Set app.signon/signon1 for commanders.
</t>
<t tx="ekr.20120219154958.10478">def createGui(self, pymacs: bool) -&gt; None:
    lm = self
    gui_option = lm.options.get('gui')
    windowFlag = lm.options.get('windowFlag')
    script = lm.options.get('script')
    if g.app.gui:
        if g.app.gui == g.app.nullGui:
            g.app.gui = None  # Enable g.app.createDefaultGui
            g.app.createDefaultGui(__file__)
        else:
            pass
            # This can happen when launching Leo from IPython.
            # This can also happen when leoID does not exist.
    elif gui_option is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        lm.createSpecialGui(gui_option, pymacs, script, windowFlag)
</t>
<t tx="ekr.20120219154958.10479">def createSpecialGui(self, gui: str, pymacs: bool, script: str, windowFlag: bool) -&gt; None:
    # lm = self
    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.argv = []  # 2021/06/24: corrected by mypy.
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        g.app.createDefaultGui()
</t>
<t tx="ekr.20120219154958.10481">def completeFileName(self, fileName: str) -&gt; str:
    fileName = g.toUnicode(fileName)
    fileName = g.finalize(fileName)
    # 2011/10/12: don't add .leo to *any* file.
    return fileName
</t>
<t tx="ekr.20120219154958.10482">def getDefaultFile(self) -&gt; Optional[str]:
    # Get the name of the workbook.
    fn = g.app.config.getString('default-leo-file')
    fn = g.finalize(fn)
    if not fn:
        return None
    if g.os_path_exists(fn):
        return fn
    if g.os_path_isabs(fn):
        # Create the file.
        g.error(f"Using default leo file name:\n{fn}")
        return fn
    # It's too risky to open a default file if it is relative.
    return None
</t>
<t tx="ekr.20120219154958.10484">def initApp(self, verbose: bool) -&gt; None:

    # Can be done early. Uses only g.app.loadDir &amp; g.app.homeDir.
    self.createAllImporterData()
    assert g.app.loadManager
    from leo.core import leoBackground
    from leo.core import leoConfig
    from leo.core import leoNodes
    from leo.core import leoPlugins
    from leo.core import leoSessions
    # Import leoIPython only if requested.  The import is quite slow.
    self.setStdStreams()
    if g.app.useIpython:
        # This launches the IPython Qt Console.  It *is* required.
        from leo.core import leoIPython
        assert leoIPython  # suppress pyflakes/flake8 warning.
    # Make sure we call the new leoPlugins.init top-level function.
    leoPlugins.init()
    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    # Create early classes *after* doing plugins.init()
    g.app.idleTimeManager = IdleTimeManager()
    g.app.backgroundProcessManager = leoBackground.BackgroundProcessManager()
    g.app.externalFilesController = leoExternalFiles.ExternalFilesController()
    g.app.recentFilesManager = RecentFilesManager()
    g.app.config = leoConfig.GlobalConfigManager()
    g.app.nodeIndices = leoNodes.NodeIndices(g.app.leoID)
    g.app.sessionManager = leoSessions.SessionManager()
    # Complete the plugins class last.
    g.app.pluginsController.finishCreate()
</t>
<t tx="ekr.20120219154958.10485">def reportDirectories(self) -&gt; None:
    """Report directories."""
    # The cwd changes later, so it would be misleading to report it here.
    for kind, theDir in (
        ('home', g.app.homeDir),
        ('leo-editor', g.app.leoEditorDir),
        ('load', g.app.loadDir),
        ('config', g.app.globalConfigDir),
    ):  # g.blue calls g.es_print, and that's annoying.
        g.es(f"{kind:&gt;10}:", os.path.normpath(theDir), color='blue')
</t>
<t tx="ekr.20120219154958.10487">def doPostPluginsInit(self) -&gt; bool:
    """Create a Leo window for each file in the lm.files list."""
    # Clear g.app.initing _before_ creating commanders.
    lm = self
    g.app.initing = False  # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.Show it and all queued messages.
    c = c1 = fn = None
    g.app.loaded_session = not lm.files
    if lm.files:
        try:
            for n, fn in enumerate(lm.files):
                lm.more_cmdline_files = n &lt; len(lm.files) - 1
                # Returns None if the file is open in another instance of Leo.
                c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
                if c and not c1:
                    c1 = c
        except Exception:
            g.es_print(f"Unexpected exception reading {fn!r}")
            g.es_exception()
            c = None

    # Load a session if the command line contains no files.
    if g.app.sessionManager and not lm.files:
        try:
            aList = g.app.sessionManager.load_snapshot()
            if aList:
                g.app.sessionManager.load_session(c1, aList)
                if g.app.windowList:
                    c = c1 = g.app.windowList[0].c
                else:
                    c = c1 = None
        except Exception:
            g.es_print('Can not load session')
            g.es_exception()

    # Enable redraws.
    g.app.disable_redraw = False
    if not c1:
        # Open or create a workbook.
        try:
            c1 = lm.openWorkBook()
        except Exception:
            g.es_print('Can not create workbook')
            g.es_exception()
    c = c1
    if not c:
        # Leo is out of options: Force an immediate exit.
        return False
    # #199.
    g.app.runAlreadyOpenDialog(c1)
    #
    # Final inits...
    # For qt gui, select the first-loaded tab.
    if hasattr(g.app.gui, 'frameFactory'):
        factory = g.app.gui.frameFactory
        if factory and hasattr(factory, 'setTabForCommander'):
            factory.setTabForCommander(c)
    g.app.logInited = True
    g.app.initComplete = True
    c.setLog()
    c.redraw()
    g.doHook("start2", c=c, p=c.p, fileName=c.fileName())
    c.initialFocusHelper()
    return True
</t>
<t tx="ekr.20120219154958.10489">def make_screen_shot(self, fn: str) -&gt; None:
    """Create a screenshot of the present Leo outline and save it to path."""
    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
</t>
<t tx="ekr.20120219154958.10491">def isValidPython(self) -&gt; bool:
    if sys.platform == 'cli':
        return True
    message = (
        f"Leo requires Python {g.minimum_python_version} or higher"
        f"You may download Python from http://python.org/download/")
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0, 1, 2)])
        ok = g.CheckVersion(version, g.minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                d = g.EmergencyDialog(
                    title='Python Version Error',
                    message=message)
                d.run()
            except Exception:
                g.es_exception()
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return False
</t>
<t tx="ekr.20120222103014.10312">def openSettingsFile(self, fn: str) -&gt; Optional[Cmdr]:
    """
    Open a settings file with a null gui.  Return the commander.

    The caller must init the c.config object.
    """
    lm = self
    if not fn:
        return None
    theFile = lm.openAnyLeoFile(fn)
    if not theFile:
        return None  # Fix #843.
    if not any([g.unitTesting, g.app.silentMode, g.app.batchMode]):
        # This occurs early in startup, so use the following.
        s = f"reading settings in {os.path.normpath(fn)}"
        if 'startup' in g.app.debug:
            print(s)
        g.es(s, color='blue')
        # A useful trace.
        # g.trace('%20s' % g.shortFileName(fn), g.callers(3))
    # Changing g.app.gui here is a major hack.  It is necessary.
    oldGui = g.app.gui
    g.app.gui = g.app.nullGui
    c = g.app.newCommander(fn)
    frame = c.frame
    frame.log.enable(False)
    g.app.lockLog()
    g.app.openingSettingsFile = True
    try:
        ok = c.fileCommands.openLeoFile(theFile, fn,
                readAtFileNodesFlag=False, silent=True)  # closes theFile.
    finally:
        g.app.openingSettingsFile = False
    g.app.unlockLog()
    c.openDirectory = frame.openDirectory = g.os_path_dirname(fn)
    g.app.gui = oldGui
    return c if ok else None
</t>
<t tx="ekr.20120223062418.10393">def loadLocalFile(self, fn: str, gui: LeoGui, old_c: Optional[Cmdr]) -&gt; Optional[Cmdr]:
    """Completely read a file, creating the corresonding outline.

    1. If fn is an existing .leo, .db or .leojs file, read it twice:
    the first time with a NullGui to discover settings,
    the second time with the requested gui to create the outline.

    2. If fn is an external file:
    get settings from the leoSettings.leo and myLeoSetting.leo, then
    create a "wrapper" outline continain an @file node for the external file.

    3. If fn is empty:
    get settings from the leoSettings.leo and myLeoSetting.leo or default settings,
    or open an empty outline.
    """
    lm = self
    # #2489: If fn is empty, open an empty, untitled .leo file.
    if not fn:
        return lm.openEmptyLeoFile(gui, old_c)
    # Return the commander if the file is an already open outline.
    fn = g.finalize(fn)
    c = lm.findOpenFile(fn)
    if c:
        return c
    # Open the file, creating a wrapper .leo file if necessary.
    previousSettings = lm.getPreviousSettings(fn)
    c = lm.openFileByName(fn, gui, old_c, previousSettings)
    return c
</t>
<t tx="ekr.20120223062418.10394">def openFileByName(self,
    fn: str,
    gui: LeoGui,
    old_c: Optional[Cmdr],
    previousSettings: "PreviousSettings",
) -&gt; Optional[Cmdr]:
    """
    Create an outline (Commander) for either:
    - a Leo file (including .leo or zipped file),
    - an external file.

    Note: The settings don't matter for pre-reads!
    For second read, the settings for the file are *exactly* previousSettings.
    """
    lm = self
    # Disable the log.
    g.app.setLog(None)
    g.app.lockLog()
    # Create the a commander for the .leo file.
    c = g.app.newCommander(
        fileName=fn,
        gui=gui,
        previousSettings=previousSettings,
    )
    g.doHook('open0')
    # Open the file before the open1 hook.
    theFile = lm.openAnyLeoFile(fn)
    if isinstance(theFile, sqlite3.Connection):
        # This commander is associated with sqlite db.
        c.sqlite_connection = theFile
    # Enable the log and do the open1 hook.
    g.app.unlockLog()
    c.frame.log.enable(True)
    # Create the outline.
    g.doHook("open1", old_c=None, c=c, new_c=c, fileName=fn)
    if theFile:
        # Some kind of existing Leo file.
        readAtFileNodesFlag = bool(previousSettings)
        # Read the Leo file.
        ok = lm.readOpenedLeoFile(c, fn, readAtFileNodesFlag, theFile)
        if not ok:
            return None
    else:
        # Not a any kind of Leo file. Create a wrapper .leo file.
        c = lm.initWrapperLeoFile(c, fn)  # #2489
        g.doHook("new", old_c=old_c, c=c, new_c=c)  # #2489.
    g.doHook("open2", old_c=old_c, c=c, new_c=c, fileName=fn)
    # Complete the inits.
    g.app.writeWaitingLog(c)
    c.setLog()
    lm.createMenu(c, fn)
    lm.finishOpen(c)
    return c
</t>
<t tx="ekr.20120223062418.10405">def createMenu(self, c: Cmdr, fn: str = None) -&gt; None:
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
            # c.enableMenuBar()
</t>
<t tx="ekr.20120223062418.10406">def findOpenFile(self, fn: str) -&gt; Optional[Cmdr]:

    def munge(name: str) -&gt; str:
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # Don't call frame.bringToFront(), it breaks --minimize
            c.setLog()
            # Selecting the new tab ensures focus is set.
            master = getattr(frame.top, 'leo_master', None)
            if master:  # master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
</t>
<t tx="ekr.20120223062418.10407">def finishOpen(self, c: Cmdr) -&gt; None:
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController:
        c.chapterController.finishCreate()
    if k:
        k.setDefaultInputState()
    c.initialFocusHelper()
    if k:
        k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()  # #181: Honor focus requests.
</t>
<t tx="ekr.20120223062418.10408">def initWrapperLeoFile(self, c: Cmdr, fn: str) -&gt; Optional[Cmdr]:
    """
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    """
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    # #1570: Resize the _new_ frame.
    frame.splitVerticalFlag, r1, r2 = frame.initialRatios()
    frame.resizePanesToRatio(r1, r2)
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        # Fix #1070: Use "newHeadline", not fn.
        p.h = "newHeadline" if fn.endswith('.leo') else f"@edit {fn}"
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None)  # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p:
            return None
    else:
        # Create an @&lt;file&gt; node.
        p = c.rootPosition()
        if p:
            # The 'load_type' key may not exist when run from the bridge.
            load_type = self.options.get('load_type', '@edit')  # #2489.
            p.setHeadString(f"{load_type} {fn}")
            c.refreshFromDisk()
            c.selectPosition(p)
    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else f"{fn}.leo"
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    if c.config.getBool('use-chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.clearChanged()
    return c
</t>
<t tx="ekr.20120223062418.10410">def openZipFile(self, fn: str) -&gt; Any:
    """
    Open a zipped file for reading.
    Return a StringIO file if successful.
    """
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile:
            return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name:
            return None
        s = theFile.read(name)
        s2 = g.toUnicode(s, 'utf-8')
        return StringIO(s2)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
</t>
<t tx="ekr.20120223062418.10412">def readOpenedLeoFile(self,
    c: Cmdr,
    fn: str,
    readAtFileNodesFlag: bool,
    theFile: Any,
) -&gt; VNode:
    """
    Call c.fileCommands.openLeoFile to open some kind of Leo file.

    the_file: An open file, which is a StringIO file for zipped files.

    Note: g.app.log is not inited here.
    """
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # Read and close the file.
    v = c.fileCommands.openLeoFile(
        theFile, fn, readAtFileNodesFlag=readAtFileNodesFlag)
    if v:
        if not c.openDirectory:
            theDir = g.finalize(g.os_path_dirname(fn))
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        # #970: Never close Leo here.
        g.app.closeLeoWindow(c.frame, finish_quit=False)
    return v
</t>
<t tx="ekr.20120223062418.10414">def getPreviousSettings(self, fn: str) -&gt; "PreviousSettings":
    """
    Return the settings in effect for fn. Typically, this involves
    pre-reading fn.
    """
    lm = self
    settingsName = f"settings dict for {g.shortFileName(fn)}"
    shortcutsName = f"shortcuts dict for {g.shortFileName(fn)}"
    # A special case: settings in leoSettings.leo do *not* override
    # the global settings, that is, settings in myLeoSettings.leo.
    isLeoSettings = fn and g.shortFileName(fn).lower() == 'leosettings.leo'
    exists = g.os_path_exists(fn)
    if fn and exists and lm.isLeoFile(fn) and not isLeoSettings:
        # Open the file usinging a null gui.
        try:
            g.app.preReadFlag = True
            c = lm.openSettingsFile(fn)
        finally:
            g.app.preReadFlag = False
        # Merge the settings from c into *copies* of the global dicts.
        d1, d2 = lm.computeLocalSettings(c,
            lm.globalSettingsDict,
            lm.globalBindingsDict,
            localFlag=True)  # d1 and d2 are copies.
        d1.setName(settingsName)
        d2.setName(shortcutsName)
        return PreviousSettings(d1, d2)
    #
    # The file does not exist, or is not valid.
    # Get the settings from the globals settings dicts.
    if lm.globalSettingsDict and lm.globalBindingsDict:  # #1766.
        d1 = lm.globalSettingsDict.copy()
        d2 = lm.globalBindingsDict.copy()
    else:
        d1 = d2 = None
    return PreviousSettings(d1, d2)
</t>
<t tx="ekr.20120223062418.10416">def openLeoFile(self, fn: str) -&gt; Any:
    """Open the file for reading."""
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
</t>
<t tx="ekr.20120223062418.10419">def isLeoFile(self, fn: str) -&gt; bool:
    """
    Return True if fn is any kind of Leo file,
    including a zipped file or .leo, .db, or .leojs file.
    """
    if not fn:
        return False
    return zipfile.is_zipfile(fn) or fn.endswith(('.leo', 'db', '.leojs'))

def isZippedFile(self, fn: str) -&gt; bool:
    """Return True if fn is a zipped file."""
    return bool(fn and zipfile.is_zipfile(fn))
</t>
<t tx="ekr.20120223062418.10421">def computeLocalSettings(self,
    c: Cmdr,
    settings_d: g.SettingsDict,
    bindings_d: g.SettingsDict,
    localFlag: bool,
) -&gt; tuple[g.SettingsDict, g.SettingsDict]:
    """
    Merge the settings dicts from c's outline into *new copies of*
    settings_d and bindings_d.
    """
    lm = self
    shortcuts_d2, settings_d2 = lm.createSettingsDicts(c, localFlag)
    if not bindings_d:  # #1766: unit tests.
        settings_d, bindings_d = lm.createDefaultSettingsDicts()
    if settings_d2:
        if g.app.trace_setting:
            key = g.app.config.munge(g.app.trace_setting)
            val = settings_d2.get(key)
            if val:
                fn = g.shortFileName(val.path)
                g.es_print(
                    f"--trace-setting: in {fn:20}: "
                    f"@{val.kind} {g.app.trace_setting}={val.val}")
        settings_d = settings_d.copy()
        settings_d.update(settings_d2)
    if shortcuts_d2:
        bindings_d = lm.mergeShortcutsDicts(c, bindings_d, shortcuts_d2, localFlag)
    return settings_d, bindings_d
</t>
<t tx="ekr.20120224140548.10528">def exists(self, c: Cmdr, setting: str, kind: str) -&gt; bool:
    """Return true if a setting of the given kind exists, even if it is None."""
    d = self.settingsDict
    if d:
        junk, found = self.getValFromDict(d, setting, kind)
        if found:
            return True
    return False
</t>
<t tx="ekr.20120224161905.10030">def openAnyLeoFile(self, fn: str) -&gt; Any:
    """Open a .leo, .leojs or .db file."""
    lm = self
    if fn.endswith('.db'):
        return sqlite3.connect(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if lm.isZippedFile(fn):
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
</t>
<t tx="ekr.20120309073937.9878"></t>
<t tx="ekr.20120311070142.9904">def checkForDuplicateShortcuts(self, c: Cmdr, d: dict[str, str]) -&gt; None:
    """
    Check for duplicates in an "inverted" dictionary d
    whose keys are strokes and whose values are lists of BindingInfo nodes.

    Duplicates happen only if panes conflict.
    """
    # Fix bug 951921: check for duplicate shortcuts only in the new file.
    for ks in sorted(list(d.keys())):
        duplicates, panes = [], ['all']
        aList = d.get(ks)  # A list of bi objects.
        aList2 = [z for z in aList if not z.pane.startswith('mode')]
        if len(aList) &gt; 1:
            for bi in aList2:
                if bi.pane in panes:
                    duplicates.append(bi)
                else:
                    panes.append(bi.pane)
        if duplicates:
            bindings = list(set([z.stroke.s for z in duplicates]))
            if len(bindings) == 1:
                kind = 'duplicate, (not conflicting)'
            else:
                kind = 'conflicting'
            g.es_print(f"{kind} key bindings in {c.shortFileName()}")
            for bi in aList2:
                g.es_print(f"{bi.pane:6} {bi.stroke.s} {bi.commandName}")
</t>
<t tx="ekr.20120311151914.9918">def isValidUrl(url: str) -&gt; bool:
    """Return true if url *looks* like a valid url."""
    table = (
        'file', 'ftp', 'gopher', 'hdl', 'http', 'https', 'imap',
        'mailto', 'mms', 'news', 'nntp', 'prospero', 'rsync', 'rtsp', 'rtspu',
        'sftp', 'shttp', 'sip', 'sips', 'snews', 'svn', 'svn+ssh', 'telnet', 'wais',
    )
    if not url:
        return False  # pragma: no cover (defensive)
    if g.isValidUnl(url):
        return True
    if url.startswith('@'):
        return False
    parsed = urlparse.urlparse(url)
    scheme = parsed.scheme
    for s in table:
        if scheme.startswith(s):
            return True
    return False
</t>
<t tx="ekr.20120320053907.9776">def computeFileUrl(fn: str, c: Cmdr = None, p: Position = None) -&gt; str:
    """
    Compute finalized url for filename fn.
    """
    # First, replace special characters (especially %20, by their equivalent).
    url = urllib.parse.unquote(fn)
    # Finalize the path *before* parsing the url.
    i = url.find('~')
    if i &gt; -1:
        # Expand '~'.
        path = url[i:]
        path = g.finalize(path)
        url = url[:i] + path
    else:
        tag = 'file://'
        tag2 = 'file:///'
        if sys.platform.startswith('win') and url.startswith(tag2):
            path = url[len(tag2) :].lstrip()
        elif url.startswith(tag):
            path = url[len(tag) :].lstrip()
        else:
            path = url
        # Handle ancestor @path directives.
        if c and c.openDirectory:
            base = c.getNodePath(p)
            path = g.finalize_join(c.openDirectory, base, path)
        else:
            path = g.finalize(path)
        url = f"{tag}{path}"
    return url
</t>
<t tx="ekr.20120420054855.14245">def get_session(self) -&gt; list[str]:
    """Return a list of UNLs for open tabs."""
    result: list[str] = []
    # Fix #1118, part 2.
    if not getattr(g.app.gui, 'frameFactory', None):
        return result
    mf = getattr(g.app.gui.frameFactory, 'masterFrame', None)
    if mf:
        outlines = [mf.widget(i).leo_c for i in range(mf.count())]
    else:
        outlines = [i.c for i in g.app.windowList]
    for c in outlines:
        result.append(c.p.get_full_gnx_UNL())
    return result
</t>
<t tx="ekr.20120420054855.14247">def load_session(self, c: Cmdr = None, unls: list[str] = None) -&gt; None:
    """
    Open a tab for each item in UNLs &amp; select the indicated node in each.

    unls is the list returned by SessionManager.load_snapshot()
    """
    if not unls:
        return
    unls = [z.strip() for z in unls or [] if z.strip()]
    for unl in unls:
        if not g.isValidUnl(unl):
            g.trace(f"Ignoring invalid session {'unl'}: {unl!r}")
            continue
        fn = g.getUNLFilePart(unl)
        exists = fn and g.os_path_exists(fn)
        if not exists:
            g.trace('File part does not exist', repr(fn))
            g.trace(f"Bad unl: {unl!r}")
            continue
        if 'startup' in g.app.debug:
            g.trace('loading session file:', fn)
        # This selects the proper position.
        g.app.loadManager.loadLocalFile(fn, gui=g.app.gui, old_c=c)
</t>
<t tx="ekr.20120420054855.14248">def load_snapshot(self) -&gt; str:
    """
    Load a snapshot of a session from the leo.session file.
    """
    try:
        session = g.app.db['session']
        if 'startup' in g.app.debug:
            g.printObj(session, tag='load_snapshot: session data')
        return session
    except KeyError:
        print('SessionManager.load_snapshot: no previous session')
    except Exception:
        g.trace('Unexpected exception in SessionManager.load_snapshot')
        g.es_exception()
    return None
</t>
<t tx="ekr.20120420054855.14249">def save_snapshot(self) -&gt; None:
    """
    Save a snapshot of the present session to the leo.session file.

    Called automatically during shutdown.
    """
    if g.app.batchMode or g.app.inBridge or g.unitTesting:
        return
    try:
        session = self.get_session()
        if 'shutdown' in g.app.debug:
            g.printObj(session, tag='save_snapshot: session data')
        if not session:
            return  # #2433: don't save an empty session.
        g.app.db['session'] = session
    except Exception:
        g.trace('Unexpected exception in SessionManager.save_snapshot')
        g.es_exception()
</t>
<t tx="ekr.20121126102050.10134"></t>
<t tx="ekr.20121126202114.3">def createDefaultSettingsDicts(self) -&gt; tuple[g.SettingsDict, g.SettingsDict]:
    """Create lm.globalSettingsDict &amp; lm.globalBindingsDict."""
    settings_d = g.SettingsDict('lm.globalSettingsDict')
    bindings_d = g.SettingsDict('lm.globalBindingsDict')
    return settings_d, bindings_d
</t>
<t tx="ekr.20130524063409.10700">def cloneAsNthChild(self, parent_v: VNode, n: int) -&gt; VNode:
    # Does not check for illegal clones!
    v = self
    v._linkAsNthChild(parent_v, n)
    return v

def insertAsFirstChild(self) -&gt; VNode:
    v = self
    return v.insertAsNthChild(0)

def insertAsLastChild(self) -&gt; VNode:
    v = self
    return v.insertAsNthChild(len(v.children))

def insertAsNthChild(self, n: int) -&gt; VNode:
    v = self
    assert 0 &lt;= n &lt;= len(v.children)
    v2 = VNode(v.context)
    v2._linkAsNthChild(v, n)
    assert v.children[n] == v2
    return v2
</t>
<t tx="ekr.20130804061744.12425">if 0:  # Override for debugging only.

    def setWindowTitle(self, s: str) -&gt; None:
        g.trace('***(DynamicWindow)', s, self.parent())
        # Call the base class method.
        QtWidgets.QMainWindow.setWindowTitle(self, s)
</t>
<t tx="ekr.20130823083943.12559">def recursiveImport(
    self,
    *,  # All arguments are kwargs.
    dir_: str = None,  # A directory or file name.
    ignore_pattern: re.Pattern = None,  # Ignore files matching this regex pattern.
    kind: str = None,
    recursive: bool = True,
    safe_at_file: bool = True,
    theTypes: list[str] = None,
    verbose: bool = True,
) -&gt; None:
    &lt;&lt; docstring &gt;&gt;
    c = self
    if not dir_:
        g.es_print('Missing dir_ argument')
        return
    if not g.os_path_exists(dir_):
        g.es_print(f"Directory/file does not exist: {dir_}")
        return
    # Import all files in dir_ after c.p.
    try:
        from leo.core import leoImport
        cc = leoImport.RecursiveImportController(c,
            dir_=dir_,
            ignore_pattern=ignore_pattern,
            kind=kind,
            recursive=recursive,
            safe_at_file=safe_at_file,
            theTypes=['.py'] if not theTypes else theTypes,
            verbose=verbose,
        )
        cc.run(dir_)
    except AssertionError:
        g.es_exception()
    finally:
        c.redraw()
</t>
<t tx="ekr.20130823083943.12596">class RecursiveImportController:
    """Recursively import all python files in a directory and clean the result."""
    @others
</t>
<t tx="ekr.20130823083943.12597">def import_dir(self, dir_: str, parent: Position) -&gt; None:
    """Import selected files from dir_, a directory."""
    if g.os_path_isfile(dir_):
        files = [dir_]
    else:
        if self.verbose:
            g.es_print('importing directory:', dir_)
        files = list(sorted(os.listdir(dir_)))
    dirs, files2 = [], []
    for path in files:
        try:
            # Catch path exceptions: keep going on small errors.
            path = g.os_path_join(dir_, path)
            if g.os_path_isfile(path):
                name, ext = g.os_path_splitext(path)
                if ext in self.theTypes:
                    files2.append(path)
            elif self.recursive:
                if not self.ignore_pattern.search(path):
                    dirs.append(path)
        except OSError:
            g.es_print('Exception computing', path)
            g.es_exception()
    if files or dirs:
        parent = parent.insertAsLastChild()
        parent.v.h = dir_
        if files2:
            for f in files2:
                if not self.ignore_pattern.search(f):
                    self.import_one_file(f, parent=parent)
        if dirs:
            assert self.recursive
            for dir_ in sorted(dirs):
                self.import_dir(dir_, parent)
</t>
<t tx="ekr.20130823083943.12607">def post_process(self, p: Position) -&gt; None:
    """
    Traverse p's tree, replacing all nodes that start with prefix
    by the smallest equivalent @path or @file node.
    """
    assert self.root_directory
    self.fix_back_slashes(p)
    for p2 in p.subtree():
        self.minimize_headline(p2)
    if self.kind not in ('@auto', '@edit'):
        self.remove_empty_nodes(p)
    self.clear_dirty_bits(p)
    self.add_class_names(p)
</t>
<t tx="ekr.20130823083943.12608">def clear_dirty_bits(self, p: Position) -&gt; None:
    c = self.c
    c.clearChanged()  # Clears *all* dirty bits.
    for p in p.self_and_subtree(copy=False):
        p.clearDirty()
</t>
<t tx="ekr.20130823083943.12609">def dump_headlines(self, p: Position) -&gt; None:
    # show all headlines.
    for p in p.self_and_subtree(copy=False):
        print(p.h)
</t>
<t tx="ekr.20130823083943.12610">def fix_back_slashes(self, p: Position) -&gt; None:
    """Convert backslash to slash in all headlines."""
    for p in p.self_and_subtree(copy=False):
        s = p.h.replace('\\', '/')
        if s != p.h:
            p.v.h = s
</t>
<t tx="ekr.20130823083943.12611">def minimize_headline(self, p: Position) -&gt; None:
    """
    Adjust headlines and add @path directives to headlines or body text.
    Create an @path directive in  @&lt;file&gt; nodes.
    """

    assert os.path.isabs(self.root_directory)

    def relative_path(path: str) -&gt; str:
        """Return path relative to the root directory."""
        assert path.startswith(self.root_directory), repr(path)
        assert os.path.isabs(path), repr(path)
        path = path.split('/')[-1] if '/' in path else path
        return path

    def compute_at_path_path(path: str) -&gt; str:
        """Compute the relative path to be used in an @path directive."""
        assert path.startswith(self.root_directory), repr(path)
        assert os.path.isabs(path), repr(path)
        path = path[len(self.root_directory) :]
        if path.startswith('/'):
            path = path[1:]
        return path

    m = self.file_pattern.match(p.h)
    if m:
        # p is an @file node of some kind.
        kind = m.group(0)
        path = p.h[len(kind) :].strip().replace('\\', '/')
        # Shorten p.h.
        p.h = f"{kind} {relative_path(path)}"
        # Prepend an @path directive to p.b if it has a directory component.
        path = compute_at_path_path(path)
        if path and '/' in path:
            directory = '/'.join(path.split('/')[:-1])
            p.b = f"@path {directory}\n{p.b}"
    elif '/' in p.h and p.h == self.root_directory:
        # Show the last component.
        directory = p.h.split('/')[-1]
        p.h = f"path: {directory}"
    elif p.h.startswith(self.root_directory):
        # The importer has created the start of an @path node.
        h = compute_at_path_path(p.h)
        if h:
            p.h = f"path: {h}"
</t>
<t tx="ekr.20130823083943.12612">def remove_empty_nodes(self, p: Position) -&gt; None:
    """Remove empty nodes. Not called for @auto or @edit trees."""
    c = self.c

    def has_significant_children(p: Position) -&gt; bool:
        """Return True if p has any descendant that is not an @path node."""
        if not p.hasChildren():
            return False
        if not p.h.startswith('path: '):
            return True
        for p2 in p.subtree():
            if has_significant_children(p2):
                return True
        return False

    aList = [
        p2 for p2 in p.self_and_subtree()
            if not p2.b.strip() and not has_significant_children(p2)]
    if aList:
        c.deletePositionsInList(aList)  # Don't redraw.
</t>
<t tx="ekr.20130823083943.12613">def run(self, dir_: str) -&gt; None:
    """
    Import all files whose extension matches self.theTypes in dir_.
    In fact, dir_ can be a path to a single file.
    """
    if self.kind not in ('@auto', '@clean', '@edit', '@file', '@nosent'):
        g.es('bad kind param', self.kind, color='red')
        return
    try:
        c, u = self.c, self.c.undoer
        t1 = time.time()
        g.app.disable_redraw = True
        last = c.lastTopLevel()
        c.selectPosition(last)
        undoData = u.beforeInsertNode(last)
        # Always create a new last top-level node.
        self.root = parent = last.insertAfter()
        parent.v.h = 'imported files'
        # Special case for a single file.
        self.n_files = 0
        if g.os_path_isfile(dir_):
            if self.verbose:
                g.es_print('\nimporting file:', dir_)
            self.import_one_file(dir_, parent)
        else:
            self.import_dir(dir_, parent)
        self.post_process(parent)
        u.afterInsertNode(parent, 'recursive-import', undoData)
    except Exception:
        g.es_print('Exception in recursive import')
        g.es_exception()
    finally:
        g.app.disable_redraw = False
        for p2 in parent.self_and_subtree(copy=False):
            p2.contract()
        c.redraw(parent)
    if not g.unitTesting:
        t2 = time.time()
        n = len(list(parent.self_and_subtree()))
        g.es_print(
            f"imported {n} node{g.plural(n)} "
            f"in {self.n_files} file{g.plural(self.n_files)} "
            f"in {t2 - t1:2.2f} seconds")
</t>
<t tx="ekr.20130823083943.12614">"""
Recursively import all python files in a directory and clean the results.

Parameters::
    dir_              The root directory or file to import.
    kind              One of ('@clean','@edit','@file','@nosent').
    recursive=True    True: recurse into subdirectories.
    safe_at_file=True True: produce @@file nodes instead of @file nodes.
    theTypes=None     A list of file extensions to import.
                      None is equivalent to ['.py']

This method cleans imported files as follows:

- Replace backslashes with forward slashes in headlines.
- Remove empty nodes.
- Add @path directives that reduce the needed path specifiers in descendant nodes.
- Add @file to nodes or replace @file with @@file.
"""
</t>
<t tx="ekr.20130823083943.12615">def __init__(self, c: Cmdr,
    *,  # All other args are kwargs.
    dir_: str,
    ignore_pattern: re.Pattern = None,
    kind: str,
    recursive: bool = True,
    safe_at_file: bool = True,
    theTypes: list[str] = None,
    verbose: bool = True,  # legacy value.
) -&gt; None:
    """Ctor for RecursiveImportController class."""
    self.c = c
    self.file_pattern = re.compile(r'^(@@|@)(auto|clean|edit|file|nosent)')
    self.ignore_pattern = ignore_pattern or re.compile(r'\.git|node_modules')
    self.kind = kind  # in ('@auto', '@clean', '@edit', '@file', '@nosent')
    self.recursive = recursive
    self.root: Position = None
    self.root_directory = dir_ if os.path.isdir(dir_) else os.path.dirname(dir_)
    # Adjust the root directory.
    assert dir_ and self.root_directory, dir_
    self.root_directory = self.root_directory.replace('\\', '/')
    if self.root_directory.endswith('/'):
        self.root_directory = self.root_directory[:-1]
    self.safe_at_file = safe_at_file
    self.theTypes = theTypes
    self.verbose = verbose
</t>
<t tx="ekr.20130915111638.11288">def goPrev(self) -&gt; Optional[Position]:
    """Select the previously visited node, if possible."""
    if self.beadPointer &gt; 0:
        self.beadPointer -= 1
        p, chapter = self.beadList[self.beadPointer]
        self.select(p, chapter)
        return p
    return None
</t>
<t tx="ekr.20130915111638.11294">def select(self, p: Position, chapter: Any) -&gt; None:
    """
    Update the history list when selecting p.

    Only self.goNext and self.goPrev call this method.
    """
    c, cc = self.c, self.c.chapterController
    if c.positionExists(p):
        self.skipBeadUpdate = True
        try:
            oldChapter = cc.getSelectedChapter()
            if oldChapter != chapter:
                cc.selectChapterForPosition(p, chapter=chapter)
            c.selectPosition(p)  # Calls cc.selectChapterForPosition
        finally:
            self.skipBeadUpdate = False
    # Fix bug #180: Always call self.update here.
    self.update(p, change=False)
</t>
<t tx="ekr.20130921043420.21175">def setFilter(self, c: Cmdr, obj: Any, w: Wrapper, tag: str) -&gt; None:
    """
    Create an event filter in obj.
    w is a wrapper object, not necessarily a QWidget.
    """
    # w's type is in (DynamicWindow,QMinibufferWrapper,LeoQtLog,LeoQtTree,
    # QTextEditWrapper,LeoQTextBrowser,LeoQuickSearchWidget,cleoQtUI)
    assert isinstance(obj, QtWidgets.QWidget), obj
    theFilter = qt_events.LeoQtEventFilter(c, w=w, tag=tag)
    obj.installEventFilter(theFilter)
    w.ev_filter = theFilter  # Set the official ivar in w.
</t>
<t tx="ekr.20130923111858.11572">def insertBefore(self) -&gt; Position:
    """
    Insert a new position before self.

    Return the newly created position.
    """
    p = self
    parent = p.parent()
    if p.hasBack():
        back = p.getBack()
        p = back.insertAfter()
    elif parent:
        p = parent.insertAsNthChild(0)
    else:
        p = p.insertAfter()
        p.moveToRoot()
    return p
</t>
<t tx="ekr.20131028155339.17098">def openWorkBook(self) -&gt; Cmdr:
    """
    Open or create a new workbook.

    @string default-leo-file gives the path, defaulting to ~/.leo/workbook.leo.

    Return the new commander.
    """
    # Never create a workbook during unit tests or in batch mode.
    if g.unitTesting or g.app.batchMode:
        return None
    fn = self.computeWorkbookFileName()
    exists = fn and os.path.exists(fn)
    if not fn:
        # The usual directory does not exist. Create an empty file.
        c = self.openEmptyLeoFile(gui=g.app.gui, old_c=None)
        c.rootPosition().h = 'Workbook'
    else:
        # Open the workboook or create an empty file.
        c = self.loadLocalFile(fn, gui=g.app.gui, old_c=None)
        if not exists:
            c.rootPosition().h = 'Workbook'
    # Create the outline with workbook's name.
    c.frame.title = title = c.computeWindowTitle(fn)
    c.frame.setTitle(title)
    c.openDirectory = c.frame.openDirectory = g.os_path_dirname(fn)
    if hasattr(c.frame, 'top'):
        c.frame.top.leo_master.setTabName(c, fn)
    # Finish: Do *not* save the file!
    g.chdir(fn)
    g.app.already_open_files = []
    c.clearChanged()
    # Do not redraw. Do not set c.p.
    return c
</t>
<t tx="ekr.20131114051702.16542">def getOutlineData(self, setting: str) -&gt; Any:
    """Return the pastable (xml) text of the entire @outline-data tree."""
    data = self.get(setting, "outlinedata")
    if setting == 'tree-abbreviations':
        # 904: Append local tree abbreviations to the global abbreviations.
        data0 = g.app.config.getOutlineData(setting)
        if data and data0 and data != data0:
            assert isinstance(data0, str)
            assert isinstance(data, str)
            # We can't merge the data here: they are .leo files!
            # abbrev.init_tree_abbrev_helper does the merge.
            data = [data0, data]
    return data
</t>
<t tx="ekr.20131118152731.16847">def create_find_grid(self, parent: LeoQtFrame) -&gt; Any:
    grid = self.createGrid(parent, 'findGrid', margin=10, spacing=10)
    grid.setColumnStretch(0, 100)
    grid.setColumnStretch(1, 100)
    grid.setColumnStretch(2, 10)
    grid.setColumnMinimumWidth(1, 75)
    grid.setColumnMinimumWidth(2, 175)
    return grid
</t>
<t tx="ekr.20131118152731.16848">def create_find_findbox(self, grid: Any, parent: LeoQtFrame, row: int) -&gt; int:
    """Create the Find: label and text area."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_findbox is None
    ftm.find_findbox = w = dw.createLineEdit(  # type:ignore
        parent, 'findPattern', disabled=fc.expert_mode)
    lab2 = self.createLabel(parent, 'findLabel', 'Find:')
    grid.addWidget(lab2, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
</t>
<t tx="ekr.20131118152731.16849">def create_find_header(self, grid: Any, parent: LeoQtFrame, row: int) -&gt; int:
    if False:
        dw = self
        lab1 = dw.createLabel(parent, 'findHeading', 'Find/Change Settings...')
        grid.addWidget(lab1, row, 0, 1, 2, Alignment.AlignLeft)  # AlignHCenter
        row += 1
    return row
</t>
<t tx="ekr.20131118152731.16850">def create_find_replacebox(self, grid: Any, parent: LeoQtFrame, row: int) -&gt; int:
    """Create the Replace: label and text area."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_replacebox is None
    ftm.find_replacebox = w = dw.createLineEdit(  # type:ignore
        parent, 'findChange', disabled=fc.expert_mode)
    lab3 = dw.createLabel(parent, 'changeLabel', 'Replace:')  # Leo 4.11.1.
    grid.addWidget(lab3, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
</t>
<t tx="ekr.20131118152731.16851">def create_find_checkboxes(self, grid: Any, parent: LeoQtFrame, max_row2: int, row: int) -&gt; int:
    """Create check boxes and radio buttons."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm

    def mungeName(kind: str, label: str) -&gt; str:
        # The returned value is the namve of an ivar.
        kind = 'check_box_' if kind == 'box' else 'radio_button_'
        name = label.replace(' ', '_').replace('&amp;', '').lower()
        return f"{kind}{name}"

    # Rows for check boxes, radio buttons &amp; execution buttons...

    d = {
        'box': dw.createCheckBox,
        'rb': dw.createRadioButton,
    }
    table = (
        # Note: the Ampersands create Alt bindings when the log pane is enable.
        # The QShortcut class is the workaround.
        # First row.
        ('box', 'whole &amp;Word', 0, 0),
        ('rb', '&amp;Entire outline', 0, 1),
        # Second row.
        ('box', '&amp;Ignore case', 1, 0),
        ('rb', '&amp;Suboutline only', 1, 1),
        # Third row.
        ('box', 'rege&amp;Xp', 2, 0),
        ('rb', '&amp;Node only', 2, 1),
        # Fourth row.
        ('box', 'mark &amp;Finds', 3, 0),
        ('rb', 'fi&amp;Le only', 3, 1),
        # Fifth row.
        ('box', 'mark &amp;Changes', 4, 0),
        ('box', 'search &amp;Headline', 4, 1),
        # Sixth Row
        ('box', 'search &amp;Body', 5, 1),

        # ('box', 'rege&amp;Xp', 2, 0),
        # ('rb', '&amp;Node only', 2, 1),
        # # Fourth row.
        # ('box', 'mark &amp;Finds', 3, 0),
        # ('box', 'search &amp;Headline', 3, 1),
        # # Fifth row.
        # ('box', 'mark &amp;Changes', 4, 0),
        # ('box', 'search &amp;Body', 4, 1),
        # ('rb', 'File &amp;Only', 5, 1),

        # Sixth row.
        # ('box', 'wrap &amp;Around', 5, 0),
        # a,b,c,e,f,h,i,n,rs,w
    )
    for kind, label, row2, col in table:
        max_row2 = max(max_row2, row2)
        name = mungeName(kind, label)
        func = d.get(kind)
        assert func
        # Fix the greedy checkbox bug:
        label = label.replace('&amp;', '')
        w = func(parent, name, label)
        grid.addWidget(w, row + row2, col)
        # The the checkbox ivars in dw and ftm classes.
        assert getattr(ftm, name) is None
        setattr(ftm, name, w)
    return max_row2
</t>
<t tx="ekr.20131118152731.16852">def create_find_buttons(self, grid: Any, parent: LeoQtFrame, max_row2: int, row: int) -&gt; int:
    """
    Per #1342, this method now creates labels, not real buttons.
    """
    dw, k = self, self.leo_c.k

    # Create Buttons in column 2 (Leo 4.11.1.)
    table = (
        (0, 2, 'find-next'),  # 'findButton',
        (1, 2, 'find-prev'),  # 'findPreviousButton',
        (2, 2, 'find-all'),  # 'findAllButton',
        (3, 2, 'replace'),  # 'changeButton',
        (4, 2, 'replace-then-find'),  # 'changeThenFindButton',
        (5, 2, 'replace-all'),  # 'changeAllButton',
    )
    for row2, col, cmd_name in table:
        stroke = k.getStrokeForCommandName(cmd_name)
        if stroke:
            label = f"{cmd_name}:  {k.prettyPrintKey(stroke)}"
        else:
            label = cmd_name
        # #1342: Create a label, not a button.
        w = dw.createLabel(parent, cmd_name, label)
        w.setObjectName('find-label')
        grid.addWidget(w, row + row2, col)
    row += max_row2
    row += 2
    return row
</t>
<t tx="ekr.20131118152731.16853">def create_help_row(self, grid: Any, parent: LeoQtFrame, row: int) -&gt; int:
    # Help row.
    if False:
        w = self.createLabel(parent,
            'findHelp', 'For help: &lt;alt-x&gt;help-for-find-commands&lt;return&gt;')
        grid.addWidget(w, row, 0, 1, 3)
        row += 1
    return row
</t>
<t tx="ekr.20131118172620.16858">def finishCreateLogPane(self) -&gt; None:
    """It's useful to create this late, because c.config is now valid."""
    assert self.findTab
    self.createFindTab(self.findTab, self.findScrollArea)
    self.findScrollArea.setWidget(self.findTab)
</t>
<t tx="ekr.20131118172620.16891">def override_events(self) -&gt; None:
    # dw = self
    c = self.leo_c
    fc = c.findCommands
    ftm = fc.ftm
    # Define class EventWrapper.
    @others
    EventWrapper(c, w=ftm.find_findbox, next_w=ftm.find_replacebox, func=fc.find_next)
    EventWrapper(c, w=ftm.find_replacebox, next_w=ftm.find_next_button, func=fc.find_next)
    # Finally, checkBoxMarkChanges goes back to ftm.find_findBox.
    EventWrapper(c, w=ftm.check_box_mark_changes, next_w=ftm.find_findbox, func=None)
</t>
<t tx="ekr.20131118172620.16892">class EventWrapper:

    def __init__(self,
        c: Cmdr, w: LeoQtFrame, next_w: LeoQtFrame, func: Callable,
    ) -&gt; None:
        self.c = c
        self.d = self.create_d()  # Keys: stroke.s; values: command-names.
        self.w = w
        self.next_w = next_w
        self.eventFilter = qt_events.LeoQtEventFilter(c, w, 'EventWrapper')
        self.func = func
        self.oldEvent = w.event
        w.event = self.wrapper

    @others
</t>
<t tx="ekr.20131118172620.16893">def wrapper(self, event: Event) -&gt; Any:

    type_ = event.type()
    # Must intercept KeyPress for events that generate FocusOut!
    if type_ == Type.KeyPress:
        return self.keyPress(event)
    if type_ == Type.KeyRelease:
        return self.keyRelease(event)
    return self.oldEvent(event)
</t>
<t tx="ekr.20131118172620.16894">def keyPress(self, event: Event) -&gt; Any:

    s = event.text()
    out = s and s in '\t\r\n'
    if out:
        # Move focus to next widget.
        if s == '\t':
            if self.next_w:
                self.next_w.setFocus(FocusReason.TabFocusReason)
            else:
                # Do the normal processing.
                return self.oldEvent(event)
        elif self.func:
            self.func()
        return True
    binding, ch, lossage = self.eventFilter.toBinding(event)
    # #2094: Use code similar to the end of LeoQtEventFilter.eventFilter.
    #        The ctor converts &lt;Alt-X&gt; to &lt;Atl-x&gt; !!
    #        That is, we must use the stroke, not the binding.
    key_event = leoGui.LeoKeyEvent(
        c=self.c, char=ch, event=event, binding=binding, w=self.w)
    if key_event.stroke:
        cmd_name = self.d.get(key_event.stroke)
        if cmd_name:
            self.c.k.simulateCommand(cmd_name)
            return True
    # Do the normal processing.
    return self.oldEvent(event)
</t>
<t tx="ekr.20131118172620.16895">def keyRelease(self, event: Event) -&gt; None:
    return self.oldEvent(event)
</t>
<t tx="ekr.20131120054058.16281">def create_d(self) -&gt; dict[str, str]:
    """Create self.d dictionary."""
    c = self.c
    d = {}
    table = (
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # New in Leo 5.2: Support these in the Find Dialog.
        'find-all',
        'find-next',
        'find-prev',
        'hide-find-tab',
        'replace',
        'replace-all',
        'replace-then-find',
        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
        # #2041 &amp; # 2094 (Leo 6.4): Support Alt-x.
        'full-command',
        'keyboard-quit',  # Might as well :-)
    )
    for cmd_name in table:
        stroke = c.k.getStrokeForCommandName(cmd_name)
        if stroke:
            d[stroke.s] = cmd_name
    return d
</t>
<t tx="ekr.20131121084830.16362">@language python

# Toggle the settings.
g.app.debug_app = not g.app.debug_app
g.app.debug_widgets = not g.app.debug_widgets
# Report the new settings.
print('g.app.debug_app: %s' % g.app.debug_app)
print('g.app.debug_widgets: %s' % g.app.debug_widgets)
</t>
<t tx="ekr.20131219220412.16582">def _relinkAsCloneOf(self, p2: Position) -&gt; None:
    """A low-level method to replace p.v by a p2.v."""
    p = self
    v, v2 = p.v, p2.v
    parent_v = p._parentVnode()
    if not parent_v:  # pragma: no cover
        g.internalError('no parent_v', p)
        return
    if parent_v.children[p._childIndex] == v:
        parent_v.children[p._childIndex] = v2
        v2.parents.append(parent_v)
        # p.v no longer truly exists.
        # p.v = p2.v
    else:  # pragma: no cover
        g.internalError(
            'parent_v.children[childIndex] != v',
            p, parent_v.children, p._childIndex, v)
</t>
<t tx="ekr.20131222112420.16371">def contract(self) -&gt; None:
    """Contract p.v and clear p.v.expandedPositions list."""
    p, v = self, self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    v.contract()

def expand(self) -&gt; None:
    p = self
    v = self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    for p2 in v.expandedPositions:
        if p == p2:
            break
    else:
        v.expandedPositions.append(p.copy())
    v.expand()

def isExpanded(self) -&gt; bool:
    p = self
    if p.isCloned():
        c = p.v.context
        return c.shouldBeExpanded(p)
    return p.v.isExpanded()
</t>
<t tx="ekr.20131223064351.16351">def isNthChildOf(self, n: int, parent_v: VNode) -&gt; bool:
    """Return True if v is the n'th child of parent_v."""
    v = self
    if not parent_v:
        return False
    children = parent_v.children
    if not children:
        return False
    return 0 &lt;= n &lt; len(children) and children[n] == v
</t>
<t tx="ekr.20131230090121.16552">def deleteAllChildren(self) -&gt; None:
    """
    Delete all children of the receiver and set p.dirty().
    """
    p = self
    p.setDirty()  # Mark @file nodes dirty!
    while p.hasChildren():
        p.firstChild().doDelete()
</t>
<t tx="ekr.20140114145953.16691">def isLocalSetting(self, setting: str, kind: str) -&gt; bool:
    """Return True if the indicated setting comes from a local .leo file."""
    if not kind or kind in ('shortcut', 'shortcuts', 'openwithtable'):
        return False
    key = g.app.config.munge(setting)
    if key is None:
        return False
    if not self.settingsDict:
        return False
    gs = self.settingsDict.get(key)
    if not gs:
        return False
    assert isinstance(gs, g.GeneralSetting), repr(gs)
    path = gs.path.lower()
    for fn in ('myLeoSettings.leo', 'leoSettings.leo'):
        if path.endswith(fn.lower()):
            return False
    return True
</t>
<t tx="ekr.20140203082618.15486">def __get_script(self) -&gt; str:
    p = self
    return g.getScript(p.v.context, p,
        useSelectedText=False,  # Always return the entire expansion.
        forcePythonSentinels=True,
        useSentinels=False)

script = property(
    __get_script,  # __set_script,
    doc="position property returning the script formed by p and its descendants")
</t>
<t tx="ekr.20140218040104.16761">def __get_nosentinels(self) -&gt; str:
    p = self
    return ''.join([z for z in g.splitLines(p.b) if not g.isDirective(z)])

nosentinels = property(
    __get_nosentinels,  # __set_nosentinels
    doc="position property returning the body text without sentinels")
</t>
<t tx="ekr.20140531104908.18833">def parse_body(self, p: Position) -&gt; None:
    """
    Parse p.b as source code, creating a tree of descendant nodes.
    This is essentially an import of p.b.
    """
    c = self.c
    d = g.app.language_extension_dict
    u, undoType = c.undoer, 'parse-body'
    if not p:
        return
    if p.hasChildren():
        g.es_print('can not run parse-body: node has children:', p.h)
        return
    language = g.scanForAtLanguage(c, p)
    self.treeType = '@file'
    ext = '.' + d.get(language)
    parser = g.app.classDispatchDict.get(ext)
    # Fix bug 151: parse-body creates "None declarations"
    if p.isAnyAtFileNode():
        fn = p.anyAtFileNodeName()
        self.methodName, self.fileType = g.os_path_splitext(fn)
    else:
        fileType = d.get(language, 'py')
        self.methodName, self.fileType = p.h, fileType
    if not parser:
        g.es_print(f"parse-body: no parser for @language {language or 'None'}")
        return
    try:
        bunch = u.beforeParseBody(p)
        s = p.b
        p.b = ''
        parser(c, p, s)
        u.afterParseBody(p, undoType, bunch)
        p.expand()
        c.selectPosition(p)
        c.redraw()
    except Exception:
        g.es_exception()
        p.b = s
</t>
<t tx="ekr.20140717074441.17772">@g.commander_command('refresh-from-disk')
def refreshFromDisk(self: Self, event: Event = None) -&gt; None:
    """
    Refresh an @&lt;file&gt; node from disk.

    This command is not undoable.
    """
    c, p = self, self.p
    if not p.isAnyAtFileNode():
        g.warning(f"not an @&lt;file&gt; node: {p.h!r}")
        return
    full_path = c.fullPath(p)
    if os.path.isdir(full_path):
        g.warning(f"not a file: {full_path!r}")
        return
    at = c.atFileCommands
    c.nodeConflictList = []
    c.recreateGnxDict()
    if p.isAtAutoNode() or p.isAtAutoRstNode():
        p.v._deleteAllChildren()
        p = at.readOneAtAutoNode(p)  # Changes p!
    elif p.isAtFileNode():
        p.v._deleteAllChildren()
        at.read(p)
    elif p.isAtCleanNode():
        # Don't delete children!
        at.readOneAtCleanNode(p)
    elif p.isAtShadowFileNode():
        p.v._deleteAllChildren()
        at.read(p)
    elif p.isAtEditNode():
        at.readOneAtEditNode(p)  # Always deletes children.
    elif p.isAtAsisFileNode():
        at.readOneAtAsisNode(p)  # Always deletes children.
    else:
        g.es_print(f"Unknown @&lt;file&gt; node: {p.h!r}")
        return
    c.selectPosition(p)
    # Create the 'Recovered Nodes' tree.
    c.fileCommands.handleNodeConflicts()
    c.redraw()
    c.undoer.clearAndWarn('refresh-from-disk')
</t>
<t tx="ekr.20140723122936.17925"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins now contain the importer code for all kinds of @auto nodes.
# Each plugin must define a top-level importer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20140723122936.17928">class C_Importer(Importer):

    language = 'c'
    string_list = ['"']  # Not single quotes.

    block_patterns = (
        ('class', re.compile(r'.*?\bclass\s+(\w+)\s*\{')),
        ('func', re.compile(r'.*?\b(\w+)\s*\(.*?\)\s*(const)?\s*{')),
        ('namespace', re.compile(r'.*?\bnamespace\s*(\w+)?\s*\{')),
        ('struct', re.compile(r'.*?\bstruct\s*(\w+)?\s*(:.*?)?\{')),
    )

    @others
</t>
<t tx="ekr.20140723140445.18076">def parse_importer_dict(self, sfn: str, m: Any) -&gt; None:
    """
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    """
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_func = importer_d.get('func', None)
        # scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_func
                g.app.atAutoDict[s] = scanner_func
                g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_func  #importer_d.get('func')#scanner_class
    elif sfn not in (
        # This is a base class, not a real plugin.
        'base_importer.py',
    ):
        g.warning(f"leo/plugins/importers/{sfn} has no importer_dict")
</t>
<t tx="ekr.20140724064952.18037">def createImporterData(self) -&gt; None:
    """Create the data structures describing importer plugins."""
    # Allow plugins to be defined in ~/.leo/plugins.
    for pattern in (
        # ~/.leo/plugins.
        g.finalize_join(g.app.homeDir, '.leo', 'plugins'),
        # leo/plugins/importers.
        g.finalize_join(g.app.loadDir, '..', 'plugins', 'importers', '*.py'),
    ):
        filenames = g.glob_glob(pattern)
        for filename in filenames:
            sfn = g.shortFileName(filename)
            if sfn != '__init__.py':
                try:
                    module_name = sfn[:-3]
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module(f"leo.plugins.importers.{module_name}")
                    self.parse_importer_dict(sfn, m)
                    # print('createImporterData', m.__name__)
                except Exception:
                    g.warning(f"can not import leo.plugins.importers.{module_name}")
                    g.printObj(filenames)
</t>
<t tx="ekr.20140726091031.18071"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins contain the write code for all kinds of special @auto nodes.
# Each plugin must define a top-level writer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20140728040812.17990">def createWritersData(self) -&gt; None:
    """Create the data structures describing writer plugins."""
    # Do *not* remove this trace.
    trace = False and 'createWritersData' not in g.app.debug_dict
    if trace:
        # Suppress multiple traces.
        g.app.debug_dict['createWritersData'] = True
    g.app.writersDispatchDict = {}
    g.app.atAutoWritersDict = {}

    # Allow plugins to be defined in ~/.leo/plugins.
    for pattern in (
        g.finalize_join(g.app.homeDir, '.leo', 'plugins'),  # ~/.leo/plugins.
        g.finalize_join(g.app.loadDir, '..', 'plugins', 'writers', '*.py'),  # leo/plugins/writers
    ):
        for filename in g.glob_glob(pattern):
            sfn = g.shortFileName(filename)
            if sfn.endswith('.py') and sfn != '__init__.py':
                try:
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module(f"leo.plugins.writers.{sfn[:-3]}")
                    self.parse_writer_dict(sfn, m)
                except Exception:
                    g.es_exception()
                    g.warning(f"can not import leo.plugins.writers.{sfn}")
    if trace:
        g.trace('LM.writersDispatchDict')
        g.printDict(g.app.writersDispatchDict)
        g.trace('LM.atAutoWritersDict')
        g.printDict(g.app.atAutoWritersDict)
</t>
<t tx="ekr.20140728040812.17991">def parse_writer_dict(self, sfn: str, m: Any) -&gt; None:
    """
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    """
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace(
                        f"{sfn}: duplicate {s} class {aClass.__name__} "
                        f"in {m.__file__}:")
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace(f"{sfn}: duplicate {ext} class", aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning(f"leo/plugins/writers/{sfn} has no writer_dict")
</t>
<t tx="ekr.20140729162415.18086">def init_at_auto_names(self) -&gt; None:
    """Init the app.atAutoNames set."""
    self.atAutoNames = set([
        "@auto-rst", "@auto",
    ])
</t>
<t tx="ekr.20140729162415.18091">def init_at_file_names(self) -&gt; None:
    """Init the app.atFileNames set."""
    self.atFileNames = set([
        "@asis",
        "@edit",
        "@file-asis", "@file-thin", "@file-nosent", "@file",
        "@clean", "@nosent",
        "@shadow",
        "@thin",
    ])
</t>
<t tx="ekr.20140829053801.18460">def set_status_line(self, p: Position) -&gt; None:
    """Update the status line."""
    c = self.c
    c.frame.body.assignPositionToEditor(p)
    c.frame.updateStatusLine()
    c.frame.clearStatusLine()
    if p and p.v:
        kind = c.config.getString('unl-status-kind') or ''
        method = p.get_legacy_UNL if kind.lower() == 'legacy' else p.get_UNL
        c.frame.putStatusLine(method())
</t>
<t tx="ekr.20140831085423.18630">This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:

si:     a g.ShortcutInfo object.
ks:     a g.KeyStroke object
stroke: a KeyStroke object.

btw:    leoFrame.BaseTextWrapper
stw:    leoFrame.StringTextWrapper

bqtw:   qt_text.BaseQTextWrapper
lqtb:   qt_text.LeoQTextBrowser
qhlw:   qt_text.QHeadlineWrapper
qmbw:   qt_text.QMinibufferWrapper
qlew:   qt_text.QLineEditWrapper
qsciw:  qt_text.QScintiallaWrapper
qtew:   qt_text.QTextEditWrapper</t>
<t tx="ekr.20140831085423.18631">The following 'official' ivars will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.widget     The gui widget for the body pane.
c.frame.body.wrapper    The high level interface for the body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.log.widget      The gui widget for the log pane.
c.frame.log.wrapper     The high-level inteface for the log pane.
c.frame.tree            The tree pane.

The following were official ivars that no longer exist:

c.frame.body.bodyCtrl   Use c.frame.body.wrapper instead.
c.frame.log.logCtrl     Use c.frame.log.wrapper instead.
</t>
<t tx="ekr.20140831085423.18639">Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly.  Instead...

2. A **wrapper class** defines a standard api that hides the details
   of the underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All wrapper classes define an official ``widget`` ivar, so core or plugin code can gain access to the real Qt widget using wrapper.widget. Searching for wrapper.widget will find all gui-dependent snippets of code in Leo's core.
</t>
<t tx="ekr.20140902032918.18591">@language rest
@wrap

Leo uses a model/view/controller architecture.

- Controller: The Commands class and its helpers in leoCommands.py and leoEditCommands.py.

- Model: The VNode and Position classes in leoNodes.py.

- View: The gui-independent base classes are in the node "Gui Base Classes". The Qt-Specific subclasses are in the node "Qt gui".

**Important**: The general organization of these classes have changed hardly at all in Leo's 20+ year history.  The reason is that what each class does is fairly obvious.  How the gets the job done may have changed drastically, but *that's an internal implementation detail of the class itself*.  This is the crucial design principle that allows Leo's code to remain stable.  *Classes do not know or meddle in the internal details of other classes*.  As a result, nobody, including EKR, needs to remember internal details.

</t>
<t tx="ekr.20140902155015.18674"></t>
<t tx="ekr.20140904043623.18552">class IconBarAPI:
    """The required API for c.frame.iconBar."""

    def __init__(self, c: Cmdr, parentFrame: Widget) -&gt; None:
        pass

    def add(self, *args: str, **keys: str) -&gt; None:
        pass

    def addRow(self, height: str = None) -&gt; None:
        pass

    def addRowIfNeeded(self) -&gt; None:
        pass

    def addWidget(self, w: Wrapper) -&gt; None:
        pass

    def clear(self) -&gt; None:
        pass

    def createChaptersIcon(self) -&gt; None:
        pass

    def deleteButton(self, w: Wrapper) -&gt; None:
        pass

    def getNewFrame(self) -&gt; None:
        pass

    def setCommandForButton(self,
        button: Any, command: str, command_p: Position, controller: Cmdr, gnx: str, script: str,
    ) -&gt; None:
        pass
</t>
<t tx="ekr.20140906065955.18794">def addRow( self , tab ):

    self.rows = self.rows + 1
    tab.configure( rows = self.rows )
    rc =  '%s,0' % (self.rows -1 )
    for z in range( self.columns ):
        self.arr.set( '%s,%s' %( self.rows - 1, z ), "" )
    tab.activate( rc )
    tab.focus_set()



</t>
<t tx="ekr.20140906065955.18802">def createBBox( parent, csvv, tab ):

    bbox = Pmw.ButtonBox( parent )
    bconfig = ( ( "Add Row", lambda tab = tab : csvv.addRow( tab ) ),
                ( "Delete Row", lambda tab = tab: csvv.deleteRow( tab ) ),
                ( "Add Column", lambda tab = tab: csvv.addColumn( tab ) ),
                ( "Delete Column", lambda tab = tab: csvv.deleteColumn( tab ) ) )
    for z in bconfig:
        bbox.add( z[ 0 ], command = z[ 1 ], background = 'white', foreground = 'blue' )
    bbox.pack()


</t>
<t tx="ekr.20140915062551.19519">def set_icon_bar_orientation(self, c: Cmdr) -&gt; None:
    """Set the orientation of the icon bar based on settings."""
    d = {
        'bottom': ToolBarArea.BottomToolBarArea,
        'left': ToolBarArea.LeftToolBarArea,
        'right': ToolBarArea.RightToolBarArea,
        'top': ToolBarArea.TopToolBarArea,
    }
    where = self.toolbar_orientation
    if not where:
        where = 'top'
    where = d.get(where.lower())
    if where:
        self.addToolBar(where, self.iconBar)
</t>
<t tx="ekr.20140916101314.19538">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20141024211256.22">def checkGnxs(self) -&gt; int:
    """
    Check the consistency of all gnx's.
    Reallocate gnx's for duplicates or empty gnx's.
    Return the number of errors found.
    """
    c = self
    # Keys are gnx's; values are sets of vnodes with that gnx.
    d: dict[str, set[VNode]] = {}
    ni = g.app.nodeIndices
    t1 = time.time()

    def new_gnx(v: VNode) -&gt; None:
        """Set v.fileIndex."""
        v.fileIndex = ni.getNewIndex(v)

    count, gnx_errors = 0, 0
    for p in c.all_positions(copy=False):
        count += 1
        v = p.v
        gnx = v.fileIndex
        if gnx:  # gnx must be a string.
            aSet: set[VNode] = d.get(gnx, set())
            aSet.add(v)
            d[gnx] = aSet
        else:
            gnx_errors += 1
            new_gnx(v)
            g.es_print(f"empty v.fileIndex: {v} new: {p.v.gnx!r}", color='red')
    for gnx in sorted(d.keys()):
        aList = list(d.get(gnx))
        if len(aList) != 1:
            print('\nc.checkGnxs...')
            g.es_print(f"multiple vnodes with gnx: {gnx!r}", color='red')
            for v in aList:
                gnx_errors += 1
                g.es_print(f"id(v): {id(v)} gnx: {v.fileIndex} {v.h}", color='red')
                new_gnx(v)
    ok = not gnx_errors
    t2 = time.time()
    if not ok:
        g.es_print(
            f"check-outline ERROR! {c.shortFileName()} "
            f"{count} nodes, {gnx_errors} gnx errors, ",
            color='red'
        )
    elif c.verbose_check_outline and not g.unitTesting:
        print(
            f"check-outline OK: {t2 - t1:4.2f} sec. "
            f"{c.shortFileName()} {count} nodes")
    return gnx_errors
</t>
<t tx="ekr.20141031053508.14">def goto_command(self, controller: Any, gnx: str) -&gt; None:
    """
    Select the node corresponding to the given gnx.
    controller is a ScriptingController instance.
    """
    # Fix bug 74: command_p may be in another outline.
    c = self.c
    c2, p = controller.open_gnx(c, gnx)
    if p:
        assert c2.positionExists(p)
        if c == c2:
            c2.selectPosition(p)
        else:
            g.app.selectLeoWindow(c2)
            # Fix #367: Process events before selecting.
            g.app.gui.qtApp.processEvents()
            c2.selectPosition(p)
    else:
        g.trace('not found', gnx)
</t>
<t tx="ekr.20141031053508.15">def add_rclick_menu(
    self,
    action_container: Any,
    rclicks: list[Any],
    controller: Cmdr,
    top_level: bool=True,
    button: str=None,
    script: str=None,
) -&gt; None:
    c = controller.c
    top_offset = -2  # insert before the remove button and goto script items
    if top_level:
        button = action_container
    for rc in rclicks:
        # pylint: disable=cell-var-from-loop
        headline = rc.position.h[8:].strip()
        act = QAction(headline, action_container)
        if '---' in headline and headline.strip().strip('-') == '':
            act.setSeparator(True)
        elif rc.position.b.strip():

            def cb(checked: str, p: Position=rc.position, button: str=button) -&gt; None:
                controller.executeScriptFromButton(
                    b=button,
                    buttonText=p.h[8:].strip(),
                    p=p,
                    script=script,
                )
                if c.exists:
                    c.outerUpdate()

            act.triggered.connect(cb)
        else:  # recurse submenu
            sub_menu = QtWidgets.QMenu(action_container)
            act.setMenu(sub_menu)
            self.add_rclick_menu(sub_menu, rc.children, controller,
                top_level=False, button=button)
        if top_level:
            # insert act before Remove Button
            action_container.insertAction(
                action_container.actions()[top_offset], act)
        else:
            action_container.addAction(act)
    if top_level and rclicks:
        act = QAction('---', action_container)
        act.setSeparator(True)
        action_container.insertAction(
            action_container.actions()[top_offset], act)
        action_container.setText(
            action_container.text() +
            (c.config.getString('mod-scripting-subtext') or '')
        )
</t>
<t tx="ekr.20150225133846.7">def doDiff(self) -&gt; None:
    """Support --diff option after loading Leo."""
    if len(self.old_argv[2:]) == 2:
        pass  # c.editFileCommands.compareAnyTwoFiles gives a message.
    else:
        # This is an unusual situation.
        g.es('--diff mode. sys.argv[2:]...', color='red')
        for z in self.old_argv[2:]:
            g.es(g.shortFileName(z) if z else repr(z), color='blue')
    commanders = g.app.commanders()
    if len(commanders) == 2:
        c = commanders[0]
        c.editFileCommands.compareAnyTwoFiles(event=None)
</t>
<t tx="ekr.20150304130753.4">@language xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;h1&gt;Body Pane&lt;/h1&gt;
      &lt;pre class="body-text"&gt;body&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;h1&gt;&lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
    &lt;xsl:if test ='./v' &gt;
      &lt;xsl:apply-templates select = 'v'/&gt;
    &lt;/xsl:if&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150316175921.5">def safe_all_positions(self, copy: bool = True) -&gt; Generator:  # pragma: no cover
    """
    A generator returning all positions of the outline. This generator does
    *not* assume that vnodes are never their own ancestors.
    """
    c = self
    p = c.rootPosition()  # Make one copy.
    while p:
        yield p.copy() if copy else p
        p.safeMoveToThreadNext()
</t>
<t tx="ekr.20150316175921.6">def safeMoveToThreadNext(self) -&gt; Position:  # pragma: no cover
    """
    Move a position to threadNext position.
    Issue an error if any vnode is an ancestor of itself.
    """
    p = self
    if p.v:
        child_v = p.v.children and p.v.children[0]
        if child_v:
            for parent in p.self_and_parents(copy=False):
                if child_v == parent.v:
                    g.app.structure_errors += 1
                    g.error(f"vnode: {child_v} is its own parent")
                    # Allocating a new vnode would be difficult.
                    # Just remove child_v from parent.v.children.
                    parent.v.children = [
                        v2 for v2 in parent.v.children if not v2 == child_v]
                    if parent.v in child_v.parents:
                        child_v.parents.remove(parent.v)
                    # Try not to hang.
                    p.moveToParent()
                    break
                elif child_v.fileIndex == parent.v.fileIndex:
                    g.app.structure_errors += 1
                    g.error(
                        f"duplicate gnx: {child_v.fileIndex!r} "
                        f"v: {child_v} parent: {parent.v}")
                    child_v.fileIndex = g.app.nodeIndices.getNewIndex(v=child_v)
                    assert child_v.gnx != parent.v.gnx
                    # Should be ok to continue.
                    p.moveToFirstChild()
                    break
            else:
                p.moveToFirstChild()
        elif p.hasNext():
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.hasNext():
                    p.moveToNext()
                    break  # found
                p.moveToParent()
            # not found.
    return p
</t>
<t tx="ekr.20150316175921.7"></t>
<t tx="ekr.20150318131947.7">def checkLinks(self) -&gt; int:
    """
    Check the consistency of all links in the outline.
    """
    # This is too slow a test to be run outside of unit tests.
    c = self
    count, errors = 0, 0
    for p in c.all_positions():
        count += 1
        if not c.checkThreadLinks(p):
            errors += 1
            break
        if not c.checkSiblings(p):
            errors += 1
            break
        if not c.checkParentAndChildren(p):
            errors += 1
            break
    return errors
</t>
<t tx="ekr.20150413091056.1">"""Warn if leoProjects.txt or leoToDo.txt contain any clones."""

clones,nodes,seen = 0,0,set()
table = (
  '@file ../doc/leoProjects.txt',
  '@file ../doc/leoToDo.txt',
)

def check_clone(c,p0,root):
    """Warn if p appears in any @&lt;file&gt; node outside of root's tree."""
    global nodes,seen
    v = p0.v
    for p in c.all_positions():
        nodes += 1
        if p.v == v:
            # Check *all* ancestors, not just the nearest one.
            for parent in p.self_and_parents():
                nodes += 1
                if parent.isAnyAtFileNode() and parent.v != root.v:
                    if parent.v not in seen:
                        seen.add(parent.v)
                        g.es_print('%s and %s contain clone: %s' % (
                            root.h,parent.h,p0.h))

for h in table:
    root = g.findNodeAnywhere(c,h)
    if root:
        for p in root.self_and_subtree():
            nodes += 1
            if p.isCloned():
                clones += 1
                check_clone(c,p,root)
    else:
        g.es_print('not found',h,color='red')
print('done: %s nodes, %s clones' % (nodes,clones))

@tabwidth -4
@language python
</t>
<t tx="ekr.20150425145248.1">test-one
execute-script
goto-prev-history-node
goto-next-history-node
beautify-files
expand-all-subheads
pylint
backup
show-commands
show-bindings</t>
<t tx="ekr.20150502050609.1">"""
Back up this .leo file.

os.environ['LEO_BACKUP'] must be the path to an existing (writable) directory.
"""
c.backup_helper(sub_dir='leoPy')
</t>
<t tx="ekr.20150507170849.1">g.cls()

print('===== Start =====')

class CreateDecorators:
    """
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    """
    def __init__(self,c,make_changes):
        self.c = c
        self.fixups = self.create_fixups()
        self.n = 0
        self.n_fail = 0
        self.make_changes=make_changes
        self.suppress = [
            'c.frame.body and c.frame.body.addEditor',
            'cls','cloneFindParents','cycleTabFocus',
            'k and k.keyboardQuit',
            'menuShortcutPlaceHolder','removeBlankLines',
            'saveBuffersKillLeo',
        ]
    @others

CreateDecorators(c,make_changes=False).run()
</t>
<t tx="ekr.20150507174711.1">def find_next_clone(self,p):
    v = p.v
    p = p.copy()
    p.moveToThreadNext()
    wrapped = False
    while 1:
        # g.trace(p.v,p.h)
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()
    return p
</t>
<t tx="ekr.20150507175246.1">def munge_lines(self,root,publicCommands):
    """Return munged lines of """
    s = publicCommands.b
    i,j = s.find('{'),s.find('}')
    s = s[i+1:j]
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150508062944.1">def run(self):
    """Top-level code."""
    self.n = 0
    found = g.findNodeAnywhere(c,'Found: getPublicCommands')
    assert found
    for child in found.children():
        publicCommands = self.find_next_clone(child)
        root = self.find_class(publicCommands)
        if root:
            lines = self.munge_lines(root,publicCommands)
            d = self.create_d(lines,publicCommands)
            self.create_decorators(d,root)
    print('\n%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150508063412.1">def create_decorators(self,d,root):
    """Create decorators for all items in d in root's tree."""
    # print('***** %s' % root.h)
    if root.h in self.fixups:
        roots = []
        aList = self.fixups.get(root.h)
        for root2_h in aList:
            root2 = g.findNodeAnywhere(self.c,root2_h)
            if root2:
                # g.trace(root.h,'=====&gt;',root2.h)
                roots.append(root2)
            else:
                g.trace('===== not found',root2_h)
    else:
        roots = [root]
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print('===== not found: %30s %s' % (root.h,f_name))
            self.n_fail += 1
</t>
<t tx="ekr.20150508063538.1">def create_d(self,lines,publicCommands):
    """Create a dict. keys are method names; values are command names."""
    trace = False
    if trace:
        g.trace('\n', publicCommands.h)
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [alist[0],' '.join(alist[1:])]
        c_name,f_name = alist[0].strip(),alist[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150508063926.1">def find_class(self,p):
    """Return the position of the class enclosing p."""
    for p2 in p.parents():
        if p2.h.lower().find('class') &gt; -1 and p2.b.find('class') &gt; -1:
            return p2
    else:
        g.trace('*** no class for p.h')
        return None
</t>
<t tx="ekr.20150508071622.1">def create_decorator(self,c_name,f_name,root):
    """
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    """
    # g.trace('%45s %s' % (c_name,f_name))
    trace = False
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        # if changed and self.make_changes:
            # new_body = ''.join(result)
            # # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150508074623.1">def create_fixups(self):
    """
    Return a fixup dict.
    Keys are headlines for classes.
    Values are new headlines of nodes containing the actual class.
    """
    return {
        'ChapterCommandsClass': ['class ChapterController'],
        'EditCommandsClass': [
            'EditCommandsClass',
            'class Commands',
            'class LeoQtFrame',
            'class LeoBody',
        ],
        'class SearchCommandsClass': ['class LeoFind (LeoFind.py)'],
        'KeyHandlerCommandsClass (add docstrings)': [
            'class KeyHandlerClass',
            'class AutoCompleterClass',
        ]
    }
</t>
<t tx="ekr.20150509183433.1">g.cls()

# Changed files:
# leoApp.py
# leoAtFile.py
# leoCommands.py
# leoFileCommands.py
# leoFrame.py
# leoUndo.py
# qt_frame.py

make_changes = True  # True, actually make the change

class CreateDecorators:
    """
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    """
    def __init__(self):
        self.n = 0
        self.n_fail = 0
        self.s = self.define_s()
    @others

CreateDecorators().run()
</t>
<t tx="ekr.20150509183433.2">def create_d(self,lines):
    """Create a dict. keys are method names; values are command names."""
    trace = False
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [alist[0],' '.join(alist[1:])]
        c_name,f_name = alist[0].strip(),alist[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        if trace:
            g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150509183433.3">def create_decorator(self,c_name,f_name,root):
    """
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    """
    trace = True
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
            result.append(s)
        if changed and make_changes:
            new_body = ''.join(result)
            print('%40s %s' % (p.h[:40],decorator.rstrip()))
    return found
</t>
<t tx="ekr.20150509183433.4">def create_decorators(self,d):
    """Create decorators for all items in d in root's tree."""
    table = (
        'class Commands', # c.
        'class LeoQtFrame', # f.
        'class LeoFrame', # f.
        'class LeoApp', # g.app.
        '@file leoAtFile.py', # c.atFileCommands
        '@file leoFileCommands.py', # c.fileCommands
        'class Undoer', # c.undoer
    )
    roots = []
    for h in table:
        root = g.findNodeAnywhere(c,h)
        assert root,h
        roots.append(root)
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print(f"===== not found: {f_name!r}")
            self.n_fail += 1
</t>
<t tx="ekr.20150509183433.8">def munge_lines(self,s):
    """Return munged lines of s. """
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150509183433.9">def run(self):
    """Top-level code."""
    lines = self.munge_lines(self.s)
    d = self.create_d(lines)
    self.create_decorators(d)
    print('%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150509193307.1"></t>
<t tx="ekr.20150514035207.1"></t>
<t tx="ekr.20150514043850.11">def expandAbbrev(self, event: Event, stroke: Stroke) -&gt; bool:
    """
    Not a command.  Expand abbreviations in event.widget.

    Words start with '@'.
    """
    # Trace for *either* 'abbrev' or 'keys'
    trace = any(z in g.app.debug for z in ('abbrev', 'keys'))
    # Verbose only for *both* 'abbrev' and 'verbose'.
    verbose = all(z in g.app.debug for z in ('abbrev', 'verbose'))
    c, p = self.c, self.c.p
    w = self.editWidget(event, forceFocus=False)
    w_name = g.app.gui.widget_name(w)
    if not w:
        if trace and verbose:
            g.trace('no w')
        return False
    ch = self.get_ch(event, stroke, w)
    if not ch:
        if trace and verbose:
            g.trace('no ch')
        return False
    s, i, j, prefixes = self.get_prefixes(w)
    for prefix in prefixes:
        i, tag, word, val = self.match_prefix(ch, i, j, prefix, s)
        if word:
            # Fix another part of #438.
            if w_name.startswith('head'):
                if val == '__NEXT_PLACEHOLDER':
                    i = w.getInsertPoint()
                    if i &gt; 0:
                        w.delete(i - 1)
                        p.h = w.getAllText()
                # Do not call c.endEditing here.
            break
    else:
        if trace and verbose:
            g.trace(f"No prefix in {s!r}")
        return False
    c.abbrev_subst_env['_abr'] = word
    if trace:
        g.trace(f"Found {word!r} = {val!r}")
    if tag == 'tree':
        self.root = p.copy()
        self.last_hit = p.copy()
        self.expand_tree(w, i, j, val, word)
        c.undoer.clearAndWarn('tree-abbreviation')
    else:
        # Never expand a search for text matches.
        place_holder = '__NEXT_PLACEHOLDER' in val
        if place_holder:
            expand_search = bool(self.last_hit)
        else:
            self.last_hit = None
            expand_search = False
        self.expand_text(w, i, j, val, word, expand_search)
        # Restore the selection range.
        if self.save_ins:
            ins = self.save_ins
            # pylint: disable=unpacking-non-sequence
            sel1, sel2 = self.save_sel
            if sel1 == sel2:
                # New in Leo 5.5
                self.post_pass()
            else:
                # some abbreviations *set* the selection range
                # so only restore non-empty ranges
                w.setSelectionRange(sel1, sel2, insert=ins)
    return True
</t>
<t tx="ekr.20150514043850.12">def expand_text(self,
    w: Wrapper,
    i: int,
    j: int,
    val: str,
    word: str,
    expand_search: bool = False,
) -&gt; None:
    """Make a text expansion at location i,j of widget w."""
    c = self.c
    if word == c.config.getString("abbreviations-next-placeholder"):
        val = ''
        do_placeholder = True
    else:
        val, do_placeholder = self.make_script_substitutions(i, j, val)
    self.replace_selection(w, i, j, val)
    # Search to the end.  We may have been called via a tree abbrev.
    p = c.p.copy()
    if expand_search:
        while p:
            if self.find_place_holder(p, do_placeholder):
                return
            p.moveToThreadNext()
    else:
        self.find_place_holder(p, do_placeholder)

</t>
<t tx="ekr.20150514043850.13">def expand_tree(self, w: Wrapper, i: int, j: int, tree_s: str, word: str) -&gt; None:
    """
    Paste tree_s as children of c.p.
    This happens *before* any substitutions are made.
    """
    c = self.c
    if not c.canPasteOutline(tree_s):
        g.trace(f"bad copied outline: {tree_s}")
        return
    old_p = c.p.copy()
    self.replace_selection(w, i, j, None)
    self.paste_tree(old_p, tree_s)
    # Make all script substitutions first.
    # Original code.  Probably unwise to change it.
    do_placeholder = False
    for p in old_p.self_and_subtree():
        # Search for the next place-holder.
        val, do_placeholder = self.make_script_substitutions(0, 0, p.b)
        if not do_placeholder:
            p.b = val
    # Now search for all place-holders.
    for p in old_p.subtree():
        if self.find_place_holder(p, do_placeholder):
            break
</t>
<t tx="ekr.20150514043850.14">def find_place_holder(self, p: Position, do_placeholder: bool) -&gt; bool:
    """
    Search for the next place-holder.
    If found, select the place-holder (without the delims).
    """
    c = self.c
    # Do #438: Search for placeholder in headline.
    s = p.h
    if do_placeholder or c.abbrev_place_start and c.abbrev_place_start in s:
        new_s, i, j = self.next_place(s, offset=0)
        if i is not None:
            p.h = new_s
            c.redraw(p)
            c.editHeadline()
            w = c.edit_widget(p)
            w.setSelectionRange(i, j, insert=j)
            return True
    s = p.b
    if do_placeholder or c.abbrev_place_start and c.abbrev_place_start in s:
        new_s, i, j = self.next_place(s, offset=0)
        if i is None:
            return False
        w = c.frame.body.wrapper
        switch = p != c.p
        if switch:
            c.selectPosition(p)
        else:
            scroll = w.getYScrollPosition()
        w.setAllText(new_s)
        p.v.b = new_s
        if switch:
            c.redraw()
        w.setSelectionRange(i, j, insert=j)
        if switch:
            w.seeInsertPoint()
        else:
            # Keep the scroll point if possible.
            w.setYScrollPosition(scroll)
            w.seeInsertPoint()
        c.bodyWantsFocusNow()
        return True
    # #453: do nothing here.
        # c.frame.body.forceFullRecolor()
        # c.bodyWantsFocusNow()
    return False
</t>
<t tx="ekr.20150514043850.15">def make_script_substitutions(self, i: int, j: int, val: str) -&gt; tuple[str, bool]:
    """Make scripting substitutions in node p."""
    c = self.c
    w = c.frame.body.wrapper
    if not c.abbrev_subst_start:
        return val, False
    # Nothing to undo.
    if c.abbrev_subst_start not in val:
        return val, False

    # Perform all scripting substitutions.
    self.save_ins = None
    self.save_sel = None
    while c.abbrev_subst_start in val:
        prefix, rest = val.split(c.abbrev_subst_start, 1)
        content = rest.split(c.abbrev_subst_end, 1)
        if len(content) != 2:
            break
        content, rest = content  # type:ignore
        try:
            self.expanding = True
            c.abbrev_subst_env['x'] = ''
            exec(content, c.abbrev_subst_env, c.abbrev_subst_env)  # type:ignore
        except Exception:
            g.es_print('exception evaluating', content)
            g.es_exception()
        finally:
            self.expanding = False
        x = c.abbrev_subst_env.get('x')
        if x is None:
            x = ''
        val = f"{prefix}{x}{rest}"
        # Save the selection range.
        self.save_ins = w.getInsertPoint()
        self.save_sel = w.getSelectionRange()
    if val == "__NEXT_PLACEHOLDER":
        # user explicitly called for next placeholder in an abbreviation inserted previously
        val = ''
        do_placeholder = True
    else:
        do_placeholder = False
        c.p.v.b = w.getAllText()
    return val, do_placeholder
</t>
<t tx="ekr.20150514043850.16">def next_place(self, s: str, offset: int = 0) -&gt; tuple[str, int, int]:
    """
    Given string s containing a placeholder like &lt;| block |&gt;,
    return (s2,start,end) where s2 is s without the &lt;| and |&gt;,
    and start, end are the positions of the beginning and end of block.
    """
    c = self.c
    if c.abbrev_place_start is None or c.abbrev_place_end is None:
        return s, None, None  # #1345.
    new_pos = s.find(c.abbrev_place_start, offset)
    new_end = s.find(c.abbrev_place_end, offset)
    if (new_pos &lt; 0 or new_end &lt; 0) and offset:
        new_pos = s.find(c.abbrev_place_start)
        new_end = s.find(c.abbrev_place_end)
        if not (new_pos &lt; 0 or new_end &lt; 0):
            g.es("Found earlier placeholder")
    if new_pos &lt; 0 or new_end &lt; 0:
        return s, None, None
    start = new_pos
    place_holder_delim = s[new_pos : new_end + len(c.abbrev_place_end)]
    place_holder = place_holder_delim[
        len(c.abbrev_place_start) : -len(c.abbrev_place_end)]
    s2 = s[:start] + place_holder + s[start + len(place_holder_delim) :]
    end = start + len(place_holder)
    return s2, start, end
</t>
<t tx="ekr.20150514043850.17">def paste_tree(self, old_p: Position, s: str) -&gt; None:
    """Paste the tree corresponding to s (xml) into the tree."""
    c = self.c
    c.fileCommands.leo_file_encoding = 'utf-8'
    p = c.pasteOutline(s=s, undoFlag=False)
    if p:
        # Promote the name node, then delete it.
        p.moveToLastChildOf(old_p)
        c.selectPosition(p)
        c.promote(undoFlag=False)
        p.doDelete()
        c.redraw(old_p)  # 2017/02/27: required.
    else:
        g.trace('paste failed')
</t>
<t tx="ekr.20150514043850.18">def replace_selection(self, w: Wrapper, i: int, j: int, s: str) -&gt; None:
    """Replace w[i:j] by s."""
    p, u = self.c.p, self.c.undoer
    w_name = g.app.gui.widget_name(w)
    bunch = u.beforeChangeBody(p)
    if i == j:
        abbrev = ''
    else:
        abbrev = w.get(i, j)
        w.delete(i, j)
    if s is not None:
        w.insert(i, s)
    if w_name.startswith('head'):
        pass  # Don't set p.h here!
    else:
        # Fix part of #438. Don't leave the headline.
        p.v.b = w.getAllText()
        u.afterChangeBody(p, 'Abbreviation', bunch)
    # Adjust self.save_sel &amp; self.save_ins
    if s is not None and self.save_sel is not None:
        # pylint: disable=unpacking-non-sequence
        i, j = self.save_sel
        ins = self.save_ins
        delta = len(s) - len(abbrev)
        self.save_sel = i + delta, j + delta
        self.save_ins = ins + delta
</t>
<t tx="ekr.20150618072619.1">if 0:

    def create_find_status(self, grid: Any, parent: LeoQtFrame, row: int) -&gt; None:
        """Create the status line."""
        dw = self
        status_label = dw.createLabel(parent, 'status-label', 'Status')
        status_line = dw.createLineEdit(parent, 'find-status', disabled=True)
        grid.addWidget(status_label, row, 0)
        grid.addWidget(status_line, row, 1, 1, 2)
        # Official ivars.
        dw.find_status_label = status_label
        dw.find_status_edit = status_line
</t>
<t tx="ekr.20150630152607.1">@g.commander_command('clone-to-at-spot')
def cloneToAtSpot(self: Cmdr, event: Event = None) -&gt; None:
    """
    Create a clone of the selected node and move it to the last @spot node
    of the outline. Create the @spot node if necessary.
    """
    c, p, u = self, self.p, self.undoer
    if not p:
        return
    # 2015/12/27: fix bug 220: do not allow clone-to-at-spot on @spot node.
    if p.h.startswith('@spot'):
        g.es("can not clone @spot node", color='red')
        return
    last_spot = None
    for p2 in c.all_positions():
        if g.match_word(p2.h, 0, '@spot'):
            last_spot = p2.copy()
    if not last_spot:
        last = c.lastTopLevel()
        last_spot = last.insertAfter()
        last_spot.h = '@spot'
    undoData = c.undoer.beforeCloneNode(p)
    c.endEditing()  # Capture any changes to the headline.
    clone = p.copy()
    clone._linkAsNthChild(last_spot, n=last_spot.numberOfChildren())
    clone.setDirty()
    c.setChanged()
    if c.checkOutline() == 0:
        u.afterCloneNode(clone, 'Clone Node', undoData)
        c.contractAllHeadlines()
        c.redraw(clone)
    else:
        clone.doDelete()
        c.setCurrentPosition(p)
</t>
<t tx="ekr.20150703061709.1">@language python

"""myLeoSettings.py: save the outline and run the pylint command"""

# print('@button run-pylint: %s' % c.shortFileName())
if c.isChanged():
    c.save()
c.k.simulateCommand('pylint')
</t>
<t tx="ekr.20160122104332.1">@language python
</t>
<t tx="ekr.20160123142722.1"># An example configuration file for make_stub_files.py.
# By default, this is ~/stubs/make_stub_files.cfg.
# Can be changed using the --config=path command-line option.

[Global]

files:

    # Files to be used *only* if no files are given on the command line.
    # glob.glob wildcards are supported.

    # c:/Repos/leo-editor/leo/core/leoAst.py
    # c:/Repos/leo-editor/leo/core/*.py
    # c:/Repos/leo-editor/plugins/*.py

output_directory: ~/stubs

prefix_lines:
    # Lines to be inserted at the start of each stub file.
    from typing import TypeVar, Iterable
    T = TypeVar('T', int, float, complex)

[Def Name Patterns]

[General Patterns]
</t>
<t tx="ekr.20160129073222.1">def __get_u(self) -&gt; Any:
    p = self
    return p.v.u

def __set_u(self, val: Any) -&gt; None:
    p = self
    p.v.u = val

u = property(
    __get_u, __set_u,
    doc="p.u property")
</t>
<t tx="ekr.20160225153333.1"></t>
<t tx="ekr.20160225153414.1">def is_at_all(self) -&gt; bool:
    """Return True if p.b contains an @all directive."""
    p = self
    return (
        p.isAnyAtFileNode()
        and any(g.match_word(s, 0, '@all') for s in g.splitLines(p.b)))

def in_at_all_tree(self) -&gt; bool:
    """Return True if p or one of p's ancestors is an @all node."""
    p = self
    for p in p.self_and_parents(copy=False):
        if p.is_at_all():
            return True
    return False
</t>
<t tx="ekr.20160225153430.1">def is_at_ignore(self) -&gt; bool:
    """Return True if p is an @ignore node."""
    p = self
    return g.match_word(p.h, 0, '@ignore')

def in_at_ignore_tree(self) -&gt; bool:
    """Return True if p or one of p's ancestors is an @ignore node."""
    p = self
    for p in p.self_and_parents(copy=False):
        if g.match_word(p.h, 0, '@ignore'):
            return True
    return False
</t>
<t tx="ekr.20160304054950.1">def setCloneFindByPredicateIcon(self, iconPath: Any, p: Position) -&gt; None:
    """Attach an icon to p.v.u."""
    if iconPath and g.os_path_exists(iconPath) and not g.os_path_isdir(iconPath):
        aList = p.v.u.get('icons', [])
        for d in aList:
            if d.get('file') == iconPath:
                break
        else:
            aList.append({
                'type': 'file',
                'file': iconPath,
                'on': 'VNode',
                # 'relPath': iconPath,
                'where': 'beforeHeadline',
                'xoffset': 2, 'xpad': 1,
                'yoffset': 0,

            })
            p.v.u['icons'] = aList
    elif iconPath:
        g.trace('bad icon path', iconPath)
</t>
<t tx="ekr.20160331191740.1">@g.command('diff-marked-nodes')
def diffMarkedNodes(event: Event) -&gt; None:
    """
    When two or more nodes are marked, this command creates a
    "diff marked node" as the last top-level node. The body of
    this node contains "diff n" nodes, one for each pair of compared
    nodes.

    Each diff n contains the diffs between the two diffed nodes, that is,
    difflib.Differ().compare(p1.b, p2.b).

    The children of the diff n are clones of the two compared nodes.
    """
    c = event and event.get('c')
    if not c:
        return
    u = c.undoer
    undoType = 'diff-marked-nodes'
    aList = [z for z in c.all_unique_positions() if z.isMarked()]
    if len(aList) &lt; 2:
        g.es_print('Please mark at least 2 nodes')
        return
    c.selectPosition(c.lastTopLevel())
    undoData = u.beforeInsertNode(c.p)
    root = c.lastTopLevel().insertAfter()
    root.h = 'diff marked nodes'
    root.b = '\n'.join([z.h for z in aList]) + '\n'
    n = 0
    while len(aList) &gt; 1:
        n += 1
        p1, p2 = aList[0], aList[1]
        aList = aList[1:]
        lines = difflib.Differ().compare(
            g.splitLines(p1.b.rstrip() + '\n'),
            g.splitLines(p2.b.rstrip() + '\n'))
        p = root.insertAsLastChild()
        p.h = f"diff {n}"
        p.b = f"1: {p1.h}\n2: {p2.h}\n{''.join(list(lines))}"
        u.afterInsertNode(p, undoType, undoData)
        for p3 in (p1, p2):
            clone = p3.clone()
            clone.moveToLastChildOf(p)
    u.afterInsertNode(root, undoType, undoData)
    root.expand()
    c.selectPosition(root)
    c.redraw()
</t>
<t tx="ekr.20160426061203.1">def dump(self) -&gt; None:
    """Dump the beadList"""
    c = self.c
    if g.unitTesting or not self.beadList:
        return
    print(f"NodeHisory.beadList: {c.shortFileName()}:")
    for i, data in enumerate(self.beadList):
        p, chapter = data
        p_s = p.h if p else 'no p'
        chapter_s = f"chapter: {chapter.name} " if chapter else ''
        mark_s = '**' if i == self.beadPointer else '  '
        print(f"{mark_s} {chapter_s} {p_s}")
    print('')
</t>
<t tx="ekr.20160430063406.1">def revertCommander(self, c: Cmdr) -&gt; None:
    """Revert c to the previously saved contents."""
    lm = self
    fn = c.mFileName
    # Re-read the file.
    theFile = lm.openAnyLeoFile(fn)
    if theFile:
        c.fileCommands.initIvars()
        # Closes the file.
        c.fileCommands.getLeoFile(theFile, fn, checkOpenFiles=False)
</t>
<t tx="ekr.20160502095354.1">def copyWithNewVnodes(self, copyMarked: bool = False) -&gt; Position:
    """
    Return an **unlinked** copy of p with a new vnode v.
    The new vnode is complete copy of v and all its descendants.
    """
    p = self
    return Position(v=p.v.copyTree(copyMarked))
</t>
<t tx="ekr.20160502100151.1">def copyTree(self, copyMarked: bool = False) -&gt; VNode:
    """
    Return an all-new tree of vnodes that are copies of self and all its
    descendants.

    **Important**: the v.parents ivar must be [] for all nodes.
    v._addParentLinks will set all parents.
    """
    v = self
    # Allocate a new vnode and gnx with empty children &amp; parents.
    v2 = VNode(context=v.context, gnx=None)
    assert v2.parents == [], v2.parents  # pylint: disable=use-implicit-booleaness-not-comparison
    assert v2.gnx
    assert v.gnx != v2.gnx
    # Copy vnode fields. Do **not** set v2.parents.
    v2._headString = g.toUnicode(v._headString, reportErrors=True)
    v2._bodyString = g.toUnicode(v._bodyString, reportErrors=True)
    v2.u = copy.deepcopy(v.u)
    if copyMarked and v.isMarked():
        v2.setMarked()
    # Recursively copy all descendant vnodes.
    for child in v.children:
        v2.children.append(child.copyTree(copyMarked))
    return v2
</t>
<t tx="ekr.20160502175451.1">def afterCopyMarkedNodes(self, p: Position) -&gt; None:
    u = self
    if u.redoing or u.undoing:
        return
    # createCommonBunch sets:
    #   oldDirty = p.isDirty()
    #   oldMarked = p.isMarked()
    #   oldSel = w and w.getSelectionRange() or None
    #   p = p.copy()
    bunch = u.createCommonBunch(p)
    # Set types.
    bunch.kind = 'copy-marked-nodes'
    bunch.undoType = 'copy-marked-nodes'
    # Set helpers.
    bunch.undoHelper = u.undoCopyMarkedNodes
    bunch.redoHelper = u.redoCopyMarkedNodes
    bunch.newP = p.next()
    bunch.newMarked = p.isMarked()
    u.pushBead(bunch)
</t>
<t tx="ekr.20160502175557.1">def redoCopyMarkedNodes(self) -&gt; None:
    c, u = self.c, self
    c.selectPosition(u.p)
    c.copyMarked()
    u.newP = c.p
</t>
<t tx="ekr.20160502175653.1">def undoCopyMarkedNodes(self) -&gt; None:
    u = self
    next = u.p.next()
    assert next.h == 'Copies of marked nodes', (u.p.h, next.h)
    next.doDelete()
    u.p.setAllAncestorAtFileNodesDirty()
    u.c.selectPosition(u.p)
</t>
<t tx="ekr.20160514120255.1">class NodeHistory:
    """A class encapsulating knowledge of visited nodes."""

    def __init__(self, c: Cmdr) -&gt; None:
        """Ctor for NodeHistory class."""
        self.c = c
        self.beadList: list[tuple[Position, Chapter]] = []
        self.beadPointer = -1
        self.skipBeadUpdate = False

    @others
</t>
<t tx="ekr.20160718072648.1">def setStdStreams(self) -&gt; None:
    """
    Make sure that stdout and stderr exist.
    This is an issue when running Leo with pythonw.exe.
    """
    # Define class LeoStdOut
    @others
    if not sys.stdout:
        sys.stdout = sys.__stdout__ = LeoStdOut('stdout')  # type:ignore
    if not sys.stderr:
        sys.stderr = sys.__stderr__ = LeoStdOut('stderr')  # type:ignore
</t>
<t tx="ekr.20160718091844.1">class LeoStdOut:
    """A class to put stderr &amp; stdout to Leo's log pane."""

    def __init__(self, kind: str) -&gt; None:
        self.kind = kind
        g.es_print = self.write
        g.pr = self.write

    def flush(self, *args: Any, **keys: Any) -&gt; None:
        pass
    @others
</t>
<t tx="ekr.20160718102306.1">def write(self, *args: Any, **keys: Any) -&gt; None:
    """Put all non-keyword args to the log pane, as in g.es."""
    #
    # Tracing will lead to unbounded recursion unless
    # sys.stderr has been redirected on the command line.
    app = g.app
    if not app or app.killed:
        return
    if app.gui and app.gui.consoleOnly:
        return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color: str = d.get('color')  # type:ignore
    if color == 'suppress':
        return
    if log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color, newline),)
</t>
<t tx="ekr.20161028035755.1">self.always_write_session_data = False  # Default: write session data only if no files on command line.
self.batchMode = False  # True: run in batch mode.
self.debug: list[str] = []  # A list of switches to be enabled.
self.diff = False  # True: run Leo in diff mode.
self.enablePlugins = True  # True: run start1 hook to load plugins. --no-plugins
self.failFast = False  # True: Use the failfast option in unit tests.
self.gui: LeoGui = None  # The gui class.
self.guiArgName: str = None  # The gui name given in --gui option.
self.ipython_inited = False  # True if leoIpython.py imports succeeded.
self.isTheme = False  # True: load files as theme files (ignore myLeoSettings.leo).
self.listen_to_log_flag = False  # True: execute listen-to-log command.
self.loaded_session = False  # Set by startup logic to True if no files specified on the command line.
self.silentMode = False  # True: no signon.
self.start_fullscreen = False  # For qt_frame plugin.
self.start_maximized = False  # For qt_frame plugin.
self.start_minimized = False  # For qt_frame plugin.
self.trace_binding: bool = None  # The name of a binding to trace, or None.
self.trace_setting: bool = None  # The name of a setting to trace, or None.
self.translateToUpperCase = False  # Never set to True.
self.useIpython = False  # True: add support for IPython.
self.use_splash_screen = True  # True: put up a splash screen.
self.write_black_sentinels = False  # True: write a space before '@' in sentinel lines.
</t>
<t tx="ekr.20161120105707.1">def nearest_roots(self, copy: bool = True, predicate: Optional[Callable] = None) -&gt; Generator:
    """
    A generator yielding all the root positions "near" p1 = self that
    satisfy the given predicate. p.isAnyAtFileNode is the default
    predicate.

    The search first proceeds up the p's tree. If a root is found, this
    generator yields just that root.

    Otherwise, the generator yields all nodes in p.subtree() that satisfy
    the predicate. Once a root is found, the generator skips its subtree.
    """
    p1 = self.copy()

    def default_predicate(p: Position) -&gt; bool:
        return p.isAnyAtFileNode()

    the_predicate = predicate or default_predicate

    # First, look up the tree.
    for p in p1.copy().self_and_parents(copy=False):
        if the_predicate(p):
            yield p.copy() if copy else p
            return
    # Next, look for all root's in p's subtree.
    after = p1.nodeAfterTree()
    p = p1.copy()
    while p and p != after:
        if the_predicate(p):
            yield p.copy() if copy else p
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
</t>
<t tx="ekr.20161120163203.1">def nearest_unique_roots(self, copy: bool = True, predicate: Callable = None) -&gt; Generator:
    """
    A generator yielding all unique root positions "near" p1 = self that
    satisfy the given predicate. p.isAnyAtFileNode is the default
    predicate.

    The search first proceeds up the p's tree. If a root is found, this
    generator yields just that root.

    Otherwise, the generator yields all unique nodes in p.subtree() that
    satisfy the predicate. Once a root is found, the generator skips its
    subtree.
    """
    p1 = self.copy()

    def default_predicate(p: Position) -&gt; bool:
        return p.isAnyAtFileNode()

    the_predicate = predicate or default_predicate

    # First, look up the tree.
    for p in p1.copy().self_and_parents(copy=False):
        if the_predicate(p):
            yield p.copy() if copy else p
            return
    # Next, look for all unique .md files in the tree.
    seen = set()
    after = p1.nodeAfterTree()
    p = p1.copy()
    while p and p != after:
        if the_predicate(p):
            if p.v not in seen:
                seen.add(p.v)
                yield p.copy() if copy else p
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

nearest = nearest_unique_roots
</t>
<t tx="ekr.20161121102113.1">def make_script_substitutions_in_headline(self, p: Position) -&gt; bool:
    """Make scripting substitutions in p.h."""
    c = self.c
    p = c.p
    pattern = re.compile(r'^(.*)%s(.+)%s(.*)$' % (
        re.escape(c.abbrev_subst_start),
        re.escape(c.abbrev_subst_end),
    ))
    changed = False
    # Perform at most one scripting substition.
    m = pattern.match(p.h)
    if m:
        content = m.group(2)
        c.abbrev_subst_env['x'] = ''
        try:
            exec(content, c.abbrev_subst_env, c.abbrev_subst_env)
            x = c.abbrev_subst_env.get('x')
            if x:
                p.h = f"{m.group(1)}{x}{m.group(3)}"
                changed = True
        except Exception:
            # Leave p.h alone.
            g.trace('scripting error in', p.h)
            g.es_exception()
    return changed
</t>
<t tx="ekr.20161121111502.1">def get_ch(self, event: Event, stroke: Stroke, w: Wrapper) -&gt; str:
    """Get the ch from the stroke."""
    ch = g.checkUnicode(event and event.char or '')
    if self.expanding:
        return None
    if w.hasSelection():
        return None
    assert g.isStrokeOrNone(stroke), stroke
    if stroke in ('BackSpace', 'Delete'):
        return None
    d = {'Return': '\n', 'Tab': '\t', 'space': ' ', 'underscore': '_'}
    if stroke:
        ch = d.get(stroke.s, stroke.s)
        if len(ch) &gt; 1:
            if (stroke.find('Ctrl+') &gt; -1 or
                stroke.find('Alt+') &gt; -1 or
                stroke.find('Meta+') &gt; -1
            ):
                ch = ''
            else:
                ch = event.char if event else ''
    else:
        ch = event.char
    return ch
</t>
<t tx="ekr.20161121112346.1">def get_prefixes(self, w: Wrapper) -&gt; tuple[str, int, int, list[str]]:
    """Return the prefixes at the current insertion point of w."""
    # New code allows *any* sequence longer than 1 to be an abbreviation.
    # Any whitespace stops the search.
    s = w.getAllText()
    j = w.getInsertPoint()
    i, prefixes = j - 1, []
    while len(s) &gt; i &gt;= 0 and s[i] not in ' \t\n':
        prefixes.append(s[i:j])
        i -= 1
    prefixes = list(reversed(prefixes))
    if '' not in prefixes:
        prefixes.append('')
    return s, i, j, prefixes
</t>
<t tx="ekr.20161121112837.1">def match_prefix(self, ch: str, i: int, j: int, prefix: str, s: str) -&gt; tuple[int, str, str, str]:
    """A match helper."""
    i = j - len(prefix)
    word = g.checkUnicode(prefix) + g.checkUnicode(ch)
    tag = 'tree'
    val = self.tree_abbrevs_d.get(word)
    if not val:
        val, tag = self.abbrevs.get(word, (None, None))
    if val:
        # Require a word match if the abbreviation is itself a word.
        if ch in ' \t\n':
            word = word.rstrip()
        if word.isalnum() and word[0].isalpha():
            if i == 0 or s[i - 1] in ' \t\n':
                pass
            else:
                i -= 1
                word, val = None, None  # 2017/03/19.
    else:
        i -= 1
        word, val = None, None
    return i, tag, word, val
</t>
<t tx="ekr.20161121114504.1">def post_pass(self) -&gt; None:
    """The post pass: make script substitutions in all headlines."""
    if self.root:
        for p in self.root.self_and_subtree():
            self.make_script_substitutions_in_headline(p)
</t>
<t tx="ekr.20161121121636.1">def exec_content(self, content: str) -&gt; None:
    """Execute the content in the environment, and return the result."""
</t>
<t tx="ekr.20170216091704.1">def openUrlHelper(event: Any, url: str = None) -&gt; Optional[str]:
    """Open the unl, url or gnx under the cursor.  Return it for unit testing."""
    c = getattr(event, 'c', None)
    if not c:
        return None
    w = getattr(event, 'w', c.frame.body.wrapper)
    if not g.app.gui.isTextWrapper(w):
        g.internalError('must be a text wrapper', w)
        return None
    if event:
        event.widget = w
    # Part 1: get the url.
    if url is None:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i, j = w.getSelectionRange()
        if i != j:
            return None  # So find doesn't open the url.
        row, col = g.convertPythonIndexToRowCol(s, ins)
        i, j = g.getLine(s, ins)
        line = s[i:j]
        # Order is important.
        &lt;&lt; look for section ref &gt;&gt;
        url = unl = None
        &lt;&lt; look for url &gt;&gt;
        if not url:
            &lt;&lt; look for unl &gt;&gt;
            if not unl:
                &lt;&lt; look for gnx &gt;&gt;
    elif not isinstance(url, str):
        url = url.toString()
        url = g.toUnicode(url)  # #571
    if url and g.isValidUrl(url):
        # Part 2: handle the url
        p = c.p
        if not g.doHook("@url1", c=c, p=p, url=url):
            g.handleUrl(url, c=c, p=p)
        g.doHook("@url2", c=c, p=p)
        return url
    # Part 3: call find-def.
    if not w.hasSelection():
        c.editCommands.extendToWord(event, select=True)
    word = w.getSelectedText().strip()
    if not word:
        return None
    p, pos, newpos = c.findCommands.find_def(event)
    if p:
        return None
    &lt;&lt; look for filename or import&gt;&gt;
    return None
</t>
<t tx="ekr.20170221063527.1">def handleUnl(unl_s: str, c: Cmdr) -&gt; Optional[Cmdr]:
    """
    Select the node given by any kind of unl.
    This must *never* open a browser.
    """
    if not unl_s:
        return None
    unl = unl_s.strip()
    if not unl:
        return None
    p = g.findAnyUnl(unl, c)
    if not p:
        print(f"Not found: {unl!r}")
        return None
    # Do not assume that p is in c.
    c2 = p.v.context
    if c2 != c:
        g.app.selectLeoWindow(c2)  # Switch outlines.
    c2.redraw(p)
    return c2
</t>
<t tx="ekr.20170226054459.1">def handleUrlHelper(url: str, c: Cmdr, p: Position) -&gt; None:  # pragma: no cover
    """Open a url.  Most browsers should handle:
        ftp://ftp.uu.net/public/whatever
        http://localhost/MySiteUnderDevelopment/index.html
        file:///home/me/todolist.html
    """
    if g.unitTesting:
        return
    tag = 'file://'
    original_url = url
    if url.startswith(tag) and not url.startswith(tag + '#'):
        # Finalize the path *before* parsing the url.
        url = g.computeFileUrl(url, c=c, p=p)
    parsed = urlparse.urlparse(url)
    if parsed.netloc:
        leo_path = os.path.join(parsed.netloc, parsed.path)
        # "readme.txt" gets parsed into .netloc...
    else:
        leo_path = parsed.path
    if leo_path.endswith('\\'):
        leo_path = leo_path[:-1]
    if leo_path.endswith('/'):
        leo_path = leo_path[:-1]
    if parsed.scheme == 'file' and leo_path.endswith('.leo'):
        g.handleUnl(original_url, c)
    elif parsed.scheme in ('', 'file'):
        unquote_path = g.unquoteUrl(leo_path)
        if g.os_path_exists(leo_path):
            g.os_startfile(unquote_path)
        else:
            g.es(f"File '{leo_path}' does not exist")
    else:
        # Mozilla throws a weird exception, then opens the file!
        try:
            webbrowser.open(url)
        except Exception:
            pass
</t>
<t tx="ekr.20170226060816.1">def traceUrl(c: Cmdr, path: str, parsed: Any, url: str) -&gt; None:  # pragma: no cover

    print()
    g.trace('url          ', url)
    g.trace('c.frame.title', c.frame.title)
    g.trace('path         ', path)
    g.trace('parsed.fragment', parsed.fragment)
    g.trace('parsed.netloc', parsed.netloc)
    g.trace('parsed.path  ', parsed.path)
    g.trace('parsed.scheme', repr(parsed.scheme))
</t>
<t tx="ekr.20170302093006.1">def createAllImporterData(self) -&gt; None:
    """
    New in Leo 5.5:

    Create global data structures describing importers and writers.
    """
    assert g.app.loadDir  # This is the only data required.
    self.createWritersData()  # Was an AtFile method.
    self.createImporterData()  # Was a LeoImportCommands method.
</t>
<t tx="ekr.20170324143944.3">@g.command('show-fonts')
def showFonts(self, event=None):
    """Open a tab in the log pane showing a font picker."""
    c, p = self.c, self.c.p
    picker = QtWidgets.QFontDialog()
    if p.h.startswith('@font'):
        (name, family, weight, slant, size) = leoConfig.parseFont(p.b)
    else:
        name, family, weight, slant, size = None, None, False, False, 12
    try:
        font = QtGui.QFont()
        if family:
            font.setFamily(family)
        font.setBold(weight)
        font.setItalic(slant)
        try:
            font.setPointSizeF(float(size))
        except TypeError:
            font.setPointSize(int(size))
        picker.setCurrentFont(font)
    except ValueError:
        pass
    except Exception:
        g.es_exception()
    result = picker.exec_()
    if not result:
        g.es("No font selected")
    else:
        font = picker.selectedFont()
        udata = c.undoer.beforeChangeNodeContents(p)
        comments = [x for x in g.splitLines(p.b) if x.strip().startswith('#')]
        defs = [
            '\n' if comments else '',
            f"{name}_family = {font.family()}\n",
            f"{name}_weight = {'bold' if font.bold() else 'normal'}\n",
            f"{name}_slant = {'italic' if font.italic() else 'roman'}\n",
            f"{name}_size = {font.pointSizeF()}\n"
        ]
        p.b = ''.join(comments + defs)
        c.undoer.afterChangeNodeContents(p, 'change-font', udata)
</t>
<t tx="ekr.20170404103953.1">def import_one_file(self, path: str, parent: Position) -&gt; None:
    """Import one file to the last top-level node."""
    c = self.c
    self.n_files += 1
    if self.kind == '@edit':
        p = parent.insertAsLastChild()
        p.v.h = '@edit ' + path.replace('\\', '/')
        s, e = g.readFileIntoString(path, kind=self.kind)
        p.v.b = s
        return
    # #1484: Use this for @auto as well.
    c.importCommands.importFilesCommand(
        files=[path],
        parent=parent,
        shortFn=True,
        treeType='@file',  # '@auto','@clean','@nosent' cause problems.
        verbose=self.verbose,  # Leo 6.6.
    )
    p = parent.lastChild()
    p.h = self.kind + p.h[5:]  # Honor the requested kind.
    if self.safe_at_file:
        p.v.h = '@' + p.v.h
</t>
<t tx="ekr.20170427112302.1">g.cls()
import glob
files = glob.glob(g.os_path_join(g.app.loadDir, '*.py'))
files = [z for z in files if g.os_path_basename(z).startswith('leo')]
if 0:
    g.printList(files)
found = set()
for p in c.all_unique_positions():
    name = p.isAnyAtFileNode()
    if name and name.startswith('leo'):
        path = g.os_path_join(g.app.loadDir, name)
        found.add(path)
if 0:
    print('found')
    g.printList(list(found))
else:
    missing = set(files) - found
    if missing:
        print('not found...')
        g.printList(list(sorted(missing)))
    else:
        print('done')
        </t>
<t tx="ekr.20170427114412.1"></t>
<t tx="ekr.20170428084123.1">@language python
"""Recursively import all python files in a directory and clean the result."""
@tabwidth -4 # For a better match.
g.cls()
# dir_ = r'C:\Repos\codon\codon\app'
dir_ = r'C:\Repos\ekr-mypy2\mypy'
c.recursiveImport(
    dir_=dir_,
    kind = '@clean', # '@auto', '@clean', '@nosent','@file',
    recursive = True,
    safe_at_file = False,
    # ['.codon', '.cpp', '.html', '.js', '.json', '.py', '.rs', '.svg', '.ts', '.tsx']
    theTypes = ['.py'],
    verbose = False,
)
if 1:
    last = c.lastTopLevel()
    last.expand()
    if last.hasChildren():
        last.firstChild().expand()
    c.redraw(last)
print('Done')</t>
<t tx="ekr.20170428084208.443">#!/usr/bin/python
# This file generates pyflakes warnings for *all* imported symbols.
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20170428084208.444">from .globals                   import DEBUG, DISABLE_RESIZE_SYSTEM

from .wgwidget                  import TEST_SETTINGS, ExhaustedTestInput, add_test_input_from_iterable, add_test_input_ch

from .npyssafewrapper           import wrapper, wrapper_basic

from   .npysThemeManagers       import ThemeManager, disableColor, enableColor
from   . import npysThemes      as     Themes
from   .apNPSApplication        import NPSApp
from   .apNPSApplicationManaged import NPSAppManaged
from   .proto_fm_screen_area    import setTheme
from   .fmForm                  import FormBaseNew, Form, TitleForm, TitleFooterForm, SplitForm, FormExpanded, FormBaseNewExpanded, blank_terminal
from   .fmActionForm            import ActionForm, ActionFormExpanded
from   .fmActionFormV2          import ActionFormV2, ActionFormExpandedV2, ActionFormMinimal
from   .fmFormWithMenus         import FormWithMenus, ActionFormWithMenus, \
                                       FormBaseNewWithMenus, SplitFormWithMenus, \
                                       ActionFormV2WithMenus
from   .fmPopup                 import Popup, MessagePopup, ActionPopup, PopupWide, ActionPopupWide
from   .fmFormMutt              import FormMutt, FormMuttWithMenus
from   .fmFileSelector          import FileSelector, selectFile

from .fmFormMuttActive          import ActionControllerSimple, TextCommandBox, \
                                       FormMuttActive, FormMuttActiveWithMenus
from .fmFormMuttActive          import FormMuttActiveTraditional, FormMuttActiveTraditionalWithMenus


from .fmFormMultiPage           import FormMultiPage, FormMultiPageAction,\
                                       FormMultiPageActionWithMenus, FormMultiPageWithMenus

from .npysNPSFilteredData       import NPSFilteredDataBase, NPSFilteredDataList

from .wgbutton                  import MiniButton
from .wgbutton                  import MiniButtonPress
from .wgbutton                  import MiniButton      as Button
from .wgbutton                  import MiniButtonPress as ButtonPress

from .wgtextbox                 import Textfield, FixedText
from .wgtitlefield              import TitleText, TitleFixedText
from .wgpassword                import PasswordEntry, TitlePassword
from .wgannotatetextbox         import AnnotateTextboxBase
from .wgannotatetextbox         import AnnotateTextboxBaseRight

from .wgslider                  import Slider, TitleSlider
from .wgslider                  import SliderNoLabel, TitleSliderNoLabel
from .wgslider                  import SliderPercent, TitleSliderPercent

from .wgwidget                  import DummyWidget, NotEnoughSpaceForWidget
from . import wgwidget as widget

from .wgmultiline               import MultiLine, Pager, TitleMultiLine, TitlePager, MultiLineAction, BufferPager, TitleBufferPager
from .wgmultiselect             import MultiSelect, TitleMultiSelect, MultiSelectFixed, \
                                       TitleMultiSelectFixed, MultiSelectAction
from .wgeditmultiline           import MultiLineEdit
from .wgcombobox                import ComboBox, TitleCombo
from .wgcheckbox                import Checkbox, RoundCheckBox, CheckBoxMultiline, RoundCheckBoxMultiline, CheckBox, CheckboxBare
from .wgFormControlCheckbox     import FormControlCheckbox
from .wgautocomplete            import TitleFilename, Filename, Autocomplete
from .muMenu                    import Menu
from .wgselectone               import SelectOne, TitleSelectOne
from .wgdatecombo               import DateCombo, TitleDateCombo

from .npysTree import TreeData
from .wgmultilinetree           import MLTree, MLTreeAnnotated, MLTreeAction, MLTreeAnnotatedAction
from .wgmultilinetreeselectable import MLTreeMultiSelect, TreeLineSelectable
from .wgmultilinetreeselectable import MLTreeMultiSelectAnnotated, TreeLineSelectableAnnotated


# The following are maintained for compatibility with old code only. ##########################################

from .compatibility_code.oldtreeclasses import MultiLineTree, SelectOneTree
from .compatibility_code.oldtreeclasses import MultiLineTreeNew, MultiLineTreeNewAction, TreeLine, TreeLineAnnotated # Experimental
from .compatibility_code.oldtreeclasses import MultiLineTreeNewAnnotatedAction, MultiLineTreeNewAnnotated # Experimental
from .compatibility_code.npysNPSTree import NPSTreeData

# End compatibility. ###########################################################################################

from .wgfilenamecombo           import FilenameCombo, TitleFilenameCombo
from .wgboxwidget               import BoxBasic, BoxTitle
from .wgmultiline               import MultiLineActionWithShortcuts
from .wgmultilineeditable       import MultiLineEditable, MultiLineEditableTitle, MultiLineEditableBoxed

from .wgmonthbox                import MonthBox
from .wggrid                    import SimpleGrid
from .wggridcoltitles           import GridColTitles

from .muNewMenu                 import NewMenu, MenuItem
from .wgNMenuDisplay            import MenuDisplay, MenuDisplayScreen

from .npyspmfuncs               import CallSubShell

from .utilNotify                 import notify, notify_confirm, notify_wait, notify_ok_cancel, notify_yes_no

# Base classes for overriding:

# Standard Forms:
from . import stdfmemail

# Experimental Only
from .wgtextboxunicode import TextfieldUnicode
from .wgtexttokens     import TextTokens, TitleTextTokens

# Very experimental. Don't use for anything serious
from .apOptions import SimpleOptionForm
from .apOptions import OptionListDisplay, OptionChanger, OptionList, OptionLimitedChoices, OptionListDisplayLine
from .apOptions import OptionFreeText, OptionSingleChoice, OptionMultiChoice, OptionMultiFreeList, \
                       OptionBoolean, OptionFilename, OptionDate, OptionMultiFreeText


# This really is about as experimental as it gets
from .apNPSApplicationEvents import StandardApp
from .eveventhandler import Event


</t>
<t tx="ekr.20170428085201.1">@nosearch
@nobeautify</t>
<t tx="ekr.20170806094318.18">def compare(self, d1: dict, d2: dict, root: Position) -&gt; Position:
    """Compare dicts d1 and d2."""
    for h in sorted(d1.keys()):
        p1, p2 = d1.get(h), d2.get(h)
        if h in d2:
            lines1, lines2 = g.splitLines(p1.b), g.splitLines(p2.b)
            aList = list(difflib.unified_diff(lines1, lines2, 'vr1', 'vr2'))
            if aList:
                p = root.insertAsLastChild()
                p.h = h
                p.b = ''.join(aList)
                p1.clone().moveToLastChildOf(p)
                p2.clone().moveToLastChildOf(p)
        elif p1.b.strip():
            # Only in p1 tree, and not an organizer node.
            p = root.insertAsLastChild()
            p.h = h + f"({p1.h} only)"
            p1.clone().moveToLastChildOf(p)
    for h in sorted(d2.keys()):
        p2 = d2.get(h)
        if h not in d1 and p2.b.strip():
            # Only in p2 tree, and not an organizer node.
            p = root.insertAsLastChild()
            p.h = h + f"({p2.h} only)"
            p2.clone().moveToLastChildOf(p)
    return root
</t>
<t tx="ekr.20170806094318.19">def run(self, c: Cmdr, p1: Position, p2: Position, tag: str) -&gt; None:
    """Main line."""
    self.c = c
    root = c.p.insertAfter()
    root.h = tag
    d1 = self.scan(p1)
    d2 = self.scan(p2)
    self.compare(d1, d2, root)
    c.p.contract()
    root.expand()
    c.selectPosition(root)
    c.redraw()
</t>
<t tx="ekr.20170806094318.7">@cmd('file-insert')
def insertFile(self, event: Event) -&gt; None:
    """
    Prompt for the name of a file.
    Insert the file's contents in the body at the insertion point.
    """
    w = self.editWidget(event)
    if not w:
        return
    fn = self.getReadableTextFile()
    if not fn:
        return
    s, e = g.readFileIntoString(fn)
    if s:
        self.beginCommand(w, undoType='insert-file')
        i = w.getInsertPoint()
        w.insert(i, s)
        w.seeInsertPoint()
        self.endCommand(changed=True, setLabel=True)
</t>
<t tx="ekr.20170806094319.10">@cmd('clean-at-clean-tree')
def cleanAtCleanTree(self, event: Event) -&gt; None:
    """
    Clean whitespace in the nearest @clean tree.

    This command is not undoable.
    """
    c = self.c
    # Look for an @clean node.
    for p in c.p.self_and_parents(copy=False):
        if p.isAtCleanNode():
            break
    else:
        g.es_print('no @clean node found', p.h, color='blue')
        return
    # pylint: disable=undefined-loop-variable
    # p is certainly defined here.
    n = 0
    for p2 in p.subtree():
        if self.cleanAtCleanNode(p2):
            n += 1
    if n &gt; 0:
        c.setChanged()
        c.undoer.clearAndWarn('clean-at-clean-tree')
    g.es_print(f"{n} node{g.plural(n)} cleaned")
</t>
<t tx="ekr.20170806094319.2">def scan(self, p1: Position) -&gt; dict[str, Position]:
    """
    Create a dict of the methods in p1.
    Keys are headlines, stripped of prefixes.
    Values are copies of positions.
    """
    d: dict[str, Position] = {}
    for p in p1.self_and_subtree(copy=False):
        h = p.h.strip()
        i = h.find('.')
        if i &gt; -1:
            h = h[i + 1 :].strip()
        if h in d:
            g.es_print('duplicate', p.h)
        else:
            d[h] = p.copy()
    return d
</t>
<t tx="ekr.20170806094319.3">def compareTrees(self, p1: Position, p2: Position, tag: str) -&gt; None:


    class CompareTreesController:
        @others

    CompareTreesController().run(self.c, p1, p2, tag)
</t>
<t tx="ekr.20170806094319.5">@cmd('clean-at-clean-files')
def cleanAtCleanFiles(self, event: Event) -&gt; None:
    """Adjust whitespace in all @clean files."""
    c = self.c
    undoType = 'clean-at-clean-files'
    c.undoer.beforeChangeGroup(c.p, undoType, verboseUndoGroup=True)
    total = 0
    for p in c.all_unique_positions():
        if p.isAtCleanNode():
            n = 0
            for p2 in p.subtree():
                bunch2 = c.undoer.beforeChangeNodeContents(p2)
                if self.cleanAtCleanNode(p2):
                    n += 1
                    total += 1
                    c.undoer.afterChangeNodeContents(p2, undoType, bunch2)
            g.es_print(f"{n} node{g.plural(n)} {p.h}")
    # Call this only once, at end.
    c.undoer.afterChangeGroup(c.p, undoType)
    if total == 0:
        g.es("Command did not find any whitespace to adjust")
    g.es_print(f"{total} total node{g.plural(total)}")
</t>
<t tx="ekr.20170806094319.8">def cleanAtCleanNode(self, p: Position) -&gt; bool:
    """Adjust whitespace in p, part of an @clean tree."""
    s = p.b.strip()
    if not s or p.h.strip().startswith('&lt;&lt;'):
        return False
    ws = '\n\n' if g.match_word(s, 0, 'class') else '\n'
    s2 = ws + s + ws
    changed = s2 != p.b
    if changed:
        p.b = s2
        p.setDirty()
    return changed
</t>
<t tx="ekr.20170806094320.12">def git_diff(self, rev1: str = 'HEAD', rev2: str = '') -&gt; None:
    """The main line of the git diff command."""
    if not self.get_parent_of_git_directory():
        return
    # Diff the given revs.
    ok = self.diff_revs(rev1, rev2)
    if ok:
        return
    # Go back at most 5 revs...
    n1, n2 = 1, 0
    while n1 &lt;= 5:
        ok = self.diff_revs(
            rev1=f"HEAD@{{{n1}}}",
            rev2=f"HEAD@{{{n2}}}")
        if ok:
            return
        n1, n2 = n1 + 1, n2 + 1
    if not ok:
        g.es_print('no changed readable files from HEAD@{1}..HEAD@{5}')
</t>
<t tx="ekr.20170806094320.13">class GitDiffController:
    """A class to do git diffs."""

    def __init__(self, c: Cmdr) -&gt; None:
        self.c = c
        self.file_node: Position = None
        self.root: Position = None
    @others
</t>
<t tx="ekr.20170806094320.15">def get_file_from_rev(self, rev: str, fn: str) -&gt; str:
    """Get the file from the given rev, or the working directory if None."""
    directory = self.get_parent_of_git_directory()
    if not directory:
        return ''
    path = g.finalize_join(directory, fn)

    # Find all the files in the rev.
    if rev:
        command = f"git ls-tree -r {rev} --name-only"
        lines = g.execGitCommand(command, directory)
        if not any(fn in z for z in lines):
            # g.trace(f"{fn} not in {rev}")
            return ''
        # Get the file using git.
        # Use the file name, not the path.
        command = f"git show {rev}:{fn}"
        lines = g.execGitCommand(command, directory)
        return g.toUnicode(''.join(lines)).replace('\r', '')

    # Read the file.
    try:
        with open(path, 'rb') as f:
            b = f.read()
        return g.toUnicode(b).replace('\r', '')
    except Exception:
        g.es_print('Can not read', path)
        g.es_exception()
        return ''
</t>
<t tx="ekr.20170806094320.18">def create_root(self, rev1: str, rev2: str) -&gt; Position:
    """Create the top-level organizer node describing the git diff."""
    c = self.c
    r1, r2 = rev1 or '', rev2 or ''
    p = c.lastTopLevel().insertAfter()
    p.h = f"git diff {r1} {r2}"
    p.b = '@ignore\n@nosearch\n'
    if r1 and r2:
        p.b += (
            f"{r1}={self.get_revno(r1)}\n"
            f"{r2}={self.get_revno(r2)}")
    else:
        p.b += f"{r1}={self.get_revno(r1)}"
    return p
</t>
<t tx="ekr.20170806094320.6">def diff_file(self, fn: str, rev1: str = 'HEAD', rev2: str = '') -&gt; None:
    """
    Create an outline describing the git diffs for fn.
    """
    c = self.c
    directory = self.get_parent_of_git_directory()
    if not directory:
        return
    s1 = self.get_file_from_rev(rev1, fn)
    s2 = self.get_file_from_rev(rev2, fn)
    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    diff_list = list(difflib.unified_diff(
        lines1,
        lines2,
        rev1 or 'uncommitted',
        rev2 or 'uncommitted',
    ))
    diff_list.insert(0, '@ignore\n@nosearch\n@language patch\n')
    self.file_node = self.create_file_node(diff_list, fn)
    # #1777: The file node will contain the entire added/deleted file.
    if not s1:
        self.file_node.h = f"Added: {self.file_node.h}"
        return
    if not s2:
        self.file_node.h = f"Deleted: {self.file_node.h}"
        return
    # Finish.
    path = g.finalize_join(directory, fn)  # #1781: bug fix.
    c1 = c2 = None
    if fn.endswith('.leo'):
        c1 = self.make_leo_outline(fn, path, s1, rev1)
        c2 = self.make_leo_outline(fn, path, s2, rev2)
    else:
        root = self.find_file(fn)
        if c.looksLikeDerivedFile(path):
            c1 = self.make_at_file_outline(fn, s1, rev1)
            c2 = self.make_at_file_outline(fn, s2, rev2)
        elif root:
            c1 = self.make_at_clean_outline(fn, root, s1, rev1)
            c2 = self.make_at_clean_outline(fn, root, s2, rev2)
    if c1 and c2:
        self.make_diff_outlines(c1, c2, fn, rev1, rev2)
        self.file_node.b = (
            f"{self.file_node.b.rstrip()}\n"
            f"@language {c2.target_language}\n")
</t>
<t tx="ekr.20170806094320.7">def find_file(self, fn: str) -&gt; Optional[Position]:
    """Return the @&lt;file&gt; node matching fn."""
    c = self.c
    fn = g.os_path_basename(fn)
    for p in c.all_unique_positions():
        if p.isAnyAtFileNode():
            fn2 = p.anyAtFileNodeName()
            if fn2.endswith(fn):
                return p
    return None
</t>
<t tx="ekr.20170806094320.9">def get_files(self, rev1: str, rev2: str) -&gt; list[str]:
    """Return a list of changed files."""
    # #2143
    directory = self.get_parent_of_git_directory()
    if not directory:
        return []
    command = f"git diff --name-only {(rev1 or '')} {(rev2 or '')}"
    # #1781: Allow diffs of .leo files.
    return [
        z.strip() for z in g.execGitCommand(command, directory)
            if not z.strip().endswith(('.db', '.zip'))
    ]
</t>
<t tx="ekr.20170806094321.1">def create_file_node(self, diff_list: list[str], fn: str) -&gt; Position:
    """Create an organizer node for the file."""
    p = self.root.insertAsLastChild()
    p.h = 'diff: ' + fn.strip()
    p.b = ''.join(diff_list)
    return p
</t>
<t tx="ekr.20170806094321.3">def find_git_working_directory(self, directory: str) -&gt; Optional[str]:
    """Return the git working directory, starting at directory."""
    while directory:
        if g.os_path_exists(g.finalize_join(directory, '.git')):
            return directory
        path2 = g.finalize_join(directory, '..')
        if path2 == directory:
            break
        directory = path2
    return None
</t>
<t tx="ekr.20170806094321.5">def finish(self) -&gt; None:
    """Finish execution of this command."""
    c = self.c
    c.selectPosition(self.root)
    self.root.expand()
    c.redraw(self.root)
    c.treeWantsFocusNow()
</t>
<t tx="ekr.20170806094321.7">def make_at_file_outline(self, fn: str, s: str, rev: str) -&gt; Cmdr:
    """Create a hidden temp outline from lines."""
    # A specialized version of atFileCommands.read.
    hidden_c = leoCommands.Commands(fn, gui=g.app.nullGui)
    at = hidden_c.atFileCommands
    hidden_c.frame.createFirstTreeNode()
    root = hidden_c.rootPosition()
    root.h = fn + ':' + rev if rev else fn
    at.initReadIvars(root, fn)
    if at.errors &gt; 0:
        g.trace('***** errors')
        return None
    at.fast_read_into_root(
        c=hidden_c,
        contents=s,
        gnx2vnode={},
        path=fn,
        root=root,
    )
    return hidden_c
</t>
<t tx="ekr.20170806125535.1">def make_diff_outlines(self,
    c1: Cmdr,
    c2: Cmdr,
    fn: str,
    rev1: str = '',
    rev2: str = '',
) -&gt; None:
    """Create an outline-oriented diff from the *hidden* outlines c1 and c2."""
    added, deleted, changed = self.compute_dicts(c1, c2)
    table = (
        (added, 'Added'),
        (deleted, 'Deleted'),
        (changed, 'Changed'))
    for d, kind in table:
        self.create_compare_node(c1, c2, d, kind, rev1, rev2)
</t>
<t tx="ekr.20170806191707.1">def compute_dicts(self, c1: Cmdr, c2: Cmdr) -&gt; tuple[dict, dict, dict]:
    """Compute inserted, deleted, changed dictionaries."""
    # Special case the root: only compare the body text.
    root1, root2 = c1.rootPosition().v, c2.rootPosition().v
    root1.h = root2.h
    if 0:
        g.trace('c1...')
        for p in c1.all_positions():
            print(f"{len(p.b):4} {p.h}")
        g.trace('c2...')
        for p in c2.all_positions():
            print(f"{len(p.b):4} {p.h}")
    d1 = {v.fileIndex: v for v in c1.all_unique_nodes()}
    d2 = {v.fileIndex: v for v in c2.all_unique_nodes()}
    added = {key: d2.get(key) for key in d2 if not d1.get(key)}
    deleted = {key: d1.get(key) for key in d1 if not d2.get(key)}
    # Remove the root from the added and deleted dicts.
    if root2.fileIndex in added:
        del added[root2.fileIndex]
    if root1.fileIndex in deleted:
        del deleted[root1.fileIndex]
    changed = {}
    for key in d1:
        if key in d2:
            v1 = d1.get(key)
            v2 = d2.get(key)
            assert v1 and v2
            assert v1.context != v2.context
            if v1.h != v2.h or v1.b != v2.b:
                changed[key] = (v1, v2)
    return added, deleted, changed
</t>
<t tx="ekr.20170806191942.2">def create_compare_node(self,
    c1: Cmdr,
    c2: Cmdr,
    d: dict[str, tuple[VNode, VNode]],
    kind: str,
    rev1: str,
    rev2: str,
) -&gt; None:
    """Create nodes describing the changes."""
    if not d:
        return
    parent = self.file_node.insertAsLastChild()
    parent.setHeadString(f"diff: {kind}")
    for key in d:
        if kind.lower() == 'changed':
            v1, v2 = d.get(key)
            # Organizer node: contains diff
            organizer = parent.insertAsLastChild()
            organizer.h = f"diff: {v2.h}"
            body = list(difflib.unified_diff(
                g.splitLines(v1.b),
                g.splitLines(v2.b),
                rev1 or 'uncommitted',
                rev2 or 'uncommitted',
            ))
            if ''.join(body).strip():
                body.insert(0, '@ignore\n@nosearch\n@language patch\n')
                body.append(f"@language {c2.target_language}\n")
            else:
                body = ['Only headline has changed']
            organizer.b = ''.join(body)
            # Node 2: Old node
            p2 = organizer.insertAsLastChild()
            p2.h = 'Old:' + v1.h
            p2.b = v1.b
            # Node 3: New node
            assert v1.fileIndex == v2.fileIndex
            p_in_c = self.find_gnx(self.c, v1.fileIndex)
            if p_in_c:  # Make a clone, if possible.
                p3 = p_in_c.clone()
                p3.moveToLastChildOf(organizer)
            else:
                p3 = organizer.insertAsLastChild()
                p3.h = 'New:' + v2.h
                p3.b = v2.b
        elif kind.lower() == 'added':
            v = d.get(key)
            new_p = self.find_gnx(self.c, v.fileIndex)
            if new_p:  # Make a clone, if possible.
                p = new_p.clone()
                p.moveToLastChildOf(parent)
                # #2950: do not change p.b.
            else:
                p = parent.insertAsLastChild()
                p.h = v.h
                p.b = v.b
        else:
            v = d.get(key)
            p = parent.insertAsLastChild()
            p.h = v.h
            p.b = v.b
</t>
<t tx="ekr.20170811173924.1">@language python
import os
import subprocess
import sys
import time
win = sys.platform.startswith('win')
old_dir = os.getcwd()
if win:
    new_dir = r'C:\Repos\leo-editor'
    path = r'C:\Users\Edward~1\Backup'
else:
    new_dir = '/home/edward/Repos/leo-editor'
    path = '/home/edward/Backup'
assert g.os_path_exists(new_dir), repr(new_dir)
assert g.os_path_exists(path), repr(path)
stamp = time.strftime("%Y%m%d-%H%M%S")
fn = g.finalize_join(path, f"leo-bundle-all-{stamp}")
bundle_command = 'git bundle create %s --all' % fn
print(bundle_command)
os.chdir(new_dir)
proc = subprocess.Popen(bundle_command, shell=True)
proc.wait()
os.chdir(old_dir)
print('done! wrote %s' % fn)
</t>
<t tx="ekr.20170819035801.90">@cmd('git-diff')
@cmd('gd')
def gitDiff(self, event: Event = None) -&gt; None:
    """Produce a Leonine git diff."""
    GitDiffController(c=self.c).git_diff(rev1='HEAD')
</t>
<t tx="ekr.20170819132219.1">def find_gnx(self, c: Cmdr, gnx: str) -&gt; Optional[Position]:
    """Return a position in c having the given gnx."""
    for p in c.all_unique_positions():
        if p.v.fileIndex == gnx:
            return p
    return None
</t>
<t tx="ekr.20170820082125.1">def diff_revs(self, rev1: str, rev2: str) -&gt; bool:
    """
    A helper for Leo's git-diff command

    Diff all files given by rev1 and rev2.
    """
    c = self.c
    u = c.undoer
    undoType = 'git-diff-revs'
    files = self.get_files(rev1, rev2)
    if not files:
        return False
    c.selectPosition(c.lastTopLevel())
    undoData = u.beforeInsertNode(c.p)
    self.root = self.create_root(rev1, rev2)
    for fn in files:
        self.diff_file(fn=fn, rev1=rev1, rev2=rev2)
    u.afterInsertNode(self.root, undoType, undoData)
    self.finish()
    return True
</t>
<t tx="ekr.20170820084258.1">def make_at_clean_outline(self, fn: str, root: Position, s: str, rev: str) -&gt; Cmdr:
    """
    Create a hidden temp outline from lines without sentinels.
    root is the @&lt;file&gt; node for fn.
    s is the contents of the (public) file, without sentinels.
    """
    # A specialized version of at.readOneAtCleanNode.
    hidden_c = leoCommands.Commands(fn, gui=g.app.nullGui)
    at = hidden_c.atFileCommands
    x = hidden_c.shadowController
    hidden_c.frame.createFirstTreeNode()
    hidden_root = hidden_c.rootPosition()
    # copy root to hidden root, including gnxs.
    root.copyTreeFromSelfTo(hidden_root, copyGnxs=True)
    hidden_root.h = fn + ':' + rev if rev else fn
    # Set at.encoding first.
    # Must be called before at.scanAllDirectives.
    at.initReadIvars(hidden_root, fn)
    # Sets at.startSentinelComment/endSentinelComment.
    at.scanAllDirectives(hidden_root)
    new_public_lines = g.splitLines(s)
    old_private_lines = at.write_at_clean_sentinels(hidden_root)
    marker = x.markerFromFileLines(old_private_lines, fn)
    old_public_lines, junk = x.separate_sentinels(old_private_lines, marker)
    if old_public_lines:
        # Fix #1136: The old lines might not exist.
        new_private_lines = x.propagate_changed_lines(
            new_public_lines, old_private_lines, marker, p=hidden_root)
        at.fast_read_into_root(
            c=hidden_c,
            contents=''.join(new_private_lines),
            gnx2vnode={},
            path=fn,
            root=hidden_root,
        )
    return hidden_c
</t>
<t tx="ekr.20170821052348.1">def get_revno(self, revspec: str, abbreviated: bool = True) -&gt; str:
    """Return the abbreviated hash for the given revision spec."""
    if not revspec:
        return 'uncommitted'
    # Return only the abbreviated hash for the revspec.
    format_s = 'h' if abbreviated else 'H'
    command = f"git show --format=%{format_s} --no-patch {revspec}"
    directory = self.get_parent_of_git_directory()
    lines = g.execGitCommand(command, directory=directory)
    return ''.join(lines).strip()
</t>
<t tx="ekr.20171031111403.1"></t>
<t tx="ekr.20171119222458.1">def isLocalSettingsFile(self) -&gt; bool:
    """Return true if c is not leoSettings.leo or myLeoSettings.leo"""
    c = self.c
    fn = c.shortFileName().lower()
    for fn2 in ('leoSettings.leo', 'myLeoSettings.leo'):
        if fn.endswith(fn2.lower()):
            return False
    return True
</t>
<t tx="ekr.20171124081846.1">@g.commander_command('check-outline')
def fullCheckOutline(self: Cmdr, event: Event = None) -&gt; None:
    """Do a full check of the consistency of a .leo file."""
    c = self
    t1 = time.process_time()
    errors = c.checkOutline()
    t2 = time.time()
    g.es_print(f"check-outline: {errors} error{g.plural(errors)} in {t2 - t1:4.2f} sec.")
</t>
<t tx="ekr.20171229131953.1">def parseFont(b: str) -&gt; tuple[str, str, bool, bool, float]:
    family = None
    weight = None
    slant = None
    size = None
    settings_name = None
    for line in g.splitLines(b):
        line = line.strip()
        if line.startswith('#'):
            continue
        i = line.find('=')
        if i &lt; 0:
            continue
        name = line[:i].strip()
        if name.endswith('_family'):
            family = line[i + 1 :].strip()
        elif name.endswith('_weight'):
            weight = line[i + 1 :].strip()
        elif name.endswith('_size'):
            size_s = line[i + 1 :].strip()
            try:
                size = float(size_s)
            except ValueError:
                size = 12.0
        elif name.endswith('_slant'):
            slant = line[i + 1 :].strip()
        if settings_name is None and name.endswith(
            ('_family', '_slant', '_weight', '_size')):
            settings_name = name.rsplit('_', 1)[0]
    return settings_name, family, weight == 'bold', slant in ('slant', 'italic'), size
</t>
<t tx="ekr.20180121045646.1">@beautify

def make_tips(c: Cmdr) -&gt; None:
    """
    A script to make entries in the global tips array.

    Each printed entry has the form:

        UserTip(
            n=anInt
            tags=[list of tags],
            title=aString,
            text='''

            aString

            ''')

    After running this script, copy the result from the console to the
    &lt;define tips&gt; section of leoTips.py.
    """
    import requests
    url = 'https://api.github.com/repos/leo-editor/leo-editor/issues?labels=Tip&amp;state='

    def get_tips(data: Any) -&gt; list[UserTip]:
        """get_tips - get tips from GitHub issues
        :param dict data: GitHub API issues list
        :return: list of Tips
        """
        tips = []
        for issue in data:
            body, n, title = issue['body'], issue['number'], issue['title']
            lines = g.splitLines(body)
            for i, s in enumerate(lines):
                if s.strip().lower().startswith('tags:'):
                    lines = lines[:i] + lines[i + 1 :]
                    text = ''.join(lines).strip()
                    s = s.strip().rstrip('.').strip()
                    s = s[len('tags:') :].strip()
                    tags = [z.strip() for z in s.split(',')]
                    break
            else:
                tags = []
                text = body.strip()
            tips.append(UserTip(n=n, tags=tags, text=text.strip(), title=title.strip(),))
        return tips

    g.cls()
    template = '''\
UserTip(
    n=%s,
    tags=%s,
    title="%s",
    text="""\

%s

"""),
'''
    template = textwrap.dedent(template)
    for kind in ('open',):  # 'closed':
        data = requests.get(url + kind, timeout=2.0).json()
        for tip in get_tips(data):
            tags = [f"{z}" for z in tip.tags or []]
            title = tip.title.lstrip('Tip:').lstrip('tip:').strip()
            print(template % (tip.n, tags, title, tip.text))
</t>
<t tx="ekr.20180121135120.1">def setUserSetting(self, setting: str, value: str) -&gt; None:
    """
    Find and set the indicated setting, either in the local file or in
    myLeoSettings.leo.
    """
    c = self.c
    fn = g.shortFileName(c.fileName())
    p = self.findSettingsPosition(setting)
    if not p:
        c = c.openMyLeoSettings()
        if not c:
            return
        fn = 'myLeoSettings.leo'
        p = c.config.findSettingsPosition(setting)
    if not p:
        root = c.config.settingsRoot()
        if not root:
            return
        fn = 'leoSettings.leo'
        p = c.config.findSettingsPosition(setting)
        if not p:
            p = root.insertAsLastChild()
    h = setting
    i = h.find('=')
    if i &gt; -1:
        h = h[:i].strip()
    p.h = f"{h} = {value}"
    print(f"Updated `{setting}` in {fn}")  # #2390.
    #
    # Delay the second redraw until idle time.
    c.setChanged()
    p.setDirty()
    c.redraw_later()
</t>
<t tx="ekr.20180123062833.1">def promote(self) -&gt; None:
    """A low-level promote helper."""
    p = self  # Do NOT copy the position.
    parent_v = p._parentVnode()
    children = p.v.children
    # Add the children to parent_v's children.
    n = p.childIndex() + 1
    z = parent_v.children[:]
    parent_v.children = z[:n]
    parent_v.children.extend(children)
    parent_v.children.extend(z[n:])
    # Remove v's children.
    p.v.children = []
    # Adjust the parent links in the moved children.
    # There is no need to adjust descendant links.
    for child in children:
        child.parents.remove(p.v)
        child.parents.append(parent_v)
</t>
<t tx="ekr.20180126043719.3">def get_one_issue(self, label: str, state: Any, limit: int = 20) -&gt; None:
    """Create a list of issues with the given label."""
    try:
        import requests
    except Exception:
        g.trace('requests not found: `pip install requests`')
        return
    root = self.root.insertAsLastChild()
    page, total = 1, 0
    page_url = self.base_url + '?labels=%s&amp;state=%s&amp;page=%s'
    while True:
        url = page_url % (label, state, page)
        r = requests.get(url, timeout=2.0)
        try:
            done, n = self.get_one_page(label, page, r, root)
            # Do not remove this trace. It's reassuring.
            g.trace(f"done: {done:5} page: {page:3} found: {n:3} label: {label}")
        except AttributeError:
            g.trace('Possible rate limit')
            self.print_header(r)
            g.es_exception()
            break
        total += n
        if done:
            break
        page += 1
        if page &gt; limit:
            g.trace('too many pages')
            break
    state = state.capitalize()
    if self.milestone:
        root.h = f"{total} {state} {label} issues for milestone {self.milestone}"
    else:
        root.h = f"{total} {state} {label} issues"
</t>
<t tx="ekr.20180211170333.2">def diff_list_of_files(self, aList: list[str], visible: bool = True) -&gt; None:
    """
    The main entry point for scripts.
    """
    c = self.c
    u = c.undoer
    if len(aList) &lt; 2:
        g.trace('Not enough files in', repr(aList))
        return
    undoType = 'diff-files'
    c.selectPosition(c.lastTopLevel())
    undoData = u.beforeInsertNode(c.p)
    self.root = self.create_root(aList)
    self.visible = visible
    while len(aList) &gt; 1:
        path1 = aList[0]
        aList = aList[1:]
        for path2 in aList:
            self.diff_two_files(path1, path2)  # adds to self.root
    u.afterInsertNode(self.root, undoType, undoData)
    self.finish()
</t>
<t tx="ekr.20180213104627.1">def diff_leo_files_helper(event: Event, title: str, visible: bool) -&gt; None:
    """Prompt for a list of Leo files to open."""
    c = event and event.get('c')
    if not c:
        return
    types = [
        ("Leo files", "*.leo *.leojs *.db"),
        ("All files", "*"),
    ]
    paths = g.app.gui.runOpenFileDialog(c,
        title=title,
        filetypes=types,
        defaultextension=".leo",
        multiple=True,
    )
    if not paths:
        return
    if len(paths) == 1:
        # Prompt for another file.
        paths2 = g.app.gui.runOpenFileDialog(c,
            title=title,
            filetypes=types,
            defaultextension=".leo",
            multiple=True,
        )
        if not paths2:
            return
        paths.extend(paths2)
    c.bringToFront()
    assert len(paths) &gt; 1
    CompareLeoOutlines(c).diff_list_of_files(paths, visible=visible)
</t>
<t tx="ekr.20180225010644.1">@nobeautify</t>
<t tx="ekr.20180225010707.1"></t>
<t tx="ekr.20180225010743.1">@nosearch</t>
<t tx="ekr.20180225010850.1"></t>
<t tx="ekr.20180225010913.1"></t>
<t tx="ekr.20180318120148.1">def computeThemeDirectories(self) -&gt; list[str]:
    """
    Return a list of *existing* directories that might contain theme .leo files.
    """
    join = g.finalize_join
    home = g.app.homeDir
    leo = join(g.app.loadDir, '..')
    table = [
        home,
        join(home, 'themes'),
        join(home, '.leo'),
        join(home, '.leo', 'themes'),
        join(leo, 'themes'),
    ]
    # Make sure home has normalized slashes.
    return [g.os_path_normslashes(z) for z in table if g.os_path_exists(z)]
</t>
<t tx="ekr.20180318133620.1">def computeThemeFilePath(self) -&gt; str:
    """
    Return the absolute path to the theme .leo file, resolved using the search order for themes.

    1. Use the --theme command-line option if it exists.

    2. Otherwise, preload the first .leo file.
       Load the file given by @string theme-name setting.

    3. Finally, look up the @string theme-name in the already-loaded, myLeoSettings.leo.
       Load the file if setting exists.  Otherwise return None.
    """
    trace = 'themes' in g.app.db
    lm = self
    resolve = self.resolve_theme_path
    #
    # Step 1: Use the --theme command-line options if it exists
    path = resolve(lm.options.get('theme_path'), tag='--theme')
    if path:
        # Caller (LM.readGlobalSettingsFiles) sets lm.theme_path
        if trace:
            g.trace('--theme:', path)
        return path
    #
    # Step 2: look for the @string theme-name setting in the first loaded file.
    path = lm.files[0] if lm.files else ''
    if path and g.os_path_exists(path):
        # Tricky: we must call lm.computeLocalSettings *here*.
        theme_c = lm.openSettingsFile(path)
        if theme_c:
            settings_d, junk_shortcuts_d = lm.computeLocalSettings(
                c=theme_c,
                settings_d=lm.globalSettingsDict,
                bindings_d=lm.globalBindingsDict,
                localFlag=False,
            )
            setting = settings_d.get_string_setting('theme-name')
            if setting:
                tag = theme_c.shortFileName()
                path = resolve(setting, tag=tag)
                if path:
                    # Caller (LM.readGlobalSettingsFiles) sets lm.theme_path
                    if trace:
                        g.trace("First loaded file", theme_c.shortFileName(), path)
                    return path
    #
    # Step 3: use the @string theme-name setting in myLeoSettings.leo.
    # Note: the setting should *never* appear in leoSettings.leo!
    setting = lm.globalSettingsDict.get_string_setting('theme-name')
    tag = 'myLeoSettings.leo'
    path = resolve(setting, tag=tag)
    if trace:
        g.trace("myLeoSettings.leo", path)
    return path
</t>
<t tx="ekr.20180321124503.1">def resolve_theme_path(self, fn: str, tag: str) -&gt; Optional[str]:
    """Search theme directories for the given .leo file."""
    if not fn:
        return None
    # Make --theme and theme-name setting do the same thing for "None"
    if fn.lower().strip() == 'none':
        return LoadManager.LM_NOTHEME_FLAG
    if not fn.endswith('.leo'):
        fn += '.leo'
    for directory in self.computeThemeDirectories():
        path = g.os_path_join(directory, fn)  # Normalizes slashes, etc.
        if g.os_path_exists(path):
            return path
    print(f"theme .leo file not found: {fn}")
    return None
</t>
<t tx="ekr.20180324065741.1">"""Copy the selected text to the next node."""
w = c.frame.body.wrapper
s = w.getSelectedText()
if s.strip():
    w.deleteTextSelection()
    c.p.b = w.getAllText()
    w.setInsertPoint(0)
    p = c.insertHeadline()
    c.selectPosition(p)
    p.b = s
    c.editHeadline()
else:
    g.es_print('no text selected')
</t>
<t tx="ekr.20180325024334.1">def get_all_issues(self, label_list: list, root: Position, state: Any, limit: int = 100) -&gt; None:
    """Get all issues for the base url."""
    try:
        import requests
    except Exception:
        g.trace('requests not found: `pip install requests`')
        return
    label = None
    assert state in ('open', 'closed')
    page_url = self.base_url + '?&amp;state=%s&amp;page=%s'
    page, total = 1, 0
    while True:
        url = page_url % (state, page)
        r = requests.get(url, timeout=2.0)
        try:
            done, n = self.get_one_page(label, page, r, root)
            # Do not remove this trace. It's reassuring.
            g.trace(f"done: {done:5} page: {page:3} found: {n} label: {label}")
        except AttributeError:
            g.trace('Possible rate limit')
            self.print_header(r)
            g.es_exception()
            break
        total += n
        if done:
            break
        page += 1
        if page &gt; limit:
            g.trace('too many pages')
            break
</t>
<t tx="ekr.20180424123010.1">def linkChildrenToParents(self, p: Position) -&gt; None:
    """
    Populate the parent links in all children of p.
    """
    for child in p.children():
        child.v.parents.append(p.v)
        self.linkChildrenToParents(child)
</t>
<t tx="ekr.20180504191650.36"></t>
<t tx="ekr.20180504191650.42"></t>
<t tx="ekr.20180504191650.68"></t>
<t tx="ekr.20180504192522.1"></t>
<t tx="ekr.20180506064102.10">def diff_two_branches(self, branch1: str, branch2: str, fn: str) -&gt; None:
    """Create an outline describing the git diffs for fn."""
    c = self.c
    u, undoType = c.undoer, 'diff-two-branches'
    if not self.get_parent_of_git_directory():
        return
    c.selectPosition(c.lastTopLevel())
    undoData = u.beforeInsertNode(c.p)
    self.root = p = c.lastTopLevel().insertAfter()
    p.h = f"git-diff-branches {branch1} {branch2}"
    s1 = self.get_file_from_branch(branch1, fn)
    s2 = self.get_file_from_branch(branch2, fn)
    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    diff_list = list(difflib.unified_diff(lines1, lines2, branch1, branch2,))
    diff_list.insert(0, '@ignore\n@nosearch\n@language patch\n')
    self.file_node = self.create_file_node(diff_list, fn)
    if c.looksLikeDerivedFile(fn):
        c1 = self.make_at_file_outline(fn, s1, branch1)
        c2 = self.make_at_file_outline(fn, s2, branch2)
    else:
        root = self.find_file(fn)
        if root:
            c1 = self.make_at_clean_outline(fn, root, s1, branch1)
            c2 = self.make_at_clean_outline(fn, root, s2, branch2)
        else:
            c1 = c2 = None
    if c1 and c2:
        self.make_diff_outlines(c1, c2, fn)
        self.file_node.b = f"{self.file_node.b.rstrip()}\n@language {c2.target_language}\n"
    u.afterInsertNode(self.root, undoType, undoData)
    self.finish()
</t>
<t tx="ekr.20180506064102.11">def get_file_from_branch(self, branch: str, fn: str) -&gt; str:
    """Get the file from the head of the given branch."""
    # #2143
    directory = self.get_parent_of_git_directory()
    if not directory:
        return ''
    command = f"git show {branch}:{fn}"
    lines = g.execGitCommand(command, directory)
    s = ''.join(lines)
    return g.toUnicode(s).replace('\r', '')
</t>
<t tx="ekr.20180507212821.1">def diff_two_revs(self, rev1: str = 'HEAD', rev2: str = '') -&gt; None:
    """
    Create an outline describing the git diffs for all files changed
    between rev1 and rev2.
    """
    c, u = self.c, self.c.undoer

    if not self.get_parent_of_git_directory():
        return
    # Get list of changed files.
    files = self.get_files(rev1, rev2)
    n = len(files)
    message = f"diffing {n} file{g.plural(n)}"
    if not g.unitTesting:
        if n &gt; 5:
            message += ". This may take awhile..."
        g.es_print(message)
    c.selectPosition(c.lastTopLevel())  # pre-select to help undo-insert

    # Create the root node.
    undoData = u.beforeInsertNode(c.p)  # c.p is subject of 'insertAfter'
    self.root = c.lastTopLevel().insertAfter()
    self.root.h = f"git diff revs: {rev1} {rev2}"
    self.root.b = '@ignore\n@nosearch\n'

    # Create diffs of all files.
    for fn in files:
        self.diff_file(fn=fn, rev1=rev1, rev2=rev2)

    u.afterInsertNode(self.root, 'diff-two-revs', undoData)
    self.finish()
</t>
<t tx="ekr.20180510095544.1"></t>
<t tx="ekr.20180510095801.1"></t>
<t tx="ekr.20180517041303.1">@g.command('show-file-line')
def show_file_line(event: Event) -&gt; None:
    """
    Prints the external file line number that corresponds to
    the line the cursor is relatively positioned in Leo's body.
    """
    c = event.get('c')
    if not c:
        return
    w = c.frame.body.wrapper
    if not w:
        return
    n0 = GoToCommands(c).find_node_start(p=c.p)
    if n0 is None:
        g.es_print('Line not found')
        return
    i = w.getInsertPoint()
    s = w.getAllText()
    row, col = g.convertPythonIndexToRowCol(s, i)
    g.es_print('line', 1 + n0 + row)
</t>
<t tx="ekr.20180524100258.1">def add_class_names(self, p: Position) -&gt; None:
    """Add class names to headlines for all descendant nodes."""
    # pylint: disable=no-else-continue
    after, class_name = None, None
    class_paren_pattern = re.compile(r'(.*)\(.*\)\.(.*)')
    paren_pattern = re.compile(r'(.*)\(.*\.py\)')
    for p in p.self_and_subtree(copy=False):
        # Part 1: update the status.
        m = self.file_pattern.match(p.h)
        if m:
            # prefix = m.group(1)
            # fn = g.shortFileName(p.h[len(prefix):].strip())
            after, class_name = None, None
            continue
        elif p.h.startswith('@path '):
            after, class_name = None, None
        elif p.h.startswith('class '):
            class_name = p.h[5:].strip()
            if class_name:
                after = p.nodeAfterTree()
                continue
        elif p == after:
            after, class_name = None, None
        # Part 2: update the headline.
        if class_name:
            if p.h.startswith(class_name):
                m = class_paren_pattern.match(p.h)
                if m:
                    p.h = f"{m.group(1)}.{m.group(2)}".rstrip()
            else:
                p.h = f"{class_name}.{p.h}"
        else:
            m = paren_pattern.match(p.h)
            if m:
                p.h = m.group(1).rstrip()
        # elif fn:
            # tag = ' (%s)' % fn
            # if not p.h.endswith(tag):
                # p.h += tag
</t>
<t tx="ekr.20180602062323.7"># #1510: https://en.wikipedia.org/wiki/Valid_characters_in_XML.
translate_dict = {z: None for z in range(20) if chr(z) not in '\t\r\n'}

def readWithElementTree(self, path: str, s_or_b: Union[str, bytes]) -&gt; tuple[VNode, Any]:

    contents = g.toUnicode(s_or_b)
    table = contents.maketrans(self.translate_dict)  # type:ignore #1510.
    contents = contents.translate(table)  # #1036, #1046.
    try:
        xroot = ElementTree.fromstring(contents)
    except Exception as e:
        # #970: Report failure here.
        if path:
            message = f"bad .leo file: {g.shortFileName(path)}"
        else:
            message = 'The clipboard is not a valid .leo file'
        g.es_print('\n' + message, color='red')
        g.es_print(g.toUnicode(e))
        print('')
        return None, None  # #1510: Return a tuple.
    g_element = xroot.find('globals')
    v_elements = xroot.find('vnodes')
    t_elements = xroot.find('tnodes')
    gnx2body, gnx2ua = self.scanTnodes(t_elements)
    hidden_v = self.scanVnodes(gnx2body, self.gnx2vnode, gnx2ua, v_elements)
    self.updateBodies(gnx2body, self.gnx2vnode)
    self.handleBits()
    return hidden_v, g_element
</t>
<t tx="ekr.20180602062323.8">def scanTnodes(self, t_elements: Any) -&gt; tuple[dict[str, str], dict[str, Any]]:

    gnx2body: dict[str, str] = {}
    gnx2ua: dict[str, dict] = defaultdict(dict)
    for e in t_elements:
        # First, find the gnx.
        gnx = e.attrib['tx']
        gnx2body[gnx] = e.text or ''
        # Next, scan for uA's for this gnx.
        for key, val in e.attrib.items():
            if key != 'tx':
                s: Optional[str] = self.resolveUa(key, val)
                if s:
                    gnx2ua[gnx][key] = s
    return gnx2body, gnx2ua
</t>
<t tx="ekr.20180602062323.9">def scanVnodes(self,
    gnx2body: dict[str, str],
    gnx2vnode: dict[str, VNode],
    gnx2ua: dict[str, Any],
    v_elements: Any,
) -&gt; VNode:

    c, fc = self.c, self.c.fileCommands
    &lt;&lt; define v_element_visitor &gt;&gt;
    #
    # Create the hidden root vnode.

    gnx = 'hidden-root-vnode-gnx'
    hidden_v = leoNodes.VNode(context=c, gnx=gnx)
    hidden_v._headString = '&lt;hidden root vnode&gt;'
    gnx2vnode[gnx] = hidden_v
    #
    # Traverse the tree of v elements.
    v_element_visitor(v_elements, hidden_v)
    return hidden_v
</t>
<t tx="ekr.20180602103135.19">m = self.node_start_pat.match(line)
if m:
    in_doc = False
    gnx, head = m.group(2), m.group(5)
    # m.group(3) is the level number, m.group(4) is the number of stars.
    level = int(m.group(3)) if m.group(3) else 1 + len(m.group(4))
    v = gnx2vnode.get(gnx)
    #
    # Case 1: The root @file node. Don't change the headline.
    if not root_seen and not v and not g.unitTesting:
        # Don't warn about a gnx mismatch in the root.
        root_gnx_adjusted = True  # pragma: no cover
    if not root_seen:
        # Fix #1064: The node represents the root, regardless of the gnx!
        root_seen = True
        clone_v = None
        gnx2body[gnx] = body = []
        # This case can happen, but not in unit tests.
        if not v:  # pragma: no cover
            # Fix #1064.
            v = root_v
            # This message is annoying when using git-diff.
                # if gnx != root_gnx:
                    # g.es_print("using gnx from external file: %s" % (v.h), color='blue')
            gnx2vnode[gnx] = v
            v.fileIndex = gnx
        v.children = []
        continue
    #
    # Case 2: We are scanning the descendants of a clone.
    parent_v, clone_v = level_stack[level - 2]
    if v and clone_v:
        # The last version of the body and headline wins..
        gnx2body[gnx] = body = []
        v._headString = head
        # Update the level_stack.
        level_stack = level_stack[: level - 1]
        level_stack.append((v, clone_v))
        # Always clear the children!
        v.children = []
        parent_v.children.append(v)
        continue
    #
    # Case 3: we are not already scanning the descendants of a clone.
    if v:
        # The *start* of a clone tree. Reset the children.
        clone_v = v
        v.children = []
    else:
        # Make a new vnode.
        v = leoNodes.VNode(context=context, gnx=gnx)
    #
    # The last version of the body and headline wins.
    gnx2vnode[gnx] = v
    gnx2body[gnx] = body = []
    v._headString = head
    #
    # Update the stack.
    level_stack = level_stack[: level - 1]
    level_stack.append((v, clone_v))
    #
    # Update the links.
    assert v != root_v
    parent_v.children.append(v)
    v.parents.append(parent_v)
    continue
</t>
<t tx="ekr.20180605062300.1">def scanGlobals(self, g_element: Any) -&gt; None:
    """Get global data from the cache, with reasonable defaults."""
    c = self.c
    d = self.getGlobalData()
    windowSize = g.app.loadManager.options.get('windowSize')
    windowSpot = g.app.loadManager.options.get('windowSpot')
    if windowSize is not None:
        h, w = windowSize  # checked in LM.scanOption.
    else:
        w, h = d.get('width'), d.get('height')
    if windowSpot is None:
        x, y = d.get('left'), d.get('top')
    else:
        y, x = windowSpot  # #1263: (top, left)
    if 'size' in g.app.debug:
        g.trace(w, h, x, y, c.shortFileName())
    # c.frame may be a NullFrame.
    c.frame.setTopGeometry(w, h, x, y)
    r1, r2 = d.get('r1'), d.get('r2')
    c.frame.resizePanesToRatio(r1, r2)
    frameFactory = getattr(g.app.gui, 'frameFactory', None)
    if not frameFactory:
        return
    assert frameFactory is not None
    mf = frameFactory.masterFrame
    if g.app.start_minimized:
        mf.showMinimized()
    elif g.app.start_maximized:
        # #1189: fast.scanGlobals calls showMaximized later.
        mf.showMaximized()
    elif g.app.start_fullscreen:
        mf.showFullScreen()
    else:
        mf.show()
</t>
<t tx="ekr.20180605075042.1">v = leoNodes.VNode(context=c, gnx=gnx)
gnx2vnode[gnx] = v
parent_v.children.append(v)
v.parents.append(parent_v)
body = g.toUnicode(gnx2body.get(gnx) or '')
assert isinstance(body, str), body.__class__.__name__
v._bodyString = body
v._headString = 'PLACE HOLDER'
</t>
<t tx="ekr.20180605075113.1"># FastRead.nativeVnodeAttributes defines the native attributes of &lt;v&gt; elements.
d = e.attrib
s = d.get('descendentTnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentTnodeUaDictList.append(aDict)
s = d.get('descendentVnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentVnodeUaDictList.append((v, aDict),)
#
# Handle vnode uA's
uaDict = gnx2ua[gnx]  # A defaultdict(dict)
for key, val in d.items():
    if key not in self.nativeVnodeAttributes:
        uaDict[key] = self.resolveUa(key, val)
if uaDict:
    v.unknownAttributes = uaDict
</t>
<t tx="ekr.20180605102822.1">def v_element_visitor(parent_e: Any, parent_v: VNode) -&gt; None:
    """Visit the given element, creating or updating the parent vnode."""
    for e in parent_e:
        assert e.tag in ('v', 'vh'), e.tag
        if e.tag == 'vh':
            parent_v._headString = g.toUnicode(e.text or '')
            continue
        # #1581: Attempt to handle old Leo outlines.
        try:
            gnx = e.attrib['t']
            v = gnx2vnode.get(gnx)
        except KeyError:
            # g.trace('no "t" attrib')
            gnx = None
            v = None
        if v:
            # A clone
            parent_v.children.append(v)
            v.parents.append(parent_v)
            # The body overrides any previous body text.
            body = g.toUnicode(gnx2body.get(gnx) or '')
            assert isinstance(body, str), body.__class__.__name__
            v._bodyString = body
        else:
            &lt;&lt; Make a new vnode, linked to the parent &gt;&gt;
            &lt;&lt; handle all other v attributes &gt;&gt;
            # Handle all inner elements.
            v_element_visitor(e, v)

</t>
<t tx="ekr.20180606035619.1"></t>
<t tx="ekr.20180606041211.1">def resolveUa(self, attr: Any, val: Any, kind: str = None) -&gt; Any:  # Kind is for unit testing.
    """Parse an unknown attribute in a &lt;v&gt; or &lt;t&gt; element."""
    try:
        val = g.toEncodedString(val)
    except Exception:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()
        return ''
    # Leave string attributes starting with 'str_' alone.
    if attr.startswith('str_'):
        if isinstance(val, (str, bytes)):
            return g.toUnicode(val)
    # Support JSON encoded attributes
    if attr.startswith('json_'):
        if isinstance(val, (str, bytes)):
            try:
                return json.loads(g.toUnicode(val))
            except json.JSONDecodeError:
                # fall back to standard handling
                g.trace(f"attribute not JSON encoded {attr}={g.toUnicode(val)}")
    try:
        # Throws a TypeError if val is not a hex string.
        binString = binascii.unhexlify(val)
    except Exception:
        # Assume that Leo 4.1 or above wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw', f"unit test failed: kind={kind}"
        else:
            g.trace(f"can not unhexlify {attr}={val}")
        return ''
    try:
        # No change needed to support protocols.
        return pickle.loads(binString)
    except Exception:
        try:
            val2 = pickle.loads(binString, encoding='bytes')
            return g.toUnicode(val2)
        except Exception:
            g.trace(f"can not unpickle {attr}={val}")
            return ''
</t>
<t tx="ekr.20180624125321.1">def handleBits(self) -&gt; None:
    """Restore the expanded and marked bits from c.db."""
    c, fc = self.c, self.c.fileCommands
    expanded = c.db.get('expanded')
    marked = c.db.get('marked')
    expanded = expanded.split(',') if expanded else []
    marked = marked.split(',') if marked else []
    fc.descendentExpandedList = expanded
    fc.descendentMarksList = marked
</t>
<t tx="ekr.20180708060437.1">def getGlobalData(self) -&gt; dict[str, Any]:
    """Return a dict containing all global data."""
    c = self.c
    try:
        window_pos = c.db.get('window_position')
        r1 = float(c.db.get('body_outline_ratio', '0.5'))
        r2 = float(c.db.get('body_secondary_ratio', '0.5'))
        top, left, height, width = window_pos
        return {
            'top': int(top),
            'left': int(left),
            'height': int(height),
            'width': int(width),
            'r1': r1,
            'r2': r2,
        }
    except Exception:
        pass
    # Use reasonable defaults.
    return {
        'top': 50, 'left': 50,
        'height': 500, 'width': 800,
        'r1': 0.5, 'r2': 0.5,
    }
</t>
<t tx="ekr.20180708145905.1">@language rest
@wrap

This is the theory of operation document for py2cs.py. The most interesting aspect of this script is the TokenSync class. This class provides a reliable way of associating tokenizer tokens with ast nodes.

@others
</t>
<t tx="ekr.20180708145905.6">
### Using the TokenSync class

The present code is driven by ast trees, but each visitor of the CoffeeScriptTraverser class takes care to preserve **otherwise-ignored tokens**. These are tokens that would otherwise be ignored: namely blank lines and comments, both entire-line comments and trailing comments.

The visitor for each statement intersperses otherwise ignored tokens using calls to the TokenSync class.  The simplest cases are like this:

    def do_Break(self, node):
        head = self.leading_string(node)
        tail = self.trailing_comment(node)
        return head + self.indent('break') + tail

The leading_string and trailing_comment methods simply redirect to the corresponding methods in the TokenSync class.  Saves a bit of typing. Compound statements are a bit more bother, but not overly so. For example:

    def do_If(self, node):

        result = self.leading_lines(node)
        tail = self.trailing_comment(node)
        s = 'if %s:%s' % (self.visit(node.test), tail)
        result.append(self.indent(s))
        for z in node.body:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
        if node.orelse:
            tail = self.tail_after_body(node.body, node.orelse, result)
            result.append(self.indent('else:' + tail))
            for z in node.orelse:
                self.level += 1
                result.append(self.visit(z))
                self.level -= 1
        return ''.join(result)

The line:

        tail = self.tail_after_body(node.body, node.orelse, result)

is a hack needed to compensate for the lack of an actual ast.Else node.
</t>
<t tx="ekr.20180708145905.7">
### Summary

The TokenSync class is, a new, elegant, unexpected and happy development. It is a relatively easy-to-use helper that allows parser-based code to preserve data that is not easily accessible in parse trees.

The TokenSync class avoids [problems with the col_offset field](
http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) in ast nodes. The TokenSync class depends only on the ast.lineno field and the tokenize module. We can expect it to be rock solid.

Edward K. Ream
February 20 to 25, 2016



</t>
<t tx="ekr.20180708152000.1">
### The problem

The initial version of py2cs.py (the script) used only tokens. This solved all token-related problems, but made parsing difficult. Alas, it is [difficult](http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) to associate tokens with ast nodes.

The script needs the following token-related data:

- The **ignored lines** (comment lines and blank lines) that precede any statement.

- The **trailing comment** strings that might follow any line.

- Optionally, the **line breaks** occurring within lines. At present, this script does not preserve such breaks, and it's probably not worth doing. Indeed, automatically breaking long lines seems more useful, especially considering that coffeescript lines may be substantially shorter than the corresponding python lines.

- The **exact spelling** of all strings.

The [ast_utils module](
https://bitbucket.org/plas/thonny/src/3b71fda7ac0b66d5c475f7a668ffbdc7ae48c2b5/thonny/ast_utils.py?at=master) purports to solve this problem with convoluted adjustments to the col_offset field. This approach is subject to subtle Python bugs, and subtle differences between Python 2 and Python 3. There is a better way...
</t>
<t tx="ekr.20180708152018.1">
### Design

The main idea is to use *only* the ast.lineno fields and the tokenizer module to recreate token data. The design assumes only that both the ast.lineno field and Python's tokenizer module are solid. This is a much more reasonable assumption than assuming that the col_offset field always tells the truth. In short, this design *ignores* the ast.col_offset field.

At startup, the TokenSync ctor assigns all the incoming tokens to various lists.  These lists are indexed by lineno:

    ts.line_tokens[i]: all the tokens on line i
    ts.string_tokens[i]: all string tokens on line i
    st.ignored_lines: the blank or comment line on line i

It is very easy to create these lists. The code does not depend on any arcane details.

#### Recovering the exact spelling of stings.

ts.synch_string returns the *next* string on the line. Here it is, stripped of defensive code:

    def sync_string(self, node):
        '''Return the spelling of the string at the given node.'''
        tokens = self.string_tokens[node.lineno-1]
        token = tokens.pop(0)
        self.string_tokens[node.lineno-1] = tokens
        return self.token_val(token)

Stripped of defensive code, the do_Str visitor is just:

    def do_Str(self, node):
        '''A string constant, including docstrings.'''
        return self.sync_string(node)

#### Recovering otherwise ignored nodes

**ts.leading_lines(node)** returns a list of otherwise ignored lines that
precede the node's line that have not already been returned.
**ts.leading_string(node)** is a convenience method that returns ''.join(ts.leading_lines(node)). The visitors of the CoffeeScriptTraverser class show how to use these methods.
</t>
<t tx="ekr.20180709064515.1">def _deleteAllChildren(self) -&gt; None:
    """
    Delete all children of self.

    This is a low-level method, used by the read code.
    It is not intended as a general replacement for p.doDelete().
    """
    v = self
    for v2 in v.children:
        try:
            v2.parents.remove(v)
        except ValueError:  # pragma: no cover
            g.internalError(f"{v} not in parents of {v2}")
            g.trace('v2.parents:')
            g.printObj(v2.parents)
    v.children = []
</t>
<t tx="ekr.20180709175203.1">def _addCopiedLink(self, childIndex: int, parent_v: VNode) -&gt; None:
    """Adjust links after adding a link to v."""
    v = self
    v.context.frame.tree.generation += 1
    parent_v.childrenModified()  # For a plugin.
    # Update parent_v.children &amp; v.parents.
    parent_v.children.insert(childIndex, v)
    v.parents.append(parent_v)
    # Set zodb changed flags.
    v._p_changed = True
    parent_v._p_changed = True
</t>
<t tx="ekr.20180709180140.1">def _linkCopiedAsNthChild(self, parent: Position, n: int) -&gt; None:
    """Link a copied self as the n'th child of the parent."""
    p = self
    parent_v = parent.v
    p.stack = parent.stack[:]
    p.stack.append((parent_v, parent._childIndex),)
    p._childIndex = n
    child = p.v
    child._addCopiedLink(n, parent_v)
</t>
<t tx="ekr.20180709181718.1">def _linkCopiedAfter(self, p_after: Position) -&gt; None:
    """Link self, a newly copied tree, after p_after."""
    p = self
    parent_v = p_after._parentVnode()
    p.stack = p_after.stack[:]
    p._childIndex = p_after._childIndex + 1
    child = p.v
    n = p_after._childIndex + 1
    child._addCopiedLink(n, parent_v)
</t>
<t tx="ekr.20180709205603.1">def getLeoOutlineFromClipboard(self, s: str) -&gt; Optional[Position]:
    """Read a Leo outline from string s in clipboard format."""
    c = self.c
    current = c.p
    if not current:
        g.trace('no c.p')
        return None
    self.initReadIvars()

    # Save and clear gnxDict.
    oldGnxDict = self.gnxDict
    self.gnxDict = {}
    if s.lstrip().startswith("{"):
        # Maybe JSON
        hidden_v = FastRead(c, self.gnxDict).readFileFromJsonClipboard(s)
    else:
        # This encoding must match the encoding used in outline_to_clipboard_string.
        s_bytes = g.toEncodedString(s, self.leo_file_encoding, reportErrors=True)
        hidden_v = FastRead(c, self.gnxDict).readFileFromClipboard(s_bytes)
    v = hidden_v.children[0]
    v.parents = []
    if not v:
        g.es("the clipboard is not valid ", color="blue")
        return None

    # Create the position.
    p = leoNodes.Position(v)

    # Do *not* adjust links when linking v.
    if current.hasChildren() and current.isExpanded():
        p._linkCopiedAsNthChild(current, 0)
    else:
        p._linkCopiedAfter(current)
    assert not p.isCloned(), g.objToString(p.v.parents)
    self.gnxDict = oldGnxDict
    self.reassignAllIndices(p)
    c.selectPosition(p)
    self.initReadIvars()
    return p

getLeoOutline = getLeoOutlineFromClipboard  # for compatibility
</t>
<t tx="ekr.20180709205640.1">def getLeoOutlineFromClipboardRetainingClones(self, s: str) -&gt; Optional[Position]:
    """Read a Leo outline from string s in clipboard format."""
    c = self.c
    current = c.p
    if not current:
        g.trace('no c.p')
        return None
    self.initReadIvars()

    # All pasted nodes should already have unique gnx's.
    ni = g.app.nodeIndices
    for v in c.all_unique_nodes():
        ni.check_gnx(c, v.fileIndex, v)

    if s.lstrip().startswith("{"):
        # Maybe JSON
        hidden_v = FastRead(c, self.gnxDict).readFileFromJsonClipboard(s)
    else:
        # This encoding must match the encoding used in outline_to_clipboard_string.
        s_bytes = g.toEncodedString(s, self.leo_file_encoding, reportErrors=True)
        hidden_v = FastRead(c, self.gnxDict).readFileFromClipboard(s_bytes)

    v = hidden_v.children[0]
    v.parents.remove(hidden_v)
    if not v:
        g.es("the clipboard is not valid ", color="blue")
        return None

    # Create the position.
    p = leoNodes.Position(v)

    # Do *not* adjust links when linking v.
    if current.hasChildren() and current.isExpanded():
        if not self.checkPaste(current, p):
            return None
        p._linkCopiedAsNthChild(current, 0)
    else:
        if not self.checkPaste(current.parent(), p):
            return None
        p._linkCopiedAfter(current)

    # Fix #862: paste-retaining-clones can corrupt the outline.
    self.linkChildrenToParents(p)
    errors = c.checkOutline()
    if errors &gt; 0:
        return None
    c.selectPosition(p)
    self.initReadIvars()
    return p
</t>
<t tx="ekr.20180816105258.1">g.cls()
import os
import leo.commands.editFileCommands as efc
path = g.finalize_join(g.app.loadDir, '..', '..')
print(f"os.chdir({path})")
os.chdir(path)

# Any revspec is valid as an argument to the "branch1" and "branch2" args.
# See https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection

efc.GitDiffController(c).diff_two_branches(
    branch1='devel', # old branch/rev
    branch2='ekr-3435-undo-for-refresh-from-disk', # new branch/rev
    fn='leo/core/leoGlobals.py',  # Don't use back slashes.
)
</t>
<t tx="ekr.20180824065751.1">print(p.gnx)</t>
<t tx="ekr.20181030041436.1"></t>
<t tx="ekr.20190118150859.10">def addNewEditor(self, name: str) -&gt; tuple[LeoQtFrame, Wrapper]:
    """Create a new body editor."""
    c, p = self.leo_c, self.leo_c.p
    body = c.frame.body
    assert isinstance(body, LeoQtBody), repr(body)
    # Step 1: create the editor.
    parent_frame = c.frame.top.leo_body_inner_frame
    widget = qt_text.LeoQTextBrowser(parent_frame, c, self)
    widget.setObjectName('richTextEdit')  # Will be changed later.
    wrapper = qt_text.QTextEditWrapper(widget, name='body', c=c)
    self.packLabel(widget)
    # Step 2: inject ivars, set bindings, etc.
    inner_frame = c.frame.top.leo_body_inner_frame  # Inject ivars *here*.
    body.injectIvars(inner_frame, name, p, wrapper)
    body.updateInjectedIvars(widget, p)
    wrapper.setAllText(p.b)
    wrapper.see(0)
    c.k.completeAllBindingsForWidget(wrapper)
    if isinstance(widget, QtWidgets.QTextEdit):
        colorizer = leoColorizer.make_colorizer(c, widget)
        colorizer.highlighter.setDocument(widget.document())
    else:
        # Scintilla only.
        body.recolorWidget(p, wrapper)
    return parent_frame, wrapper
</t>
<t tx="ekr.20190201104956.1">def readOneAtAsisNode(self, p: Position) -&gt; None:  # pragma: no cover
    """Read one @asis node. Used only by refresh-from-disk"""
    at, c = self, self.c
    fn = c.fullPath(p)
    junk, ext = g.os_path_splitext(fn)
    # Remember the full fileName.
    at.rememberReadPath(fn, p)
    # if not g.unitTesting: g.es("reading: @asis %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None:
        return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    old_body = p.b
    p.b = g.toUnicode(s, encoding=encoding, reportErrors=True)
    if not c.isChanged() and p.b != old_body:
        c.setChanged()
</t>
<t tx="ekr.20190328160622.1">def setCachedBits(self) -&gt; None:
    """
    Set the cached expanded and marked bits for *all* nodes.
    Also cache the current position.
    """
    trace = 'cache' in g.app.debug
    c = self.c
    if not c.mFileName:
        return  # New.
    current = [str(z) for z in self.currentPosition.archivedPosition()]
    expanded = [v.gnx for v in c.all_unique_nodes() if v.isExpanded()]
    marked = [v.gnx for v in c.all_unique_nodes() if v.isMarked()]
    c.db['expanded'] = ','.join(expanded)
    c.db['marked'] = ','.join(marked)
    c.db['current_position'] = ','.join(current)
    if trace:
        g.trace(f"\nset c.db for {c.shortFileName()}")
        print('expanded:', expanded)
        print('marked:', marked)
        print('current_position:', current)
        print('')
</t>
<t tx="ekr.20190402091335.1">from leo.commands import editFileCommands as efc

efc.GitDiffController(c).diff_two_revs(
    rev1='master',  # Old
    rev2='devel',   # New
)
</t>
<t tx="ekr.20190406154306.1">g.openWithFileName(r'C:\apps\pyzo\pyzo.leo')</t>
<t tx="ekr.20190607124533.1"></t>
<t tx="ekr.20190824094650.1">def close_event(self, event: Event) -&gt; None:

    # Save session data.
    g.app.saveSession()
    
    # Attempt to close all windows.
    for c in g.app.commanders():
        allow = c.exists and g.app.closeLeoWindow(c.frame)
        if not allow:
            event.ignore()
            return
    event.accept()
</t>
<t tx="ekr.20190831030206.1">def createActivesSettingsOutline(self) -&gt; None:
    """
    Create and open an outline, summarizing all presently active settings.

    The outline retains the organization of all active settings files.

    See #852: https://github.com/leo-editor/leo-editor/issues/852
    """
    ActiveSettingsOutline(self.c)
</t>
<t tx="ekr.20190901181116.1">def getSource(self, setting: str) -&gt; str:
    """
    Return a string representing the source file of the given setting,
    one of ("local_file", "theme_file", "myLeoSettings", "leoSettings", "ignore", "error")
    """
    if not isinstance(setting, g.GeneralSetting):
        return "error"
    try:
        path = setting.path
    except Exception:
        return "error"
    if not path:
        return "local_file"
    path = path.lower()
    for tag in ('myLeoSettings.leo', 'leoSettings.leo'):
        if path.endswith(tag.lower()):
            return tag[:-4]  # PR: #2422.
    theme_path = g.app.loadManager.theme_path
    if theme_path and g.shortFileName(theme_path.lower()) in path:
        return "theme_file"
    if path == 'register-command' or path.find('mode') &gt; -1:
        return 'ignore'
    return "local_file"
</t>
<t tx="ekr.20190905082644.1">def settingIsActiveInPath(self, gs: str, target_path: str) -&gt; bool:
    """Return True if settings file given by path actually defines the setting, gs."""
    assert isinstance(gs, g.GeneralSetting), repr(gs)
    return gs.path == target_path
</t>
<t tx="ekr.20191007034723.1">@g.command('show-clone-parents')
def show_clones(event: Event = None) -&gt; None:
    """Display links to all parent nodes of the node c.p."""
    c = event.get('c')
    if not c:
        return
    seen = []
    for clone in c.vnode2allPositions(c.p.v):
        parent = clone.parent()
        if parent and parent not in seen:
            seen.append(parent)
            unl = message = parent.get_legacy_UNL()
            # Drop the file part.
            i = unl.find('#')
            if i &gt; 0:
                message = unl[i + 1 :]
            c.frame.log.put(message + '\n', nodeLink=f"{unl}::1")

</t>
<t tx="ekr.20191010112910.1">@g.command('show-clone-ancestors')
def show_clone_ancestors(event: Event = None) -&gt; None:
    """Display links to all ancestor nodes of the node c.p."""
    c = event.get('c')
    if not c:
        return
    p = c.p
    g.es(f"Ancestors of {p.h}...")
    for clone in c.all_positions():
        if clone.v == p.v:
            unl = message = clone.get_legacy_UNL()
            # Drop the file part.
            i = unl.find('#')
            if i &gt; 0:
                message = unl[i + 1 :]
            # Drop the target node from the message.
            parts = message.split('--&gt;')
            if len(parts) &gt; 1:
                message = '--&gt;'.join(parts[:-1])
            c.frame.log.put(message + '\n', nodeLink=f"{unl}::1")
</t>
<t tx="ekr.20191110165235.2">token_index = 0
prev_line_token = None

def add_token(self, kind: str, five_tuple: tuple, line: str, s_row: int, value: str) -&gt; None:
    """
    Add a token to the results list.

    Subclasses could override this method to filter out specific tokens.
    """
    tok = Token(kind, value)
    tok.five_tuple = five_tuple
    tok.index = self.token_index
    # Bump the token index.
    self.token_index += 1
    tok.line = line
    tok.line_number = s_row
    self.results.append(tok)
</t>
<t tx="ekr.20191110165235.4">header_has_been_shown = False

def do_token(self, contents: str, five_tuple: tuple) -&gt; None:
    """
    Handle the given token, optionally including between-token whitespace.

    This is part of the "gem".

    Links:

    - 11/13/19: ENB: A much better untokenizer
      https://groups.google.com/forum/#!msg/leo-editor/DpZ2cMS03WE/VPqtB9lTEAAJ

    - Untokenize does not round-trip ws before bs-nl
      https://bugs.python.org/issue38663
    """
    import token as token_module
    # Unpack..
    tok_type, val, start, end, line = five_tuple
    s_row, s_col = start  # row/col offsets of start of token.
    e_row, e_col = end  # row/col offsets of end of token.
    kind = token_module.tok_name[tok_type].lower()
    # Calculate the token's start/end offsets: character offsets into contents.
    s_offset = self.offsets[max(0, s_row - 1)] + s_col
    e_offset = self.offsets[max(0, e_row - 1)] + e_col
    # tok_s is corresponding string in the line.
    tok_s = contents[s_offset:e_offset]
    # Add any preceding between-token whitespace.
    ws = contents[self.prev_offset:s_offset]
    if ws:
        # No need for a hook.
        self.add_token('ws', five_tuple, line, s_row, ws)
    # Always add token, even if it contributes no text!
    self.add_token(kind, five_tuple, line, s_row, tok_s)
    # Update the ending offset.
    self.prev_offset = e_offset
</t>
<t tx="ekr.20191113063144.1">class TokenOrderGenerator:
    """
    A class that traverses ast (parse) trees in token order.

    Overview: https://github.com/leo-editor/leo-editor/issues/1440#issue-522090981

    Theory of operation:
    - https://github.com/leo-editor/leo-editor/issues/1440#issuecomment-573661883
    - https://leo-editor.github.io/leo-editor/appendices.html#tokenorder-classes-theory-of-operation

    How to: https://leo-editor.github.io/leo-editor/appendices.html#tokenorder-class-how-to

    Project history: https://github.com/leo-editor/leo-editor/issues/1440#issuecomment-574145510
    """

    begin_end_stack: list[str] = []
    equal_sign_spaces = True  # A flag for orange.do_equal_op
    n_nodes = 0  # The number of nodes that have been visited.
    node_index = 0  # The index into the node_stack.
    node_stack: list[ast.AST] = []  # The stack of parent nodes.
    try_stack: list[str] = []  # A stack of either '' (Try) or '*' (TryStar)

    @others
</t>
<t tx="ekr.20191113063144.13"></t>
<t tx="ekr.20191113063144.14"></t>
<t tx="ekr.20191113063144.15"># AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list,
#                expr? returns)

def do_AsyncFunctionDef(self, node: Node) -&gt; None:

    if node.decorator_list:
        for z in node.decorator_list:
            # '@%s\n'
            self.op('@')
            self.visit(z)
    # 'asynch def (%s): -&gt; %s\n'
    # 'asynch def %s(%s):\n'
    async_token_type = 'async' if has_async_tokens else 'name'
    self.token(async_token_type, 'async')
    self.name('def')
    self.name(node.name)  # A string
    self.op('(')
    self.visit(node.args)
    self.op(')')
    returns = getattr(node, 'returns', None)
    if returns is not None:
        self.op('-&gt;')
        self.visit(node.returns)
    self.op(':')
    self.level += 1
    self.visit(node.body)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.16">def do_ClassDef(self, node: Node) -&gt; None:

    for z in node.decorator_list or []:
        # @{z}\n
        self.op('@')
        self.visit(z)
    # class name(bases):\n
    self.name('class')
    self.name(node.name)  # A string.
    if node.bases:
        self.op('(')
        self.visit(node.bases)
        self.op(')')
    self.op(':')
    # Body...
    self.level += 1
    self.visit(node.body)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.17"># FunctionDef(
#   identifier name,
#   arguments args,
#   stmt* body,
#   expr* decorator_list,
#   expr? returns,
#   string? type_comment)

def do_FunctionDef(self, node: Node) -&gt; None:

    # Guards...
    returns = getattr(node, 'returns', None)
    # Decorators...
        # @{z}\n
    for z in node.decorator_list or []:
        self.op('@')
        self.visit(z)
    # Signature...
        # def name(args): -&gt; returns\n
        # def name(args):\n
    self.name('def')
    self.name(node.name)  # A string.
    self.op('(')
    self.visit(node.args)
    self.op(')')
    if returns is not None:
        self.op('-&gt;')
        self.visit(node.returns)
    self.op(':')
    # Body...
    self.level += 1
    self.visit(node.body)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.18">def do_Interactive(self, node: Node) -&gt; None:  # pragma: no cover

    self.visit(node.body)
</t>
<t tx="ekr.20191113063144.19">def do_Module(self, node: Node) -&gt; None:

    # Encoding is a non-syncing statement.
    self.visit(node.body)
</t>
<t tx="ekr.20191113063144.20">def do_Lambda(self, node: Node) -&gt; None:

    self.name('lambda')
    self.visit(node.args)
    self.op(':')
    self.visit(node.body)
</t>
<t tx="ekr.20191113063144.21"></t>
<t tx="ekr.20191113063144.22">def do_Expr(self, node: Node) -&gt; None:
    """An outer expression."""
    # No need to put parentheses.
    self.visit(node.value)
</t>
<t tx="ekr.20191113063144.23">def do_Expression(self, node: Node) -&gt; None:  # pragma: no cover
    """An inner expression."""
    # No need to put parentheses.
    self.visit(node.body)
</t>
<t tx="ekr.20191113063144.24">def do_GeneratorExp(self, node: Node) -&gt; None:

    # '&lt;gen %s for %s&gt;' % (elt, ','.join(gens))
    # No need to put parentheses or commas.
    self.visit(node.elt)
    self.visit(node.generators)
</t>
<t tx="ekr.20191113063144.26"></t>
<t tx="ekr.20191113063144.27"># arguments = (
#       arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,
#       expr* kw_defaults, arg? kwarg, expr* defaults
# )

sync_equal_flag = False  # A small hack.

def do_arguments(self, node: Node) -&gt; None:
    """Arguments to ast.Function or ast.Lambda, **not** ast.Call."""
    #
    # No need to generate commas anywhere below.
    #
    # Let block. Some fields may not exist pre Python 3.8.
    n_plain = len(node.args) - len(node.defaults)
    posonlyargs = getattr(node, 'posonlyargs', [])
    vararg = getattr(node, 'vararg', None)
    kwonlyargs = getattr(node, 'kwonlyargs', [])
    kw_defaults = getattr(node, 'kw_defaults', [])
    kwarg = getattr(node, 'kwarg', None)
    # 1. Sync the position-only args.
    if posonlyargs:
        for z in posonlyargs:
            self.visit(z)
        self.op('/')
    # 2. Sync all args.
    for i, z in enumerate(node.args):
        assert isinstance(z, ast.arg)
        self.visit(z)
        if i &gt;= n_plain:
            old = self.equal_sign_spaces
            try:
                self.equal_sign_spaces = getattr(z, 'annotation', None) is not None
                self.op('=')
            finally:
                self.equal_sign_spaces = old
            self.visit(node.defaults[i - n_plain])
    # 3. Sync the vararg.
    if vararg:
        self.op('*')
        self.visit(vararg)
    # 4. Sync the keyword-only args.
    if kwonlyargs:
        if not vararg:
            self.op('*')
        for n, z in enumerate(kwonlyargs):
            self.visit(z)
            val = kw_defaults[n]
            if val is not None:
                self.op('=')
                self.visit(val)
    # 5. Sync the kwarg.
    if kwarg:
        self.op('**')
        self.visit(kwarg)


</t>
<t tx="ekr.20191113063144.28"># arg = (identifier arg, expr? annotation)

def do_arg(self, node: Node) -&gt; None:
    """This is one argument of a list of ast.Function or ast.Lambda arguments."""
    self.name(node.arg)
    annotation = getattr(node, 'annotation', None)
    if annotation is not None:
        self.op(':')
        self.visit(node.annotation)
</t>
<t tx="ekr.20191113063144.29"># Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self, node: Node) -&gt; None:

    self.visit(node.value)
    self.op('.')
    self.name(node.attr)  # A string.
</t>
<t tx="ekr.20191113063144.3">def enter_node(self, node: Node) -&gt; None:
    """Enter a node."""
    # Update the stats.
    self.n_nodes += 1
    # Do this first, *before* updating self.node.
    node.parent = self.node
    if self.node:
        children: list[Node] = getattr(self.node, 'children', [])
        children.append(node)
        self.node.children = children
    # Inject the node_index field.
    assert not hasattr(node, 'node_index'), g.callers()
    node.node_index = self.node_index
    self.node_index += 1
    # begin_visitor and end_visitor must be paired.
    self.begin_end_stack.append(node.__class__.__name__)
    # Push the previous node.
    self.node_stack.append(self.node)
    # Update self.node *last*.
    self.node = node
</t>
<t tx="ekr.20191113063144.30">def do_Bytes(self, node: Node) -&gt; None:

    """
    It's invalid to mix bytes and non-bytes literals, so just
    advancing to the next 'string' token suffices.
    """
    token = self.find_next_significant_token()
    self.token('string', token.value)
</t>
<t tx="ekr.20191113063144.31"># Call(expr func, expr* args, keyword* keywords)

# Python 3 ast.Call nodes do not have 'starargs' or 'kwargs' fields.

def do_Call(self, node: Node) -&gt; None:

    # The calls to op(')') and op('(') do nothing by default.
    # Subclasses might handle them in an overridden tog.set_links.
    self.visit(node.func)
    self.op('(')
    # No need to generate any commas.
    self.handle_call_arguments(node)
    self.op(')')
</t>
<t tx="ekr.20191113063144.32"># keyword arguments supplied to call (NULL identifier for **kwargs)

# keyword = (identifier? arg, expr value)

def do_keyword(self, node: Node) -&gt; None:  # pragma: no cover
    """A keyword arg in an ast.Call."""
    # This should never be called.
    # tog.hande_call_arguments calls self.visit(kwarg_arg.value) instead.
    filename = getattr(self, 'filename', '&lt;no file&gt;')
    raise AssignLinksError(
        f"file: {filename}\n"
        f"do_keyword should never be called\n"
        f"{g.callers(8)}")
</t>
<t tx="ekr.20191113063144.33"># comprehension = (expr target, expr iter, expr* ifs, int is_async)

def do_comprehension(self, node: Node) -&gt; None:

    # No need to put parentheses.
    self.name('for')  # #1858.
    self.visit(node.target)  # A name
    self.name('in')
    self.visit(node.iter)
    for z in node.ifs or []:
        self.name('if')
        self.visit(z)
</t>
<t tx="ekr.20191113063144.34">def do_Constant(self, node: Node) -&gt; None:  # pragma: no cover
    """
    https://greentreesnakes.readthedocs.io/en/latest/nodes.html

    A constant. The value attribute holds the Python object it represents.
    This can be simple types such as a number, string or None, but also
    immutable container types (tuples and frozensets) if all of their
    elements are constant.
    """
    # Support Python 3.8.
    if node.value is None or isinstance(node.value, bool):
        # Weird: return a name!
        self.token('name', repr(node.value))
    elif node.value == Ellipsis:
        self.op('...')
    elif isinstance(node.value, str):
        self.do_Str(node)
    elif isinstance(node.value, (int, float)):
        self.token('number', repr(node.value))
    elif isinstance(node.value, bytes):
        self.do_Bytes(node)
    elif isinstance(node.value, tuple):
        self.do_Tuple(node)
    elif isinstance(node.value, frozenset):
        self.do_Set(node)
    else:
        # Unknown type.
        g.trace('----- Oops -----', repr(node.value), g.callers())
</t>
<t tx="ekr.20191113063144.35"># Dict(expr* keys, expr* values)

def do_Dict(self, node: Node) -&gt; None:

    assert len(node.keys) == len(node.values)
    self.op('{')
    # No need to put commas.
    for i, key in enumerate(node.keys):
        key, value = node.keys[i], node.values[i]
        self.visit(key)  # a Str node.
        self.op(':')
        if value is not None:
            self.visit(value)
    self.op('}')
</t>
<t tx="ekr.20191113063144.36"># DictComp(expr key, expr value, comprehension* generators)

# d2 = {val: key for key, val in d}

def do_DictComp(self, node: Node) -&gt; None:

    self.token('op', '{')
    self.visit(node.key)
    self.op(':')
    self.visit(node.value)
    for z in node.generators or []:
        self.visit(z)
        self.token('op', '}')
</t>
<t tx="ekr.20191113063144.37">def do_Ellipsis(self, node: Node) -&gt; None:  # pragma: no cover (Does not exist for python 3.8+)

    self.op('...')
</t>
<t tx="ekr.20191113063144.38"># https://docs.python.org/3/reference/expressions.html#slicings

# ExtSlice(slice* dims)

def do_ExtSlice(self, node: Node) -&gt; None:  # pragma: no cover (deprecated)

    # ','.join(node.dims)
    for i, z in enumerate(node.dims):
        self.visit(z)
        if i &lt; len(node.dims) - 1:
            self.op(',')
</t>
<t tx="ekr.20191113063144.39"># FormattedValue(expr value, int? conversion, expr? format_spec)

def do_FormattedValue(self, node: Node) -&gt; None:  # pragma: no cover
    """
    This node represents the *components* of a *single* f-string.

    Happily, JoinedStr nodes *also* represent *all* f-strings,
    so the TOG should *never visit this node!
    """
    filename = getattr(self, 'filename', '&lt;no file&gt;')
    raise AssignLinksError(
        f"file: {filename}\n"
        f"do_FormattedValue should never be called")

    # This code has no chance of being useful...

        # conv = node.conversion
        # spec = node.format_spec
        # self.visit(node.value)
        # if conv is not None:
            # self.token('number', conv)
        # if spec is not None:
            # self.visit(node.format_spec)
</t>
<t tx="ekr.20191113063144.4">def create_links(self, tokens: list[Token], tree: Node, file_name: str = '') -&gt; list:
    """
    A generator creates two-way links between the given tokens and ast-tree.

    Callers should call this generator with list(tog.create_links(...))

    The sync_tokens method creates the links and verifies that the resulting
    tree traversal generates exactly the given tokens in exact order.

    tokens: the list of Token instances for the input.
            Created by make_tokens().
    tree:   the ast tree for the input.
            Created by parse_ast().
    """
    # Init all ivars.
    self.equal_sign_spaces = True  # For a special case in set_links().
    self.file_name = file_name  # For tests.
    self.level = 0  # Python indentation level.
    self.node = None  # The node being visited.
    self.tokens = tokens  # The immutable list of input tokens.
    self.tree = tree  # The tree of ast.AST nodes.
    # Traverse the tree.
    self.visit(tree)
    # Ensure that all tokens are patched.
    self.node = tree
    self.token('endmarker', '')
    # Return [] for compatibility with legacy code: list(tog.create_links).
    return []
</t>
<t tx="ekr.20191113063144.40">def do_Index(self, node: Node) -&gt; None:  # pragma: no cover (deprecated)

    self.visit(node.value)
</t>
<t tx="ekr.20191113063144.41"># JoinedStr(expr* values)

def do_JoinedStr(self, node: Node) -&gt; None:
    """
    JoinedStr nodes represent at least one f-string and all other strings
    concatenated to it.

    Analyzing JoinedStr.values would be extremely tricky, for reasons that
    need not be explained here.

    Instead, we get the tokens *from the token list itself*!
    """
    for z in self.get_concatenated_string_tokens():
        self.token(z.kind, z.value)
</t>
<t tx="ekr.20191113063144.42">def do_List(self, node: Node) -&gt; None:

    # No need to put commas.
    self.op('[')
    self.visit(node.elts)
    self.op(']')
</t>
<t tx="ekr.20191113063144.43"># ListComp(expr elt, comprehension* generators)

def do_ListComp(self, node: Node) -&gt; None:

    self.op('[')
    self.visit(node.elt)
    for z in node.generators:
        self.visit(z)
    self.op(']')
</t>
<t tx="ekr.20191113063144.44">def do_Name(self, node: Node) -&gt; None:

    self.name(node.id)

def do_NameConstant(self, node: Node) -&gt; None:  # pragma: no cover (Does not exist in Python 3.8+)

    self.name(repr(node.value))

</t>
<t tx="ekr.20191113063144.45">def do_Num(self, node: Node) -&gt; None:  # pragma: no cover (Does not exist in Python 3.8+)

    self.token('number', node.n)
</t>
<t tx="ekr.20191113063144.47"># Set(expr* elts)

def do_Set(self, node: Node) -&gt; None:

    self.op('{')
    self.visit(node.elts)
    self.op('}')
</t>
<t tx="ekr.20191113063144.48"># SetComp(expr elt, comprehension* generators)

def do_SetComp(self, node: Node) -&gt; None:

    self.op('{')
    self.visit(node.elt)
    for z in node.generators or []:
        self.visit(z)
    self.op('}')
</t>
<t tx="ekr.20191113063144.49"># slice = Slice(expr? lower, expr? upper, expr? step)

def do_Slice(self, node: Node) -&gt; None:

    lower = getattr(node, 'lower', None)
    upper = getattr(node, 'upper', None)
    step = getattr(node, 'step', None)
    if lower is not None:
        self.visit(lower)
    # Always put the colon between upper and lower.
    self.op(':')
    if upper is not None:
        self.visit(upper)
    # Put the second colon if it exists in the token list.
    if step is None:
        token = self.find_next_significant_token()
        if token and token.value == ':':
            self.op(':')
    else:
        self.op(':')
        self.visit(step)
</t>
<t tx="ekr.20191113063144.50">def do_Str(self, node: Node) -&gt; None:
    """This node represents a string constant."""
    # This loop is necessary to handle string concatenation.
    for z in self.get_concatenated_string_tokens():
        self.token(z.kind, z.value)
</t>
<t tx="ekr.20191113063144.51"># Subscript(expr value, slice slice, expr_context ctx)

def do_Subscript(self, node: Node) -&gt; None:

    self.visit(node.value)
    self.op('[')
    self.visit(node.slice)
    self.op(']')
</t>
<t tx="ekr.20191113063144.52"># Tuple(expr* elts, expr_context ctx)

def do_Tuple(self, node: Node) -&gt; None:

    # Do not call op for parens or commas here.
    # They do not necessarily exist in the token list!
    self.visit(node.elts)
</t>
<t tx="ekr.20191113063144.53"></t>
<t tx="ekr.20191113063144.55">def do_BinOp(self, node: Node) -&gt; None:

    op_name_ = op_name(node.op)
    self.visit(node.left)
    self.op(op_name_)
    self.visit(node.right)
</t>
<t tx="ekr.20191113063144.56"># BoolOp(boolop op, expr* values)

def do_BoolOp(self, node: Node) -&gt; None:

    # op.join(node.values)
    op_name_ = op_name(node.op)
    for i, z in enumerate(node.values):
        self.visit(z)
        if i &lt; len(node.values) - 1:
            self.name(op_name_)
</t>
<t tx="ekr.20191113063144.57"># Compare(expr left, cmpop* ops, expr* comparators)

def do_Compare(self, node: Node) -&gt; None:

    assert len(node.ops) == len(node.comparators)
    self.visit(node.left)
    for i, z in enumerate(node.ops):
        op_name_ = op_name(node.ops[i])
        if op_name_ in ('not in', 'is not'):
            for z in op_name_.split(' '):
                self.name(z)
        elif op_name_.isalpha():
            self.name(op_name_)
        else:
            self.op(op_name_)
        self.visit(node.comparators[i])
</t>
<t tx="ekr.20191113063144.58">def do_UnaryOp(self, node: Node) -&gt; None:

    op_name_ = op_name(node.op)
    if op_name_.isalpha():
        self.name(op_name_)
    else:
        self.op(op_name_)
    self.visit(node.operand)
</t>
<t tx="ekr.20191113063144.59"># IfExp(expr test, expr body, expr orelse)

def do_IfExp(self, node: Node) -&gt; None:

    self.visit(node.body)
    self.name('if')
    self.visit(node.test)
    self.name('else')
    self.visit(node.orelse)
</t>
<t tx="ekr.20191113063144.60"></t>
<t tx="ekr.20191113063144.61"># AnnAssign(expr target, expr annotation, expr? value, int simple)

def do_AnnAssign(self, node: Node) -&gt; None:

    # {node.target}:{node.annotation}={node.value}\n'
    self.visit(node.target)
    self.op(':')
    self.visit(node.annotation)
    if node.value is not None:  # #1851
        self.op('=')
        self.visit(node.value)
</t>
<t tx="ekr.20191113063144.62"># Assert(expr test, expr? msg)

def do_Assert(self, node: Node) -&gt; None:

    # Guards...
    msg = getattr(node, 'msg', None)
    # No need to put parentheses or commas.
    self.name('assert')
    self.visit(node.test)
    if msg is not None:
        self.visit(node.msg)
</t>
<t tx="ekr.20191113063144.63">def do_Assign(self, node: Node) -&gt; None:

    for z in node.targets:
        self.visit(z)
        self.op('=')
    self.visit(node.value)
</t>
<t tx="ekr.20191113063144.64">def do_AsyncFor(self, node: Node) -&gt; None:

    # The def line...
    # Py 3.8 changes the kind of token.
    async_token_type = 'async' if has_async_tokens else 'name'
    self.token(async_token_type, 'async')
    self.name('for')
    self.visit(node.target)
    self.name('in')
    self.visit(node.iter)
    self.op(':')
    # Body...
    self.level += 1
    self.visit(node.body)
    # Else clause...
    if node.orelse:
        self.name('else')
        self.op(':')
        self.visit(node.orelse)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.65">def do_AsyncWith(self, node: Node) -&gt; None:

    async_token_type = 'async' if has_async_tokens else 'name'
    self.token(async_token_type, 'async')
    self.do_With(node)
</t>
<t tx="ekr.20191113063144.66"># AugAssign(expr target, operator op, expr value)

def do_AugAssign(self, node: Node) -&gt; None:

    # %s%s=%s\n'
    op_name_ = op_name(node.op)
    self.visit(node.target)
    self.op(op_name_ + '=')
    self.visit(node.value)
</t>
<t tx="ekr.20191113063144.67"># Await(expr value)

def do_Await(self, node: Node) -&gt; None:

    async_token_type = 'await' if has_async_tokens else 'name'
    self.token(async_token_type, 'await')
    self.visit(node.value)
</t>
<t tx="ekr.20191113063144.68">def do_Break(self, node: Node) -&gt; None:

    self.name('break')
</t>
<t tx="ekr.20191113063144.69">def do_Continue(self, node: Node) -&gt; None:

    self.name('continue')
</t>
<t tx="ekr.20191113063144.7">px = -1  # Index of the previously synced token.

def sync_token(self, kind: str, val: str) -&gt; None:
    """
    Sync to a token whose kind &amp; value are given. The token need not be
    significant, but it must be guaranteed to exist in the token list.

    The checks in this method constitute a strong, ever-present, unit test.

    Scan the tokens *after* px, looking for a token T matching (kind, val).
    raise AssignLinksError if a significant token is found that doesn't match T.
    Otherwise:
    - Create two-way links between all assignable tokens between px and T.
    - Create two-way links between T and self.node.
    - Advance by updating self.px to point to T.
    """
    node, tokens = self.node, self.tokens
    assert isinstance(node, ast.AST), repr(node)
    if 0:  # A Superb trace.
        g.trace(
            f"px: {self.px:4} "
            f"node: {node.__class__.__name__:&lt;12} "
            f"significant? {int(is_significant(kind, val))} "
            f"kind/val: {kind:&gt;10}: {val!r}")
    #
    # Step one: Look for token T.
    old_px = px = self.px + 1
    while px &lt; len(self.tokens):
        token = tokens[px]
        if (kind, val) == (token.kind, token.value):
            break  # Success.
        if kind == token.kind == 'number':
            val = token.value
            break  # Benign: use the token's value, a string, instead of a number.
        if is_significant_token(token):  # pragma: no cover
            line_s = f"line {token.line_number}:"
            val = str(val)  # for g.truncate.
            raise AssignLinksError(
                f"       file: {self.filename}\n"
                f"{line_s:&gt;12} {token.line.strip()}\n"
                f"Looking for: {kind}.{g.truncate(val, 40)!r}\n"
                f"      found: {token.kind}.{token.value!r}\n"
                f"token.index: {token.index}\n")
        # Skip the insignificant token.
        px += 1
    else:  # pragma: no cover
        val = str(val)  # for g.truncate.
        raise AssignLinksError(
             f"       file: {self.filename}\n"
             f"Looking for: {kind}.{g.truncate(val, 40)}\n"
             f"      found: end of token list")
    #
    # Step two: Assign *secondary* links only for newline tokens.
    #           Ignore all other non-significant tokens.
    while old_px &lt; px:
        token = tokens[old_px]
        old_px += 1
        if token.kind in ('comment', 'newline', 'nl'):
            self.set_links(node, token)
    #
    # Step three: Set links in the found token.
    token = tokens[px]
    self.set_links(node, token)
    #
    # Step four: Advance.
    self.px = px

token = sync_token  # For readability.
</t>
<t tx="ekr.20191113063144.70">def do_Delete(self, node: Node) -&gt; None:

    # No need to put commas.
    self.name('del')
    self.visit(node.targets)
</t>
<t tx="ekr.20191113063144.71">def do_ExceptHandler(self, node: Node) -&gt; None:

    # Except line...
    self.name('except')
    if self.try_stack[-1] == '*':
        self.op('*')
    if getattr(node, 'type', None):
        self.visit(node.type)
    if getattr(node, 'name', None):
        self.name('as')
        self.name(node.name)
    self.op(':')
    # Body...
    self.level += 1
    self.visit(node.body)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.73">def do_For(self, node: Node) -&gt; None:

    # The def line...
    self.name('for')
    self.visit(node.target)
    self.name('in')
    self.visit(node.iter)
    self.op(':')
    # Body...
    self.level += 1
    self.visit(node.body)
    # Else clause...
    if node.orelse:
        self.name('else')
        self.op(':')
        self.visit(node.orelse)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.74"># Global(identifier* names)

def do_Global(self, node: Node) -&gt; None:

    self.name('global')
    for z in node.names:
        self.name(z)
</t>
<t tx="ekr.20191113063144.75"># If(expr test, stmt* body, stmt* orelse)

def do_If(self, node: Node) -&gt; None:
    &lt;&lt; do_If docstring &gt;&gt;
    # Use the next significant token to distinguish between 'if' and 'elif'.
    token = self.find_next_significant_token()
    self.name(token.value)
    self.visit(node.test)
    self.op(':')
    #
    # Body...
    self.level += 1
    self.visit(node.body)
    self.level -= 1
    #
    # Else and elif clauses...
    if node.orelse:
        self.level += 1
        token = self.find_next_significant_token()
        if token.value == 'else':
            self.name('else')
            self.op(':')
            self.visit(node.orelse)
        else:
            self.visit(node.orelse)
        self.level -= 1
</t>
<t tx="ekr.20191113063144.76">def do_Import(self, node: Node) -&gt; None:

    self.name('import')
    for alias in node.names:
        self.name(alias.name)
        if alias.asname:
            self.name('as')
            self.name(alias.asname)
</t>
<t tx="ekr.20191113063144.77"># ImportFrom(identifier? module, alias* names, int? level)

def do_ImportFrom(self, node: Node) -&gt; None:

    self.name('from')
    for _i in range(node.level):
        self.op('.')
    if node.module:
        self.name(node.module)
    self.name('import')
    # No need to put commas.
    for alias in node.names:
        if alias.name == '*':  # #1851.
            self.op('*')
        else:
            self.name(alias.name)
        if alias.asname:
            self.name('as')
            self.name(alias.asname)
</t>
<t tx="ekr.20191113063144.78"># Nonlocal(identifier* names)

def do_Nonlocal(self, node: Node) -&gt; None:

    # nonlocal %s\n' % ','.join(node.names))
    # No need to put commas.
    self.name('nonlocal')
    for z in node.names:
        self.name(z)
</t>
<t tx="ekr.20191113063144.79">def do_Pass(self, node: Node) -&gt; None:

    self.name('pass')
</t>
<t tx="ekr.20191113063144.81"># Raise(expr? exc, expr? cause)

def do_Raise(self, node: Node) -&gt; None:

    # No need to put commas.
    self.name('raise')
    exc = getattr(node, 'exc', None)
    cause = getattr(node, 'cause', None)
    tback = getattr(node, 'tback', None)
    self.visit(exc)
    if cause:
        self.name('from')  # #2446.
        self.visit(cause)
    self.visit(tback)
</t>
<t tx="ekr.20191113063144.82">def do_Return(self, node: Node) -&gt; None:

    self.name('return')
    self.visit(node.value)
</t>
<t tx="ekr.20191113063144.83"># Starred(expr value, expr_context ctx)

def do_Starred(self, node: Node) -&gt; None:
    """A starred argument to an ast.Call"""
    self.op('*')
    self.visit(node.value)
</t>
<t tx="ekr.20191113063144.85"># Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)

def do_Try(self, node: Node) -&gt; None:

    # Try line...
    self.name('try')
    self.op(':')
    # Body...
    self.level += 1
    self.visit(node.body)
    self.try_stack.append('')
    self.visit(node.handlers)
    self.try_stack.pop()
    # Else...
    if node.orelse:
        self.name('else')
        self.op(':')
        self.visit(node.orelse)
    # Finally...
    if node.finalbody:
        self.name('finally')
        self.op(':')
        self.visit(node.finalbody)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.88">def do_While(self, node: Node) -&gt; None:

    # While line...
        # while %s:\n'
    self.name('while')
    self.visit(node.test)
    self.op(':')
    # Body...
    self.level += 1
    self.visit(node.body)
    # Else clause...
    if node.orelse:
        self.name('else')
        self.op(':')
        self.visit(node.orelse)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.89"># With(withitem* items, stmt* body)

# withitem = (expr context_expr, expr? optional_vars)

def do_With(self, node: Node) -&gt; None:

    expr: Optional[ast.AST] = getattr(node, 'context_expression', None)
    items: list[ast.AST] = getattr(node, 'items', [])
    self.name('with')
    self.visit(expr)
    # No need to put commas.
    for item in items:
        self.visit(item.context_expr)
        optional_vars = getattr(item, 'optional_vars', None)
        if optional_vars is not None:
            self.name('as')
            self.visit(item.optional_vars)
    # End the line.
    self.op(':')
    # Body...
    self.level += 1
    self.visit(node.body)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.90">def do_Yield(self, node: Node) -&gt; None:

    self.name('yield')
    if hasattr(node, 'value'):
        self.visit(node.value)
</t>
<t tx="ekr.20191113063144.91"># YieldFrom(expr value)

def do_YieldFrom(self, node: Node) -&gt; None:

    self.name('yield')
    self.name('from')
    self.visit(node.value)
</t>
<t tx="ekr.20191113081443.1">def visit(self, node: Node) -&gt; None:
    """Given an ast node, return a *generator* from its visitor."""
    # This saves a lot of tests.
    if node is None:
        return
    if 0:  # pragma: no cover
        # Keep this trace!
        cn = node.__class__.__name__ if node else ' '
        caller1, caller2 = g.callers(2).split(',')
        g.trace(f"{caller1:&gt;15} {caller2:&lt;14} {cn}")
    # More general, more convenient.
    if isinstance(node, (list, tuple)):
        for z in node or []:
            if isinstance(z, ast.AST):
                self.visit(z)
            else:  # pragma: no cover
                # Some fields may contain ints or strings.
                assert isinstance(z, (int, str)), z.__class__.__name__
        return
    # We *do* want to crash if the visitor doesn't exist.
    method = getattr(self, 'do_' + node.__class__.__name__)
    # Don't even *think* about removing the parent/child links.
    # The nearest_common_ancestor function depends upon them.
    self.enter_node(node)
    method(node)
    self.leave_node(node)
</t>
<t tx="ekr.20191122222412.1">"""
The parse trees for the following are identical!

  if 1:            if 1:
      pass             pass
  else:            elif 2:
      if 2:            pass
          pass

So there is *no* way for the 'if' visitor to disambiguate the above two
cases from the parse tree alone.

Instead, we scan the tokens list for the next 'if', 'else' or 'elif' token.
"""
</t>
<t tx="ekr.20191124083124.1">def sync_name(self, val: str) -&gt; None:
    aList = val.split('.')
    if len(aList) == 1:
        self.sync_token('name', val)
    else:
        for i, part in enumerate(aList):
            self.sync_token('name', part)
            if i &lt; len(aList) - 1:
                self.sync_op('.')

name = sync_name  # for readability.
</t>
<t tx="ekr.20191125120814.1">last_statement_node = None

def set_links(self, node: Node, token: Token) -&gt; None:
    """Make two-way links between token and the given node."""
    # Don't bother assigning comment, comma, parens, ws and endtoken tokens.
    if token.kind == 'comment':
        # Append the comment to node.comment_list.
        comment_list: list[Token] = getattr(node, 'comment_list', [])
        node.comment_list = comment_list + [token]
        return
    if token.kind in ('endmarker', 'ws'):
        return
    if token.kind == 'op' and token.value in ',()':
        return
    # *Always* remember the last statement.
    statement = find_statement_node(node)
    if statement:
        self.last_statement_node = statement
        assert not isinstance(self.last_statement_node, ast.Module)
    if token.node is not None:  # pragma: no cover
        line_s = f"line {token.line_number}:"
        raise AssignLinksError(
                f"       file: {self.filename}\n"
                f"{line_s:&gt;12} {token.line.strip()}\n"
                f"token index: {self.px}\n"
                f"token.node is not None\n"
                f" token.node: {token.node.__class__.__name__}\n"
                f"    callers: {g.callers()}")
    # Assign newlines to the previous statement node, if any.
    if token.kind in ('newline', 'nl'):
        # Set an *auxillary* link for the split/join logic.
        # Do *not* set token.node!
        token.statement_node = self.last_statement_node
        return
    if is_significant_token(token):
        # Link the token to the ast node.
        token.node = node
        # Add the token to node's token_list.
        add_token_to_token_list(token, node)
        # Special case. Inject equal_sign_spaces into '=' tokens.
        if token.kind == 'op' and token.value == '=':
            token.equal_sign_spaces = self.equal_sign_spaces
</t>
<t tx="ekr.20191204105506.1">def handle_call_arguments(self, node: Node) -&gt; None:
    """
    Generate arguments in the correct order.

    Call(expr func, expr* args, keyword* keywords)

    https://docs.python.org/3/reference/expressions.html#calls

    Warning: This code will fail on Python 3.8 only for calls
             containing kwargs in unexpected places.
    """
    # *args:    in node.args[]:     Starred(value=Name(id='args'))
    # *[a, 3]:  in node.args[]:     Starred(value=List(elts=[Name(id='a'), Num(n=3)])
    # **kwargs: in node.keywords[]: keyword(arg=None, value=Name(id='kwargs'))
    #
    # Scan args for *name or *List
    args = node.args or []
    keywords = node.keywords or []

    def get_pos(obj: Node) -&gt; tuple[int, int, Any]:
        line1 = getattr(obj, 'lineno', None)
        col1 = getattr(obj, 'col_offset', None)
        return line1, col1, obj

    def sort_key(aTuple: tuple) -&gt; int:
        line, col, obj = aTuple
        return line * 1000 + col

    if 0:  # pragma: no cover
        g.print_obj([ast.dump(z) for z in args], tag='args')
        g.print_obj([ast.dump(z) for z in keywords], tag='keywords')

    if py_version &gt;= (3, 9):
        places = [get_pos(z) for z in args + keywords]
        places.sort(key=sort_key)
        ordered_args = [z[2] for z in places]
        for z in ordered_args:
            if isinstance(z, ast.Starred):
                self.op('*')
                self.visit(z.value)
            elif isinstance(z, ast.keyword):
                if getattr(z, 'arg', None) is None:
                    self.op('**')
                    self.arg_helper(z.value)
                else:
                    self.arg_helper(z.arg)
                    old = self.equal_sign_spaces
                    try:
                        self.equal_sign_spaces = False
                        self.op('=')
                    finally:
                        self.equal_sign_spaces = old
                    self.arg_helper(z.value)
            else:
                self.arg_helper(z)
    else:  # pragma: no cover
        #
        # Legacy code: May fail for Python 3.8
        #
        # Scan args for *arg and *[...]
        kwarg_arg = star_arg = None
        for z in args:
            if isinstance(z, ast.Starred):
                if isinstance(z.value, ast.Name):  # *Name.
                    star_arg = z
                    args.remove(z)
                    break
                elif isinstance(z.value, (ast.List, ast.Tuple)):  # *[...]
                    # star_list = z
                    break
                raise AttributeError(f"Invalid * expression: {ast.dump(z)}")  # pragma: no cover
        # Scan keywords for **name.
        for z in keywords:
            if hasattr(z, 'arg') and z.arg is None:
                kwarg_arg = z
                keywords.remove(z)
                break
        # Sync the plain arguments.
        for z in args:
            self.arg_helper(z)
        # Sync the keyword args.
        for z in keywords:
            self.arg_helper(z.arg)
            self.op('=')
            self.arg_helper(z.value)
        # Sync the * arg.
        if star_arg:
            self.arg_helper(star_arg)
        # Sync the ** kwarg.
        if kwarg_arg:
            self.op('**')
            self.visit(kwarg_arg.value)
</t>
<t tx="ekr.20191204114930.1">def arg_helper(self, node: Union[Node, str]) -&gt; None:
    """
    Yield the node, with a special case for strings.
    """
    if isinstance(node, str):
        self.token('name', node)
    else:
        self.visit(node)
</t>
<t tx="ekr.20191213085126.1">def reloadSettings(self) -&gt; None:
    """Undoer.reloadSettings."""
    c = self.c
    self.granularity = c.config.getString('undo-granularity')
    if self.granularity:
        self.granularity = self.granularity.lower()
    if self.granularity not in ('node', 'line', 'word', 'char'):
        self.granularity = 'line'
</t>
<t tx="ekr.20191213085226.1">def redoHelper(self) -&gt; None:
    """The default do-nothing redo helper."""
    pass
</t>
<t tx="ekr.20191213085246.1">def undoHelper(self) -&gt; None:
    """The default do-nothing undo helper."""
    pass
</t>
<t tx="ekr.20191213092304.1">def update_status(self) -&gt; None:
    """
    Update status after either an undo or redo:
    """
    c, u = self.c, self
    w = c.frame.body.wrapper
    # Redraw and recolor.
    c.frame.body.updateEditors()  # New in Leo 4.4.8.
    #
    # Set the new position.
    if 0:  # Don't do this: it interferes with selection ranges.
        # This strange code forces a recomputation of the root position.
        c.selectPosition(c.p)
    else:
        c.setCurrentPosition(c.p)
    #
    # # 1451. *Always* set the changed bit.
    # Redrawing *must* be done here before setting u.undoing to False.
    i, j = w.getSelectionRange()
    ins = w.getInsertPoint()
    c.redraw()
    c.recolor()
    if u.inHead:
        c.editHeadline()
        u.inHead = False
    else:
        c.bodyWantsFocus()
        w.setSelectionRange(i, j, insert=ins)
        w.seeInsertPoint()
</t>
<t tx="ekr.20191213161023.1">def setAllAncestorAtFileNodesDirty(self) -&gt; None:
    """
    Original idea by Виталије Милошевић (Vitalije Milosevic).

    Modified by EKR.
    """
    v = self
    seen: set[VNode] = set([v.context.hiddenRootNode])

    def v_and_parents(v: VNode) -&gt; Generator:
        if v in seen:
            return
        seen.add(v)
        yield v
        for parent_v in v.parents:
            if parent_v not in seen:
                yield from v_and_parents(parent_v)

    for v2 in v_and_parents(v):
        if v2.isAnyAtFileNode():
            v2.setDirty()
</t>
<t tx="ekr.20191222102831.7">def change_quotes(self, lt_s: str, aList: list[Token]) -&gt; bool:
    """
    Carefully check quotes in all "inner" tokens as necessary.

    Return False if the f-string would contain backslashes.

    We expect the following "outer" tokens.

    aList[0]:  ('string', 'f')
    aList[1]:  ('string',  a single or double quote.
    aList[-1]: ('string', a single or double quote matching aList[1])
    """
    # Sanity checks.
    if len(aList) &lt; 4:
        return True  # pragma: no cover (defensive)
    if not lt_s:  # pragma: no cover (defensive)
        self.message("can't create f-fstring: no lt_s!")
        return False
    delim = lt_s[0]
    # Check tokens 0, 1 and -1.
    token0 = aList[0]
    token1 = aList[1]
    token_last = aList[-1]
    for token in token0, token1, token_last:
        # These are the only kinds of tokens we expect to generate.
        ok = (
            token.kind == 'string' or
            token.kind == 'op' and token.value in '{}')
        if not ok:  # pragma: no cover (defensive)
            self.message(
                f"unexpected token: {token.kind} {token.value}\n"
                f":           lt_s: {lt_s!r}")
            return False
    # These checks are important...
    if token0.value != 'f':
        return False  # pragma: no cover (defensive)
    val1 = token1.value
    if delim != val1:
        return False  # pragma: no cover (defensive)
    val_last = token_last.value
    if delim != val_last:
        return False  # pragma: no cover (defensive)
    #
    # Check for conflicting delims, preferring f"..." to f'...'.
    for delim in ('"', "'"):
        aList[1] = aList[-1] = Token('string', delim)
        for z in aList[2:-1]:
            if delim in z.value:
                break
        else:
            return True
    if not self.silent:  # pragma: no cover (silent unit test)
        self.message(
            f"can't create f-fstring: {lt_s!r}\n"
            f":   conflicting delims:")
    return False
</t>
<t tx="ekr.20191222104224.1">def scan_rhs(self, node: Node) -&gt; list[list[Token]]:
    """
    Scan the right-hand side of a potential f-string.

    Return a list of the token lists for each element.
    """
    trace = False
    # First, Try the most common cases.
    if isinstance(node, ast.Str):
        token_list = get_node_token_list(node, self.tokens)
        return [token_list]
    if isinstance(node, (list, tuple, ast.Tuple)):
        result = []
        elts = node.elts if isinstance(node, ast.Tuple) else node
        for i, elt in enumerate(elts):
            tokens = tokens_for_node(self.filename, elt, self.tokens)
            result.append(tokens)
            if trace:  # pragma: no cover
                g.trace(f"item: {i}: {elt.__class__.__name__}")
                g.print_obj(tokens, tag=f"Tokens for item {i}")
        return result
    # Now we expect only one result.
    tokens = tokens_for_node(self.filename, node, self.tokens)
    return [tokens]
</t>
<t tx="ekr.20191223052749.1"></t>
<t tx="ekr.20191223053324.1">def tokens_for_node(filename: str, node: Node, global_token_list: list[Token]) -&gt; list[Token]:
    """Return the list of all tokens descending from node."""
    # Find any token descending from node.
    token = find_anchor_token(node, global_token_list)
    if not token:
        if 0:  # A good trace for debugging.
            print('')
            g.trace('===== no tokens', node.__class__.__name__)
        return []
    assert is_ancestor(node, token)
    # Scan backward.
    i = first_i = token.index
    while i &gt;= 0:
        token2 = global_token_list[i - 1]
        if getattr(token2, 'node', None):
            if is_ancestor(node, token2):
                first_i = i - 1
            else:
                break
        i -= 1
    # Scan forward.
    j = last_j = token.index
    while j + 1 &lt; len(global_token_list):
        token2 = global_token_list[j + 1]
        if getattr(token2, 'node', None):
            if is_ancestor(node, token2):
                last_j = j + 1
            else:
                break
        j += 1
    last_j = match_parens(filename, first_i, last_j, global_token_list)
    results = global_token_list[first_i : last_j + 1]
    return results
</t>
<t tx="ekr.20191225054848.1">def replace(self, node: Node, s: str, values: list[list[Token]]) -&gt; None:
    """
    Replace node with an ast.Str node for s.
    Replace all tokens in the range of values with a single 'string' node.
    """
    # Replace the tokens...
    tokens = tokens_for_node(self.filename, node, self.tokens)
    i1 = i = tokens[0].index
    replace_token(self.tokens[i], 'string', s)
    j = 1
    while j &lt; len(tokens):
        replace_token(self.tokens[i1 + j], 'killed', '')
        j += 1
    # Replace the node.
    new_node = ast.Str()
    new_node.s = s
    replace_node(new_node, node)
    # Update the token.
    token = self.tokens[i1]
    token.node = new_node
    # Update the token list.
    add_token_to_token_list(token, new_node)
</t>
<t tx="ekr.20191226155316.1">def substitute_values(self, lt_s: str, specs: list[re.Match], values: list[list[Token]]) -&gt; list[Token]:
    """
    Replace specifiers with values in lt_s string.

    Double { and } as needed.
    """
    i, results = 0, [Token('string', 'f')]
    for spec_i, m in enumerate(specs):
        value = tokens_to_string(values[spec_i])
        start, end, spec = m.start(0), m.end(0), m.group(1)
        if start &gt; i:
            val = lt_s[i:start].replace('{', '{{').replace('}', '}}')
            results.append(Token('string', val[0]))
            results.append(Token('string', val[1:]))
        head, tail = self.munge_spec(spec)
        results.append(Token('op', '{'))
        results.append(Token('string', value))
        if head:
            results.append(Token('string', '!'))
            results.append(Token('string', head))
        if tail:
            results.append(Token('string', ':'))
            results.append(Token('string', tail))
        results.append(Token('op', '}'))
        i = end
    # Add the tail.
    tail = lt_s[i:]
    if tail:
        tail = tail.replace('{', '{{').replace('}', '}}')
        results.append(Token('string', tail[:-1]))
        results.append(Token('string', tail[-1]))
    return results
</t>
<t tx="ekr.20191227051737.1">class TestTOG(BaseTest):
    """
    Tests for the TokenOrderGenerator class.

    These tests call BaseTest.make_data, which creates the two-way links
    between tokens and the parse tree.

    The asserts in tog.sync_tokens suffice to create strong unit tests.
    """

    debug_list = [
        # 'tokens', 'tree',
        # 'post-tokens', 'post-tree'
    ]

    @others
</t>
<t tx="ekr.20191227052446.10"></t>
<t tx="ekr.20191227052446.11">def test_ClassDef(self):
    contents = """\
class TestClass1:
    pass

def decorator():
    pass

@decorator
class TestClass2:
    pass

@decorator
class TestClass(base1, base2):
    pass
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.12">def test_ClassDef2(self):
    contents = r'''\
"""ds 1"""
class TestClass:
    """ds 2"""
    def long_name(a, b=2):
        """ds 3"""
        print('done')
'''
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.13">def test_FunctionDef(self):
    contents = r"""\
def run(fileName=None, pymacs=None):
    pass
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.14"></t>
<t tx="ekr.20191227052446.15">def test_attribute(self):
    contents = r"""\
open(os.devnull, "w")
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.16">def test_CompareOp(self):
    contents = r"""\
if a and not b and c:
    pass
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.17">def test_Dict(self):
    contents = r"""\
d = {'a' if x else 'b': True,}
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.18">def test_DictComp(self):
    # leoGlobals.py, line 3028.
    contents = r"""\
d2 = {val: key for key, val in d}
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.19">def test_ListComp(self):
    # ListComp and comprehension.
    contents = r"""\
any([p2.isDirty() for p2 in p.subtree()])
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.20">def test_NameConstant(self):
    contents = r"""\
run(a=None, b=str)
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.21">def test_op_semicolon(self):
    contents = r"""\
print('c');
print('d')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.22">def test_op_semicolon2(self):
    contents = r"""\
a = 1 ; b = 2
print('a') ; print('b')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.23">def test_UnaryOp(self):
    contents = r"""\
print(-(2))
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.32"></t>
<t tx="ekr.20191227052446.33">def test_if1(self):
    # Line 93, leoTips.py
    contents = r"""\
self.make_data(contents)
unseen = [i for i in range(5) if i not in seen]
for issue in data:
    for a in aList:
        print('a')
    else:
        print('b')
if b:
    print('c')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.34">def test_if2(self):
    contents = r"""\
for i, j in b:
    pass
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.35">def test_if3(self):
    contents = r"""\
if -(2):
    pass
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.36">def test_if4(self):
    contents = r"""\
if 1:
    print('a')
elif 2:
    print('b')
elif 3:
    print('c')
    print('d')
print('-')
if 1:
    print('e')
elif 2:
    print('f')
    print('g')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.37">def test_if5(self):
    contents = r"""\
if 1:
    pass
elif 2:
    pass
    pass
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.38">def test_if6(self):
    contents = r"""\
if (a):
    print('a1')
    print('a2')
elif b:
    print('b1')
    print('b2')
else:
    print('c1')
    print('c2')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.39">def test_if7(self):
    contents = r"""\
if 1:
    print('a')
else:
    print('b')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.40">def test_if8(self):
    contents = r"""\
if 1:
    print('a')
else:
    if 2:
        print('b')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.41">def test_if9(self):
    contents = r"""\
if a:
    if b:
        print('b')
else:
    if d:
        print('d')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.42">def test_if10(self):
    contents = r"""\
if 1:
    a = 'class' if cond else 'def'
    # find_pattern = prefix + ' ' + word
    print('1')
else:
    print('2')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.43"></t>
<t tx="ekr.20191227052446.44">def test_Call(self):
    contents = """func(a, b, one='one', two=2, three=4+5, *args, **kwargs)"""
    # contents = """func(*args, **kwargs)"""
# f1(a,b=2)
# f2(1 + 2)
# f3(arg, *args, **kwargs)
# f4(a='a', *args, **kwargs)
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.45">def test_Global(self):
    # Line 1604, leoGlobals.py
    contents = r"""
def spam():
    global gg
    print('')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.46">def test_Try(self):
    contents = r"""\
try:
    print('a1')
    print('a2')
except ImportError:
    print('b1')
    print('b2')
except SyntaxError:
    print('c1')
    print('c2')
finally:
    print('d1')
    print('d2')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.47">def test_Try2(self):
    # Line 240: leoDebugger.py
    contents = r"""\
try:
    print('a')
except ValueError:
    print('b')
else:
    print('c')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.48">def test_With(self):
    # leoGlobals.py, line 1785.
    contents = r"""\
with open(fn) as f:
    pass
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.49">def test_YieldFrom(self):
    # Line 1046, leoAst.py
    contents = r"""\
def gen_test():
    self.node = tree
    yield from self.gen_token('newline', '\n')
    print('done')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.50"></t>
<t tx="ekr.20191227052446.52">def test_escapes(self):
    # Line 4609, leoGlobals.py
    contents = r"""\
print("\x7e" "\0777") # tilde.
print('done')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.53">def test_backslashes(self):
    # leoGlobals.py.
    contents = r'''\
class SherlockTracer:
    """before\\after"""
'''
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.54">def test_bs_nl(self):
    contents = r"""\
print('hello\
world')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.55">def test_bytes(self):
    # Line 201, leoApp.py
    contents = r"""\
print(b'\xfe')
print('done')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.56">def test_empyt_string(self):
    contents = r"""\
self.s = ''
self.i = 0
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.57">def test_escaped_delims(self):
    contents = r"""\
print("a\"b")
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.58">def test_escaped_strings(self):
    contents = r"""\
f1(a='\b', b='\n', t='\t')
f2(f='\f', r='\r', v='\v')
f3(bs='\\')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.59">def test_fstring_join(self):
    # The first newline causes the fail.
    contents = r"""\
print(f"a {old_id!r}\n" "b\n")
print('done')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.60">def test_raw_docstring(self):
    contents = r'''\
# Line 1619 leoFind.py
print(r"""DS""")
'''
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.61">def test_raw_escapes(self):
    contents = r"""\
r1(a=r'\b', b=r'\n', t=r'\t')
r2(f=r'\f', r=r'\r', v=r'\v')
r3(bs=r'\\')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.62">def test_single_quote(self):
    # leoGlobals.py line 806.
    contents = r"""\
print('"')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.63">def test_concatenation_1(self):
    contents = r"""\
print('a' 'b')
print('c')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.64">def test_potential_fstring(self):
    contents = r"""\
print('test %s=%s'%(a, 2))
print('done')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.65"></t>
<t tx="ekr.20191227052446.66">def test_fstring1(self):
    # Line 1177, leoApp.py
    contents = r"""\
print(
    message = f"line 1: {old_id!r}\n" "line 2\n"
)
print('done')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.67">def test_fstring2(self):
    contents = r"""\
func(f"{b if not cond1 else ''}")
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.68">def test_fstring3(self):
    contents = r"""\
print(f'{7.1}')
print('end')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.69">def test_fstring4(self):
    contents = r"""\
print(f'{7.1}' 'p7.2')
print('end')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.70">def test_fstring5(self):
    contents = r"""\
print('p1' f'{f2}')
'end'
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.71">def test_fstring6(self):
    contents = r"""\
print(f'{f1}' f'{f2}')
'end'
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.72">def test_fstring7(self):
    contents = r"""\
print('s1', f'{f2}' f'f3' f'{f4}' 's5')
'end'
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.73">def test_fstring8(self):
    # leoFind.py line 856
    contents = r"""\
a = f"{'a' if x else 'b'}"
f()

# Pass
# print(f"{'a' if x else 'b'}")
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.74">def test_fstring9(self):
    contents = r"""\
func(
    "Isearch"
    f"{' Backward' if True else ''}"
)
print('done')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.75">def test_fstring10(self):
    # leoFind.py: line 861
    contents = r"""\
one(f"{'B'}" ": ")
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.76">def test_fstring11(self):
    contents = r"""\
print(f'x3{e3+1}y3' f'x4{e4+2}y4')
print('done')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.77"># Single f-strings.
# 'p1' ;
# f'f1' ;
# f'x1{e1}y1' ;
# f'x2{e2+1}y2{e2+2}z2' ;

# Concatentated strings...
# 'p2', 'p3' ;
# f'f2' 'f3' ;

# f'x5{e5+1}y5{e5+1}z5' f'x6{e6+1}y6{e6+1}z6' ;
</t>
<t tx="ekr.20191227052446.78">def test_fstring12(self):
    contents = r"""\
print(f'x1{e1}y1', 'p1')
print(f'x2{e2}y2', f'f2')
print(f'x3{e3}y3', f'x4{e4}y4')
print('end')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.79">def test_fstring13(self):
    contents = r"""\
print(f'x1{e1}y1{e2}z1', 'p1')
print(f'x2{e3}y2{e3}z2', f'f2')
print(f'x3{e4}y3{e5}z3', f'x4{e6}y4{e7}z4')
print('end')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.80">def test_fstring14(self):
    contents = r"""\
print(f"{list(z for z in ('a', 'b', 'c') if z != 'b')}")
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.81">def test_fstring15(self):
    contents = r"""\
print(f"test {a}={2}")
print('done')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.82">def test_regex_fstring(self):
    # Line 7709, leoGlobals.py
    contents = r'''\
fr"""{kinds}://[^\s'"]+[\w=/]"""
'''
    self.make_data(contents)
</t>
<t tx="ekr.20191227052446.83">def test_fstring16(self):
    contents = r"""\
'p1' ;
f'f1' ;
'done' ;
"""
    self.make_data(contents)
</t>
<t tx="ekr.20191227054856.1">def make_data(self, contents, description=None):
    """Return (contents, tokens, tree) for the given contents."""
    contents = contents.lstrip('\\\n')
    if not contents:
        return '', None, None  # pragma: no cover
    self.link_error = None
    t1 = get_time()
    self.update_counts('characters', len(contents))
    # Ensure all tests end in exactly one newline.
    contents = textwrap.dedent(contents).rstrip() + '\n'
    # Create the TOG instance.
    self.tog = TokenOrderGenerator()
    self.tog.filename = description or g.callers(2).split(',')[0]
    # Pass 0: create the tokens and parse tree
    tokens = self.make_tokens(contents)
    if not tokens:
        self.fail('make_tokens failed')  # pragma: no cover
    tree = self.make_tree(contents)
    if not tree:
        self.fail('make_tree failed')  # pragma: no cover
    if 'contents' in self.debug_list:
        dump_contents(contents)  # pragma: no cover
    if 'ast' in self.debug_list:  # pragma: no cover
        if py_version &gt;= (3, 9):
            # pylint: disable=unexpected-keyword-arg
            g.printObj(ast.dump(tree, indent=2), tag='ast.dump')
        else:
            g.printObj(ast.dump(tree), tag='ast.dump')
    if 'tree' in self.debug_list:  # Excellent traces for tracking down mysteries.
        dump_ast(tree)  # pragma: no cover
    if 'tokens' in self.debug_list:
        dump_tokens(tokens)  # pragma: no cover
    self.balance_tokens(tokens)
    # Pass 1: create the links.
    self.create_links(tokens, tree)
    if 'post-tree' in self.debug_list:
        dump_tree(tokens, tree)  # pragma: no cover
    if 'post-tokens' in self.debug_list:
        dump_tokens(tokens)  # pragma: no cover
    t2 = get_time()
    self.update_times('90: TOTAL', t2 - t1)
    if self.link_error:
        self.fail(self.link_error)  # pragma: no cover
    return contents, tokens, tree
</t>
<t tx="ekr.20191227075951.1">def test_end_of_line(self):
    self.make_data("""# Only a comment.""")
</t>
<t tx="ekr.20191227103533.1">def make_file_data(self, filename):
    """Return (contents, tokens, tree) from the given file."""
    directory = os.path.dirname(__file__)
    filename = g.finalize_join(directory, '..', '..', 'core', filename)
    assert os.path.exists(filename), repr(filename)
    contents = read_file(filename)
    contents, tokens, tree = self.make_data(contents, filename)
    return contents, tokens, tree
</t>
<t tx="ekr.20191227145620.1"></t>
<t tx="ekr.20191227154302.1">class BaseTest(unittest.TestCase):
    """
    The base class of all tests of leoAst.py.

    This class contains only helpers.
    """

    # Statistics.
    counts: dict[str, int] = {}
    times: dict[str, float] = {}

    # Debugging traces &amp; behavior.
    # create_links: 'full-traceback'
    # make_data: 'contents', 'tokens', 'tree',
    #            'post-tokens', 'post-tree',
    #            'unit-test'
    debug_list: list[str] = []
    link_error: Exception = None

    @others
</t>
<t tx="ekr.20191228095945.1"># Actions should fail by throwing an exception.
</t>
<t tx="ekr.20191228095945.10">def fstringify(self, contents, tokens, tree, filename=None, silent=False):
    """
    BaseTest.fstringify.
    """
    t1 = get_time()
    if not filename:
        filename = g.callers(1)
    fs = Fstringify()
    if silent:
        fs.silent = True
    result_s = fs.fstringify(contents, filename, tokens, tree)
    t2 = get_time()
    self.update_times('21: fstringify', t2 - t1)
    return result_s
</t>
<t tx="ekr.20191228095945.11">def make_tokens(self, contents):
    """
    BaseTest.make_tokens.

    Make tokens from contents.
    """
    t1 = get_time()
    # Tokenize.
    tokens = make_tokens(contents)
    t2 = get_time()
    self.update_counts('tokens', len(tokens))
    self.update_times('01: make-tokens', t2 - t1)
    return tokens
</t>
<t tx="ekr.20191228095945.12">def dump_stats(self):  # pragma: no cover
    """Show all calculated statistics."""
    if self.counts or self.times:
        print('')
        self.dump_counts()
        self.dump_times()
        print('')
</t>
<t tx="ekr.20191228101437.1">def create_links(self, tokens, tree, filename='unit test'):
    """
    BaseTest.create_links.

    Insert two-way links between the tokens and ast tree.
    """
    tog = self.tog
    try:
        t1 = get_time()
        tog.create_links(tokens, tree)
        t2 = get_time()
        self.update_counts('nodes', tog.n_nodes)
        self.update_times('11: create-links', t2 - t1)
    except Exception as e:  # pragma: no cover
        if 'full-traceback' in self.debug_list:
            g.es_exception()
        # Weird: calling self.fail creates ugly failures.
        self.link_error = e
</t>
<t tx="ekr.20191228101601.1"></t>
<t tx="ekr.20191228102101.1">def make_tree(self, contents):
    """
    BaseTest.make_tree.

    Return the parse tree for the given contents string.
    """
    t1 = get_time()
    tree = parse_ast(contents)
    t2 = get_time()
    self.update_times('02: parse_ast', t2 - t1)
    return tree
</t>
<t tx="ekr.20191228154757.1">def dump_counts(self):  # pragma: no cover
    """Show all calculated counts."""
    for key, n in self.counts.items():
        print(f"{key:&gt;16}: {n:&gt;6}")
</t>
<t tx="ekr.20191228154801.1">def dump_times(self):  # pragma: no cover
    """
    Show all calculated times.

    Keys should start with a priority (sort order) of the form `[0-9][0-9]:`
    """
    for key in sorted(self.times):
        t = self.times.get(key)
        key2 = key[3:]
        print(f"{key2:&gt;16}: {t:6.3f} sec.")
</t>
<t tx="ekr.20191228181624.1">def update_counts(self, key, n):  # pragma: no cover
    """Update the count statistic given by key, n."""
    old_n = self.counts.get(key, 0)
    self.counts[key] = old_n + n

def update_times(self, key, t):  # pragma: no cover
    """Update the timing statistic given by key, t."""
    old_t = self.times.get(key, 0.0)
    self.times[key] = old_t + t
</t>
<t tx="ekr.20191228184647.1">def balance_tokens(self, tokens: list[Token]) -&gt; int:
    """
    TOG.balance_tokens.

    Insert two-way links between matching paren tokens.
    """
    count, stack = 0, []
    for token in tokens:
        if token.kind == 'op':
            if token.value == '(':
                count += 1
                stack.append(token.index)
            if token.value == ')':
                if stack:
                    index = stack.pop()
                    tokens[index].matching_paren = token.index
                    tokens[token.index].matching_paren = index
                else:  # pragma: no cover
                    g.trace(f"unmatched ')' at index {token.index}")
    if stack:  # pragma: no cover
        g.trace("unmatched '(' at {','.join(stack)}")
    return count
</t>
<t tx="ekr.20191228185201.1">def balance_tokens(self, tokens):
    """
    BastTest.balance_tokens.

    Insert links between corresponding paren tokens.
    """
    t1 = get_time()
    count = self.tog.balance_tokens(tokens)
    t2 = get_time()
    self.update_counts('paren-tokens', count)
    self.update_times('03: balance-tokens', t2 - t1)
    return count
</t>
<t tx="ekr.20191228193740.1">def test_aaa(self):
    """The first test."""
    g.total_time = get_time()

def test_zzz(self):
    """The last test."""
    t2 = get_time()
    self.update_times('90: TOTAL', t2 - g.total_time)
    # self.dump_stats()
</t>
<t tx="ekr.20191229071733.1">def init_from_file(self, filename: str) -&gt; tuple[str, str, list[Token], Node]:  # pragma: no cover
    """
    Create the tokens and ast tree for the given file.
    Create links between tokens and the parse tree.
    Return (contents, encoding, tokens, tree).
    """
    self.level = 0
    self.filename = filename
    encoding, contents = read_file_with_encoding(filename)
    if not contents:
        return None, None, None, None
    self.tokens = tokens = make_tokens(contents)
    self.tree = tree = parse_ast(contents)
    self.create_links(tokens, tree)
    return contents, encoding, tokens, tree
</t>
<t tx="ekr.20191229071746.1">def init_from_string(self, contents: str, filename: str) -&gt; tuple[list[Token], Node]:  # pragma: no cover
    """
    Tokenize, parse and create links in the contents string.

    Return (tokens, tree).
    """
    self.filename = filename
    self.level = 0
    self.tokens = tokens = make_tokens(contents)
    self.tree = tree = parse_ast(contents)
    self.create_links(tokens, tree)
    return tokens, tree
</t>
<t tx="ekr.20200101030236.1">def tokens_to_string(tokens: list[Token]) -&gt; str:
    """Return the string represented by the list of tokens."""
    if tokens is None:
        # This indicates an internal error.
        print('')
        g.trace('===== token list is None ===== ')
        print('')
        return ''
    return ''.join([z.to_string() for z in tokens])
</t>
<t tx="ekr.20200103174914.1"></t>
<t tx="ekr.20200104032811.1">def leave_node(self, node: Node) -&gt; None:
    """Leave a visitor."""
    # begin_visitor and end_visitor must be paired.
    entry_name = self.begin_end_stack.pop()
    assert entry_name == node.__class__.__name__, f"{entry_name!r} {node.__class__.__name__}"
    assert self.node == node, (repr(self.node), repr(node))
    # Restore self.node.
    self.node = self.node_stack.pop()
</t>
<t tx="ekr.20200107165250.2">def __init__(self, settings: Settings = None):
    """Ctor for Orange class."""
    if settings is None:
        settings = {}
    valid_keys = (
        'allow_joined_strings',
        'max_join_line_length',
        'max_split_line_length',
        'orange',
        'tab_width',
    )
    # For mypy...
    self.kind: str = ''
    # Default settings...
    self.allow_joined_strings = False  # EKR's preference.
    self.max_join_line_length = 88
    self.max_split_line_length = 88
    self.tab_width = 4
    # Override from settings dict...
    for key in settings:  # pragma: no cover
        value = settings.get(key)
        if key in valid_keys and value is not None:
            setattr(self, key, value)
        else:
            g.trace(f"Unexpected setting: {key} = {value!r}")
</t>
<t tx="ekr.20200107175223.1">def beautify(self, contents, tokens, tree, filename=None, max_join_line_length=None, max_split_line_length=None):
    """
    BaseTest.beautify.
    """
    t1 = get_time()
    if not contents:
        return ''  # pragma: no cover
    if not filename:
        filename = g.callers(2).split(',')[0]
    orange = Orange()
    result_s = orange.beautify(contents, filename, tokens, tree,
        max_join_line_length=max_join_line_length,
        max_split_line_length=max_split_line_length)
    t2 = get_time()
    self.update_times('22: beautify', t2 - t1)
    self.code_list = orange.code_list
    return result_s
</t>
<t tx="ekr.20200110092217.1">def check_roundtrip(self, contents):
    """Check that the tokenizer round-trips the given contents."""
    contents, tokens, tree = self.make_data(contents)
    results = tokens_to_string(tokens)
    self.assertEqual(contents, results)
</t>
<t tx="ekr.20200110103036.1">def adjust_expected(self, s):
    """Adjust leading indentation in the expected string s."""
    return textwrap.dedent(s.lstrip('\\\n')).rstrip() + '\n'
</t>
<t tx="ekr.20200110162044.1">def find_next_significant_token(self) -&gt; Optional[Token]:
    """
    Scan from *after* self.tokens[px] looking for the next significant
    token.

    Return the token, or None. Never change self.px.
    """
    px = self.px + 1
    while px &lt; len(self.tokens):
        token = self.tokens[px]
        px += 1
        if is_significant_token(token):
            return token
    # This will never happen, because endtoken is significant.
    return None  # pragma: no cover
</t>
<t tx="ekr.20200111042825.1">def test_string_concatenation_2(self):
    # Crash in leoCheck.py.
    contents = """return self.Type('error', 'no member %s' % ivar)"""
    self.make_data(contents)
</t>
<t tx="ekr.20200111083914.1">def get_concatenated_string_tokens(self) -&gt; list[Token]:
    """
    Return the next 'string' token and all 'string' tokens concatenated to
    it. *Never* update self.px here.
    """
    trace = False
    tag = 'tog.get_concatenated_string_tokens'
    i = self.px
    # First, find the next significant token.  It should be a string.
    i, token = i + 1, None
    while i &lt; len(self.tokens):
        token = self.tokens[i]
        i += 1
        if token.kind == 'string':
            # Rescan the string.
            i -= 1
            break
        # An error.
        if is_significant_token(token):  # pragma: no cover
            break
    # Raise an error if we didn't find the expected 'string' token.
    if not token or token.kind != 'string':  # pragma: no cover
        if not token:
            token = self.tokens[-1]
        filename = getattr(self, 'filename', '&lt;no filename&gt;')
        raise AssignLinksError(
            f"\n"
            f"{tag}...\n"
            f"file: {filename}\n"
            f"line: {token.line_number}\n"
            f"   i: {i}\n"
            f"expected 'string' token, got {token!s}")
    # Accumulate string tokens.
    assert self.tokens[i].kind == 'string'
    results = []
    while i &lt; len(self.tokens):
        token = self.tokens[i]
        i += 1
        if token.kind == 'string':
            results.append(token)
        elif token.kind == 'op' or is_significant_token(token):
            # Any significant token *or* any op will halt string concatenation.
            break
        # 'ws', 'nl', 'newline', 'comment', 'indent', 'dedent', etc.
    # The (significant) 'endmarker' token ensures we will have result.
    assert results
    if trace:  # pragma: no cover
        g.print_obj(results, tag=f"{tag}: Results")
    return results
</t>
<t tx="ekr.20200111171738.1">def test_FunctionDef_with_annotations(self):
    contents = r"""\
def foo(a: 'x', b: 5 + 6, c: list) -&gt; max(2, 9):
    pass
"""
    self.make_data(contents)
    # contents, tokens, tree = self.make_data(contents)
    # dump_ast(tree)
</t>
<t tx="ekr.20200111175043.1">def test_AsyncFunctionDef(self):
    contents = """\
@my_decorator
async def count() -&gt; 42:
    print("One")
    await asyncio.sleep(1)
"""
    self.make_data(contents)
</t>
<t tx="ekr.20200111175335.1">def test_For(self):
    contents = r"""\
for a in b:
    pass
"""
    self.make_data(contents)
</t>
<t tx="ekr.20200111191153.1">def test_Dict_2(self):
    contents = r"""\
d = {}
"""
    self.make_data(contents)
</t>
<t tx="ekr.20200111194454.1">def test_Set(self):
    contents = """{'a', 'b'}"""
    self.make_data(contents)
</t>
<t tx="ekr.20200111195654.1">def test_SetComp(self):
    contents = """aSet = { (x, y) for x in r for y in r if x &lt; y }"""
    self.make_data(contents)
</t>
<t tx="ekr.20200111200424.1">def test_ImportFrom(self):
    contents = r"""from a import b as c"""
    self.make_data(contents)
</t>
<t tx="ekr.20200111200640.1">def test_Nonlocal(self):
    contents = r"""nonlocal name1, name2"""
    self.make_data(contents)
</t>
<t tx="ekr.20200112042410.1">def test_ExtSlice(self):
    contents = r"""a [1, 2: 3]"""
    self.make_data(contents)
</t>
<t tx="ekr.20200112065944.1">def test_ellipsis_1(self):
    contents = """
def spam():
    ...
"""
    self.make_data(contents)
</t>
<t tx="ekr.20200112070228.1">def test_ellipsis_2(self):
    contents = """
def partial(func: Callable[..., str], *args):
    pass
"""
    self.make_data(contents)
</t>
<t tx="ekr.20200112071833.1">def test_AsyncFor(self):
    # This may require Python 3.7.
    contents = """\
async def commit(session, data):
    async for z in session.transaction():
        await z(data)
    else:
        print('oops')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20200112073151.1">def test_AsyncWith(self):
    contents = """\
async def commit(session, data):
    async with session.transaction():
        await session.update(data)
"""
    self.make_data(contents)
</t>
<t tx="ekr.20200112075707.1">def test_AnnAssign(self):
    contents = """x: int = 0"""
    self.make_data(contents)
</t>
<t tx="ekr.20200206040424.1">def test_Lambda(self):

    # Coverage test for spaces
    contents = """f = lambda x: x"""
    self.make_data(contents)
</t>
<t tx="ekr.20200206040732.1">def test_Delete(self):

    # Coverage test for spaces
    contents = """del x"""
    self.make_data(contents)
</t>
<t tx="ekr.20200206041336.1">def test_While(self):
    contents = r"""\
while f():
    print('continue')
else:
    print('done')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20200206041611.1">def test_Yield(self):
    contents = r"""\
def gen_test():
    yield self.gen_token('newline', '\n')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20200206041753.1">def test_comment_in_set_links(self):
    contents = """
def spam():
    # comment
    pass
"""
    self.make_data(contents)
</t>
<t tx="ekr.20200212095937.1"></t>
<t tx="ekr.20200212095937.2">True:  allow joined lines to contain strings.
False: (Recommended by EKR): Retain alignment of strings.</t>
<t tx="ekr.20200212095937.3">True: Retain indentation of overindented stand-alone comment lines.</t>
<t tx="ekr.20200212095937.5"># At present I am of the opinion that joining lines is usually a bad idea.

Should be &lt;= beautify-max-split-line-length.
Zero suppresses all line joining.</t>
<t tx="ekr.20200212095937.6">Zero suppresses all line splitting.</t>
<t tx="ekr.20200222083959.1">import logging
rootLogger = logging.getLogger('')
rootLogger.setLevel(logging.DEBUG)
socketHandler = logging.handlers.SocketHandler(
    'localhost',
    logging.handlers.DEFAULT_TCP_LOGGING_PORT,
)
rootLogger.addHandler(socketHandler)
logging.info('-' * 20)
</t>
<t tx="ekr.20200222151754.1">import yoton

# Create another context and a sub channel
ct2 = yoton.Context()
sub = yoton.SubChannel(ct2, 'chat')

# Connect
ct2.connect('publichost:test')

# Receive
while True:
    i = int(sub.recv())
    print(i)
    if i == 10:
        break
</t>
<t tx="ekr.20200308193719.1">d = {}  # Keys are gnxs, values is a list of vnodes with that gnx.
for v in c.all_nodes():
    gnx = v.gnx
    aList = d.get(gnx, [])
    if v not in aList:
        aList.append(v)
        d [gnx] = aList
        if len(aList) &gt; 1:
            print(f"gnx clash: {gnx}")
            g.printObj(aList)
print('done')</t>
<t tx="ekr.20200422075655.1">@g.commander_command('restart-leo')
def restartLeo(self: Self, event: Event = None) -&gt; None:
    """Restart Leo, reloading all presently open outlines."""
    c, lm = self, g.app.loadManager
    trace = 'shutdown' in g.app.debug
    # Write .leoRecentFiles.txt.
    g.app.recentFilesManager.writeRecentFilesFile(c)
    # Abort the restart if the user veto's any close.
    for c in g.app.commanders():
        if c.changed:
            veto = False
            try:
                c.promptingForClose = True
                veto = c.frame.promptForSave()
            finally:
                c.promptingForClose = False
            if veto:
                g.es_print('Cancelling restart-leo command')
                return
    # Officially begin the restart process. A flag for efc.ask.
    g.app.restarting = True
    # Save session data.
    g.app.saveSession()
    # Close all unsaved outlines.
    g.app.setLog(None)  # Kill the log.
    for c in g.app.commanders():
        frame = c.frame
        # This is similar to g.app.closeLeoWindow.
        g.doHook("close-frame", c=c)
        # Save the window state
        g.app.commander_cacher.commit()  # store cache, but don't close it.
        # This may remove frame from the window list.
        if frame in g.app.windowList:
            g.app.destroyWindow(frame)
            g.app.windowList.remove(frame)
        else:
            # #69.
            g.app.forgetOpenFile(fn=c.fileName())
    # Complete the shutdown.
    g.app.finishQuit()
    # Restart, restoring the original command line.
    args = ['-c'] + lm.old_argv
    if trace:
        g.trace('restarting with args', args)
    sys.stdout.flush()
    sys.stderr.flush()
    os.execv(sys.executable, args)
</t>
<t tx="ekr.20200810074755.1">def isValidLanguage(language: str) -&gt; bool:
    """True if the given language may be used as an external file."""
    return bool(language and language in g.app.language_delims_dict)
</t>
<t tx="ekr.20201012111338.28">def _from_dict_recursive(self, top, d):
    """see from_dict()"""
    top.h = d['h']
    top.b = d['b']
    top.u = d['u']
    top.children[:] = []
    for child in d['children']:
        top.children.append(self._from_dict_recursive(vnode(self.c), child))
    return top

</t>
<t tx="ekr.20201012111545.1">@language python
@tabwidth -4
@pagewidth 80
</t>
<t tx="ekr.20201012114516.1"></t>
<t tx="ekr.20201013034659.1"></t>
<t tx="ekr.20201013034742.10"># These can be overridden in subclasses.
</t>
<t tx="ekr.20201013034742.11"># Define an override if desired...

if 0: # The base class
    def clean_headline(self, s):
        """Return a cleaned up headline s."""
        return s.strip()
        
if 0: # A more complex example, for the C language.
    def clean_headline(self, s):
        """Return a cleaned up headline s."""
        import re
        type1 = r'(static|extern)*'
        type2 = r'(void|int|float|double|char)*'
        class_pattern = r'\s*(%s)\s*class\s+(\w+)' % (type1)
        pattern = r'\s*(%s)\s*(%s)\s*(\w+)' % (type1, type2)
        m = re.match(class_pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            return '%sclass %s' % (prefix1, m.group(2))
        m = re.match(pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            prefix2 = '%s ' % (m.group(2)) if m.group(2) else ''
            h = m.group(3) or '&lt;no c function name&gt;'
            return '%s%s%s' % (prefix1, prefix2, h)
        else:
            return s
</t>
<t tx="ekr.20201013034742.12">def clean_nodes(self, parent):
    """
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an examplle.
    """
    pass
</t>
<t tx="ekr.20201013034742.13">class {{cap_name}}_ScanState:
    """A class representing the state of the {{name}} line-oriented scan."""
    
    def __init__(self, d=None):
        """{{cap_name}}_ScanState.__init__"""
        if d:
            prev = d.get('prev')
            self.context = prev.context
            # Adjust these by hand.
            self.curlies = prev.curlies
        else:
            self.context = ''
            # Adjust these by hand.
            self.curlies = 0

    def __repr__(self):
        """{{cap_name}}_ScanState.__repr__"""
        # Adjust these by hand.
        return "{{cap_name}}_ScanState context: %r curlies: %s" % (
            self.context, self.curlies)

    __str__ = __repr__

    @others
</t>
<t tx="ekr.20201013034742.16">"""Converts the word at the cursor to pep8 style throughout a given tree."""
# aTestExample notFoundExample.
import re
# clear()
table = (
    # 'BLS.new_scan',
    # 'BLS.Code generation',
    # 'class Importer',
)
@others
Pep8(table, change=True).run()
</t>
<t tx="ekr.20201013034742.17">class Pep8:
    """
    Convert the word under the cursor to pep8 style in all subtrees in
    table.
    """
    
    def __init__ (self, table, change=False):
        """Ctor for Pep8 class."""
        self.change = change
        self.table = table
        
    @others
</t>
<t tx="ekr.20201013034742.18">def change_all(self, name, new_name, root):
    """Change name to new_name throughout root's tree."""
    u = c.undoer
    bunch = u.beforeChangeTree(root)
    found = False
    self.pattern = re.compile(r'\b%s\b' % name)
    for p in root.self_and_subtree():
        found = self.change_headline(name, new_name, p) or found
        found = self.change_body(name, new_name, p) or found
    if found:
        u.afterChangeTree(root, 'pep8', bunch)
    return found
</t>
<t tx="ekr.20201013034742.19">def change_body(self, name, new_name, p):
    indices = []
    for m in self.pattern.finditer(p.b):
        indices.append(str(m.start()))
    if indices:
        n = len(indices)
        g.es_print('%s change%s: %s' % (n, g.plural(n), p.h))
        s = p.b
        for i in reversed(indices):
            i = int(i)
            s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.b = s
            p.setDirty()
        else:
            g.es_print(s)
    return bool(indices)</t>
<t tx="ekr.20201013034742.2">g.cls()
# define constants that describe the new language.
name = 'php'  # The name of the file, and the prefix for classes.
language = 'php'  # The name of the language, case doesn't matter.
extensions = ['.php',]  # A list of file extensions supported by this importer.
strict = False  # True if leading whitespace is particularly significant.
state_ivar = 'self.curlies'
    # 'self.indent' for python, coffeescript.
    # 'self.curlies' for many other languages
    # '(self, curlies, self.parens)' for more complex comparisons
&lt;&lt; define run &amp; helpers &gt;&gt;
run(extensions, language, name, state_ivar)
</t>
<t tx="ekr.20201013034742.20">def change_headline(self, name, new_name, p):
    m = self.pattern.search(p.h)
    if m:
        i = m.start()
        s = p.h
        s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.h = s
            p.setDirty()
            g.es_print('changed headline', s)
        else:
            g.es_print('headline', s)
    return bool(m)
</t>
<t tx="ekr.20201013034742.21">def get_name(self):
    i, j = c.editCommands.extendToWord(event=None, select=False)
    w = c.frame.body.wrapper
    s = w.getAllText()
    name = s[i:j]
    return name
</t>
<t tx="ekr.20201013034742.22">def run(self):
    # self.clear()
    name = self.get_name()
    new_name = self.to_pep8(name)
    if len(name) &lt; 2:
        g.es_print('name too short:', name)
    elif new_name == name:
        g.es_print('already pep8:', name)
    else:
        g.es_print('%s -&gt; %s' % (name, new_name))
        # Preload the replacement text.
        c.findCommands.ftm.set_find_text(new_name)
        found = False
        for target in table:
            root = g.findNodeAnywhere(c, target)
            if root:
                found = self.change_all(name, new_name, root) or found
            else:
                g.es_print('not found: %s' % target)
        if found:
            c.redraw()
        else:
            g.es_print('not found:', name)
</t>
<t tx="ekr.20201013034742.23">def to_pep8(self, s):
    
    if len(s) &gt; 1 and s[0].islower() and s.lower() != s:
        result = []
        for ch in s:
            result.append(ch)
            if ch.isupper():
                result.pop()
                result.append('_%s' % (ch.lower()))
        return ''.join(result)
    else:
        return name</t>
<t tx="ekr.20201013034742.24">def clear():
    g.cls()
    c.k.simulateCommand('clear-log')
</t>
<t tx="ekr.20201013034742.3">@others</t>
<t tx="ekr.20201013034742.4">def copy_tree(source, root, h):
    """Copy the source tree to the node after p, with headline h."""
    p2 = root.insertAfter()
    source.copyTreeFromSelfTo(p2)
    p2.h = h
    return p2
 </t>
<t tx="ekr.20201013034742.5">def make_substitutions(destination, patterns):
    """Make all substitutions in the destination tree."""
    for p in destination.self_and_subtree():
        h = substitute(p.h, patterns)
        if p.h != h:
            p.h = h
        b = substitute(p.b, patterns)
        if p.b != b:
            p.b = b
</t>
<t tx="ekr.20201013034742.6">def run(extensions, language, name, state_ivar):
    """The driver for this script."""
    patterns = {
        'cap_name': name.capitalize(),
        'extensions': '[%s]' % ', '.join(["'%s'" % (z) for z in extensions]),
        'language': language.lower(),
        'name': name.lower(),
        'strict': 'True' if strict else 'False',
        'state_ivar': state_ivar,
    }
    h = '@button make-importer'
    root = g.findNodeAnywhere(c, h)
    assert root, h
    h = '@@file importers/{{name}}.py'
    source = g.findNodeInTree(c, root, h)
    assert source, h
    destination = copy_tree(source, root, h)
    make_substitutions(destination, patterns)
    c.contractAllHeadlines()
    c.redraw()</t>
<t tx="ekr.20201013034742.7">def substitute(s, patterns):
    """Make all substitutions in s."""
    for pattern in patterns:
        find = '{{%s}}' % pattern
        replace = patterns.get(pattern)
        i = 0
        while i &lt; len(s):
            progress = i
            j = s.find(find, i)
            if j == -1: break
            s = s[:j] + replace + s[j+len(find):]
            i = j+len(replace)
            assert progress &lt; i
    return s
</t>
<t tx="ekr.20201013034742.8">"""The @auto importer for the {{name}} language."""
import leo.plugins.importers.linescanner as linescanner
Importer = linescanner.Importer
@others
importer_dict = {
    'class': {{cap_name}}_Importer,
    'extensions': {{extensions}},
}
@language python
@tabwidth -4


</t>
<t tx="ekr.20201013034742.9">class {{cap_name}}_Importer(Importer):
    """The importer for the {{name}} lanuage."""

    def __init__(self, c):
        """{{cap_name}}_Importer.__init__"""
        # Init the base class.
        Importer.__init__(self,
            c,
            language = '{{language}}',
        )
        
    @others
</t>
<t tx="ekr.20201015145257.1">import leo.core.leoImport as leoImport
import importlib
importlib.reload(leoImport)
g.cls()
# Change path as necessary.
path = r'c:\users\edreamleo\lsa.py'
assert g.os_path_exists(path)
x = leoImport.LegacyExternalFileImporter(c)
x.import_file(path)
</t>
<t tx="ekr.20201018062305.1">"""
Overwrite LeoPyRef.leo from the given list of nodes.

This script will delete any nodes that are in LeoPyRef.leo but not in
leoPy.leo.

"""
# Do not use this script—it creates huge diffs.
import io
import os
@others
main(node_list = ['Startup', 'Notes', 'Script files', 'Code'])
</t>
<t tx="ekr.20201018063747.1">def put_content(positions_list):
    """
    Return the desired contents of leoPyRef.leo.
    
    Based on code by Виталије Милошевић.
    """
    fc = c.fileCommands
    # Make only a few copies.
    p = c.rootPosition().copy()
    fc.currentPosition = p.copy()
    fc.rootPosition = p.copy()
    old_vnodesDict = fc.vnodesDict  # Save.
    fc.vnodesDict = {}
    try:
        # Put the file
        fc.outputFile = io.StringIO()
        put_prolog()  # Put prolog w/o the stylesheet.
        fc.putHeader()
        fc.putGlobals()
        fc.putPrefs()
        fc.putFindSettings()
        fc.put("&lt;vnodes&gt;\n")
        for p in positions_list:
            # An optimization: Write the next top-level node.
            fc.put_v_element(p, isIgnore=p.isAtIgnoreNode())
        fc.put("&lt;/vnodes&gt;\n")
        put_tnodes(positions_list)  # Put only *required* tnodes.
        fc.putPostlog()
        s = fc.outputFile.getvalue()
    finally:
        fc.outputFile = None
        fc.vnodesDict = old_vnodesDict  # Restore!
    return s
</t>
<t tx="ekr.20201018065757.1">def check_file_names():
    """Return True if leoPyRef exists and we are running from leoPy.leo."""
    if not 'leoPy.leo' in c.shortFileName():
        oops('Run this script only from leoPy.leo')
        return None
    fileName = g.finalize_join(g.app.loadDir, '..', 'core', 'leoPyRef.leo')
    if not os.path.exists(fileName):
        oops(f"Not found: {fileName}")
        return None
    return fileName</t>
<t tx="ekr.20201018065921.1">def check_nodes(node_list):
    """Return True if all nodes are found."""
    result = []
    for node in node_list:
        p = g.findTopLevelNode(c, node, exact=True)
        if p:
            result.append(p.copy())
        else:
            oops(f"Top-level node {node} not found")
            return []
    return result</t>
<t tx="ekr.20201018070822.1">def main(node_list):
    """The main line."""
    c.endEditing()
    fileName = check_file_names()
    if not fileName:
        return  # Error.
    positions_list = check_nodes(node_list)
    if not positions_list:
        return  # Error.
    content = put_content(positions_list)
    if not content:
        return  # Error.
    with open(fileName, 'w', encoding="utf-8", newline='\n') as f:
        f.write(content)
    print('')
    g.es_print(f"Updated {g.shortFileName(fileName)}")
</t>
<t tx="ekr.20201018072911.1">def oops(message):
    """Print an error message"""
    print('')
    g.es_print(message)
    print('')</t>
<t tx="ekr.20201107145642.1">def afterChangeHeadline(self, p: Position, command: str, bunch: g.Bunch) -&gt; None:
    """Create an undo node using d created by beforeChangeHeadline."""
    u = self
    if u.redoing or u.undoing:
        return  # pragma: no cover
    #
    # Set the type &amp; helpers.
    bunch.kind = 'headline'
    bunch.undoType = command
    bunch.undoHelper = u.undoChangeHeadline
    bunch.redoHelper = u.redoChangeHeadline
    bunch.newHead = p.h
    u.pushBead(bunch)

afterChangeHead = afterChangeHeadline
</t>
<t tx="ekr.20201107145859.1">def beforeChangeHeadline(self, p: Position) -&gt; g.Bunch:
    """
    Return data that gets passed to afterChangeNode.

    The oldHead kwarg works around a Qt difficulty when changing headlines.
    """
    u = self
    bunch = u.createCommonBunch(p)
    bunch.oldHead = p.h
    return bunch

beforeChangeHead = beforeChangeHeadline
</t>
<t tx="ekr.20201107150041.1">def undoChangeHeadline(self) -&gt; None:
    """Undo a change to a node's headline."""
    c, u = self.c, self
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    c.frame.body.recolor(u.p)
    u.p.initHeadString(u.oldHead)
    # This is required. Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.oldHead)
</t>
<t tx="ekr.20201107150619.1">def redoChangeHeadline(self) -&gt; None:
    c, u = self.c, self
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    c.frame.body.recolor(u.p)
    # Restore the headline.
    u.p.initHeadString(u.newHead)
    # This is required. Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.newHead)
</t>
<t tx="ekr.20201109074740.1">def beforeChangeBody(self, p: Position) -&gt; g.Bunch:
    """Return data that gets passed to afterChangeBody."""
    w = self.c.frame.body.wrapper
    bunch = self.createCommonBunch(p)  # Sets u.oldMarked, u.oldSel, u.p
    bunch.oldBody = p.b
    bunch.oldHead = p.h
    bunch.oldIns = w.getInsertPoint()
    bunch.oldYScroll = w.getYScrollPosition()
    return bunch
</t>
<t tx="ekr.20201109075104.1">def afterChangeBody(self, p: Position, command: str, bunch: g.Bunch) -&gt; None:
    """
    Create an undo node using d created by beforeChangeNode.

    *Important*: Before calling this method, caller must:
    - Set p.v.b. (Setting p.b would cause a redraw).
    - Set the desired selection range and insert point.
    - Set the y-scroll position, if desired.
    """
    c = self.c
    u, w = self, c.frame.body.wrapper
    if u.redoing or u.undoing:
        return  # pragma: no cover
    # Set the type &amp; helpers.
    bunch.kind = 'body'
    bunch.undoType = command
    bunch.undoHelper = u.undoChangeBody
    bunch.redoHelper = u.redoChangeBody
    bunch.newBody = p.b
    bunch.newHead = p.h
    bunch.newIns = w.getInsertPoint()
    bunch.newMarked = p.isMarked()
    # Careful: don't use ternary operator.
    if w:
        bunch.newSel = w.getSelectionRange()
    else:
        bunch.newSel = 0, 0  # pragma: no cover
    bunch.newYScroll = w.getYScrollPosition() if w else 0
    u.pushBead(bunch)
    #
    if g.unitTesting:
        assert command.lower() != 'typing', g.callers()
    elif command.lower() == 'typing':  # pragma: no cover
        g.trace(
            'Error: undoType should not be "Typing"\n'
            'Call u.doTyping instead')
    u.updateAfterTyping(p, w)
</t>
<t tx="ekr.20201109080631.1">def undoChangeBody(self) -&gt; None:
    """
    Undo all changes to the contents of a node,
    including headline and body text, and marked bits.
    """
    c, u, w = self.c, self, self.c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:
        c.selectPosition(u.p)
    u.p.setDirty()
    u.p.b = u.oldBody
    u.p.h = u.oldHead
    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.oldHead)
    if u.oldMarked:
        u.p.setMarked()
    else:
        u.p.clearMarked()
    if u.groupCount == 0:
        w.setAllText(u.oldBody)
        i, j = u.oldSel
        w.setSelectionRange(i, j, insert=u.oldIns)
        w.setYScrollPosition(u.oldYScroll)
        c.frame.body.recolor(u.p)
    u.updateMarks('old')
</t>
<t tx="ekr.20201109080732.1">def redoChangeBody(self) -&gt; None:
    c, u, w = self.c, self, self.c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
    u.p.setDirty()
    u.p.b = u.newBody
    u.p.h = u.newHead
    # This is required so. Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.newHead)
    if u.newMarked:
        u.p.setMarked()
    else:
        u.p.clearMarked()
    if u.groupCount == 0:
        w.setAllText(u.newBody)
        i, j = u.newSel
        w.setSelectionRange(i, j, insert=u.newIns)
        w.setYScrollPosition(u.newYScroll)
        c.frame.body.recolor(u.p)
    u.updateMarks('new')
    u.p.setDirty()
</t>
<t tx="ekr.20201127035748.1">def updateAfterTyping(self, p: Position, w: Wrapper) -&gt; None:
    """
    Perform all update tasks after changing body text.

    This is ugly, ad-hoc code, but should be done uniformly.
    """
    c = self.c
    if g.isTextWrapper(w):
        # An important, ever-present unit test.
        if p == c.p:
            all = w.getAllText()
            if g.unitTesting:
                assert p.b == all, (w, g.callers())
            elif p.b != all:
                g.trace(
                    f"\np.b != w.getAllText() p: {p.h} \n"
                    f"w: {w!r} \n{g.callers()}\n")
        p.v.insertSpot = ins = w.getInsertPoint()
        # From u.doTyping.
        newSel = w.getSelectionRange()
        if newSel is None:
            p.v.selectionStart, p.v.selectionLength = (ins, 0)
        else:
            i, j = newSel
            p.v.selectionStart, p.v.selectionLength = (i, j - i)
    else:
        if g.unitTesting:
            assert False, f"Not a text wrapper: {g.callers()}"  # noqa
        g.trace('Not a text wrapper')
        p.v.insertSpot = 0
        p.v.selectionStart, p.v.selectionLength = (0, 0)
    if not p.isDirty():
        p.setDirty()
    if not c.isChanged():
        c.setChanged()
    # Update editors.
    c.frame.body.updateEditors()
    # Update icons.
    val = p.computeIcon()
    if not hasattr(p.v, "iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
    if p == c.p:
        # Recolor the body.
        c.frame.scanForTabWidth(p)  # Calls frame.setTabWidth()
        c.recolor()
        w.setFocus()
</t>
<t tx="ekr.20201202144529.1"></t>
<t tx="ekr.20201208114843.1"># No longer needed. Use the git-diff-pr command.
import leo.commands.editFileCommands as efc
x = efc.GitDiffController(c)
x.diff_pull_request()
</t>
<t tx="ekr.20201208115447.1">def diff_pull_request(self) -&gt; None:
    """
    Create a Leonine version of the diffs that would be
    produced by a pull request between two branches.
    """
    directory = self.get_parent_of_git_directory()
    if not directory:
        return
    aList = g.execGitCommand("git rev-parse devel", directory)
    if aList:
        devel_rev = aList[0]
        devel_rev = devel_rev[:8]
        g.trace('devel_rev', devel_rev)
        self.diff_two_revs(
            rev1=devel_rev,  # Before: Latest devel commit.
            rev2='HEAD',  # After: Latest branch commit
        )
    else:
        g.es_print('FAIL: git rev-parse devel')
</t>
<t tx="ekr.20201215050832.1">def make_leo_outline(self, fn: str, path: str, s: str, rev: str) -&gt; Cmdr:
    """Create a hidden temp outline for the .leo file in s."""
    hidden_c = leoCommands.Commands(fn, gui=g.app.nullGui)
    hidden_c.frame.createFirstTreeNode()
    root = hidden_c.rootPosition()
    root.h = fn + ':' + rev if rev else fn
    hidden_c.fileCommands.getLeoFile(
        theFile=io.StringIO(initial_value=s),
        fileName=path,
        readAtFileNodesFlag=False,
        silent=False,
        checkOpenFiles=False,
    )
    return hidden_c
</t>
<t tx="ekr.20201222095250.1">g.cls()
import glob
import os
theme_dir = os.path.join(g.app.loadDir, '..', 'themes')
assert os.path.exists(theme_dir), repr(theme_dir)
paths = glob.glob(f"{theme_dir}{os.sep}*.leo")

def clean(s):
    return s.strip().replace('-','').replace('_','').replace(' ','')
    
for path in paths:
    d = {}
    c = g.createHiddenCommander(path)
    sfn = c.shortFileName()
    if sfn == 'old_themes.leo':
        continue
    print('checking ', sfn)
    for p in c.all_unique_positions():
        h = clean(p.h)
        if h.startswith('@'):
            if h in d:
                print(f"  {sfn:20}: duplicate {h}")
            else:
                d [h] = True
print('done')</t>
<t tx="ekr.20210110092457.1">@language python
@nosearch
</t>
<t tx="ekr.20210110092457.5">g.cls()
import os
os.chdir(os.path.join(g.app.loadDir, '..', '..'))
# os.system('py-cov-find')
command = r'pytest --cov-report html --cov-report term-missing --cov leo.core.leoFind leo\core\leoFind.py'
os.system(command)
g.es_print('done')</t>
<t tx="ekr.20210110092457.6">import os
# os.system('moz htmlcov/leo_core_leoFind_py.html')
os.chdir(os.path.join(g.app.loadDir, '..', '..'))
os.system('moz htmlcov/leo_core_leoFind_py.html')</t>
<t tx="ekr.20210110092457.7">g.cls()
import os
os.system('python -m unittest leoFind.py')
g.es_print('done')</t>
<t tx="ekr.20210118013157.1">"""
Convert defs in LeoFind to pep8 names.
- Don't change defs containing underscores.
- Check for existing target.
"""
g.cls()
import re
h = 'class LeoFind (LeoFind.py)'
root = g.findNodeAnywhere(c, h)
@others
if root:
    main(root)
else:
    print('not found:', root)</t>
<t tx="ekr.20210118013807.1">def main(root):
    pattern = re.compile(r'^def\s+(\w+)', re.MULTILINE)
    for pass_n in (0, 1):
        n = 0
        for p in root.subtree():
            for m in re.finditer(pattern, p.b):
                target = m.group(0)
                old_func = m.group(1)
                if '_' in target:
                    continue
                if target.islower():
                    continue
                if old_func == 'finishCreate':  # Special case.
                    return
                new_func = new_name(old_func)
                if new_func == old_func:
                    continue
                if pass_n == 0:
                    if exists(new_func, root):
                        g.trace(f"already exists: {old_func} {new_func}")
                        g.trace('aborting')
                        return
                else:
                    n += 1
                    convert(old_func, new_func, root)
    g.trace(f"converted {n} function names")
    c.redraw()
            </t>
<t tx="ekr.20210118020530.1">def new_name(s):
    """Return the new name of s."""
    assert ' ' not in s
    # Convert s to underscore style.
    result = []
    for i, ch in enumerate(s):
        if i &gt; 0 and ch.isupper():
            result.append('_')
        result.append(ch.lower())
    return ''.join(result).replace('i_search', 'isearch')
</t>
<t tx="ekr.20210118021337.1">def exists(s, root):
    """Return True if s exists in any of root's nodes."""
    for p in root.self_and_subtree():
        if s in p.b:
            return True
    return False</t>
<t tx="ekr.20210118024739.1">def convert(old_func, new_func, root):
    print(f"{old_func} =&gt; {new_func}\n")
    for p in root.subtree():
        pattern = rf"\b{old_func}\b"
        p.h = re.sub(pattern, new_func, p.h)
        p.b = re.sub(pattern, new_func, p.b)
        # g.printObj(g.splitLines(s2), tag='p.h')
    print('')</t>
<t tx="ekr.20210307060752.1">class ConvertAtRoot:
    """
    A class to convert @root directives to @clean nodes:

    - Change @root directive in body to @clean in the headline.
    - Make clones of section references defined outside of @clean nodes,
      moving them so they are children of the nodes that reference them.
    """

    errors = 0
    root = None  # Root of @root tree.
    root_pat = re.compile(r'^@root\s+(.+)$', re.MULTILINE)
    section_pat = re.compile(r'\s*&lt;\&lt;(.+)&gt;\&gt;')
    units: list[Position] = []  # List of positions containing @unit.

    @others
</t>
<t tx="ekr.20210307060752.2">def convert_file(self, c: Cmdr) -&gt; None:
    """Convert @root to @clean in the the .leo file at the given path."""
    self.find_all_units(c)
    for p in c.all_positions():
        m = self.root_pat.search(p.b)
        path = m and m.group(1)
        if path:
            # Weird special case. Don't change section definition!
            if self.section_pat.match(p.h):
                print(f"\nCan not create @clean node: {p.h}\n")
                self.errors += 1
            else:
                self.root = p.copy()
                p.h = f"@clean {path}"
            self.do_root(p)
            self.root = None
    #
    # Check the results.
    link_errors = c.checkOutline()
    self.errors += link_errors
    print(f"{self.errors} error{g.plural(self.errors)} in {c.shortFileName()}")
    c.redraw()
    # if not self.errors: self.dump(c)
</t>
<t tx="ekr.20210307075117.1">def do_root(self, p: Position) -&gt; None:
    """
    Make all necessary clones for section definitions.
    """
    for p in p.self_and_subtree():
        self.make_clones(p)
</t>
<t tx="ekr.20210307075325.1">def make_clones(self, p: Position) -&gt; None:
    """Make clones for all undefined sections in p.b."""
    for s in g.splitLines(p.b):
        m = self.section_pat.match(s)
        if m:
            section_name = g.angleBrackets(m.group(1).strip())
            section_p = self.make_clone(p, section_name)
            if not section_p:
                print(f"MISSING: {section_name:30} {p.h}")
                self.errors += 1
</t>
<t tx="ekr.20210307080500.1">def make_clone(self, p: Position, section_name: str) -&gt; Optional[Position]:
    """Make c clone for section, if necessary."""

    def clone_and_move(parent: Position, section_p: Position) -&gt; None:
        clone = section_p.clone()
        if self.check_clone_move(clone, parent):
            print(f"  CLONE: {section_p.h:30} parent: {parent.h}")
            clone.moveToLastChildOf(parent)
        else:
            print(f"Can not clone: {section_p.h:30} parent: {parent.h}")
            clone.doDelete()
            self.errors += 1
    #
    # First, look in p's subtree.
    section_p = self.find_section(p, section_name)
    if section_p:
        # g.trace('FOUND', section_name)
        # Already defined in a good place.
        return section_p
    #
    # Finally, look in the @unit tree.
    for unit_p in self.units:
        section_p = self.find_section(unit_p, section_name)
        if section_p:
            clone_and_move(p, section_p)
            return section_p
    return None
</t>
<t tx="ekr.20210307082125.1">def find_section(self, root: Position, section_name: str) -&gt; Optional[Position]:
    """Find the section definition node in root's subtree for the given section."""

    def munge(s: str) -&gt; str:
        return s.strip().replace(' ', '').lower()

    for p in root.subtree():
        if munge(p.h).startswith(munge(section_name)):
            return p
    return None
</t>
<t tx="ekr.20210307085034.1">def find_all_units(self, c: Cmdr) -&gt; None:
    """Scan for all @unit nodes."""
    for p in c.all_positions():
        if '@unit' in p.b:
            self.units.append(p.copy())
</t>
<t tx="ekr.20210308044128.1">def check_clone_move(self, p: Position, parent: Position) -&gt; bool:
    """
    Return False if p or any of p's descendants is a clone of parent
    or any of parents ancestors.
    """
    # Like as checkMoveWithParentWithWarning without warning.
    clonedVnodes = {}
    for ancestor in parent.self_and_parents(copy=False):
        if ancestor.isCloned():
            v = ancestor.v
            clonedVnodes[v] = v
    if not clonedVnodes:
        return True
    for p in p.self_and_subtree(copy=False):
        if p.isCloned() and clonedVnodes.get(p.v):
            return False
    return True
</t>
<t tx="ekr.20210308045306.1">def dump(self, c: Cmdr) -&gt; None:
    print(f"Dump of {c.shortFileName()}...")
    for p in c.all_positions():
        print(' ' * 2 * p.level(), p.h)
</t>
<t tx="ekr.20210311154956.1">@cmd('copy-gnx')
@cmd('gnx-show')
@cmd('show-gnx')
def copyGnx(self, event: Event) -&gt; None:
    """Copy c.p.gnx to the clipboard and display a gnx-oriented unl in the status area."""
    c = self.c
    if not c:
        return
    p = c.p
    if not p:
        return
    url = p.get_UNL()
    g.app.gui.replaceClipboardWith(url)
    status_line = getattr(c.frame, "statusLine", None)
    if status_line:
        status_line.put(url)
</t>
<t tx="ekr.20210316085413.2">def leojs_vnode(self, p: Position, gnxSet: Any, isIgnore: bool = False) -&gt; dict[str, Any]:
    """Return a jsonized vnode."""
    c = self.c
    fc = self
    v = p.v
    # Precompute constants.
    # Write the entire @edit tree if it has children.
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip() and not p.hasChildren()
    isFile = p.isAtFileNode()
    isShadow = p.isAtShadowFileNode()
    isThin = p.isAtThinFileNode()
    # Set forceWrite.
    if isIgnore or p.isAtIgnoreNode():
        forceWrite = True
    elif isAuto or isEdit or isFile or isShadow or isThin:
        forceWrite = False
    else:
        forceWrite = True
    # Set the write bit if necessary.
    if forceWrite or self.usingClipboard:
        v.setWriteBit()  # 4.2: Indicate we wrote the body text.

    status = 0
    if v.isMarked():
        status |= v.markedBit
    if p.isExpanded():
        status |= v.expandedBit
    if p == c.p:
        status |= v.selectedBit

    children: list[dict[str, Any]] = []  # Start empty

    if p.hasChildren() and (forceWrite or self.usingClipboard):
        # This optimization eliminates all "recursive" copies.
        p.moveToFirstChild()
        while 1:
            children.append(fc.leojs_vnode(p, gnxSet, isIgnore))
            if p.hasNext():
                p.moveToNext()
            else:
                break
        p.moveToParent()  # Restore p in the caller.

    # At least will contain  the gnx
    result: dict[str, Any] = {
        'gnx': v.fileIndex,
    }

    if v.fileIndex not in gnxSet:
        result['vh'] = v._headString  # Not a clone so far so add his headline text
        gnxSet.add(v.fileIndex)
        if children:
            result['children'] = children

    # Else, just add status if needed
    if status:
        result['status'] = status

    return result
</t>
<t tx="ekr.20210318174705.1">def test_ImportFromStar(self):
    contents = r"""from sys import *"""
    self.make_data(contents)
</t>
<t tx="ekr.20210318213133.1">def test_full_grammar(self):
    # Load py3_test_grammar.py.
    dir_ = os.path.dirname(__file__)
    path = os.path.abspath(os.path.join(dir_, '..', 'py3_test_grammar.py'))
    assert os.path.exists(path), path
    if py_version &lt; (3, 9):
        self.skipTest('Requires Python 3.9 or above')  # pragma: no cover
    # Verify that leoAst can parse the file.
    contents = read_file(path)
    self.make_data(contents)
</t>
<t tx="ekr.20210318213945.1"></t>
<t tx="ekr.20210318214057.1">def test_line_315(self):

    #
    # Known bug: position-only args exist in Python 3.8,
    #            but there is no easy way of syncing them.
    #            This bug will not be fixed.
    #            The workaround is to require Python 3.9
    if py_version &gt;= (3, 9):
        contents = '''\
f(1, x=2,
    *[3, 4], y=5)
'''
    elif 1:  # pragma: no cover
        contents = '''f(1, *[a, 3], x=2, y=5)'''  # pragma: no cover
    else:  # pragma: no cover
        contents = '''f(a, *args, **kwargs)'''
    contents, tokens, tree = self.make_data(contents)
</t>
<t tx="ekr.20210319130349.1">def test_line_875(self):

    contents = '''list((x, y) for x in 'abcd' for y in 'abcd')'''
    contents, tokens, tree = self.make_data(contents)
</t>
<t tx="ekr.20210319130616.1">def test_line_898(self):

    contents = '''g = ((i,j) for i in range(x) if t for j in range(x))'''
    contents, tokens, tree = self.make_data(contents)
</t>
<t tx="ekr.20210320065202.1">def test_line_483(self):

    if py_version &lt; (3, 8):
        # Python 3.8: https://bugs.python.org/issue32117
        self.skipTest(f"Python {v1}.{v2} does not support generalized iterable assignment")  # pragma: no cover
    contents = '''def g3(): return 1, *return_list'''
    contents, tokens, tree = self.make_data(contents)
</t>
<t tx="ekr.20210320065344.1">def test_line_494(self):

    """
    https://docs.python.org/3/whatsnew/3.8.html#other-language-changes

    Generalized iterable unpacking in yield and return statements no longer
    requires enclosing parentheses. This brings the yield and return syntax
    into better agreement with normal assignment syntax.
    """
    if py_version &lt; (3, 8):
        # Python 3.8: https://bugs.python.org/issue32117
        self.skipTest(f"Python {v1}.{v2} does not support generalized iterable assignment")  # pragma: no cover
    contents = '''def g2(): yield 1, *yield_list'''
    contents, tokens, tree = self.make_data(contents)
</t>
<t tx="ekr.20210320085705.1">def test_walrus_operator(self):

    if py_version &lt; (3, 8):
        self.skipTest(f"Python {v1}.{v2} does not support assignment expressions")  # pragma: no cover
    contents = '''if (n := len(a)) &gt; 10: pass'''
    contents, tokens, tree = self.make_data(contents)
</t>
<t tx="ekr.20210320095504.8">def test_line_337(self):

    if py_version &gt;= (3, 8):  # Requires neither line_no nor col_offset fields.
        contents = '''def f(a, b:1, c:2, d, e:3=4, f=5, *g:6, h:7, i=8, j:9=10, **k:11) -&gt; 12: pass'''
    else:
        contents = '''def f(a, b, d=4, *arg, **keys): pass'''  # pragma: no cover
    contents, tokens, tree = self.make_data(contents)
</t>
<t tx="ekr.20210321171703.1"># NamedExpr(expr target, expr value)

def do_NamedExpr(self, node: Node) -&gt; None:  # Python 3.8+

    self.visit(node.target)
    self.op(':=')
    self.visit(node.value)
</t>
<t tx="ekr.20210321172902.1">def test_bug_1851(self):

    contents = r'''\
def foo(a1):
    pass
'''
    contents, tokens, tree = self.make_data(contents)
</t>
<t tx="ekr.20210429045101.1">g.cls()
fc = c.fileCommands
d = fc.gnxDict
for key in sorted(d.keys()):
    v = d.get(key)
    if v.h.lower() == 'newheadline':
        print('in dict', key, v)
        for p in c.all_positions():
            if p.v == v:
                print(p)
        else:
            print('no position for', v)
print('done')</t>
<t tx="ekr.20210510071427.1">def put_prolog():
    """Same as fc.putProlog, without the stylysheet."""
    fc = c.fileCommands
    tag = 'http://leoeditor.com/namespaces/leo-python-editor/1.1'
    #
    # Put the xml line.
    fc.putXMLLine()
    #
    # Put the "created by Leo" line.
    fc.put('&lt;!-- Created by Leo: http://leoeditor.com/leo_toc.html --&gt;\n')
    #
    # Do *not* put the stylesheet line.
        # fc.putStyleSheetLine()
    #
    # Put the namespace
    fc.put(f'&lt;leo_file xmlns:leo="{tag}" &gt;\n')
</t>
<t tx="ekr.20210510071812.1">def put_tnodes(positions_list):
    """
    Write all tnodes except those for vnodes appearing in @file, @edit or @auto nodes.
    """
        
    def should_suppress(p):
        return any(z.isAtFileNode() or z.isAtEditNode() or z.isAtAutoNode()
            for z in p.self_and_parents())

    fc = c.fileCommands
    fc.put("&lt;tnodes&gt;\n")
    suppress = {}
    for p in c.all_positions(copy=False):
        if should_suppress(p):
            suppress[p.v] = True
    # Write tnodes in *outline* order.
    written = {}
    for root in positions_list:
        for p in root.self_and_subtree():
            if p.v not in suppress and p.v not in written:
                written[p.v] = True
                fc.put_t_element(p.v)
    fc.put("&lt;/tnodes&gt;\n")
</t>
<t tx="ekr.20210530065000.2"># This node contains the commands needed to execute a program in a particular language.
# Format: language-name: command

#
# execute-general-script always creates a temporary file.
# Just before executing the command, execute-general-script
# Replaces &lt;FILE&gt; by the name of the temporary file.

# This does work.
# python: python -v &lt;FILE&gt;

go: go run .
python: python
rust: rustc
</t>
<t tx="ekr.20210530065000.3"># This node contains the regex pattern to determine the line number in error messages.
# Format: language-name: regex pattern
#
# Patterns must define two groups, in either order:
# One group, containing only digits, defines the line number.
# The other group defines the file name.


go: ^\s*(.*):([0-9]+):([0-9]+):.+$
python: ^\s*File "(.+)", line ([0-9]+), in .+$
rust: ^\s*--&gt; (.+):([0-9]+):([0-9]+)\s*$</t>
<t tx="ekr.20210630070717.1">"""
See #2025: https://github.com/leo-editor/leo-editor/issues/2025

Note: I have chosen *not* to update the gnx's. Félix deserves the credit for the changes.

A script to restore gnx's in sentinels in leoserver.py from the devel branch to the felix-server2 branch.

devel-leoserver.py: the version of leoserver.py from devel
felix_server.py:    The version of leoserver.py from felix-server-2
new_server.py:      leoserver.py, with updated gnx's.

After running this script, `kdiff3 devel-leoserver.py new-leoserver.py` shows *only*
the expected changes to sentinel lines.
"""

g.cls()
import difflib
import os
verbose = True
ekr_server = r'c:\diffs\devel-leoserver.py'
felix_server = r'c:\diffs\felix-server2-leoserver.py'
new_server = r'c:\diffs\new-leoserver.py'
assert os.path.exists(ekr_server), ekr_server
assert os.path.exists(felix_server), felix_server
#
# The target (new!) version should be the ekr_server code.
# With this convention:
#   all '-' opcodes will refer to felix gnx's!
#   These lines refer to lines that Félix *inserted* or *changed*
with open(felix_server) as f:
    a1_s = f.read()
with open(ekr_server) as f:
    b1_s = f.read()
print('len ekr', len(b1_s), 'len felix', len(a1_s))
# ndiff compares *lists* of strings.
# a and b are lists of @+node sentinels.
a_list = [z for z in g.splitLines(a1_s) if z.strip().startswith('#@+node:')]
b_list = [z for z in g.splitLines(b1_s) if z.strip().startswith('#@+node:')]
changed, deleted, inserted = [], [], []
diff = list(difflib.ndiff(a_list, b_list))
i = 0
while i &lt; len(diff):
    progress = i
    s = diff[i]
    code = s[0]
    line1 = s[2:]
    if code == '-':  # Félix inserted or changed the node.
        line2_s = diff[i+1] if i+1 &lt; len(diff) else ''
        line3_s = diff[i+2] if i+2 &lt; len(diff) else ''
        line2_code = line2_s[0] if line2_s else ''
        line3 = line3_s[2:]
        assert 'felix' in line1, s
        if line2_code == '?':  # The line changed. Remember the first and third lines.
            assert line2_s
            assert line3_s
            changed.append((line1, line3))
            i += 4
        else: # Félix inserted the node.
            inserted.append(line1)
            i += 1
    elif code == '+':  # Félix deleted the node.
        assert 'ekr' in line1, s
        deleted.append(line1)
        i += 1
    else:
        print(f"{i:&gt;3}: UNKNOWN CODE")
        print(f"{i:&gt;3}: {s!r}")
        print('')
        for j, s in enumerate(diff[:i+1]):
            print(f"{j:&gt;3}: {s!r}")
        break
    assert i &gt; progress
#
# Print the results.
print('')
print(f"Inserted {len(inserted)} nodes")
if verbose:
    print('')
    for i, z in enumerate(inserted):
        print(f"{i:&gt;3}: {z!r}")
    print('')
print(f" Deleted {len(deleted)} nodes")
if verbose:
    print('')
    for i, z in enumerate(deleted):
        print(f"{i:&gt;3}: {z!r}")
    print('')
print(f" Changed {len(changed)} nodes")
if verbose:
    print('')
    for i, z in enumerate(changed):
        a, b = z
        print(f"{i:&gt;3}: felix: {a!r}")
        print(f"{i:&gt;3}:   ekr: {b!r}")
        print('')
#
# Change the leoserver.py, *not* the ekr file.
result = a1_s
for z in changed:
    a, b = z
    assert '#@+node:felix' not in b, repr(b)
    result = result.replace(a, b)
if 0:
    g.printObj(g.splitLines(result), tag=result)
if 0:
    i, n = 0, 0
    tag = '#@+node:felix'
    while True:
        i = result.find(tag, i)
        if i == -1:
            break
        print(n, repr(result[i: i+50]))
        i += len(tag)
        n += 1
if 1:
    # Write the file.
    with open(new_server, 'w') as f:
        f.write(result)
    print(f"wrote {new_server}")
    
</t>
<t tx="ekr.20210630103405.1">g.cls()
import difflib, os, re
ekr_server = r'c:\diffs\devel-leoserver.py'
felix_server = r'c:\diffs\felix-server2-leoserver.py'
with open(ekr_server) as f:
    a1_s = f.read()
with open(felix_server) as f:
    b1_s = f.read()
# a and b are lists of @+node sentinel lines.
a_list = [z.lstrip() for z in g.splitLines(a1_s) if z.strip().startswith('#@+node:')]
b_list = [z.lstrip() for z in g.splitLines(b1_s) if z.strip().startswith('#@+node:')]
# Show the diffs.
diff = difflib.ndiff(a_list, b_list)
for i, s in enumerate(diff):
    print(f"{i:&lt;3}: {s.rstrip()}")
</t>
<t tx="ekr.20210701044426.1"></t>
<t tx="ekr.20210701044513.1"></t>
<t tx="ekr.20210802162650.1">def test_FunctionDef_with_posonly_args(self):

    if py_version &lt; (3, 9):
        self.skipTest('Requires Python 3.9')  # pragma: no cover

    # From PEP 570
    contents = r"""\
def pos_only_arg(arg, /):
    pass
def kwd_only_arg(*, arg):
    pass
def combined_example(pos_only, /, standard, *, kwd_only):
    pass
"""
    self.make_data(contents)
</t>
<t tx="ekr.20210819080657.1">def get_parent_of_git_directory(self) -&gt; Optional[str]:
    """
    #2143.
    Resolve filename to the nearest directory containing a .git directory.
    """
    c = self.c
    filename = c.fileName()
    if not filename:
        print('git-diff: outline has no name')
        return None
    directory = os.path.dirname(filename)
    if directory and not os.path.isdir(directory):
        directory = os.path.dirname(directory)
    if not directory:
        print(f"git-diff: outline has no directory. filename: {filename!r}")
        return None
    # Does path/../ref exist?
    base_directory = g.gitHeadPath(directory)
    if not base_directory:
        print(f"git-diff: no .git directory: {directory!r} filename: {filename!r}")
        return None
    # This should guarantee that the directory contains a .git directory.
    directory = g.finalize_join(base_directory, '..', '..')
    return directory
</t>
<t tx="ekr.20210829132319.1">"""Convert old-style tests to new-style tests"""
g.cls()
import importlib
from leo.commands import convertCommands
importlib.reload(convertCommands)

root_h = '--- To be converted'
root = g.findNodeAnywhere(c, root_h)
converter = convertCommands.ConvertAtTests()
# converter = convertCommands.ConvertShadowTests()
# converter = convertCommands.ConvertUndoTests()
# converter = convertCommands.ConvertColorizerTests()
convertCommands.convert_at_test_nodes(c, converter, root, copy_tree=True)</t>
<t tx="ekr.20210830095545.52">def test_paste_retaining_clones(self):
    c, p = self.c, self.c.p
    child = p.insertAsNthChild(0)
    child.setHeadString('child')
    self.assertTrue(child)
    grandChild = child.insertAsNthChild(0)
    grandChild.setHeadString('grand child')
    c.selectPosition(child)
    c.copyOutline()
    oldVnodes = [p2.v for p2 in child.self_and_subtree()]
    c.p.contract()  # Essential
    c.pasteOutlineRetainingClones()
    self.assertNotEqual(c.p, child)
    newVnodes = [p2.v for p2 in c.p.self_and_subtree()]
    for v in newVnodes:
        self.assertTrue(v in oldVnodes)
</t>
<t tx="ekr.20210830151601.1">def create_test_outline(self) -&gt; None:
    p = self.c.p
    # Create the following outline:
    #
    # root
    #   child clone a
    #     node clone 1
    #   child b
    #     child clone a
    #       node clone 1
    #   child c
    #     node clone 1
    #   child clone a
    #     node clone 1
    #   child b
    #     child clone a
    #       node clone 1
    assert p == self.root_p
    assert p.h == 'root'
    # Child a
    child_clone_a = p.insertAsLastChild()
    child_clone_a.h = 'child clone a'
    node_clone_1 = child_clone_a.insertAsLastChild()
    node_clone_1.h = 'node clone 1'
    # Child b
    child_b = p.insertAsLastChild()
    child_b.h = 'child b'
    # Clone 'child clone a'
    clone = child_clone_a.clone()
    clone.moveToLastChildOf(child_b)
    # Child c
    child_c = p.insertAsLastChild()
    child_c.h = 'child c'
    # Clone 'node clone 1'
    clone = node_clone_1.clone()
    clone.moveToLastChildOf(child_c)
    # Clone 'child clone a'
    clone = child_clone_a.clone()
    clone.moveToLastChildOf(p)
    # Clone 'child b'
    clone = child_b.clone()
    clone.moveToLastChildOf(p)
</t>
<t tx="ekr.20210901140645.19">def test_getLastTracebackFileAndLineNumber(self):
    fn = ''
    try:
        assert False
    except AssertionError:
        fn, n = g.getLastTracebackFileAndLineNumber()
    self.assertEqual(fn.lower(), __file__.lower())

</t>
<t tx="ekr.20210901140855.2">def setUp(self) -&gt; None:
    """
    Create a commander using g.app.gui.
    Create the nodes in the commander.
    """
    # Do the import here to avoid circular dependencies.
    from leo.core import leoCommands

    # Set g.unitTesting *early*, for guards.
    g.unitTesting = True

    # Default.
    g.app.write_black_sentinels = False

    # Create a new commander for each test.
    # This is fast, because setUpClass has done all the imports.
    fileName = g.os_path_finalize_join(g.app.loadDir, 'LeoPyRef.leo')
    self.c = c = leoCommands.Commands(fileName=fileName, gui=g.app.gui)

    # Init the 'root' and '@settings' nodes.
    self.root_p = c.rootPosition()
    self.root_p.h = 'root'
    self.settings_p = self.root_p.insertAfter()
    self.settings_p.h = '@settings'

    # Select the 'root' node.
    c.selectPosition(self.root_p)

def tearDown(self) -&gt; None:
    self.c = None
</t>
<t tx="ekr.20210902014907.1">class LeoUnitTest(unittest.TestCase):
    """
    The base class for all unit tests in Leo.

    Contains setUp/tearDown methods and various utilites.
    """

    @classmethod
    def setUpClass(cls: Any) -&gt; None:
        create_app(gui_name='null')

    @others
</t>
<t tx="ekr.20210902165045.1">class TestGlobals(LeoUnitTest):

    &lt;&lt; TestGlobals: declare all data &gt;&gt;
    &lt;&lt; TestGlboals: define unchanging data &gt;&gt;

    @others
</t>
<t tx="ekr.20210904064440.3">class BaseTestImporter(LeoUnitTest):
    """The base class for tests of leoImport.py"""

    ext = None  # Subclasses must set this to the language's extension.
    treeType = '@file'  # Fix #352.

    def setUp(self):
        super().setUp()
        g.app.loadManager.createAllImporterData()
        g.app.write_black_sentinels = False

    @others
</t>
<t tx="ekr.20210904065459.11">def test_importer(self):

    s = '''
        from libc.math cimport pow

        cdef double square_and_add (double x):
            """Compute x^2 + x as double.

            This is a cdef function that can be called from within
            a Cython program, but not from Python.
            """
            return pow(x, 2.0) + x

        cpdef print_result (double x):
            """This is a cpdef function that can be called from Python."""
            print("({} ^ 2) + {} = {}".format(x, x, square_and_add(x)))
    '''
    expected_results = (
        (0, '',  # check_outlines ignores the first headline.
                '&lt;&lt; TestCython.test_importer: preamble &gt;&gt;\n'
                '@others\n'
                '@language cython\n'
                '@tabwidth -4\n'
        ),
        (1, '&lt;&lt; TestCython.test_importer: preamble &gt;&gt;',
                'from libc.math cimport pow\n'
                '\n'
        ),
        (1, 'cdef double square_and_add',
                'cdef double square_and_add (double x):\n'
                '    """Compute x^2 + x as double.\n'
                '\n'
                '    This is a cdef function that can be called from within\n'
                '    a Cython program, but not from Python.\n'
                '    """\n'
                '    return pow(x, 2.0) + x\n'
        ),
        (1, 'cpdef print_result',
                'cpdef print_result (double x):\n'
                '    """This is a cpdef function that can be called from Python."""\n'
                '    print("({} ^ 2) + {} = {}".format(x, x, square_and_add(x)))\n'
        ),
    )
    self.new_run_test(s, expected_results)
</t>
<t tx="ekr.20210904065459.126">def test_scan_line(self):
    c = self.c
    x = cs.Coffeescript_Importer(c)
    self.assertEqual(x.single_comment, '#')
</t>
<t tx="ekr.20210904065459.15">@tabwidth -2 # Required

def test_1(self):

    s = r"""
    # Js2coffee relies on Narcissus's parser.

    {parser} = @Narcissus or require('./narcissus_packed')

    # Main entry point

    buildCoffee = (str) -&gt;
      str  = str.replace /\r/g, ''
      str += "\n"

      builder    = new Builder
      scriptNode = parser.parse str
    """

    expected_results = (
        (0, '',  # Ignore the first headline.
                '&lt;&lt; TestCoffeescript.test_1: preamble &gt;&gt;\n'
                '@others\n'
                '@language coffeescript\n'
                '@tabwidth -4\n'
        ),
        (1, '&lt;&lt; TestCoffeescript.test_1: preamble &gt;&gt;',
                "# Js2coffee relies on Narcissus's parser.\n"
                '\n'
                "{parser} = @Narcissus or require('./narcissus_packed')\n"
                '\n'
                '# Main entry point\n'
                '\n'
        ),
        (1, 'def buildCoffee',
                'buildCoffee = (str) -&gt;\n'
                "  str  = str.replace /\\r/g, ''\n"
                '  str += "\\n"\n'
                '\n'
                '  builder    = new Builder\n'
                '  scriptNode = parser.parse str\n'
        ),
    )
    self.new_run_test(s, expected_results)

</t>
<t tx="ekr.20210904065459.16">@tabwidth -2 # Required

def test_2(self):

    s = """
      class Builder
        constructor: -&gt;
          @transformer = new Transformer
        # `build()`

        build: (args...) -&gt;
          node = args[0]
          @transform node

          name = 'other'
          name = node.typeName()  if node != undefined and node.typeName

          fn  = (@[name] or @other)
          out = fn.apply(this, args)

          if node.parenthesized then paren(out) else out
        # `transform()`

        transform: (args...) -&gt;
          @transformer.transform.apply(@transformer, args)

        # `body()`

        body: (node, opts={}) -&gt;
          str = @build(node, opts)
          str = blockTrim(str)
          str = unshift(str)
          if str.length &gt; 0 then str else ""

      """
    expected_results = (
      (0, '',  # Ignore the first headline.
            '@others\n'
            '@language coffeescript\n'
            '@tabwidth -4\n'
      ),
      (1, 'class Builder',
            'class Builder\n'
            '  @others\n'
      ),
      (2, 'def constructor',
          'constructor: -&gt;\n'
          '  @transformer = new Transformer\n'
      ),
      (2, 'def build',
            '# `build()`\n'
            '\n'
            'build: (args...) -&gt;\n'
            '  node = args[0]\n'
            '  @transform node\n'
            '\n'
            "  name = 'other'\n"
            '  name = node.typeName()  if node != undefined and node.typeName\n'
            '\n'
            '  fn  = (@[name] or @other)\n'
            '  out = fn.apply(this, args)\n'
            '\n'
            '  if node.parenthesized then paren(out) else out\n'
      ),
      (2, 'def transform',
          '# `transform()`\n'
          '\n'
          'transform: (args...) -&gt;\n'
          '  @transformer.transform.apply(@transformer, args)\n'
      ),
      (2, 'def body',
          '# `body()`\n'
          '\n'
          'body: (node, opts={}) -&gt;\n'
          '  str = @build(node, opts)\n'
          '  str = blockTrim(str)\n'
          '  str = unshift(str)\n'
          '  if str.length &gt; 0 then str else ""\n'
      ),
    )
    self.new_run_test(s, expected_results)
</t>
<t tx="ekr.20210904065459.63">def test_short_classes(self):
    s = (
        'import sys\n'
        'def f1():\n'
        '    pass\n'
        '\n'
        'class Class1:\n'
        '    def method11():\n'
        '        pass\n'
        '    def method12():\n'
        '        pass\n'
        '        \n'
        'a = 2\n'
        '\n'
        'def f2():\n'
        '    pass\n'
        '\n'
        '# An outer comment\n'
        '@myClassDecorator\n'
        'class Class2:\n'
        '    @myDecorator\n'
        '    def method21():\n'
        '        pass\n'
        '    def method22():\n'
        '        pass\n'
        '        \n'
        '# About main.\n'
        'def main():\n'
        '    pass\n'
        '\n'
        "if __name__ == '__main__':\n"
        '    main()\n'
    )
    p = self.run_test(s, strict_flag=True)
    self.check_outline(p, (
        (0, '', # check_outline ignores the first headline
                'import sys\n'
                '@others\n'
                "if __name__ == '__main__':\n"
                '    main()\n'
                '\n'
                '@language python\n'
                '@tabwidth -4\n'
        ),
        (1, 'f1',
                'def f1():\n'
                '    pass\n'
                '\n'
        ),
        # Use this if unit tests *do* honor threshold.
        # (1, 'Class1', 'class Class1:\n'  # Don't split very short classes.
                      # '    def method11():\n'
                      # '        pass\n'
                      # '    def method12():\n'
                      # '        pass\n'
                      # '\n'
        # ),
        (1, 'class Class1',
                    'class Class1:\n'  # Don't split very short classes.
                    '    @others\n'
        ),
        (2, 'method11',
                    'def method11():\n'
                    '    pass\n'
        ),
        (2, 'method12',
                    'def method12():\n'
                    '    pass\n'
                    '\n'
        ),
        (1, 'a = 2',
                    'a = 2\n'
                    '\n'
        ),
        (1, 'f2',
                    'def f2():\n'
                    '    pass\n'
                    '\n'
        ),
        # Use this if unit tests *do* honor threshold.
        # (1, 'Class2', '# An outer comment\n'
                      # '@myClassDecorator\n'
                      # 'class Class2:\n'
                      # '    @myDecorator\n'
                      # '    def method21():\n'
                      # '        pass\n'
                      # '    def method22():\n'
                      # '        pass\n'
                      # '\n'
        # ),
        (1, 'class Class2',
                    '# An outer comment\n'
                    '@myClassDecorator\n'
                    'class Class2:\n'
                    '    @others\n'
        ),
        (2, 'method21',
                    '@myDecorator\n'
                    'def method21():\n'
                    '    pass\n'
        ),
        (2, 'method22',
                      'def method22():\n'
                      '    pass\n'
                      '\n'
        ),
        (1, 'main', '# About main.\n'
                    'def main():\n'
                    '    pass\n'
                    '\n'
        )
    ))

</t>
<t tx="ekr.20210905203541.10">def test_g_ensureLeadingNewlines(self):
    s = ' \n \n\t\naa bc'
    s2 = 'aa bc'
    for i in range(3):
        result = g.ensureLeadingNewlines(s, i)
        val = ('\n' * i) + s2
        self.assertEqual(result, val)
</t>
<t tx="ekr.20210905203541.11">def test_g_ensureTrailingNewlines(self):
    s = 'aa bc \n \n\t\n'
    s2 = 'aa bc'
    for i in range(3):
        result = g.ensureTrailingNewlines(s, i)
        val = s2 + ('\n' * i)
        self.assertEqual(result, val)
</t>
<t tx="ekr.20210905203541.12">def test_g_find_word(self):
    table = (
        ('abc a bc x', 'bc', 0, 6),
        ('abc a bc x', 'bc', 1, 6),
        ('abc a x', 'bc', 0, -1),
    )
    for s, word, i, expected in table:
        actual = g.find_word(s, word, i)
        self.assertEqual(actual, expected)
</t>
<t tx="ekr.20210905203541.14">def test_g_fullPath(self):
    c = self.c
    child = c.rootPosition().insertAfter()
    child.h = '@path abc'
    grand = child.insertAsLastChild()
    grand.h = 'xyz'
    path = g.fullPath(c, grand, simulate=True)
    end = g.os_path_normpath('abc/xyz')
    assert path.endswith(end), repr(path)
</t>
<t tx="ekr.20210905203541.16">def test_g_get_directives_dict(self):
    c = self.c
    p = c.p
    # Note: @comment must follow @language.
    p.b = textwrap.dedent("""\
        ATlanguage python
        ATcomment a b c
        ATtabwidth -8
        ATpagewidth 72
        ATencoding utf-8
""").replace('AT', '@')
    d = g.get_directives_dict(p)
    self.assertEqual(d.get('language'), 'python')
    self.assertEqual(d.get('tabwidth'), '-8')
    self.assertEqual(d.get('pagewidth'), '72')
    self.assertEqual(d.get('encoding'), 'utf-8')
    self.assertEqual(d.get('comment'), 'a b c')
    assert not d.get('path'), d.get('path')
</t>
<t tx="ekr.20210905203541.17">def test_g_getDocString(self):
    s1 = 'no docstring'
    s2 = textwrap.dedent('''\
# comment
"""docstring2."""
''')
    s3 = textwrap.dedent('''\
"""docstring3."""
\'\'\'docstring2.\'\'\'
''')
    table = (
        (s1, ''),
        (s2, 'docstring2.'),
        (s3, 'docstring3.'),
    )
    for s, result in table:
        s2 = g.getDocString(s)
        self.assertEqual(s2, result)
</t>
<t tx="ekr.20210905203541.18">def test_g_getLine(self):
    s = 'a\ncd\n\ne'
    for i, result in (
        (-1, (0, 2)),  # One too few.
        (0, (0, 2)), (1, (0, 2)),
        (2, (2, 5)), (3, (2, 5)), (4, (2, 5)),
        (5, (5, 6)),
        (6, (6, 7)),
        (7, (6, 7)),  # One too many.
    ):
        j, k = g.getLine(s, i)
        self.assertEqual((j, k), result, msg=f"i: {i}, j: {j}, k: {k}")
</t>
<t tx="ekr.20210905203541.20">def test_g_getWord(self):
    s = 'abc xy_z5 pdq'
    i, j = g.getWord(s, 5)
    self.assertEqual(s[i:j], 'xy_z5')
</t>
<t tx="ekr.20210905203541.21">def test_g_guessExternalEditor(self):
    c = self.c
    val = g.guessExternalEditor(c)
    assert val, 'no val'  # This can be different on different platforms.
</t>
<t tx="ekr.20210905203541.23">def test_g_import_module(self):
    assert g.import_module('leo.core.leoAst')
        # Top-level .py file.
</t>
<t tx="ekr.20210905203541.24">def test_g_isDirective(self):
    table = (
        (True, '@language python\n'),
        (True, '@tabwidth -4 #test\n'),
        (True, '@others\n'),
        (True, '    @others\n'),
        (True, '@encoding\n'),
        (False, '@encoding.setter\n'),
        (False, '@encoding("abc")\n'),
        (False, 'encoding = "abc"\n'),
    )
    for expected, s in table:
        result = g.isDirective(s)
        self.assertEqual(expected, bool(result), msg=s)
</t>
<t tx="ekr.20210905203541.25">def test_g_match_word(self):
    table = (
        (True, 0, 'a', 'a'),
        (False, 0, 'a', 'b'),
        (True, 0, 'a', 'a b'),
        (False, 1, 'a', 'aa b'),  # Tests bug fixed 2017/06/01.
        (False, 1, 'a', '_a b'),
        (False, 0, 'a', 'aw b'),
        (False, 0, 'a', 'a_'),
        (True, 2, 'a', 'b a c'),
        (False, 0, 'a', 'b a c'),
    )
    for data in table:
        expected, i, word, line = data
        got = g.match_word(line + '\n', i, word)
        self.assertEqual(expected, got)
</t>
<t tx="ekr.20210905203541.26">def test_g_os_path_finalize_join_with_thumb_drive(self):
    path1 = r'C:\Python32\Lib\site-packages\leo-editor\leo\core'
    path2 = r'\N:Home\PTC_Creo\Creo.wmv'
    path3 = r'N:\Home\PTC_Creo\Creo.wmv'
    path12 = os.path.join(path1, path2)
    path13 = os.path.join(path1, path3)
    if 0:
        print(path12, g.os.path.abspath(path12))
        print(path13, g.os.path.abspath(path13))
</t>
<t tx="ekr.20210905203541.28">def test_g_removeBlankLines(self):
    for s, expected in (
        ('a\nb', 'a\nb'),
        ('\n  \n\nb\n', 'b\n'),
        (' \t \n\n  \n c\n\t\n', ' c\n'),
    ):
        result = g.removeBlankLines(s)
        self.assertEqual(result, expected, msg=repr(s))
</t>
<t tx="ekr.20210905203541.30">def test_g_removeLeadingBlankLines(self):
    for s, expected in (
        ('a\nb', 'a\nb'),
        ('\n  \nb\n', 'b\n'),
        (' \t \n\n\n c', ' c'),
    ):
        result = g.removeLeadingBlankLines(s)
        self.assertEqual(result, expected, msg=repr(s))
</t>
<t tx="ekr.20210905203541.31">def test_g_removeTrailing(self):
    s = 'aa bc \n \n\t\n'
    table = (
        ('\t\n ', 'aa bc'),
        ('abc\t\n ', ''),
        ('c\t\n ', 'aa b'),
    )
    for arg, val in table:
        result = g.removeTrailing(s, arg)
        self.assertEqual(result, val)
</t>
<t tx="ekr.20210905203541.32">def test_g_sanitize_filename(self):
    table = (
        ('A25&amp;()', 'A'),  # Non-alpha characters.
        ('B\tc', 'B c'),  # Tabs.
        ('"AB"', "'AB'"),  # Double quotes.
        ('\\/:|&lt;&gt;*:.', '_'),  # Special characters.
        ('_____________', '_'),  # Combining underscores.
        ('A' * 200, 'A' * 128),  # Maximum length.
        ('abc.', 'abc_'),  # Trailing dots.
    )
    for s, expected in table:
        got = g.sanitize_filename(s)
        self.assertEqual(got, expected, msg=repr(s))
</t>
<t tx="ekr.20210905203541.33">def test_g_scanAtHeaderDirectives_header(self):
    c = self.c
    aList = g.get_directives_dict_list(c.p)
    g.scanAtHeaderDirectives(aList)
</t>
<t tx="ekr.20210905203541.35">def test_g_scanAtHeaderDirectives_noheader(self):
    c = self.c
    aList = g.get_directives_dict_list(c.p)
    g.scanAtHeaderDirectives(aList)
</t>
<t tx="ekr.20210905203541.36">def test_g_scanAtLineendingDirectives_cr(self):
    c = self.c
    p = c.p
    p.b = '@lineending cr\n'
    aList = g.get_directives_dict_list(p)
    s = g.scanAtLineendingDirectives(aList)
    self.assertEqual(s, '\r')
</t>
<t tx="ekr.20210905203541.37">def test_g_scanAtLineendingDirectives_crlf(self):
    c = self.c
    p = c.p
    p.b = '@lineending crlf\n'
    aList = g.get_directives_dict_list(p)
    s = g.scanAtLineendingDirectives(aList)
    self.assertEqual(s, '\r\n')
</t>
<t tx="ekr.20210905203541.38">def test_g_scanAtLineendingDirectives_lf(self):
    c = self.c
    p = c.p
    p.b = '@lineending lf\n'
    aList = g.get_directives_dict_list(p)
    s = g.scanAtLineendingDirectives(aList)
    self.assertEqual(s, '\n')
</t>
<t tx="ekr.20210905203541.39">def test_g_scanAtLineendingDirectives_nl(self):
    c = self.c
    p = c.p
    p.b = '@lineending nl\n'
    aList = g.get_directives_dict_list(p)
    s = g.scanAtLineendingDirectives(aList)
    self.assertEqual(s, '\n')
</t>
<t tx="ekr.20210905203541.4">def test_g_checkVersion(self):
    # for condition in ('&lt;','&lt;=','&gt;','&gt;='):
    for v1, condition, v2 in (
        ('8.4.12', '&gt;', '8.4.3'),
        ('1', '==', '1.0'),
        ('2', '&gt;', '1'),
        ('1.2', '&gt;', '1'),
        ('2', '&gt;', '1.2.3'),
        ('1.2.3', '&lt;', '2'),
        ('1', '&lt;', '1.1'),
    ):
        assert g.CheckVersion(v1, v2, condition=condition, trace=False)
</t>
<t tx="ekr.20210905203541.40">def test_g_scanAtLineendingDirectives_platform(self):
    c = self.c
    p = c.p
    p.b = '@lineending platform\n'
    aList = g.get_directives_dict_list(p)
    s = g.scanAtLineendingDirectives(aList)
    if sys.platform.startswith('win'):
        self.assertEqual(s, '\r\n')  # pragma: no cover
    else:
        self.assertEqual(s, '\n')  # pragma: no cover
</t>
<t tx="ekr.20210905203541.41">def test_g_scanAtPagewidthDirectives_minus_40(self):
    c = self.c
    p = c.p
    p.b = '@pagewidth -40\n'
    aList = g.get_directives_dict_list(p)
    n = g.scanAtPagewidthDirectives(aList)
    # The @pagewidth directive in the parent should control.
    # Depending on how this test is run, the result could be 80 or None.
    assert n in (None, 80), repr(n)
</t>
<t tx="ekr.20210905203541.42">def test_g_scanAtPagewidthDirectives_40(self):
    c = self.c
    p = c.p
    p.b = '@pagewidth 40\n'
    aList = g.get_directives_dict_list(p)
    n = g.scanAtPagewidthDirectives(aList)
    self.assertEqual(n, 40)
</t>
<t tx="ekr.20210905203541.43">def test_g_scanAtTabwidthDirectives_6(self):
    c = self.c
    p = c.p
    p.b = '@tabwidth 6\n'
    aList = g.get_directives_dict_list(p)
    n = g.scanAtTabwidthDirectives(aList)
    self.assertEqual(n, 6)
</t>
<t tx="ekr.20210905203541.44">def test_g_scanAtTabwidthDirectives_minus_6(self):
    c = self.c
    p = c.p
    p.b = '@tabwidth -6\n'
    aList = g.get_directives_dict_list(p)
    n = g.scanAtTabwidthDirectives(aList)
    self.assertEqual(n, -6)
</t>
<t tx="ekr.20210905203541.45">def test_g_scanAtWrapDirectives_nowrap(self):
    c = self.c
    p = c.p
    p.b = '@nowrap\n'
    aList = g.get_directives_dict_list(p)
    s = g.scanAtWrapDirectives(aList)
    assert s is False, repr(s)
</t>
<t tx="ekr.20210905203541.46">def test_g_scanAtWrapDirectives_wrap_with_wrap_(self):
    c = self.c
    p = c.p
    p.b = '@wrap\n'
    aList = g.get_directives_dict_list(p)
    s = g.scanAtWrapDirectives(aList)
    assert s is True, repr(s)
</t>
<t tx="ekr.20210905203541.47">def test_g_scanAtWrapDirectives_wrap_without_nowrap_(self):
    c = self.c
    aList = g.get_directives_dict_list(c.p)
    s = g.scanAtWrapDirectives(aList)
    assert s is None, repr(s)
</t>
<t tx="ekr.20210905203541.48">def test_g_set_delims_from_language(self):
    table = (
        ('c', ('//', '/*', '*/')),
        ('python', ('#', '', '')),
        ('xxxyyy', ('', '', '')),
    )
    for language, expected in table:
        result = g.set_delims_from_language(language)
        self.assertEqual(result, expected, msg=language)
</t>
<t tx="ekr.20210905203541.49">def test_g_set_delims_from_string(self):
    table = (
        ('c', '@comment // /* */', ('//', '/*', '*/')),
        ('c', '// /* */', ('//', '/*', '*/')),
        ('python', '@comment #', ('#', '', '')),
        ('python', '#', ('#', '', '')),
        ('xxxyyy', '@comment a b c', ('a', 'b', 'c')),
        ('xxxyyy', 'a b c', ('a', 'b', 'c')),
    )
    for language, s, expected in table:
        result = g.set_delims_from_string(s)
        self.assertEqual(result, expected, msg=language)
</t>
<t tx="ekr.20210905203541.5">def test_g_CheckVersionToInt(self):
    self.assertEqual(g.CheckVersionToInt('12'), 12)
    self.assertEqual(g.CheckVersionToInt('2a5'), 2)
    self.assertEqual(g.CheckVersionToInt('b2'), 0)
</t>
<t tx="ekr.20210905203541.50">def test_g_skip_blank_lines(self):
    end = g.skip_blank_lines("", 0)
    self.assertEqual(end, 0)
    end = g.skip_blank_lines(" ", 0)
    self.assertEqual(end, 0)
    end = g.skip_blank_lines("\n", 0)
    self.assertEqual(end, 1)
    end = g.skip_blank_lines(" \n", 0)
    self.assertEqual(end, 2)
    end = g.skip_blank_lines("\n\na\n", 0)
    self.assertEqual(end, 2)
    end = g.skip_blank_lines("\n\n a\n", 0)
    self.assertEqual(end, 2)
</t>
<t tx="ekr.20210905203541.51">def test_g_skip_line(self):
    s = 'a\n\nc'
    for i, result in (
        (-1, 2),  # One too few.
        (0, 2), (1, 2),
        (2, 3),
        (3, 4),
        (4, 4),  # One too many.
    ):
        j = g.skip_line(s, i)
        self.assertEqual(j, result, msg=i)
</t>
<t tx="ekr.20210905203541.52">def test_g_skip_to_end_of_line(self):
    s = 'a\n\nc'
    for i, result in (
        (-1, 1),  # One too few.
        (0, 1), (1, 1),
        (2, 2),
        (3, 4),
        (4, 4),  # One too many.
    ):
        j = g.skip_to_end_of_line(s, i)
        self.assertEqual(j, result, msg=i)
</t>
<t tx="ekr.20210905203541.53">def test_g_skip_to_start_of_line(self):
    s1 = 'a\n\nc'
    table1 = (
        (-1, 0),  # One too few.
        (0, 0), (1, 0),
        (2, 2),
        (3, 3),
        (4, 4),  # One too many.
    )
    s2 = 'a\n'
    table2 = (
        (1, 0),
        (2, 2),
    )  # A special case at end.
    for s, table in ((s1, table1), (s2, table2)):
        for i, result in table:
            j = g.skip_to_start_of_line(s, i)
            self.assertEqual(j, result, msg=i)
</t>
<t tx="ekr.20210905203541.54">def test_g_splitLongFileName(self):
    table = (
        r'abcd/xy\pdqabc/aaa.py',
    )
    for s in table:
        g.splitLongFileName(s, limit=3)
</t>
<t tx="ekr.20210905203541.55">def test_g_stripPathCruft(self):
    table = (
        (None, None),  # Retain empty paths for warnings.
        ('', ''),
        (g.app.loadDir, g.app.loadDir),
        ('&lt;abc&gt;', 'abc'),
        ('"abc"', 'abc'),
        ("'abc'", 'abc'),
    )
    for path, expected in table:
        result = g.stripPathCruft(path)
        self.assertEqual(result, expected)
</t>
<t tx="ekr.20210905203541.56">def test_g_warnOnReadOnlyFile(self):
    c = self.c
    fc = c.fileCommands
    path = g.finalize_join(g.app.loadDir, '..', 'test', 'test-read-only.txt')
    if os.path.exists(path):  # pragma: no cover
        os.chmod(path, stat.S_IREAD)
        fc.warnOnReadOnlyFiles(path)
        assert fc.read_only
    else:  # pragma: no cover
        fc.warnOnReadOnlyFiles(path)
</t>
<t tx="ekr.20210905203541.6">def test_g_comment_delims_from_extension(self):
    # New in Leo 4.6, set_delims_from_language returns '' instead of None.
    table = (
        ('.c', ('//', '/*', '*/')),
        ('.html', ('', '&lt;!--', '--&gt;')),
        ('.py', ('#', '', '')),
        ('.Globals', ('', '', '')),
    )
    for ext, expected in table:
        result = g.comment_delims_from_extension(ext)
        self.assertEqual(result, expected, msg=repr(ext))
</t>
<t tx="ekr.20210905203541.7">def test_g_convertPythonIndexToRowCol(self):
    s1 = 'abc\n\np\nxy'
    table1 = (
        (-1, (0, 0)),  # One too small.
        (0, (0, 0)),
        (1, (0, 1)),
        (2, (0, 2)),
        (3, (0, 3)),  # The newline ends a row.
        (4, (1, 0)),
        (5, (2, 0)),
        (6, (2, 1)),
        (7, (3, 0)),
        (8, (3, 1)),
        (9, (3, 2)),  # One too many.
        (10, (3, 2)),  # Two too many.
    )
    s2 = 'abc\n\np\nxy\n'
    table2 = (
        (9, (3, 2)),
        (10, (4, 0)),  # One too many.
        (11, (4, 0)),  # Two too many.
    )
    s3 = 'ab'  # Test special case.  This was the cause of off-by-one problems.
    table3 = (
        (-1, (0, 0)),  # One too small.
        (0, (0, 0)),
        (1, (0, 1)),
        (2, (0, 2)),  # One too many.
        (3, (0, 2)),  # Two too many.
    )
    for n, s, table in ((1, s1, table1), (2, s2, table2), (3, s3, table3)):
        for i, result in table:
            row, col = g.convertPythonIndexToRowCol(s, i)
            self.assertEqual(row, result[0], msg=f"n: {n}, i: {i}")
            self.assertEqual(col, result[1], msg=f"n: {n}, i: {i}")
</t>
<t tx="ekr.20210905203541.8">def test_g_convertRowColToPythonIndex(self):
    s1 = 'abc\n\np\nxy'
    s2 = 'abc\n\np\nxy\n'
    table1 = (
        (0, (-1, 0)),  # One too small.
        (0, (0, 0)),
        (1, (0, 1)),
        (2, (0, 2)),
        (3, (0, 3)),  # The newline ends a row.
        (4, (1, 0)),
        (5, (2, 0)),
        (6, (2, 1)),
        (7, (3, 0)),
        (8, (3, 1)),
        (9, (3, 2)),  # One too large.
    )
    table2 = (
        (9, (3, 2)),
        (10, (4, 0)),  # One two many.
    )
    for s, table in ((s1, table1), (s2, table2)):
        for i, data in table:
            row, col = data
            result = g.convertRowColToPythonIndex(s, row, col)
            self.assertEqual(i, result, msg=f"row: {row}, col: {col}, i: {i}")
</t>
<t tx="ekr.20210905203541.9">def test_g_create_temp_file(self):
    theFile = None
    try:
        theFile, fn = g.create_temp_file()
        assert theFile
        assert isinstance(fn, str)
    finally:
        if theFile:
            theFile.close()
</t>
<t tx="ekr.20210906075242.6">def test_c_demote_illegal_clone_demote(self):
    c, p = self.c, self.c.p
    # Create two cloned children.
    c.selectPosition(p)
    c.insertHeadline()
    p2 = c.p
    p2.moveToFirstChildOf(p)
    p2.setHeadString('aClone')
    c.selectPosition(p2)
    c.clone()
    self.assertEqual(2, p.numberOfChildren())
    # Select the first clone and demote (it should be illegal)
    c.selectPosition(p2)
    c.demote()  # This should do nothing.
    self.assertEqual(0, c.checkOutline())
    self.assertEqual(2, p.numberOfChildren())
</t>
<t tx="ekr.20210912064148.1"></t>
<t tx="ekr.20210912064205.1"></t>
<t tx="ekr.20210914161519.1">def test_bug_2171(self):

    if py_version &lt; (3, 9):
        self.skipTest('Requires Python 3.9')  # pragma: no cover

    contents = "'HEAD:%s' % g.os_path_join( *(relative_path + [filename]) )"
    contents, tokens, tree = self.make_data(contents)
</t>
<t tx="ekr.20210927034148.1">def scanOptions(self, fileName: str, pymacs: bool) -&gt; dict[str, Any]:
    """Handle all options, remove them from sys.argv and set lm.options."""
    # Define helper functions.
    @others

    obsolete_options = [
        '--dock', '--global-docks', '--init-docks', '--no-cache',
        '--no-dock', '--session-restore', '--session-save', '--use-docks',
    ]
    usage = defineUsage()
    utils = g.OptionsUtils(usage, obsolete_options)
    # Handle help args.
    if any(z in sys.argv for z in ('-h', '-?', '--help')):
        print(usage)
        sys.exit()
    doSimpleOptions()
    doTraceOptions()
    # Set the LoadManager.files ivar.
    self.files = computeFilesList(fileName)
    # Return a dictionary of complex options.
    script = None if pymacs else doScriptOption()  # Used twice below.
    return {
        'gui': doGuiOption(),
        'load_type': doLoadTypeOption(),
        'script': script,
        'select': doSelectOption(),
        'theme_path': doThemeOption(),
        'version': any(z in sys.argv for z in ('-v', '--version')),
        'windowFlag': script and '--script-window' in sys.argv,
        'windowSize': doWindowSizeOption(),
        'windowSpot': doWindowSpotOption(),
    }
</t>
<t tx="ekr.20210927034148.10">def doWindowSizeOption() -&gt; Optional[tuple[int, int]]:
    """Handle --window-size"""
    m = utils.find_complex_option(r'--window-size=(\d+)x(\d+)')
    if not m:
        return None
    try:
        h, w = int(m.group(1)), int(m.group(2))
    except ValueError:
        arg = m.group(0)
        utils.option_error(arg, 'Invalid value: expected int x int')
    return h, w
</t>
<t tx="ekr.20210927034148.3">def computeFilesList(fileName: str) -&gt; list[str]:
    """Return the list of files on the command line."""
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        aList = g.glob_glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return [g.os_path_normslashes(z) for z in result]
</t>
<t tx="ekr.20210927034148.4">def doGuiOption() -&gt; str:
    """Handle --gui option. Default to 'qt'"""
    m = utils.find_complex_option(r'--gui=(\w+)')
    valid = ('console', 'curses', 'null', 'qt', 'text')
    if not m:
        g.app.guiArgName = 'qt'
        return 'qt'
    # Validate the gui.
    gui = m.group(1).lower()
    if gui == 'qttabs':
        gui = 'qt'  # Allow legacy qttabs gui.
    elif not gui.startswith('browser') and gui not in valid:
        arg = m.group(0)
        valid_s = ', '.join(valid)
        utils.option_error(arg, f"Expected one of {valid_s}")
    g.app.guiArgName = gui
    return gui

</t>
<t tx="ekr.20210927034148.5">def doLoadTypeOption() -&gt; Optional[str]:
    """Handle load-type"""
    m = utils.find_complex_option(r'--load-type=@(edit|file)')
    return m.group(1).lower() if m else None
</t>
<t tx="ekr.20210927034148.6">def doScreenShotOption(self, args: Any) -&gt; str:

    # --screen-shot=fn
    s = args.screen_shot
    if s:
        s = s.strip('"')
    return s
</t>
<t tx="ekr.20210927034148.7">def doScriptOption() -&gt; Optional[str]:
    """Handle --script=path"""
    m = utils.find_complex_option(r'--script=(.+)')
    if not m:
        return None
    fn = m.group(1).replace('"', '')
    # #1090: use cwd, not g.app.loadDir, to find scripts.
    path = g.finalize_join(os.getcwd(), fn)
    script, e = g.readFileIntoString(path, kind='script:', verbose=False)
    if not script:
        arg = m.group(0)
        utils.option_error(arg, f"Script not found: {m.group(1)!r}")
    return script
</t>
<t tx="ekr.20210927034148.9">def doWindowSpotOption() -&gt; Optional[tuple[int, int]]:
    """Handle --window-spot"""
    m = utils.find_complex_option(r'--window-spot=(\d+)x(\d+)')
    if not m:
        return None
    try:
        top, left = int(m.group(1)), int(m.group(2))
    except ValueError:
        arg = m.group(0)
        utils.option_error(arg, 'Invalid value: expected int x int')
    return top, left
</t>
<t tx="ekr.20211011090013.1">"""
Find and convert hanging comments.

Warning: do not run this script on unit testing files.
"""
# https://github.com/leo-editor/leo-editor/pull/2622
g.cls()
import re
from typing import Any, List

trace = True  # It's useful to trace even when also replacing.
replace = True  # Replace body text.
max_line_length = 70  # Maximum line length for lines containing trailing comments.

@others

for p in c.p.self_and_subtree():
    convert(p)
print('done')
</t>
<t tx="ekr.20211014103433.1">"""
Convert the TeX sources, assumed to be in ~/tex.web, to an outline.

https://mirror.las.iastate.edu/tex-archive/systems/knuth/dist/tex/tex.web

"""
g.cls()
import os
import re
# Read
path = os.path.expanduser('~/tex.web')
with open(path) as f:
    contents = f.read()
# Create root.
last = c.lastTopLevel()
if last.h == 'tex.web':
    last.doDelete()
last = c.lastTopLevel()
root = last.insertAfter()
root.h = 'tex.web'
root.b = '@language tex'
prefix = root.insertAsLastChild()
prefix.h = 'prefix'
# Patterns
at_star_pat = re.compile(r'^@\*(.*?)$')
at_space_pat = re.compile(r'^@ (.*?)$')
at_p_pat = re.compile(r'^@p (.*?)$')
at_sec_pat = re.compile(r'^@&lt;(.*?)@&gt;=(.*?)$')
@others  # Define handlers and helpers.
table = (
    (at_star_pat, do_at_star),
    (at_space_pat, do_at_space),
    (at_p_pat, do_p),
    (at_sec_pat, do_sec),
)
count = 0
parents = [('prefix', prefix)]  # Tuples: (kind, p)
for i, s in enumerate(g.splitLines(contents)):
    for pattern, helper in table:
        m = pattern.match(s)
        if m:
            helper(i, m, s)  # m not used at present.
            count += 1
    else:
        parent = parents[-1][1]
        parent.b += s
# Finish
root.expand()
c.redraw(root)
print(f"done: {count} pattern{g.plural(count)}")</t>
<t tx="ekr.20211014112513.1">def do_at_star(i, m, s):
    global parents
    print(s.rstrip())  # A good progress indicator.
    parent = root.insertAsLastChild()
    parent.h = s.strip()
    parents = [('@*', parent)]  # Always prune the stack.

def do_at_space(i, m, s):
    new_node('@ ', s)
    
def do_p(i, m, s):
    new_node('@p', s)

def do_sec(i, m, s):
    new_node('@&lt;', s)
</t>
<t tx="ekr.20211014120710.1">def new_node(kind, h):
    """Create a new node as the last child of an '@*' node."""
    global parents
    kind = parents[-1][0]
    if kind == '@*':
        parent = parents[-1][1]
    else:
        # Prune the stack back to the '@*' entry.
        parent_tuple = parents[0]
        assert parent_tuple[0] == '@*', parents
        parents = [parent_tuple]
        parent = parent_tuple[1]
    child = parent.insertAsLastChild()
    child.h = h.strip()
    parents.append(('@ ', child))
</t>
<t tx="ekr.20211020091540.1">c.backup_helper(sub_dir='leoPy')
</t>
<t tx="ekr.20211108044605.1">def compute_unit_test_kind(self, ext: str) -&gt; str:
    """Return kind from the given extention."""
    aClass = g.app.classDispatchDict.get(ext)
    kind = {
        '.json': '@auto-json',
        '.md': '@auto-md',
        '.org': '@auto-org',
        '.otl': '@auto-otl',
        '.rst': '@auto-rst',
    }.get(ext)
    if kind:
        return kind
    if aClass:
        d2 = g.app.atAutoDict
        for z in d2:
            if d2.get(z) == aClass:
                return z  # pragma: no cover
    return '@file'
</t>
<t tx="ekr.20211108063520.1">class TestCoffeescript(BaseTestImporter):

    ext = '.coffee'

    @others
</t>
<t tx="ekr.20211108063908.1">class TestCython(BaseTestImporter):

    ext = '.pyx'
    @others
</t>
<t tx="ekr.20211108082509.1">class TestPython(BaseTestImporter):

    ext = '.py'

    @others
</t>
<t tx="ekr.20211108085023.1">def test_get_leading_indent(self):
    c = self.c
    importer = coffeescript.Coffeescript_Importer(c)
    self.assertEqual(importer.single_comment, '#')
</t>
<t tx="ekr.20211126055349.1">def test_short_file(self):

    input_s = self.dedent('''\
        """A docstring"""
        switch = 1
        print(3)
        print(6)
        def a():
            pass
        print(7)
    ''')
    p = self.run_test(input_s, strict_flag=True)
    self.check_outline(p, (
        (0, '',  # check_outline ignores the first headline.
                '"""A docstring"""\n'
                'switch = 1\n'
                'print(3)\n'
                'print(6)\n'
                '@others\n'
                'print(7)\n'
                '\n'
                '@language python\n'
                '@tabwidth -4\n'
        ),
        (1, 'a',  # Unit tests ignore size threshold.
           'def a():\n'
           '    pass\n'
        ),
    ))
</t>
<t tx="ekr.20211127042843.1">def run_test(self, s: str) -&gt; Position:
    """
    Run a unit test of an import scanner,
    i.e., create a tree from string s at location c.p.
    Return the created tree.
    """
    c, ext, p = self.c, self.ext, self.c.p
    self.assertTrue(ext)

    # Run the test.
    parent = p.insertAsLastChild()
    kind = self.compute_unit_test_kind(ext)

    # TestCase.id() has the form leo.unittests.core.file.class.test_name
    id_parts = self.id().split('.')
    self.short_id = f"{id_parts[-2]}.{id_parts[-1]}"
    parent.h = f"{kind} {self.short_id}"

    # createOutline calls Importer.gen_lines and Importer.check.
    test_s = textwrap.dedent(s).strip() + '\n'
    c.importCommands.createOutline(parent.copy(), ext, test_s)
    return parent
</t>
<t tx="ekr.20211129062220.1">def dump_tree(self, root: Position = None, tag: str = None) -&gt; None:  # pragma: no cover
    """
    Dump root's tree, or the entire tree if root is None.
    """
    print('')
    if tag:
        print(tag)
    _iter = root.self_and_subtree if root else self.c.all_positions
    for p in _iter():
        print('')
        print('level:', p.level(), p.h)
        g.printObj(g.splitLines(p.v.b))
</t>
<t tx="ekr.20211202064822.1">def test_nested_classes(self):
    s = """
        class TestCopyFile(unittest.TestCase):
            _delete = False
            a00 = 1
            class Faux(object):
                _entered = False
                _exited_with = None # type: tuple
                _raised = False
        """
    # mypy/test-data/stdlib-samples/3.2/test/shutil.py
    expected_results = (
        (0, '',  # Ignore the first headline.
               '@others\n'
               '@language python\n'
               '@tabwidth -4\n'
        ),
        (1, 'class TestCopyFile',
                'class TestCopyFile(unittest.TestCase):\n'
                '    ATothers\n'.replace('AT', '@')
        ),
        (2, 'class Faux',
                    '_delete = False\n'
                    'a00 = 1\n'
                    'class Faux(object):\n'
                    '    _entered = False\n'
                    '    _exited_with = None # type: tuple\n'
                    '    _raised = False\n'
        ),
    )
    self.new_run_test(s, expected_results)
</t>
<t tx="ekr.20220224120239.1">def test_Raise(self):
    contents = "raise ImportError from None"
    self.make_data(contents)
</t>
<t tx="ekr.20220306092217.1">g.cls()
g.cls()
&lt;&lt; prefixes &gt;&gt;
&lt;&lt; old tests &gt;&gt;
commands = (
    # f" {commands}.test_outlineCommands.TestOutlineCommands.test_paste_retaining_clones",
    # f" {commands}.test_outlineCommands.TestOutlineCommands.test_paste_node",
    # f" {commands}.test_outlineCommands.TestOutlineCommands.test_paste_as_template",
    
    # f" {commands}.test_outlineCommands.TestOutlineCommands.test_restoreFromCopiedTree",
    # f" {commands}.test_outlineCommands.TestOutlineCommands.test_p_v_archive",
    
    # f" {core}.test_leoCommands.TestCommands.check_c_check_links",
    f"  {core}.test_leoNodes.TestNodes.test_paste_retaining_clones",
)
verbose_flag = ''  # -v
commands_s = f"python -m unittest {verbose_flag} {' '.join(commands)}"
g.execute_shell_commands(commands_s)
</t>
<t tx="ekr.20220318033804.1">def openEmptyLeoFile(self, gui: LeoGui, old_c: Optional[Cmdr]) -&gt; Cmdr:
    """Open an empty, untitled, new Leo file."""
    lm = self
    # Disable the log.
    g.app.setLog(None)
    g.app.lockLog()
    # Create the commander for the .leo file.
    c = g.app.newCommander(
        fileName=None,
        gui=gui,
        previousSettings=lm.getPreviousSettings(None),
    )
    g.doHook('open0')
    # Enable the log.
    g.app.unlockLog()
    c.frame.log.enable(True)
    g.doHook("open1", old_c=old_c, c=c, new_c=c, fileName=None)
    # Init the frame.
    c.frame.setInitialWindowGeometry()
    c.frame.deiconify()
    c.frame.lift()
    c.frame.splitVerticalFlag, r1, r2 = c.frame.initialRatios()
    c.frame.resizePanesToRatio(r1, r2)
    c.mFileName = None
    c.wrappedFileName = None
    # Fix a buglet: Don't call c.computeWindowTitle here.
    c.frame.setTitle(c.frame.title)
    # Late inits. Order matters.
    if c.config.getBool('use-chapters') and c.chapterController:
        c.chapterController.finishCreate()
    c.clearChanged()
    g.doHook("open2", old_c=old_c, c=c, new_c=c, fileName=None)
    g.doHook("new", old_c=old_c, c=c, new_c=c)
    g.app.writeWaitingLog(c)
    c.setLog()
    lm.createMenu(c)
    lm.finishOpen(c)
    return c
</t>
<t tx="ekr.20220318085657.1">"""
Find and mark all nodes containing underindented trailing comments in c's outline.

Such comments have the form:
    
    .. some code ..
        A trailing, overindented comment.
"""
g.cls()
import re
pattern = re.compile(r'\w+\s*=\s\w+')

def do_node(p):
    global count
    prev_assign = False
    old_lws = 0
    lines = g.splitLines(p.b)
    for i, line in enumerate(lines):
        lws = g.computeLeadingWhitespaceWidth(line, tab_width=-4)
        if line.strip().startswith('#'):
            if prev_assign and lws &gt; old_lws:
                # Found a likely trailing comment.
                p.setMarked()
                count += 1
                return True
            prev_assign = False
        else:
            old_lws = lws
            prev_assign = pattern.search(line)
    return False
    
count = 0
c.clearAllMarked()
for p in c.all_unique_positions():
    do_node(p)
print(f"found {count} nodes.")
</t>
<t tx="ekr.20220319145807.1">g.cls()

# Monkey-patched git-diff-pr command.
import leo.commands.editFileCommands as efc

rev1 = 'master'  
rev2 = 'ekr-walk-special-case'
x = efc.GitDiffController(c)

@others

# Monkey-patch, with x bound.
x.make_diff_outlines = make_diff_outlines_ignoring_comments
x.diff_two_revs(rev1, rev2)
</t>
<t tx="ekr.20220319151900.1">def make_diff_outlines_ignoring_comments(c1, c2, fn, rev1='', rev2=''):
    """Create an outline-oriented diff from the *hidden* outlines c1 and c2."""
    self = x
    added, deleted, changed = self.compute_dicts(c1, c2)
    table = (
        (added, 'Added'),
        (deleted, 'Deleted'),
        (changed, 'Changed'))
    for d, kind in table:
        if kind.lower() == 'changed':
            for key in d:
                v1, v2 = d.get(key)
                v1.b = strip_comments(v1.b)
                v2.b = strip_comments(v2.b)
        self.create_compare_node(c1, c2, d, kind, rev1, rev2)
</t>
<t tx="ekr.20220319152417.1">def strip_comments(aString):
    """
    Strip everything that looks like a comment from aString.
    It's fine, for now, to ignore strings and docstrings.
    """
    result = []
    lines = g.splitLines(aString)
    for s in lines:
        if s.strip().startswith('#@'):
            # Retain everything that looks like a sentinel.
            result.append(s)
        else:
            # Strip the comment, ignoring the end of the line.
            i = s.find('#')
            if i == -1:
                result.append(s)
            else:
                tail = s[:i]
                if tail.strip():
                    result.append(tail.rstrip() + '\n')
    return ''.join(result)
</t>
<t tx="ekr.20220329095904.1">def test_Match(self):

    if py_version &lt; (3, 10):  # pragma: no cover
        self.skipTest('Require python 3.10')
    contents = r"""\
match node:
    # Passed...
    case 1: pass
    case (2, 3): pass
    case BinOp("+", a, BinOp("*", b, c)): pass
    case {"text": message, "color": c}: pass
    case 401 | 403 | 404: pass
    case xyzzy if a &gt; 1: pass
    case {"sound": _, "format": _}: pass
    case BinOp2("+", a, BinOp("*", d = 2)): pass
    case BinOp2("-", d, e = 2): pass
    case {"pat1": 2, **rest}: pass
    case _: pass
    case (4, 5, *rest): pass
    case [6, 5, *rest]: pass
    case ['a'|'b' as ab, c]: pass
    case True: pass
    case False: pass
    case None: pass
    case True | False | None: pass
    case True, False, None: pass  # A tuple!
"""
    try:
        # self.debug_list.append('contents')
        # self.debug_list.append('tokens')
        # self.debug_list.append('tree')
        # self.debug_list.append('full-traceback')
        self.make_data(contents)
    finally:
        self.debug_list = []
</t>
<t tx="ekr.20220401034726.1"># Match(expr subject, match_case* cases)

# match_case = (pattern pattern, expr? guard, stmt* body)

# Full syntax diagram: # https://peps.python.org/pep-0634/#appendix-a

def do_Match(self, node: Node) -&gt; None:

    cases = getattr(node, 'cases', [])
    self.name('match')
    self.visit(node.subject)
    self.op(':')
    for case in cases:
        self.visit(case)
</t>
<t tx="ekr.20220401034726.10"># MatchValue(expr value)

def do_MatchValue(self, node: Node) -&gt; None:

    self.visit(node.value)
</t>
<t tx="ekr.20220401034726.2">#  match_case = (pattern pattern, expr? guard, stmt* body)

def do_match_case(self, node: Node) -&gt; None:

    guard = getattr(node, 'guard', None)
    body = getattr(node, 'body', [])
    self.name('case')
    self.visit(node.pattern)
    if guard:
        self.name('if')
        self.visit(guard)
    self.op(':')
    for statement in body:
        self.visit(statement)
</t>
<t tx="ekr.20220401034726.3"># MatchAs(pattern? pattern, identifier? name)

def do_MatchAs(self, node: Node) -&gt; None:
    pattern = getattr(node, 'pattern', None)
    name = getattr(node, 'name', None)
    if pattern and name:
        self.visit(pattern)
        self.name('as')
        self.name(name)
    elif pattern:
        self.visit(pattern)  # pragma: no cover
    else:
        self.name(name or '_')
</t>
<t tx="ekr.20220401034726.4"># MatchClass(expr cls, pattern* patterns, identifier* kwd_attrs, pattern* kwd_patterns)

def do_MatchClass(self, node: Node) -&gt; None:

    patterns = getattr(node, 'patterns', [])
    kwd_attrs = getattr(node, 'kwd_attrs', [])
    kwd_patterns = getattr(node, 'kwd_patterns', [])
    self.visit(node.cls)
    self.op('(')
    for pattern in patterns:
        self.visit(pattern)
    for i, kwd_attr in enumerate(kwd_attrs):
        self.name(kwd_attr)  # a String.
        self.op('=')
        self.visit(kwd_patterns[i])
    self.op(')')
</t>
<t tx="ekr.20220401034726.5"># MatchMapping(expr* keys, pattern* patterns, identifier? rest)

def do_MatchMapping(self, node: Node) -&gt; None:
    keys = getattr(node, 'keys', [])
    patterns = getattr(node, 'patterns', [])
    rest = getattr(node, 'rest', None)
    self.op('{')
    for i, key in enumerate(keys):
        self.visit(key)
        self.op(':')
        self.visit(patterns[i])
    if rest:
        self.op('**')
        self.name(rest)  # A string.
    self.op('}')
</t>
<t tx="ekr.20220401034726.6"># MatchOr(pattern* patterns)

def do_MatchOr(self, node: Node) -&gt; None:
    patterns = getattr(node, 'patterns', [])
    for i, pattern in enumerate(patterns):
        if i &gt; 0:
            self.op('|')
        self.visit(pattern)
</t>
<t tx="ekr.20220401034726.7"># MatchSequence(pattern* patterns)

def do_MatchSequence(self, node: Node) -&gt; None:
    patterns = getattr(node, 'patterns', [])
    # Scan for the next '(' or '[' token, skipping the 'case' token.
    token = None
    for token in self.tokens[self.px + 1 :]:
        if token.kind == 'op' and token.value in '([':
            break
        if is_significant_token(token):
            # An implicit tuple: there is no '(' or '[' token.
            token = None
            break
    else:
        raise AssignLinksError('Ill-formed tuple')  # pragma: no cover
    if token:
        self.op(token.value)
    for pattern in patterns:
        self.visit(pattern)
    if token:
        self.op(']' if token.value == '[' else ')')
</t>
<t tx="ekr.20220401034726.8"># MatchSingleton(constant value)

def do_MatchSingleton(self, node: Node) -&gt; None:
    """Match True, False or None."""
    # g.trace(repr(node.value))
    self.token('name', repr(node.value))
</t>
<t tx="ekr.20220401034726.9"># MatchStar(identifier? name)

def do_MatchStar(self, node: Node) -&gt; None:
    name = getattr(node, 'name', None)
    self.op('*')
    if name:
        self.name(name)
</t>
<t tx="ekr.20220402052020.1"># The synchronizer sync tokens to nodes.
</t>
<t tx="ekr.20220402052102.1">def sync_op(self, val: str) -&gt; None:
    """
    Sync to the given operator.

    val may be '(' or ')' *only* if the parens *will* actually exist in the
    token list.
    """
    self.sync_token('op', val)

op = sync_op  # For readability.
</t>
<t tx="ekr.20220410180439.1">error_patterns = (g.flake8_pat, g.mypy_pat, g.pyflakes_pat, g.pylint_pat, g.python_pat)

# This table encodes which groups extract the filename and line_number from global regex patterns.
# This is the *only* method that should need to know this information!

link_table: list[tuple[int, int, Any]] = [
    # (filename_i, line_number_i, pattern)
    (1, 2, g.flake8_pat),
    (1, 2, g.mypy_pat),
    (1, 2, g.pyflakes_pat),
    (1, 2, g.pylint_pat),
    (1, 2, g.python_pat),
]

def put_html_links(self, s: str) -&gt; bool:
    """
    If *any* line in s contains a matches against known error patterns,
    then output *all* lines in s to the log, and return True.

    Otherwise, return False.
    """
    c = self.c
    trace = False and not g.unitTesting

    @others  # Define helpers

    # Report any bad chars.
    printables = string.ascii_letters + string.digits + string.punctuation + ' ' + '\n'
    bad = list(set(ch for ch in s if ch not in printables))
    # Strip bad chars.
    if bad:
        g.trace('Strip unprintables', repr(bad), 'in', repr(s))
        # Strip unprintable chars.
        s = ''.join(ch for ch in s if ch in printables)
    lines = s.split('\n')
    # Return False if no lines match initially. This is an efficiency measure.
    for line in lines:
        m, junk, junk = find_match(line)
        if m:
            break
    else:
        return False  # The caller must handle s.

    # Compute the list of @&lt;file&gt; nodes.
    at_file_nodes = [z for z in c.all_positions() if z.isAnyAtFileNode()]

    # Output each line using log.put, with or without a nodeLink.
    found_matches = 0
    for i, line in enumerate(lines):
        m, filename_i, line_number_i = find_match(line)
        if m:
            filename = m.group(filename_i)
            line_number = m.group(line_number_i)
            p = find_at_file_node(filename)
            if p:
                unl = p.get_UNL()
                found_matches += 1
                if trace:
                    # LeoQtLog.put writes: f'&lt;a href="{url}" title="{nodeLink}"&gt;{s}&lt;/a&gt;'
                    g.trace(f"{unl}::-{line_number}")
                self.put(line, nodeLink=f"{unl}::-{line_number}")  # Use global line.
            else:  # An unusual case.
                message = f"no p for {filename!r}"
                if g.unitTesting:
                    raise ValueError(message)
                    # g.trace(f"{i:2} p not found! {filename!r}")
                self.put(line)
        else:  # None of the patterns match.
            self.put(line)
    return bool(found_matches)
</t>
<t tx="ekr.20220411085334.1">def to_html(self, color: str, s: str) -&gt; str:
    """Convert s to html."""
    s = s.replace('&amp;', '&amp;amp;').replace('&lt;', '&amp;lt;').replace('&gt;', '&amp;gt;')
    # #884: Always convert leading blanks and tabs to &amp;nbsp.
    n = len(s) - len(s.lstrip())
    if n &gt; 0 and s.strip():
        s = '&amp;nbsp;' * (n) + s[n:]
    if not self.wrap:
        # Convert all other blanks to &amp;nbsp;
        s = s.replace(' ', '&amp;nbsp;')
    s = s.replace('\n', '&lt;br&gt;')  # The caller is responsible for newlines!
    s = f'&lt;font color="{color}"&gt;{s}&lt;/font&gt;'
    return s
</t>
<t tx="ekr.20220411165627.1">def test_put_html_links(self):

    c, p = self.c, self.c.p
    # Create a test outline.
    assert p == self.root_p
    assert p.h == 'root'
    p2 = p.insertAsLastChild()
    p2.h = '@file test_file.py'
    # Run the tests.
    table = (
        # python.
        (True, 'File "test_file.py", line 5'),
        # pylint.
        (True, r'leo\unittest\test_file.py:1326:8: W0101: Unreachable code (unreachable)'),
        # pyflakes.
        (True, r"test_file.py:51:13 'leo.core.leoQt5.*' imported but unused"),
        # mypy...
        (True, 'test_file.py:116: error: Function is missing a return type annotation  [no-untyped-def]'),
        (True, r'leo\core\test_file.py:116: note: Use "-&gt; None" if function does not return a value'),
        (False, 'Found 1 error in 1 file (checked 1 source file)'),
        (False, 'mypy: done'),
        # Random output.
        (False, 'Hello world\n'),
    )
    for expected, s in table:
        s = s.replace('\\', os.sep).rstrip() + '\n'
        result = c.frame.log.put_html_links(s)
        self.assertEqual(result, expected, msg=repr(s))
</t>
<t tx="ekr.20220412084258.1">def find_at_file_node(filename: str) -&gt; Position:
    """Find a position corresponding to filename s"""
    target = os.path.normpath(filename)
    parts = target.split(os.sep)
    while parts:
        target = os.sep.join(parts)
        parts.pop(0)
        # Search twice, preferring exact matches.
        for p in at_file_nodes:
            if target == os.path.normpath(p.anyAtFileNodeName()):
                return p
        for p in at_file_nodes:
            if os.path.normpath(p.anyAtFileNodeName()).endswith(target):
                return p
    return None
</t>
<t tx="ekr.20220415013957.1">if TYPE_CHECKING:  # pragma: no cover
    from leo.core.leoChapters import ChapterController
    from leo.core.leoCommands import Commands as Cmdr
    from leo.core.leoGui import LeoKeyEvent as Event
    from leo.core.leoGui import LeoGui
    from leo.core.leoMenu import LeoMenu, NullMenu
    from leo.core.leoNodes import Position, VNode
    from leo.plugins.qt_frame import DynamicWindow
    from leo.plugins.qt_text import QTextEditWrapper as Wrapper
    from leo.plugins.qt_text import LeoQtBody, LeoQtLog, LeoQtMenu, LeoQtTree, QtIconBarClass
    from leo.plugins.notebook import NbController
    Widget = Any
</t>
<t tx="ekr.20220420100806.1">def find_match(line: str) -&gt; tuple[Any, int, int]:
    """Search line for any pattern in link_table."""
    if not line.strip():
        return None, None, None
    for filename_i, line_number_i, pattern in self.link_table:
        m = pattern.match(line)
        if m:
            return m, filename_i, line_number_i
    return None, None, None
</t>
<t tx="ekr.20220425052306.1">compound_statement = (
    # Leo doesn't use 'match'
    'async ', 'class ', 'def ', 'else:', 'elif ', 'except',
    'finally:', 'for ', 'if ', 'try:', 'while ', 'with ',
)
pat = re.compile(r'\)\s*-&gt;.*:\s*$')  # End of multiline def.

def convert(p: Any) -&gt; None:
    """Convert all hanging comments in p.b."""
    if p.isAnyAtFileNode():
        print('   Scan:', p.h)
    changed, last, result = False, '', []
    i, lines = 0, p.b.split('\n')
    sep = '-' * 40
    while i &lt; len(lines):
        progress = i
        more_lines = []
        s = lines[i]
        s_s = s.lstrip()
        last_s = last.lstrip()
        lws_s = compute_lws(s)
        lws_last = compute_lws(last)
        if (
            last_s and s_s.startswith('#')
            and not pat.match(last_s)
            and not last_s.startswith(('#', '"""', "'''"))
            and not last_s.endswith(('[', '(', '{', '):'))
            and not last_s.startswith(compound_statement)
            and lws_last &lt; lws_s
        ):
            changed = True
            result.pop()  # Discard the last line!
            j = i + 1  # Look for more indented lines.
            while j &lt; len(lines):
                s2 = lines[j]
                s2_s = s2.strip()
                lws_s2 = compute_lws(s2)
                if lws_s2 &gt;= lws_s and s2_s.startswith('#'):
                    more_lines.append(s2)
                    j += 1
                else:
                    break
            if not more_lines and len(last_s) + len(s_s) &lt; max_line_length:
                # Emit one line.
                result.append(f"{last}  {s_s}")
                if trace:
                    g.printObj([last, s, sep, f"{last}  {s_s}\n"], tag=p.h)
            else:
                # Emit the first comment line.
                result.append(f"{lws_last}{s_s}")
                # Emit any additional comment lines.
                for z in more_lines:
                    result.append(f"{lws_last}{z.lstrip()}")
                # Emit the last (non-comment) line.
                result.append(last)
                if trace:
                    added_lines = [f"{lws_last}{z.lstrip()}" for z in more_lines]
                    g.printObj(
                        [last, s] + more_lines + [sep] +
                        [f"{lws_last}{s_s}"] + added_lines + [last], tag=p.h)
            i += 1 + len(more_lines)
            last = lines[i]
        else:
            result.append(s)
            last = s
            i += 1
        assert progress &lt; i
    if changed:
        print('Changed:', p.h)
        if replace:
            p.b = '\n'.join(result)
</t>
<t tx="ekr.20220425184232.1">def compute_lws(s: str) -&gt; int:
    """Return the leading whitespace of s."""
    n = len(s) - len(s.lstrip())
    return s[:n]
</t>
<t tx="ekr.20220503081113.1">g.cls()
import re
&lt;&lt; init core_p, command_p and globals_p &gt;&gt;
d = {}  # Dict[func-name, True]
# If I were going to do more work I would do the following:
# exclusions: Dict[str, list[str]] = {}
exclusions = set()  # Set[func-name]
@others
# Create d...
scan(core_p)
scan(command_p)
scan(globals_p)
suppress = ('c',)  # 'g', 'p',
count = 0
words = list(sorted(z for z in d.keys() if z not in suppress))
functions_pat = re.compile(fr".*\b({'|'.join(words)})\b\s*[^(]")
# Check functions...
check(core_p)
check(command_p)
check(globals_p)
print('Found', count)
g.printObj(list(sorted(exclusions)), tag='Function appearing in special contexts')
</t>
<t tx="ekr.20220503084045.1">def_pat = re.compile(r'^\s*def ([\w_]+)\s*\(')

def scan(root: "Position") -&gt; None:
    """Add entries in d for all function/method definitions."""
    for p in root.subtree():
        for s in p.b.split('\n'):
            m = def_pat.match(s)
            if m:
                name = m.group(1)
                if not name.startswith('__'):
                    d [m.group(1)] = True</t>
<t tx="ekr.20220503084230.1">def check(root: "Position") -&gt; None:
    """Print any functions in d that don't look like a function call."""
    global count
    print('Check:', root.h)
    skipping = None
    for p in root.subtree():
        skipping = False
        if '@language rest' in p.b:
            continue
        for s in p.b.split('\n'):
            ss = s.strip()
            # Handle skipping modes...
            if skipping == '@':
                if ss.startswith('@c'):
                    skipping = None
                continue
            if skipping:
                for skipping in ('"""', "'''"):
                    if skipping in ss:
                        skipping = None
                        continue
                continue
            # Not skipping strings. Ignore comments.
            assert not skipping, repr(skipping)
            i = ss.find('#')
            if i &gt; -1:
                ss = ss[:i].strip()
            if not ss:
                continue
            # Start skipping modes.
            if ss.startswith('@ ') or ss=='@':
                skipping = '@'
                continue
            if ss.count('"""') == 1:
                skipping = '"""'
                continue
            if ss.count("'''") == 1:
                skipping = "'''"
                continue
            if '"' in ss or "'" in ss:  # Ignore lines containing strings.
                continue
            # Skip special cases.
            if ss.startswith((
                '&lt;&lt;', '@cmd', '@g.command',
                'def', 'from', 'import', 'print',
            )):
                continue
            m = functions_pat.match(ss)
            if not m:
                continue
            # The function is in the line.
            # Ignore if it is within any kind of special context.
            h = g.truncate(p.h, 25)
            func = m.group(1)
            args_pat = re.compile(rf".*?[\w_]+\s*\(.*?\b{func}\b.*?\)")
            array_pat = re.compile(rf".*?\b{func}\b\s*(\[|\])")
            op_pat = re.compile(
                rf".*?\b{func}\b\s*(\=|\&lt;|\&gt;|\+|\-|\,|\)|\:|\!|\%|"
                rf"in\b|is\b|and\b|or\b|else\b|if\b|not\b)"
            )
            attr_pat = re.compile(rf".*\b{func}\.")
            if args_pat.match(ss):
                if 0: print(f"  Arg: {h:30} {func:20} {ss}")
                exclusions.add(func)
            elif array_pat.match(ss):
                if 0: print(f"Array: {h:30} {func:20} {ss}")
                exclusions.add(func)
            elif op_pat.match(ss):
                if 0: print(f"   OP: {h:30} {func:20} {ss}")
                exclusions.add(func)
            elif attr_pat.match(ss):
                if 0: print(f" Attr: {h:30} {func:20} {ss}")
                exclusions.add(func)
            else:
                count += 1
                print(f"Found: {h:30} {func:20} {ss}")</t>
<t tx="ekr.20220503084900.1">core_p = g.findNodeAnywhere(c, 'Core classes')
command_p = g.findNodeAnywhere(c, 'Command classes')
globals_p = g.findNodeAnywhere(c, '@file leoGlobals.py')
assert core_p and command_p and globals_p
</t>
<t tx="ekr.20220503193901.1"># 'exception',
# Imports...
    # 'commands', 'cmd', 'core', 'external', 'gui_plugins', 'import_module',
    # 'modes', 'modules',
    # 'os', 'pickle', 'plugins', 'rst3', 'test', 'tests',
# Functions/methods...
# 'caller', 'callers', 'copy', 'count', 'end', 'fileName',
# 'ivars', 'key', 'kind', 'level', 'match', 'remove', 'trace',
    # 'add', 'add_to_dot', 'backup', 'blank',
    # 'caller', 'callers', 'children', 'clone', 'cls', 'command_name', 'commanders',
    # 'commit', 'convert', 'copy', 'count',
    # 'delegate', 'do', 'done', 'dump', 'encode', 'end', 'error', 'es', 'exists', 'expand',
    # 'filename', 'fileName', 'find', 'flush', 'get',
    # 'handler', 'handler1', 'handler2', 'hash',
    # 'IdleTime', 'ignore', 'indent', 'it', 'items', 'ivars', 'join', 'key', 'keys', 'kind',
    # 'level', 'lt', 'lower', 'lws', 'match', 'message', 'name', 'new', 'next', 'nodes', 'note',
    # 'on_idle', 'open', 'parents', 'path', 'predicate', 'put',
    # 'read', 'readline', 'red', 'redoHelper', 'remove', 'replace', 'report', 'rt',
    # 'scan', 'select', 'set', 'show', 'start', 'stop',
    # 'toString', 'toUnicode', 'trace', 'translateString',
    # 'underline', 'undoHelper', 'unl', 'values', 'visit',
    # 'warn', 'warning', 'word',</t>
<t tx="ekr.20220527065937.1">g.cls()
import json
import os
import textwrap
path = r'C:\Repos\leo-editor\mypy_stubs\3.9\leo\core\leoApp.data.json'
with open(path, 'r') as f:
    d = json.load(f)

def make_outline(d, p, topFlag):
    """Set p.b from dict d. Generate child nodes for inner dicts.."""
    result = []
    for key, value in d.items():
        if isinstance(value, dict):
            h2 = 'top' if topFlag else p.h[2:-2].strip()
            section_name = g.angleBrackets(f" {h2}.{key} ")
            result.append(f'"{key}": {{\n')
            result.append(f"    {section_name}\n")
            result.append('}\n')
            child = p.insertAsLastChild()
            child.h = section_name
            make_outline(value, child, topFlag=False)
        elif isinstance(value, str):
            result.append(f'"{key}": "{value}"\n')
        else:
            result.append(f'"{key}": {value}\n')
    p.b = ''.join(result)

# Recursively make the outline.
top = c.lastTopLevel().insertAfter()
top.h = os.path.basename(path)
make_outline(d, top, topFlag=True)
# Adjust top.b.
top.b = f"{{\n{textwrap.indent(top.b.strip(),' '*4)}\n}}\n"
c.redraw(top)
    </t>
<t tx="ekr.20220704211851.1">for match in g.unl_regex.finditer(line):
    # Don't open if we click after the unl.
    if match.start() &lt;= col &lt; match.end():
        unl = match.group()
        g.handleUnl(unl, c)
        return None
</t>
<t tx="ekr.20220720043557.1">class Python_Importer(Importer):
    """Leo's Python importer"""

    language = 'python'
    string_list = ['"""', "'''", '"', "'"]  # longest first.
    allow_preamble = True

    # The default patterns. Overridden in the Cython_Importer class.
    # Group 1 matches the name of the class/def.
    async_def_pat = re.compile(r'\s*async\s+def\s*(\w+)\s*\(')
    def_pat = re.compile(r'\s*def\s*(\w+)\s*\(')
    class_pat = re.compile(r'\s*class\s*(\w+)')

    block_patterns: tuple = (
        ('class', class_pat),
        ('async def', async_def_pat),
        ('def', def_pat),
    )

    @others
</t>
<t tx="ekr.20220728055719.1"># Pattern that matches any compound statement.
compound_statements_s = '|'.join([
    rf"\b{z}\b" for z in (
        'case', 'catch', 'class', 'do', 'else', 'for', 'if', 'switch', 'try', 'while',
    )
])
compound_statements_pat = re.compile(compound_statements_s)

# Pattern that *might* be continued on the next line.
multi_line_func_pat = re.compile(r'.*?\b(\w+)\s*\(.*?\)\s*(const)?')

def find_blocks(self, i1: int, i2: int) -&gt; list[Block]:
    """
    C_Importer.find_blocks: override Importer.find_blocks.

    Find all blocks in the given range of *guide* lines from which blanks
    and tabs have been deleted.

    Return a list of Blocks, that is, tuples(name, start, start_body, end).
    """
    lines = self.guide_lines
    i, prev_i, result = i1, i1, []
    while i &lt; i2:
        s = lines[i]
        i += 1
        for kind, pattern in self.block_patterns:
            m = pattern.match(s)
            m2 = self.multi_line_func_pat.match(s)
            if m:
                name = m.group(1) or ''
                if (
                    # Don't match if the line contains a trailing '}'.
                    '}' not in s[m.end(1) :]
                    # Don't match compound statements.
                    and not self.compound_statements_pat.match(name)
                ):
                    end = self.find_end_of_block(i, i2)
                    assert i1 + 1 &lt;= end &lt;= i2, (i1, end, i2)
                    result.append((kind, name, prev_i, i, end))
                    i = prev_i = end
                    break
            elif m2 and i &lt; i2:
                # Don't match compound statements.
                name = m2.group(1) or ''
                if (
                    # The next line must start with '{'
                    lines[i].strip().startswith('{')
                    # Don't match compound statements.
                    and not self.compound_statements_pat.match(name)
                ):
                    end = self.find_end_of_block(i + 1, i2)
                    assert i1 + 1 &lt;= end &lt;= i2, (i1, end, i2)
                    result.append(('func', name, prev_i, i + 1, end))
                    i = prev_i = end
                    break
    return result
</t>
<t tx="ekr.20220805071838.1">def dump_headlines(self, c: Cmdr, tag: str = None) -&gt; None:  # pragma: no cover
    """Dump all headlines."""
    print('')
    g.trace(f"{tag or ''} {c.fileName()}")
    print('')
    for p in c.all_positions():
        print(f"{p.gnx:25}: {' '*p.level()}{p.h}")
</t>
<t tx="ekr.20220806170537.1">def dump_string(self, s: str, tag: str = None) -&gt; None:
    if tag:
        print(tag)
    g.printObj([f"{i:2} {z.rstrip()}" for i, z in enumerate(g.splitLines(s))])
</t>
<t tx="ekr.20220809054555.1">def check_round_trip(self, p: Position, s: str) -&gt; None:
    """Assert that p's outline is equivalent to s."""
    c = self.c
    s = s.rstrip()  # Ignore trailing whitespace.
    result_s = c.atFileCommands.atAutoToString(p).rstrip()  # Ignore trailing whitespace.
    # Ignore leading whitespace and all blank lines.
    s_lines = [z.lstrip() for z in g.splitLines(s) if z.strip()]
    result_lines = [z.lstrip() for z in g.splitLines(result_s) if z.strip()]
    if s_lines != result_lines:
        g.trace('FAIL', g.caller(2))
        g.printObj([f"{i:&lt;4} {z}" for i, z in enumerate(s_lines)], tag=f"expected: {p.h}")
        g.printObj([f"{i:&lt;4} {z}" for i, z in enumerate(result_lines)], tag=f"results: {p.h}")
    self.assertEqual(s_lines, result_lines)
</t>
<t tx="ekr.20220820051212.1">if TYPE_CHECKING:  # pragma: no cover
    from leo.core.leoApp import PreviousSettings
    from leo.core.leoGui import LeoKeyEvent as Event
    from leo.core.leoNodes import Position, VNode
    # 11 subcommanders...
    from leo.core.leoAtFile import AtFile
    from leo.core.leoChapters import ChapterController
    from leo.core.leoFileCommands import FileCommands
    from leo.core.leoFind import LeoFind
    from leo.core.leoImport import LeoImportCommands
    from leo.core.leoIPython import InternalIPKernel
    from leo.core.leoKeys import KeyHandlerClass
    from leo.core.leoHistory import NodeHistory
    from leo.core.leoPersistence import PersistenceDataController
    from leo.core.leoPrinting import PrintingController
    from leo.core.leoShadow import ShadowController
    from leo.core.leoUndo import Undoer
    from leo.core.leoVim import VimCommands
    # 14 command handlers...
    from leo.commands.abbrevCommands import AbbrevCommandsClass
    from leo.commands.bufferCommands import BufferCommandsClass
    from leo.commands.controlCommands import ControlCommandsClass
    from leo.commands.convertCommands import ConvertCommandsClass
    from leo.commands.debugCommands import DebugCommandsClass
    from leo.commands.editCommands import EditCommandsClass
    from leo.commands.editFileCommands import EditFileCommandsClass
    from leo.commands.gotoCommands import GoToCommands
    from leo.commands.helpCommands import HelpCommandsClass
    from leo.commands.keyCommands import KeyHandlerCommandsClass
    from leo.commands.killBufferCommands import KillBufferCommandsClass
    from leo.commands.rectangleCommands import RectangleCommandsClass
    from leo.core.leoRst import RstCommands
    from leo.commands.spellCommands import SpellCommandsClass
    # Other objects...
    from leo.core.leoGui import LeoGui
    from leo.plugins.qt_gui import StyleSheetManager
    from leo.plugins.qt_text import QTextEditWrapper as Wrapper
    RegexFlag = Union[int, re.RegexFlag]  # re.RegexFlag does not define 0
    Widget = Any
</t>
<t tx="ekr.20220820162604.1">binding = g.app.trace_binding
# First, see if the binding is for a command. (Doesn't work for plugin commands).
if localFlag and binding in c.k.killedBindings:
    g.es_print(
        f"--trace-binding: {c.shortFileName()} "
        f"sets {binding} to None")
elif localFlag and binding in c.commandsDict:
    d = c.k.computeInverseBindingDict()
    g.trace(
        f"--trace-binding: {c.shortFileName():20} "
        f"binds {binding} to {d.get(binding) or []}")
else:
    stroke = g.KeyStroke(binding)
    bi_list = inverted_new_d.get(stroke)
    if bi_list:
        print('')
        for bi in bi_list:
            fn = bi.kind.split(' ')[-1]  # bi.kind #
            stroke2 = c.k.prettyPrintKey(stroke)
            if bi.pane and bi.pane != 'all':
                pane = f" in {bi.pane} panes"
            else:
                pane = ''
            g.es_print(
                f"--trace-binding: {fn:20} binds {stroke2} "
                f"to {bi.commandName:&gt;20}{pane}")
        print('')
</t>
<t tx="ekr.20220823130338.1">"""Ensure that all expected @&lt;file&gt; nodes exist."""
g.cls()
import glob
import os
join, norm, sep = os.path.join, os.path.normpath, os.sep

# Compute the directories.
leo_dir = norm(join(g.app.loadDir, '..', '..'))
core_dir = join(leo_dir, 'core')
commands_dir = join(leo_dir, 'commands')
external_dir = join(leo_dir, 'external')
plugins_dir = join(leo_dir, 'plugins')

def make_list(pattern):
    return [norm(z) for z in glob.glob(pattern) if '__init__' not in z]

# Find paths on disk.
core_files = make_list(f"{core_dir}{sep}*.py")
commands_files = make_list(f"{commands_dir}{sep}*.py")
external_files = make_list(f"{external_dir}{sep}*.py")
plugin_files = make_list(f"{plugins_dir}{sep}*.py")

# Compute paths from @&lt;file&gt; nodes.
at_file_paths = sorted([
    norm(c.fullPath(z))
        for z in c.all_unique_positions()
            if z.isAnyAtFileNode()
])

# g.printObj(at_file_paths, tag='known paths')

excluded_files = (
    r'plugins\qt_main.py',  # Generated automatically.
    r'plugins\baseNativeTree.py',  # No longer used.
)

def is_excluded(path):
    return any(z in path for z in excluded_files)

# Ensure that @&lt;file&gt; nodes exist for every file on disk.
missing = []
for z in core_files + external_files + plugin_files:
    if z not in at_file_paths and not is_excluded(z):
        missing.append(z)
if missing:
    g.printObj(missing, tag='missing')
else:
    print('No missing files!')
print('done')</t>
<t tx="ekr.20220823195205.1">"""
Stand alone GUI free index builder for Leo's full text search system::

  python leoftsindex.py &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;...

If the file name starts with @ it's a assumed to be a simple
text file listing files to be indexed.

If &lt;file&gt; does not contain '#' it's assumed to be a .leo file
to index, and is indexed.

If &lt;file&gt; does contain '#' it's assumed to be a .leo file
containing a list of .leo files to index, with the list in
the node indicated by the UNL after the #, e.g.::

   path/to/myfile.leo#Lists--&gt;List of outlines

In the latter case, if the node identified by the UNL has children,
the list of files to scan is built from the first line of the body
of each child node of the identified node (works well with bookmarks.py).
If the node identified by the UNL does not have children, the
node's body is assumed to be a simple text listing of paths to .leo files).

.. note::

    It may be necessary to quote the "file" on the command line,
    as the '#' may be interpreted as a comment delimiter::

        python leoftsindex.py "workbook.leo#Links"


"""

import sys
# add folder containing 'leo' folder to path
# sys.path.append("/home/tbrown/Package/leo/bzr/leo.repo/trunk")
import leo.core.leoBridge as leoBridge
import leo.plugins.leofts as leofts

controller = leoBridge.controller(
    gui='nullGui',
    loadPlugins=False,  # True: attempt to load plugins.
    readSettings=False,  # True: read standard settings files.
    silent=False,  # True: don't print signon messages.
    verbose=False
)
g = controller.globals()

# list of "files" to process
files = sys.argv[1:]

# set up leofts
leofts.set_leo(g)
g._gnxcache = leofts.GnxCache()
fts = leofts.get_fts()

fn2c = {}  # cache to avoid loading same outline twice
done = set()  # outlines scanned, to avoid repetition repetition

todo = list(files)

while todo:

    item = todo.pop(0)

    print("INDEX: %s" % item)

    if '#' in item:
        fn, node = item.split('#', 1)
    else:
        fn, node = item, None

    if node:
        c = fn2c.setdefault(fn, controller.openLeoFile(fn))
        found, dummy, p = g.recursiveUNLSearch(node.split('--&gt;'), c)
        if not found:
            print("Could not find '%s'" % item)
            break
        if not p:
            p = c.p
        if p.hasChildren():
            # use file named in first node of each child
            files = [chl.b.strip().split('\n', 1)[0].strip() for chl in p.children()]
        else:
            # use all files listed in body
            files = [i.strip() for i in p.b.strip().split('\n')]

    elif fn.startswith('@'):
        todo.extend(open(fn[1:]).read().strip().split('\n'))
        files = []

    else:
        files = [fn]

    for fn in files:

        # file names may still have '#' if taken from a node list
        real_name = fn.split('#', 1)[0]
        if real_name in done:
            continue
        done.add(real_name)

        if len(files) != 1:
            print(" FILE: %s" % real_name)

        c = fn2c.setdefault(real_name, controller.openLeoFile(fn))
        fts.drop_document(real_name)
        fts.index_nodes(c)
@language python
@tabwidth -4
</t>
<t tx="ekr.20220904210247.1"># This is a copy of the @enabled-plugins node from leoSettings.leo,
# ensuring that the @enabled-plugins node in myLeoSettings.leo has no effect.

# Standard plugins...

plugins_menu.py     # Adds 'Plugins' menu.
contextmenu.py      # Required by the vim.py and xemacs.py plugins.
mod_autosave.py
mod_scripting.py
nav_qt.py           # Forward/back buttons &amp; goto-next/prev-history-node
nodetags.py
quicksearch.py      # Nav pane.
todo.py             # Task pane.
viewrendered.py     # (Or viewrendered3.py) Plugins menu support.
</t>
<t tx="ekr.20220905044353.1">def updateIcon(self) -&gt; None:
    """Update any user icon."""
    c, v = self.context, self
    try:
        tree = c.frame.tree  # May not exist at startup.
        if not tree:
            return
        if not hasattr(tree, 'nodeIconsDict'):  # Only exists for Qt gui.
            return
    except AttributeError:
        return

    # #2870: Clear the icon cache (Remove v.gnx from the dict).
    tree.nodeIconsDict.pop(v.gnx, None)
    icon = tree.getIcon(v)
    items = tree.vnode2items(v)
    for item in items:
        tree.setItemIcon(item, icon)
</t>
<t tx="ekr.20220920120550.1">@language rest
@wrap

*** This issue has been assigned the "Later" milestone.

Many mypy warnings remain.

https://github.com/leo-editor/leo-editor/issues/2882
PR: https://github.com/leo-editor/leo-editor/pull/2883

@language python
@nosearch
</t>
<t tx="ekr.20220920202642.1"></t>
<t tx="ekr.20220922085357.1">def removeButtons(self) -&gt; None:
    if not self._buttons:
        return
    for b in self._buttons:
        self.c.frame.iconBar.deleteButton(b)
    self._buttons = None
</t>
<t tx="ekr.20221104065722.1">def test_parse_body(self):

    c = self.c
    u = c.undoer
    x = c.importCommands
    target = c.p.insertAfter()
    target.h = 'target'

    body_1 = textwrap.dedent(
    """
        import os

        def macro(func):
            def new_func(*args, **kwds):
                raise RuntimeError('blah blah blah')
        return new_func
    """).strip() + '\n'
    target.b = body_1
    x.parse_body(target)

    expected_results = (
        (0, '',  # Ignore the top-level headline.
            '&lt;&lt; target: preamble &gt;&gt;\n'
            '@others\n'
            'return new_func\n'
            '@language python\n'
            '@tabwidth -4\n'
        ),
        (1, '&lt;&lt; target: preamble &gt;&gt;',
            'import os\n'
            '\n'
        ),
        (1, 'def macro',
            'def macro(func):\n'
            '    @others\n'
        ),
        (2, 'def new_func',
            'def new_func(*args, **kwds):\n'
            "    raise RuntimeError('blah blah blah')\n"
        ),
    )
    # Don't call run_test.
    self.check_outline(target, expected_results)

    # Test undo
    u.undo()
    self.assertEqual(target.b, body_1, msg='undo test')
    self.assertFalse(target.hasChildren(),  msg='undo test')
    # Test redo
    u.redo()
    self.check_outline(target, expected_results)
</t>
<t tx="ekr.20221129012213.1"># See flake8 settings in setup.cfg.</t>
<t tx="ekr.20221201043917.1">@language batch
@echo off
cd %~dp0..\..

call reindent-leo.cmd

echo test-leo
py -m unittest %*
</t>
<t tx="ekr.20221201080228.1">@language python
#!/usr/bin/env python3

# from leo.core import leoGlobals as g

tag = 'blacken_leo.py:'

try:
    import black
    print('blacken_leo.py: black', black)
except ImportError:
    print('blacken_leo.py: can not import black')
    
print(tag, '*** Call black.main ***')
black.main()
    
# try:
    # from black import __main__
    # print(tag, __main__)
# except Exception as e:
    # print(tag, e)
</t>
<t tx="ekr.20221204070905.1"></t>
<t tx="ekr.20221204071056.1">@language batch
@echo off
cd %~dp0..\..

echo pylint-leo
time /T
call py -m pylint leo --extension-pkg-allow-list=PyQt6.QtCore,PyQt6.QtGui,PyQt6.QtWidgets %*
time /T
</t>
<t tx="ekr.20221204071146.1">@language batch
@echo off
cd %~dp0..\..

rem See leo-editor/.mypy.ini for exclusions!
rem Always use the fast (official) version of mypy.

echo mypy-leo
py -m mypy --debug-cache leo %*
</t>
<t tx="ekr.20221204071220.1">@language batch
@echo off
cls
cd %~dp0..\..

echo test-one-leo
call py -m unittest leo.unittests.core.test_leoGlobals.TestGlobals.test_g_handleScriptException
</t>
<t tx="ekr.20221204071554.1">@language batch
@echo off
cls
cd %~dp0..\..

echo full-test-leo
rem call reindent-leo.cmd
rem call beautify-leo.cmd
call test-leo.cmd
rem echo.
call ruff-leo.cmd
call mypy-leo.cmd
rem call flake8-leo.cmd
rem call pylint-leo.cmd
rem echo.
echo Done!
</t>
<t tx="ekr.20221204072154.1">@language batch
@echo off
cd %~dp0..\..

:: Save path to reindent.py to a file .leo\reindent-path.txt
call py %~dp0\find-reindent.py

set PATH_FILE=%USERPROFILE%\.leo\reindent-path.txt
set /P "REINDENT_PATH="&lt; %PATH_FILE%

:: echo %REINDENT_PATH%

if "%REINDENT_PATH%"=="" goto no_reindent

echo reindent-leo

rem echo reindent leo/core
call py %REINDENT_PATH% -r leo\core
rem echo reindent leo/commands
call py %REINDENT_PATH% -r leo\commands
rem echo reindent leo/plugins/importers
call py %REINDENT_PATH% -r leo\plugins\importers
rem echo reindent leo/plugins/writers
call py %REINDENT_PATH% -r leo\plugins\writers
rem echo reindent leo/unittests
call py %REINDENT_PATH% -r leo\unittests
goto done

:no_reindent
echo Cannot find reindent.py, skipping reindentation

:done
</t>
<t tx="ekr.20221204072456.1">@language batch
@echo off
cd %~dp0..\..

echo beautify-leo
call py -m leo.core.leoAst --orange --recursive leo\core
call py -m leo.core.leoAst --orange --recursive leo\commands
call py -m leo.core.leoAst --orange --recursive leo\plugins\importers
call py -m leo.core.leoAst --orange --recursive leo\plugins\writers
rem call py -m leo.core.leoAst --orange --recursive leo\modes

</t>
<t tx="ekr.20221204074235.1">@language batch
@echo off
cd %~dp0..\..

rem: See leo-editor/setup.cfg for defaults.

echo flake8-leo
py -m flake8 %*
</t>
<t tx="ekr.20230115020533.1">@language batch
@echo off
cd %~dp0..\..

echo black leo.core
call py -m black --skip-string-normalization leo\core
</t>
<t tx="ekr.20230131234527.1">def test_g_objToString(self):

    &lt;&lt; define s &gt;&gt;
    &lt;&lt; define class TestClass &gt;&gt;
    table = (
        (s, 'String1'),
        ('This is a test', "String2"),
        ({'a': 1, 'b': 2}, 'Dict'),
        (['one', 'two', 'three'], 'List'),
        (('x', 'y'), 'Tuple'),
        (g.printObj, 'Function'),
        (TestClass, "Class"),
        (TestClass(), "Instance"),
        (TestClass.test_function, 'unbound method'),
        (TestClass().test_function,'bound method')
    )
    for data, tag in table:
        result = g.objToString(data, tag=tag)
        self.assertTrue(tag in result, msg=data)
        self.assertTrue(isinstance(result, str))
        result2 = g.objToString(data)
        self.assertTrue(isinstance(result2, str))
</t>
<t tx="ekr.20230131234637.1">s = """g.cls()

def f1():
    g.trace(g.callers(1))
    g.trace(g.callers_list(1))
    f2()

def f2():
    print('')
    g.trace(g.callers(2))
    g.trace(g.callers_list(2))
    f3()

def f3():
    print('')
    g.trace(g.callers(2))
    g.trace(g.callers_list(2))
    t = TestClass()
    assert t

def f4():
    print('')
    g.trace(g.callers())
    g.trace(g.callers_list())

class TestClass:
    def __init__(self):
        print('')
        g.trace('(TestClass)')
        f4()

f1()
"""
</t>
<t tx="ekr.20230131234648.1">class TestClass:

    def test_function(self):
        pass
</t>
<t tx="ekr.20230206004301.1">@language batch
@echo off
cls
rem -a: write all files  (make clean)
cd %~dp0..\..
cd leo\doc\html

echo.
echo sphinx-build -a (make clean)
echo.
sphinx-build -M html . _build -a
</t>
<t tx="ekr.20230221153849.1">def test_g_handleScriptException(self):

    c = self.c
    table = (
        'test_leoGlobals.py", line',
        'in test_g_handleScriptException',
        'print(1/0)',
        'ZeroDivisionError: division by zero'
    )
    with self.assertRaises(ZeroDivisionError):
        try:
            print(1/0)
        except ZeroDivisionError:
            old_stdout = sys.stdout
            sys.stdout = io.StringIO()
            g.handleScriptException(c, c.p)
            report = sys.stdout.getvalue()
            for s in table:
                assert s in report, repr(s)
            sys.stdout = old_stdout
            # print(report)
            raise
</t>
<t tx="ekr.20230306104439.1">def printColorSettings(self) -&gt; None:
    """
    Print the value of all @color settings.

    The following shows where the each setting comes from:

    -     leoSettings.leo,
    -  @  @button, @command, @mode.
    - [D] default settings.
    - [F] indicates the file being loaded,
    - [M] myLeoSettings.leo,
    - [T] theme .leo file.
    """
    legend = '''\
legend:
    leoSettings.leo
 @  @button, @command, @mode
[D] default settings
[F] loaded .leo File
[M] myLeoSettings.leo
[T] theme .leo file.
'''
    c = self.c
    if g.unitTesting:
        return
    legend = textwrap.dedent(legend)
    result = []
    for name, val, _c, letter in g.app.config.config_iter(c):
        if name.strip().startswith('@color'):
            kind = '   ' if letter == ' ' else f"[{letter}]"
            result.append(f"{kind} {name} = {val}\n")
    # Use a single g.es statement.
    result.append('\n' + legend)
    g.es_print('', ''.join(result), tabName='Settings')
</t>
<t tx="ekr.20230306104456.1">def printFontSettings(self) -&gt; None:
    """
    Print the value of every @font setting.

    The following shows where the each setting comes from:

    -     leoSettings.leo,
    -  @  @button, @command, @mode.
    - [D] default settings.
    - [F] indicates the file being loaded,
    - [M] myLeoSettings.leo,
    - [T] theme .leo file.
    """
    legend = '''\
legend:
    leoSettings.leo
 @  @button, @command, @mode
[D] default settings
[F] loaded .leo File
[M] myLeoSettings.leo
[T] theme .leo file.
'''
    c = self.c
    if g.unitTesting:
        return
    legend = textwrap.dedent(legend)
    result = []
    for name, val, _c, letter in g.app.config.config_iter(c):
        # @font nodes set @family, @weight, @slant, @size settings.
        if name.strip().startswith(('@font', '@family', '@weight', '@slant', '@size')):
            kind = '   ' if letter == ' ' else f"[{letter}]"
            result.append(f"{kind} {name} = {val}\n")
    # Use a single g.es statement.
    result.append('\n' + legend)
    g.es_print('', ''.join(result), tabName='Settings')
</t>
<t tx="ekr.20230318040137.1">@language rest
@nosearch

PR: https://github.com/leo-editor/leo-editor/pull/3215

@language python
</t>
<t tx="ekr.20230325055810.1">def test_g_findGnx(self):
    c = self.c

    # Define per-commander data.
    self._define_per_commander_data()

    # Test all error messages for all paths.
    for data in self.files_data:  # &lt;@file&gt; &lt;filename&gt;
        kind, relative_path = data
        headline = msg = f"{kind} {relative_path}"
        self._make_tree(c, headline)
        test_p = g.findNodeAnywhere(c, headline)
        self.assertTrue(test_p)
        result2 = g.findGnx(test_p.gnx, c)
        self.assertEqual(result2, test_p, msg=msg)

    # Create the test tree.
    self._make_tree(c, 'Root')
    # Test all positions.
    for p in c.all_positions():
        for gnx in (f"{p.gnx}", f"{p.gnx}::0"):
            self.assertEqual(p, g.findGnx(gnx, c), msg=gnx)
</t>
<t tx="ekr.20230330042647.1">def _make_tree(self, c, root_h=None):
    """Make a test tree for c."""
    ### c = self.c
    root = c.rootPosition()
    root.h = root_h or 'Root'
    root.b = "def root():\n    pass\n"
    last = root

    def make_child(n, p):
        p2 = p.insertAsLastChild()
        p2.h = f"child {n}"
        p2.b = (
            f"def child{n}():\n"
            f"    v{n} = 2\n"
            f"    # node {n} line 1: blabla second blabla bla second ble blu\n"
            f"    # node {n} line 2: blabla second blabla bla second ble blu"
        )
        return p2

    def make_top(n, sib):
        p = sib.insertAfter()
        p.h = f"Node {n}"
        p.b = (
            f"def top{n}():\n:"
            f"    v{n} = 3\n"
        )
        return p

    for n in range(0, 4, 3):
        last = make_top(n + 1, last)
        child = make_child(n + 2, last)
        make_child(n + 3, child)

    for p in c.all_positions():
        p.v.clearDirty()
        p.v.clearVisited()

    # Always start with the root selected.
    c.selectPosition(c.rootPosition())
</t>
<t tx="ekr.20230402232100.1">def fullPath(self, p: Position, simulate: bool = False) -&gt; str:
    """
    Return the full path (including fileName) in effect at p. Neither the
    path nor the fileName will be created if it does not exist.
    """
    c = self
    # Search p and p's parents.
    for p in p.self_and_parents(copy=False):
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        fn = p.h if simulate else p.anyAtFileNodeName()  # Use p.h for unit tests.
        if fn:
            return g.finalize_join(path, fn)
    return ''
</t>
<t tx="ekr.20230424051945.1"></t>
<t tx="ekr.20230506095516.1">class TestAnnotations(unittest.TestCase):
    """Test that annotations of c, g, p, s, v are as expected."""

    @others
</t>
<t tx="ekr.20230506095648.1">class TestChains(unittest.TestCase):
    """Ensure that only certain chains exist."""

    @others
</t>
<t tx="ekr.20230506111649.1">class AnnotationsTraverser(NodeVisitor):

    annotations_set = set()

    def __init__(self, tester):
        super().__init__()
        self.tester = tester

    @others
</t>
<t tx="ekr.20230506111649.3">def visit_AnnAssign(self, node):
    # AnnAssign(expr target, expr annotation, expr? value, int simple)
    if isinstance(node.target, ast.Name):
        if node.annotation:
            id_s = node.target.id
            self.test_annotation(node, id_s, node.annotation)
</t>
<t tx="ekr.20230506111649.4">def visit_FunctionDef(self, node):
    arguments = node.args
    for arg in arguments.args:
        # arg = (identifier arg, expr? annotation, string? type_comment)
        assert isinstance(arg, ast.arg)
        annotation = getattr(arg, 'annotation', None)
        if annotation:
            id_s = arg.arg
            self.test_annotation(node, id_s, annotation)
    self.generic_visit(node) # Visit all children.
</t>
<t tx="ekr.20230506111927.1">class ChainsTraverser(NodeVisitor):

    chains_set = set()

    def visit_Attribute(self, node):
        """
        Add only top-level Attribute chains to chains_set.
        Do *not* call generic_visit!
        """
        chain = ast.unparse(node)
        self.chains_set.add(chain)
</t>
<t tx="ekr.20230506123402.1">annotation_table = (
    (re.compile(r'\b(c[0-9]?|[\w_]+_c)\b'), 'Cmdr'),
    (re.compile(r'\b(p[0-9]?|[\w_]+_p)\b'), 'Position'),
    (re.compile(r'\b(s[0-9]?|[\w_]+_s)\b'), 'str'),
    (re.compile(r'\b(v[0-9]?|[\w_]+_v)\b'), 'VNode'),
)

def test_annotation(self, node: ast.AST, identifier: str, annotation: ast.Expr) -&gt; None:
    """Test the annotation of identifier."""
    exceptions = (
        # Problem annotating Cmdr in leoCommands.py...
        'add_commandCallback', 'bringToFront', 'universalCallback',
        #
        'find_language', # p_or_v is a false match.
        # These methods should always be annotated Any.
        '__eq__', '__ne__',
        'resolveArchivedPosition',
        'setBodyString', 'setHeadString',
        'to_encoded_string', 'to_unicode', 'toUnicode',
    )
    for pattern, expected_annotation in self.annotation_table:
        m = pattern.match(identifier)
        if not m:
            continue
        node_s = g.splitLines(ast.unparse(node))[0].strip()
        if any(node_s.startswith(f"def {z}") for z in exceptions):
            continue
        annotation_s = ast.unparse(annotation)
        self.annotations_set.add(f"{identifier:&gt;20}: {annotation_s}")
        expected = (
            expected_annotation,
            f"'{expected_annotation}'",
            f"Optional[{expected_annotation}]",
            f"Optional['{expected_annotation}']")
        msg = (
            'test_annotation\n'
            f"    path: {self.tester.path}\n"
            f"    node: {node_s}\n"
            f"expected: {expected_annotation}\n"
            f"     got: {annotation_s}")
        if 0:  # Production.
            self.tester.assertTrue(annotation_s in expected, msg=msg)
        else:  # Allow multiple failures.
            if annotation_s not in expected:
                print(msg)
</t>
<t tx="ekr.20230507080042.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3317
PR2: https://github.com/leo-editor/leo-editor/pull/3319

@language python
</t>
<t tx="ekr.20230507122715.1"></t>
<t tx="ekr.20230507122923.1">def slow_test_all_paths(self):

    load_files()
    traverser = ChainsTraverser()
    traverser.chains_set = set()
    for path in files_dict:
        contents, tree = files_dict [path]
        traverser.visit(tree)
    chains_list = [filter_chain(z) for z in sorted(list(traverser.chains_set))]
    long_chains_list = [z for z in chains_list if z.count('.') &gt; 2]
    if 0:  # Print prefixes.
        prefixes = ['.'.join(z.split('.')[0:2]) for z in long_chains_list]
        for z in sorted(list(set(prefixes))):
            if z.startswith(('c.', 'p.', 'v.')):
                print(z)
    if 0:
        print(f"{len(chains_list)} chains:")
        print(f"{len(long_chains_list)} long chains:")
    if 0:
        for z in long_chains_list:
            print(z)
    if 0:
        dump_chains(chains_list, long_chains_list)
    self.assertTrue(len(long_chains_list) &gt; 400)
</t>
<t tx="ekr.20230507122925.1">def test_one_chain(self):
    contents = textwrap.dedent('''\
        w = c.frame.body.wrapper.widget
''')
    tree = ast.parse(contents, filename='test_one_chain')
    traverser = ChainsTraverser()
    traverser.chains_set = set()
    traverser.visit(tree)
    chains_list = list(traverser.chains_set)
    chain = filter_chain(chains_list[0])
    self.assertEqual(chain, 'c.frame.body.wrapper.widget')
</t>
<t tx="ekr.20230507170833.1">def dump_chains(chains_list, long_chains_list):

    c_pat = re.compile(r'\b(c[0-9]?|[\w_]+_c)\b')
    p_pat = re.compile(r'\b(p[0-9]?|[\w_]+_p)\b')
    # s_pat = re.compile(r'\b(s[0-9]?|[\w_]+_s)\b')
    v_pat = re.compile(r'\b(v[0-9]?|[\w_]+_v)\b')
    pats = (c_pat, p_pat, v_pat)

    print(g.callers(1))
    for s in long_chains_list:
        if any(pat.match(s) for pat in pats):
            print(s)
</t>
<t tx="ekr.20230507171657.1">def test_bare_chain(self):
    contents = 'leoImport.MORE_Importer(c).import_file(fn)'
    tree = ast.parse(contents, filename='test_one_chain')
    traverser = ChainsTraverser()
    traverser.chains_set = set()
    traverser.visit(tree)
    chains_list = list(traverser.chains_set)
    chain = filter_chain(chains_list[0])
    self.assertEqual(chain, 'leoImport.MORE_Importer().import_file')
</t>
<t tx="ekr.20230508085817.1"></t>
<t tx="ekr.20230508145335.1"># These tests load (once) all files in leo/core, leo/commands and leo/plugins/qt_*.py.
g.cls()
g.execute_shell_commands(
    'python -m unittest '
    # 'leo.unittests.test_design.TestAnnotations.slow_test_all_paths '
    # 'leo.unittests.test_design.TestChains.slow_test_all_paths'
    # 'leo.unittests.core.test_leoImport.TestLeoImport.slow_test_ric_run',
    # 'leo.unittests.commands.test_editFileCommands.TestEditFileCommands.verbose_test_git_diff',
    # f" {commands}.test_editFileCommands.TestEditFileCommands.slow_test_gdc_node_history",

)
</t>
<t tx="ekr.20230508150535.1">def slow_test_all_paths(self):
    load_files()
    traverser = AnnotationsTraverser(tester=self)
    for path in files_dict:
        self.path = path
        contents, tree = files_dict [path]
        traverser.visit(tree)
    if 0:
        for s in sorted(list(traverser.annotations_set)):
            print(s)
</t>
<t tx="ekr.20230509205648.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3327
PR: https://github.com/leo-editor/leo-editor/pull/3330


@language python
</t>
<t tx="ekr.20230511074046.1">commands = 'leo.unittests.commands'
core = 'leo.unittests.core'
design = 'leo.unittests.test_design'
gui = 'leo.unittests.test_gui'
importers = 'leo.unittests.test_importers'
syntax = 'leo.unittests.test_syntax'
#
testAtFile = 'test_leoAtFile.TestAtFile'
testColorizer = 'test_leoColorizer.TestColorizer'
testCommands = 'test_leoCommands.TestCommands'
testGlobals = 'test_leoGlobals.TestGlobals'
</t>
<t tx="ekr.20230514135132.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3343
PR: https://github.com/leo-editor/leo-editor/pull/3345

@language python
</t>
<t tx="ekr.20230514135259.1"></t>
<t tx="ekr.20230514140918.1">def find_blocks(self, i1: int, i2: int) -&gt; list[Block]:
    """
    Python_Importer.find_blocks: override Importer.find_blocks.

    Find all blocks in the given range of *guide* lines from which blanks
    and tabs have been deleted.

    Return a list of Blocks, that is, tuples(name, start, start_body, end).
    """
    i, prev_i, results = i1, i1, []
    while i &lt; i2:
        s = self.guide_lines[i]
        i += 1
        for kind, pattern in self.block_patterns:
            m = pattern.match(s)
            if m:
                # cython may include trailing whitespace.
                name = m.group(1).strip()
                end = self.find_end_of_block(i, i2)
                assert i1 + 1 &lt;= end &lt;= i2, (i1, end, i2)
                results.append((kind, name, prev_i, i, end))
                i = prev_i = end
                break
    return results
</t>
<t tx="ekr.20230514140918.4">def find_end_of_block(self, i: int, i2: int) -&gt; int:
    """
    i is the index of the class/def line (within the *guide* lines).

    Return the index of the line *following* the entire class/def

    Note: All following blank/comment lines are *excluded* from the block.
    """
    def lws_n(s: str) -&gt; int:
        """Return the length of the leading whitespace for s."""
        return len(s) - len(s.lstrip())

    prev_line = self.guide_lines[i - 1]
    kinds = ('class', 'def', '-&gt;')  # '-&gt;' denotes a coffeescript function.
    assert any(z in prev_line for z in kinds), (i, repr(prev_line))
    # Handle multi-line def's. Scan to the line containing a close parenthesis.
    if prev_line.strip().startswith('def ') and ')' not in prev_line:
        while i &lt; i2:
            i += 1
            if ')' in self.guide_lines[i - 1]:
                break
    tail_lines = 0
    if i &lt; i2:
        lws1 = lws_n(prev_line)
        while i &lt; i2:
            s = self.guide_lines[i]
            i += 1
            if s.strip():
                if lws_n(s) &lt;= lws1:
                    # A non-comment line that ends the block.
                    # Exclude all tail lines.
                    return i - tail_lines - 1
                # A non-comment line that does not end the block.
                tail_lines = 0
            else:
                # A comment line.
                tail_lines += 1
    return i2 - tail_lines
</t>
<t tx="ekr.20230514195224.1">def test_delete_comments_and_strings(self):

    from leo.plugins.importers.python import Python_Importer
    importer = Python_Importer(self.c)

    lines = [
        'i = 1 # comment.\n',
        's = "string"\n',
        "s2 = 'string'\n",
        'if 1:\n',
        '    pass \n',
        '"""\n',
        '    if 1: a = 2\n',
        '"""\n',
        "'''\n",
        '    if 2: a = 2\n',
        "'''\n",
        'i = 2\n'
    ]
    expected_lines = [
        'i = 1 \n',
        's = \n',
        's2 = \n',
        'if 1:\n',
        '    pass \n',
        '\n',
        '\n',
        '\n',
        '\n',
        '\n',
        '\n',
        'i = 2\n'
    ]
    result = importer.delete_comments_and_strings(lines)
    self.assertEqual(len(result), len(expected_lines))
    self.assertEqual(result, expected_lines)
</t>
<t tx="ekr.20230514223556.1">def test_basic(self):
    s = (
        'import sys\n'
        'def f1():\n'
        '    pass # comment 1\n'
        # 'class Class1:\n'
        # '    def method1():\n'
        # '        pass # comment1\n'
        # '    def method2():\n'
        # '        pass # comment2\n'
        # '\n'
        
        '# About main.\n'  # This will be associated with the *previous* block.
        'def main():\n'
        '    pass\n'
        '\n'
        "if __name__ == '__main__':\n"
        '    main()\n'
    )
    expected_results = (
        (0, '', # check_outline ignores the first headline
                '@others\n'
                "if __name__ == '__main__':\n"
                '    main()\n'
                '@language python\n'
                '@tabwidth -4\n'
        ),
        (1, 'def f1',
                'import sys\n'
                'def f1():\n'
                '    pass # comment 1\n'
                '# About main.\n'
        ),
        (1, 'def main',
                'def main():\n'
                '    pass\n'
        )
    )
    p = self.run_test(s, strict_flag=False, check_flag=False)
    self.check_outline(p, expected_results, trace_results=False)
</t>
<t tx="ekr.20230515074705.1"></t>
<t tx="ekr.20230515172316.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3346
PR: https://github.com/leo-editor/leo-editor/pull/3347

@language python
</t>
<t tx="ekr.20230526124600.1">def new_run_test(self, s: str, expected_results: tuple) -&gt; None:
    """
    Run a unit test of an import scanner,
    i.e., create a tree from string s at location p.
    """
    c, ext, p = self.c, self.ext, self.c.p
    self.assertTrue(ext)

    # Run the test.
    parent = p.insertAsLastChild()
    kind = self.compute_unit_test_kind(ext)

    # TestCase.id() has the form leo.unittests.core.file.class.test_name
    id_parts = self.id().split('.')
    self.short_id = f"{id_parts[-2]}.{id_parts[-1]}"
    parent.h = f"{kind} {self.short_id}"

    # createOutline calls Importer.gen_lines and Importer.check.
    test_s = textwrap.dedent(s).strip() + '\n'
    c.importCommands.createOutline(parent.copy(), ext, test_s)

    # Dump the actual results on failure and raise AssertionError.
    self.check_outline(parent, expected_results)
</t>
<t tx="ekr.20230526135305.1">def check_outline(self, p: Position, expected: tuple) -&gt; None:
    """
    BaseTestImporter.check_outline.

    Check that p's outline matches the expected results.

    Dump the actual outline if there is a mismatch.
    """
    try:
        p0_level = p.level()
        actual = [(z.level(), z.h, z.b) for z in p.self_and_subtree()]
        for i, actual in enumerate(actual):
            try:
                a_level, a_h, a_str = actual
                e_level, e_h, e_str = expected[i]
            except ValueError:
                assert False  # So we print the actual results.
            msg = f"FAIL in node {i} {e_h}"
            self.assertEqual(a_level - p0_level, e_level, msg=msg)
            if i &gt; 0:  # Don't test top-level headline.
                self.assertEqual(e_h, a_h, msg=msg)
            self.assertEqual(g.splitLines(e_str), g.splitLines(a_str), msg=msg)
    except AssertionError:
        # Dump actual results, including bodies.
        self.dump_tree(p, tag='Actual results...')
        raise
</t>
<t tx="ekr.20230527075112.1">def new_round_trip_test(self, s: str, expected_s: str = None) -&gt; None:
    p = self.run_test(s)
    self.check_round_trip(p, expected_s or s)
</t>
<t tx="ekr.20230529075138.10">def find_blocks(self, i1: int, i2: int) -&gt; list[Block]:
    """
    Importer.find_blocks.

    Find all blocks in the given range of *guide* lines.

    Use the patterns in self.block_patterns to find the start the start of a block.

    Subclasses may override this method for more control.

    Return a list of Blocks, that is, tuples(kind, name, start, start_body, end).
    """
    min_size = self.minimum_block_size
    i, prev_i, results = i1, i1, []
    while i &lt; i2:
        s = self.guide_lines[i]
        i += 1
        # Assume that no pattern matches a compound statement.
        for kind, pattern in self.block_patterns:
            m = pattern.match(s)
            if m:
                # cython may include trailing whitespace.
                name = m.group(1).strip()
                end = self.find_end_of_block(i, i2)
                assert i1 + 1 &lt;= end &lt;= i2, (i1, end, i2)
                # Don't generate small blocks.
                if min_size == 0 or end - prev_i &gt; min_size:
                    results.append((kind, name, prev_i, i, end))
                    i = prev_i = end
                else:
                    i = end
                break
    return results
</t>
<t tx="ekr.20230529075138.11">def find_end_of_block(self, i: int, i2: int) -&gt; int:
    """
    Importer.find_end_of_block.

    Return the index of end of the block.
    i: The index of the (guide) line *following* the start of the block.
    i2: The inedex last (guide) line to be scanned.

    This method assumes that that '{' and '}' delimit blocks.
    Subclasses may override this method as necessary.
    """
    level = 1  # All blocks start with '{'
    while i &lt; i2:
        line = self.guide_lines[i]
        i += 1
        for ch in line:
            if ch == '{':
                level += 1
            if ch == '}':
                level -= 1
                if level == 0:
                    return i
    return i2
</t>
<t tx="ekr.20230529075138.12">def make_guide_lines(self, lines: list[str]) -&gt; list[str]:
    """
    Importer.make_guide_lines.

    Return a list if **guide lines** that simplify the detection of blocks.

    This default method removes all comments and strings from the original lines.

    The perl importer overrides this methods to delete regexes as well
    as comments and strings.
    """
    return self.delete_comments_and_strings(lines[:])
</t>
<t tx="ekr.20230529075138.13">def compute_headline(self, block: Block) -&gt; str:
    """
    Importer.compute_headline.

    Return the headline for the given block.

    Subclasses may override this method as necessary.
    """
    child_kind, child_name, child_start, child_start_body, child_end = block
    return f"{child_kind} {child_name}" if child_name else f"unnamed {child_kind}"

</t>
<t tx="ekr.20230529075138.14">def gen_block(self, block: Block, parent: Position) -&gt; None:
    """
    Importer.gen_block.

    Create all descendant blocks and their parent nodes.

    Five importers override this method to take full control over finding
    blocks.
    """
    lines = self.lines
    kind, name, start, start_body, end = block
    assert start &lt;= start_body &lt;= end, (start, start_body, end)

    # Find all blocks in the body of this block.
    blocks = self.find_blocks(start_body, end)
    if 0:
        self.trace_blocks(blocks)
    if blocks:
        common_lws = self.compute_common_lws(blocks)
        # Start with the head: lines[start : start_start_body].
        result_list = lines[start:start_body]
        # Special case: create a preamble node as the first child of the parent.
        if self.allow_preamble and parent == self.root and start == 0:
            self.create_preamble(blocks, parent, result_list)
        # Add indented @others.
        result_list.extend([f"{common_lws}@others\n"])
        # Recursively generate the inner nodes/blocks.
        last_end = end
        for block in blocks:
            child_kind, child_name, child_start, child_start_body, child_end = block
            last_end = child_end
            # Generate the child containing the new block.
            child = parent.insertAsLastChild()
            child.h = self.compute_headline(block)
            self.gen_block(block, child)
            # Remove common_lws.
            self.remove_common_lws(common_lws, child)
        # Add any tail lines.
        result_list.extend(lines[last_end:end])
    else:
        result_list = lines[start:end]
    # Delete extra leading and trailing whitespace.
    parent.b = ''.join(result_list).lstrip('\n').rstrip() + '\n'
</t>
<t tx="ekr.20230529075138.15">def gen_lines(self, lines: list[str], parent: Position) -&gt; None:
    """
    Importer.gen_lines: Allocate lines to the parent and descendant nodes.

    Subclasses may override this method, but none do.
    """
    try:
        assert self.root == parent, (self.root, parent)
        self.lines = lines
        # Delete all children.
        parent.deleteAllChildren()
        # Create the guide lines.
        self.guide_lines = self.make_guide_lines(lines)
        n1, n2 = len(self.lines), len(self.guide_lines)
        assert n1 == n2, (n1, n2)
        # Start the recursion.
        block = ('outer', 'parent', 0, 0, len(lines))
        self.gen_block(block, parent=parent)
    except ImporterError as e:
        g.trace(f"Importer error: {e}")
        parent.deleteAllChildren()
        parent.b = ''.join(lines)
    except Exception:
        g.trace('Unexpected exception!')
        g.es_exception()
        parent.deleteAllChildren()
        parent.b = ''.join(lines)

    # Add trailing lines.
    parent.b += f"@language {self.language}\n@tabwidth {self.tab_width}\n"
</t>
<t tx="ekr.20230529075138.16">def remove_common_lws(self, lws: str, p: Position) -&gt; None:
    """Remove the given leading whitespace from all lines of p.b."""
    if len(lws) == 0:
        return
    assert lws.isspace(), repr(lws)
    n = len(lws)
    lines = g.splitLines(p.b)
    result: list[str] = []
    for line in lines:
        stripped_line = line.strip()
        assert not stripped_line or line.startswith(lws), repr(line)
        result.append(line[n:] if stripped_line else line)
    p.b = ''.join(result)
</t>
<t tx="ekr.20230529075138.17">def trace_blocks(self, blocks: list[Block]) -&gt; None:
    """For debugging: trace the list of blocks."""
    if not blocks:
        g.trace('No blocks')
        return
    print('')
    print('Blocks...')
    lines = self.lines
    for z in blocks:
        kind2, name2, start2, start_body2, end2 = z
        tag = f"  {kind2:&gt;10} {name2:&lt;20} {start2:4} {start_body2:4} {end2:4}"
        g.printObj(lines[start2:end2], tag=tag)
    print('End of Blocks')
    print('')
</t>
<t tx="ekr.20230529075138.34">def create_placeholders(self, level: int, lines_dict: dict, parents: list[Position]) -&gt; None:
    """
    Create placeholder nodes so between the current level (len(parents)) and the desired level.

    The org and otl importers use this method.
    """
    if level &lt;= len(parents):
        return
    n = level - len(parents)
    assert n &gt; 0
    assert level &gt;= 0
    while n &gt; 0:
        n -= 1
        parent = parents[-1]
        child = parent.insertAsLastChild()
        child.h = f"placeholder level {len(parents)}"
        parents.append(child)
        lines_dict[child.v] = []
</t>
<t tx="ekr.20230529075138.36">def check_blanks_and_tabs(self, lines: list[str]) -&gt; bool:  # pragma: no cover (missing test)
    """
    Importer.check_blanks_and_tabs.

    Check for intermixed blank &amp; tabs.

    Subclasses may override this method to suppress this check.
    """
    # Do a quick check for mixed leading tabs/blanks.
    fn = g.shortFileName(self.root.h)
    w = self.tab_width
    blanks = tabs = 0
    for s in lines:
        lws = self.get_str_lws(s)
        blanks += lws.count(' ')
        tabs += lws.count('\t')
    # Make sure whitespace matches @tabwidth directive.
    if w &lt; 0:
        ok = tabs == 0
        message = 'tabs found with @tabwidth %s in %s' % (w, fn)
    elif w &gt; 0:
        ok = blanks == 0
        message = 'blanks found with @tabwidth %s in %s' % (w, fn)
    if ok:
        ok = (blanks == 0 or tabs == 0)
        message = 'intermixed blanks and tabs in: %s' % (fn)
    if not ok:
        if g.unitTesting:
            assert False, message
        else:
            g.es(message)
    return ok
</t>
<t tx="ekr.20230529075138.37">def import_from_string(self, parent: Position, s: str) -&gt; None:
    """
    Importer.import_from_string.

    The top-level code for almost all importers.

    Overriding this method gives the subclass completed control.
    """
    c = self.c
    # Fix #449: Cloned @auto nodes duplicates section references.
    if parent.isCloned() and parent.hasChildren():  # pragma: no cover (missing test)
        return
    self.root = root = parent.copy()

    # Check for intermixed blanks and tabs.
    self.tab_width = c.getTabWidth(p=root)
    lines = g.splitLines(s)
    ws_ok = self.check_blanks_and_tabs(lines)  # Issues warnings.

    # Regularize leading whitespace
    if not ws_ok:
        lines = self.regularize_whitespace(lines)

    # A hook for xml importer: preprocess lines.
    lines = self.preprocess_lines(lines)

    # Generate all nodes.
    self.gen_lines(lines, parent)

    # Importers should never dirty the outline.
    # #1451: Do not change the outline's change status.
    for p in root.self_and_subtree():
        p.clearDirty()
</t>
<t tx="ekr.20230529075138.38">def preprocess_lines(self, lines: list[str]) -&gt; list[str]:
    """
    A hook to enable preprocessing lines before calling x.find_blocks.

    Xml_Importer uses this hook to split lines.
    """
    return lines
</t>
<t tx="ekr.20230529075138.39">def regularize_whitespace(self, lines: list[str]) -&gt; list[str]:  # pragma: no cover (missing test)
    """
    Importer.regularize_whitespace.

    Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.

    Subclasses may override this method to suppress this processing.
    """
    kind = 'tabs' if self.tab_width &gt; 0 else 'blanks'
    kind2 = 'blanks' if self.tab_width &gt; 0 else 'tabs'
    fn = g.shortFileName(self.root.h)
    count, result, tab_width = 0, [], self.tab_width
    if tab_width &lt; 0:  # Convert tabs to blanks.
        for n, line in enumerate(lines):
            i, w = g.skip_leading_ws_with_indent(line, 0, tab_width)
            # Use negative width.
            s = g.computeLeadingWhitespace(w, -abs(tab_width)) + line[i:]
            if s != line:
                count += 1
            result.append(s)
    elif tab_width &gt; 0:  # Convert blanks to tabs.
        for n, line in enumerate(lines):
            # Use positive width.
            s = g.optimizeLeadingWhitespace(line, abs(tab_width))
            if s != line:
                count += 1
            result.append(s)
    if count and not g.unitTesting:
        g.es(f"changed leading {kind2} to {kind} in {count} line{g.plural(count)} in {fn}")
    return result
</t>
<t tx="ekr.20230529075138.4">class Importer:
    """
    The base class for almost all of Leo's importers.

    Many importers only define `block_patterns` and `language` class ivars.

    Analyzing **guide lines** (lines without comments and strings)
    grealtly simplifies this class and all of Leo's importers.

    Subclasses may override the following methods to recognize blocks:

    Override `i.find_blocks` or `i.find_end_of_block1` to tweak `i.gen_block`.
    Override `i.gen_block` for more control.
    Override `i.import_from_string` for complete control.

    Subclasses may override these methods to handle the incoming text:

    Override `i.check_blanks_and tabs` to suppress warnings.
    Override `i.preprocess_lines` to adjust incoming lines.
    Override `i.regularize_whitespace` to allow mixed tabs and spaces.
    """

    # Don't split classes, functions or methods smaller than this value.
    minimum_block_size = 0  # 0: create all blocks.

    # Must be overridden in subclasses.
    language: str = None

    # May be overridden in subclasses.
    allow_preamble = False
    block_patterns: tuple = tuple()
    level_up_ch = '{'
    level_down_ch = '}'
    string_list: list[str] = ['"', "'"]

    @others
</t>
<t tx="ekr.20230529075138.42">def get_str_lws(self, s: str) -&gt; str:
    """Return the characters of the lws of s."""
    m = re.match(r'([ \t]*)', s)
    return m.group(0) if m else ''
</t>
<t tx="ekr.20230529075138.5">def __init__(self, c: Cmdr) -&gt; None:
    """Importer.__init__"""
    assert self.language, g.callers()  # Do not remove.
    self.c = c  # May be None.
    self.root: Position = None
    delims = g.set_delims_from_language(self.language)
    self.single_comment, self.block1, self.block2 = delims
    self.tab_width = 0  # Must be set later.
</t>
<t tx="ekr.20230529075138.7"># Subclasses are unlikely ever to need to override these methods.
</t>
<t tx="ekr.20230529075138.8">def compute_common_lws(self, blocks: list[Block]) -&gt; str:
    """
    Return the length of the common leading indentation of all non-blank
    lines in all blocks.

    This method assumes that no leading whitespace contains intermixed tabs and spaces.

    The returned string should consist of all blanks or all tabs.
    """
    if not blocks:
        return ''
    lws_list: list[int] = []
    for block in blocks:
        kind, name, start, start_body, end = block
        lines = self.lines[start:end]
        for line in lines:
            stripped_line = line.lstrip()
            if stripped_line:  # Skip empty lines
                lws_list.append(len(line[: -len(stripped_line)]))
    n = min(lws_list) if lws_list else 0
    ws_char = ' ' if self.tab_width &lt; 1 else '\t'
    return ws_char * n
</t>
<t tx="ekr.20230529075138.9">def delete_comments_and_strings(self, lines: list[str]) -&gt; list[str]:
    """
    Delete all comments and strings from the given lines.

    The resulting lines form **guide lines**. The input and guide
    lines are "parallel": they have the same number of lines.

    Analyzing the guide lines instead of the input lines is the
    simplifying trick behind the new importers.
    """
    string_delims = self.string_list
    line_comment, start_comment, end_comment = g.set_delims_from_language(self.language)
    target = ''  # The string ending a multi-line comment or string.
    escape = '\\'
    result = []
    for line in lines:
        result_line, skip_count = [], 0
        for i, ch in enumerate(line):
            if ch == '\n':
                break  # Avoid appending the newline twice.
            if skip_count &gt; 0:
                skip_count -= 1  # Skip the character.
                continue
            if target:
                if line.startswith(target, i):
                    if len(target) &gt; 1:
                        # Skip the remaining characters of the target.
                        skip_count = len(target) - 1
                    target = ''  # Begin accumulating characters.
            elif ch == escape:
                skip_count = 1
                continue
            elif line_comment and line.startswith(line_comment, i):
                break  # Skip the rest of the line.
            elif any(line.startswith(z, i) for z in string_delims):
                # Allow multi-character string delimiters.
                for z in string_delims:
                    if line.startswith(z, i):
                        target = z
                        if len(z) &gt; 1:
                            skip_count = len(z) - 1
                        break
            elif start_comment and line.startswith(start_comment, i):
                target = end_comment
                if len(start_comment) &gt; 1:
                    # Skip the remaining characters of the starting comment delim.
                    skip_count = len(start_comment) - 1
            else:
                result_line.append(ch)
        # End the line and append it to the result.
        if line.endswith('\n'):
            result_line.append('\n')
        result.append(''.join(result_line))
    assert len(result) == len(lines)  # A crucial invariant.
    return result
</t>
<t tx="ekr.20230529075640.1"></t>
<t tx="ekr.20230607163543.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3358
PR: https://github.com/leo-editor/leo-editor/pull/3362

@language python
</t>
<t tx="ekr.20230607164309.1">def test_struct(self):
    # From codon soources.
    s = """
    struct SrcInfoAttribute : public Attribute {
      static const std::string AttributeName;

      std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override {
        return std::make_unique&lt;SrcInfoAttribute&gt;(*this);
      }

    private:
      std::ostream &amp;doFormat(std::ostream &amp;os) const override { return os &lt;&lt; info; }
    };
    """
    expected_results = (
        (0, '',  # Ignore the first headline.
            '@others\n'
            '@language c\n'
            '@tabwidth -4\n'
        ),
        (1, 'struct SrcInfoAttribute',
             'struct SrcInfoAttribute : public Attribute {\n'
             '  static const std::string AttributeName;\n'
             '\n'
             '  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override {\n'
             '    return std::make_unique&lt;SrcInfoAttribute&gt;(*this);\n'
             '  }\n'
             '\n'
             'private:\n'
             '  std::ostream &amp;doFormat(std::ostream &amp;os) const override { return os &lt;&lt; info; }\n'
             '};\n'
        ),
    )
    self.new_run_test(s, expected_results)
</t>
<t tx="ekr.20230607170737.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/3359
PR: https://github.com/leo-editor/leo-editor/pull/3380

@language python
@nosearch
</t>
<t tx="ekr.20230607171025.1"></t>
<t tx="ekr.20230608053503.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/3328
PR: https://github.com/leo-editor/leo-editor/pull/3363

@language python
@nosearch
</t>
<t tx="ekr.20230608160541.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3364
PR: https://github.com/leo-editor/leo-editor/pull/3365

@language python
</t>
<t tx="ekr.20230609081427.1"></t>
<t tx="ekr.20230609122845.1">PR: https://github.com/leo-editor/leo-editor/pull/3367
</t>
<t tx="ekr.20230610154229.1">https://github.com/leo-editor/leo-editor/issues/3369
https://github.com/leo-editor/leo-editor/pull/3373
</t>
<t tx="ekr.20230611110204.1">https://github.com/leo-editor/leo-editor/pull/3372</t>
<t tx="ekr.20230612071030.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3375
PR: https://github.com/leo-editor/leo-editor/pull/3376

@language python
</t>
<t tx="ekr.20230612071112.1">https://github.com/leo-editor/leo-editor/pull/3377</t>
<t tx="ekr.20230612072414.1">def test_long_declaration(self):

    # ekr-mypy2/mypy/applytype.py

    # Note: the return type uses the python 3.11 syntax for Union.

    s = """
    def get_target_type(
        tvar: TypeVarLikeType,
        type: Type,
        callable: CallableType,
    ) -&gt; Type | None:
        if isinstance(tvar, ParamSpecType):
            return type
        if isinstance(tvar, TypeVarTupleType):
            return type
        return type
    """
    expected_results = (
        (0, '',  # Ignore the first headline.
                '@others\n'
                '@language python\n'
                '@tabwidth -4\n'
        ),
        (1, 'def get_target_type',
                'def get_target_type(\n'
                '    tvar: TypeVarLikeType,\n'
                '    type: Type,\n'
                '    callable: CallableType,\n'
                ') -&gt; Type | None:\n'
                '    if isinstance(tvar, ParamSpecType):\n'
                '        return type\n'
                '    if isinstance(tvar, TypeVarTupleType):\n'
                '        return type\n'
                '    return type\n'
        ),
    )
    self.new_run_test(s, expected_results)
</t>
<t tx="ekr.20230612072809.1"></t>
<t tx="ekr.20230612081544.1"></t>
<t tx="ekr.20230612084311.1"></t>
<t tx="ekr.20230612085239.1">def test_preamble(self):

    s = '''
        # This file is part of Leo: https://leo-editor.github.io/leo-editor
        """
        This is a docstring.
        """
        import sys
        from leo.core import leoGlobals as g

        def f():
            g.trace()
    '''
    expected_results = (
        (0, '',  # Ignore the first headline.
                '&lt;&lt; TestPython.test_preamble: docstring &gt;&gt;\n'
                '&lt;&lt; TestPython.test_preamble: declarations &gt;&gt;\n'
               '@others\n'
               '@language python\n'
               '@tabwidth -4\n'
        ),
        (1, '&lt;&lt; TestPython.test_preamble: docstring &gt;&gt;',
                '# This file is part of Leo: https://leo-editor.github.io/leo-editor\n'
                '"""\n'
                'This is a docstring.\n'
                '"""\n'
        ),
        (1, '&lt;&lt; TestPython.test_preamble: declarations &gt;&gt;',
                'import sys\n'
                'from leo.core import leoGlobals as g\n'
                '\n'
        ),
        (1, 'def f',
               'def f():\n'
               '    g.trace()\n'
        )
    )
    self.new_run_test(s, expected_results)
</t>
<t tx="ekr.20230612170928.1">def create_preamble(self, blocks: list[Block], parent: Position, result_list: list[str]) -&gt; None:
    """
    Importer.create_preamble: Create one preamble node.

    Subclasses may override this method to create multiple preamble nodes.
    """
    assert self.allow_preamble
    assert parent == self.root
    lines = self.lines
    common_lws = self.compute_common_lws(blocks)
    child_kind, child_name, child_start, child_start_body, child_end = blocks[0]
    new_start = max(0, child_start_body - 1)
    preamble = lines[:new_start]
    if preamble and any(z for z in preamble):
        child = parent.insertAsLastChild()
        section_name = '&lt;&lt; preamble &gt;&gt;'
        child.h = section_name
        child.b = ''.join(preamble)
        result_list.insert(0, f"{common_lws}{section_name}\n")
        # Adjust this block.
        blocks[0] = child_kind, child_name, new_start, child_start_body, child_end
</t>
<t tx="ekr.20230612171619.1">def create_preamble(self, blocks: list[Block], parent: Position, result_list: list[str]) -&gt; None:
    """
    Python_Importer.create_preamble:
    Create preamble nodes for the module docstrings and everything else.
    """
    assert self.allow_preamble
    assert parent == self.root
    lines = self.lines
    common_lws = self.compute_common_lws(blocks)
    child_kind, child_name, child_start, child_start_body, child_end = blocks[0]
    new_start = max(0, child_start_body - 1)
    preamble_lines = lines[:new_start]
    if not preamble_lines or not any(z for z in preamble_lines):
        return

    def make_node(index: int, preamble_lines: list[str], title: str) -&gt; None:
        child = parent.insertAsLastChild()
        parent_s = os.path.split(parent.h)[1].replace('@file', '').replace('@clean', '').strip()
        section_name = f"&lt;&lt; {parent_s}: {title} &gt;&gt;"
        child.h = section_name
        child.b = ''.join(preamble_lines)
        result_list.insert(index, f"{common_lws}{section_name}\n")

    def find_docstring() -&gt; list[str]:
        i = 0
        while i &lt; len(preamble_lines):
            for delim in ('"""', "'''"):
                if preamble_lines[i].count(delim) == 1:
                    i += 1
                    while i &lt; len(preamble_lines):
                        if preamble_lines[i].count(delim) == 1:
                            return preamble_lines[: i + 1]
                        i += 1
                    return []  # Mal-formed docstring.
            i += 1
        return []

    docstring_lines = find_docstring()
    if docstring_lines:
        make_node(0, docstring_lines, "docstring")
        declaration_lines = preamble_lines[len(docstring_lines) :]
        if declaration_lines:
            make_node(1, declaration_lines, "declarations")
    else:
        make_node(0, preamble_lines, "preamble")

    # Adjust this block.
    blocks[0] = child_kind, child_name, new_start, child_start_body, child_end
</t>
<t tx="ekr.20230612204810.1"></t>
<t tx="ekr.20230613092343.1"></t>
<t tx="ekr.20230613094743.1"></t>
<t tx="ekr.20230613235653.1">def test_ric_minimize_headlines(self):
    c, root = self.c, self.c.rootPosition()
    if sys.platform.startswith('win'):
        dir_ = 'C:/Repos/non-existent-directory/mypy'
    else:
        dir_ = '/Repos/non-existent-directory/mypy'
    # minimize_headlines changes only headlines that start with dir_ or @&lt;file&gt; dir_.
    table = (
        ('root', 'root'),
        (dir_, 'path: mypy'),
        (f"{dir_}/test", 'path: mypy/test'),
        (f"{dir_}/xyzzy/test2", 'path: mypy/xyzzy/test2'),
        (f"@clean {dir_}/x.py", '@clean x.py'),
    )
    x = leoImport.RecursiveImportController(c,
        dir_=dir_,
        kind='@clean',
        recursive=True,
        safe_at_file = False,
        theTypes=['.py'],
        verbose=False,
    )
    for h, expected in table:
        root.h = h
        x.minimize_headline(root)
        self.assertEqual(root.h, expected, msg=h)

    # Test that the recursive import only generates @&lt;file&gt; nodes containing absolute paths.
    for h in ('@file bad1.py', '@edit bad2.py'):
        with self.assertRaises(AssertionError, msg=h):
            root.h = h
            x.minimize_headline(root)
</t>
<t tx="ekr.20230614100733.1">https://github.com/leo-editor/leo-editor/pull/3379

</t>
<t tx="ekr.20230614124415.1"></t>
<t tx="ekr.20230614204314.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3368
PR: https://github.com/leo-editor/leo-editor/pull/3383

PEP 654: Exception Groups and except*
https://peps.python.org/pep-0654/
https://docs.python.org/3/whatsnew/3.11.html#pep-654-exception-groups-and-except

@language python
</t>
<t tx="ekr.20230615031918.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3381
PR: https://github.com/leo-editor/leo-editor/pull/3382

@language python
</t>
<t tx="ekr.20230615034517.1">def doSimpleOptions() -&gt; None:
    """Handle options without arguments."""
    &lt;&lt; define scanArgv helpers &gt;&gt;

    options_dict: dict[str, Callable] = {
        '-b': _black,
        '--black-sentinels': _black,
        '--diff': _diff,
        '--fail-fast': _fail_fast,
        '--fullscreen': _full_screen,
        '--listen-to-log': _listen_to_log,
        '--ipython': _ipython,
        '--maximized': _maximized,
        '--minimized': _minimized,
        '--no-plugins': _no_plugins,
        '--no-splash': _no_splash,
        '--quit': _quit,
        '--save-session': _save_session,
        '--silent': _silent,
    }
    for option, helper in options_dict.items():
        if option in sys.argv:
            helper()
</t>
<t tx="ekr.20230615034937.1">def check_options(self) -&gt; None:
    """Make sure all command-line options pass sanity checks."""
    option_prefixes = [z[:-1] for z in self.valid_options if z.endswith('=')]
    for arg in sys.argv:
        if arg in self.obsolete_options:
            print(f"Ignoring obsolete option: {arg!r}")
        elif arg.startswith('-'):
            for option in self.valid_options:
                if arg.startswith(option) and not arg.endswith('='):
                    break
            else:
                for prefix in option_prefixes:
                    if arg.startswith(prefix):
                        self.option_error(arg, 'Missing value')
                self.option_error(arg, 'Unknown option')
        else:
            # Do a simple check for file arguments.
            if any(z in arg for z in ',='):
                self.option_error(arg, 'Invalid file arg')
</t>
<t tx="ekr.20230615053133.1">def _black() -&gt; None:
    g.app.write_black_sentinels = True

def _diff() -&gt; None:
    g.app.diff = True

def _fail_fast() -&gt; None:
    g.app.failFast = True

def _full_screen() -&gt; None:
    g.app.start_fullscreen = True

def _listen_to_log() -&gt; None:
    g.app.listen_to_log_flag = True

def _ipython() -&gt; None:
    g.app.useIpython = True

def _maximized() -&gt; None:
    g.app.start_maximized = True

def _minimized() -&gt; None:
    g.app.start_minimized = True
    g.app.use_splash_screen = False

def _no_plugins() -&gt; None:
    g.app.enablePlugins = False

def _no_splash() -&gt; None:
    g.app.use_splash_screen = False

def _quit() -&gt; None:
    g.app.quit_after_load = True

def _save_session() -&gt; None:
    g.app.always_write_session_data = True

def _silent() -&gt; None:
    g.app.silentMode = True
</t>
<t tx="ekr.20230615055158.1">def doSelectOption() -&gt; Optional[str]:
    """Handle --select=headline"""
    m = utils.find_complex_option(r'--select=(.+)')
    return m.group(1) if m else None
</t>
<t tx="ekr.20230615060055.1">def doThemeOption() -&gt; Optional[str]:
    """Handle --theme=path"""
    m = utils.find_complex_option(r'--theme=(.+)')
    return m.group(1).replace('"', '') if m else None
</t>
<t tx="ekr.20230615062610.1">def compute_valid_options(self) -&gt; list[str]:
    """
    Return a list of valid options by parsing the given usage message.
    Options requiring an argument end with '='.
    """
    # Abbreviations (-whatever) must appear before full options (--whatever).
    option_pattern = re.compile(r'\s*(-\w)?,?\s*(--[\w-]+=?)')
    valid = ['-?']
    for line in g.splitLines(self.usage):
        m = option_pattern.match(line)
        if m:
            if m.group(1):
                valid.append(m.group(1))
            if m.group(2):
                valid.append(m.group(2))
    return sorted(list(set(valid)))
</t>
<t tx="ekr.20230615062931.1">def defineUsage() -&gt; str:
    """
    Return (that is, define) Leo's usage message.

    The g.OptionsUtils class uses this message to compute the list of valid options!
    """
    # Abbreviations (-whatever) must appear before full options (--whatever).
    return textwrap.dedent("""
usage: launchLeo.py [options] file1, file2, ...

options:
  -h, --help            show this help message and exit
  -b, --black-sentinels write black-compatible sentinel comments
  --diff                use Leo as an external git diff
  --fail-fast           stop unit tests after the first failure
  --fullscreen          start fullscreen
  --ipython             enable ipython support
  --gui=GUI             specify gui: browser,console,curses,qt,text,null
  --listen-to-log       start log_listener.py on startup
  --load-type=TYPE      @&lt;file&gt; type for non-outlines: @edit or @file
  --maximized           start maximized
  --minimized           start minimized
  --no-plugins          disable all plugins
  --no-splash           disable the splash screen
  --quit                quit immediately after loading
  --save-session        always save session data when Leo closes
  --script=PATH         execute a script and then exit
  --script-window       execute script using default gui
  --select=ID           headline or gnx of node to select
  --silent              disable all log messages
  --theme=NAME          use the named theme file
  --trace=LIST          add one or more strings to g.app.debug

        A comma-separated list. Valid values are:
        abbrev, beauty, cache, coloring, drawing, events, focus, git, gnx,
        importers, ipython, keys, layouts, plugins, save, select, sections,
        shutdown, size, speed, startup, themes, undo, verbose, zoom.

  --trace-binding=KEY   trace commands bound to a key
  --trace-setting=NAME  trace where named setting is set
  --window-size=SIZE    initial window size: (height x width)
  --window-spot=SPOT    initial window position: (top x left)
  -v, --version         print version number and exit
""")
</t>
<t tx="ekr.20230615075314.1">def doTraceOptions() -&gt; None:
    """Handle --trace-binding, --trace-setting and --trace"""

    # --trace-binding
    m = utils.find_complex_option(r'--trace-binding=([\w\-\+]+)')
    if m:
        g.app.trace_binding = m.group(1)
        print(f"Enabling --trace-binding={m.group(1)}")

    # --trace-setting=setting
    m = utils.find_complex_option(r'--trace-setting=([\w]+)')
    if m:
        # g.app.config does not exist yet.
        g.app.trace_setting = m.group(1)
        print(f"Enabling --trace-setting={m.group(1)}")

    # --trace=option.
    valid = [
        'abbrev', 'beauty', 'cache', 'coloring', 'drawing', 'events',
        'focus', 'git', 'gnx', 'importers', 'ipython', 'keys',
        'layouts', 'plugins', 'save', 'select', 'sections', 'shutdown',
        'size', 'speed', 'startup', 'themes', 'undo', 'verbose', 'zoom',
    ]
    m = utils.find_complex_option(r'--trace=([\w\,]+)')
    if not m:
        return
    values = m.group(1).split(',')
    error = False
    for value in values:
        if value in valid:
            g.app.debug.append(value)
        else:
            error = True
    if error:
        arg = m.group(0)
        valid_s = '\n   '.join(valid)
        print(f"Valid --trace values are:\n   {valid_s}")
        utils.option_error(arg, 'Invalid value')
    print(f"\nEnabling --trace={', '.join(g.app.debug)}\n")
</t>
<t tx="ekr.20230615084117.1">def find_complex_option(self, regex: str) -&gt; Optional[re.Match]:
    """
    Check arguments that take an argument.

    Exit if the option exists but contains argument.
    """
    assert '=' in regex, repr(regex)
    prefix = regex.split('=')[0]
    for arg in sys.argv:
        if arg.split('=')[0] == prefix:
            m = re.match(regex, arg)
            if m:
                return m
            self.option_error(arg, 'Missing or erroneous value')
    return None
</t>
<t tx="ekr.20230615211005.1"># TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)

# Examples:
#   except* SpamError:
#   except* FooError as e:
#   except* (BarError, BazError) as e:

def do_TryStar(self, node: Node) -&gt; None:

    # Try line...
    self.name('try')
    self.op(':')
    # Body...
    self.level += 1
    self.visit(node.body)
    self.try_stack.append('*')
    self.visit(node.handlers)
    self.try_stack.pop()
    # Else...
    if node.orelse:
        self.name('else')
        self.op(':')
        self.visit(node.orelse)
    # Finally...
    if node.finalbody:
        self.name('finally')
        self.op(':')
        self.visit(node.finalbody)
    self.level -= 1
</t>
<t tx="ekr.20230616015533.1">def test_TryStar(self):

    if py_version &lt; (3, 11):
        self.skipTest('Python 3.11+ only')

    contents = r"""\
try:
    print('a1')
    print('a2')
except* ImportError:
    print('b1')
    print('b2')
except* SyntaxError:
    print('c1')
    print('c2')
else:
    print('d1')
finally:
    print('e1')
    print('e2')
"""
    self.make_data(contents)
</t>
<t tx="ekr.20230616025129.1"></t>
<t tx="ekr.20230616025136.1"></t>
<t tx="ekr.20230616032729.1">https://github.com/leo-editor/leo-editor/pull/3384</t>
<t tx="ekr.20230616034015.1">https://github.com/leo-editor/leo-editor/pull/3385
</t>
<t tx="ekr.20230616073628.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3386
PR: https://github.com/leo-editor/leo-editor/pull/3388

@language python
</t>
<t tx="ekr.20230616075049.1">def option_error(self, arg: str, message: str) -&gt; None:
    """Print an error message and help message, then exit."""
    g.trace(g.callers(6))
    message2 = f"Invalid {arg!r} option: {message}"
    print(message2)
    print(self.usage)
    print(message2)
    sys.exit(1)
</t>
<t tx="ekr.20230616134732.1">class OptionsUtils:
    """
    A stateless class for handling command-line options.

    This class *calculates* valid options from the usage message.
    """

    def __init__(self, usage: str, obsolete_options: list[str] = None) -&gt; None:
        # This class is essentially stateless because these ivars never change.
        self.usage = usage
        self.obsolete_options = obsolete_options
        self.valid_options = self.compute_valid_options()
        self.check_options()

    @others
</t>
<t tx="ekr.20230616170306.1">https://github.com/leo-editor/leo-editor/pull/3389</t>
<t tx="ekr.20230616184953.1">https://github.com/leo-editor/leo-editor/pull/3390</t>
<t tx="ekr.20230617065356.1">def test_LM_scanOptions(self):

    bad_table = (
        '-h', '--help',
        '--gui', '--gui=xxx',
        '--listen-to-log=',
        '--load-type=@auto', '--load-type=@clean',
        '--screen-shot', '--screen-shot=', '--screen-shot-',
        '--screen-shot=xyzzy',
        '--script=xyzzy.py',
        '--trace','--trace-', 'trace=', '--trace=xxx',
        '--trace-binding', '--trace-binding-', '--trace-binding=',
        '--window-', 'window=',
        '--window-size', '--window-size=', '--window-size=100',
        '--window-spot', '--window-spot=', '--window-spot=50',
        '--yyy',
    )
    good_table = (
        '-b', '--black-sentinels',
        '--diff',
        '--fail-fast',
        '--fullscreen',
        '--gui=console', '--gui=curses', '--gui=null', '--gui=qt', '--gui=text',
        '--ipython',
        '--listen-to-log',
        '--load-type=@edit', '--load-type=@file',
        '--maximized', '--minimized',
        '--no-plugins', '--no-splash',
        '--quit',
        '--script-window',
        '--select=whatever',
        '--silent',
        '--theme=whatever',
        '--trace-binding=whatever',
        '--trace-setting=whatever',
        '--trace=coloring',
        '-v', '--version',
        '--window-size=100x200',
        '--window-spot=50x60',
    )
    scan = g.app.loadManager.scanOptions

    # Careful. Restore sys.argv and sys.stdout.
    old_argv = sys.argv
    old_stdout = sys.stdout
    try:
        sys.stdout = open(os.devnull, 'w')
        for option in good_table:
            sys.argv = ['leo', option]
            scan(None, False)
        for option in bad_table:
            with self.assertRaises(SystemExit, msg=option):
                sys.argv = ['leo', option]
                scan(None, False)
    finally:
        sys.argv = old_argv
        sys.stdout = old_stdout
</t>
<t tx="ekr.20230617065929.1">def test_g_OptionsUtils(self):

    if any(z in sys.argv for z in ('--cov', '--cov-report')):
        self.skipTest('Running coverage')

    usage = (
"""
options:
  -h, --help            show this help message and exit
  -b, --black-sentinels write black-compatible sentinel comments
  --diff                use Leo as an external git diff
  --fail-fast           stop unit tests after the first failure
""")

    # Create the class.
    obsolete_options = [
        '--dock', '--global-docks', '--init-docks', '--no-cache',
        '--no-dock', '--session-restore', '--session-save', '--use-docks',
    ]
    x = g.OptionsUtils(usage, obsolete_options)

    # Test x.compute_valid_options.
    expected_valid_options = [
        '--black-sentinels', '--diff', '--fail-fast', '--help',
        '-?', '-b', '-h',
    ]
    self.assertEqual(x.compute_valid_options(), expected_valid_options)

    # Test x.option_error and x.check_options.
    bad_options = (
        '--listen-to-log=',
        '--load-type=@auto', '--load-type=@clean',
        '--screen-shot', '--screen-shot=', '--screen-shot-',
        '--script=xyzzy.py',
        '--trace','--trace-', 'trace=', '--trace=xxx',
        '--trace-binding', '--trace-binding-', '--trace-binding=',
        '--window-', 'window=',
        '--window-size', '--window-size=', '--window-size=100',
        '--window-spot', '--window-spot=', '--window-spot=50',
        '--yyy',
    )
    old_argv = sys.argv
    old_stdout = sys.stdout
    try:
        sys.stdout = open(os.devnull, 'w')
        for option in obsolete_options:
            sys.argv = ['leo', option]
            x.check_options()
        with self.assertRaises(SystemExit):
            x.option_error('--xyzzy', 'Unknown option')
            x.option_error('-x', 'Unknown option')
        for option in bad_options:
            with self.assertRaises(SystemExit, msg=option):
                sys.argv = ['leo', option]
                x.check_options()
    except Exception:
        g.es_exception()
    finally:
        sys.stdout = old_stdout
        sys.argv = old_argv
</t>
<t tx="ekr.20230618022117.1">PR: https://github.com/leo-editor/leo-editor/pull/3393

Later commit:
https://github.com/leo-editor/leo-editor/commit/a0952e829d2200052e037707e4a23ad9c53c39ee</t>
<t tx="ekr.20230618072327.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3396
PR: https://github.com/leo-editor/leo-editor/pull/3397

@language python
</t>
<t tx="ekr.20230618073516.1"></t>
<t tx="ekr.20230618112927.1"></t>
<t tx="ekr.20230618195419.1">PR: https://github.com/leo-editor/leo-editor/pull/3398</t>
<t tx="ekr.20230619075952.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3312
PR: https://github.com/leo-editor/leo-editor/pull/3399

@language python
</t>
<t tx="ekr.20230619123102.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3230
PR: https://github.com/leo-editor/leo-editor/pull/xxx

c.frame.top is a DynamicWindow (a QMainWindow)

QToolBar * barTest = addToolBar(tr("aaaa"));
...
QMainWindow.addToolBarBreak();
QToolBar * barTest2 = addToolBar(tr("bbbb"));


@language python
</t>
<t tx="ekr.20230619123122.1">import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QToolBar, QAction

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        self.setWindowTitle("Multi-Line Icon Bar")

        toolbar = QToolBar()
        self.addToolBar(toolbar)

        actions = [
            ("New", "icons/new.png", "Create a new document"),
            ("Open", "icons/open.png", "Open an existing document"),
            ("Save", "icons/save.png", "Save the current document"),
            ("Cut", "icons/cut.png", "Cut selected text"),
            ("Copy", "icons/copy.png", "Copy selected text"),
            ("Paste", "icons/paste.png", "Paste text from clipboard"),
            
            ("New", "icons/new.png", "Create a new document"),
            ("Open", "icons/open.png", "Open an existing document"),
            ("Save", "icons/save.png", "Save the current document"),
            ("Cut", "icons/cut.png", "Cut selected text"),
            ("Copy", "icons/copy.png", "Copy selected text"),
            ("Paste", "icons/paste.png", "Paste text from clipboard"),
        ]

        for action_text, icon_path, tooltip_text in actions:
            action = QAction(action_text, self)
            action.setIcon(QIcon(icon_path))
            action.setToolTip(tooltip_text)
            toolbar.addAction(action)

        self.setGeometry(300, 300, 400, 300)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())
</t>
<t tx="ekr.20230619124256.1">I found the solution, in the QMainWindow there is a funtion "addToolBarBreak" to add a new row.
but first as you write use multiple toolbars ,as follows


QToolBar * barTest = addToolBar(tr("aaaa"));
...
QMainWindow.addToolBarBreak();
QToolBar * barTest2 = addToolBar(tr("bbbb"));
.....// some other actions in the second row</t>
<t tx="ekr.20230619124346.1">@nosearch

# Word, Head, Body

# found 8 nodes</t>
<t tx="ekr.20230619124410.1"></t>
<t tx="ekr.20230619124457.1"></t>
<t tx="ekr.20230619124519.1"></t>
<t tx="ekr.20230622051358.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3336
PR: https://github.com/leo-editor/leo-editor/pull/3401

@language python
</t>
<t tx="ekr.20230624014959.1"></t>
<t tx="ekr.20230624015529.1">find_gnx_pat = re.compile(r'^(.*)::([-\d]+)?$')

def findGnx(gnx: str, c: Cmdr) -&gt; Optional[Position]:
    """
    gnx: the gnx part of a gnx-based unl.

    The gnx part may be the actual gnx or &lt;actual-gnx&gt;::&lt;line-number&gt;

    Return the first position in c with the actual gnx.
    """
    # Get the actual gnx and line number.
    n: int = 0  # The line number.
    m = find_gnx_pat.match(gnx)
    if m:
        # Get the actual gnx and line number.
        gnx = m.group(1)
        try:
            n = int(m.group(2))
        except(TypeError, ValueError):
            pass
    for p in c.all_unique_positions():
        if p.gnx == gnx:
            if n is None:
                return p
            p2, offset = c.gotoCommands.find_file_line(-n, p)
            return p2 or p
    return None
</t>
<t tx="ekr.20230624100622.1">@language rest
@wrap
@
Clickable links have four forms:

1. Error messages produced by flake8, mypy, pyflakes, pylint, python:

   Some of these tools produce clickable links in the log pane when run
   *within* Leo. Some do not.

   When running these tools *outside of* Leo, copying an error message from
   the *console* to Leo's log pane will create clickable links in the log
   pane. Control-clicking these links will select the proper node and line
   provided the outline contains an `@&lt;file&gt;` node for file mentioned in
   the error message.

2. New in Leo 6.7.4: UNLs based on gnx's (global node indices):

   Links of the form `unl:gnx:` + `//{outline}#{gnx}` open the given
   outline and select the first outline node with the given gnx. These UNLs
   will work as long as the node exists anywhere in the outline.

   For example, the link: `unl:gnx://#ekr.20031218072017.2406` refers to this
   outline's "Code" node. Try it. The link works in this outline.

   *Note*: `{outline}` is optional. It can be an absolute path name or a relative
   path name resolved using `@data unl-path-prefixes`.

3. Leo's headline-based UNLs, as shown in the status pane:

   Headline-based UNLs consist of `unl://` + `//{outline}#{headline_list}`
   where headline_list is list of headlines separated by `--&gt;`.

   This link works: `unl://#Code--&gt;About this file`.

   *Note*: `{outline}` is optional. It can be an absolute path name or a relative
   path name resolved using `@data unl-path-prefixes`.

4. Web URLs: file, ftp, gopher, http, https, mailto, news, nntp, prospero, telnet, wais.

   For example, Leo's forum: https://leo-editor.github.io/leo-editor/
</t>
<t tx="ekr.20230624114517.1"></t>
<t tx="ekr.20230624171452.1">def get_UNL(self) -&gt; str:
    """
    Return a gnx-oriented UNL.

    Breaking change to Leo's API: returned a path-oriented UNL previously.

    @bool full-unl-paths determines the size of the file part.

    LeoTree.set_status_line calls this method if gnx-based unls are in effect.
    """
    p = self
    c = p.v.context
    full = c.config.getBool('full-unl-paths', default=False)
    file_part = c.fileName() if full else os.path.basename(c.fileName())
    return 'unl:gnx:' + f"//{file_part}#{self.gnx}"
</t>
<t tx="ekr.20230625185133.1">old_unl_pat1 = re.compile(r"(.*?)unl\://.*?#(.*)$")  # First test for '#'
old_unl_pat2 = re.compile(r"(.*?)unl\://(.*)$")  # Second, assume no '#'.

@cmd('convert-unls')
def convert_unls(self, event: Event) -&gt; None:  # pragma: no cover
    """
    Convert all legacy (headline-based) unls to gnx-based unls.
    """
    c, undo_type = self.c, 'convert-unls'
    p1 = c.p.copy()
    u = c.undoer
    u.beforeChangeGroup(p1, undo_type)
    n_changed, n_changed_nodes = 0, 0
    for p in c.all_unique_positions():
        changed, node_changed, result = False, False, []
        bunch = u.beforeChangeBody(p)
        for line in g.splitLines(p.b):
            m = self.old_unl_pat1.match(line) or self.old_unl_pat2.match(line)
            if not m:
                result.append(line)
                continue
            prefix = m.group(1)
            unl = m.group(2).replace('%20', ' ')
            p2 = g.findUnl(unl.split('--&gt;'), c)
            if not p2:
                result.append(line)
                continue
            new_unl = f"{'unl'}:gnx:{p2.gnx}\n"
            result.append(f"{prefix}{new_unl}")
            if not node_changed:
                node_changed = True
                n_changed_nodes += 1
                print(f"Node: {p.h}...")  # not p2.h.
            print(f"  old: {unl}")
            print(f"  new: {new_unl.rstrip()}\n")
            changed = True
            n_changed += 1
        if changed:
            c.setBodyString(p, ''.join(result))  # Required.
            u.afterChangeBody(p, undo_type, bunch)
    if n_changed:
        g.es_print(
            f"Changed {n_changed} unl{g.plural(n_changed)} "
            f"in {n_changed_nodes} node{g.plural(n_changed_nodes)}")
        u.afterChangeGroup(p1, undo_type)
    c.contractAllHeadlines()
    c.redraw(p1)
    g.es('convert-gnxs: done')
</t>
<t tx="ekr.20230626064652.1">def findUnl(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUnl: support for legacy UNLs.
    unlList is a list of headlines.

    This method must remain for compatibility with plugins.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define two *optional* unl patterns.

    # old_pat: ':' followed by a list of node indices.
    #          Deprecated and probably does not work.
    #          This pattern will remain for compatibility.
    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')

    # new_pat: '::' followed by a line number.
    #          Negative line numbers denote global line numbers.
    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')

    @others  # Define helper functions

    unlList = convert_unl_list(unlList1)
    if not unlList:
        return None
    # Find all target headlines.
    targets = []
    m = new_pat.match(unlList[-1])
    target = m and m.group(1) or unlList[-1]
    targets.append(target.strip())
    targets.extend(unlList[:-1])
    # Find all target positions. Prefer later positions.
    positions = list(reversed(list(z for z in c.all_positions() if z.h.strip() in targets)))
    while unlList:
        for p in positions:
            p1 = p.copy()
            if full_match(p):
                assert p == p1, (p, p1)
                n = 0  # The default line number.
                # Parse the last target.
                m = new_pat.match(unlList[-1])
                if m:
                    line = m.group(3)
                    try:
                        n = int(line)
                    except(TypeError, ValueError):
                        g.trace('bad line number', line)
                if n &lt; 0:
                    p2, offset = c.gotoCommands.find_file_line(-n, p)  # Calls c.redraw().
                    if not p2:
                        g.trace(f"{p.h}: global line {n} not found")
                return p
        # Not found. Pop the first parent from unlList.
        unlList.pop(0)
    return None

findUNL = findUnl  # Compatibility.
</t>
<t tx="ekr.20230626064652.2">def convert_unl_list(aList: list[str]) -&gt; list[str]:
    """
    Convert old-style UNLs to new UNLs, retaining line numbers if possible.
    """
    result = []
    for s in aList:
        # Try to get the line number.
        for m, line_group in (
            (old_pat.match(s), 4),
            (new_pat.match(s), 3),
        ):
            if m:
                try:
                    n = int(m.group(line_group))
                    result.append(f"{m.group(1)}::{n}")
                    continue
                except Exception:
                    pass
        # Finally, just add the whole UNL.
        result.append(s)
    # Do *not* remove duplicates!
    return result
</t>
<t tx="ekr.20230626064652.3">def full_match(p: Position) -&gt; bool:
    """Return True if the stripped headlines of p and all p's parents match unlList."""
    # Careful: make copies.
    aList: list[str] = unlList[:]
    p1 = p.copy()
    while aList and p1:
        m = new_pat.match(aList[-1])
        if m and m.group(1).strip() != p1.h.strip():
            return False
        if not m and aList[-1].strip() != p1.h.strip():
            return False
        aList.pop()
        p1.moveToParent()
    return not aList
</t>
<t tx="ekr.20230627143007.1">
</t>
<t tx="ekr.20230628072109.1"># unls must contain a (possible empty) file part followed by something else.
valid_unl_pattern = re.compile(r"(unl:gnx|unl|file)://(.*?)#.+")

def isValidUnl(unl_s: str) -&gt; bool:
    """Return true if the given unl is valid."""
    return bool(valid_unl_pattern.match(unl_s))
</t>
<t tx="ekr.20230628072620.1">def findAnyUnl(unl_s: str, c: Cmdr) -&gt; Optional[Position]:
    """
    Find the Position corresponding to an UNL.

    The UNL may be either a legacy (path-based) or new (gnx-based) unl.
    """
    unl = unl_s
    if unl.startswith('unl:gnx:'):
        # Resolve a gnx-based unl.
        unl = unl[8:]
        file_part = g.getUNLFilePart(unl)
        c2 = g.openUNLFile(c, file_part)
        if not c2:
            return None
        tail = unl[3 + len(file_part) :]  # 3: Skip the '//' and '#'
        return g.findGnx(tail, c2)
    # Resolve a file-based unl.
    for prefix in ('unl:', 'file:'):
        if unl.startswith(prefix):
            unl = unl[len(prefix) :]
            break
    else:
        print(f"Bad unl: {unl_s}")
        return None
    file_part = g.getUNLFilePart(unl)
    c2 = g.openUNLFile(c, file_part)
    if not c2:
        return None
    tail = unl[3 + len(file_part) :]  # 3: Skip the '//' and '#'
    unlList = tail.split('--&gt;')
    return g.findUnl(unlList, c2)
</t>
<t tx="ekr.20230628105236.1">@language batch
@echo off
cd %~dp0..\..

echo ruff leo/core
call py -m ruff leo/core

echo ruff leo/commands
call py -m ruff leo/commands

rem qt_main.py is auto generated.
rem call py -m ruff leo/plugins/qt*.py

echo ruff leo/plugins/qt...
call py -m ruff leo/plugins/qt_gui.py
call py -m ruff leo/plugins/qt_text.py
call py -m ruff leo/plugins/qt_tree.py
</t>
<t tx="ekr.20230628173526.1"># All unls must contain a file part: f"//{file-name}#"
# The file-name may be empty.
</t>
<t tx="ekr.20230628173542.1">def get_legacy_UNL(self) -&gt; str:
    """
    Return a headline-oriented UNL, as in legacy versions of p.get_UNL.

    @bool full-unl-paths determines the size of the file part.

    LeoTree.set_status_line will call this method if legacy unls are in effect.
    """
    p = self
    c = p.v.context
    path_part = '--&gt;'.join(list(reversed([z.h for z in self.self_and_parents()])))
    full = c.config.getBool('full-unl-paths', default=False)
    file_part = c.fileName() if full else os.path.basename(c.fileName())
    return 'unl:' + f"//{file_part}#{path_part}"
</t>
<t tx="ekr.20230628173542.2">def get_full_legacy_UNL(self) -&gt; str:
    """
    Return a legacy unl with the full file-name component.

    Not used in Leo's core or official plugins.
    """
    p = self
    c = p.v.context
    path_part = '--&gt;'.join(list(reversed([z.h for z in self.self_and_parents(copy=False)])))
    return 'unl:' + f"//{c.fileName()}#{path_part}"
</t>
<t tx="ekr.20230628174317.1">def get_full_gnx_UNL(self) -&gt; str:
    """
    Return a gnx-oriented UNL with a full path component.

    Not used in Leo's core or official plugins.
    """
    p = self
    c = p.v.context
    file_part = c.fileName()
    return 'unl:gnx:' + f"//{file_part}#{self.gnx}"
</t>
<t tx="ekr.20230628174804.1">def get_short_legacy_UNL(self) -&gt; str:
    """
    Return a legacy unl with a short file-name component.

    Not used in Leo's core or official plugins.
    """
    p = self
    c = p.v.context
    file_part = os.path.basename(c.fileName())
    path_part = '--&gt;'.join(list(reversed([z.h for z in self.self_and_parents(copy=False)])))
    return 'unl:' + f"//{file_part}#{path_part}"
</t>
<t tx="ekr.20230628175148.1">def get_short_gnx_UNL(self) -&gt; str:
    """
    Return a legacy unl without the file-name component.

    Not used in Leo's core or official plugins.
    """
    p = self
    c = p.v.context
    file_part = os.path.basename(c.fileName())
    return 'unl:gnx:' + f"//{file_part}#{self.gnx}"
</t>
<t tx="ekr.20230629185140.1"></t>
<t tx="ekr.20230630132339.1">file_part_pattern = re.compile(r'//(.*?)#.+')

def getUNLFilePart(s: str) -&gt; str:
    """Return the file part of a unl, that is, everything *between* '//' and '#'."""
    # Strip the prefix if it exists.
    for prefix in ('unl:gnx:', 'unl:', 'file:'):
        if s.startswith(prefix):
            s = s[len(prefix) :]
            break
    m = file_part_pattern.match(s)
    return m.group(1) if m else ''
</t>
<t tx="ekr.20230630132340.1">def openUNLFile(c: Cmdr, s: str) -&gt; Cmdr:
    """
    Open the commander for filename s, the file part of an unl.

    Return None if the file can not be found.
    """
    base = os.path.basename
    norm = os.path.normpath
    c_name = c.fileName()

    def standard(path: str) -&gt; str:
        """Standardize the path for easy comparison."""
        return norm(path).lower()

    if not s.strip():
        return None
    if s.startswith('//') and s.endswith('#'):
        s = s[2:-1]
    if not s.strip():
        return None
    # Always match within the present file.
    if os.path.isabs(s) and standard(s) == standard(c_name):
        return c
    if not os.path.isabs(s) and standard(s) == standard(base(c_name)):
        return c
    if os.path.isabs(s):
        path = standard(s)
    else:
        # Values of d should be directories.
        d = g.parsePathData(c)
        base_s = base(s)
        directory = d.get(base_s)
        if not directory:
            return None
        if not os.path.exists(directory):
            return None
        path = standard(os.path.join(directory, base_s))
    if path == standard(c_name):
        return c
    # Search all open commanders.
    # This is a good shortcut, and it helps unit tests.
    for c2 in g.app.commanders():
        if path == standard(c2.fileName()):
            return c2
    # Open the file if possible.
    if not os.path.exists(path):
        return None
    return g.openWithFileName(path)
</t>
<t tx="ekr.20230630132341.1">path_data_pattern = re.compile(r'(.+?):\s*(.+)')

def parsePathData(c: Cmdr) -&gt; dict[str, str]:
    """
    Return a dict giving path prefixes for the files given in @data
    unl-path-prefixes.
    """
    lines = c.config.getData('unl-path-prefixes')
    d: dict[str, str] = {}
    for line in lines:
        m = path_data_pattern.match(line)
        if m:
            key, path = m.group(1), m.group(2)
            if key in d:
                g.trace(f"Ignoring duplicate key: {line!r}")  # pragma: no cover
            else:
                d[key] = os.path.normpath(path)
        else:
            g.trace(f"Ignoring line: {line!r}")  # pragma: no cover
    return d
</t>
<t tx="ekr.20230701044111.1"># g.handleUnl just calls findAnyUnl before selecting a position.

# g.handleUrl should *never*be tested.</t>
<t tx="ekr.20230701060241.1"># All these paths appear in @file or @clean nodes in LeoPyRef.leo.

# kind: @clean, @edit, @file,
# path: path to an existing file, relative to LeoPyRef.leo (in leo/core).
files_data = (
    # The hard case: __init__.py
    ('@file', '../plugins/importers/__init__.py'),
    ('@file',  '../plugins/writers/__init__.py'),
    ('@clean', '../plugins/leo_babel/__init__.py'),
    ('@file',  '../plugins/editpane/__init__.py'),
    # Other files.
    ('@file', 'leoApp.py'),
    ('@file', '../commands/abbrevCommands.py'),
    ('@edit', '../../launchLeo.py'),
    ('@file', '../external/log_listener.py'),
    ('@file', '../plugins/cursesGui2.py'),
)
</t>
<t tx="ekr.20230701060854.1"># m.group(1) is the filename and m.group(2) is the line number.
error_patterns = {
    'flake8': g.flake8_pat,     # r'(.+?):([0-9]+):[0-9]+:.*$'
    'mypy':  g.mypy_pat,        # r'^(.+?):([0-9]+):\s*(error|note)\s*(.*)\s*$'
    'pyflakes': g.pyflakes_pat, # r'^(.*):([0-9]+):[0-9]+ .*?$'
    'pylint': g.pylint_pat,     # r'^(.*):\s*([0-9]+)[,:]\s*[0-9]+:.*?\(.*\)\s*$'
    'python': g.python_pat,     # r'^\s*File\s+"(.*?)",\s*line\s*([0-9]+)\s*$'
}
</t>
<t tx="ekr.20230701061343.1"></t>
<t tx="ekr.20230701061355.1">def _test_per_commander_data(self):
    """Test the test data."""
    c = self.c

    # All dicts must have the same keys.
    for d in (self.error_messages, self.error_patterns, self.error_templates):
        self.assertEqual(self.tools, list(sorted(d.keys())))

    # Pretest: all absolute paths must exist.
    for z in self.absolute_paths:
        self.assertTrue(os.path.exists(z), msg=repr(z))

    # Pretest: all generated error messages must match the tool's pattern.
    for tool in self.tools:
        pattern = self.error_patterns[tool]
        messages = self.error_messages[tool]
        for message in messages:
            self.assertTrue(pattern.match(message), msg=(
                'Error message does not match error pattern:\n'
                f"    tool: {tool!r}\n"
                f" message: {message!r}\n"
                f" pattern: {pattern!r}"))

    # More tests...
    for data in self.files_data:  # &lt;@file&gt; &lt;filename&gt;
        kind, relative_path = data
        headline = msg = f"{kind} {relative_path}"
        absolute_path = g.os_path_finalize_join(g.app.loadDir, relative_path)
        self.assertTrue(absolute_path in self.absolute_paths, msg=msg)
        self.assertTrue(os.path.exists(absolute_path), msg=msg)
        self._make_tree(c, headline)
        test_p = g.findNodeAnywhere(c, headline)
        full_path = c.fullPath(test_p)
        self.assertEqual(full_path, absolute_path, msg=msg)
        self.assertTrue(test_p, msg=msg)
</t>
<t tx="ekr.20230701065318.1">def _define_per_commander_data(self):
    """Define data that depends on c."""
    c = self.c

    # List of absolute paths in the test data.
    self.assertTrue(c.fileName)
    self.absolute_paths = [
        g.os_path_finalize_join(os.path.dirname(c.fileName()), relative_path)
            for _, relative_path in self.files_data
    ]

    # The error line for each absolute path. Default all lines to 0.
    self.error_lines = {}
    for z in self.absolute_paths:
        self.error_lines[z] = 0

    # Error messages for every tool and every absolute path.
    self.error_messages = {}
    for tool in self.tools:
        self.error_messages [tool] = []
        for path in self.absolute_paths:
            template = self.error_templates[tool]
            self.error_messages[tool].append(
                template.replace('FILE', path)
                .replace('LINE', '1')
                .replace('COL', f"{self.error_lines[path]!s}")
                .replace('ERR', f"{tool} error")
            )
</t>
<t tx="ekr.20230701070151.1"></t>
<t tx="ekr.20230701071240.1"># Error message templates.
error_templates = {
    'flake8':   'FILE:LINE:COL:ERR',
    'mypy':     'FILE:LINE:error ERR',
    'pyflakes': 'FILE:LINE:COL ERR',
    'pylint':   'FILE:LINE:COL: (ERR)',
    'python':   'File "FILE", line LINE',
}
</t>
<t tx="ekr.20230701083715.1">absolute_paths: list[str]
error_lines: dict[str, int]
error_messages: dict[str, list[str]]
error_patterns: dict[str, re.Pattern]
error_templates: dict[str, str]
files_data: tuple[str, str]
invalid_unls: tuple[str]
tools = ['flake8', 'mypy', 'pyflakes', 'pylint', 'python']
valid_unls: tuple[str]
</t>
<t tx="ekr.20230701083918.1">&lt;&lt; define files data &gt;&gt;
&lt;&lt; define error_patterns &gt;&gt;
&lt;&lt; define error_templates &gt;&gt;
&lt;&lt; define invalid_unls &gt;&gt;
&lt;&lt; define missing_unls &gt;&gt;
&lt;&lt; define valid_unl_templates &gt;&gt;
</t>
<t tx="ekr.20230701084035.1">def test_per_commander_data(self):

    # Test the data only here.
    self._define_per_commander_data()
    self._test_per_commander_data()
</t>
<t tx="ekr.20230701084458.1"># Syntactically invalid unls.
invalid_unls = (
    'unl:gnx:xyzzy#.20230622112649.1',  # Missing '//'
    'unl:gnx://xyzzy.20230622112649.1', # Missing '#'
    'unl:gnx//xyzzy#.20230622112649.1', # Missing ':'
    'unl//xyzzy#.20230622112649.1', # Missing ':'

)

</t>
<t tx="ekr.20230701085717.1"></t>
<t tx="ekr.20230701085746.1">def test_g_isValidUnl(self):

    for unl in self.valid_unls + self.missing_unls:
        self.assertTrue(g.isValidUnl(unl), msg=unl)
    for unl in self.invalid_unls:
        self.assertFalse(g.isValidUnl(unl), msg=unl)
</t>
<t tx="ekr.20230701090956.1"># Define unls with files parts that refer to non-existent files.
# These should be syntactically valid.
missing_unls = (
    'unl:gnx://xyzzy#.20230622112649.1',
    'unl://xyzzy#does--&gt;not--&gt;exist',
)
</t>
<t tx="ekr.20230701090956.2"># These links are functional only if on @data unl-path-prefixes contains the proper file part.
valid_unls = (

    'unl:gnx://#ekr.20180311131424.1',

    # test.leo:Error mssages (copy to log)
    'unl:gnx://#ekr.20230622112649.1',

    # test.leo:Recent
    'unl:gnx://test.leo#ekr.20180311131424.1',
    'unl:gnx://#ekr.20180311131424.1',

    # test.leo: Error mssages (copy to log)
    'unl:gnx://test.leo#ekr.20230622112649.1',
    'unl:gnx://#ekr.20230622112649.1',

    # In LeoDocs.leo: Leo 6.7.3 release notes
    'unl:gnx://LeoDocs.leo#ekr.20230409052507.1',

    # In LeoDocs.leo: ** Read me first **
    'unl:gnx://LeoDocs.leo#ekr.20050831195449',

    # Legacy unls in test.leo.
    'unl://#Coloring tests--&gt;Syntax coloring template',
    'unl://#@file ../plugins/importers/__init__.py',
    'unl://C:/Repos/leo-editor/leo/test/test.leo#@clean ../plugins/leo_babel/__init__.py',
    'unl://#@clean ../plugins/leo_babel/__init__.py',
    'unl://C:/Repos/leo-editor/leo/test/test.leo#Viewrendered examples',
    'unl://#Viewrendered examples',
    'unl://C:/Repos/leo-editor/leo/test/test.leo#Viewrendered examples--&gt;Python code',
    'unl://#Viewrendered examples--&gt;Python code',

    # Absolute file: valid, but can't be resolved in a unit test.
    'unl://C:/Repos/leo-editor/leo/test/test.leo#@file ../plugins/importers/__init__.py',

)
</t>
<t tx="ekr.20230701095636.1">def test_g_findAnyUnl(self):

    # g.findAnyUnl returns a Position or None.

    ### To do: resolve all valid unls to a real position.

    c = self.c
    self._make_tree(c, root_h='root')

    if 0:  ### Not yet.
        for unl in self.valid_unls + self.missing_unls:
            p = c.rootPosition()
            self.assertEqual(p, g.findAnyUnl(unl, c), msg=unl)

    # Suppress warnings.
    old_stdout = sys.stdout
    try:
        sys.stdout = open(os.devnull, 'w')
        for unl in self.invalid_unls:
            self.assertEqual(None, g.findAnyUnl(unl, c), msg=unl)
    finally:
        sys.stdout = old_stdout
</t>
<t tx="ekr.20230701101300.1">def test_g_isValidUrl(self):

    bad_table = ('@whatever',)
    good_table = (
        'http://leo-editor.github.io/leo-editor/preface.html',
        'https://github.com/leo-editor/leo-editor/issues?q=is%3Aissue+milestone%3A6.6.3+',
    )
    for unl in self.valid_unls + self.missing_unls + good_table:
        self.assertTrue(g.isValidUrl(unl), msg=unl)
    for unl in self.invalid_unls + bad_table:
        self.assertFalse(g.isValidUrl(unl), msg=unl)
</t>
<t tx="ekr.20230701102932.1"></t>
<t tx="ekr.20230701102939.1"></t>
<t tx="ekr.20230701103509.1">def test_g_parsePathData(self) -&gt; None:

    c = self.c

    # Set @data unl-path-prefixes

    s = textwrap.dedent("""
        # lines have the form:
        # x.leo: &lt;absolute path to x.leo&gt;

        test.leo:    c:/Repos/leo-editor/leo/test
        LeoDocs.leo: c:/Repos/leo-editor/leo/doc
    """)
    lines = g.splitLines(s)
    self._set_setting(c, kind='data', name='unl-path-prefixes', val=lines)
    lines2 = c.config.getData('unl-path-prefixes')
    expected_lines = [
        'test.leo:    c:/Repos/leo-editor/leo/test',
        'LeoDocs.leo: c:/Repos/leo-editor/leo/doc',
    ]
    self.assertEqual(lines2, expected_lines)
    d = g.parsePathData(c)
    paths = ['c:/Repos/leo-editor/leo/test', 'c:/Repos/leo-editor/leo/doc']
    expected_paths = [os.path.normpath(z) for z in paths]
    self.assertEqual(list(sorted(d.values())), list(sorted(expected_paths)))
</t>
<t tx="ekr.20230701113123.1">def test_p_get_star_UNL(self):

    # Test 11 p.get_*_UNL methods.
    c = self.c
    self._make_tree(c)
    root = c.rootPosition().next()
    p = root.firstChild()

    # Calculate the various kinds of results.
    gnx = p.gnx
    path = '--&gt;'.join([root.h, p.h])
    long_fn = c.fileName()
    short_fn = os.path.basename(c.fileName())

    empty_gnx = 'unl:' + f"gnx://#{gnx}"
    empty_path = 'unl:' + f"gnx://#{path}"
    full_gnx = 'unl:' + f"gnx://{long_fn}#{gnx}"
    full_legacy = 'unl:' + f"//{long_fn}#{path}"
    short_gnx = 'unl:' + f"gnx://{short_fn}#{gnx}"
    short_legacy = 'unl:' + f"//{short_fn}#{path}"
    all_unls = (empty_gnx, empty_path, full_gnx, full_legacy, short_gnx, short_legacy)

    # Pre-test.
    for unl in all_unls:
        self.assertTrue(g.isValidUnl(unl), msg=unl)

    def set_config(kind, full):
        """Set c.config settings from the args."""
        getBool, getString = c.config.getBool, c.config.getString
        c.config.set(p=None, kind='string', name='unl-status-kind', val=kind)
        c.config.set(p=None, kind='bool', name='full-unl-paths', val=full)
        self.assertEqual(full, getBool('full-unl-paths'), msg=full)
        self.assertEqual(kind, getString('unl-status-kind'), msg=kind)

    # Test g.get_UNL and g.get_legacy_UNL.
    expected_get_UNL = {
        'legacy:0': short_gnx,
        'legacy:1': full_gnx,
        'gnx:0': short_gnx,
        'gnx:1': full_gnx,
    }
    expected_get_legacy_UNL = {
        'legacy:0': short_legacy,
        'legacy:1': full_legacy,
        'gnx:0': short_legacy,
        'gnx:1': full_legacy,
    }
    for kind in ('legacy', 'gnx'):
        for full in (True, False):
            set_config(kind, full)
            for d, f in (
                (expected_get_UNL, p.get_UNL),
                (expected_get_legacy_UNL, p.get_legacy_UNL),
            ):
                expected = d[f"{kind}:{str(int(full))}"]
                self.assertEqual(expected, f(), msg=f"{f.__name__}: kind: {kind} full: {full}")

    # Test all other p.get_*_UNL methods.
    # Their returned values should not depend on settings, but change the settings to make sure.
    for kind in ('legacy', 'gnx'):
        for full in (True, False):
            set_config(kind, full)
            for expected, f in (
                # Test g.get_full/short_gnx_UNL.
                (full_gnx, p.get_full_gnx_UNL),
                (short_gnx, p.get_short_gnx_UNL),
                # Test g.get_full/short_legacy_UNL.
                (full_legacy, p.get_full_legacy_UNL),
                (short_legacy, p.get_short_legacy_UNL),
            ):
                msg = f"{f.__name__}: kind: {kind} full: {full}"
                self.assertEqual(expected, f(), msg=msg)
</t>
<t tx="ekr.20230701171707.1">def test_g_getUNLFilePart(self):

    table = (
        ('unl:' + 'gnx://a.leo#whatever', 'a.leo'),
        ('unl:' + '//b.leo#whatever', 'b.leo'),
        ('file:' + '//c.leo#whatever', 'c.leo'),
        ('//d.leo#whatever', 'd.leo'),
    )
    for unl, expected in table:
        self.assertEqual(expected, g.getUNLFilePart(unl), msg=unl)
</t>
<t tx="ekr.20230702040714.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3413
PR: https://github.com/leo-editor/leo-editor/pull/3418

@language python
</t>
<t tx="ekr.20230702120645.1"></t>
<t tx="ekr.20230702154511.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3416
PR: https://github.com/leo-editor/leo-editor/pull/3433.

@language python
</t>
<t tx="ekr.20230702154838.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3409
PR: https://github.com/leo-editor/leo-editor/pull/3422

@language python
</t>
<t tx="ekr.20230702160250.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3442

@language python
</t>
<t tx="ekr.20230702165040.1">def _patch_at_data_unl_path_prefixes(self):
    """
    Create a new outline, linked into g.app.windowList.

    Patch @data unl-path-prefixes so that g.findAnyUnl will find nodes in
    the new commander.

    Return the commander for the new outline.
    """
    from leo.core.leoCommands import Commands
    c = c1 = self.c

    # Create the new commander, linked into g.app.windowList.
    c2 = Commands(fileName=None, gui=g.app.gui)
    self.assertTrue(c2.frame)
    g.app.windowList.append(c1.frame)
    g.app.windowList.append(c2.frame)

    # Give both commanders new (non-existent) names.
    c1_name = 'test_outline1.leo'
    c2_name = 'test_outline2.leo'
    directory = os.path.dirname(c.fileName())
    c.mFileName = os.path.normpath(os.path.join(directory, c1_name))
    c2.mFileName = os.path.normpath(os.path.join(directory, c2_name))
    self.assertEqual(c1_name, os.path.basename(c.fileName()))
    self.assertEqual(c2_name, os.path.basename(c2.fileName()))

    def make_line(c):
        file_name = c.fileName()
        key = os.path.basename(file_name)
        # Values must be directories.
        value = os.path.normpath(os.path.dirname(file_name))
        # print(f"{key:17} {value}")
        return f"{key}: {value}"

    # Init the @data unl-path-prefixes.
    lines = [make_line(z) for z in (c, c2)]
    self._set_setting(c, kind='data', name='unl-path-prefixes', val=lines)
    lines2 = c.config.getData('unl-path-prefixes')
    self.assertEqual(list(sorted(lines)), list(sorted(lines2)))
    d = g.parsePathData(c)
    if 0:
        print('')
        g.printObj(d)
    return c2
</t>
<t tx="ekr.20230702165813.1">def test_patch_at_data_unl_path_prefixes(self):
    # Test the helper, _patch_at_data_unl_path_prefixes.
    c1 = self.c
    c2 = self._patch_at_data_unl_path_prefixes()
    self.assertTrue(c2)
    self.assertTrue(c1.fileName())
    self.assertTrue(c2.fileName())
    self.assertFalse(c1 == c2)
    self.assertTrue(c1 in g.app.commanders())
    self.assertTrue(c2 in g.app.commanders())
    self.assertTrue(c1.frame in g.app.windowList)
    self.assertTrue(c2.frame in g.app.windowList)
</t>
<t tx="ekr.20230703041152.1">@nosearch

# Word, Head, Body

# found 6 nodes</t>
<t tx="ekr.20230703055934.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3420
PR: https://github.com/leo-editor/leo-editor/pull/3421

The fix was to change a setting.

@language python
</t>
<t tx="ekr.20230703100758.1">def saveSession(self) -&gt; None:
    """Save session data depending on command-line arguments."""
    if self.sessionManager and (
        self.loaded_session or self.always_write_session_data
    ):
        self.sessionManager.save_snapshot()
</t>
<t tx="ekr.20230703103458.1">def _set_setting(self, c: Cmdr, kind: str, name: str, val: Any) -&gt; None:
    """
    Call c.config.set with the given args, suppressing stdout.
    """
    try:
        old_stdout = sys.stdout
        sys.stdout = open(os.devnull, 'w')
        c.config.set(p=None, kind=kind, name=name, val=val)
    finally:
        sys.stdout = old_stdout
</t>
<t tx="ekr.20230703103514.1">def test_set_setting(self) -&gt; None:
    # Not run by default. To run:
    # python -m unittest leo.core.leoTest2.LeoUnitTest.verbose_test_set_setting
    c = self.c
    val: Any
    for val in (True, False):
        name = 'test-bool-setting'
        self._set_setting(c, kind='bool', name=name, val=val)
        self.assertTrue(c.config.getBool(name) == val)
    val = 'aString'
    self._set_setting(c, kind='string', name=name, val=val)
    self.assertTrue(c.config.getString(name) == val)
</t>
<t tx="ekr.20230703142942.1"></t>
<t tx="ekr.20230703175447.1">def test_g_openUNLFile(self):

    # Create a new commander
    c1 = self.c
    c2 = self._patch_at_data_unl_path_prefixes()
    # Change both filenames.
    file_name1 = os.path.basename(c1.fileName())
    file_name2 = os.path.basename(c2.fileName())
    # Cross-file tests.
    c3 = g.openUNLFile(c1, file_name2)
    self.assertEqual(c3, c2)
    c4 = g.openUNLFile(c2, file_name1)
    self.assertEqual(c4, c1)
</t>
<t tx="ekr.20230703175743.1">def test_g_findUnl(self):

    c = self.c

    # Create the test tree.
    self._make_tree(c, 'Root')
    # Test all positions.
    for p in c.all_positions():
        # Plain headlines.
        headlines = list(reversed([z.h for z in p.self_and_parents()]))
        self.assertEqual(p, g.findUnl(headlines, c), msg=','.join(headlines))
        # Headlines with new-style line numbers:
        aList1 = [f"{z}::0" for z in headlines]
        self.assertEqual(p, g.findUnl(aList1, c), msg=','.join(aList1))
        # Headlines with old-style child offsets.
        if 0:  # I don't understand the old-style format!
            aList2 = [f"{z}:0" for z in headlines]
            self.assertEqual(p, g.findUnl(aList2, c), msg=','.join(aList2))
</t>
<t tx="ekr.20230703181745.1">    c1 = self.c
    c2 = self._patch_at_data_unl_path_prefixes()

    self._make_tree(c1, 'Root1')
    self._make_tree(c2, 'Root2')
    self._dump_headlines(c1)
    self._dump_headlines(c2)
</t>
<t tx="ekr.20230704030847.1">def pad(s: str, width: int) -&gt; str:
    """Return a string of blanks to pad string s to the given width."""
    return ' ' * max(0, width - len(s))
</t>
<t tx="ekr.20230704035519.1"></t>
<t tx="ekr.20230704070426.10">def convert_unl_list(aList: list[str]) -&gt; list[str]:
    """
    Convert old-style UNLs to new UNLs, retaining line numbers if possible.
    """
    result = []
    for s in aList:
        # Try to get the line number.
        for m, line_group in (
            (old_pat.match(s), 4),
            (new_pat.match(s), 3),
        ):
            if m:
                try:
                    n = int(m.group(line_group))
                    result.append(f"{m.group(1)}::{n}")
                    continue
                except Exception:
                    pass
        # Finally, just add the whole UNL.
        result.append(s)
    # Do *not* remove duplicates!
    return result
</t>
<t tx="ekr.20230704070426.11">def full_match(p: Position) -&gt; bool:
    """Return True if the stripped headlines of p and all p's parents match unlList."""
    # Careful: make copies.
    aList, p1 = unlList[:], p.copy()
    while aList and p1:
        m = new_pat.match(aList[-1])
        if m and m.group(1).strip() != p1.h.strip():
            return False
        if not m and aList[-1].strip() != p1.h.strip():
            return False
        aList.pop()
        p1.moveToParent()
    return not aList
</t>
<t tx="ekr.20230704070426.12"></t>
<t tx="ekr.20230704070426.19">@ignore
@nosearch
@language patch
--- uncommitted
+++ uncommitted
@@ -1,6 +1,14 @@
 def objToString(obj: Any, *, indent: int = 0, tag: str = None, width: int = 120) -&gt; str:
     """Pretty print any Python object to a string."""
-    if isinstance(obj, (list, tuple)):
+    if isinstance(obj, dict):
+        result_list = ['{\n']
+        pad = max([len(key) for key in obj])
+        for key in sorted(obj):
+            pad_s = ' ' * max(0, pad - len(key))
+            result_list.append(f"  {pad_s}{key}: {obj.get(key)}\n")
+        result_list.append('}')
+        result = ''.join(result_list)
+    elif isinstance(obj, (list, tuple)):
         # Return the enumerated lines of the list.
         result_list = ['[\n' if isinstance(obj, list) else '(\n']
         for i, z in enumerate(obj):
@language python
</t>
<t tx="ekr.20230704070426.2">@ignore
@nosearch
@language patch
--- devel
+++ ekr-3181-mypy-links
@@ -142,8 +142,8 @@
     'VimCommands':              ['c', 'vimCommands'],
 }
 #@-&lt;&lt; define global decorator dicts &gt;&gt;
-#@+&lt;&lt; define global error regexs &gt;&gt;
-#@+node:ekr.20220412193109.1: ** &lt;&lt; define global error regexs &gt;&gt; (leoGlobals.py)
+#@+&lt;&lt; define global error regexes &gt;&gt;
+#@+node:ekr.20220412193109.1: ** &lt;&lt; define global error regexes &gt;&gt; (leoGlobals.py)
 # Most code need only know about the *existence* of these patterns.
 
 # For all *present* patterns, m.group(1) is the filename and m.group(2) is the line number.
@@ -155,7 +155,7 @@
 pyflakes_pat = re.compile(r'^(.*):([0-9]+):[0-9]+ .*?$')
 pylint_pat = re.compile(r'^(.*):\s*([0-9]+)[,:]\s*[0-9]+:.*?\(.*\)\s*$')
 python_pat = re.compile(r'^\s*File\s+"(.*?)",\s*line\s*([0-9]+)\s*$')
-#@-&lt;&lt; define global error regexs &gt;&gt;
+#@-&lt;&lt; define global error regexes &gt;&gt;
 #@+&lt;&lt; define g.decorators &gt;&gt;
 #@+node:ekr.20150508165324.1: ** &lt;&lt; define g.Decorators &gt;&gt;
 #@+others
@@ -315,8 +315,8 @@
     return _decorator
 #@-others
 #@-&lt;&lt; define g.decorators &gt;&gt;
-#@+&lt;&lt; define regex's &gt;&gt;
-#@+node:ekr.20200810093517.1: ** &lt;&lt; define regex's &gt;&gt;
+#@+&lt;&lt; define regexes &gt;&gt;
+#@+node:ekr.20200810093517.1: ** &lt;&lt; define regexes &gt;&gt; (leoGlobals.py)
 # Regex used by this module, and in leoColorizer.py.
 g_language_pat = re.compile(r'^@language\s+(\w+)+', re.MULTILINE)
 
@@ -342,7 +342,7 @@
 url_leadins = 'fghmnptw'
 url_kinds = '(file|ftp|gopher|http|https|mailto|news|nntp|prospero|telnet|wais)'
 url_regex = re.compile(fr"""\b{url_kinds}://[^\s'"]+""")
-#@-&lt;&lt; define regex's &gt;&gt;
+#@-&lt;&lt; define regexes &gt;&gt;
 tree_popup_handlers: list[Callable] = []  # Set later.
 user_dict: dict[Any, Any] = {}  # Non-persistent dictionary for scripts and plugins.
 app: Any = None  # The singleton app object. Set by runLeo.py.
@@ -2784,7 +2784,15 @@
 #@+node:ekr.20050819064157: *4* g.objToString &amp; aliases
 def objToString(obj: Any, *, indent: int = 0, tag: str = None, width: int = 120) -&gt; str:
     """Pretty print any Python object to a string."""
-    if isinstance(obj, (list, tuple)):
+    if isinstance(obj, dict):
+        result_list = ['{\n']
+        pad = max([len(key) for key in obj])
+        for key in sorted(obj):
+            pad_s = ' ' * max(0, pad - len(key))
+            result_list.append(f"  {pad_s}{key}: {obj.get(key)}\n")
+        result_list.append('}')
+        result = ''.join(result_list)
+    elif isinstance(obj, (list, tuple)):
         # Return the enumerated lines of the list.
         result_list = ['[\n' if isinstance(obj, list) else '(\n']
         for i, z in enumerate(obj):
@@ -5284,10 +5292,6 @@
     g.trace(f"bad string index: {index}")
     return 0
 #@+node:ekr.20140526144610.17601: *3* g.Strings
-#@+node:ekr.20190503145501.1: *4* g.isascii
-def isascii(s: str) -&gt; bool:
-    # s.isascii() is defined in Python 3.7.
-    return all(ord(ch) &lt; 128 for ch in s)
 #@+node:ekr.20031218072017.3106: *4* g.angleBrackets &amp; virtual_event_name
 def angleBrackets(s: str) -&gt; str:
     """Returns &lt; &lt; s &gt; &gt;"""
@@ -5304,6 +5308,10 @@
 def ensureTrailingNewlines(s: str, n: int) -&gt; str:
     s = g.removeTrailing(s, '\t\n\r ')
     return s + '\n' * n
+#@+node:ekr.20190503145501.1: *4* g.isascii
+def isascii(s: str) -&gt; bool:
+    # s.isascii() is defined in Python 3.7.
+    return all(ord(ch) &lt; 128 for ch in s)
 #@+node:ekr.20050920084036.4: *4* g.longestCommonPrefix &amp; g.itemsMatchingPrefixInList
 def longestCommonPrefix(s1: str, s2: str) -&gt; str:
     """Find the longest prefix common to strings s1 and s2."""
@@ -5332,6 +5340,10 @@
     else:
         common_prefix = ''
     return pmatches, common_prefix
+#@+node:ekr.20230704030847.1: *4* g.pad
+def pad(s: str, width: int) -&gt; str:
+    """Return a string of blanks to pad string s to the given width."""
+    return ' ' * max(0, width - len(s))
 #@+node:ekr.20090516135452.5776: *4* g.removeLeading/Trailing
 # Warning: g.removeTrailingWs already exists.
 # Do not change it!
@@ -7166,6 +7178,50 @@
     command = f"{sys.executable} -m unittest {verbosity} {tests or ''} "
     g.execute_shell_commands(command)
 #@+node:ekr.20120311151914.9916: ** g.Urls &amp; UNLs
+#@+&lt;&lt; About clickable links &gt;&gt;
+#@+node:ekr.20230624100622.1: *3* &lt;&lt; About clickable links &gt;&gt;
+#@@language rest
+#@@wrap
+#@+at
+# Clickable links have four forms:
+#
+# 1. Error messages produced by flake8, mypy, pyflakes, pylint, python:
+#
+#    Some of these tools produce clickable links in the log pane when run
+#    *within* Leo. Some do not.
+#
+#    When running these tools *outside of* Leo, copying an error message from
+#    the *console* to Leo's log pane will create clickable links in the log
+#    pane. Control-clicking these links will select the proper node and line
+#    provided the outline contains an `@&lt;file&gt;` node for file mentioned in
+#    the error message.
+#
+# 2. New in Leo 6.7.4: UNLs based on gnx's (global node indices):
+#
+#    Links of the form `unl:gnx:` + `//{outline}#{gnx}` open the given
+#    outline and select the first outline node with the given gnx. These UNLs
+#    will work as long as the node exists anywhere in the outline.
+#
+#    For example, the link: `unl:gnx://#ekr.20031218072017.2406` refers to this
+#    outline's "Code" node. Try it. The link works in this outline.
+#
+#    *Note*: `{outline}` is optional. It can be an absolute path name or a relative
+#    path name resolved using `@data unl-path-prefixes`.
+#
+# 3. Leo's headline-based UNLs, as shown in the status pane:
+#
+#    Headline-based UNLs consist of `unl://` + `//{outline}#{headline_list}`
+#    where headline_list is list of headlines separated by `--&gt;`.
+#
+#    This link works: `unl://#Code--&gt;About this file`.
+#
+#    *Note*: `{outline}` is optional. It can be an absolute path name or a relative
+#    path name resolved using `@data unl-path-prefixes`.
+#
+# 4. Web URLs: file, ftp, gopher, http, https, mailto, news, nntp, prospero, telnet, wais.
+#
+#    For example, Leo's forum: https://leo-editor.github.io/leo-editor/
+#@-&lt;&lt; About clickable links &gt;&gt;
 #@+node:ekr.20120320053907.9776: *3* g.computeFileUrl
 def computeFileUrl(fn: str, c: Cmdr = None, p: Position = None) -&gt; str:
     """
@@ -7197,19 +7253,69 @@
             path = g.finalize(path)
         url = f"{tag}{path}"
     return url
-#@+node:ekr.20190608090856.1: *3* g.es_clickable_link
-def es_clickable_link(c: Cmdr, p: Position, line_number: int, message: str) -&gt; None:
+#@+node:ekr.20190608090856.1: *3* g.es_clickable_link (not used)
+def es_clickable_link(c: Cmdr, p: Position, line_number: int, message: str) -&gt; None:  # pragma: no cover
     """
     Write a clickable message to the given line number of p.b.
 
     Negative line numbers indicate global lines.
 
     """
+    # Not used in Leo's core.
     unl = p.get_UNL()
     c.frame.log.put(message.strip() + '\n', nodeLink=f"{unl}::{line_number}")
-#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helpers
-def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
-    """
+#@+node:ekr.20230628072620.1: *3* g.findAnyUnl
+def findAnyUnl(unl_s: str, c: Cmdr) -&gt; Optional[Position]:
+    """Find a either a legacy (path-based) or new (gnx-based) unl."""
+    unl = unl_s
+    if unl.startswith('unl:gnx:'):
+        # Resolve a gnx-based unl.
+        unl = unl[8:]
+        file_part = g.getUNLFilePart(unl)
+        c2 = g.openUNLFile(c, file_part)
+        tail = unl[3 + len(file_part) :]  # 3: Skip the '//' and '#'
+        return g.findGnx(tail, c2)
+    # Resolve a file-based unl.
+    for prefix in ('unl:', 'file:'):
+        if unl.startswith(prefix):
+            unl = unl[len(prefix) :]
+            break
+    else:
+        print(f"Bad unl: {unl_s}")
+        return None
+    file_part = g.getUNLFilePart(unl)
+    c2 = g.openUNLFile(c, file_part)
+    tail = unl[3 + len(file_part) :]  # 3: Skip the '//' and '#'
+    unlList = tail.split('--&gt;')
+    return g.findUnl(unlList, c2)
+#@+node:ekr.20230624015529.1: *3* g.findGnx (new unls)
+file_pat = re.compile(r'^(.*)::([-\d]+)?$')  # '::' is the separator.
+
+def findGnx(gnx: str, c: Cmdr) -&gt; Optional[Position]:
+    """Return the position with the given gnx in c."""
+    n: int = 0  # The line number.
+    m = file_pat.match(gnx)
+    if m:
+        gnx = m.group(1)
+        try:
+            n = int(m.group(2))
+        except(TypeError, ValueError):
+            pass
+    for p in c.all_unique_positions():
+        if p.gnx == gnx:
+            if n is None:
+                return p
+            p2, offset = c.gotoCommands.find_file_line(-n, p)
+            return p2 or p
+    return None
+#@+node:ekr.20230626064652.1: *3* g.findUnl &amp; helpers (legacy unls)
+def findUnl(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
+    """
+    g.findUnl: support for legacy UNLs.
+    unlList is a list of headlines.
+
+    This method must remain for compatibility with plugins.
+
     Find and move to the unl given by the unlList in the commander c.
     Return the found position, or None.
     """
@@ -7218,7 +7324,7 @@
     new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')  # '::' is the separator.
 
     #@+others  # Define helper functions
-    #@+node:ekr.20220213142925.1: *4* function: convert_unl_list
+    #@+node:ekr.20230626064652.2: *4* function: convert_unl_list
     def convert_unl_list(aList: list[str]) -&gt; list[str]:
         """
         Convert old-style UNLs to new UNLs, retaining line numbers if possible.
@@ -7241,11 +7347,12 @@
             result.append(s)
         # Do *not* remove duplicates!
         return result
-    #@+node:ekr.20220213142735.1: *4* function: full_match
+    #@+node:ekr.20230626064652.3: *4* function: full_match
     def full_match(p: Position) -&gt; bool:
         """Return True if the stripped headlines of p and all p's parents match unlList."""
         # Careful: make copies.
-        aList, p1 = unlList[:], p.copy()
+        aList: list[str] = unlList[:]
+        p1 = p.copy()
         while aList and p1:
             m = new_pat.match(aList[-1])
             if m and m.group(1).strip() != p1.h.strip():
@@ -7283,19 +7390,15 @@
                     except(TypeError, ValueError):
                         g.trace('bad line number', line)
                 if n &lt; 0:
-                    p, offset = c.gotoCommands.find_file_line(-n, p)  # Calls c.redraw().
-                    if not p:
-                        g.trace(f"Not found: global line {n}")
-                    return p
-                insert_point = sum(len(z) for z in g.splitLines(p.b)[:n])
-                c.redraw(p)
-                c.frame.body.wrapper.setInsertPoint(insert_point)
-                c.frame.bringToFront()
-                c.bodyWantsFocusNow()
+                    p2, offset = c.gotoCommands.find_file_line(-n, p)  # Calls c.redraw().
+                    if not p2:
+                        g.trace(f"{p.h}: global line {n} not found")
                 return p
         # Not found. Pop the first parent from unlList.
         unlList.pop(0)
     return None
+
+findUNL = findUnl  # Compatibility.
 #@+node:ekr.20120311151914.9917: *3* g.getUrlFromNode
 def getUrlFromNode(p: Position) -&gt; Optional[str]:
     """
@@ -7331,84 +7434,25 @@
             return s
     return None
 #@+node:ekr.20170221063527.1: *3* g.handleUnl
-def handleUnl(unl: str, c: Cmdr) -&gt; Any:
-    """
-    Handle a Leo UNL. This must *never* open a browser.
-
-    Return the commander for the found UNL, or None.
-
-    Redraw the commander if the UNL is found.
-    """
+def handleUnl(unl_s: str, c: Cmdr) -&gt; Optional[Cmdr]:
+    """
+    Select the node given by any kind of unl.
+    This must *never* open a browser.
+    """
+    if not unl_s:
+        return None
+    unl = unl_s.strip()
     if not unl:
         return None
-    unll = unl.lower()
-    if unll.startswith('unl://'):
-        unl = unl[6:]
-    elif unll.startswith('file://'):
-        unl = unl[7:]
-    unl = unl.strip()
-    if not unl:
+    p = g.findAnyUnl(unl, c)
+    if not p:
+        print(f"Not found: {unl!r}")
         return None
-    unl = g.unquoteUrl(unl)
-    # Compute path and unl.
-    if '#' not in unl and '--&gt;' not in unl:
-        # The path is the entire unl.
-        path, unl = unl, None
-    elif '#' not in unl:
-        # The path is empty.
-        # Move to the unl in *this* commander.
-        p = g.findUNL(unl.split("--&gt;"), c)
-        if p:
-            c.redraw(p)
-        return c
-    else:
-        path, unl = unl.split('#', 1)
-    if not unl:
-        return None  # #2731.
-    if not path:  # #2407
-        # Move to the unl in *this* commander.
-        p = g.findUNL(unl.split("--&gt;"), c)
-        if p:
-            c.redraw(p)
-        return c
-    if c:
-        base = g.os_path_dirname(c.fileName())
-        c_path = g.finalize_join(base, path)
-    else:
-        c_path = None
-    # Look for the file in various places.
-    table = (
-        c_path,
-        g.finalize_join(g.app.loadDir, '..', path),
-        g.finalize_join(g.app.loadDir, '..', '..', path),
-        g.finalize_join(g.app.loadDir, '..', 'core', path),
-        g.finalize_join(g.app.loadDir, '..', 'config', path),
-        g.finalize_join(g.app.loadDir, '..', 'dist', path),
-        g.finalize_join(g.app.loadDir, '..', 'doc', path),
-        g.finalize_join(g.app.loadDir, '..', 'test', path),
-        g.app.loadDir,
-        g.app.homeDir,
-    )
-    for path2 in table:
-        if path2 and path2.lower().endswith('.leo') and os.path.exists(path2):
-            path = path2
-            break
-    else:
-        g.es_print('path not found', repr(path))
-        return None
-    # End editing in *this* outline, so typing in the new outline works.
-    c.endEditing()
-    c.redraw()
-    # Open the path.
-    c2 = g.openWithFileName(path, old_c=c)
-    if not c2:
-        return None
-    # Find  and redraw.
-    # #2445: Default to c2.rootPosition().
-    p = g.findUNL(unl.split("--&gt;"), c2) or c2.rootPosition()
+    # Do not assume that p is in c.
+    c2 = p.v.context
+    if c2 != c:
+        g.app.selectLeoWindow(c2)  # Switch outlines.
     c2.redraw(p)
-    c2.bringToFront()
-    c2.bodyWantsFocusNow()
     return c2
 #@+node:tbrown.20090219095555.63: *3* g.handleUrl &amp; helpers
 def handleUrl(url: str, c: Cmdr = None, p: Position = None) -&gt; Any:
@@ -7425,7 +7469,7 @@
     if urll.startswith('@url'):
         url = url[4:].lstrip()
     if (
-        urll.startswith(('#', 'unl://')) or
+        urll.startswith(('#', 'unl://', 'unl:gnx:')) or
         urll.startswith('file://') and '--&gt;' in urll
     ):
         return g.handleUnl(url, c)
@@ -7437,12 +7481,14 @@
         g.es_exception()
         return None
 #@+node:ekr.20170226054459.1: *4* g.handleUrlHelper
-def handleUrlHelper(url: str, c: Cmdr, p: Position) -&gt; None:
+def handleUrlHelper(url: str, c: Cmdr, p: Position) -&gt; None:  # pragma: no cover
     """Open a url.  Most browsers should handle:
         ftp://ftp.uu.net/public/whatever
         http://localhost/MySiteUnderDevelopment/index.html
         file:///home/me/todolist.html
     """
+    if g.unitTesting:
+        return
     tag = 'file://'
     original_url = url
     if url.startswith(tag) and not url.startswith(tag + '#'):
@@ -7462,23 +7508,18 @@
         g.handleUnl(original_url, c)
     elif parsed.scheme in ('', 'file'):
         unquote_path = g.unquoteUrl(leo_path)
-        if g.unitTesting:
-            pass
-        elif g.os_path_exists(leo_path):
+        if g.os_path_exists(leo_path):
             g.os_startfile(unquote_path)
         else:
             g.es(f"File '{leo_path}' does not exist")
     else:
-        if g.unitTesting:
+        # Mozilla throws a weird exception, then opens the file!
+        try:
+            webbrowser.open(url)
+        except Exception:
             pass
-        else:
-            # Mozilla throws a weird exception, then opens the file!
-            try:
-                webbrowser.open(url)
-            except Exception:
-                pass
 #@+node:ekr.20170226060816.1: *4* g.traceUrl
-def traceUrl(c: Cmdr, path: str, parsed: Any, url: str) -&gt; None:
+def traceUrl(c: Cmdr, path: str, parsed: Any, url: str) -&gt; None:  # pragma: no cover
 
     print()
     g.trace('url          ', url)
@@ -7488,6 +7529,13 @@
     g.trace('parsed.netloc', parsed.netloc)
     g.trace('parsed.path  ', parsed.path)
     g.trace('parsed.scheme', repr(parsed.scheme))
+#@+node:ekr.20230628072109.1: *3* g.isValidUnl
+# unls must contain a (possible empty) file part followed by something else.
+valid_unl_pattern = re.compile(r"(unl:gnx|unl|file)://(.*?)#.+")
+
+def isValidUnl(unl_s: str) -&gt; bool:
+    """Return true if the given unl is valid."""
+    return bool(valid_unl_pattern.match(unl_s))
 #@+node:ekr.20120311151914.9918: *3* g.isValidUrl
 def isValidUrl(url: str) -&gt; bool:
     """Return true if url *looks* like a valid url."""
@@ -7497,9 +7545,8 @@
         'sftp', 'shttp', 'sip', 'sips', 'snews', 'svn', 'svn+ssh', 'telnet', 'wais',
     )
     if not url:
-        return False
-    if url.lower().startswith('unl://') or url.startswith('#'):
-        # All Leo UNL's.
+        return False  # pragma: no cover (defensive)
+    if g.isValidUnl(url):
         return True
     if url.startswith('@'):
         return False
@@ -7510,7 +7557,7 @@
             return True
     return False
 #@+node:ekr.20120315062642.9744: *3* g.openUrl
-def openUrl(p: Position) -&gt; None:
+def openUrl(p: Position) -&gt; None:  # pragma: no cover
     """
     Open the url of node p.
     Use the headline if it contains a valid url.
@@ -7524,7 +7571,7 @@
                 g.handleUrl(url, c=c, p=p)
             g.doHook("@url2", c=c, p=p, url=url)
 #@+node:ekr.20110605121601.18135: *3* g.openUrlOnClick (open-url-under-cursor)
-def openUrlOnClick(event: Any, url: str = None) -&gt; Optional[str]:
+def openUrlOnClick(event: Any, url: str = None) -&gt; Optional[str]:  # pragma: no cover
     """Open the URL under the cursor.  Return it for unit testing."""
     # QTextEditWrapper.mouseReleaseEvent calls this outside Leo's command logic.
     # Make sure to catch all exceptions!
@@ -7533,7 +7580,7 @@
     except Exception:
         g.es_exception()
         return None
-#@+node:ekr.20170216091704.1: *4* g.openUrlHelper (changed)
+#@+node:ekr.20170216091704.1: *4* g.openUrlHelper
 def openUrlHelper(event: Any, url: str = None) -&gt; Optional[str]:
     """Open the unl, url or gnx under the cursor.  Return it for unit testing."""
     c = getattr(event, 'c', None)
@@ -7674,15 +7721,101 @@
     #@-&lt;&lt; look for filename or import&gt;&gt;
     return None
 #@+node:ekr.20170226093349.1: *3* g.unquoteUrl
-def unquoteUrl(url: str) -&gt; str:
-    """Replace special characters (especially %20, by their equivalent)."""
+def unquoteUrl(url: str) -&gt; str:  # pragma: no cover
+    """Replace escaped characters (especially %20, by their equivalent)."""
     return urllib.parse.unquote(url)
+#@+node:ekr.20230627143007.1: *3* g: file part utils
+
+#@+node:ekr.20230630132339.1: *4* g.getUNLFilePart
+file_part_pattern = re.compile(r'//(.*?)#.+')
+
+def getUNLFilePart(s: str) -&gt; str:
+    """Return the file part of a unl, that is, everything *between* '//' and '#'."""
+    # Strip the prefix if it exists.
+    for prefix in ('unl:gnx:', 'unl:', 'file:'):
+        if s.startswith(prefix):
+            s = s[len(prefix) :]
+            break
+    m = file_part_pattern.match(s)
+    return m.group(1) if m else ''
+#@+node:ekr.20230630132340.1: *4* g.openUNLFile
+def openUNLFile(c: Cmdr, s: str) -&gt; Cmdr:
+    """
+    Open the commander for filename s, the file part of an unl.
+
+    Return c if the file can not be found.
+    """
+    trace = False and g.unitTesting
+    if not s.strip():
+        return c
+    if s.startswith('//') and s.endswith('#'):
+        s = s[2:-1]
+    if not s.strip():
+        return c
+    if os.path.isabs(s):
+        path = os.path.normpath(s).lower()
+    else:
+        # Values of d should be directories.
+        d = g.parsePathData(c)
+        if trace:
+            print('')
+            g.printObj(d, tag='d')
+        base = os.path.basename(s)
+        directory = d.get(base)
+        if not directory:
+            g.trace(f"No directory for {s!r}")
+            return c
+        if not os.path.exists(directory):
+            g.trace(f"Directory found: {directory!r}")
+            return c
+        path = os.path.normpath(os.path.join(directory, base)).lower()
+        if trace:
+            g.trace('   directory:', directory.lower())
+            g.trace('        path:', path.lower())
+            g.trace('c.fileName():', os.path.normpath(c.fileName()).lower())
+    if path == os.path.normpath(c.fileName()).lower():
+        return c
+    # Search all open commanders.
+    # This is a good shortcut, and it helps unit tests.
+    for c2 in g.app.commanders():
+        if path == os.path.normpath(c2.fileName()).lower():
+            if trace:
+                g.trace(f"       Found: {os.path.normpath(c2.fileName())}")
+            return c2
+    # Open the file if possible.
+    if not os.path.exists(path):
+        if trace:
+            g.trace(f"   Not found: {path}")
+        return c
+    if trace:
+        g.trace(f"Opening {path}")
+    return g.openWithFileName(path)
+#@+node:ekr.20230630132341.1: *4* g.parsePathData
+path_data_pattern = re.compile(r'(.+?):\s*(.+)')
+
+def parsePathData(c: Cmdr) -&gt; dict[str, str]:
+    """
+    Return a dict giving path prefixes for the files given in @data unl-path-prefixes.
+    """
+    lines = c.config.getData('unl-path-prefixes')
+    d: dict[str, str] = {}
+    for line in lines:
+        m = path_data_pattern.match(line)
+        if m:
+            key, path = m.group(1), m.group(2)
+            if key in d:
+                g.trace(f"Ignoring duplicate key: {line!r}")  # pragma: no cover
+            else:
+                d[key] = os.path.normpath(path)
+        else:
+            g.trace(f"Ignoring line: {line!r}")  # pragma: no cover
+    return d
 #@-others
 # set g when the import is about to complete.
 g = sys.modules.get('leo.core.leoGlobals')
 assert g, sorted(sys.modules.keys())
 if __name__ == '__main__':
-    unittest.main()
+    unittest.main()  # pragma: no cover
 
 #@@language python
 #@@tabwidth -4
@language python
</t>
<t tx="ekr.20230704070426.20">def objToString(obj: Any, *, indent: int = 0, tag: str = None, width: int = 120) -&gt; str:
    """Pretty print any Python object to a string."""
    if isinstance(obj, (list, tuple)):
        # Return the enumerated lines of the list.
        result_list = ['[\n' if isinstance(obj, list) else '(\n']
        for i, z in enumerate(obj):
            result_list.append(f"  {i:4}: {z!r}\n")
        result_list.append(']\n' if isinstance(obj, list) else ')\n')
        result = ''.join(result_list)
    elif not isinstance(obj, str):
        result = pprint.pformat(obj, indent=indent, width=width)
        # Put opening/closing delims on separate lines.
        if result.count('\n') &gt; 0 and result[0] in '([{' and result[-1] in ')]}':
            result = f"{result[0]}\n{result[1:-2]}\n{result[-1]}"
    elif '\n' not in obj:
        result = repr(obj)
    else:
        # Return the enumerated lines of the string.
        lines = ''.join([
            f"  {i:4}: {z!r}\n" for i, z in enumerate(g.splitLines(obj))
        ])
        result = f"[\n{lines}]\n"
    return f"{tag.strip()}: {result}" if tag and tag.strip() else result

toString = objToString
dictToString = objToString
listToString = objToString
tupleToString = objToString
</t>
<t tx="ekr.20230704070426.25">@ignore
@nosearch
@language patch
--- uncommitted
+++ uncommitted
@@ -1,79 +1,20 @@
-def handleUnl(unl: str, c: Cmdr) -&gt; Any:
+def handleUnl(unl_s: str, c: Cmdr) -&gt; Optional[Cmdr]:
     """
-    Handle a Leo UNL. This must *never* open a browser.
-
-    Return the commander for the found UNL, or None.
-
-    Redraw the commander if the UNL is found.
+    Select the node given by any kind of unl.
+    This must *never* open a browser.
     """
+    if not unl_s:
+        return None
+    unl = unl_s.strip()
     if not unl:
         return None
-    unll = unl.lower()
-    if unll.startswith('unl://'):
-        unl = unl[6:]
-    elif unll.startswith('file://'):
-        unl = unl[7:]
-    unl = unl.strip()
-    if not unl:
+    p = g.findAnyUnl(unl, c)
+    if not p:
+        print(f"Not found: {unl!r}")
         return None
-    unl = g.unquoteUrl(unl)
-    # Compute path and unl.
-    if '#' not in unl and '--&gt;' not in unl:
-        # The path is the entire unl.
-        path, unl = unl, None
-    elif '#' not in unl:
-        # The path is empty.
-        # Move to the unl in *this* commander.
-        p = g.findUNL(unl.split("--&gt;"), c)
-        if p:
-            c.redraw(p)
-        return c
-    else:
-        path, unl = unl.split('#', 1)
-    if not unl:
-        return None  # #2731.
-    if not path:  # #2407
-        # Move to the unl in *this* commander.
-        p = g.findUNL(unl.split("--&gt;"), c)
-        if p:
-            c.redraw(p)
-        return c
-    if c:
-        base = g.os_path_dirname(c.fileName())
-        c_path = g.finalize_join(base, path)
-    else:
-        c_path = None
-    # Look for the file in various places.
-    table = (
-        c_path,
-        g.finalize_join(g.app.loadDir, '..', path),
-        g.finalize_join(g.app.loadDir, '..', '..', path),
-        g.finalize_join(g.app.loadDir, '..', 'core', path),
-        g.finalize_join(g.app.loadDir, '..', 'config', path),
-        g.finalize_join(g.app.loadDir, '..', 'dist', path),
-        g.finalize_join(g.app.loadDir, '..', 'doc', path),
-        g.finalize_join(g.app.loadDir, '..', 'test', path),
-        g.app.loadDir,
-        g.app.homeDir,
-    )
-    for path2 in table:
-        if path2 and path2.lower().endswith('.leo') and os.path.exists(path2):
-            path = path2
-            break
-    else:
-        g.es_print('path not found', repr(path))
-        return None
-    # End editing in *this* outline, so typing in the new outline works.
-    c.endEditing()
-    c.redraw()
-    # Open the path.
-    c2 = g.openWithFileName(path, old_c=c)
-    if not c2:
-        return None
-    # Find  and redraw.
-    # #2445: Default to c2.rootPosition().
-    p = g.findUNL(unl.split("--&gt;"), c2) or c2.rootPosition()
+    # Do not assume that p is in c.
+    c2 = p.v.context
+    if c2 != c:
+        g.app.selectLeoWindow(c2)  # Switch outlines.
     c2.redraw(p)
-    c2.bringToFront()
-    c2.bodyWantsFocusNow()
     return c2
@language python
</t>
<t tx="ekr.20230704070426.26">def handleUnl(unl: str, c: Cmdr) -&gt; Any:
    """
    Handle a Leo UNL. This must *never* open a browser.

    Return the commander for the found UNL, or None.

    Redraw the commander if the UNL is found.
    """
    if not unl:
        return None
    unll = unl.lower()
    if unll.startswith('unl://'):
        unl = unl[6:]
    elif unll.startswith('file://'):
        unl = unl[7:]
    unl = unl.strip()
    if not unl:
        return None
    unl = g.unquoteUrl(unl)
    # Compute path and unl.
    if '#' not in unl and '--&gt;' not in unl:
        # The path is the entire unl.
        path, unl = unl, None
    elif '#' not in unl:
        # The path is empty.
        # Move to the unl in *this* commander.
        p = g.findUNL(unl.split("--&gt;"), c)
        if p:
            c.redraw(p)
        return c
    else:
        path, unl = unl.split('#', 1)
    if not unl:
        return None  # #2731.
    if not path:  # #2407
        # Move to the unl in *this* commander.
        p = g.findUNL(unl.split("--&gt;"), c)
        if p:
            c.redraw(p)
        return c
    if c:
        base = g.os_path_dirname(c.fileName())
        c_path = g.finalize_join(base, path)
    else:
        c_path = None
    # Look for the file in various places.
    table = (
        c_path,
        g.finalize_join(g.app.loadDir, '..', path),
        g.finalize_join(g.app.loadDir, '..', '..', path),
        g.finalize_join(g.app.loadDir, '..', 'core', path),
        g.finalize_join(g.app.loadDir, '..', 'config', path),
        g.finalize_join(g.app.loadDir, '..', 'dist', path),
        g.finalize_join(g.app.loadDir, '..', 'doc', path),
        g.finalize_join(g.app.loadDir, '..', 'test', path),
        g.app.loadDir,
        g.app.homeDir,
    )
    for path2 in table:
        if path2 and path2.lower().endswith('.leo') and os.path.exists(path2):
            path = path2
            break
    else:
        g.es_print('path not found', repr(path))
        return None
    # End editing in *this* outline, so typing in the new outline works.
    c.endEditing()
    c.redraw()
    # Open the path.
    c2 = g.openWithFileName(path, old_c=c)
    if not c2:
        return None
    # Find  and redraw.
    # #2445: Default to c2.rootPosition().
    p = g.findUNL(unl.split("--&gt;"), c2) or c2.rootPosition()
    c2.redraw(p)
    c2.bringToFront()
    c2.bodyWantsFocusNow()
    return c2
</t>
<t tx="ekr.20230704070426.27">@ignore
@nosearch
@language patch
--- uncommitted
+++ uncommitted
@@ -12,7 +12,7 @@
     if urll.startswith('@url'):
         url = url[4:].lstrip()
     if (
-        urll.startswith(('#', 'unl://')) or
+        urll.startswith(('#', 'unl://', 'unl:gnx:')) or
         urll.startswith('file://') and '--&gt;' in urll
     ):
         return g.handleUnl(url, c)
@language python
</t>
<t tx="ekr.20230704070426.28">def handleUrl(url: str, c: Cmdr = None, p: Position = None) -&gt; Any:
    """Open a url or a unl."""
    if c and not p:
        p = c.p
    # These two special cases should match the hacks in jedit.match_any_url.
    if url.endswith('.'):
        url = url[:-1]
    if '(' not in url and url.endswith(')'):
        url = url[:-1]
    # Lower the url.
    urll = url.lower()
    if urll.startswith('@url'):
        url = url[4:].lstrip()
    if (
        urll.startswith(('#', 'unl://')) or
        urll.startswith('file://') and '--&gt;' in urll
    ):
        return g.handleUnl(url, c)
    try:
        g.handleUrlHelper(url, c, p)
        return urll  # For unit tests.
    except Exception:
        g.es_print("g.handleUrl: exception opening", repr(url))
        g.es_exception()
        return None
</t>
<t tx="ekr.20230704070426.29">@ignore
@nosearch
@language patch
--- uncommitted
+++ uncommitted
@@ -1,9 +1,11 @@
-def handleUrlHelper(url: str, c: Cmdr, p: Position) -&gt; None:
+def handleUrlHelper(url: str, c: Cmdr, p: Position) -&gt; None:  # pragma: no cover
     """Open a url.  Most browsers should handle:
         ftp://ftp.uu.net/public/whatever
         http://localhost/MySiteUnderDevelopment/index.html
         file:///home/me/todolist.html
     """
+    if g.unitTesting:
+        return
     tag = 'file://'
     original_url = url
     if url.startswith(tag) and not url.startswith(tag + '#'):
@@ -23,18 +25,13 @@
         g.handleUnl(original_url, c)
     elif parsed.scheme in ('', 'file'):
         unquote_path = g.unquoteUrl(leo_path)
-        if g.unitTesting:
-            pass
-        elif g.os_path_exists(leo_path):
+        if g.os_path_exists(leo_path):
             g.os_startfile(unquote_path)
         else:
             g.es(f"File '{leo_path}' does not exist")
     else:
-        if g.unitTesting:
+        # Mozilla throws a weird exception, then opens the file!
+        try:
+            webbrowser.open(url)
+        except Exception:
             pass
-        else:
-            # Mozilla throws a weird exception, then opens the file!
-            try:
-                webbrowser.open(url)
-            except Exception:
-                pass
@language python
</t>
<t tx="ekr.20230704070426.30">def handleUrlHelper(url: str, c: Cmdr, p: Position) -&gt; None:
    """Open a url.  Most browsers should handle:
        ftp://ftp.uu.net/public/whatever
        http://localhost/MySiteUnderDevelopment/index.html
        file:///home/me/todolist.html
    """
    tag = 'file://'
    original_url = url
    if url.startswith(tag) and not url.startswith(tag + '#'):
        # Finalize the path *before* parsing the url.
        url = g.computeFileUrl(url, c=c, p=p)
    parsed = urlparse.urlparse(url)
    if parsed.netloc:
        leo_path = os.path.join(parsed.netloc, parsed.path)
        # "readme.txt" gets parsed into .netloc...
    else:
        leo_path = parsed.path
    if leo_path.endswith('\\'):
        leo_path = leo_path[:-1]
    if leo_path.endswith('/'):
        leo_path = leo_path[:-1]
    if parsed.scheme == 'file' and leo_path.endswith('.leo'):
        g.handleUnl(original_url, c)
    elif parsed.scheme in ('', 'file'):
        unquote_path = g.unquoteUrl(leo_path)
        if g.unitTesting:
            pass
        elif g.os_path_exists(leo_path):
            g.os_startfile(unquote_path)
        else:
            g.es(f"File '{leo_path}' does not exist")
    else:
        if g.unitTesting:
            pass
        else:
            # Mozilla throws a weird exception, then opens the file!
            try:
                webbrowser.open(url)
            except Exception:
                pass
</t>
<t tx="ekr.20230704070426.33">@ignore
@nosearch
@language patch
--- uncommitted
+++ uncommitted
@@ -6,9 +6,8 @@
         'sftp', 'shttp', 'sip', 'sips', 'snews', 'svn', 'svn+ssh', 'telnet', 'wais',
     )
     if not url:
-        return False
-    if url.lower().startswith('unl://') or url.startswith('#'):
-        # All Leo UNL's.
+        return False  # pragma: no cover (defensive)
+    if g.isValidUnl(url):
         return True
     if url.startswith('@'):
         return False
@language python
</t>
<t tx="ekr.20230704070426.34">def isValidUrl(url: str) -&gt; bool:
    """Return true if url *looks* like a valid url."""
    table = (
        'file', 'ftp', 'gopher', 'hdl', 'http', 'https', 'imap',
        'mailto', 'mms', 'news', 'nntp', 'prospero', 'rsync', 'rtsp', 'rtspu',
        'sftp', 'shttp', 'sip', 'sips', 'snews', 'svn', 'svn+ssh', 'telnet', 'wais',
    )
    if not url:
        return False
    if url.lower().startswith('unl://') or url.startswith('#'):
        # All Leo UNL's.
        return True
    if url.startswith('@'):
        return False
    parsed = urlparse.urlparse(url)
    scheme = parsed.scheme
    for s in table:
        if scheme.startswith(s):
            return True
    return False
</t>
<t tx="ekr.20230704070426.7"></t>
<t tx="ekr.20230704070426.9">def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')  # '::' is the separator.

    @others  # Define helper functions

    unlList = convert_unl_list(unlList1)
    if not unlList:
        return None
    # Find all target headlines.
    targets = []
    m = new_pat.match(unlList[-1])
    target = m and m.group(1) or unlList[-1]
    targets.append(target.strip())
    targets.extend(unlList[:-1])
    # Find all target positions. Prefer later positions.
    positions = list(reversed(list(z for z in c.all_positions() if z.h.strip() in targets)))
    while unlList:
        for p in positions:
            p1 = p.copy()
            if full_match(p):
                assert p == p1, (p, p1)
                n = 0  # The default line number.
                # Parse the last target.
                m = new_pat.match(unlList[-1])
                if m:
                    line = m.group(3)
                    try:
                        n = int(line)
                    except(TypeError, ValueError):
                        g.trace('bad line number', line)
                if n &lt; 0:
                    p, offset = c.gotoCommands.find_file_line(-n, p)  # Calls c.redraw().
                    if not p:
                        g.trace(f"Not found: global line {n}")
                    return p
                insert_point = sum(len(z) for z in g.splitLines(p.b)[:n])
                c.redraw(p)
                c.frame.body.wrapper.setInsertPoint(insert_point)
                c.frame.bringToFront()
                c.bodyWantsFocusNow()
                return p
        # Not found. Pop the first parent from unlList.
        unlList.pop(0)
    return None
</t>
<t tx="ekr.20230704070458.1"></t>
<t tx="ekr.20230704130731.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3423
PR: https://github.com/leo-editor/leo-editor/pull/3426

git-log: https://git-scm.com/docs/git-log#Documentation/git-log.txt--Lltstartgtltendgtltfilegt

Rev 01272f90f3 restored (one of) Terry's gnx.

To do later:
- replace '#' by language-specific comment delim.
- Use a rev cache?
- API: Get history of given position.

.. ekr.20230626064652.1  # EKR's replacement gnx
.. tbrown.20140311095634.15188

@language python
</t>
<t tx="ekr.20230704183625.1">@language rest

PR: https://github.com/leo-editor/leo-editor/pull/3424
</t>
<t tx="ekr.20230704211058.1">@language rest

*** clicking error links should search from end of outline.

Household
- Ask Krill about San Diego.
- Order CPAP mask.
- Call Bachhuber about plavix.

Later:
- Rewrite LeoPyRef.leo after all changes.

See children.
</t>
<t tx="ekr.20230705050235.1">- Manage energy, not time.
- Avoid burnout for 50 years.
- Postit notes by computer: Allows me to leave :-)
- Postit notes in bedroom: so I can sleep.</t>
<t tx="ekr.20230705082614.1">def node_history(self, path: str, gnxs: list[str], limit: int = None) -&gt; None:
    """Produce a Leonine history of the node whose file name and gnx are given."""
    c = self.c
    # The path must be absolute.
    if not os.path.isabs(path):
        g.trace(f"Not absolute: {path!r}")
        return
    # Get all the revs.
    rev_list = self._get_revs_for_path(path)
    # Get the files.
    contents_list = self._get_contents_for_revs(path, rev_list, limit)
    # Truncate revs_list so it has the same length as contents_list.
    truncated_revs_list = rev_list[: len(contents_list)]
    # Find changed nodes.
    diff_list = self._get_diff_list(contents_list, gnxs, path, truncated_revs_list)
    if not diff_list:
        return
    # Create the root node.
    self.root = p = c.lastTopLevel().insertAfter()
    limit_s = 'None' if limit is None else limit
    p.h = f"node_history: {g.shortFileName(path)}"
    p.b = f"@ignore\n@nosearch\n\n# gnxs: {', '.join(gnxs)}\n# limit: {limit_s}"
    # Generate all other nodes.
    self._generate_nodes(diff_list, truncated_revs_list)
    self.finish()
</t>
<t tx="ekr.20230705084709.1">def _get_revs_for_path(self, path: str) -&gt; list[str]:
    """
    Return the list of full hashes for all commits to the given absolute path.
    """
    # Run the command itself in leo-editor, the parent of the .git directory.
    git_parent_directory = self.get_parent_of_git_directory()

    # Human readable summary.
    # %h (%an %cs %s): Abbreviated hash, author, date, commit message
    args_s = "--no-patch --pretty='format:%H'"  # Just the long hash.
    command = fr"git log {args_s} -- {path}"
    aList = g.execGitCommand(command, git_parent_directory)
    result = [z.strip() for z in aList]
    return result
</t>
<t tx="ekr.20230705085430.1">def _get_contents_for_revs(self,
    path: str,
    rev_list: list[str],
    limit: Optional[int] = None,
) -&gt; list[list[str]]:
    """
    Return the contents of the file as a list of lines.
    path: the full path to the file.
    rev_list: the list of full git hashes for each rev.
    limit: None (no limit), the number revs to search.
    """
    # Note: the time module excludes sleep time. It's inaccurate here.

    # Run the command itself in the leo-editor, the parent of the .git directory.
    git_parent_directory = self.get_parent_of_git_directory()

    # Compute the path relative to the parent.
    relative_path = os.path.relpath(path, git_parent_directory).replace('\\', '/')

    # Get full file contents of rev.
    result: list[list[str]] = []
    of_s = '' if limit is None else f" of {len(rev_list)}"
    n = len(rev_list) if limit is None else min(limit, len(rev_list))
    g.es_print(f"Reading {n}{of_s} revs!\nThis will take a few minutes.")
    for i, rev in enumerate(rev_list[:limit]):
        command = fr"git show {rev}:{relative_path}"
        aList = g.execGitCommand(command, git_parent_directory)
        result.append(aList)
        if i &gt; 0 and (i % 100) == 0:
            g.es_print(f"Progress: {i} revs")
    g.es_print(f"Done! {n}{of_s} revs")
    return result
</t>
<t tx="ekr.20230705103504.1"></t>
<t tx="ekr.20230705174359.1">@language rest

I use clones because they help focus my attention on the task at hand.

This FAQ entry describes in detail how I use clones.
https://leo-editor.github.io/leo-editor/FAQ.html#how-does-ekr-use-clones

I don't understand why more Leonistas don't follow my example :-)

Info issue #1177 describes another aspect of my workflow.
https://github.com/leo-editor/leo-editor/issues/1177

</t>
<t tx="ekr.20230706110602.1"></t>
<t tx="ekr.20230706110947.1">#@+node:tbrown.20111010104549.26758: *4* p.get_UNL
    def get_UNL(self) -&gt; str:
        """
        Return a UNL representing a clickable link.
        See the section &lt; define global error regexs &gt; for the regexes.

        New in Leo 6.6: Use a single, simplified format for UNL's:

        - unl: //
        - self.v.context.fileName() #
        - a list of headlines separated by '--&gt;'

        New in Leo 6.6:
        - Always add unl: // and file name.
        - Never translate '--&gt;' to '--%3E'.
        - Never generate child indices.
        """
        base_unl = (self.v.context.fileName() + '#'
            + '--&gt;'.join(list(reversed([z.h for z in self.self_and_parents(copy=False)])))
                    )
        encoded = base_unl.replace("'", "%27")
        return 'unl://' + encoded</t>
<t tx="ekr.20230706124802.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3429
PR: https://github.com/leo-editor/leo-editor/pull/xxx

@language python
</t>
<t tx="ekr.20230706125038.1"></t>
<t tx="ekr.20230706125050.1"></t>
<t tx="ekr.20230706125618.1">def anyGnxClashes(c: Cmdr, pasted: Position) -&gt; bool:
    """Return True if there are any gnx clashes within c's outline."""
    c = self
    # Make *sure* p is not already in the outline.
    for p in c.all_positions():
        if p == pasted:
            g.trace(f"Can not happen: pasted in outline: {pasted!r}")
            return True
    for p in c.all_positions():
        if p.v.gnx == pasted.gnx:
            # g.trace(f"Gnx clash: {pasted!r}, {p!r}")
            return True
    return False
</t>
<t tx="ekr.20230706132550.1">def preReadLeoOutlineFromClipboard(self, s: str) -&gt; Optional[Position]:
    """
    Read a Leo outline from string s in clipboard format.
    Return the newly-created position, but do *not* link it into the outline.
    """
    ### Based on getLeoOutlineFromClipboard
    c = self.c
    current = c.p
    if not current:
        g.trace('no c.p')
        return None
    self.initReadIvars()
    # Save the hidden root's children.
    old_children = c.hiddenRootNode.children
    # Save and clear gnxDict.
    oldGnxDict = self.gnxDict
    self.gnxDict = {}
    if s.lstrip().startswith("{"):
        # Maybe JSON
        hidden_v = FastRead(c, self.gnxDict).readFileFromJsonClipboard(s)
    else:
        # This encoding must match the encoding used in outline_to_clipboard_string.
        s_bytes = g.toEncodedString(s, self.leo_file_encoding, reportErrors=True)
        hidden_v = FastRead(c, self.gnxDict).readFileFromClipboard(s_bytes)
    v = hidden_v.children[0]
    v.parents = []
    # Restore the hidden root's children
    c.hiddenRootNode.children = old_children
    if not v:
        g.es("the clipboard is not valid ", color="blue")
        return None
    # Create the position.
    p = leoNodes.Position(v)
    self.gnxDict = oldGnxDict
    return p

    ###
        # # Do *not* adjust links when linking v.
        # if current.hasChildren() and current.isExpanded():
            # p._linkCopiedAsNthChild(current, 0)
        # else:
            # p._linkCopiedAfter(current)
        # assert not p.isCloned(), g.objToString(p.v.parents)
        # self.gnxDict = oldGnxDict
        # self.reassignAllIndices(p)
        # c.selectPosition(p)
        # self.initReadIvars()
        # return p


</t>
<t tx="ekr.20230706192145.1">@g.commander_command('paste-node-allocating-gnxs')
def pasteOutlineAllocatingGnxs(
    self: Self,
    event: Event = None,
    s: str = None,
    undoFlag: bool = True,
) -&gt; Optional[Position]:
    """
    Paste an outline into the present outline from the clipboard.
    Always allocate new gnxs.
    """
    # Define helper.
    @others
    c, fc = self, self.fileCommands
    if s is None:
        s = g.app.gui.getTextFromClipboard()
    c.endEditing()
    if not s or not c.canPasteOutline(s):
        return None  # This should never happen.
    isLeo = s.lstrip().startswith("{") or g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        return None
    # Get *position* to be pasted.
    pasted = fc.getLeoOutlineFromClipboard(s)  # Reassigns gnxs.
    if not pasted:
        return None
    # Validate.
    c.validateOutline()
    c.checkOutline()
    # Handle the "before" data for undo.
    if undoFlag:
        undoData = c.undoer.beforeInsertNode(c.p,
            pasteAsClone=False,
            copiedBunchList=[],
        )
    # Paste the node into the outline.
    c.selectPosition(pasted)
    pasted.setDirty()
    c.setChanged()
    back = pasted.back()
    if back and back.hasChildren() and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # Finish the command.
    if undoFlag:
        c.undoer.afterInsertNode(pasted, 'Paste Node Allocating Gnxs', undoData)
    c.redraw(pasted)
    c.recolor()
    return pasted
</t>
<t tx="ekr.20230708161215.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3431
PR: https://github.com/leo-editor/leo-editor/pull/3432

@language python
</t>
<t tx="ekr.20230708161435.1"></t>
<t tx="ekr.20230708162329.1"></t>
<t tx="ekr.20230709033411.1"></t>
<t tx="ekr.20230709034733.1"></t>
<t tx="ekr.20230709035419.1"></t>
<t tx="ekr.20230709055224.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3403

@language python
</t>
<t tx="ekr.20230709055736.1"></t>
<t tx="ekr.20230709120116.1">https://github.com/leo-editor/leo-editor/pull/3436</t>
<t tx="ekr.20230710054912.1">@language rest

PR: https://github.com/leo-editor/leo-editor/pull/3437

@language python
@nosearch
</t>
<t tx="ekr.20230710055039.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3435
PR: https://github.com/leo-editor/leo-editor/pull/3438

@language python
</t>
<t tx="ekr.20230713075025.1"></t>
<t tx="ekr.20230713080301.1"></t>
<t tx="ekr.20230713145834.1">def beforeParseBody(self, p: Position) -&gt; g.Bunch:
    u = self
    bunch = u.createCommonBunch(p)
    bunch.oldBody = p.b
    return bunch
</t>
<t tx="ekr.20230713150109.1">def undoParseBody(self) -&gt; None:
    """Restore p.b and delete all children."""
    u = self
    c = u.c
    p = u.p
    w = c.frame.body.wrapper
    p.deleteAllChildren()
    c.selectPosition(p)
    p.setDirty()
    p.b = u.oldBody
    w.setAllText(u.oldBody)
    w.setSelectionRange(0, 0, insert=0)
    w.setYScrollPosition(0)
</t>
<t tx="ekr.20230713150847.1">def redoParseBody(self) -&gt; None:
    """Redo the parse-body command."""
    u = self
    c = u.c
    ic = c.importCommands
    p = u.p
    if c.p != p:
        c.selectPosition(p)
    ic.parse_body(p)
</t>
<t tx="ekr.20230713151537.1">def afterParseBody(self, p: Position, command: str, bunch: g.Bunch) -&gt; None:
    """
    Create an undo node using d created by u.beforeParseBody
    """
    c = self.c
    u, w = self, c.frame.body.wrapper
    if u.redoing or u.undoing:
        return  # pragma: no cover
    # Set the type &amp; helpers.
    bunch.kind = 'parse-body'
    bunch.undoType = command
    bunch.undoHelper = u.undoParseBody
    bunch.redoHelper = u.redoParseBody
    u.pushBead(bunch)
    u.updateAfterTyping(p, w)
</t>
<t tx="ekr.20230713152722.1"></t>
<t tx="ekr.20230713170902.1"></t>
<t tx="ekr.20230714012821.1">def clearAndWarn(self, command_name: str) -&gt; None:
    """
    Clear all undo state and issue a warning.

    All non-undoable commands should call this method.
    """
    u = self
    u.last_undoable_command_name = command_name
    u.clearUndoState()
</t>
<t tx="ekr.20230714094011.1"></t>
<t tx="ekr.20230714131540.3">def test_diff_marked_nodes(self):

    from leo.core.leoCompare import diffMarkedNodes

    # Setup.
    c = self.c
    u = c.undoer
    root = c.rootPosition()
    root.deleteAllChildren()
    while root.hasNext():
        root.next().doDelete()
    c.selectPosition(root)

    # Create two sets of nodes.
    node1 = root.insertAsLastChild()
    node2 = root.insertAsLastChild()
    child1 = node1.insertAsLastChild()
    child2 = node2.insertAsLastChild()

    # Mark the nodes.
    node1.setMarked()
    node2.setMarked()

    # Populate the nodes.
    table = (
        (node1, 'node 1', '# Node 1.\n'),
        (node2, 'node 1a', '# Node 1.\n'),  # Headlines differ.
        (child1, 'child 1', '# Child 1.\n'),
        (child2, 'child 1', '# Child 1a.\n'),  # Bodies differ.
    )
    for p, h, b in table:
        p.h = h
        p.b = b
    self.assertEqual(c.lastTopLevel(), root)

    # Run the command.
    diffMarkedNodes(event={'c': c})
    self.assertEqual(c.lastTopLevel().h, 'diff marked nodes')
    u.undo()
    self.assertEqual(c.lastTopLevel(), root)
    u.redo()
    self.assertEqual(c.lastTopLevel().h, 'diff marked nodes')
</t>
<t tx="ekr.20230714143317.3">def slow_test_gdc_node_history(self):

    # These links are valid within leoPy.leo on EKR's machine.
    # g.findUnl:        unl:gnx://leoPy.leo#ekr.20230626064652.1
    # g.parsePathData:  unl:gnx://leoPy.leo#ekr.20230630132341.1

    path = g.os_path_finalize_join(g.app.loadDir, 'leoGlobals.py')
    msg = repr(path)
    self.assertTrue(os.path.exists(path), msg=msg)
    self.assertTrue(os.path.isabs(path), msg=msg)
    self.assertTrue(os.path.isfile(path), msg=msg)
    x = GitDiffController(c=self.c)
    gnxs = (
        'ekr.20230626064652.1',  # EKR's replacement gnx
        'tbrown.20140311095634.15188',  # Terry's original node.
    )
    x.node_history(path, gnxs, limit=30)
    # self.dump_tree(tag='slow_test_gdc_node_history')
</t>
<t tx="ekr.20230714143451.1">def test_diff_two_branches(self):
    c = self.c
    u = c.undoer
    x = GitDiffController(c=c)

    # Setup the outline.
    root = c.rootPosition()
    root.h = '@file leoGlobals.py'
    root.deleteAllChildren()
    while root.hasNext():
        root.next().doDelete()
    c.selectPosition(root)

    # Run the test in the leo-editor directory (the parent of the .git directory).
    try:
        # Change directory.
        new_dir = g.finalize_join(g.app.loadDir, '..', '..')
        old_dir = os.getcwd()
        os.chdir(new_dir)

        # Run the command, suppressing output from git.
        expected_last_headline = 'git-diff-branches master devel'
        try:
            sys.stdout = open(os.devnull, 'w')
            x.diff_two_branches(
                branch1='master',
                branch2='devel',
                fn='leo/core/leoGlobals.py'  # Don't use backslashes.
            )
        finally:
            sys.stdout = sys.__stdout__
        self.assertEqual(c.lastTopLevel().h, expected_last_headline)
        u.undo()
        self.assertEqual(c.lastTopLevel(), root)
        u.redo()
        self.assertEqual(c.lastTopLevel().h, expected_last_headline)
    finally:
        os.chdir(old_dir)
</t>
<t tx="ekr.20230714154706.1">def verbose_test_git_diff(self):
    # Don't run this test by default.
    # It can spew random git messages depending on the state of the repo.
    c = self.c
    u = c.undoer
    x = GitDiffController(c=c)

    # Setup the outline.
    root = c.rootPosition()
    while root.hasNext():
        root.next().doDelete()
    c.selectPosition(root)

    expected_last_headline = 'git diff HEAD'
    # Run the command, suppressing git messages.
    # Alas, this suppression does not work.
    try:
        sys.stdout = open(os.devnull, 'w')
        x.git_diff()
    finally:
        sys.stdout = sys.__stdout__
    self.assertTrue(c.lastTopLevel().h.startswith(expected_last_headline))
    # Test undo/redo.
    u.undo()
    self.assertEqual(c.lastTopLevel(), root)
    u.redo()
    self.assertTrue(c.lastTopLevel().h.startswith(expected_last_headline))
</t>
<t tx="ekr.20230714160049.1">def test_diff_two_revs(self):
    c = self.c
    u = c.undoer
    x = GitDiffController(c=c)

    # Setup the outline.
    root = c.rootPosition()
    while root.hasNext():
        root.next().doDelete()
    c.selectPosition(root)

    # Run the command.
    expected_last_headline = 'git diff revs: HEAD'
    try:
        sys.stdout = open(os.devnull, 'w')
        x.diff_two_revs()
    finally:
        sys.stdout = sys.__stdout__
    self.assertEqual(c.lastTopLevel().h.strip(), expected_last_headline)
    # Test undo/redo.
    u.undo()
    self.assertEqual(c.lastTopLevel(), root)
    u.redo()
    self.assertEqual(c.lastTopLevel().h.strip(), expected_last_headline)
</t>
<t tx="ekr.20230714160900.1">def test_diff_list_of_files(self):

    from leo.core.leoCompare import CompareLeoOutlines

    # Setup.
    c = self.c
    u = c.undoer
    x = CompareLeoOutlines(c)
    root = c.rootPosition()
    root.deleteAllChildren()
    while root.hasNext():
        root.next().doDelete()
    c.selectPosition(root)
    self.assertEqual(c.lastTopLevel(), root)

    # The contents of a small .leo file.
    contents1 = textwrap.dedent(
        """
        &lt;?xml version="1.0" encoding="utf-8"?&gt;
        &lt;!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html --&gt;
        &lt;leo_file xmlns:leo="http://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" &gt;
        &lt;leo_header file_format="2"/&gt;
        &lt;globals/&gt;
        &lt;preferences/&gt;
        &lt;find_panel_settings/&gt;
        &lt;vnodes&gt;
        &lt;v t="ekr.20230714162224.2"&gt;&lt;vh&gt;test_file1.leo&lt;/vh&gt;&lt;/v&gt;
        &lt;/vnodes&gt;
        &lt;tnodes&gt;
        &lt;t tx="ekr.20230714162224.2"&gt;&lt;/t&gt;
        &lt;/tnodes&gt;
        &lt;/leo_file&gt;
        """).lstrip()  # Leo doesn't tolerate a leading blank line!
    contents2 = contents1.replace('test_file1.leo', 'test_file2.leo')

    # Create the absolute paths.
    directory = tempfile.gettempdir()
    path1 = os.path.normpath(os.path.join(directory, 'test_file1.leo'))
    path2 = os.path.normpath(os.path.join(directory, 'test_file2.leo'))
    paths = [path1, path2]

    # Create two temp .leo files.
    for path, contents in ((path1, contents1), (path2, contents2)):
        with open(path, 'wb') as f:
            f.write(g.toEncodedString(contents))

    # Run the command.
    expected_last_headline = 'diff-leo-files'
    x.diff_list_of_files(paths)
    self.assertEqual(c.lastTopLevel().h, expected_last_headline)

    # Test undo and redo.
    u.undo()
    self.assertEqual(c.lastTopLevel(), root)
    u.redo()
    self.assertEqual(c.lastTopLevel().h, expected_last_headline)

    # Remove temporary files.
    for path in paths:
        self.assertTrue(os.path.exists(path), msg=path)
        os.remove(path)
        self.assertFalse(os.path.exists(path), msg=path)
</t>
<t tx="ekr.20230715004610.1">def slow_test_ric_run(self):
    c = self.c
    u = c.undoer

    # Setup.
    root = c.rootPosition()
    root.deleteAllChildren()
    while root.hasNext():
        root.next().doDelete()
    c.selectPosition(root)
    self.assertEqual(c.lastTopLevel(), root)
    if 1:
        # 0.9 sec to import only leoGlobals.py
        dir_ = g.os_path_finalize_join(g.app.loadDir, 'leoGlobals.py')
    else:
        # 4.1 sec. to import leo/core/*.py.
        dir_ = os.path.normpath(g.app.loadDir)
    self.assertTrue(os.path.exists(dir_), msg=dir_)

    # Run the tests.
    expected_headline = 'imported files'
    for kind in ('@clean', '@file'):
        x = leoImport.RecursiveImportController(c,
            dir_=dir_,
            kind='@clean',
            recursive=True,
            safe_at_file = True,
            theTypes=['.py'],
            verbose=False,
        )
        x.run(dir_)
        self.assertEqual(c.lastTopLevel().h, expected_headline)
        u.undo()
        self.assertEqual(c.lastTopLevel(), root)
        u.redo()
        self.assertEqual(c.lastTopLevel().h, expected_headline)
        u.undo()
        self.assertEqual(c.lastTopLevel(), root)
</t>
<t tx="ekr.20230715061355.1"># Found 3 marked nodes</t>
<t tx="ekr.20230716044824.1">https://github.com/leo-editor/leo-editor/pull/3440</t>
<t tx="ekr.20230716093221.1">leo-editor\leo\doc\sphinx-docs\conf.py: error:
    Duplicate module named "conf" (also at "c:\Repos\leo-editor\leo\doc\html\conf.py")

leo-editor\leo\doc\sphinx-docs\conf.py: note:
    See https://mypy.readthedocs.io/en/stable/running_mypy.html#mapping-file-paths-to-modules
    for more info

leo-editor\leo\doc\sphinx-docs\conf.py: note:
    Common resolutions include:
        a) using `--exclude` to avoid checking one of them,
        b) adding `__init__.py` somewhere,
        c) using `--explicit-package-bases` or adjusting MYPYPATH
</t>
<t tx="ekr.20230716154607.1">https://github.com/leo-editor/leo-editor/issues/3005
PR: https://github.com/leo-editor/leo-editor/pull/3441

*** remove .js files.
</t>
<t tx="ekr.20230716182220.1">https://github.com/leo-editor/leo-editor/pull/3444</t>
<t tx="ekr.20230717040958.1">Overview

- Do all release work in `6.7.4` or `gh-pages`.

About merges:
- Do *not* merge devel into 6.7.4.
- Merge bug fix branches into `devel` and `6.7.4`
- Merge `6.7.4` into `devel` any time.

@language rest
</t>
<t tx="ekr.20230717040958.10" __bookmarks="7d7100580700000069735f6475706571014930300a732e">- git checkout master
- full-test-leo
</t>
<t tx="ekr.20230717040958.11" __bookmarks="7d7100580700000069735f6475706571014930300a732e">Create a git tag **last**

git checkout master
git tag -a v6.7.2 -m "Added v6.7.2 tag"
git push --follow-tags
</t>
<t tx="ekr.20230717040958.12" __bookmarks="7d7100580700000069735f6475706571014930300a732e">Update the *GitHub* release at https://github.com/leo-editor/leo-editor/releases

This must be done *soon* after the release's actual commit.
There is a "Draft New Release" button at the top-right of the page.
</t>
<t tx="ekr.20230717040958.13">**build**

- git checkout master
- Delete files in leoeditor/dist
- python -m build

**upload**

- ***Disable VPN***

python -m twine upload -r pypi dist/*

username:  __token__
password:  EKR: Copy contents of leo_pypi_token.txt
           Then paste using "Paste" from console Edit menu.
           
File names must be unique.
If there are conflicting names, add -NNN to the filename, like this:
    leo-6.7.4-2-py3-none-any.whl
    leo-6.7.4-2.tar.gz

**install**

- Remove leo-editor from sitecustomize.py if it exists.

python -m pip install --index-url https://pypi.org/simple/ --no-deps leo==6.7.4

**test**

cd ~  # Anywhere except leo-editor folder!
python -m leo.core.runLeo

**uninstall after testing**

python -m pip uninstall leo
</t>
<t tx="ekr.20230717040958.14" __bookmarks="7d7100580700000069735f6475706571014930300a732e">- git checkout devel
- git merge 6.7.4
- update version in leoVersion.py.

Create a branch for the *new* version:

git tag -a v6.7.5-devel -m "Added v6.7.5-devel tag"
git push --follow-tags
</t>
<t tx="ekr.20230717040958.15">- Change 6.7.4 (the old version) to 6.7.5.
  Be careful about the new version in the `Update version in devel` item.
</t>
<t tx="ekr.20230717040958.16" __bookmarks="7d7100580700000069735f6475706571014930300a732e">- Announce to leo-editor first.

Public announcements, after creating a package.

- Announce to SourceForge:  http://sourceforge.net/projects/leo/
   **Markdown accepted, so paste release notes in LeoDocs.leo.**.

- Announce to Python-announce-list using email:
   python-announce-list@python.org
   **Paste source-forge or leo-editor announcement**.

  - Check it by visiting the archive:
    https://mail.python.org/archives/list/python-announce-list@python.org/
  
- My blog: http://edreamleo.blogspot.com/
  **Paste GitHub announcement**.
</t>
<t tx="ekr.20230717040958.2" __bookmarks="7d7100580700000069735f6475706571014930300a732e">- (Done) Make sure Leo looks good without myLeoSettings.leo.

- (Done) Make sure Leo runs with Python 3.9.

- (Done) Run the full-test-leo script. See #2867:
  https://github.com/leo-editor/leo-editor/issues/2867
</t>
<t tx="ekr.20230717040958.3">- (Done) Run all "check" buttons in leoSettings.leo.
</t>
<t tx="ekr.20230717040958.4">Do *not* use the (disabled) write-LeoPyRef button in LeoPy.leo. It is buggy.

- Create LeoPyRef.leo by copying leoPy.leo to it, then deleting unwanted nodes.
- Open LeoPyRef.leo. Verify the diff after saving.
</t>
<t tx="ekr.20230717040958.5" __bookmarks="7d7100580700000069735f6475706571014930300a732e">- (Done) Make sure copyright dates are correct.
- (Done) Update the version numbers in index.html and conf.py:
  Search for 6.7.
- (Done) Update the release notes. *Make sure to update links*.
- (Done) Create new "what's new" section.
- (Done) Remove top-level clones.
- (Done) Spell check entire file, starting at the "Web pages" node.
- (Done) Copy release notes to leoDist.leo.
- (Done) Copy release notes to LeoReleaseNotes.leo

</t>
<t tx="ekr.20230717040958.6">LeoDist.leo:
- (Done) Make sure copyright dates are correct.
- (Done) Update version numbers. Search for ##version
  The final version in PKG-INFO.TXT must be called 6.7.4, not 6.7.4-final.
  See Pep 440: https://www.python.org/dev/peps/pep-0440/
- (Done) Update readme.md.
- (Done) Update version in 'PKG-INFO.TXT'
- (Done) Check readme.md spelling.
- (Done) Make sure no distributed .leo file contains xml-stylesheet elements.
  Run @button check .leo files in leo-dist.leo.
</t>
<t tx="ekr.20230717040958.7" __bookmarks="7d7100580700000069735f6475706571014930300a732e">- (done) git checkout `gh-pages`.
- (done) git merge 6.7.4
- (done) Run the `make-sphinx` from LeoDocs.leo
  This script copies files from leo/doc/html/_build/html to leo-editor/docs
- (done) Commit the changes and push.
- (done) Check the GitHub Pages actions page:
  https://github.com/leo-editor/leo-editor/actions
- (done) Check Leo's website.
</t>
<t tx="ekr.20230717040958.8" __bookmarks="7d7100580700000069735f6475706571014930300a732e">leoVersion.py:
- Update version constant.
- Update static date.
- Update date of the release, in &lt;&lt; version dates &gt;&gt; section.
</t>
<t tx="ekr.20230717040958.9" __bookmarks="7d7100580700000069735f6475706571014930300a732e">From 6.7.4 branch:

- git merge master
- Fix any conflicts and push.
- git checkout master
- git merge 6.7.4</t>
<t tx="ekr.20230717145150.1">@language rest

https://chat.openai.com/share/664302e5-575e-4f71-aa24-3b2078bb3ce7

Commander's intention

https://chat.openai.com/c/8df4c9fc-e575-427f-9cc3-b6ede0a0cb1c</t>
<t tx="ekr.20230717151112.1">@language rest

Thank you for providing the example Python file created by Leo. Based on
the information you provided, it seems like you want to extract the outline
structure and the Global Node Index (GNX) from the file.

To recreate the entire change log for one or more Python files and extract
the GNX information, you can utilize Git commands along with some
scripting. Here's a general approach you can follow:

1. Initialize a Git repository: Start by initializing a Git repository in
   the directory containing the Python files you want to track. Open a
   terminal or command prompt, navigate to the directory, and run the
   command `git init`.

2. Stage the Python files: Add the Python files to the Git repository by
   running the command `git add &lt;file_name&gt;` for each file. This stages the
   files for commit.

3. Commit the initial version: Commit the staged files using the command
   `git commit -m "Initial commit"`. This creates an initial version in the
   Git history.

4. Iterate over the Git history: Use the command `git log --reverse
   --name-only` to iterate over the Git commit history in reverse order,
   listing only the file names that were changed in each commit.

5. Extract the GNX information: Write a script in your preferred language
   (e.g., Python) to parse the file contents and extract the GNX
   information. You can use regular expressions or string manipulation
   techniques to extract the GNX values from the lines starting with
   "#@+node:".

6. Generate the change log: As you iterate over the Git history, for each
   commit, extract the file content and use your script to extract the GNX
   information. Store this information along with the commit message,
   author, and timestamp. This will generate the change log with the GNX
   details for each file.

Please note that the implementation details may vary depending on your
specific requirements and the programming language you choose to extract
the GNX information.

Remember to consult the Git documentation and the scripting language you
decide to use for further details on the commands and techniques mentioned
above.

I hope this provides you with a starting point for creating the series of
Git commands and extracting the desired information from the Python files.
If you have any further questions, feel free to ask!</t>
<t tx="ekr.20230717151135.1">@language rest

Here it is:  The lines that start with "#@+" are Leo's sentinel comments. These comments denote outline structure. Nodes that start with "#@+node" denote the start of a node. Nodes continue until the next line that starts with "#@+node". The gnx field has the form ":id.timestamp:" In the node below, the gnx field is ":ekr.20090717092906.12765:" and the gnx itself is everything between the outer colons, that is, "ekr.20090717092906.12765"

Here is the actual file:

@language python

#@+leo-ver=5-thin
#@+node:ekr.20090717092906.12765: * @file leoVersion.py
"""
A module holding the version-related info
"""
#@+&lt;&lt; version dates &gt;&gt;
#@+node:ekr.20141117073519.12: ** &lt;&lt; version dates &gt;&gt;
#@@nocolor-node
#@+at
</t>
<t tx="ekr.20230717210524.1"></t>
<t tx="ekr.20230717220528.1"></t>
<t tx="ekr.20230718063545.1">PR: https://github.com/leo-editor/leo-editor/pull/3445</t>
<t tx="ekr.20230718075224.1"></t>
<t tx="ekr.20230718093415.1"></t>
<t tx="ekr.20230718190545.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3446
closed PR: https://github.com/leo-editor/leo-editor/pull/3449
Unified PR:  https://github.com/leo-editor/leo-editor/pull/3455

@language python
</t>
<t tx="ekr.20230719122859.1">def _get_diff_list(self,
    contents_list: list[list[str]],  # List of lines for each file.
    gnxs: list[str],
    path: str,
    revs_list: list[str],
) -&gt; list[g.Bunch]:
    """Return a list of Bunches describing the nodes to be diffed."""

    assert len(contents_list) == len(revs_list)

    # Compile the patterns once.
    node_patterns = [
        (gnx, re.compile(fr'^\s*#@\+node:({gnx}):')) for gnx in gnxs
    ]

    # Create the list of g.Bunches.
    node_data_list = []
    for i in range(len(contents_list)):
        bunch = self._get_action(i, path, contents_list, node_patterns, revs_list)
        if bunch:
            node_data_list.append(bunch)
    return node_data_list
</t>
<t tx="ekr.20230719161306.1">def _get_action(self,
    i: int,  # The index into contents_list and revs_list
    path: str,
    contents_list: list[list[str]],  # Lines for each contents.
    node_patterns: list[tuple[str, re.Pattern]],  # Patterns matching @+node sentinels for each gnx.
    revs_list: list[str]
) -&gt; Optional[g.Bunch]:
    """
    Return a g.Bunch describing the action to be taken at rev i.
    """
    assert len(contents_list) == len(revs_list)
    if i + 1 &gt;= len(revs_list):
        return None  # Can't diff past this rev.

    # Step 1: Find all nodes matching one of the gnx's in contents[i], contents[i+1]
    nodes: list[list[tuple]] = [
        [],  # Tuples describing nodes in rev i.
        [],  # Tuples describing nodes in rev i + 1
    ]
    for index in (0, 1):
        rev_i = i + index
        for gnx, pattern in node_patterns:
            node_info = self._find_node(contents_list[rev_i], pattern, gnx, revs_list[rev_i])
            if node_info:
                nodes[index].append((rev_i, gnx, node_info))

    # Quick test: are both sets of lines the same?
    if not nodes[0] and not nodes[1]:
        skip_flag = True
    elif nodes[0] and nodes[1]:
        range0 = nodes[0][0][2]
        range1 = nodes[1][0][2]
        contents0 = contents_list[i]
        contents1 = contents_list[i + 1]
        body0 = contents0[range0[0]:range0[1]]
        body1 = contents1[range1[0]:range1[1]]
        skip_flag = body0 == body1
    else:
        skip_flag = False

    # Return if there is nothing to diff.
    if skip_flag:
        return None

    # Step 2: Create the g.Bunch
    kind = 'add' if not nodes[0] else 'delete' if not nodes[1] else 'diff'
    nodes0, nodes1 = nodes[0], nodes[1]
    if nodes0:
        gnx0 = nodes0[0][1]
        range0 = nodes0[0][2]
        contents0 = contents_list[i]
        body0 = contents0[range0[0]:range0[1]]
    else:
        gnx0 = range0 = contents0 = body0 = None
    if nodes1:
        gnx1 = nodes1[0][1]
        range1 = nodes1[0][2]
        contents1 = contents_list[i + 1]
        body1 = contents1[range1[0]:range1[1]]
    else:
        gnx1 = range1 = contents1 = body1 = None
    return g.Bunch(
        i=i, kind=kind,
        gnx0=gnx0, gnx1=gnx1,
        rev0=revs_list[i], rev1=revs_list[i + 1],
        body0=body0, body1=body1,
        # Optional debugging info.
        nodes0=nodes0, contents0=contents0, range0=range0,
        nodes1=nodes1, contents1=contents1, range1=range1,
    )
</t>
<t tx="ekr.20230719170046.1">node_ending_patterns = (
    re.compile(r'^\s*#@\+node:(.*?):'),  # A start node sentinel.
    re.compile(r'^\s*#@\-others'),  # A -others sentinel
    re.compile(r'^\s*#@\-leo'),  # A -leo sentinel.
)

def _find_node(self,
    contents: list[str],  # The list of lines.
    pattern: re.Pattern,
    # For debugging only.
    gnx: str,  # gnx being matched.
    rev: str,  # Full hash.
    ) -&gt; Optional[tuple[int, int]]:
    """
    Return (i1, i2) the range of lines of the node, or None.
    i1: The index of the line matching pattern.
    i2: The index of the line ending the node.


    The lines start at the first line matching the pattern.

    The lines end at the first line matching one of the ending patterns.
    """
    for i, line in enumerate(contents):
        if pattern.match(line):
            break
    else:
        return None
    i1 = i
    i += 1
    while i &lt; len(contents):
        line = contents[i]
        i += 1
        if any(z.match(line) for z in self.node_ending_patterns):
            # g.printObj(contents[i1:i], tag=f"Found {rev[:7]} {gnx} {i1}:{i}")
            return (i1, i - 1)
    return None
</t>
<t tx="ekr.20230720085122.1">def _trace_diff_list(self, diff_list: list[g.Bunch]) -&gt; None:
    """Trace the diff_list."""
    if 1:  # Brief.
        for z in diff_list:
            body_n0 = 'None' if z.body0 is None else len(z.body0)
            body_n1 = 'None' if z.body1 is None else len(z.body1)
            print(
                f"{z.i:&gt;4} {z.kind:&gt;7} {z.rev0[:7]} {z.rev1[:7]} "
                # f"len(contents0/1: {n0} {n1} range0/1: {z.range0} {z.range1}")
                f"len(body0/1): {body_n0} {body_n1}")
    elif 0:  # Too verbose.
        g.printObj(diff_list, tag='diff_list')
    else:  # Verbose.
        for bunch in diff_list:
            result = []
            for key in ('i', 'kind', 'rev0', 'rev1', 'body0', 'body1', 'range0', 'range1'):
                val = bunch.get(key)
                if val is None:
                    continue
                if key == 'i':
                    pad_s = ' ' * max(0, 4 - len(str(val)))
                    result.append(f"{key}:{pad_s} {val}")
                elif key == 'kind':
                    result.append(f"{key}: {val:&lt;6}")
                elif key.startswith(('body', 'contents')):
                    result.append(f"{key}: {len(val):&lt;3}")
                elif key.startswith('rev'):
                    result.append(f"{key}: {val[:7]}")
                else:
                    result.append(f"{key}: {val}")
            print(' '.join(result))
</t>
<t tx="ekr.20230720085415.1">def _generate_nodes(self, diff_list: list[g.Bunch], revs_list: list[str]) -&gt; None:
    """
    Generate all diff nodes from diff_list, a list of g.Bunches returned from _get_action.
    """
    # self._trace_diff_list(diff_list)
    for b in diff_list:
        # self._trace_kind(b, revs_list)
        p = self.root.insertAsLastChild()
        gnx0_s = b.gnx0 or ''
        gnx1_s = b.gnx1 or ''
        gnxs_s = gnx0_s if b.gnx0 == b.gnx1 else f"{gnx0_s} {gnx1_s}"
        p.h = f"{b.i:&gt;4} {b.kind}"  # {gnx0_s} {gnx1_s}"
        if b.kind == 'diff':
            diff = list(difflib.unified_diff(b.body0 or [], b.body1 or [], b.rev0, b.rev1))
            p.b = f"diff {gnxs_s}\n\n{''.join(diff)}"
            child1 = p.insertAsLastChild()
            child1.h = 'old'
            child1.b = ''.join(b.body0 or [])
            child2 = p.insertAsLastChild()
            child2.h = 'new'
            child2.b = ''.join(b.body1 or [])
        elif b.kind == 'add':
            p.b = f"add {gnxs_s}\n\n{''.join(b.body1 or [])}"
        elif b.kind == 'delete':
            p.b = f"delete {gnxs_s}\n\n{''.join(b.body0 or [])}"
        else:
            g.trace(f"Bad b.kind: {b.kind!r}")
</t>
<t tx="ekr.20230720091027.1">def _trace_kind(self, b: g.Bunch, revs_list: list[str]) -&gt; None:
    tag = f"{b.i:&gt;4}: {b.rev0[:7]} {b.rev1[:7]}"
    if b.kind == 'add':
        print(f"{tag}:    add len(body1):   {len(b.body1)}")
    elif b.kind == 'delete':
        print(f"{tag}: delete len(body0):   {len(b.body0)}")
    elif b.kind == 'diff':
        # pad_s = ' ' * (9 + len(tag))
        print(f"{tag}:   diff len(body0/2): {len(b.body0)} {len(b.nodes1)}")
    else:
        g.trace('Unknown kind', repr(b.kind))
</t>
<t tx="ekr.20230720114553.1"></t>
<t tx="ekr.20230720115916.1">g.cls()
import leo.commands.editFileCommands as efc

x = efc.GitDiffController(c=c)
path = g.os_path_finalize_join(g.app.loadDir, 'leoGlobals.py')
gnxs = (
    'ekr.20230626064652.1',  # EKR's replacement gnx
    'tbrown.20140311095634.15188',  # Terry's original node.
)
x.node_history(path, gnxs, limit=60)
</t>
<t tx="ekr.20230720120523.1"></t>
<t tx="ekr.20230720165209.1">@ignore
@nosearch

# gnxs: ekr.20230626064652.1, tbrown.20140311095634.15188
# limit: 60</t>
<t tx="ekr.20230720165209.10">#@+node:ekr.20230626064652.1: *3* g.findUnl &amp; helpers (legacy unls)
def findUnl(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUnl: support for legacy UNLs.
    This method must remain for compatibily with plugins.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.11">diff ekr.20230626064652.1

--- 93280e5578ea7765127f12e1c8d5d72c5720f1fd
+++ a9ffdd475e917aa8b82650c4279717bb145102fd
@@ -1,7 +1,7 @@
-#@+node:ekr.20230626064652.1: *3* g.findUnl &amp; helpers (legacy unls)
-def findUnl(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
+#@+node:ekr.20230626064652.1: *3* g.findUNL &amp; helpers (legacy unls)
+def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
     """
-    g.findUnl: support for legacy UNLs.
+    g.findUNL: support for legacy UNLs.
     This method must remain for compatibily with plugins.
 
     Find and move to the unl given by the unlList in the commander c.
</t>
<t tx="ekr.20230720165209.12">#@+node:ekr.20230626064652.1: *3* g.findUnl &amp; helpers (legacy unls)
def findUnl(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUnl: support for legacy UNLs.
    This method must remain for compatibily with plugins.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.13">#@+node:ekr.20230626064652.1: *3* g.findUNL &amp; helpers (legacy unls)
def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUNL: support for legacy UNLs.
    This method must remain for compatibily with plugins.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.14">diff ekr.20230626064652.1

--- 7a1a47abce3cf5600ccb6924d2ab0df5319310cf
+++ 4e7181399845bdf1d067a2dd1cf73e47523f5732
@@ -1,4 +1,4 @@
-#@+node:ekr.20230626064652.1: *3* g.findUNL &amp; helpers (legacy unls)
+#@+node:ekr.20230626064652.1: *3* g.findUNL &amp; helpers
 def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
     """
     g.findUNL: support for legacy UNLs.
</t>
<t tx="ekr.20230720165209.15">#@+node:ekr.20230626064652.1: *3* g.findUNL &amp; helpers (legacy unls)
def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUNL: support for legacy UNLs.
    This method must remain for compatibily with plugins.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.16">#@+node:ekr.20230626064652.1: *3* g.findUNL &amp; helpers
def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUNL: support for legacy UNLs.
    This method must remain for compatibily with plugins.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.17">delete ekr.20230626064652.1 

#@+node:ekr.20230626064652.1: *3* g.findUNL &amp; helpers
def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUNL: support for legacy UNLs.
    This method must remain for compatibily with plugins.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.18">add  tbrown.20140311095634.15188

#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helper (deprecated)
def findUNL(unlList: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUNL: deprectated. Use g.findGNX instead.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the format of the file-oriented unl &lt;file name&gt;::&lt;line-number&gt;
    file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.19">diff tbrown.20140311095634.15188

--- 80184cad12b62865d2261dc1b974af283b452264
+++ f65769a5d8992e6ab1ff58ae0b56ae36761cc704
@@ -1,8 +1,6 @@
-#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helper (deprecated)
+#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helpers
 def findUNL(unlList: list[str], c: Cmdr) -&gt; Optional[Position]:
     """
-    g.findUNL: deprectated. Use g.findGNX instead.
-
     Find and move to the unl given by the unlList in the commander c.
     Return the found position, or None.
     """
</t>
<t tx="ekr.20230720165209.2">diff tbrown.20140311095634.15188 ekr.20230626064652.1

--- 01272f90f3ec2c05452ad9ff425fde57acdf76d5
+++ 955386fc090f36eeb806a032979a2370132d2983
@@ -1,4 +1,4 @@
-#@+node:tbrown.20140311095634.15188: *3* g.findUnl &amp; helpers (legacy unls)
+#@+node:ekr.20230626064652.1: *3* g.findUnl &amp; helpers (legacy unls)
 def findUnl(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
     """
     g.findUnl: support for legacy UNLs.
</t>
<t tx="ekr.20230720165209.20">#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helper (deprecated)
def findUNL(unlList: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUNL: deprectated. Use g.findGNX instead.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the format of the file-oriented unl &lt;file name&gt;::&lt;line-number&gt;
    file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.21">#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helpers
def findUNL(unlList: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the format of the file-oriented unl &lt;file name&gt;::&lt;line-number&gt;
    file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.22">diff tbrown.20140311095634.15188

--- 5dfc45e9f1f778fe3e7750dd8549e78c45de2967
+++ e55c05032ffc8f70351a1951e5bb15a456c441d0
@@ -1,10 +1,11 @@
 #@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helpers
-def findUNL(unlList: list[str], c: Cmdr) -&gt; Optional[Position]:
+def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
     """
     Find and move to the unl given by the unlList in the commander c.
     Return the found position, or None.
     """
-    # Define the format of the file-oriented unl &lt;file name&gt;::&lt;line-number&gt;
+    # Define the unl patterns.
+    parts_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
     file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.
 
     #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.23">#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helpers
def findUNL(unlList: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the format of the file-oriented unl &lt;file name&gt;::&lt;line-number&gt;
    file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.24">#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helpers
def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    parts_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.25">diff tbrown.20140311095634.15188

--- e55c05032ffc8f70351a1951e5bb15a456c441d0
+++ 1577aa1aacdbed7fa047a8f6fde9a94048f9dc5a
@@ -7,5 +7,7 @@
     # Define the unl patterns.
     parts_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
     file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.
+    
+    g.printObj(unlList1, tag='findUNL')
 
     #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.26">#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helpers
def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    parts_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.27">#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helpers
def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    parts_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.
    
    g.printObj(unlList1, tag='findUNL')

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.28">diff tbrown.20140311095634.15188

--- 1577aa1aacdbed7fa047a8f6fde9a94048f9dc5a
+++ 3264deb1ff5c9a506ccce9f9ef849d54a684ae55
@@ -7,7 +7,5 @@
     # Define the unl patterns.
     parts_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
     file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.
-    
-    g.printObj(unlList1, tag='findUNL')
 
     #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.29">#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helpers
def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    parts_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.
    
    g.printObj(unlList1, tag='findUNL')

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.3">#@+node:tbrown.20140311095634.15188: *3* g.findUnl &amp; helpers (legacy unls)
def findUnl(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUnl: support for legacy UNLs.
    unlList is a list of headlines.

    This method must remain for compatibility with plugins.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define two *optional* unl patterns.

    # old_pat: ':' followed by a list of node indices.
    #          Deprecated and probably does not work.
    #          This pattern will remain for compatibility.
    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')

    # new_pat: '::' followed by a line number.
    #          Negative line numbers denote global line numbers.
    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.30">#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helpers
def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    parts_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.31">diff tbrown.20140311095634.15188

--- f6629757af95220dc4ce95fbee0aee009da3a3ac
+++ 61e8d6fc07059310db6c38fe5bc03aee8db39e0d
@@ -7,5 +7,5 @@
     # Define the unl patterns.
     parts_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
     file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.
-
+    
     #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.32">#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helpers
def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    parts_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.33">#@+node:tbrown.20140311095634.15188: *3* g.findUNL &amp; helpers
def findUNL(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    parts_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    file_pat = re.compile(r'^(.*?)::([-\d]+)?$')  # '::' is the separator.
    
    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.4">#@+node:ekr.20230626064652.1: *3* g.findUnl &amp; helpers (legacy unls)
def findUnl(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUnl: support for legacy UNLs.
    unlList is a list of headlines.

    This method must remain for compatibility with plugins.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define two *optional* unl patterns.

    # old_pat: ':' followed by a list of node indices.
    #          Deprecated and probably does not work.
    #          This pattern will remain for compatibility.
    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')

    # new_pat: '::' followed by a line number.
    #          Negative line numbers denote global line numbers.
    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.5">diff ekr.20230626064652.1

--- 722a935a57f1e78086064821e5702e55c2344aa2
+++ e28dc56cf19af25d2adc08b79d9ae995cbf96d27
@@ -9,15 +9,8 @@
     Find and move to the unl given by the unlList in the commander c.
     Return the found position, or None.
     """
-    # Define two *optional* unl patterns.
-
-    # old_pat: ':' followed by a list of node indices.
-    #          Deprecated and probably does not work.
-    #          This pattern will remain for compatibility.
-    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')
-
-    # new_pat: '::' followed by a line number.
-    #          Negative line numbers denote global line numbers.
-    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')
+    # Define the unl patterns.
+    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
+    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')  # '::' is the separator.
 
     #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.6">#@+node:ekr.20230626064652.1: *3* g.findUnl &amp; helpers (legacy unls)
def findUnl(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUnl: support for legacy UNLs.
    unlList is a list of headlines.

    This method must remain for compatibility with plugins.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define two *optional* unl patterns.

    # old_pat: ':' followed by a list of node indices.
    #          Deprecated and probably does not work.
    #          This pattern will remain for compatibility.
    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')

    # new_pat: '::' followed by a line number.
    #          Negative line numbers denote global line numbers.
    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.7">#@+node:ekr.20230626064652.1: *3* g.findUnl &amp; helpers (legacy unls)
def findUnl(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUnl: support for legacy UNLs.
    unlList is a list of headlines.

    This method must remain for compatibility with plugins.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720165209.8">diff ekr.20230626064652.1

--- db2d07dd35ba1ae7a99d409b72a6e4dd795ae8b1
+++ 9d1e40847b8fa8342e75e2509dc47bca79b38bc5
@@ -2,9 +2,7 @@
 def findUnl(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
     """
     g.findUnl: support for legacy UNLs.
-    unlList is a list of headlines.
-
-    This method must remain for compatibility with plugins.
+    This method must remain for compatibily with plugins.
 
     Find and move to the unl given by the unlList in the commander c.
     Return the found position, or None.
</t>
<t tx="ekr.20230720165209.9">#@+node:ekr.20230626064652.1: *3* g.findUnl &amp; helpers (legacy unls)
def findUnl(unlList1: list[str], c: Cmdr) -&gt; Optional[Position]:
    """
    g.findUnl: support for legacy UNLs.
    unlList is a list of headlines.

    This method must remain for compatibility with plugins.

    Find and move to the unl given by the unlList in the commander c.
    Return the found position, or None.
    """
    # Define the unl patterns.
    old_pat = re.compile(r'^(.*):(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')  # ':' is the separator.
    new_pat = re.compile(r'^(.*?)(::)([-\d]+)?$')  # '::' is the separator.

    #@+others  # Define helper functions
</t>
<t tx="ekr.20230720210931.1">def dump_clone_info(self, c: Cmdr, tag: str = None) -&gt; None:
    """Dump all clone info."""
    print('')
    g.trace(f"{tag or ''} {c.fileName()}")
    print('')
    for p in c.all_positions():
        head_s = f"{' '*p.level()}{p.h}"
        print(
            f"clone? {int(p.isCloned())} id(v): {id(p.v)} gnx: {p.gnx:30}: "
            f"{head_s:&lt;10} parents: {p.v.parents}"
        )
</t>
<t tx="ekr.20230721130054.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3452
PR (closed): https://github.com/leo-editor/leo-editor/pull/3454
Unified PR:  https://github.com/leo-editor/leo-editor/pull/3455

@language python
</t>
<t tx="ekr.20230721130238.1">def afterChangeTree(self, command: str, bunch: g.Bunch) -&gt; None:

    c = self.c
    p = self.p
    u = self
    w = c.frame.body.wrapper
    # Set types.
    bunch.kind = command
    bunch.undoType = command
    bunch.undoHelper = u.undoChangeTree
    bunch.redoHelper = u.redoChangeTree
    bunch.newPastedTree = c.fileCommands.outline_to_clipboard_string(c.p)
    bunch.newIns = w.getInsertPoint()
    bunch.newSel = w.getSelectionRange()
    bunch.newMarked = p.isMarked()
    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
    # Recalculate the menu labels.
    u.setUndoTypes()
</t>
<t tx="ekr.20230721130319.1">def beforeChangeTree(self, p: Position) -&gt; None:

    c = self.c
    w = self.c.frame.body.wrapper
    bunch = self.createCommonBunch(p)  # Sets u.oldMarked, u.oldSel, u.p

    ###
    bunch.oldPastedTree = c.fileCommands.outline_to_clipboard_string(c.p)
    bunch.oldBody = p.b
    bunch.oldHead = p.h
    bunch.oldIns = w.getInsertPoint()
    bunch.oldYScroll = w.getYScrollPosition()
    return bunch
</t>
<t tx="ekr.20230721131446.1">def undoChangeTree(self) -&gt; None:
    """
    Undo all changes to the node and its subtree.
    """
    c = self.c
    u = self
    w = c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:
        c.selectPosition(u.p)
    assert c.p == u.p
    p = u.p
    # u.p.setDirty()

    # Paste the outline and select it.
    s = u.oldPastedTree
    pasted = c.fileCommands.getLeoOutlineFromClipboardRetainingClones(s)
    assert c.p == pasted

    # Delete the old tree. Its position should still exist.
    c.p.back.doDelete(pasted)

    # Finish
    w.setAllText(u.oldBody)
    c.frame.body.recolor(p)
    p.h = u.oldHead
    # This is required.  Otherwise c.redraw will revert the change!
    c.frame.tree.setHeadline(p, u.oldHead)
    i, j = u.oldSel
    w.setSelectionRange(i, j)
    w.setYScrollPosition(u.oldYScroll)
    u.updateMarks('old')
</t>
<t tx="ekr.20230721131611.1">def redoChangeTree(self) -&gt; None:
    c, u, w = self.c, self, self.c.frame.body.wrapper
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:
        c.selectPosition(u.p)
    ### s = u.newPastedTree



    u.p.setDirty()
    u.p.b = u.newBody
    u.p.h = u.newHead
    # This is required so. Otherwise redraw will revert the change!
    c.frame.tree.setHeadline(u.p, u.newHead)
    if u.newMarked:
        u.p.setMarked()
    else:
        u.p.clearMarked()
    if u.groupCount == 0:
        w.setAllText(u.newBody)
        i, j = u.newSel
        w.setSelectionRange(i, j, insert=u.newIns)
        w.setYScrollPosition(u.newYScroll)
        c.frame.body.recolor(u.p)
    u.updateMarks('new')
    u.p.setDirty()
</t>
<t tx="ekr.20230722062645.1">def restoreFromCopiedTree(self, v: VNode, s: str) -&gt; None:
    &lt;&lt; docstring: restoreFromCopiedTree &gt;&gt;
    c, u = self.c, self
    fc = c.fileCommands
    if not isinstance(v, VNode):
        g.trace("Can't happen: not a vnode: {v!r}")
        return
    old_parents = v.parents[:]  # Essential.

    # This encoding must match the encoding used in outline_to_clipboard_string.
    encoding = fc.leo_file_encoding

    # Create a tree of vnodes from s.
    x = FastRead(c, fc.gnxDict)  # Must use fc.gnxDict.
    fc.initReadIvars()
    s_bytes = g.toEncodedString(s, encoding, reportErrors=True)
    hidden_v = x.readFileFromClipboard(s_bytes)
    fc.initReadIvars()
    if not hidden_v:
        u.clearAndWarn('undo-change-tree')
        return

    # The big switcharoo: change v in place.
    new_v = hidden_v.children[0]
    new_v.parents = old_parents  # restore v.parents.
    assert v.gnx == new_v.gnx
    v = new_v  ### Experimental.

    # All pasted nodes should have unique gnx's.
    ni = g.app.nodeIndices
    for v in c.all_unique_nodes():
        ni.check_gnx(c, v.fileIndex, v)
</t>
<t tx="ekr.20230722062838.1">"""
c.restoreFromCopiedTree: restore v from a copied tree.

This is a low-level method. See u.undo/redoChangeTree for examples.

The caller is responsible for:

- Calling c.endEditing.
- Setting c.p correctly.
- Updating selection range and y-scroll position in c.frame.body.wrapper.
- Calling c.redraw.
"""
</t>
<t tx="ekr.20230722083123.1">def test_restoreFromCopiedTree(self):

    c = self.c
    u = c.undoer

    @others  # Define helper functions.

    # Create the tree.
    self.clean_tree()
    cc = self.create_test_paste_outline()

    # No need to select cc. We use only vnodes.
    # c.selectPosition(cc)

    # Create the gnx_dict.
    vnodes = list(set(list(c.all_nodes())))
    gnx_dict = {z.h: z.gnx for z in vnodes}

    # s1: before inserting cc:child3.
    s1 = c.fileCommands.outline_to_clipboard_string(cc)
    assert s1

    # Insert cc:child3.
    cc_child3 = cc.insertAsLastChild()
    cc_child3.h = 'cc:child3'
    gnx_dict[cc_child3.h] = cc_child3.gnx

    self.assertFalse(c.checkOutline())
    test_tree(tag='1: before inserting cc:child3')

    s2 = c.fileCommands.outline_to_clipboard_string(cc)
    assert s2

    self.assertFalse(c.checkOutline())
    test_tree(tag='2: after inserting cc:child3')

     # Get back to the starting point.
    for (v, s, tag) in (
        (cc.v, s2, '2: undo'),
    ):
        u.restoreFromCopiedTree(v, s)
        self.assertFalse(c.checkOutline())
        test_tree(tag=tag)

    # Check multiple do/redo cycles.
    for i in range(3):
        for (v, s, tag) in (
            (cc.v, s1, f"1: redo{i}"),
            (cc.v, s2, f"2: undo{i}"),
        ):
            u.restoreFromCopiedTree(v, s)
            self.assertFalse(c.checkOutline())
            test_tree(tag=tag)
</t>
<t tx="ekr.20230722093357.1"></t>
<t tx="ekr.20230722101720.1">@language rest
@nosearch

Unified PR: https://github.com/leo-editor/leo-editor/pull/3455

#3453: (Invalid) fc.getLeoOutlineFromClipBoardRetainingClones assumes c.p is a top-level node.
https://github.com/leo-editor/leo-editor/issues/3453

PR #3449: paste-retaining clones.
https://github.com/leo-editor/leo-editor/pull/3449

PR #3454: undo/redo change tree.
https://github.com/leo-editor/leo-editor/pull/3454

@language python
</t>
<t tx="ekr.20230722104048.1"></t>
<t tx="ekr.20230722104508.1">def test_paste_retaining_clones(self):

    c = self.c
    p = c.p
    u = c.undoer

    @others  # Define test_tree function.

    # Every paste will invalidate positions, so search for headlines instead.
    valid_target_headlines = (
        'root', 'aa', 'aa:child1', 'bb', 'dd', 'dd:child1', 'dd:child1:child1', 'dd:child2', 'ee',
    )
    for target_headline in valid_target_headlines:
        for test_kind, is_json in (
            ('cut', True), ('cut', False), ('copy', True), ('copy', False),
        ):

            # print(f"TEST {test_kind} {target_headline}")

            # Create the tree and gnx_dict.
            self.clean_tree()
            cc = self.create_test_paste_outline()
            # Calculate vnodes and gnx_dict for test_node, before any changes.
            vnodes = list(set(list(c.all_nodes())))
            gnx_dict = {z.h: z.gnx for z in vnodes}
            self.assertEqual(0, c.checkOutline())

            # Change the body text of cc and cc:child1, the two cloned nodes.
            cc.b = 'cc body: changed'
            cc_child1 = cc.firstChild()
            assert cc_child1.h == 'cc:child1', repr(cc_child1.h)
            cc_child1.b = 'cc:child1 body: changed'

            # Cut or copy cc.
            if test_kind == 'cut':
                # Delete cc *without* undo.
                c.selectPosition(cc)
                self.copy_node(is_json)
                back = cc.threadBack()
                assert back
                cc.doDelete()
                c.selectPosition(back)
            else:
                # *Copy*  node cc
                c.selectPosition(cc)
                self.copy_node(is_json)

                # Restore the empty bodies of cc and cc:child1 before the paste.
                cc.b = cc_child1.b = ''  # Copy does not change these positions.

            self.assertEqual(0, c.checkOutline())

            # Pretest: select all positions in the tree.
            for p in c.all_positions():
                c.selectPosition(p)

            # Find the target position by headline.
            target_p = g.findNodeAnywhere(c, target_headline)
            self.assertTrue(target_p, msg=target_headline)

            # Paste after the target.
            c.selectPosition(target_p)
            c.pasteOutlineRetainingClones()

            # Check the paste.
            self.assertEqual(0, c.checkOutline())
            test_tree(pasted_flag=True, tag='paste-retaining-clones')

            # Check multiple undo/redo cycles.
            for i in range(3):
                u.undo()
                self.assertEqual(0, c.checkOutline())
                test_tree(pasted_flag=False, tag=f"undo {i}")
                u.redo()
                self.assertEqual(0, c.checkOutline())
                test_tree(pasted_flag=True, tag=f"redo {i}")
</t>
<t tx="ekr.20230722192350.1">@nosearch</t>
<t tx="ekr.20230722194025.1"></t>
<t tx="ekr.20230723031540.1">def checkVnodeLinks(self) -&gt; int:
    """
    Check and repair all vnode links.
    Return the number of errors.
    """
    c = self

    @others # Define helpers.

    error_list, messages, n = find_errors()
    if n == 0:
        return 0
    print('\n'.join(messages))
    if 1:  # To be tested!
        fix_errors(error_list)
        undelete_nodes(error_list)
        error_list, messages, n = recheck()
        if n:
            print('\n'.join(messages))
    return n
</t>
<t tx="ekr.20230723044517.1"></t>
<t tx="ekr.20230723123619.1"></t>
<t tx="ekr.20230723160812.1">def test_tree(pasted_flag: bool, tag: str) -&gt; None:
    """Test the tree"""
    seen = set()
    if test_kind == 'cut':
        cloned_headlines = ('cc:child1',) if pasted_flag else ()
    else:
        cloned_headlines = ('cc:child1', 'cc') if pasted_flag else ('cc:child1',)
    try:
        tag_s = f"{tag} kind: {test_kind} pasted? {int(pasted_flag)}"
        for p in c.all_positions():
            seen.add(p.v)
            if p.h in cloned_headlines:
                assert p.isCloned(), f"{tag_s}: not cloned: {p.h}"
                assert p.b, f"{tag_s} {p.h}: unexpected empty body text: {p.b!r}"
            else:
                assert not p.isCloned(), f"{tag_s}: is cloned: {p.h}"
            message = f"{tag}: p.gnx: {p.gnx} != expected {gnx_dict.get(p.h)}"
            assert gnx_dict.get(p.h) == p.gnx, message

        # Test that all and *only* the expected nodes exist.
        if test_kind == 'copy' or tag.startswith(('redo', 'paste-')):
            for z in seen:
                assert z in vnodes, f"p.v not in vnodes: {z.gnx}, {z.h}"
            for z in vnodes:
                assert z in seen, f"vnode not seen: {z.gnx}, {z.h}"
        else:
            assert test_kind == 'cut' and tag.startswith('undo')
            # All seen nodes should exist in vnodes.
            for z in seen:
                assert z in vnodes, f"{z.h} not in vnodes"
            # All vnodes should be seen except cc and cc:child2.
            for z in vnodes:
                if z.h in ('cc', 'cc:child2'):
                    assert z not in seen, f"{z.h} in seen after undo"
                else:
                    assert z in seen, f"{z.h} not seen after undo"
    except Exception as e:
        message = f"clone_test failed! tag: {tag}: {e}"
        print(f"\n{message}\n")
        self.dump_clone_info(c)
        # g.printObj(gnx_dict, tag='gnx_dict')
        # g.printObj(vnodes, tag='vnodes')
        # g.printObj([f"{z.gnx:30} {' '*z.level()}{z.h:10} {z.b!r}" for z in c.all_positions()], tag='bodies')
        self.fail(message)  # This throws another exception!
</t>
<t tx="ekr.20230724064558.1">def test_paste_node(self):

    c = self.c
    p = c.p
    u = c.undoer

    @others  # Define test_tree function.

    self.clean_tree()
    cc = self.create_test_paste_outline()

    # All nodes except cc and its children itself are valid targets.
    valid_target_headlines = list(sorted(
        z.h for z in c.all_unique_positions() if z.h not in ('cc', 'cc:child1', 'cc:child2')
    ))
    # g.printObj(valid_target_headlines, tag='valid_target_headlines')
    for target_headline in valid_target_headlines:
        for test_kind, is_json in (
            ('cut', True), ('cut', False), ('copy', True), ('copy', False),
        ):

            # print('TEST', test_kind, target_headline)

            # Create the tree and gnx_dict.
            self.clean_tree()
            cc = self.create_test_paste_outline()
            # Calculate vnodes and gnx_dict for test_node, before any changes.
            vnodes = list(set(list(c.all_nodes())))
            gnx_dict = {z.h: z.gnx for z in vnodes}
            self.assertFalse(c.checkOutline())

            # Cut or copy cc.
            if test_kind == 'cut':
                # Delete cc *without* undo.
                c.selectPosition(cc)
                self.copy_node(is_json)
                back = cc.threadBack()
                assert back
                cc.doDelete()
                c.selectPosition(back)
            else:
                # *Copy*  node cc
                c.selectPosition(cc)
                self.copy_node(is_json)
            self.assertFalse(c.checkOutline())

            # Pretest: select all positions in the tree.
            for p in c.all_positions():
                c.selectPosition(p)

            # Find the target position by headline.
            target_p = g.findNodeAnywhere(c, target_headline)
            self.assertTrue(target_p, msg=target_headline)

            # Paste after the target.
            c.selectPosition(target_p)
            c.pasteOutline()

            # Check the paste.
            self.assertFalse(c.checkOutline())
            test_tree(pasted_flag=True, tag='paste-node')

            # Check multiple undo/redo cycles.
            for i in range(3):
                u.undo()
                self.assertFalse(c.checkOutline())
                test_tree(pasted_flag=False, tag=f"undo {i}")
                u.redo()
                self.assertFalse(c.checkOutline())
                test_tree(pasted_flag=True, tag=f"redo {i}")
</t>
<t tx="ekr.20230724064558.5">def test_tree(pasted_flag: bool, tag: str) -&gt; None:
    """Test the tree"""
    seen = set()
    # All tests cut/copy cc.
    cloned_headline = None if test_kind == 'cut' else 'cc:child1'
    try:
        tag_s = f"{tag} kind: {test_kind} pasted? {int(pasted_flag)}"
        for p in c.all_positions():
            seen.add(p.v)
            if p.h == cloned_headline and p.gnx in gnx_dict.values():
                assert p.isCloned(), f"{tag_s}: not cloned: {p.h}"
                assert p.gnx in gnx_dict.get(p.h), f"{tag_s}: not in gnx_dict: {p.h}"
            else:
                assert not p.isCloned(), f"{tag_s}: is cloned: {p.h}"
    except Exception as e:
        message = f"clone_test failed! tag: {tag}: {e}"
        print(f"\n{message}\n")
        self.dump_clone_info(c)
        # g.printObj(gnx_dict, tag='gnx_dict')
        # g.printObj(vnodes, tag='vnodes')
        self.fail(message)
</t>
<t tx="ekr.20230724084617.1"># f" {importers}",
# f" {core}.test_leoAst.TestTOG"
# f" {core}.test_leoApp.TestApp",
# f" {core}.test_leoCompare.TestCompare",
# f" {core}.test_leoGlobals.TestGlobals",
# f" {core}.test_leoImport.TestLeoImport",
# f" {core}.test_leoTest2.TestTest2",

# f" {commands}.test_editFileCommands",
# f" {commands}.test_commanderFileCommands",
# f" {commands}.test_editFileCommands.TestEditFileCommands.slow_test_gdc_node_history",

# f" {core}.test_leoGlobals.TestGlobals.test_g_parsePathData",</t>
<t tx="ekr.20230724092804.1">def updateBodies(self, gnx2body: dict[str, str], gnx2vnode: dict[str, VNode]) -&gt; None:
    """Update bodies to enforce the "pasted wins" policy."""
    for gnx in gnx2body:
        body = gnx2body[gnx]
        try:
            v = gnx2vnode[gnx]
            v.b = body
        except KeyError:
            pass
</t>
<t tx="ekr.20230724130924.1">def test_paste_as_template(self):

    c = self.c
    p = c.p
    u = c.undoer

    @others  # Define test_tree function.

    # Every paste will invalidate positions, so search for headlines instead.
    valid_target_headlines = (
        'root', 'aa', 'aa:child1', 'bb', 'dd', 'dd:child1', 'dd:child1:child1', 'dd:child2', 'ee',
    )
    for target_headline in valid_target_headlines:
        for test_kind, is_json in (
            ('cut', True), ('cut', False), ('copy', True), ('copy', False),
        ):

            # print(f"TEST {test_kind} {target_headline}")

            # Create the tree and gnx_dict.
            self.clean_tree()
            cc = self.create_test_paste_outline()
            # Calculate vnodes and gnx_dict for test_node, before any changes.
            vnodes = list(set(list(c.all_nodes())))
            gnx_dict = {z.h: z.gnx for z in vnodes}
            self.assertFalse(c.checkOutline())

            # Change the body text of all the to-be-copied nodes.
            cc.b = 'cc body: changed'
            cc_child1 = cc.firstChild()
            cc_child2 = cc_child1.next()
            assert cc.h == 'cc', repr(cc)
            assert cc_child1.h == 'cc:child1', repr(cc_child1.h)
            assert cc_child2.h == 'cc:child2', repr(cc_child2.h)
            cc.b = 'cc body: changed'
            cc_child1.b = 'cc:child1 body: changed'
            cc_child2.b = 'cc:child2 body: changed'

            # Cut or copy cc.
            if test_kind == 'cut':
                # Delete cc *without* undo.
                c.selectPosition(cc)
                self.copy_node(is_json)
                back = cc.threadBack()
                assert back
                cc.doDelete()
                c.selectPosition(back)
            else:
                # *Copy*  node cc
                c.selectPosition(cc)
                self.copy_node(is_json)

                # Restore the empty bodies of cc and cc:child1.
                # Copy does not change these positions.
                cc.b = cc_child1.b = cc_child2.b = ''

            self.assertFalse(c.checkOutline())

            # Pretest: select all positions in the tree.
            for p in c.all_positions():
                c.selectPosition(p)

            # Find the target position by headline.
            target_p = g.findNodeAnywhere(c, target_headline)
            self.assertTrue(target_p, msg=target_headline)

            # Paste after the target.
            c.selectPosition(target_p)
            c.pasteAsTemplate()

            # Check the paste.
            self.assertFalse(c.checkOutline())
            test_tree(pasted_flag=True, tag='paste-as-template')

            # Check multiple undo/redo cycles.
            for i in range(3):
                u.undo()
                self.assertFalse(c.checkOutline())
                test_tree(pasted_flag=False, tag=f"undo {i}")
                u.redo()
                self.assertFalse(c.checkOutline())
                test_tree(pasted_flag=True, tag=f"redo {i}")
</t>
<t tx="ekr.20230724130959.5">def test_tree(pasted_flag: bool, tag: str) -&gt; None:
    """Test the tree."""
    tag_s = f"kind: {test_kind} is_json? {int(is_json)} pasted? {int(pasted_flag)} {target_p.h}"
    try:
        # Test clone status and gnx. Set seen.
        seen = set()
        for p in c.all_positions():
            seen.add(p.v)
            if p.h == 'cc:child1':
                assert p.isCloned(), f"{tag_s}: not cloned: {p.h}"
            else:
                assert not p.isCloned(), f"{tag_s}: is cloned: {p.h}"

        # Test bodies. A fairly weak test.
        for p in c.all_positions():
            if p.h in ('cc', 'cc:child1', 'cc:child2'):
                pass  # One copy will have a body, another won't.
            else:
                assert not p.b, f"{tag_s} unexpected body: {p.h}"

        # Test gnxs.
        for p in c.all_positions():
            if p.h in ('cc', 'cc:child2'):
                pass  # The pasted copies will have new gnxs.
            else:
                message = f"{tag_s}: p.gnx: {p.gnx} !=  {gnx_dict.get(p.h)}"
                assert p.gnx == gnx_dict.get(p.h), message

        # Test that all and *only* the expected nodes exist.
        if test_kind == 'copy' or tag.startswith(('redo', 'paste-')):
            for z in seen:
                if z.h not in ('cc', 'cc:child2'):
                    assert z in vnodes, f"p.v not in vnodes: {z.gnx}, {z.h}"
            for z in vnodes:
                if z.h not in ('cc', 'cc:child2'):
                    assert z in seen, f"vnode not seen: {z.gnx}, {z.h}"
        else:
            assert test_kind == 'cut' and tag.startswith('undo')
            # All seen nodes should exist in vnodes.
            for z in seen:
                if z.h not in ('cc', 'cc:child2'):
                    assert z in vnodes, f"{z.h} not in vnodes"
            # All vnodes should be seen except cc and cc:child2.
            for z in vnodes:
                if z.h in ('cc', 'cc:child2'):
                    assert z not in seen, f"{z.h} in seen after undo"
                else:
                    assert z in seen, f"{z.h} not seen after undo"
    except Exception as e:
        message = f"clone_test failed! tag: {tag}: {e}"
        print(f"\n{message}\n")
        # self.dump_clone_info(c)
        self.dump_bodies(c)
        g.printObj(gnx_dict, tag='gnx_dict')
        # g.printObj(vnodes, tag='vnodes')
        # g.printObj([f"{z.gnx:30} {' '*z.level()}{z.h:10} {z.b!r}" for z in c.all_positions()], tag='bodies')
        self.fail(message)  # This throws another exception!
</t>
<t tx="ekr.20230724140451.1">def create_test_paste_outline(self) -&gt; Position:
    """
    Create the following tree:

        aa
            aa:child1
        bb
        cc:child1 (clone)
        cc
          cc:child1 (clone)
          cc:child2
        dd
          dd:child1
            dd:child1:child1
          dd:child2
        ee

    return cc.
    """
    c = self.c
    root = c.rootPosition()
    aa = root.insertAfter()
    aa.h = 'aa'
    aa_child1 = aa.insertAsLastChild()
    aa_child1.h = 'aa:child1'
    bb = aa.insertAfter()
    bb.h = 'bb'
    cc = bb.insertAfter()
    cc.h = 'cc'
    cc_child1 = cc.insertAsLastChild()
    cc_child1.h = 'cc:child1'
    cc_child2 = cc_child1.insertAfter()
    cc_child2.h = 'cc:child2'
    dd = cc.insertAfter()
    dd.h = 'dd'
    dd_child1 = dd.insertAsLastChild()
    dd_child1.h = 'dd:child1'
    dd_child2 = dd.insertAsLastChild()
    dd_child2.h = 'dd:child2'
    dd_child1_child1 = dd_child1.insertAsLastChild()
    dd_child1_child1.h = 'dd:child1:child1'
    ee = dd.insertAfter()
    ee.h = 'ee'
    clone = cc_child1.clone()
    clone.moveAfter(bb)
    assert clone.v == cc_child1.v
    # Careful: position cc has changed.
    cc = clone.next().copy()
    # Initial checks.
    assert cc.h == 'cc'
    # Make *sure* clones are as expected.
    for p in c.all_positions():
        if p.h == 'cc:child1':
            assert p.isCloned(), p.h
        else:
            assert not p.isCloned(), p.h
    return cc
</t>
<t tx="ekr.20230724141139.1">def copy_node(self, is_json=False) -&gt; str:
    """Copy c.p to the clipboard."""
    c = self.c
    if is_json:
        s = c.fileCommands.outline_to_clipboard_json_string()
    else:
        s = c.fileCommands.outline_to_clipboard_string()
    g.app.gui.replaceClipboardWith(s)
    return s
</t>
<t tx="ekr.20230724174102.1">def dump_bodies(self, c: Cmdr) -&gt; None:  # pragma: no cover
    """Dump all headlines."""
    print('')
    g.trace(c.fileName())
    print('')
    for p in c.all_positions():
        head_s = f"{' '*p.level()} {p.h}"
        print(f"{p.gnx:&lt;28} {head_s:&lt;20} body: {p.b!r}")

</t>
<t tx="ekr.20230724210028.1">def test_tree(tag: str) -&gt; None:
    """Test the tree."""
    assert tag[0].isnumeric()
    try:
        for p in c.all_positions():
            if p.h == 'cc:child1' and not tag.startswith('4'):
                assert p.isCloned(), f"{p.h} is not cloned"
            else:
                assert not p.isCloned(), f"{p.h} is cloned"
            assert p.gnx in gnx_dict.get(p.h), f"{p.h} not in gnx_dict"
    except Exception as e:
        message = f"Fail! tag: {tag}: {e}"
        print(f"\n{message}")
        self.dump_clone_info(c)
        # g.printObj(gnx_dict, tag='gnx_dict')
        # g.printObj(vnodes, tag='vnodes')
        self.fail(message)
</t>
<t tx="ekr.20230725084746.1">def save_data(v: VNode) -&gt; dict:
    assert isinstance(v, VNode), repr(v)
    # Careful: deepcopy can't pickle v.context or v.expandedPositions
    v.context = None
    old_expandedPositions = v.expandedPositions
    v.expandedPositions = None
    d = {
        'c': c,
        'gnx_dict': c.fileCommands.gnxDict,
        'deepcopy': copy.deepcopy(v),
    }
    v.context = c
    v.expandedPositions = old_expandedPositions
    return d

def restore_data(v, data: dict) -&gt; None:
    assert isinstance(v, VNode), repr(v)
    c.fileCommands.gnxDict = data['gnx_dict']
    v = data['deepcopy']
    v.context = data['c']
</t>
<t tx="ekr.20230725111522.1">def test_p_v_archive(self):
    c = self.c
    p = c.p
    v = p.v
    ### Add uAs.
    p.archive()
    v.archive()
    if 0:
        print('p.archive:')
        g.printObj(p.archive())
    if 0:
        print('v.archive:')
        g.printObj(v.archive())
</t>
<t tx="ekr.20230726013411.1">@language rest


@language python
</t>
<t tx="ekr.20230726014624.1"></t>
<t tx="ekr.20230726014755.1"></t>
<t tx="ekr.20230726063237.1">def archive(self) -&gt; dict[str, Any]:
    """Return a json-like archival dictionary for p/v.unarchive."""
    p = self

    # Create a list of all vnodes in p.self_and_subtree.
    all_unique_vnodes: list[VNode] = []
    for p in p.self_and_subtree():
        if p.v not in all_unique_vnodes:
            all_unique_vnodes.append(p.b)

    # Create an archive of all_vnodes.
    parents_dict: dict[str, list[str]] = {}
    for v in all_unique_vnodes:
        parents_dict[v.gnx] = [z.gnx for z in v.parents]

    children_dict: dict[str, list[str]] = {}
    for v in all_unique_vnodes:
        children_dict[v.gnx] = [z.gnx for z in v.children]

    marks_dict: dict[str, str] = {}
    for v in all_unique_vnodes:
        marks_dict[v.gnx] = str(int(v.isMarked()))

    uas_dict: dict[str, dict] = {}
    for v in all_unique_vnodes:
        uas_dict[v.gnx] = v.archive_ua()  # To do.

    return {
        'vnodes': all_unique_vnodes,
        'parents': parents_dict,
        'children': children_dict,
        'marks': marks_dict,
        'uAs': uas_dict,
    }
</t>
<t tx="ekr.20230726065751.1"></t>
<t tx="ekr.20230726091431.1"></t>
<t tx="ekr.20230726104947.1"></t>
<t tx="ekr.20230726105021.1"></t>
<t tx="ekr.20230726105038.1"></t>
<t tx="ekr.20230726105058.1"></t>
<t tx="ekr.20230726105114.1"></t>
<t tx="ekr.20230726105140.1"></t>
<t tx="ekr.20230726105303.1"></t>
<t tx="ekr.20230726180323.1">@language rest

Computing the archive string
- fc.outline_to_clipboard_string unl:gnx://leoPy.leo#ekr.20031218072017.1573
- fc.put_v_elements &amp; helper unl:gnx://leoPy.leo#ekr.20031218072017.1579
- fc.put_v_element &amp; helper unl:gnx://leoPy.leo#ekr.20031218072017.1863
- fc.compute_attribute_bits unl:gnx://leoPy.leo#ekr.20031218072017.1865
- fc.putDescendentVnodeUas &amp; helper unl:gnx://leoPy.leo#ekr.20080805071954.2
- fc.pickle unl:gnx://leoPy.leo#ekr.20080805085257.2

Handling uAs</t>
<t tx="ekr.20230726180501.1">@language rest
@nosearch

Following a link sometimes generates two node history entries
https://github.com/leo-editor/leo-editor/issues/3463

PR: https://github.com/leo-editor/leo-editor/pull/3465


@language python
</t>
<t tx="ekr.20230726182331.1"></t>
<t tx="ekr.20230726182849.1"></t>
<t tx="ekr.20230726185713.1"></t>
<t tx="ekr.20230726191706.1"></t>
<t tx="ekr.20230727042339.1">@language rest
@nosearch

https://github.com/leo-editor/leo-editor/issues/3464
Unified PR: https://github.com/leo-editor/leo-editor/pull/3455

@language python
</t>
<t tx="ekr.20230727044355.1">def check_c_checkVnodeLinks(self):
    c = self.c
    self.assertEqual(c.checkVnodeLinks(), 0)  # Leo's main checker.
    self.assertEqual(c.checkLinks(), 0)  # A slow test, suitable only for unit tests.
</t>
<t tx="ekr.20230727053247.1"></t>
<t tx="ekr.20230727061724.1"></t>
<t tx="ekr.20230727073322.1">NodeHistory.select: unl:gnx://leoPy.leo#ekr.20130915111638.11294
NodeHistory.update: unl:gnx://leoPy.leo#ville.20090724234020.14676</t>
<t tx="ekr.20230727074847.1">def find_file_line_helper(self, n: int, p: Position = None) -&gt; tuple[Position, int]:
    c = self.c
    if n &lt; 0:
        return None, -1
    p = p or c.p
    root, fileName = self.find_root(p)
    if not root:
        return self.find_script_line(n, p)
    # Step 1: Get the lines of external files *with* sentinels,
    #         even if the actual external file actually contains no sentinels.
    sentinels = root.isAtFileNode()
    s = self.get_external_file_with_sentinels(root)
    # Special case empty files.
    if not s.strip():
        return p, 0
    lines = g.splitLines(s)
    # Step 2: scan the lines for line n.
    if sentinels:
        # All sentinels count as real lines.
        gnx, h, offset = self.scan_sentinel_lines(lines, n, root)
    else:
        # Not all sentinels count as real lines.
        gnx, h, offset = self.scan_nonsentinel_lines(lines, n, root)
    if gnx:
        p = self.find_gnx2(root, gnx, h)
        if p:
            self.success(n, offset, p)
            return p, offset
    self.fail(lines, n, root)
    return None, -1
</t>
<t tx="ekr.20230727094834.1"># Found 19 marked nodes</t>
<t tx="ekr.20230727094921.1">@nosearch

# Word, Head, Body

# found 15 nodes</t>
<t tx="ekr.20230727095204.1"></t>
<t tx="ekr.20230727095339.1"></t>
<t tx="ekr.20230727095448.1"></t>
<t tx="ekr.20230727100619.1"></t>
<t tx="ekr.20230728005934.1">def find_errors() -&gt; tuple[list[tuple[VNode, VNode]], list[str], int]:
    """
    Scan all vnodes for erroneous parent/child pairs.

    Return (error_list, messages, n)
    """
    error_list: list[tuple[VNode, VNode]] = []
    messages: list[str] = []
    n = 0
    for parent_v in c.all_unique_nodes():  # Avoids recursion.
        for child_v in parent_v.children:
            children_n = parent_v.children.count(child_v)
            parents_n = child_v.parents.count(parent_v)
            if children_n != parents_n:
                error_list.append((parent_v, child_v))
                messages.append(
                    'Mismatch between parent.children and child.parents\n'
                    f"parent: {parent_v.h:30} count(parent.children) = {children_n}\n"
                    f" child: {child_v.h:30} count(child.parents = {parents_n}")
                n += 1
    return error_list, messages, n
</t>
<t tx="ekr.20230728010156.1">def fix_errors(error_list: list[tuple[VNode, VNode]]) -&gt; None:
    "Fix all erroneous nodes by adding/deleting entries from v.parents." ""
    for parent_v, child_v in error_list:
        children_n = parent_v.children.count(child_v)
        parents_n = child_v.parents.count(parent_v)
        if parents_n == children_n:
            g.trace('Can not happen: parents_n == children_n')
        elif parents_n &lt; children_n:
            while parents_n &lt; children_n:
                child_v.parents.append(parent_v)
                parents_n += 1
        else:
            while parents_n &gt; children_n:
                child_v.parents.remove(parent_v)
                parents_n += 1
</t>
<t tx="ekr.20230728010753.1">def undelete_nodes(error_list: list[tuple[VNode, VNode]]) -&gt; None:

    """Restore a parent link to any node that would otherwise be deleted."""
    seen: list[VNode] = []
    for parent_v, child_v in error_list:
        if not child_v.parents and child_v not in seen:
            # Add child_v to *one* parent.
            seen.append(child_v)
            parent_v.children.append(child_v)
            child_v.parents.append(parent_v)
</t>
<t tx="ekr.20230728011151.1">def recheck() -&gt; tuple[list[tuple[VNode, VNode]], list[str], int]:
    """
    Rescan all vnodes to ensure that no errors remain.

    Return (error_list, messages, no)
    """
    error_list: list[tuple[VNode, VNode]] = []
    messages: list[str] = []
    n = 0
    for parent_v in c.all_unique_nodes():  # Avoids recursion.
        for child_v in parent_v.children:
            children_n = parent_v.children.count(child_v)
            parents_n = child_v.parents.count(parent_v)
            if children_n != parents_n:
                error_list.append((parent_v, child_v))
                messages.append(
                    'Error recovery failed!'
                    f"parent: {parent_v.h:30} count(parent.children) = {children_n}\n"
                    f" child: {child_v.h:30} count(child.parents = {parents_n}")
                n += 1
    return error_list, messages, n
</t>
<t tx="ekr.20230728060514.1">@language python

# Create a list of vnodes of interest, say all vnodes in p.self_and_subtree.
all_unique_vnodes: list[VNode] = []
for p in p.self_and_subtree():
    if p.v not in all_vnodes:
        all_unique_vnodes.append(p.b)
        
# Create an archive of all_vnodes.
parents_dict: dict[str, str] = {}
for v in all_unique_vnodes:
    parents_dict [v.gnx] = [z.gnx for z in v.parents]
    
children_dict: dict[str, str] = {}
for v in all_unique_vnodes:
    children_dict [v.gnx] = [z.gnx for z in v.children]
    
marks_dict: dict[str, str] = {}
for v in all_unique_vnodes:
    marks_dict [v.gnx] = str(int(v.isMarked()))
    
uas_dict: dict[str, dict] = {}
for v in all_unique_vnodes:
    uas_dict [v.gnx] = v.archive_ua()  # To do.

{
    'all-vnodes': [v.gnx for v in all_vnodes],
    'parents': parents_dict,
    'children': children_dict,
    'marks': marks_dict,
    'uAs': uAs_dict,
}</t>
<t tx="ekr.20230728062638.1">def archive_uas(self) -&gt; dict[str, dict]:
    """To do: return a json-like dict of all uas."""
    return {}
</t>
<t tx="ekr.20230728081210.1"></t>
<t tx="felix.20220618165345.1">def readWithJsonTree(self, path: str, s: str) -&gt; tuple[VNode, Any]:
    try:
        d = json.loads(s)
    except Exception:
        g.trace(f"Error converting JSON from  .leojs file: {path}")
        g.es_exception()
        return None, None

    try:
        g_element = d.get('globals', {})  # globals is optional
        v_elements = d.get('vnodes')
        t_elements = d.get('tnodes')
        gnx2ua: dict = defaultdict(dict)
        gnx2ua.update(d.get('uas', {}))  # User attributes in their own dict for leojs files
        gnx2body = self.scanJsonTnodes(t_elements)
        hidden_v = self.scanJsonVnodes(gnx2body, self.gnx2vnode, gnx2ua, v_elements)
        self.updateBodies(gnx2body, self.gnx2vnode)
        self.handleBits()
    except Exception:
        g.trace(f"Error .leojs JSON is not valid: {path}")
        g.es_exception()
        return None, None

    return hidden_v, g_element

</t>
<t tx="felix.20220618174623.1">def scanJsonTnodes(self, t_elements: Any) -&gt; dict[str, str]:

    gnx2body: dict[str, str] = {}

    for gnx, body in t_elements.items():
        gnx2body[gnx] = body or ''

    return gnx2body

</t>
<t tx="felix.20220618174639.1">def scanJsonVnodes(self,
    gnx2body: dict[str, str],
    gnx2vnode: dict[str, VNode],
    gnx2ua: dict[str, Any],
    v_elements: Any,
) -&gt; Optional[VNode]:

    c, fc = self.c, self.c.fileCommands

    def v_element_visitor(parent_e: Any, parent_v: VNode) -&gt; None:
        """Visit the given element, creating or updating the parent vnode."""
        for i, v_dict in enumerate(parent_e):
            # Get the gnx.
            gnx = v_dict.get('gnx')
            if not gnx:
                g.trace("Bad .leojs file: no gnx in v_dict")
                g.printObj(v_dict)
                return
            #
            # Create the vnode.
            assert len(parent_v.children) == i, (i, parent_v, parent_v.children)

            try:
                v = gnx2vnode.get(gnx)
            except KeyError:
                # g.trace('no "t" attrib')
                gnx = None
                v = None
            if v:
                # A clone
                parent_v.children.append(v)
                v.parents.append(parent_v)
                # The body overrides any previous body text.
                body = g.toUnicode(gnx2body.get(gnx) or '')
                assert isinstance(body, str), body.__class__.__name__
                v._bodyString = body
            else:
                v = leoNodes.VNode(context=c, gnx=gnx)
                gnx2vnode[gnx] = v
                parent_v.children.append(v)
                v.parents.append(parent_v)

                v._headString = v_dict.get('vh', '')
                v._bodyString = gnx2body.get(gnx, '')
                v.statusBits = v_dict.get('status', 0)  # Needed ?
                if v.isExpanded():
                    fc.descendentExpandedList.append(gnx)
                if v.isMarked():
                    fc.descendentMarksList.append(gnx)
                #

                # Handle vnode uA's
                uaDict = gnx2ua[gnx]  # A defaultdict(dict)

                if uaDict:
                    v.unknownAttributes = uaDict

                # Recursively create the children.
                v_element_visitor(v_dict.get('children', []), v)

    gnx = 'hidden-root-vnode-gnx'
    hidden_v = leoNodes.VNode(context=c, gnx=gnx)
    hidden_v._headString = '&lt;hidden root vnode&gt;'
    gnx2vnode[gnx] = hidden_v
    #
    # Traverse the tree of v elements.
    v_element_visitor(v_elements, hidden_v)

    # add all possible UAs for external files loading process to add UA's.
    fc.descendentTnodeUaDictList.append(gnx2ua)
    return hidden_v
</t>
<t tx="felix.20220618181309.1">def scanJsonGlobals(self, json_d: dict) -&gt; None:
    """Set the geometries from the globals dict."""
    c = self.c

    def toInt(x: int, default: int) -&gt; int:
        try:
            return int(x)
        except Exception:
            return default

    # Priority 1: command-line args
    windowSize = g.app.loadManager.options.get('windowSize')
    windowSpot = g.app.loadManager.options.get('windowSpot')
    #
    # Priority 2: The cache.
    db_top, db_left, db_height, db_width = c.db.get('window_position', (None, None, None, None))
    #
    # Priority 3: The globals dict in the .leojs file.
    #             Leo doesn't write the globals element, but leoInteg might.

    # height &amp; width
    height, width = windowSize or (None, None)
    if height is None:
        height, width = json_d.get('height'), json_d.get('width')
    if height is None:
        height, width = db_height, db_width
    height, width = toInt(height, 500), toInt(width, 800)
    #
    # top, left.
    top, left = windowSpot or (None, None)
    if top is None:
        top, left = json_d.get('top'), json_d.get('left')
    if top is None:
        top, left = db_top, db_left
    top, left = toInt(top, 50), toInt(left, 50)
    #
    # r1, r2.
    r1 = float(c.db.get('body_outline_ratio', '0.5'))
    r2 = float(c.db.get('body_secondary_ratio', '0.5'))
    if 'size' in g.app.debug:
        g.trace(width, height, left, top, c.shortFileName())
    # c.frame may be a NullFrame.
    c.frame.setTopGeometry(width, height, left, top)
    c.frame.resizePanesToRatio(r1, r2)
    frameFactory = getattr(g.app.gui, 'frameFactory', None)
    if not frameFactory:
        return
    assert frameFactory is not None
    mf = frameFactory.masterFrame
    if g.app.start_minimized:
        mf.showMinimized()
    elif g.app.start_maximized:
        # #1189: fast.scanGlobals calls showMaximized later.
        mf.showMaximized()
    elif g.app.start_fullscreen:
        mf.showFullScreen()
    else:
        mf.show()

</t>
<t tx="felix.20230326225405.1">def afterChangeMultiHeadline(self, command: str, bunch: g.Bunch) -&gt; None:
    """Create an undo node using d created by beforeChangeMultiHeadline."""
    u = self
    c = self.c
    if u.redoing or u.undoing:
        return  # pragma: no cover
    # Set the type &amp; helpers.
    bunch.kind = 'multipleHeadline'
    bunch.undoType = command
    bunch.undoHelper = u.undoChangeMultiHeadline
    bunch.redoHelper = u.redoChangeMultiHeadline
    oldHeadlines = bunch.headlines
    newHeadlines = {}
    for p in c.all_unique_positions():
        if p.h != oldHeadlines[p.gnx][0]:
            newHeadlines[p.gnx] = (oldHeadlines[p.gnx][0], p.h)
    # Filtered down dict containing only the changed ones.
    bunch.headlines = newHeadlines
    u.pushBead(bunch)

afterChangeMultiHead = afterChangeMultiHeadline
</t>
<t tx="felix.20230326230839.1">def beforeChangeMultiHeadline(self, p: Position) -&gt; g.Bunch:
    """
    Return data that gets passed to afterChangeMultiHeadline.
    p is used to select position after undo/redo multiple headline changes is done
    """
    c, u = self.c, self
    bunch = u.createCommonBunch(p)
    headlines = {}
    for p in c.all_unique_positions():
        headlines[p.gnx] = (p.h, None)
    # contains all, but will get reduced by afterChangeMultiHeadline
    bunch.headlines = headlines
    return bunch

beforeChangeMultiHead = beforeChangeMultiHeadline
</t>
<t tx="felix.20230326231408.1">def redoChangeMultiHeadline(self) -&gt; None:
    c, u = self.c, self
    c.frame.body.recolor(u.p)
    # Swap the ones from the 'bunch.headline' dict
    for gnx, oldNewTuple in u.headlines.items():
        v = c.fileCommands.gnxDict.get(gnx)
        v.initHeadString(oldNewTuple[1])
        if v.gnx == u.p.gnx:
            u.p.setDirty()
            # This is required.  Otherwise redraw will revert the change!
            c.frame.tree.setHeadline(u.p, oldNewTuple[1])
    # selectPosition causes recoloring, so don't do this unless needed.
    if c.p != u.p:  # #1333.
        c.selectPosition(u.p)
</t>
<t tx="felix.20230326231543.1">def undoChangeMultiHeadline(self) -&gt; None:
    """Undo a change to a node's headline."""
    c, u = self.c, self
    # selectPosition causes recoloring, so don't do this unless needed.
    c.frame.body.recolor(u.p)
    # Swap the ones from the 'bunch.headline' dict
    for gnx, oldNewTuple in u.headlines.items():
        v = c.fileCommands.gnxDict.get(gnx)
        v.initHeadString(oldNewTuple[0])
        if v.gnx == u.p.gnx:
            u.p.setDirty()
            # This is required.  Otherwise redraw will revert the change!
            c.frame.tree.setHeadline(u.p, oldNewTuple[0])
    #
    if c.p != u.p:
        c.selectPosition(u.p)
</t>
<t tx="peckj.20131023115434.10115">def createNodeHierarchy(self, heads: list, forcecreate: bool = False) -&gt; Position:
    """ Create the proper hierarchy of nodes with headlines defined in
        'heads' as children of the current position

        params:
        heads - list of headlines in order to create, i.e. ['foo','bar','baz']
                will create:
                  self
                  -foo
                  --bar
                  ---baz
        forcecreate - If False (default), will not create nodes unless they don't exist
                      If True, will create nodes regardless of existing nodes
        returns the final position ('baz' in the above example)
    """
    c = self.v.context
    return c.createNodeHierarchy(heads, parent=self, forcecreate=forcecreate)
</t>
<t tx="shadow.20080825171547.2">def textOffset(self) -&gt; Optional[int]:
    """
    Return the fcol offset of self.
    Return None if p is has no ancestor @&lt;file&gt; node.
    http://tinyurl.com/5nescw
    """
    p = self
    found, offset = False, 0
    for p in p.self_and_parents(copy=False):
        if p.isAnyAtFileNode():
            # Ignore parent of @&lt;file&gt; node.
            found = True
            break
        parent = p.parent()
        if not parent:
            break
        # If p is a section definition, search the parent for the reference.
        # Otherwise, search the parent for @others.
        h = p.h.strip()
        i = h.find('&lt;&lt;')
        j = h.find('&gt;&gt;')
        target = h[i : j + 2] if -1 &lt; i &lt; j else '@others'
        for s in parent.b.split('\n'):
            if s.find(target) &gt; -1:
                offset += g.skip_ws(s, 0)
                break
    return offset if found else None
</t>
<t tx="tbnorth.20170616105931.1">def handleURL(self, url: str) -&gt; None:
    """handleUrl - user clicked an URL / UNL link

    :param str url: URL for link
    """
    c = self.c
    g.es(url)
    if not g.isValidUnl(url):
        g.handleUrl(url, c=c)
        return
    our_unl = c.p.get_UNL()

    ### This is too early.
        # new_c = g.handleUnl(url, c)
        # if not new_c or not hasattr(new_c, 'backlinkController'):
            # return

    new_p = g.findAnyUnl(our_unl, c)
    if not new_p:
        g.es(f"unl not found: {our_unl!r}. not creating backlink")
        return
    new_c = new_p.v.context
    if not hasattr(new_c, 'backlinkController'):
        g.es('No controller. not creating backlink')
        return

    ### To do: should this code switch outlines???
        # new_c = new_p.v.context
        # if new_c != c:
            # g.app.selectLeoWindow(new_c)  # Switch outlines.

    new_c.backlinkController.initBacklink(new_p.v)
    if our_unl not in [i.rsplit('##', 1)[0] for i in new_p.v.u['_bklnk']['urls']]:
        new_p.v.u['_bklnk']['urls'].append("%s##%s" % (our_unl, self.c.p.h))
        new_c.backlinkController.updateTabInt()
        new_p.setDirty()
        new_c.setChanged()
        g.es("NOTE: created back link automatically")
</t>
<t tx="tbnorth.20171220123648.1">def linkClicked(self, link: str) -&gt; None:
    """linkClicked - link clicked in log

    :param QUrl link: link that was clicked
    """
    s = g.toUnicode(link.toString())
    url = urllib.parse.unquote(s)
    g.handleUrl(url, c=self.c)
</t>
<t tx="tbrown.20090219095555.63">def handleUrl(url: str, c: Cmdr = None, p: Position = None) -&gt; Any:
    """Open a url or a unl."""
    if c and not p:
        p = c.p
    # These two special cases should match the hacks in jedit.match_any_url.
    if url.endswith('.'):
        url = url[:-1]
    if '(' not in url and url.endswith(')'):
        url = url[:-1]
    # Lower the url.
    urll = url.lower()
    if urll.startswith('@url'):
        url = url[4:].lstrip()
    if (
        urll.startswith(('#', 'unl://', 'unl:gnx:')) or
        urll.startswith('file://') and '--&gt;' in urll
    ):
        return g.handleUnl(url, c)
    try:
        g.handleUrlHelper(url, c, p)
        return urll  # For unit tests.
    except Exception:
        g.es_print("g.handleUrl: exception opening", repr(url))
        g.es_exception()
        return None
</t>
<t tx="tbrown.20091028100922.1493">def updateEditorInt(self):

    c = self.c

    self.initForm()
    for attr in self.getAttribs():
        class_, name, value, path, type_, readonly = attr
        if readonly:
            self.form.addRow(QtWidgets.QLabel(name), QtWidgets.QLabel(str(value)))

        else:
            editor = editWatcher(c, c.currentPosition().v, class_, name, value, path, type_)
            self.editors.append(editor)

            self.form.addRow(QtWidgets.QLabel(name), editor.widget())
</t>
<t tx="tbrown.20111010104549.26758">def get_full_legacy_UNL(self) -&gt; str:
    """
    Return a legacy unl with the full file-name component.

    Not used in Leo's core or official plugins.
    """
    p = self
    c = p.v.context
    path_part = '--&gt;'.join(list(reversed([z.h for z in self.self_and_parents(copy=False)])))
    return 'unl:' + f"//{c.fileName()}#{path_part}"
</t>
<t tx="tom.20220328141455.1"># Navigate to section reference if one was clicked.
l_ = line.strip()
if l_.endswith('&gt;&gt;') and l_.startswith('&lt;&lt;'):
    p = c.p
    px = None
    for p1 in p.subtree():
        if p1.h.strip() == l_:
            px = p1
            break
    if px:
        c.selectPosition(px)
        c.redraw()
    return None
</t>
<t tx="tom.20220328141544.1"># Find the url on the line.
for match in g.url_regex.finditer(line):
    # Don't open if we click after the url.
    if match.start() &lt;= col &lt; match.end():
        url = match.group(0)
        if g.isValidUrl(url):
            break
</t>
<t tx="tom.20220328142302.1">target = None
for match in gnx_regex.finditer(line):
    # Don't open if we click after the gnx.
    if match.start() &lt;= col &lt; match.end():
        target = match.group(0)[4:]  # Strip the leading 'gnx:'
        break

if target:
    found_gnx = False
    if c.p.gnx == target:
        return target
    for p in c.all_unique_positions():
        if p.v.gnx == target:
            found_gnx = True
            break
    if found_gnx:
        c.selectPosition(p)
        c.redraw()
    return target
</t>
<t tx="tom.20230130102836.1"># Part 4: #2546: look for a file name.
s = w.getAllText()
i, j = w.getSelectionRange()
m = re.match(r'(\w+)\.(\w){1,4}\b', s[i:])
filename, filename_w = '', ''
if m:
    filename = m.group(0)
# Part 5: #3112: look for import statement
else:
    FROMre = r'^from [\./\\]*([^\s/\\].+)\s+import'
    IMPORTre = r'^import\s+[\./\\]*([^\s/\\].+)'
    IMPORTSre = FROMre + '|' + IMPORTre

    m = re.match(IMPORTSre, s[i:], re.MULTILINE)
    module = m and (m[2] or m[1])
    if module:
        filename = module + '.py'
        filename_w = module + '.pyw'

if filename:
    # Navigate to the first node whose headline ends with the filename.
    effective_filename = ''
    for p in c.all_unique_positions():
        headline = p.h.strip()
        if headline.endswith(filename):
            effective_filename = filename
        elif filename_w and headline.endswith(filename_w):
            effective_filename = filename_w
        if effective_filename:
            # Set the find text.
            c.findCommands.ftm.set_find_text(effective_filename)
            # Select.
            c.redraw(p)
            break
</t>
<t tx="ville.20090518182905.5425">class NavController:

    def __init__(self, c: Cmdr) -&gt; None:
        self.c = c
        c._prev_next = self
        self._buttons: Optional[tuple[Action, Action]] = self.makeButtons()

    @others
</t>
<t tx="ville.20090518182905.5427">def makeButtons(self) -&gt; tuple[Action, Action]:

    c = self.c
    w = c.frame.iconBar.w
    if not w:
        return None  # For unit testing.
    icon_l = w.style().standardIcon(StandardPixmap.SP_ArrowLeft)
    icon_r = w.style().standardIcon(StandardPixmap.SP_ArrowRight)
    # Create the actions.
    act_l = QAction(icon_l, 'prev', w)
    act_r = QAction(icon_r, 'next', w)
    # Use the new commands.
    act_l.triggered.connect(lambda checked: c.goToPrevHistory())
    act_r.triggered.connect(lambda checked: c.goToNextHistory())
    # Don't execute the command twice.
    self.c.frame.iconBar.add(qaction=act_l)
    self.c.frame.iconBar.add(qaction=act_r)
    return act_l, act_r
</t>
<t tx="ville.20090724234020.14676">def update(self, p: Position, change: bool = True) -&gt; None:
    """
    Update the beadList while p is being selected.

    change: True:  The caller is c.frame.tree.selectHelper.
            False: The caller is NodeHistory.select.
    """
    c, cc = self.c, self.c.chapterController
    if not p or not c.positionExists(p) or self.skipBeadUpdate:
        return
    # A hack: don't add @chapter nodes.
    # These are selected during the transitions to a new chapter.
    if p.h.startswith('@chapter '):
        return
    # Fix bug #180: handle the change flag.
    aList: list[tuple[Position, Chapter]] = []
    found = -1
    for i, data in enumerate(self.beadList):
        p2, junk_chapter = data
        if c.positionExists(p2):
            if p == p2:
                if change:
                    pass  # We'll append later.
                elif found == -1:
                    found = i
                    aList.append(data)
                else:
                    pass  # Remove any duplicate.
            else:
                aList.append(data)
    if change or found == -1:
        data = (p.copy(), cc.getSelectedChapter())
        aList.append(data)
        self.beadPointer = len(aList) - 1
    else:
        self.beadPointer = found
    self.beadList = aList
    # self.dump()
</t>
<t tx="ville.20120502221057.7498">def contentModified(self) -&gt; None:
    g.contentModifiedSet.add(self)
</t>
<t tx="ville.20120502221057.7499">def childrenModified(self) -&gt; None:
    g.childrenModifiedSet.add(self)
</t>
<t tx="vitalije.20200529105105.1">@g.commander_command('paste-as-template')
def pasteAsTemplate(self: Cmdr, event: Event = None) -&gt; None:
    """Paste as template clones only nodes that were already clones"""
    c = self
    p = c.p
    s = g.app.gui.getTextFromClipboard()
    if not s or not c.canPasteOutline(s):
        return  # This should never happen.
    isJson = s.lstrip().startswith("{")

    # Define helpers.
    @others

    xvelements: Any
    xtelements: Any
    uas: Any  # Possible bug?

    x = leoFileCommands.FastRead(c, {})

    if not isJson:
        xroot = ElementTree.fromstring(s)
        xvelements = xroot.find('vnodes')  # &lt;v&gt; elements.
        xtelements = xroot.find('tnodes')  # &lt;t&gt; elements.
        bodies, uas = x.scanTnodes(xtelements)
        # g.printObj(bodies, tag='bodies/gnx2body')
        x.updateBodies(bodies, x.gnx2vnode)
        root_gnx = xvelements[0].attrib.get('t')  # the gnx of copied node
    else:
        xroot = json.loads(s)
        xvelements = xroot.get('vnodes')  # &lt;v&gt; elements.
        xtelements = xroot.get('tnodes')  # &lt;t&gt; elements.
        bodies = x.scanJsonTnodes(xtelements)
        # g.printObj(bodies, tag='bodies/gnx2body')

        def addBody(node: Any) -&gt; None:
            if not hasattr(bodies, node['gnx']):
                bodies[node['gnx']] = ''
            if node.get('children'):
                for child in node['children']:
                    addBody(child)

        # generate bodies for all possible nodes, not just non-empty bodies.
        addBody(xvelements[0])
        uas = defaultdict(dict)
        uas.update(xroot.get('uas', {}))
        root_gnx = xvelements[0].get('gnx')  # the gnx of copied node

    # outside will contain gnxes of nodes that are outside the copied tree
    outside = {x.gnx for x in skip_root(c.hiddenRootNode)}

    # we generate new gnx for each node in the copied tree
    translation = {x: translate_gnx(x) for x in bodies}

    seen = set(outside)  # required for the treatment of local clones inside the copied tree

    heads: dict[str, str] = {}

    bunch = c.undoer.createCommonBunch(p)
    &lt;&lt; prepare destination data &gt;&gt;

    pasted = do_paste(vpar, index)

    newp = leoNodes.Position(pasted, index, parStack)

    bunch.undoHelper = undoHelper
    bunch.redoHelper = redoHelper
    bunch.undoType = 'paste-retaining-outside-clones'

    newp.setDirty()
    c.undoer.pushBead(bunch)
    c.redraw(newp)
</t>
<t tx="vitalije.20200529111500.1"># destination data consists of
#    1. vpar --- parent v node that should receive pasted child
#    2. index --- at which pasted child will be
#    3. parStack --- a stack for creating new position of the pasted node
#
# the new position will be:  Position(vpar.children[index], index, parStack)
# but it can't be calculated yet, before actual paste is done
if p.isExpanded():
    # paste as a first child of current position
    vpar = p.v
    index = 0
    parStack = p.stack + [(p.v, p._childIndex)]
else:
    # paste after the current position
    parStack = p.stack
    vpar = p.stack[-1][0] if p.stack else c.hiddenRootNode
    index = p._childIndex + 1

</t>
<t tx="vitalije.20200529112224.1">def skip_root(v: VNode) -&gt; Generator:
    """
    generates v nodes in the outline order
    but skips a subtree of the node with root_gnx
    """
    if v.gnx != root_gnx:
        yield v
        for ch in v.children:
            yield from skip_root(ch)
</t>
<t tx="vitalije.20200529112459.1">def translate_gnx(gnx: str) -&gt; str:
    """
    allocates a new gnx for all nodes that
    are not found outside copied tree
    """
    if gnx in outside:
        return gnx
    return g.app.nodeIndices.computeNewIndex()
</t>
<t tx="vitalije.20200529114857.1">gnx2v = c.fileCommands.gnxDict
def getv(gnx: str) -&gt; tuple[VNode, bool]:
    """
    returns a pair (vnode, is_new) for the given gnx.
    if node doesn't exist, creates a new one.
    """
    v = gnx2v.get(gnx)
    if v is None:
        return leoNodes.VNode(c, gnx), True
    return v, False
</t>
<t tx="vitalije.20200529115141.1">def viter(parent_gnx: str, xv: Any) -&gt; Generator:
    """
    iterates &lt;v&gt; nodes generating tuples:

        (parent_gnx, child_gnx, headline, body)

    skipping the descendants of already seen nodes.
    """

    if not isJson:
        chgnx = xv.attrib.get('t')
    else:
        chgnx = xv.get('gnx')

    b = bodies[chgnx]
    gnx = translation.get(chgnx)
    if gnx in seen:
        yield parent_gnx, gnx, heads.get(gnx), b
    else:
        seen.add(gnx)
        if not isJson:
            h = xv[0].text
        else:
            h = xv.get('vh', '')
        heads[gnx] = h
        yield parent_gnx, gnx, h, b
        if not isJson:
            for xch in xv[1:]:
                yield from viter(gnx, xch)
        else:
            if xv.get('children'):
                for xch in xv['children']:
                    yield from viter(gnx, xch)

</t>
<t tx="vitalije.20200529115539.1">def do_paste(vpar: Any, index: int) -&gt; VNode:
    """
    pastes a new node as a child of vpar at given index
    """
    vpargnx = vpar.gnx
    # the first node is inserted at the given index
    # and the rest are just appended at parents children
    # to achieve this we first create a generator object
    rows = viter(vpargnx, xvelements[0])

    # then we just take first tuple
    pgnx, gnx, h, b = next(rows)

    # create vnode
    v, _ = getv(gnx)
    v.h = h
    v.b = b

    # and finally insert it at the given index
    vpar.children.insert(index, v)
    v.parents.append(vpar)

    pasted = v  # remember the first node as a return value

    # now we iterate the rest of tuples
    for pgnx, gnx, h, b in rows:

        # get or create a child `v`
        v, isNew = getv(gnx)
        if isNew:
            v.h = h
            v.b = b
            ua = uas.get(gnx)
            if ua:
                v.unknownAttributes = ua
        # get parent node `vpar`
        vpar = getv(pgnx)[0]

        # and link them
        vpar.children.append(v)
        v.parents.append(vpar)

    return pasted
</t>
<t tx="vitalije.20200529120440.1">def undoHelper() -&gt; None:
    v = vpar.children.pop(index)
    v.parents.remove(vpar)
    c.redraw(bunch.p)
</t>
<t tx="vitalije.20200529120537.1">def redoHelper() -&gt; None:
    vpar.children.insert(index, pasted)
    pasted.parents.append(vpar)
    c.redraw(newp)
</t>
<t tx="vitalije.20211206201240.1">def test_general_test_1(self):

    s = (
    """
        import sys
        def f1():
            pass

        class Class1:
            def method11():
                pass
            def method12():
                pass

        #
        # Define a = 2
        a = 2

        def f2():
            pass

        # An outer comment
        ATmyClassDecorator
        class Class2:
            def method21():
                print(1)
                print(2)
                print(3)
            ATmyDecorator
            def method22():
                pass
            def method23():
                pass

        class UnderindentedComment:
        # Outer underindented comment
            def u1():
            # Underindented comment in u1.
                pass

        # About main.

        def main():
            pass

        if __name__ == '__main__':
            main()
    """).replace('AT', '@')

    expected_results = (
        (0, '',  # Ignore the first headline.
                '&lt;&lt; TestPython.test_general_test_1: preamble &gt;&gt;\n'
                '@others\n'
                '\n'
                "if __name__ == '__main__':\n"
                '    main()\n'
                '@language python\n'
                '@tabwidth -4\n'
        ),
        (1, '&lt;&lt; TestPython.test_general_test_1: preamble &gt;&gt;',
                'import sys\n'
        ),
        (1, 'def f1',
                'def f1():\n'
                '    pass\n'
        ),
        (1, 'class Class1',
                   'class Class1:\n'
                   '    @others\n'
        ),
        (2, 'def method11',
                   'def method11():\n'
                   '    pass\n'
        ),
        (2, 'def method12',
                   'def method12():\n'
                   '    pass\n'
        ),
        (1, 'def f2',
                   '#\n'
                   '# Define a = 2\n'
                   'a = 2\n'
                   '\n'
                   'def f2():\n'
                   '    pass\n'
        ),
        (1, 'class Class2',
                   '# An outer comment\n'
                   '@myClassDecorator\n'
                   'class Class2:\n'
                   '    @others\n'
        ),
        (2, 'def method21',
                   'def method21():\n'
                   '    print(1)\n'
                   '    print(2)\n'
                   '    print(3)\n'
        ),
        (2, 'def method22',
                   '@myDecorator\n'
                   'def method22():\n'
                   '    pass\n'
        ),
        (2, 'def method23',
                   'def method23():\n'
                   '    pass\n'
        ),
        (1, 'class UnderindentedComment',
            'class UnderindentedComment:\n'
            '@others\n'  # The underindented comments prevents indentaion
        ),
        (2, 'def u1',
                '# Outer underindented comment\n'
                '    def u1():\n'
                '    # Underindented comment in u1.\n'
                '        pass\n'
        ),
        (1, 'def main',
                   '# About main.\n'
                   '\n'
                   'def main():\n'
                   '    pass\n'
        ),
    )
    self.new_run_test(s, expected_results)
</t>
<t tx="vitalije.20211206212507.1">def test_oneliners(self):
    s = """
        import sys
        def f1():
            pass

        class Class1:pass
        a = 2
        @dec_for_f2
        def f2(): pass


        class A: pass
        # About main.
        def main():
            pass

        if __name__ == '__main__':
            main()
    """

    # Note: new_gen_block deletes leading and trailing whitespace from all blocks.
    expected_results = (
        (0, '',  # Ignore the first headline.
                '&lt;&lt; TestPython.test_oneliners: preamble &gt;&gt;\n'
                '@others\n'
                '\n'
                "if __name__ == '__main__':\n"
                '    main()\n'
                '@language python\n'
                '@tabwidth -4\n'
        ),
        (1, '&lt;&lt; TestPython.test_oneliners: preamble &gt;&gt;',
                'import sys\n'
        ),
        (1, 'def f1',
                'def f1():\n'
                '    pass\n'
        ),
        (1, 'class Class1',
                'class Class1:pass\n'
        ),
        (1, 'def f2',
                'a = 2\n'
                '@dec_for_f2\n'
                'def f2(): pass\n'
        ),
        (1, 'class A',
                'class A: pass\n'
        ),
        (1, 'def main',
                   '# About main.\n'
                   'def main():\n'
                   '    pass\n'
        ),
    )
    self.new_run_test(s, expected_results)
</t>
<t tx="vitalije.20211207183645.1">def test_strange_indentation(self):
    s = """
        a = 1
        if 1:
         print('1')
        if 2:
          print('2')
        if 3:
           print('3')
        if 4:
            print('4')
        if 5:
            print('5')
        if 6:
            print('6')
        if 7:
            print('7')
        if 8:
            print('8')
        if 9:
            print('9')
        if 10:
            print('10')
        if 11:
            print('11')
        if 12:
            print('12')
    """
    expected_results = (
        (0, '',  # Ignore the first headline.
           'a = 1\n'
           'if 1:\n'
           " print('1')\n"
           'if 2:\n'
           "  print('2')\n"
           'if 3:\n'
           "   print('3')\n"
           'if 4:\n'
           "    print('4')\n"
           'if 5:\n'
           "    print('5')\n"
           'if 6:\n'
           "    print('6')\n"
           'if 7:\n'
           "    print('7')\n"
           'if 8:\n'
           "    print('8')\n"
           'if 9:\n'
           "    print('9')\n"
           'if 10:\n'
           "    print('10')\n"
           'if 11:\n'
           "    print('11')\n"
           'if 12:\n'
           "    print('12')\n"
           '@language python\n'
           '@tabwidth -4\n'
        ),
    )
    self.new_run_test(s, expected_results)
</t>
<t tx="vitalije.20211207185708.1">def test_only_docs(self):
    s = (
            'class A:\n'
            '    """\n'
            '    dummy doc\n'
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            "    another line\n"
            '    """\n'
            '    def __init__(self):\n'
            '        pass\n'
            '\n'
        )
    p = self.run_test(s, strict_flag=True)
    self.check_outline(p, (
        (0, '',  # check_outline ignores the first headline.
                   '@others\n'
                   '@language python\n'
                   '@tabwidth -4\n'
        ),
        (1, 'class A',
                   'class A:\n'
                   '    """\n'
                   '    dummy doc\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    another line\n'
                   '    """\n'
                   '    @others\n'
        ),
        (2, '__init__',
                   'def __init__(self):\n'
                   '    pass\n'
                   '\n'
        )
    ))
</t>
<t tx="vitalije.20211207200701.1">def test_no_methods(self):

    s = """
        class A:
            a=1
            b=2
            c=3
    """
    expected_results = (
        (0, '',  # Ignore the first headline.
               '@others\n'
               '@language python\n'
               '@tabwidth -4\n'
        ),
        (1, 'class A',
               'class A:\n'
               '    a=1\n'
               '    b=2\n'
               '    c=3\n'
        )
    )
    self.new_run_test(s, expected_results)
</t>
<t tx="vitalije.20211208210459.1">def test_strange_indentation_with_added_class_in_the_headline(self):
    self.c.config.set(None, 'bool', 'put-class-in-imported-headlines', True)
    s = (
            'if 1:\n'
            " print('1')\n"
            'if 2:\n'
            "  print('2')\n"
            'if 3:\n'
            "   print('3')\n"
            '\n'
            'class StrangeClass:\n'
            ' a = 1\n'
            ' if 1:\n'
            "  print('1')\n"
            ' if 2:\n'
            "   print('2')\n"
            ' if 3:\n'
            "    print('3')\n"
            ' if 4:\n'
            "     print('4')\n"
            ' if 5:\n'
            "     print('5')\n"
            ' if 6:\n'
            "     print('6')\n"
            ' if 7:\n'
            "     print('7')\n"
            ' if 8:\n'
            "     print('8')\n"
            ' if 9:\n'
            "     print('9')\n"
            ' if 10:\n'
            "     print('10')\n"
            ' if 11:\n'
            "     print('11')\n"
            ' if 12:\n'
            "     print('12')\n"
            ' def a(self):\n'
            '   pass\n'
        )
    p = self.run_test(s, strict_flag=True)
    self.check_outline(p, (
        (0, '',  # check_outline ignores the first headline.
                   'if 1:\n'
                   " print('1')\n"
                   'if 2:\n'
                   "  print('2')\n"
                   'if 3:\n'
                   "   print('3')\n"
                   '\n'
                   '@others\n'
                   '@language python\n'
                   '@tabwidth -4\n'
        ),
        (1, 'class StrangeClass',
                   'class StrangeClass:\n'
                   ' a = 1\n'
                   ' if 1:\n'
                   "  print('1')\n"
                   ' if 2:\n'
                   "   print('2')\n"
                   ' if 3:\n'
                   "    print('3')\n"
                   ' if 4:\n'
                   "     print('4')\n"
                   ' if 5:\n'
                   "     print('5')\n"
                   ' if 6:\n'
                   "     print('6')\n"
                   ' if 7:\n'
                   "     print('7')\n"
                   ' if 8:\n'
                   "     print('8')\n"
                   ' if 9:\n'
                   "     print('9')\n"
                   ' if 10:\n'
                   "     print('10')\n"
                   ' if 11:\n'
                   "     print('11')\n"
                   ' if 12:\n'
                   "     print('12')\n"
                   ' @others\n'
        ),
        (2, 'a',
                   'def a(self):\n'
                   '  pass\n\n'
        )
    ))
</t>
<t tx="vitalije.20211213125307.1">def test_large_class_under_indented(self):
    s = (
            'class A:\n'
            '    a=1\n'
            '    b=1\n'
            '    c=1\n'
            '    d=1\n'
            '    e=1\n'
            '    def f(self):\n'
            '        self._f = """dummy\n'
            'dummy2\n'
            'dummy3"""\n'
            '    g=1\n'
            '    h=1\n'
            '    i=1\n'
            '    j=1\n'
            '    k=1\n'
            '    l=1\n'
            '    m=1\n'
            '    n=1\n'
            '    o=1\n'
            '    p=1\n'
            '    q=1\n'
            '    r=1\n'
            '    s=1\n'
            '    t=1\n'
            '    u=1\n'
            '    v=1\n'
            '    w=1\n'
            '    x=1\n'
            '    y=1\n'
            '    x=1\n'
            '\n'
        )
    p = self.run_test(s, strict_flag=False)  # We expect perfect import to fail.
    self.check_outline(p, (
        (0, '',  # check_outline ignores the first headline.
                   '@others\n'
                   '@language python\n'
                   '@tabwidth -4\n'
        ),
        (1, 'class A',
                   'class A:\n'
                   '    a=1\n'
                   '    b=1\n'
                   '    c=1\n'
                   '    d=1\n'
                   '    e=1\n'
                   '    @others\n'
                   '    g=1\n'
                   '    h=1\n'
                   '    i=1\n'
                   '    j=1\n'
                   '    k=1\n'
                   '    l=1\n'
                   '    m=1\n'
                   '    n=1\n'
                   '    o=1\n'
                   '    p=1\n'
                   '    q=1\n'
                   '    r=1\n'
                   '    s=1\n'
                   '    t=1\n'
                   '    u=1\n'
                   '    v=1\n'
                   '    w=1\n'
                   '    x=1\n'
                   '    y=1\n'
                   '    x=1\n'
                   '\n'
        ),
        (2, 'f',
                   'def f(self):\n'
                   '    self._f = """dummy\n'
                   # '\\\\-4.dummy2\n'
                   # '\\\\-4.dummy3"""\n'
                   'dummy2\n'
                   'dummy3"""\n'
        )
    ))
</t>
<t tx="vitalije.20211213125810.1">def test_nested_classes_with_async(self):
    s = (
            'class TestCopyFile(unittest.TestCase):\n'
            '\n'
            '    _delete = False\n'
            '    a00 = 1\n'
            '    a01 = 1\n'
            '    a02 = 1\n'
            '    a03 = 1\n'
            '    a04 = 1\n'
            '    a05 = 1\n'
            '    a06 = 1\n'
            '    a07 = 1\n'
            '    a08 = 1\n'
            '    a09 = 1\n'
            '    a10 = 1\n'
            '    a11 = 1\n'
            '    a12 = 1\n'
            '    a13 = 1\n'
            '    a14 = 1\n'
            '    a15 = 1\n'
            '    a16 = 1\n'
            '    a17 = 1\n'
            '    a18 = 1\n'
            '    a19 = 1\n'
            '    a20 = 1\n'
            '    a21 = 1\n'
            '    async def a(self):\n'
            '        return await f(self)\n'
            '    class Faux(object):\n'
            '        _entered = False\n'
            '        _exited_with = None # type: tuple\n'
            '        _raised = False\n'
          )
    p = self.run_test(s, strict_flag=True)
    self.check_outline(p, (
        (0, '',  # check_outline ignores the first headline.
                   '@others\n'
                   '@language python\n'
                   '@tabwidth -4\n'
        ),
        (1, 'class TestCopyFile',
                   'class TestCopyFile(unittest.TestCase):\n'
                   '\n'
                   '    _delete = False\n'
                   '    a00 = 1\n'
                   '    a01 = 1\n'
                   '    a02 = 1\n'
                   '    a03 = 1\n'
                   '    a04 = 1\n'
                   '    a05 = 1\n'
                   '    a06 = 1\n'
                   '    a07 = 1\n'
                   '    a08 = 1\n'
                   '    a09 = 1\n'
                   '    a10 = 1\n'
                   '    a11 = 1\n'
                   '    a12 = 1\n'
                   '    a13 = 1\n'
                   '    a14 = 1\n'
                   '    a15 = 1\n'
                   '    a16 = 1\n'
                   '    a17 = 1\n'
                   '    a18 = 1\n'
                   '    a19 = 1\n'
                   '    a20 = 1\n'
                   '    a21 = 1\n'
                   '    @others\n'
        ),
        (2, 'a',
                   'async def a(self):\n'
                   '    return await f(self)\n'
        ),
        (2, 'class Faux',
                   'class Faux(object):\n'
                   '    _entered = False\n'
                   '    _exited_with = None # type: tuple\n'
                   '    _raised = False\n\n'
        )
   ))
</t>
</tnodes>
</leo_file>
