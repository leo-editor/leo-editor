#@+leo-ver=4-thin
#@+node:ekr.20081121105001.147:@thin qtNotes.txt
#@+all
#@+node:ekr.20081121105001.148: qt To do
#@+node:ekr.20090316095604.11:Urgent 4
#@+node:ekr.20081215162017.5:Support multiple body editors
#@+node:ekr.20090318091009.13:Prototype code
@color

import leo.plugins.qtGui as qtGui

f = c.frame
inner_f = f.top.ui.leo_body_inner_frame
body = qtGui.leoQtBody(f,None) # body is a leoQtFrame
w = body.widget.widget
    # body.widget is a leoQTextEditWidget
    # body.widget.widget is a QTextEdit

inner_f.layout().addWidget(w,0,1)
#@nonl
#@-node:ekr.20090318091009.13:Prototype code
#@+node:ekr.20081121105001.572: class leoQTextEditWidget
class leoQTextEditWidget (leoQtBaseTextWidget):

    @others
#@+node:ekr.20081121105001.573:Birth
#@+node:ekr.20081121105001.574:ctor
def __init__ (self,widget,name,c=None):

    # widget is a QTextEdit.

    # Init the base class.
    leoQtBaseTextWidget.__init__(self,widget,name,c=c)

    self.baseClassName='leoQTextEditWidget'

    widget.setUndoRedoEnabled(False)

    self.setConfig()
    self.setFontFromConfig()
    self.setColorFromConfig()
    # self.setScrollBarOrientation()

    # Override the mouse handler
    #### widget.mouseReleaseEvent = self.mouseReleaseEvent
#@-node:ekr.20081121105001.574:ctor
#@+node:ekr.20081121105001.575:setFontFromConfig
def setFontFromConfig (self,w=None):

    '''Set the font in the widget w (a body editor).'''

    c = self.c
    if not w: w = self.widget

    font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    # w.configure(font=font)

    # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
#@-node:ekr.20081121105001.575:setFontFromConfig
#@+node:ekr.20081121105001.576:setColorFromConfig
def setColorFromConfig (self,w=None):

    '''Set the font in the widget w (a body editor).'''

    c = self.c
    if w is None: w = self.widget

    bg = c.config.getColor("body_text_background_color") or 'white'
    try:
        pass ### w.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()

    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try:
        pass ### w.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try:
            pass ### w.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()

    sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    try:
        pass ### w.configure(selectbackground=sel_bg)
    except Exception:
        g.es("exception setting body pane text selection background color")
        g.es_exception()

    sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    try:
        pass ### w.configure(selectforeground=sel_fg)
    except Exception:
        g.es("exception setting body pane text selection foreground color")
        g.es_exception()

    # if sys.platform != "win32": # Maybe a Windows bug.
        # fg = c.config.getColor("body_cursor_foreground_color")
        # bg = c.config.getColor("body_cursor_background_color")
        # if fg and bg:
            # cursor="xterm" + " " + fg + " " + bg
            # try:
                # pass ### w.configure(cursor=cursor)
            # except:
                # import traceback ; traceback.print_exc()
#@-node:ekr.20081121105001.576:setColorFromConfig
#@+node:ekr.20081121105001.577:setConfig
def setConfig (self):

    c = self.c ; w = self.widget

    n = c.config.getInt('qt-rich-text-zoom-in')

    w.setWordWrapMode(QtGui.QTextOption.NoWrap)

    # w.zoomIn(1)
    # w.updateMicroFocus()
    if n not in (None,0):
        # This only works when there is no style sheet.
        # g.trace('zoom-in',n)
        w.zoomIn(n)
        w.updateMicroFocus()

    # tab stop in pixels - no config for this (yet)        
    w.setTabStopWidth(24)


#@-node:ekr.20081121105001.577:setConfig
#@+node:ekr.20090303095630.10:setScrollBarOrientation (QTextEdit)
# def setScrollBarOrientation (self):

    # c = self.c
    # orientation = c.config.getString(jk13ab02xy04)
#@-node:ekr.20090303095630.10:setScrollBarOrientation (QTextEdit)
#@-node:ekr.20081121105001.573:Birth
#@+node:ekr.20090322092751.1:mouseReleaseEvent (not used)
def mouseReleaseEvent (self,event):

    '''An override of the self.widget.mouseReleaseEvent,
    monkey-patched by the leoQTextEditWidget ctor.'''

    g.trace(self,event,self.widget)
    # self.c.frame.tree.endEditLabel()
    self.c.endEditing()
    event.ignore()
#@-node:ekr.20090322092751.1:mouseReleaseEvent (not used)
#@+node:ekr.20081121105001.578:Widget-specific overrides (QTextEdit)
#@+node:ekr.20090205153624.11:delete (avoid call to setAllText)
def delete(self,i,j=None):

    trace = False and not g.unitTesting
    c,w = self.c,self.widget
    colorer = c.frame.body.colorizer.highlighter.colorer
    n = colorer.recolorCount

    i = self.toGuiIndex(i)
    if j is None: j = i+1
    j = self.toGuiIndex(j)

    # Set a hook for the colorer.
    colorer.initFlag = True

    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    cursor = w.textCursor()
    cursor.setPosition(i)
    moveCount = abs(j-i)
    cursor.movePosition(cursor.Right,cursor.KeepAnchor,moveCount)
    cursor.removeSelectedText()
    sb.setSliderPosition(pos)

    if trace:
        g.trace('%s calls to recolor' % (
            colorer.recolorCount-n))
#@-node:ekr.20090205153624.11:delete (avoid call to setAllText)
#@+node:ekr.20081121105001.579:flashCharacter (leoQTextEditWidget)
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):

    # numbered color names don't work in Ubuntu 8.10, so...
    if bg[-1].isdigit() and bg[0] != '#':
        bg = bg[:-1]
    if fg[-1].isdigit() and fg[0] != '#':
        fg = fg[:-1]

    # This might causes problems during unit tests.
    # The selection point isn't restored in time.
    if g.app.unitTesting: return

    w = self.widget # A QTextEdit.
    e = QtGui.QTextCursor

    def after(func):
        QtCore.QTimer.singleShot(delay,func)

    def addFlashCallback(self=self,w=w):
        n,i = self.flashCount,self.flashIndex

        cursor = w.textCursor() # Must be the widget's cursor.
        cursor.setPosition(i)
        cursor.movePosition(e.Right,e.KeepAnchor,1)

        extra = w.ExtraSelection()
        extra.cursor = cursor
        if self.flashBg: extra.format.setBackground(QtGui.QColor(self.flashBg))
        if self.flashFg: extra.format.setForeground(QtGui.QColor(self.flashFg))
        self.extraSelList = [extra] # keep the reference.
        w.setExtraSelections(self.extraSelList)

        self.flashCount -= 1
        after(removeFlashCallback)

    def removeFlashCallback(self=self,w=w):
        w.setExtraSelections([])
        if self.flashCount > 0:
            after(addFlashCallback)
        else:
            w.setFocus()

    # g.trace(flashes,fg,bg)
    self.flashCount = flashes
    self.flashIndex = i
    self.flashBg = g.choose(bg.lower()=='same',None,bg)
    self.flashFg = g.choose(fg.lower()=='same',None,fg)

    addFlashCallback()
#@-node:ekr.20081121105001.579:flashCharacter (leoQTextEditWidget)
#@+node:ekr.20081121105001.580:getAllText (leoQTextEditWidget)
def getAllText(self):

    w = self.widget
    s = unicode(w.toPlainText())

    # Doesn't work: gets only the line containing the cursor.
    # s = unicode(w.textCursor().block().text())

    # g.trace(repr(s))
    return s
#@nonl
#@-node:ekr.20081121105001.580:getAllText (leoQTextEditWidget)
#@+node:ekr.20081121105001.581:getInsertPoint
def getInsertPoint(self):

    return self.widget.textCursor().position()
#@-node:ekr.20081121105001.581:getInsertPoint
#@+node:ekr.20081121105001.582:getSelectionRange
def getSelectionRange(self,sort=True):

    w = self.widget
    tc = w.textCursor()
    i,j = tc.selectionStart(),tc.selectionEnd()
    # g.trace(i,j,g.callers(4))
    return i,j
#@nonl
#@-node:ekr.20081121105001.582:getSelectionRange
#@+node:ekr.20081121105001.583:getYScrollPosition
def getYScrollPosition(self):

    w = self.widget
    sb = w.verticalScrollBar()
    i = sb.sliderPosition()

    # Return a tuple, only the first of which is used.
    return i,i 
#@-node:ekr.20081121105001.583:getYScrollPosition
#@+node:ekr.20081121105001.584:hasSelection
def hasSelection(self):

    return self.widget.textCursor().hasSelection()
#@-node:ekr.20081121105001.584:hasSelection
#@+node:ekr.20090205153624.12:insert (avoid call to setAllText)
def insert(self,i,s):

    trace = False and not g.unitTesting
    c,w = self.c,self.widget
    colorer = c.frame.body.colorizer.highlighter.colorer
    n = colorer.recolorCount

    # Set a hook for the colorer.
    colorer.initFlag = True

    i = self.toGuiIndex(i)

    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    cursor = w.textCursor()
    cursor.setPosition(i)
    cursor.insertText(s) # This cause an incremental call to recolor.
    sb.setSliderPosition(pos)

    if trace:
        g.trace('%s calls to recolor' % (
            colorer.recolorCount-n))
#@-node:ekr.20090205153624.12:insert (avoid call to setAllText)
#@+node:ekr.20081121105001.585:see
def see(self,i):

    self.widget.ensureCursorVisible()
#@nonl
#@-node:ekr.20081121105001.585:see
#@+node:ekr.20081121105001.586:seeInsertPoint
def seeInsertPoint (self):

    self.widget.ensureCursorVisible()
#@-node:ekr.20081121105001.586:seeInsertPoint
#@+node:ekr.20081121105001.587:setAllText
def setAllText(self,s,insert=None):

    '''Set the text of the widget.

    If insert is None, the insert point, selection range and scrollbars are initied.
    Otherwise, the scrollbars are preserved.'''

    trace = False and not g.unitTesting
    c,w = self.c,self.widget
    colorizer = c.frame.body.colorizer
    highlighter = colorizer.highlighter
    colorer = highlighter.colorer

    # Set a hook for the colorer.
    colorer.initFlag = True

    sb = w.verticalScrollBar()
    if insert is None: i,pos = 0,0
    else: i,pos = insert,sb.sliderPosition()

    if trace: t1 = g.getTime()
    w.setPlainText(s)
    if trace: g.trace(g.timeSince(t1))

    self.setSelectionRange(i,i,insert=i)
    sb.setSliderPosition(pos)
#@nonl
#@-node:ekr.20081121105001.587:setAllText
#@+node:ekr.20081121105001.588:setInsertPoint
def setInsertPoint(self,i):

    w = self.widget

    s = w.toPlainText()
    i = max(0,min(i,len(s)))
    cursor = w.textCursor()

    # block = cursor.block()
    # i = max(0,min(i,block.length()))

    cursor.setPosition(i)
    w.setTextCursor(cursor)
#@-node:ekr.20081121105001.588:setInsertPoint
#@+node:ekr.20081121105001.589:setSelectionRangeHelper & helper
def setSelectionRangeHelper(self,i,j,insert):

    w = self.widget
    # g.trace('i',i,'j',j,'insert',insert,g.callers(4))
    e = QtGui.QTextCursor
    if i > j: i,j = j,i
    n = self.lengthHelper()
    # s = w.toPlainText() ; n = len(s)
    i = max(0,min(i,n))
    j = max(0,min(j,n))
    k = max(0,min(j-i,n))
    cursor = w.textCursor()
    if i == j:
        cursor.setPosition(i)
    elif insert in (j,None):
        cursor.setPosition(i)
        cursor.movePosition(e.Right,e.KeepAnchor,k)
    else:
        cursor.setPosition(j)
        cursor.movePosition(e.Left,e.KeepAnchor,k)

    w.setTextCursor(cursor)
#@+node:ekr.20081121105001.590:lengthHelper
def lengthHelper(self):

    '''Return the length of the text.'''

    w = self.widget
    cursor = w.textCursor()
    cursor.movePosition(QtGui.QTextCursor.End)
    n = cursor.position()
    return n

#@-node:ekr.20081121105001.590:lengthHelper
#@-node:ekr.20081121105001.589:setSelectionRangeHelper & helper
#@+node:ekr.20081121105001.591:setYScrollPosition
def setYScrollPosition(self,pos):

    # g.trace('pos',pos)

    w = self.widget
    sb = w.verticalScrollBar()
    if pos is None: pos = 0
    elif type(pos) == types.TupleType:
        pos = pos[0]
    sb.setSliderPosition(pos)
#@-node:ekr.20081121105001.591:setYScrollPosition
#@-node:ekr.20081121105001.578:Widget-specific overrides (QTextEdit)
#@-node:ekr.20081121105001.572: class leoQTextEditWidget
#@+node:ekr.20081121110412.143:Editors (tkBody)
#@+node:ekr.20081121110412.144:createEditorFrame
def createEditorFrame (self,pane):

    f = Tk.Frame(pane)
    f.pack(side='top',expand=1,fill='both')
    return f
#@-node:ekr.20081121110412.144:createEditorFrame
#@+node:ekr.20081121110412.145:packEditorLabelWidget
def packEditorLabelWidget (self,w):

    '''Create a Tk label widget.'''

    if not hasattr(w,'leo_label') or not w.leo_label:
        # g.trace('w.leo_frame',id(w.leo_frame))
        w.pack_forget()
        w.leo_label = Tk.Label(w.leo_frame)
        w.leo_label.pack(side='top')
        w.pack(expand=1,fill='both')
#@nonl
#@-node:ekr.20081121110412.145:packEditorLabelWidget
#@+node:ekr.20081121110412.146:setEditorColors
def setEditorColors (self,bg,fg):

    c = self.c ; d = self.editorWidgets

    for key in d:
        w2 = d.get(key)
        # g.trace(id(w2),bg,fg)
        try:
            w2.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
#@-node:ekr.20081121110412.146:setEditorColors
#@-node:ekr.20081121110412.143:Editors (tkBody)
#@+node:ekr.20081121110412.133:tkBody.createTextWidget
def createTextWidget (self,parentFrame,p,name):

    c = self.c

    parentFrame.configure(bg='LightSteelBlue1')

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")

    # Setgrid=1 cause severe problems with the font panel.
    body = w = leoTkTextWidget (parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)

    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')

    def yscrollCallback(x,y,bodyBar=bodyBar,w=w):
        # g.trace(x,y,g.callers())
        if hasattr(w,'leo_scrollBarSpot'):
            w.leo_scrollBarSpot = (x,y)
        return bodyBar.set(x,y)

    body['yscrollcommand'] = yscrollCallback # bodyBar.set

    bodyBar['command'] =  body.yview
    bodyBar.pack(side="right", fill="y")

    # Always create the horizontal bar.
    bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview

    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")

    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)

    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v

    w.leo_active = True
    # New in Leo 4.4.4 final: inject the scrollbar items into the text widget.
    w.leo_bodyBar = bodyBar # 2007/10/31
    w.leo_bodyXBar = bodyXBar # 2007/10/31
    w.leo_chapter = None
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w
#@-node:ekr.20081121110412.133:tkBody.createTextWidget
#@+node:ekr.20081121105001.205:class leoQtBody (leoBody)
class leoQtBody (leoFrame.leoBody):

    """A class that represents the body pane of a Qt window."""

    @others
#@+node:ekr.20081121105001.206: Birth
#@+node:ekr.20081121105001.207: ctor (qtBody)
def __init__ (self,frame,parentFrame):

    trace = False and not g.unitTesting

    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)

    c = self.c
    assert c.frame == frame and frame.c == c

    self.useScintilla = c.config.getBool('qt-use-scintilla')

    # Set the actual gui widget.
    if self.useScintilla:
        self.widget = w = leoQScintillaWidget(
            c.frame.top.textEdit,
            name='body',c=c)
        self.bodyCtrl = w # The widget as seen from Leo's core.
        self.colorizer = leoColor.nullColorizer(c)
    else:
        top = c.frame.top
        sw = top.ui.stackedWidget
        qtWidget = top.ui.richTextEdit # A QTextEdit.
        sw.setCurrentIndex(1)
        self.widget = w = leoQTextEditWidget(
            qtWidget,name = 'body',c=c)
        self.bodyCtrl = w # The widget as seen from Leo's core.

        # Hook up the QSyntaxHighlighter
        self.colorizer = leoQtColorizer(c,w.widget)
        w.acceptRichText = False

    # Config stuff.
    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    wrap = c.config.getBool('body_pane_wraps')
    # g.trace('wrap',wrap,self.widget.widget)
    if self.useScintilla:
        pass
    else:
        self.widget.widget.setWordWrapMode(g.choose(wrap,
            QtGui.QTextOption.WordWrap,
            QtGui.QTextOption.NoWrap))
    wrap = g.choose(wrap,"word","none")
    self.wrapState = wrap

    # For multiple body editors.
    self.editor_name = None
    self.editor_v = None
    self.numberOfEditors = 1
    self.totalNumberOfEditors = 1

    if trace: print('qtBody.__init__ %s' % self.widget)
#@-node:ekr.20081121105001.207: ctor (qtBody)
#@+node:ekr.20081121105001.208:createBindings (qtBody)
def createBindings (self,w=None):

    '''(qtBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''

    # frame = self.frame ; c = self.c ; k = c.k
    # if not w: w = self.widget

    # c.bind(w,'<Key>', k.masterKeyHandler)

    # def onFocusOut(event,c=c):
        # # This interferes with inserting new nodes.
            # # c.k.setDefaultInputState()
        # self.setEditorColors(
            # bg=c.k.unselected_body_bg_color,
            # fg=c.k.unselected_body_fg_color)
        # # This is required, for example, when typing Alt-Shift-anyArrow in insert mode.
        # # But we suppress coloring in the widget.
        # oldState = k.unboundKeyAction
        # k.unboundKeyAction = k.defaultUnboundKeyAction
        # c.k.showStateAndMode(w=g.app.gui.get_focus(c))
        # k.unboundKeyAction = oldState

    # def onFocusIn(event,c=c):
        # # g.trace('callback')
        # c.k.setDefaultInputState()
        # c.k.showStateAndMode()  # TNB - fix color when window manager returns focus to Leo

    # c.bind(w,'<FocusOut>', onFocusOut)
    # c.bind(w,'<FocusIn>', onFocusIn)

    # table = [
        # ('<Button-1>',  frame.OnBodyClick,          k.masterClickHandler),
        # ('<Button-3>',  frame.OnBodyRClick,         k.masterClick3Handler),
        # ('<Double-1>',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        # ('<Double-3>',  None,                       k.masterDoubleClick3Handler),
        # ('<Button-2>',  frame.OnPaste,              k.masterClickHandler),
    # ]

    # table2 = (
        # ('<Button-2>',  frame.OnPaste,              k.masterClickHandler),
    # )

    # if c.config.getBool('allow_middle_button_paste'):
        # table.extend(table2)

    # for kind,func,handler in table:
        # def bodyClickCallback(event,handler=handler,func=func):
            # return handler(event,func)

        # c.bind(w,kind,bodyClickCallback)
#@-node:ekr.20081121105001.208:createBindings (qtBody)
#@+node:ekr.20081121105001.209:get_name
def getName (self):

    return 'body-widget'
#@-node:ekr.20081121105001.209:get_name
#@-node:ekr.20081121105001.206: Birth
#@+node:ekr.20081121105001.210:Do-nothings

# Configuration will be handled by style sheets.
def cget(self,*args,**keys):        return None
def configure (self,*args,**keys):  pass
def setEditorColors (self,bg,fg):   pass

def oops (self):
    g.trace('qtBody',g.callers(3))
#@-node:ekr.20081121105001.210:Do-nothings
#@+node:ekr.20081121105001.211:High-level interface to self.widget
def appendText (self,s):
    return self.widget.appendText(s)

def bind (self,kind,*args,**keys):
    return self.widget.bind(kind,*args,**keys)

def deleteTextSelection (self):
    return self.widget.deleteTextSelection()

def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):
    return self.widget(i,bg,fg,flashes,delay)

def get(self,i,j=None):
    return self.widget.get(i,j)

def getAllText (self):
    return self.widget.getAllText()

def getFocus (self):
    return self.widget.getFocus()

def getInsertPoint(self):
    return self.widget.getInsertPoint()

def getSelectedText (self):
    return self.widget.getSelectedText()

def getSelectionRange (self,sort=True):
    return self.widget.getSelectionRange(sort)

def getYScrollPosition (self):
    return self.widget.getYScrollPosition()

def insert(self,i,s):
    return self.widget.insert(i,s)

def scrollLines (self,n):
    return self.widget.scrollLines(n)

def see(self,index):
    return self.widget.see(index)

def seeInsertPoint(self):
    return self.widget.seeInsertPoint()

def setAllText (self,s):
    return self.widget.setAllText(s)

def setBackgroundColor (self,color):
    return self.widget.setBackgroundColor(color)

def setFocus (self):
    return self.widget.setFocus()

def setForegroundColor (self,color):
    return self.widget.setForegroundColor(color)

def setInsertPoint (self,pos):
    return self.widget.setInsertPoint(pos)

def setSelectionRange (self,sel):
    i,j = sel
    return self.widget.setSelectionRange(i,j)

def setYScrollPosition (self,i):
    return self.widget.setYScrollPosition(i)
#@-node:ekr.20081121105001.211:High-level interface to self.widget
#@+node:ekr.20081121105001.212:Editors (qtBody)
#@+node:ekr.20081121105001.214:packEditorLabelWidget
def packEditorLabelWidget (self,w):

    '''Create a Tk label widget.'''

    # if not hasattr(w,'leo_label') or not w.leo_label:
        # # g.trace('w.leo_frame',id(w.leo_frame))
        # w.pack_forget()
        # w.leo_label = Tk.Label(w.leo_frame)
        # w.leo_label.pack(side='top')
        # w.pack(expand=1,fill='both')
#@nonl
#@-node:ekr.20081121105001.214:packEditorLabelWidget
#@+node:ekr.20081121105001.215:entries
if 1:
    @others
#@nonl
#@+node:ekr.20081121105001.216:addEditor & helpers (qtBody)
# An override of leoFrame.addEditor.

def addEditor (self,event=None):

    '''Add another editor to the body pane.'''

    trace = True and not g.unitTesting

    bodyCtrl = self.c.frame.body.bodyCtrl # A leoQTextEditWidget
    self.editorWidgets['1'] = bodyCtrl
    c = self.c ; p = c.currentPosition()
    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1

    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        # The name of the last editor need not be '1'
        d = self.editorWidgets ; keys = d.keys()
        if len(keys) == 1:
            w_old = d.get(keys[0])
            if trace: g.trace('w_old',w_old)
            self.updateInjectedIvars(w_old,p)
            self.selectLabel(w_old) # Immediately create the label in the old editor.
        else:
            g.trace('can not happen: unexpected editorWidgets',d)

    name = '%d' % self.totalNumberOfEditors

    f,w = self.createEditorFrame()
    self.createEditorWidget(f,name,p,w)
    self.editorWidgets[name] = w

    # for pane in panes:
        # self.pb.configurepane(pane,size=minSize)

    # self.pb.updatelayout()
    if trace: g.trace('w',w)
    c.frame.body.bodyCtrl = w

    self.updateInjectedIvars(w,p)
    self.selectLabel(w)
    self.selectEditor(w)
    self.updateEditors()
    c.bodyWantsFocusNow()
#@+node:ekr.20081121105001.213:createEditorFrame
def createEditorFrame (self):

    f = self.c.frame
    inner_f = f.top.ui.leo_body_inner_frame
    body = leoQtBody(f,None)
    w = body.widget.widget

    inner_f.layout().addWidget(w,0,1)
    w.setFocus()

    return inner_f,body.widget
#@-node:ekr.20081121105001.213:createEditorFrame
#@+node:ekr.20081121105001.217:createEditorWidget
def createEditorWidget (self,f,name,p,w):

    trace = False and not g.unitTesting
    c = self.c

    if trace: g.trace(p.h,w)
    #### w = self.createTextWidget(f,name,p,w)
    self.updateInjectedIvars(w,p)
    w.delete(0,'end')
    w.insert('end',p.bodyString())
    w.see(0)
    ##self.setFontFromConfig(w=w)
    ##self.setColorFromConfig(w=w)
    self.createBindings(w=w)
    c.k.completeAllBindingsForWidget(w)
    self.recolorWidget(p,w)

    #### return w
#@-node:ekr.20081121105001.217:createEditorWidget
#@+node:ekr.20090318091009.14:createTextWidget (not used)
def createTextWidget (self,parentFrame,name,p,w):

    c = self.c

    # # parentFrame.configure(bg='LightSteelBlue1')

    # # wrap = c.config.getBool('body_pane_wraps')
    # # wrap = g.choose(wrap,"word","none")

    # Setgrid=1 cause severe problems with the font panel.
    #### w = leoQTextEditWidget (widget,name,c)


    # # bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')

    # # def yscrollCallback(x,y,bodyBar=bodyBar,w=w):
        # # # g.trace(x,y,g.callers())
        # # if hasattr(w,'leo_scrollBarSpot'):
            # # w.leo_scrollBarSpot = (x,y)
        # # return bodyBar.set(x,y)

    # # body['yscrollcommand'] = yscrollCallback # bodyBar.set

    # # bodyBar['command'] =  body.yview
    # # bodyBar.pack(side="right", fill="y")

    # # # Always create the horizontal bar.
    # # bodyXBar = Tk.Scrollbar(
        # # parentFrame,name='bodyXBar',orient="horizontal")
    # # body['xscrollcommand'] = bodyXBar.set
    # # bodyXBar['command'] = body.xview

    # # if wrap == "none":
        # # # g.trace(parentFrame)
        # # bodyXBar.pack(side="bottom", fill="x")

    # # body.pack(expand=1,fill="both")

    # # self.wrapState = wrap

    # # if 0: # Causes the cursor not to blink.
        # # body.configure(insertofftime=0)

    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v

    w.leo_active = True
    # New in Leo 4.4.4 final: inject the scrollbar items into the text widget.
    w.leo_bodyBar = None #### bodyBar # 2007/10/31
    w.leo_bodyXBar = None #### bodyXBar # 2007/10/31
    w.leo_chapter = None
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    #### return w
#@-node:ekr.20090318091009.14:createTextWidget (not used)
#@-node:ekr.20081121105001.216:addEditor & helpers (qtBody)
#@+node:ekr.20081121105001.218:assignPositionToEditor
def assignPositionToEditor (self,p):

    '''Called *only* from tree.select to select the present body editor.'''

    c = self.c ; cc = c.chapterController ; w = c.frame.body.bodyCtrl

    # self.updateInjectedIvars(w,p)
    # self.selectLabel(w)

    # g.trace('===',id(w),w.leo_chapter.name,w.leo_p.h)
#@-node:ekr.20081121105001.218:assignPositionToEditor
#@+node:ekr.20081121105001.219:cycleEditorFocus
def cycleEditorFocus (self,event=None):

    '''Cycle keyboard focus between the body text editors.'''

    # c = self.c ; d = self.editorWidgets ; w = c.frame.body.bodyCtrl
    # values = d.values()
    # if len(values) > 1:
        # i = values.index(w) + 1
        # if i == len(values): i = 0
        # w2 = d.values()[i]
        # assert(w!=w2)
        # self.selectEditor(w2)
        # c.frame.body.bodyCtrl = w2
        # # g.pr('***',g.app.gui.widget_name(w2),id(w2))

    # return 'break'
#@-node:ekr.20081121105001.219:cycleEditorFocus
#@+node:ekr.20081121105001.220:deleteEditor
def deleteEditor (self,event=None):

    '''Delete the presently selected body text editor.'''

    # c = self.c ; w = c.frame.body.bodyCtrl ; d = self.editorWidgets

    # if len(d.keys()) == 1: return

    # name = w.leo_name

    # del d [name] 
    # self.pb.delete(name)
    # panes = self.pb.panes()
    # minSize = float(1.0/float(len(panes)))

    # for pane in panes:
        # self.pb.configurepane(pane,size=minSize)

    # # Select another editor.
    # w = d.values()[0]
    # # c.frame.body.bodyCtrl = w # Don't do this now?
    # self.numberOfEditors -= 1
    # self.selectEditor(w)
#@-node:ekr.20081121105001.220:deleteEditor
#@+node:ekr.20081121105001.221:findEditorForChapter (leoBody)
def findEditorForChapter (self,chapter,p):

    '''Return an editor to be assigned to chapter.'''

    return self.c.frame.body.bodyCtrl

    # c = self.c ; d = self.editorWidgets ; values = d.values()

    # # First, try to match both the chapter and position.
    # if p:
        # for w in values:
            # if (
                # hasattr(w,'leo_chapter') and w.leo_chapter == chapter and
                # hasattr(w,'leo_p') and w.leo_p and w.leo_p == p
            # ):
                # # g.trace('***',id(w),'match chapter and p',p.h)
                # return w

    # # Next, try to match just the chapter.
    # for w in values:
        # if hasattr(w,'leo_chapter') and w.leo_chapter == chapter:
            # # g.trace('***',id(w),'match only chapter',p.h)
            # return w

    # # As a last resort, return the present editor widget.
    # # g.trace('***',id(self.bodyCtrl),'no match',p.h)
    # return c.frame.body.bodyCtrl
#@-node:ekr.20081121105001.221:findEditorForChapter (leoBody)
#@+node:ekr.20081121105001.222:select/unselectLabel
def unselectLabel (self,w):

    pass

    # self.createChapterIvar(w)
    # self.packEditorLabelWidget(w)
    # s = self.computeLabel(w)
    # if hasattr(w,'leo_label') and w.leo_label:
        # w.leo_label.configure(text=s,bg='LightSteelBlue1')

def selectLabel (self,w):

    pass

    # if self.numberOfEditors > 1:
        # self.createChapterIvar(w)
        # self.packEditorLabelWidget(w)
        # s = self.computeLabel(w)
        # # g.trace(s,g.callers())
        # if hasattr(w,'leo_label') and w.leo_label:
            # w.leo_label.configure(text=s,bg='white')
    # elif hasattr(w,'leo_label') and w.leo_label:
        # w.leo_label.pack_forget()
        # w.leo_label = None
#@-node:ekr.20081121105001.222:select/unselectLabel
#@+node:ekr.20081121105001.223:selectEditor & helpers
selectEditorLockout = False

def selectEditor(self,w):

    '''Select editor w and node w.leo_p.'''

    return self.c.frame.body.bodyCtrl

    #  Called by body.onClick and whenever w must be selected.
    # trace = False
    # c = self.c
    # if not w: return self.c.frame.body.bodyCtrl
    # if self.selectEditorLockout: return

    # if w and w == self.c.frame.body.bodyCtrl:
        # if w.leo_p and w.leo_p != c.currentPosition():
            # c.selectPosition(w.leo_p)
            # c.bodyWantsFocusNow()
        # return

    # try:
        # val = None
        # self.selectEditorLockout = True
        # val = self.selectEditorHelper(w)
    # finally:
        # self.selectEditorLockout = False

    # return val # Don't put a return in a finally clause.
#@+node:ekr.20081121105001.224:selectEditorHelper
def selectEditorHelper (self,w):

    c = self.c ; cc = c.chapterController ; d = self.editorWidgets

    trace = False

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    if trace:
        g.trace('==1',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.h)

    self.inactivateActiveEditor(w)

    # The actual switch.
    c.frame.body.bodyCtrl = w
    w.leo_active = True

    self.switchToChapter(w)
    self.selectLabel(w)

    if not self.ensurePositionExists(w):
        g.trace('***** no position editor!')
        return 'break'

    if trace:
        g.trace('==2',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.h)

    # g.trace('expanding ancestors of ',w.leo_p.h,g.callers())
    c.expandAllAncestors(w.leo_p)
    c.selectPosition(w.leo_p) # Calls assignPositionToEditor.
    c.redraw()

    c.recolor_now()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocusNow()
    return 'break'
#@+node:ekr.20081121105001.225:<< restore the selection, insertion point and the scrollbar >>
# g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    w.setInsertPoint(w.leo_insertSpot)
else:
    w.setInsertPoint(0)

if w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)
else:
    w.seeInsertPoint()

if w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass
#@-node:ekr.20081121105001.225:<< restore the selection, insertion point and the scrollbar >>
#@-node:ekr.20081121105001.224:selectEditorHelper
#@-node:ekr.20081121105001.223:selectEditor & helpers
#@+node:ekr.20081121105001.226:updateEditors
# Called from addEditor and assignPositionToEditor

def updateEditors (self):

    pass

    # c = self.c ; p = c.currentPosition()
    # d = self.editorWidgets
    # if len(d.keys()) < 2: return # There is only the main widget.

    # for key in d:
        # w = d.get(key)
        # v = w.leo_v
        # if v and v == p.v and w != c.frame.body.bodyCtrl:
            # w.delete(0,'end')
            # w.insert('end',p.bodyString())
            # # g.trace('update',w,v)
            # self.recolorWidget(p,w)

    # c.bodyWantsFocus()
#@-node:ekr.20081121105001.226:updateEditors
#@-node:ekr.20081121105001.215:entries
#@+node:ekr.20081121105001.227:utils
#@+node:ekr.20081121105001.228:computeLabel
def computeLabel (self,w):

    s = w.leo_label_s

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        s = '%s: %s' % (w.leo_chapter.name,s)

    return s
#@-node:ekr.20081121105001.228:computeLabel
#@+node:ekr.20081121105001.229:createChapterIvar
def createChapterIvar (self,w):

    c = self.c ; cc = c.chapterController

    if not hasattr(w,'leo_chapter') or not w.leo_chapter:
        if cc and self.use_chapters:
            w.leo_chapter = cc.getSelectedChapter()
        else:
            w.leo_chapter = None
#@-node:ekr.20081121105001.229:createChapterIvar
#@+node:ekr.20081121105001.230:ensurePositionExists
def ensurePositionExists(self,w):

    '''Return True if w.leo_p exists or can be reconstituted.'''

    c = self.c

    if c.positionExists(w.leo_p):
        return True
    else:
        g.trace('***** does not exist',w.leo_name)
        for p2 in c.all_positions_with_unique_vnodes_iter():
            if p2.v and p2.v == w.leo_v:
                w.leo_p = p2.copy()
                return True
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            return False
#@-node:ekr.20081121105001.230:ensurePositionExists
#@+node:ekr.20081121105001.231:inactivateActiveEditor
def inactivateActiveEditor(self,w):

    '''Inactivate the previously active editor.'''

    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.yview()
            w2.leo_insertSpot = w2.getInsertPoint()
            w2.leo_selection = w2.getSelectionRange()
            # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
            # g.trace('inactivate',id(w2))
            return
#@-node:ekr.20081121105001.231:inactivateActiveEditor
#@+node:ekr.20081121105001.232:recolorWidget
def recolorWidget (self,p,w):

    c = self.c ; old_w = c.frame.body.bodyCtrl

    # g.trace('w',id(w),p.h,len(w.getAllText()))

    # Save.
    c.frame.body.bodyCtrl = w
    try:
        # c.recolor_now(interruptable=False) # Force a complete recoloring.
        c.frame.body.colorizer.colorize(p,incremental=False,interruptable=False)
    finally:
        # Restore.
        c.frame.body.bodyCtrl = old_w
#@-node:ekr.20081121105001.232:recolorWidget
#@+node:ekr.20081121105001.233:switchToChapter (leoBody)
def switchToChapter (self,w):

    '''select w.leo_chapter.'''

    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            # g.trace('===','old',oldChapter.name,'new',name,w.leo_p)
            cc.selectChapterByName(name)
            c.bodyWantsFocusNow()
#@-node:ekr.20081121105001.233:switchToChapter (leoBody)
#@+node:ekr.20081121105001.234:updateInjectedIvars
# Called from addEditor and assignPositionToEditor.

def updateInjectedIvars (self,w,p):

    c = self.c ; cc = c.chapterController

    if cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None

    w.leo_p = p.copy()
    w.leo_v = w.leo_p.v
    w.leo_label_s = p.h

    # g.trace('   ===', id(w),w.leo_chapter and w.leo_chapter.name,p.h)
#@-node:ekr.20081121105001.234:updateInjectedIvars
#@-node:ekr.20081121105001.227:utils
#@-node:ekr.20081121105001.212:Editors (qtBody)
#@-node:ekr.20081121105001.205:class leoQtBody (leoBody)
#@+node:ekr.20081121105001.249:class leoQtFrame
class leoQtFrame (leoFrame.leoFrame):

    """A class that represents a Leo window rendered in qt."""

    @others
#@+node:ekr.20081121105001.250: Birth & Death (qtFrame)
#@+node:ekr.20081121105001.251:__init__ (qtFrame)
def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title
    self.initComplete = False # Set by initCompleteHint().
    leoQtFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBarClass = self.qtIconBarClass
    self.statusLineClass = self.qtStatusLineClass
    self.iconBar = None

    self.trace_status_line = None # Set in finishCreate.

    << set the leoQtFrame ivars >>

    self.minibufferVisible = True
#@+node:ekr.20081121105001.252:<< set the leoQtFrame ivars >> (removed frame.bodyCtrl ivar)
# "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None # This will be a class Window object.
self.tree = None
# self.treeBar = None # Replaced by injected frame.canvas.leo_treeBar.

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None
#@-node:ekr.20081121105001.252:<< set the leoQtFrame ivars >> (removed frame.bodyCtrl ivar)
#@-node:ekr.20081121105001.251:__init__ (qtFrame)
#@+node:ekr.20081121105001.253:__repr__ (qtFrame)
def __repr__ (self):

    return "<leoQtFrame: %s>" % self.title
#@-node:ekr.20081121105001.253:__repr__ (qtFrame)
#@+node:ekr.20081121105001.254:qtFrame.finishCreate & helpers
def finishCreate (self,c):

    f = self ; f.c = c

    # g.trace('***qtFrame')

    self.bigTree           = c.config.getBool('big_outline_pane')
    self.trace_status_line = c.config.getBool('trace_status_line')
    self.use_chapters      = c.config.getBool('use_chapters')
    self.use_chapter_tabs  = c.config.getBool('use_chapter_tabs')

    # xx todo
    f.top = DynamicWindow(c)
    g.app.gui.attachLeoIcon(f.top)
    f.top.setWindowTitle(self.title)
    f.top.show()

    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    # # f.createOuterFrames()
    f.createIconBar() # A base class method.
    # # f.createLeoSplitters(f.outerFrame)
    f.createSplitterComponents()
    f.createStatusLine() # A base class method.
    f.createFirstTreeNode() # Call the base-class method.
    f.menu = leoQtMenu(f)
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = leoQtMinibuffer(c)
    c.bodyWantsFocusNow()
#@+node:ekr.20081121105001.255:createSplitterComponents (qtFrame)
def createSplitterComponents (self):

    f = self ; c = f.c

    f.tree  = leoQtTree(c,f)
    f.log   = leoQtLog(f,None)
    f.body  = leoQtBody(f,None)

    if f.use_chapters:
        c.chapterController = cc = leoChapters.chapterController(c)

    # # Create the canvas, tree, log and body.
    # if f.use_chapters:
        # c.chapterController = cc = leoChapters.chapterController(c)

    # # split1.pane1 is the secondary splitter.

    # if self.bigTree: # Put outline in the main splitter.
        # if self.use_chapters and self.use_chapter_tabs:
            # cc.tt = leoQtTreeTab(c,f.split1Pane2,cc)
        # f.canvas = f.createCanvas(f.split1Pane1)
        # f.tree  = leoQtTree(c,f,f.canvas)
        # f.log   = leoQtLog(f,f.split2Pane2)
        # f.body  = leoQtBody(f,f.split2Pane1)
    # else:
        # if self.use_chapters and self.use_chapter_tabs:
            # cc.tt = leoQtTreeTab(c,f.split2Pane1,cc)
        # f.canvas = f.createCanvas(f.split2Pane1)
        # f.tree   = leoQtTree(c,f,f.canvas)
        # f.log    = leoQtLog(f,f.split2Pane2)
        # f.body   = leoQtBody(f,f.split1Pane2)

    # # Yes, this an "official" ivar: this is a kludge.
    # # f.bodyCtrl = f.body.bodyCtrl

    # # Configure.
    # f.setTabWidth(c.tab_width)
    # f.reconfigurePanes()
    # f.body.setFontFromConfig()
    # f.body.setColorFromConfig()
#@-node:ekr.20081121105001.255:createSplitterComponents (qtFrame)
#@-node:ekr.20081121105001.254:qtFrame.finishCreate & helpers
#@+node:ekr.20081121105001.256:initCompleteHint
def initCompleteHint (self):

    '''A kludge: called to enable text changed events.'''

    self.initComplete = True
    # g.trace(self.c)
#@-node:ekr.20081121105001.256:initCompleteHint
#@+node:ekr.20081121105001.257:Destroying the qtFrame
#@+node:ekr.20081121105001.258:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c

    # g.printGcAll()

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    if 1:
        # Destroy all ivars in subcommanders.
        g.clearAllIvars(c.atFileCommands)
        if c.chapterController: # New in Leo 4.4.3 b1.
            g.clearAllIvars(c.chapterController)
        g.clearAllIvars(c.fileCommands)
        g.clearAllIvars(c.keyHandler) # New in Leo 4.4.3 b1.
        g.clearAllIvars(c.importCommands)
        g.clearAllIvars(c.tangleCommands)
        g.clearAllIvars(c.undoer)
        g.clearAllIvars(c)
    if 0: # No need.
        tree = frame.tree ; body = self.body
        g.clearAllIvars(body.colorizer)
        g.clearAllIvars(body)
        g.clearAllIvars(tree)

#@+node:ekr.20081121105001.259:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.all_positions_with_unique_vnodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if key not in tDict:
            tDict[key] = p.v.t

for key in tDict:
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@-node:ekr.20081121105001.259:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20081121105001.258:destroyAllObjects
#@+node:ekr.20081121105001.260:destroySelf (qtFrame)
def destroySelf (self):

    # Remember these: we are about to destroy all of our ivars!
    c,top = self.c,self.top 

    # Indicate that the commander is no longer valid.
    c.exists = False

    if 0: # We can't do this unless we unhook the event filter.
        # Destroys all the objects of the commander.
        self.destroyAllObjects()

    c.exists = False # Make sure this one ivar has not been destroyed.

    # g.trace('qtFrame',c,g.callers(4))
    top.close()

#@-node:ekr.20081121105001.260:destroySelf (qtFrame)
#@-node:ekr.20081121105001.257:Destroying the qtFrame
#@-node:ekr.20081121105001.250: Birth & Death (qtFrame)
#@+node:ekr.20081121105001.261:class qtStatusLineClass (qtFrame)
class qtStatusLineClass:

    '''A class representing the status line.'''

    @others
#@+node:ekr.20081121105001.262:ctor
def __init__ (self,c,parentFrame):

    self.c = c
    self.statusBar = c.frame.top.statusBar
    self.lastFcol= 0
    self.lastRow = 0
    self.lastCol = 0

    # Create the text widgets.
    self.textWidget1 = w1 = QtGui.QLineEdit(self.statusBar)
    self.textWidget2 = w2 = QtGui.QLineEdit(self.statusBar)
    w1.setObjectName('status1')
    w2.setObjectName('status2')
    self.statusBar.addWidget(w1,True)
    self.statusBar.addWidget(w2,True)
    self.put('')
    self.update()
    c.frame.top.setStyleSheets()
#@-node:ekr.20081121105001.262:ctor
#@+node:ekr.20081121105001.263: do-nothings
def disable (self,background=None): pass
def enable(self,background="white"):pass
def getFrame (self):                return None
def isEnabled(self):                return True
def onActivate (self,event=None):   pass
def pack (self):                    pass
def setBindings (self):             pass
def unpack (self):                  pass

hide = unpack
show = pack

#@-node:ekr.20081121105001.263: do-nothings
#@+node:ekr.20081121105001.264:clear, get & put/1
def clear (self):
    self.put('')

def get (self):
    return self.textWidget2.text()

def put(self,s,color=None):
    self.put_helper(s,self.textWidget2)

def put1(self,s,color=None):
    self.put_helper(s,self.textWidget1)

def put_helper(self,s,w):
    # w.setEnabled(True)
    w.setText(s)
    # w.setEnabled(False)
#@-node:ekr.20081121105001.264:clear, get & put/1
#@+node:ekr.20081121105001.265:update
def update (self):

    if g.app.killed: return
    c = self.c ; body = c.frame.body
    s = body.getAllText()
    i = body.getInsertPoint()
    # Compute row,col & fcol
    row,col = g.convertPythonIndexToRowCol(s,i)
    if col > 0:
        s2 = s[i-col:i]
        s2 = g.toUnicode(s2,g.app.tkEncoding)
        col = g.computeWidth (s2,c.tab_width)
    fcol = col + c.currentPosition().textOffset()
    self.put1(
        "line: %d, col: %d, fcol: %d" % (row,col,fcol))
    self.lastRow = row
    self.lastCol = col
    self.lastFcol = fcol
#@-node:ekr.20081121105001.265:update
#@-node:ekr.20081121105001.261:class qtStatusLineClass (qtFrame)
#@+node:ekr.20081121105001.266:class qtIconBarClass
class qtIconBarClass:

    '''A class representing the singleton Icon bar'''

    @others
#@+node:ekr.20081121105001.267: ctor
def __init__ (self,c,parentFrame):

    self.c = c
    self.parentFrame = parentFrame
    self.w = c.frame.top.iconBar # A QToolBar.
    self.actions = []

    # g.app.iconWidgetCount = 0
#@-node:ekr.20081121105001.267: ctor
#@+node:ekr.20081121105001.268: do-nothings
def addRow(self,height=None):   pass
def getFrame (self):            return None
def getNewFrame (self):         return None
def pack (self):                pass
def unpack (self):              pass

hide = unpack
show = pack
#@-node:ekr.20081121105001.268: do-nothings
#@+node:ekr.20081121105001.269:add
def add(self,*args,**keys):

    '''Add a button to the icon bar.'''

    c = self.c
    command = keys.get('command')
    text = keys.get('text')
    if not text: return

    # imagefile = keys.get('imagefile')
    # image = keys.get('image')

    action = self.w.addAction(text)

    self.actions.append(action)
    b = self.w.widgetForAction(action)

    #b = QtGui.QPushButton(text,self.w)
    #b.leo_buttonAction = self.addWidget(b)

    b.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)

    def delete_callback(action=action,):
        self.w.removeAction(action)

    b.leo_removeAction = rb = QtGui.QAction('Remove Button' ,b)
    b.addAction(rb)
    rb.connect(rb, QtCore.SIGNAL("triggered()"), delete_callback)

    if command:
        def button_callback(c=c,command=command):
            g.trace('command',command.__name__)
            val = command()
            if c.exists:
                c.bodyWantsFocus()
                c.outerUpdate()
            return val

        self.w.connect(action,
            QtCore.SIGNAL("triggered()"),
            button_callback)

    return action
#@-node:ekr.20081121105001.269:add
#@+node:ekr.20081121105001.270:addRowIfNeeded
def addRowIfNeeded (self):

    '''Add a new icon row if there are too many widgets.'''

    # n = g.app.iconWidgetCount

    # if n >= self.widgets_per_row:
        # g.app.iconWidgetCount = 0
        # self.addRow()

    # g.app.iconWidgetCount += 1
#@-node:ekr.20081121105001.270:addRowIfNeeded
#@+node:ekr.20081121105001.271:addWidget
def addWidget (self,w):

    self.w.addWidget(w)
#@-node:ekr.20081121105001.271:addWidget
#@+node:ekr.20081121105001.272:clear
def clear(self):

    """Destroy all the widgets in the icon bar"""

    self.w.clear()
    self.actions = []

    g.app.iconWidgetCount = 0
#@-node:ekr.20081121105001.272:clear
#@+node:ekr.20081121105001.273:deleteButton
def deleteButton (self,w):
    """ w is button """

    #g.trace(w, '##')    

    self.w.removeAction(w)

    self.c.bodyWantsFocus()
    self.c.outerUpdate()
#@-node:ekr.20081121105001.273:deleteButton
#@+node:ekr.20081121105001.274:setCommandForButton
def setCommandForButton(self,button,command):

    if command:
        QtCore.QObject.connect(button,
            QtCore.SIGNAL("triggered()"),command)
#@-node:ekr.20081121105001.274:setCommandForButton
#@-node:ekr.20081121105001.266:class qtIconBarClass
#@+node:ekr.20081121105001.275:Minibuffer methods
#@+node:ekr.20081121105001.276:showMinibuffer
def showMinibuffer (self):

    '''Make the minibuffer visible.'''

    # frame = self

    # if not frame.minibufferVisible:
        # frame.minibufferFrame.pack(side='bottom',fill='x')
        # frame.minibufferVisible = True
#@-node:ekr.20081121105001.276:showMinibuffer
#@+node:ekr.20081121105001.277:hideMinibuffer
def hideMinibuffer (self):

    '''Hide the minibuffer.'''

    # frame = self

    # if frame.minibufferVisible:
        # frame.minibufferFrame.pack_forget()
        # frame.minibufferVisible = False
#@-node:ekr.20081121105001.277:hideMinibuffer
#@+node:ekr.20081121105001.278:f.setMinibufferBindings
def setMinibufferBindings (self):

    '''Create bindings for the minibuffer..'''

    pass
#@-node:ekr.20081121105001.278:f.setMinibufferBindings
#@-node:ekr.20081121105001.275:Minibuffer methods
#@+node:ekr.20081121105001.279:Configuration (qtFrame)
#@+node:ekr.20081121105001.280:configureBar (qtFrame)
def configureBar (self,bar,verticalFlag):

    c = self.c

    # Get configuration settings.
    w = c.config.getInt("split_bar_width")
    if not w or w < 1: w = 7
    relief = c.config.get("split_bar_relief","relief")
    if not relief: relief = "flat"
    color = c.config.getColor("split_bar_color")
    if not color: color = "LightSteelBlue2"

    try:
        if verticalFlag:
            # Panes arranged vertically; horizontal splitter bar
            bar.configure(relief=relief,height=w,bg=color,cursor="sb_v_double_arrow")
        else:
            # Panes arranged horizontally; vertical splitter bar
            bar.configure(relief=relief,width=w,bg=color,cursor="sb_h_double_arrow")
    except: # Could be a user error. Use all defaults
        g.es("exception in user configuration for splitbar")
        g.es_exception()
        if verticalFlag:
            # Panes arranged vertically; horizontal splitter bar
            bar.configure(height=7,cursor="sb_v_double_arrow")
        else:
            # Panes arranged horizontally; vertical splitter bar
            bar.configure(width=7,cursor="sb_h_double_arrow")
#@-node:ekr.20081121105001.280:configureBar (qtFrame)
#@+node:ekr.20081121105001.281:configureBarsFromConfig (qtFrame)
def configureBarsFromConfig (self):

    c = self.c

    w = c.config.getInt("split_bar_width")
    if not w or w < 1: w = 7

    relief = c.config.get("split_bar_relief","relief")
    if not relief or relief == "": relief = "flat"

    color = c.config.getColor("split_bar_color")
    if not color or color == "": color = "LightSteelBlue2"

    if self.splitVerticalFlag:
        bar1,bar2=self.bar1,self.bar2
    else:
        bar1,bar2=self.bar2,self.bar1

    try:
        bar1.configure(relief=relief,height=w,bg=color)
        bar2.configure(relief=relief,width=w,bg=color)
    except: # Could be a user error.
        g.es("exception in user configuration for splitbar")
        g.es_exception()
#@-node:ekr.20081121105001.281:configureBarsFromConfig (qtFrame)
#@+node:ekr.20081121105001.282:reconfigureFromConfig (qtFrame)
def reconfigureFromConfig (self):

    frame = self ; c = frame.c

    frame.tree.setFontFromConfig()
    frame.configureBarsFromConfig()

    frame.body.setFontFromConfig()
    frame.body.setColorFromConfig()

    frame.setTabWidth(c.tab_width)
    frame.log.setFontFromConfig()
    frame.log.setColorFromConfig()

    c.redraw()
#@-node:ekr.20081121105001.282:reconfigureFromConfig (qtFrame)
#@+node:ekr.20081121105001.283:setInitialWindowGeometry (qtFrame)
def setInitialWindowGeometry(self):

    """Set the position and size of the frame to config params."""

    c = self.c

    h = c.config.getInt("initial_window_height") or 500
    w = c.config.getInt("initial_window_width") or 600
    x = c.config.getInt("initial_window_left") or 10
    y = c.config.getInt("initial_window_top") or 10

    if h and w and x and y:
        self.setTopGeometry(w,h,x,y)
#@-node:ekr.20081121105001.283:setInitialWindowGeometry (qtFrame)
#@+node:ekr.20081121105001.284:setTabWidth (qtFrame)
def setTabWidth (self, w):

    return

    # try: # This can fail when called from scripts
        # # Use the present font for computations.
        # font = self.body.bodyCtrl.cget("font") # 2007/10/27
        # root = g.app.root # 4/3/03: must specify root so idle window will work properly.
        # font = tkFont.Font(root=root,font=font)
        # tabw = font.measure(" " * abs(w)) # 7/2/02
        # self.body.bodyCtrl.configure(tabs=tabw)
        # self.tab_width = w
        # # g.trace(w,tabw)
    # except:
        # g.es_exception()
#@-node:ekr.20081121105001.284:setTabWidth (qtFrame)
#@+node:ekr.20081121105001.285:setWrap (qtFrame)
def setWrap (self,p):

    c = self.c
    theDict = c.scanAllDirectives(p)
    if not theDict: return

    return

    # wrap = theDict.get("wrap")
    # if self.body.wrapState == wrap: return

    # self.body.wrapState = wrap
    # w = self.body.bodyCtrl

    # # g.trace(wrap)
    # if wrap:
        # w.configure(wrap="word") # 2007/10/25
        # w.leo_bodyXBar.pack_forget() # 2007/10/31
    # else:
        # w.configure(wrap="none")
        # # Bug fix: 3/10/05: We must unpack the text area to make the scrollbar visible.
        # w.pack_forget()  # 2007/10/25
        # w.leo_bodyXBar.pack(side="bottom", fill="x") # 2007/10/31
        # w.pack(expand=1,fill="both")  # 2007/10/25
#@-node:ekr.20081121105001.285:setWrap (qtFrame)
#@+node:ekr.20081121105001.286:reconfigurePanes (use config bar_width) (qtFrame)
def reconfigurePanes (self):

    return

    # c = self.c

    # border = c.config.getInt('additional_body_text_border')
    # if border == None: border = 0

    # # The body pane needs a _much_ bigger border when tiling horizontally.
    # border = g.choose(self.splitVerticalFlag,2+border,6+border)
    # self.body.bodyCtrl.configure(bd=border) # 2007/10/25

    # # The log pane needs a slightly bigger border when tiling vertically.
    # border = g.choose(self.splitVerticalFlag,4,2) 
    # self.log.configureBorder(border)
#@-node:ekr.20081121105001.286:reconfigurePanes (use config bar_width) (qtFrame)
#@+node:ekr.20081121105001.287:resizePanesToRatio (qtFrame)
def resizePanesToRatio(self,ratio,ratio2):

    #g.trace(ratio,ratio2,g.callers())

    self.divideLeoSplitter(self.splitVerticalFlag,ratio)
    self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@-node:ekr.20081121105001.287:resizePanesToRatio (qtFrame)
#@+node:leohag.20081208130321.12:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, self.top.splitter_2 )

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, self.top.ui.splitter)

#@-node:leohag.20081208130321.12:divideLeoSplitter
#@+node:leohag.20081208130321.13:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, splitter ):#verticalFlag, bar, pane1, pane2):

    sizes = splitter.sizes()

    if len(sizes)!=2:
        g.trace('there must be two and only two widgets in the splitter')

    if frac > 1 or frac < 0:
        g.trace('split ratio [%s] out of range 0 <= frac <= 1'%frac)

    s1, s2 = sizes
    s = s1+s2
    s1 = int(s * frac + 0.5)
    s2 = s - s1 

    splitter.setSizes([s1,s2])

@
    # if self.bigTree:
        # pane1,pane2 = pane2,pane1

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@-node:leohag.20081208130321.13:divideAnySplitter
#@-node:ekr.20081121105001.279:Configuration (qtFrame)
#@+node:ekr.20081121105001.288:Event handlers (qtFrame)
#@+node:ekr.20081121105001.289:frame.OnCloseLeoEvent
# Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):

    f = self ; c = f.c

    if c.inCommand:
        # g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)
#@-node:ekr.20081121105001.289:frame.OnCloseLeoEvent
#@+node:ekr.20081121105001.290:frame.OnControlKeyUp/Down
def OnControlKeyDown (self,event=None):

    self.controlKeyIsDown = True

def OnControlKeyUp (self,event=None):

    self.controlKeyIsDown = False
#@-node:ekr.20081121105001.290:frame.OnControlKeyUp/Down
#@+node:ekr.20081121105001.291:OnActivateBody (qtFrame)
def OnActivateBody (self,event=None):

    # try:
        # frame = self ; c = frame.c
        # c.setLog()
        # w = c.get_focus()
        # if w != c.frame.body.bodyCtrl:
            # frame.tree.OnDeactivate()
        # c.bodyWantsFocusNow()
    # except:
        # g.es_event_exception("activate body")

    return 'break'
#@-node:ekr.20081121105001.291:OnActivateBody (qtFrame)
#@+node:ekr.20081121105001.292:OnActivateLeoEvent, OnDeactivateLeoEvent
def OnActivateLeoEvent(self,event=None):

    '''Handle a click anywhere in the Leo window.'''

    self.c.setLog()

def OnDeactivateLeoEvent(self,event=None):

    pass # This causes problems on the Mac.
#@-node:ekr.20081121105001.292:OnActivateLeoEvent, OnDeactivateLeoEvent
#@+node:ekr.20081121105001.293:OnActivateTree
def OnActivateTree (self,event=None):

    try:
        frame = self ; c = frame.c
        c.setLog()

        if 0: # Do NOT do this here!
            # OnActivateTree can get called when the tree gets DE-activated!!
            c.bodyWantsFocus()

    except:
        g.es_event_exception("activate tree")
#@-node:ekr.20081121105001.293:OnActivateTree
#@+node:ekr.20081121105001.294:OnBodyClick, OnBodyRClick (Events)
def OnBodyClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyclick1",c=c,p=p,v=p,event=event):
            self.OnActivateBody(event=event)
            c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
        g.doHook("bodyclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyrclick1",c=c,p=p,v=p,event=event):
            c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
        g.doHook("bodyrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
#@-node:ekr.20081121105001.294:OnBodyClick, OnBodyRClick (Events)
#@+node:ekr.20081121105001.295:OnBodyDoubleClick (Events)
def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if event and not g.doHook("bodydclick1",c=c,p=p,v=p,event=event):
            c.editCommands.extendToWord(event) # Handles unicode properly.
            c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
        g.doHook("bodydclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodydclick")

    return "break" # Restore this to handle proper double-click logic.
#@-node:ekr.20081121105001.295:OnBodyDoubleClick (Events)
#@-node:ekr.20081121105001.288:Event handlers (qtFrame)
#@+node:ekr.20081121105001.296:Gui-dependent commands
#@+node:ekr.20081121105001.297:Minibuffer commands... (qtFrame)
#@+node:ekr.20081121105001.298:contractPane
def contractPane (self,event=None):

    '''Contract the selected pane.'''

    # f = self ; c = f.c
    # w = c.get_requested_focus()
    # wname = c.widget_name(w)

    # # g.trace(wname)
    # if not w: return

    # if wname.startswith('body'):
        # f.contractBodyPane()
    # elif wname.startswith('log'):
        # f.contractLogPane()
    # elif wname.startswith('head') or wname.startswith('canvas'):
        # f.contractOutlinePane()
#@-node:ekr.20081121105001.298:contractPane
#@+node:ekr.20081121105001.299:expandPane
def expandPane (self,event=None):

    '''Expand the selected pane.'''

    # f = self ; c = f.c

    # w = c.get_requested_focus()
    # wname = c.widget_name(w)

    # # g.trace(wname)
    # if not w: return

    # if wname.startswith('body'):
        # f.expandBodyPane()
    # elif wname.startswith('log'):
        # f.expandLogPane()
    # elif wname.startswith('head') or wname.startswith('canvas'):
        # f.expandOutlinePane()
#@-node:ekr.20081121105001.299:expandPane
#@+node:ekr.20081121105001.300:fullyExpandPane
def fullyExpandPane (self,event=None):

    '''Fully expand the selected pane.'''

    # f = self ; c = f.c

    # w = c.get_requested_focus()
    # wname = c.widget_name(w)

    # # g.trace(wname)
    # if not w: return

    # if wname.startswith('body'):
        # f.fullyExpandBodyPane()
    # elif wname.startswith('log'):
        # f.fullyExpandLogPane()
    # elif wname.startswith('head') or wname.startswith('canvas'):
        # f.fullyExpandOutlinePane()
#@-node:ekr.20081121105001.300:fullyExpandPane
#@+node:ekr.20081121105001.301:hidePane
def hidePane (self,event=None):

    '''Completely contract the selected pane.'''

    # f = self ; c = f.c

    # w = c.get_requested_focus()
    # wname = c.widget_name(w)

    # g.trace(wname)
    # if not w: return

    # if wname.startswith('body'):
        # f.hideBodyPane()
        # c.treeWantsFocusNow()
    # elif wname.startswith('log'):
        # f.hideLogPane()
        # c.bodyWantsFocusNow()
    # elif wname.startswith('head') or wname.startswith('canvas'):
        # f.hideOutlinePane()
        # c.bodyWantsFocusNow()
#@-node:ekr.20081121105001.301:hidePane
#@+node:ekr.20081121105001.302:expand/contract/hide...Pane
@ The first arg to divideLeoSplitter means the following:

    f.splitVerticalFlag: use the primary   (tree/body) ratio.
not f.splitVerticalFlag: use the secondary (tree/log) ratio.
@c

def contractBodyPane (self,event=None):
    '''Contract the body pane.'''
    f = self ; r = min(1.0,f.ratio+0.1)
    f.divideLeoSplitter(f.splitVerticalFlag,r)

def contractLogPane (self,event=None):
    '''Contract the log pane.'''
    f = self ; r = min(1.0,f.ratio+0.1)
    f.divideLeoSplitter(not f.splitVerticalFlag,r)

def contractOutlinePane (self,event=None):
    '''Contract the outline pane.'''
    f = self ; r = max(0.0,f.ratio-0.1)
    f.divideLeoSplitter(f.splitVerticalFlag,r)

def expandBodyPane (self,event=None):
    '''Expand the body pane.'''
    self.contractOutlinePane()

def expandLogPane(self,event=None):
    '''Expand the log pane.'''
    f = self ; r = max(0.0,f.ratio-0.1)
    f.divideLeoSplitter(not f.splitVerticalFlag,r)

def expandOutlinePane (self,event=None):
    '''Expand the outline pane.'''
    self.contractBodyPane()
#@-node:ekr.20081121105001.302:expand/contract/hide...Pane
#@+node:ekr.20081121105001.303:fullyExpand/hide...Pane
def fullyExpandBodyPane (self,event=None):
    '''Fully expand the body pane.'''
    f = self
    f.divideLeoSplitter(f.splitVerticalFlag,0.0)

def fullyExpandLogPane (self,event=None):
    '''Fully expand the log pane.'''
    f = self
    f.divideLeoSplitter(not f.splitVerticalFlag,0.0)

def fullyExpandOutlinePane (self,event=None):
    '''Fully expand the outline pane.'''
    f = self
    f.divideLeoSplitter(f.splitVerticalFlag,1.0)

def hideBodyPane (self,event=None):
    '''Completely contract the body pane.'''
    f = self
    f.divideLeoSplitter(f.splitVerticalFlag,1.0)

def hideLogPane (self,event=None):
    '''Completely contract the log pane.'''
    f = self
    f.divideLeoSplitter(not f.splitVerticalFlag,1.0)

def hideOutlinePane (self,event=None):
    '''Completely contract the outline pane.'''
    f = self
    f.divideLeoSplitter(f.splitVerticalFlag,0.0)
#@-node:ekr.20081121105001.303:fullyExpand/hide...Pane
#@-node:ekr.20081121105001.297:Minibuffer commands... (qtFrame)
#@+node:ekr.20081121105001.304:Window Menu...
#@+node:ekr.20081121105001.305:toggleActivePane (qtFrame)
def toggleActivePane (self,event=None):

    '''Toggle the focus between the outline and body panes.'''

    frame = self ; c = frame.c

    if c.get_focus() == frame.body.bodyCtrl: # 2007/10/25
        c.treeWantsFocusNow()
    else:
        c.endEditing()
        c.bodyWantsFocusNow()
#@-node:ekr.20081121105001.305:toggleActivePane (qtFrame)
#@+node:ekr.20081121105001.306:cascade
def cascade (self,event=None):

    '''Cascade all Leo windows.'''

    # x,y,delta = 10,10,10
    # for frame in g.app.windowList:
        # top = frame.top

        # # Compute w,h
        # top.update_idletasks() # Required to get proper info.
        # geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
        # dim,junkx,junky = geom.split('+')
        # w,h = dim.split('x')
        # w,h = int(w),int(h)

        # # Set new x,y and old w,h
        # frame.setTopGeometry(w,h,x,y,adjustSize=False)

        # # Compute the new offsets.
        # x += 30 ; y += 30
        # if x > 200:
            # x = 10 + delta ; y = 40 + delta
            # delta += 10
#@-node:ekr.20081121105001.306:cascade
#@+node:ekr.20081121105001.307:equalSizedPanes
def equalSizedPanes (self,event=None):

    '''Make the outline and body panes have the same size.'''

    frame = self
    frame.resizePanesToRatio(0.5,frame.secondary_ratio)
#@-node:ekr.20081121105001.307:equalSizedPanes
#@+node:ekr.20081121105001.308:hideLogWindow
def hideLogWindow (self,event=None):

    frame = self

    frame.divideLeoSplitter2(0.99, not frame.splitVerticalFlag)
#@-node:ekr.20081121105001.308:hideLogWindow
#@+node:ekr.20081121105001.309:minimizeAll
def minimizeAll (self,event=None):

    '''Minimize all Leo's windows.'''

    self.minimize(g.app.pythonFrame)
    for frame in g.app.windowList:
        self.minimize(frame)
        self.minimize(frame.findPanel)

def minimize(self,frame):

    pass

    # if frame and frame.top.state() == "normal":
        # frame.top.iconify()
#@-node:ekr.20081121105001.309:minimizeAll
#@+node:ekr.20081121105001.310:toggleSplitDirection (qtFrame)
# The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.

def toggleSplitDirection (self,event=None):

    '''Toggle the split direction in the present Leo window.'''

    frame = self ; top = frame.top

    for w in (top.splitter,top.splitter_2):
        w.setOrientation(
            g.choose(w.orientation() == QtCore.Qt.Horizontal,
                QtCore.Qt.Vertical,QtCore.Qt.Horizontal))
#@nonl
#@+node:ekr.20081121105001.311:toggleQtSplitDirection
def toggleQtSplitDirection (self,verticalFlag):

    # Abbreviations.
    frame = self
    # bar1 = self.bar1 ; bar2 = self.bar2
    # split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
    # split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
    # # Reconfigure the bars.
    # bar1.place_forget()
    # bar2.place_forget()
    # self.configureBar(bar1,verticalFlag)
    # self.configureBar(bar2,not verticalFlag)
    # # Make the initial placements again.
    # self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
    # self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
    # # Adjust the log and body panes to give more room around the bars.
    # self.reconfigurePanes()
    # # Redraw with an appropriate ratio.
    # vflag,ratio,secondary_ratio = frame.initialRatios()
    # self.resizePanesToRatio(ratio,secondary_ratio)
#@-node:ekr.20081121105001.311:toggleQtSplitDirection
#@-node:ekr.20081121105001.310:toggleSplitDirection (qtFrame)
#@+node:ekr.20081121105001.312:resizeToScreen
def resizeToScreen (self,event=None):

    '''Resize the Leo window so it fill the entire screen.'''

    top = self.top

    # w = top.winfo_screenwidth()
    # h = top.winfo_screenheight()

    # if sys.platform.startswith('win'):
        # top.state('zoomed')
    # elif sys.platform == 'darwin':
        # # Must leave room to get at very small resizing area.
        # geom = "%dx%d%+d%+d" % (w-20,h-55,10,25)
        # top.geometry(geom)
    # else:
        # # Fill almost the entire screen.
        # # Works on Windows. YMMV for other platforms.
        # geom = "%dx%d%+d%+d" % (w-8,h-46,0,0)
        # top.geometry(geom)
#@-node:ekr.20081121105001.312:resizeToScreen
#@-node:ekr.20081121105001.304:Window Menu...
#@+node:ekr.20081121105001.313:Help Menu...
#@+node:ekr.20081121105001.314:leoHelp
def leoHelp (self,event=None):

    '''Open Leo's offline tutorial.'''

    frame = self ; c = frame.c

    theFile = g.os_path_join(g.app.loadDir,"..","doc","sbooks.chm")

    if g.os_path_exists(theFile):
        os.startfile(theFile)
    else:
        answer = g.app.gui.runAskYesNoDialog(c,
            "Download Tutorial?",
            "Download tutorial (sbooks.chm) from SourceForge?")

        if answer == "yes":
            try:
                if 0: # Download directly.  (showProgressBar needs a lot of work)
                    url = "http://umn.dl.sourceforge.net/sourceforge/leo/sbooks.chm"
                    import urllib
                    self.scale = None
                    urllib.urlretrieve(url,theFile,self.showProgressBar)
                    if self.scale:
                        self.scale.destroy()
                        self.scale = None
                else:
                    url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
                    import webbrowser
                    os.chdir(g.app.loadDir)
                    webbrowser.open_new(url)
            except:
                g.es("exception downloading","sbooks.chm")
                g.es_exception()
#@+node:ekr.20081121105001.315:showProgressBar
def showProgressBar (self,count,size,total):

    # g.trace("count,size,total:",count,size,total)
    if self.scale == None:
        pass
        << create the scale widget >>
    # self.scale.set(count*size)
    # self.scale.update_idletasks()
#@+node:ekr.20081121105001.316:<< create the scale widget >>
# top = qt.Toplevel()
# top.title("Download progress")
# self.scale = scale = qt.Scale(top,state="normal",orient="horizontal",from_=0,to=total)
# scale.pack()
# top.lift()
#@-node:ekr.20081121105001.316:<< create the scale widget >>
#@-node:ekr.20081121105001.315:showProgressBar
#@-node:ekr.20081121105001.314:leoHelp
#@-node:ekr.20081121105001.313:Help Menu...
#@-node:ekr.20081121105001.296:Gui-dependent commands
#@+node:ekr.20081121105001.317:Qt bindings... (qtFrame)
def bringToFront (self):
    self.top.showNormal()
def deiconify (self):
    self.top.showNormal()
def getFocus(self):
    return g.app.gui.get_focus() 
def get_window_info(self):
    rect = self.top.geometry()
    topLeft = rect.topLeft()
    x,y = topLeft.x(),topLeft.y()
    w,h = rect.width(),rect.height()
    return w,h,x,y
def iconify(self):
    g.trace()
    self.top.showMinimized()
def lift (self):
    self.top.activateWindow()
def update (self):
    pass
def getTitle (self):
    return g.app.gui.toUnicode(self.top.windowTitle())

def setTitle (self,s):
    self.top.setWindowTitle(s)
def setTopGeometry(self,w,h,x,y,adjustSize=True):
    self.top.setGeometry(QtCore.QRect(x,y,w,h))
#@-node:ekr.20081121105001.317:Qt bindings... (qtFrame)
#@-node:ekr.20081121105001.249:class leoQtFrame
#@+node:ekr.20081121105001.212:Editors (qtBody)
#@+node:ekr.20081121105001.214:packEditorLabelWidget
def packEditorLabelWidget (self,w):

    '''Create a Tk label widget.'''

    # if not hasattr(w,'leo_label') or not w.leo_label:
        # # g.trace('w.leo_frame',id(w.leo_frame))
        # w.pack_forget()
        # w.leo_label = Tk.Label(w.leo_frame)
        # w.leo_label.pack(side='top')
        # w.pack(expand=1,fill='both')
#@nonl
#@-node:ekr.20081121105001.214:packEditorLabelWidget
#@+node:ekr.20081121105001.215:entries
if 1:
    @others
#@nonl
#@+node:ekr.20081121105001.216:addEditor & helpers (qtBody)
# An override of leoFrame.addEditor.

def addEditor (self,event=None):

    '''Add another editor to the body pane.'''

    trace = True and not g.unitTesting

    bodyCtrl = self.c.frame.body.bodyCtrl # A leoQTextEditWidget
    self.editorWidgets['1'] = bodyCtrl
    c = self.c ; p = c.currentPosition()
    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1

    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        # The name of the last editor need not be '1'
        d = self.editorWidgets ; keys = d.keys()
        if len(keys) == 1:
            w_old = d.get(keys[0])
            if trace: g.trace('w_old',w_old)
            self.updateInjectedIvars(w_old,p)
            self.selectLabel(w_old) # Immediately create the label in the old editor.
        else:
            g.trace('can not happen: unexpected editorWidgets',d)

    name = '%d' % self.totalNumberOfEditors

    f,w = self.createEditorFrame()
    self.createEditorWidget(f,name,p,w)
    self.editorWidgets[name] = w

    # for pane in panes:
        # self.pb.configurepane(pane,size=minSize)

    # self.pb.updatelayout()
    if trace: g.trace('w',w)
    c.frame.body.bodyCtrl = w

    self.updateInjectedIvars(w,p)
    self.selectLabel(w)
    self.selectEditor(w)
    self.updateEditors()
    c.bodyWantsFocusNow()
#@+node:ekr.20081121105001.213:createEditorFrame
def createEditorFrame (self):

    f = self.c.frame
    inner_f = f.top.ui.leo_body_inner_frame
    body = leoQtBody(f,None)
    w = body.widget.widget

    inner_f.layout().addWidget(w,0,1)
    w.setFocus()

    return inner_f,body.widget
#@-node:ekr.20081121105001.213:createEditorFrame
#@+node:ekr.20081121105001.217:createEditorWidget
def createEditorWidget (self,f,name,p,w):

    trace = False and not g.unitTesting
    c = self.c

    if trace: g.trace(p.h,w)
    #### w = self.createTextWidget(f,name,p,w)
    self.updateInjectedIvars(w,p)
    w.delete(0,'end')
    w.insert('end',p.bodyString())
    w.see(0)
    ##self.setFontFromConfig(w=w)
    ##self.setColorFromConfig(w=w)
    self.createBindings(w=w)
    c.k.completeAllBindingsForWidget(w)
    self.recolorWidget(p,w)

    #### return w
#@-node:ekr.20081121105001.217:createEditorWidget
#@+node:ekr.20090318091009.14:createTextWidget (not used)
def createTextWidget (self,parentFrame,name,p,w):

    c = self.c

    # # parentFrame.configure(bg='LightSteelBlue1')

    # # wrap = c.config.getBool('body_pane_wraps')
    # # wrap = g.choose(wrap,"word","none")

    # Setgrid=1 cause severe problems with the font panel.
    #### w = leoQTextEditWidget (widget,name,c)


    # # bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')

    # # def yscrollCallback(x,y,bodyBar=bodyBar,w=w):
        # # # g.trace(x,y,g.callers())
        # # if hasattr(w,'leo_scrollBarSpot'):
            # # w.leo_scrollBarSpot = (x,y)
        # # return bodyBar.set(x,y)

    # # body['yscrollcommand'] = yscrollCallback # bodyBar.set

    # # bodyBar['command'] =  body.yview
    # # bodyBar.pack(side="right", fill="y")

    # # # Always create the horizontal bar.
    # # bodyXBar = Tk.Scrollbar(
        # # parentFrame,name='bodyXBar',orient="horizontal")
    # # body['xscrollcommand'] = bodyXBar.set
    # # bodyXBar['command'] = body.xview

    # # if wrap == "none":
        # # # g.trace(parentFrame)
        # # bodyXBar.pack(side="bottom", fill="x")

    # # body.pack(expand=1,fill="both")

    # # self.wrapState = wrap

    # # if 0: # Causes the cursor not to blink.
        # # body.configure(insertofftime=0)

    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v

    w.leo_active = True
    # New in Leo 4.4.4 final: inject the scrollbar items into the text widget.
    w.leo_bodyBar = None #### bodyBar # 2007/10/31
    w.leo_bodyXBar = None #### bodyXBar # 2007/10/31
    w.leo_chapter = None
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    #### return w
#@-node:ekr.20090318091009.14:createTextWidget (not used)
#@-node:ekr.20081121105001.216:addEditor & helpers (qtBody)
#@+node:ekr.20081121105001.218:assignPositionToEditor
def assignPositionToEditor (self,p):

    '''Called *only* from tree.select to select the present body editor.'''

    c = self.c ; cc = c.chapterController ; w = c.frame.body.bodyCtrl

    # self.updateInjectedIvars(w,p)
    # self.selectLabel(w)

    # g.trace('===',id(w),w.leo_chapter.name,w.leo_p.h)
#@-node:ekr.20081121105001.218:assignPositionToEditor
#@+node:ekr.20081121105001.219:cycleEditorFocus
def cycleEditorFocus (self,event=None):

    '''Cycle keyboard focus between the body text editors.'''

    # c = self.c ; d = self.editorWidgets ; w = c.frame.body.bodyCtrl
    # values = d.values()
    # if len(values) > 1:
        # i = values.index(w) + 1
        # if i == len(values): i = 0
        # w2 = d.values()[i]
        # assert(w!=w2)
        # self.selectEditor(w2)
        # c.frame.body.bodyCtrl = w2
        # # g.pr('***',g.app.gui.widget_name(w2),id(w2))

    # return 'break'
#@-node:ekr.20081121105001.219:cycleEditorFocus
#@+node:ekr.20081121105001.220:deleteEditor
def deleteEditor (self,event=None):

    '''Delete the presently selected body text editor.'''

    # c = self.c ; w = c.frame.body.bodyCtrl ; d = self.editorWidgets

    # if len(d.keys()) == 1: return

    # name = w.leo_name

    # del d [name] 
    # self.pb.delete(name)
    # panes = self.pb.panes()
    # minSize = float(1.0/float(len(panes)))

    # for pane in panes:
        # self.pb.configurepane(pane,size=minSize)

    # # Select another editor.
    # w = d.values()[0]
    # # c.frame.body.bodyCtrl = w # Don't do this now?
    # self.numberOfEditors -= 1
    # self.selectEditor(w)
#@-node:ekr.20081121105001.220:deleteEditor
#@+node:ekr.20081121105001.221:findEditorForChapter (leoBody)
def findEditorForChapter (self,chapter,p):

    '''Return an editor to be assigned to chapter.'''

    return self.c.frame.body.bodyCtrl

    # c = self.c ; d = self.editorWidgets ; values = d.values()

    # # First, try to match both the chapter and position.
    # if p:
        # for w in values:
            # if (
                # hasattr(w,'leo_chapter') and w.leo_chapter == chapter and
                # hasattr(w,'leo_p') and w.leo_p and w.leo_p == p
            # ):
                # # g.trace('***',id(w),'match chapter and p',p.h)
                # return w

    # # Next, try to match just the chapter.
    # for w in values:
        # if hasattr(w,'leo_chapter') and w.leo_chapter == chapter:
            # # g.trace('***',id(w),'match only chapter',p.h)
            # return w

    # # As a last resort, return the present editor widget.
    # # g.trace('***',id(self.bodyCtrl),'no match',p.h)
    # return c.frame.body.bodyCtrl
#@-node:ekr.20081121105001.221:findEditorForChapter (leoBody)
#@+node:ekr.20081121105001.222:select/unselectLabel
def unselectLabel (self,w):

    pass

    # self.createChapterIvar(w)
    # self.packEditorLabelWidget(w)
    # s = self.computeLabel(w)
    # if hasattr(w,'leo_label') and w.leo_label:
        # w.leo_label.configure(text=s,bg='LightSteelBlue1')

def selectLabel (self,w):

    pass

    # if self.numberOfEditors > 1:
        # self.createChapterIvar(w)
        # self.packEditorLabelWidget(w)
        # s = self.computeLabel(w)
        # # g.trace(s,g.callers())
        # if hasattr(w,'leo_label') and w.leo_label:
            # w.leo_label.configure(text=s,bg='white')
    # elif hasattr(w,'leo_label') and w.leo_label:
        # w.leo_label.pack_forget()
        # w.leo_label = None
#@-node:ekr.20081121105001.222:select/unselectLabel
#@+node:ekr.20081121105001.223:selectEditor & helpers
selectEditorLockout = False

def selectEditor(self,w):

    '''Select editor w and node w.leo_p.'''

    return self.c.frame.body.bodyCtrl

    #  Called by body.onClick and whenever w must be selected.
    # trace = False
    # c = self.c
    # if not w: return self.c.frame.body.bodyCtrl
    # if self.selectEditorLockout: return

    # if w and w == self.c.frame.body.bodyCtrl:
        # if w.leo_p and w.leo_p != c.currentPosition():
            # c.selectPosition(w.leo_p)
            # c.bodyWantsFocusNow()
        # return

    # try:
        # val = None
        # self.selectEditorLockout = True
        # val = self.selectEditorHelper(w)
    # finally:
        # self.selectEditorLockout = False

    # return val # Don't put a return in a finally clause.
#@+node:ekr.20081121105001.224:selectEditorHelper
def selectEditorHelper (self,w):

    c = self.c ; cc = c.chapterController ; d = self.editorWidgets

    trace = False

    if not w.leo_p:
        g.trace('no w.leo_p') 
        return 'break'

    if trace:
        g.trace('==1',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.h)

    self.inactivateActiveEditor(w)

    # The actual switch.
    c.frame.body.bodyCtrl = w
    w.leo_active = True

    self.switchToChapter(w)
    self.selectLabel(w)

    if not self.ensurePositionExists(w):
        g.trace('***** no position editor!')
        return 'break'

    if trace:
        g.trace('==2',id(w),
            hasattr(w,'leo_chapter') and w.leo_chapter and w.leo_chapter.name,
            hasattr(w,'leo_p') and w.leo_p and w.leo_p.h)

    # g.trace('expanding ancestors of ',w.leo_p.h,g.callers())
    c.expandAllAncestors(w.leo_p)
    c.selectPosition(w.leo_p) # Calls assignPositionToEditor.
    c.redraw()

    c.recolor_now()
    << restore the selection, insertion point and the scrollbar >>
    c.bodyWantsFocusNow()
    return 'break'
#@+node:ekr.20081121105001.225:<< restore the selection, insertion point and the scrollbar >>
# g.trace('active:',id(w),'scroll',w.leo_scrollBarSpot,'ins',w.leo_insertSpot)

if w.leo_insertSpot:
    w.setInsertPoint(w.leo_insertSpot)
else:
    w.setInsertPoint(0)

if w.leo_scrollBarSpot is not None:
    first,last = w.leo_scrollBarSpot
    w.yview('moveto',first)
else:
    w.seeInsertPoint()

if w.leo_selection:
    try:
        start,end = w.leo_selection
        w.setSelectionRange(start,end)
    except Exception:
        pass
#@-node:ekr.20081121105001.225:<< restore the selection, insertion point and the scrollbar >>
#@-node:ekr.20081121105001.224:selectEditorHelper
#@-node:ekr.20081121105001.223:selectEditor & helpers
#@+node:ekr.20081121105001.226:updateEditors
# Called from addEditor and assignPositionToEditor

def updateEditors (self):

    pass

    # c = self.c ; p = c.currentPosition()
    # d = self.editorWidgets
    # if len(d.keys()) < 2: return # There is only the main widget.

    # for key in d:
        # w = d.get(key)
        # v = w.leo_v
        # if v and v == p.v and w != c.frame.body.bodyCtrl:
            # w.delete(0,'end')
            # w.insert('end',p.bodyString())
            # # g.trace('update',w,v)
            # self.recolorWidget(p,w)

    # c.bodyWantsFocus()
#@-node:ekr.20081121105001.226:updateEditors
#@-node:ekr.20081121105001.215:entries
#@+node:ekr.20081121105001.227:utils
#@+node:ekr.20081121105001.228:computeLabel
def computeLabel (self,w):

    s = w.leo_label_s

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        s = '%s: %s' % (w.leo_chapter.name,s)

    return s
#@-node:ekr.20081121105001.228:computeLabel
#@+node:ekr.20081121105001.229:createChapterIvar
def createChapterIvar (self,w):

    c = self.c ; cc = c.chapterController

    if not hasattr(w,'leo_chapter') or not w.leo_chapter:
        if cc and self.use_chapters:
            w.leo_chapter = cc.getSelectedChapter()
        else:
            w.leo_chapter = None
#@-node:ekr.20081121105001.229:createChapterIvar
#@+node:ekr.20081121105001.230:ensurePositionExists
def ensurePositionExists(self,w):

    '''Return True if w.leo_p exists or can be reconstituted.'''

    c = self.c

    if c.positionExists(w.leo_p):
        return True
    else:
        g.trace('***** does not exist',w.leo_name)
        for p2 in c.all_positions_with_unique_vnodes_iter():
            if p2.v and p2.v == w.leo_v:
                w.leo_p = p2.copy()
                return True
        else:
             # This *can* happen when selecting a deleted node.
            w.leo_p = c.currentPosition()
            return False
#@-node:ekr.20081121105001.230:ensurePositionExists
#@+node:ekr.20081121105001.231:inactivateActiveEditor
def inactivateActiveEditor(self,w):

    '''Inactivate the previously active editor.'''

    d = self.editorWidgets

    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        w2 = d.get(key)
        if w2 != w and w2.leo_active:
            w2.leo_active = False
            self.unselectLabel(w2)
            w2.leo_scrollBarSpot = w2.yview()
            w2.leo_insertSpot = w2.getInsertPoint()
            w2.leo_selection = w2.getSelectionRange()
            # g.trace('inactive:',id(w2),'scroll',w2.leo_scrollBarSpot,'ins',w2.leo_insertSpot)
            # g.trace('inactivate',id(w2))
            return
#@-node:ekr.20081121105001.231:inactivateActiveEditor
#@+node:ekr.20081121105001.232:recolorWidget
def recolorWidget (self,p,w):

    c = self.c ; old_w = c.frame.body.bodyCtrl

    # g.trace('w',id(w),p.h,len(w.getAllText()))

    # Save.
    c.frame.body.bodyCtrl = w
    try:
        # c.recolor_now(interruptable=False) # Force a complete recoloring.
        c.frame.body.colorizer.colorize(p,incremental=False,interruptable=False)
    finally:
        # Restore.
        c.frame.body.bodyCtrl = old_w
#@-node:ekr.20081121105001.232:recolorWidget
#@+node:ekr.20081121105001.233:switchToChapter (leoBody)
def switchToChapter (self,w):

    '''select w.leo_chapter.'''

    c = self.c ; cc = c.chapterController

    if hasattr(w,'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            # g.trace('===','old',oldChapter.name,'new',name,w.leo_p)
            cc.selectChapterByName(name)
            c.bodyWantsFocusNow()
#@-node:ekr.20081121105001.233:switchToChapter (leoBody)
#@+node:ekr.20081121105001.234:updateInjectedIvars
# Called from addEditor and assignPositionToEditor.

def updateInjectedIvars (self,w,p):

    c = self.c ; cc = c.chapterController

    if cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None

    w.leo_p = p.copy()
    w.leo_v = w.leo_p.v
    w.leo_label_s = p.h

    # g.trace('   ===', id(w),w.leo_chapter and w.leo_chapter.name,p.h)
#@-node:ekr.20081121105001.234:updateInjectedIvars
#@-node:ekr.20081121105001.227:utils
#@-node:ekr.20081121105001.212:Editors (qtBody)
#@+node:ekr.20081121105001.214:packEditorLabelWidget
def packEditorLabelWidget (self,w):

    '''Create a Tk label widget.'''

    # if not hasattr(w,'leo_label') or not w.leo_label:
        # # g.trace('w.leo_frame',id(w.leo_frame))
        # w.pack_forget()
        # w.leo_label = Tk.Label(w.leo_frame)
        # w.leo_label.pack(side='top')
        # w.pack(expand=1,fill='both')
#@nonl
#@-node:ekr.20081121105001.214:packEditorLabelWidget
#@+node:ekr.20081121105001.216:addEditor & helpers (qtBody)
# An override of leoFrame.addEditor.

def addEditor (self,event=None):

    '''Add another editor to the body pane.'''

    trace = True and not g.unitTesting

    bodyCtrl = self.c.frame.body.bodyCtrl # A leoQTextEditWidget
    self.editorWidgets['1'] = bodyCtrl
    c = self.c ; p = c.currentPosition()
    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1

    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        # The name of the last editor need not be '1'
        d = self.editorWidgets ; keys = d.keys()
        if len(keys) == 1:
            w_old = d.get(keys[0])
            if trace: g.trace('w_old',w_old)
            self.updateInjectedIvars(w_old,p)
            self.selectLabel(w_old) # Immediately create the label in the old editor.
        else:
            g.trace('can not happen: unexpected editorWidgets',d)

    name = '%d' % self.totalNumberOfEditors

    f,w = self.createEditorFrame()
    self.createEditorWidget(f,name,p,w)
    self.editorWidgets[name] = w

    # for pane in panes:
        # self.pb.configurepane(pane,size=minSize)

    # self.pb.updatelayout()
    if trace: g.trace('w',w)
    c.frame.body.bodyCtrl = w

    self.updateInjectedIvars(w,p)
    self.selectLabel(w)
    self.selectEditor(w)
    self.updateEditors()
    c.bodyWantsFocusNow()
#@+node:ekr.20081121105001.213:createEditorFrame
def createEditorFrame (self):

    f = self.c.frame
    inner_f = f.top.ui.leo_body_inner_frame
    body = leoQtBody(f,None)
    w = body.widget.widget

    inner_f.layout().addWidget(w,0,1)
    w.setFocus()

    return inner_f,body.widget
#@-node:ekr.20081121105001.213:createEditorFrame
#@+node:ekr.20081121105001.217:createEditorWidget
def createEditorWidget (self,f,name,p,w):

    trace = False and not g.unitTesting
    c = self.c

    if trace: g.trace(p.h,w)
    #### w = self.createTextWidget(f,name,p,w)
    self.updateInjectedIvars(w,p)
    w.delete(0,'end')
    w.insert('end',p.bodyString())
    w.see(0)
    ##self.setFontFromConfig(w=w)
    ##self.setColorFromConfig(w=w)
    self.createBindings(w=w)
    c.k.completeAllBindingsForWidget(w)
    self.recolorWidget(p,w)

    #### return w
#@-node:ekr.20081121105001.217:createEditorWidget
#@+node:ekr.20090318091009.14:createTextWidget (not used)
def createTextWidget (self,parentFrame,name,p,w):

    c = self.c

    # # parentFrame.configure(bg='LightSteelBlue1')

    # # wrap = c.config.getBool('body_pane_wraps')
    # # wrap = g.choose(wrap,"word","none")

    # Setgrid=1 cause severe problems with the font panel.
    #### w = leoQTextEditWidget (widget,name,c)


    # # bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')

    # # def yscrollCallback(x,y,bodyBar=bodyBar,w=w):
        # # # g.trace(x,y,g.callers())
        # # if hasattr(w,'leo_scrollBarSpot'):
            # # w.leo_scrollBarSpot = (x,y)
        # # return bodyBar.set(x,y)

    # # body['yscrollcommand'] = yscrollCallback # bodyBar.set

    # # bodyBar['command'] =  body.yview
    # # bodyBar.pack(side="right", fill="y")

    # # # Always create the horizontal bar.
    # # bodyXBar = Tk.Scrollbar(
        # # parentFrame,name='bodyXBar',orient="horizontal")
    # # body['xscrollcommand'] = bodyXBar.set
    # # bodyXBar['command'] = body.xview

    # # if wrap == "none":
        # # # g.trace(parentFrame)
        # # bodyXBar.pack(side="bottom", fill="x")

    # # body.pack(expand=1,fill="both")

    # # self.wrapState = wrap

    # # if 0: # Causes the cursor not to blink.
        # # body.configure(insertofftime=0)

    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v

    w.leo_active = True
    # New in Leo 4.4.4 final: inject the scrollbar items into the text widget.
    w.leo_bodyBar = None #### bodyBar # 2007/10/31
    w.leo_bodyXBar = None #### bodyXBar # 2007/10/31
    w.leo_chapter = None
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    #### return w
#@-node:ekr.20090318091009.14:createTextWidget (not used)
#@-node:ekr.20081121105001.216:addEditor & helpers (qtBody)
#@+node:ekr.20081121105001.222:select/unselectLabel
def unselectLabel (self,w):

    pass

    # self.createChapterIvar(w)
    # self.packEditorLabelWidget(w)
    # s = self.computeLabel(w)
    # if hasattr(w,'leo_label') and w.leo_label:
        # w.leo_label.configure(text=s,bg='LightSteelBlue1')

def selectLabel (self,w):

    pass

    # if self.numberOfEditors > 1:
        # self.createChapterIvar(w)
        # self.packEditorLabelWidget(w)
        # s = self.computeLabel(w)
        # # g.trace(s,g.callers())
        # if hasattr(w,'leo_label') and w.leo_label:
            # w.leo_label.configure(text=s,bg='white')
    # elif hasattr(w,'leo_label') and w.leo_label:
        # w.leo_label.pack_forget()
        # w.leo_label = None
#@-node:ekr.20081121105001.222:select/unselectLabel
#@-node:ekr.20081215162017.5:Support multiple body editors
#@+node:ekr.20090318091009.10:Fix undo problems with qt gui
#@-node:ekr.20090318091009.10:Fix undo problems with qt gui
#@+node:ekr.20090318091009.12:Script errors mess up syntax coloring
#@-node:ekr.20090318091009.12:Script errors mess up syntax coloring
#@-node:ekr.20090316095604.11:Urgent 4
#@+node:ekr.20090304084841.10:Asap 4
#@+node:ekr.20081215074704.16:Mark finds doesn't work in Qt gui plugin
http://groups.google.com/group/leo-editor/browse_thread/thread/b2af78fbb36d3590
#@nonl
#@-node:ekr.20081215074704.16:Mark finds doesn't work in Qt gui plugin
#@+node:ekr.20090304084841.15:Complete open-with menu
#@-node:ekr.20090304084841.15:Complete open-with menu
#@+node:ekr.20090128083504.1:Fix rclick
@nocolor-node

rClick


After the qt-plugin merge (rev 1251 ), the image plugin no longer works. I
couldn't find any mention of gsimage in the diff.

 # Erase image if it was previously displayed
             a = g.app ; c = keywords.get("c")

-            if a.gsimage:
+            if getattr(a, 'gsimage', None):
                 try:
                     c.frame.body.bodyCtrl.delete(a.gsimage)
                 except:
#@-node:ekr.20090128083504.1:Fix rclick
#@-node:ekr.20090304084841.10:Asap 4
#@+node:ekr.20090304084841.11:Later
#@+node:ekr.20081215074704.21:Add drag and drop
#@-node:ekr.20081215074704.21:Add drag and drop
#@+node:ekr.20081121105001.151:Clean up settings
- Can style sheets really do the job?

- Remove old-style Leo settings?

- Add stylesheets for dialogs.
    - Set font for dummy widget in style sheet, then copy that font.
#@+node:ekr.20081121105001.150:QScintilla stuff
- Check event handling with QScintilla.
- Experiment with sending <shift-tab> directly to QScintilla.
- Call setLexer(0) for nocolor nodes.
- Add settings for syntax coloring.
- Make Scintilla handle Leo markup.
- Install new Qt version and play with QScintilla.
    From QScintilla change log:
    2008/10/12 14:32:05  phil
    QsciScintilla::setSelection() is now implemented using SCI_SETSEL so that the
    carat can be left at either the start or the end of the selection.
    Exposed QsciScintilla::positionFromLineIndex() and
    QsciScintilla::lineIndexFromPosition().
    - Fix problem with accented characters: see child node for notes.
#@nonl
#@-node:ekr.20081121105001.150:QScintilla stuff
#@-node:ekr.20081121105001.151:Clean up settings
#@+node:ekr.20081215162017.4:Allow coloring of script buttons
#@-node:ekr.20081215162017.4:Allow coloring of script buttons
#@+node:ekr.20081215074704.20:Change background color of body pane depending on focus
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/1cce885a697d0236/5aea5d0587b47b92?lnk=gst&q=command+and+insert#5aea5d0587b47b92

Set focus in/out events.
#@nonl
#@-node:ekr.20081215074704.20:Change background color of body pane depending on focus
#@+node:ekr.20081124094918.1:Fix problems with scim
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/59c1e5d6acaf4de0

I've some more information about the problems with accent previously
reported:
- I can confirm that they are caused by the interaction scim+leo (with
and without the qt plugin). If scim is not started leo works fine. If
scim is running the problems appear and are slightly different with
and without the qt plugin. The workaround is obvious: don't use leo
and scim at the same time :-)
- accents are not working in the qt plugin when scintilla is used. If
qt-use-scintilla=False I can write this:

 (the same for the rest of vowels)

but if qt-use-scintilla=True when I enter the same sequence in the
keyboard I get:

`aaa (the same for the rest of vowels)

- the problem with the  character (reported previously too) is only
present in the qt plugin (both with and without scintilla)
#@-node:ekr.20081124094918.1:Fix problems with scim
#@+node:ekr.20090223065019.11:Make Leo's page-up/page-down commands funtional
# This will be needed for vim.
#@nonl
#@-node:ekr.20090223065019.11:Make Leo's page-up/page-down commands funtional
#@-node:ekr.20090304084841.11:Later
#@-node:ekr.20081121105001.148: qt To do
#@+node:ekr.20081121105001.185:Scripts
#@+node:ekr.20081121105001.186:Script to display Qt font database
import PyQt4.QtGui as QtGui

db = QtGui.QFontDatabase()
for family in db.families():
    print family
    for style in db.styles(family):
        print '\t',style,db.smoothSizes(family,style)
#@-node:ekr.20081121105001.186:Script to display Qt font database
#@+node:ekr.20081121105001.187:dump guiBindNamesInverseDict
print g.dictToString(c.k.guiBindNamesInverseDict)

@
   BackSpace: 'BackSpace'
       Begin: 'Begin'
       Break: 'Break'
   Caps_Lock: 'Caps_Lock'
       Clear: 'Clear'
      Delete: 'Delete'
        Down: 'Down'
         End: 'End'
      Escape: 'Escape'
          F1: 'F1'
         F10: 'F10'
         F11: 'F11'
         F12: 'F12'
          F2: 'F2'
          F3: 'F3'
          F4: 'F4'
          F5: 'F5'
          F6: 'F6'
          F7: 'F7'
          F8: 'F8'
          F9: 'F9'
        Home: 'Home'
        Left: 'Left'
    Linefeed: 'Linefeed'
        Next: 'Next'
    Num_Lock: 'Num_Lock'
       Prior: 'Prior'
      Return: 'Return'
       Right: 'Right'
         Tab: 'Tab'
          Up: 'Up'
   ampersand: '&'
 asciicircum: '^'
  asciitilde: '~'
    asterisk: '*'
          at: '@'
   backslash: '\\'
         bar: '|'
   braceleft: '{'
  braceright: '}'
 bracketleft: '['
bracketright: ']'
       colon: ':'
       comma: ','
      dollar: '$'
       equal: '='
      exclam: '!'
     greater: '>'
        less: '<'
       minus: '-'
  numbersign: '#'
   parenleft: '('
  parenright: ')'
     percent: '%'
      period: '.'
        plus: '+'
    question: '?'
    quotedbl: '"'
   quoteleft: '`'
  quoteright: "'"
   semicolon: ';'
       slash: '/'
       space: ' '
  underscore: '_'
#@nonl
#@-node:ekr.20081121105001.187:dump guiBindNamesInverseDict
#@-node:ekr.20081121105001.185:Scripts
#@+node:ekr.20090124101344.1:Recent
#@+node:ekr.20081215074704.15:Cut/paste work erratically
#@+node:ekr.20090128083504.11:Report
#@-node:ekr.20090128083504.11:Report
#@+node:ekr.20081121105001.502:toUnicode (qtGui)
def toUnicode (self,s,encoding='utf-8',reportErrors=True):

    return unicode(s)
#@nonl
#@-node:ekr.20081121105001.502:toUnicode (qtGui)
#@+node:ekr.20081121105001.183:Clipboard (qtGui)
def replaceClipboardWith (self,s):

    '''Replace the clipboard with the string s.'''

    trace = False and not g.unitTesting
    cb = self.qtApp.clipboard()
    if cb:
        # cb.clear()  # unnecessary, breaks on some Qt versions
        if type(s) == type(''):
            s = g.app.gui.toUnicode(s)
        cb.setText(s)
        if trace: g.trace(len(s),type(s))
    else:
        g.trace('no clipboard!')

def getTextFromClipboard (self):

    '''Get a unicode string from the clipboard.'''

    trace = False and not g.unitTesting
    cb = self.qtApp.clipboard()
    if cb:
        s = cb.text()
        if trace: g.trace (len(s),type(s))
        s = g.app.gui.toUnicode(s)
        return s
    else:
        g.trace('no clipboard!')
        return ''
#@-node:ekr.20081121105001.183:Clipboard (qtGui)
#@-node:ekr.20081215074704.15:Cut/paste work erratically
#@+node:ekr.20090128173959.1:Fixed headline reversion
#@+node:ekr.20090126120517.22:getItemText
def getItemText (self,item):

    '''Return the text of the item.'''

    if item:
        return unicode(item.text(0))
    else:
        return '<no item>'
#@nonl
#@-node:ekr.20090126120517.22:getItemText
#@+node:ekr.20090124174652.59:onHeadChanged (nativeTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None,e=None):

    '''Officially change a headline.'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; u = c.undoer
    if not p:
        if trace: g.trace('** no p')
        return

    item = self.getCurrentItem()
    if not e:
        e = self.getTreeEditorForItem(item)
    if not e:
        if trace and verbose: g.trace('** not editing')
        return

    s = unicode(e.text())
    self.closeEditorHelper(e,item)
    oldHead = p.h
    changed = s != oldHead
    if trace: g.trace('new',repr(s),'old',p.h,g.callers())
    if changed:
        p.initHeadString(s)
        item.setText(0,s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)

    # This is a crucial shortcut.
    if g.unitTesting: return

    self.redraw_after_head_changed()

    if self.stayInTree:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
    c.outerUpdate()
#@-node:ekr.20090124174652.59:onHeadChanged (nativeTree)
#@+node:ekr.20090124174652.58:endEditLabel (nativeTree)
def endEditLabel (self):

    '''Override leoTree.endEditLabel.

    End editing of the presently-selected headline.'''

    c = self.c ; p = c.currentPosition()

    self.onHeadChanged(p)
#@nonl
#@-node:ekr.20090124174652.58:endEditLabel (nativeTree)
#@+node:ekr.20090124174652.60:setHeadline (nativeTree)
def setHeadline (self,p,s):

    '''Force the actual text of the headline widget to p.h.'''

    trace = False and not g.unitTesting

    # This is used by unit tests to force the headline and p into alignment.
    if not p:
        if trace: g.trace('*** no p')
        return

    # Don't do this here: the caller should do it.
    # p.setHeadString(s)
    e = self.edit_widget(p)
    if e:
        if trace: g.trace('e',s)
        e.setAllText(s)
    else:
        item = self.position2item(p)
        if item:
            if trace: g.trace('item',s)
            self.setItemText(item,s)
        else:
            if trace: g.trace('*** failed. no item for %s' % p.h)
#@-node:ekr.20090124174652.60:setHeadline (nativeTree)
#@-node:ekr.20090128173959.1:Fixed headline reversion
#@+node:ekr.20090129125507.10:Fixed (??) body pane corruption
#@+node:ekr.20090124174652.10:__init__ (nativeTree)
def __init__(self,c,frame):

    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Components.
    self.c = c
    self.canvas = self # An official ivar used by Leo's core.

    # Subclasses should define headline wrappers to
    # be a subclass of leoFrame.baseTextWidget.
    self.headlineWrapper = leoFrame.baseTextWidget

    # Subclasses should define .treeWidget to be the underlying
    # native tree widget.
    self.treeWidget = None

    # Widget independent status ivars...
    self.contracting = False
    self.dragging = False
    self.expanding = False
    self.prev_p = None
    self.redrawing = False
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    self.selecting = False

    # Debugging...
    self.nodeDrawCount = 0
    self.traceCallersFlag = False # Enable traceCallers method.

    # Associating items with vnodes...
    self.item2vnodeDict = {}
    self.tnode2itemsDict = {} # values are lists of items.
    self.vnode2itemsDict = {} # values are lists of items.

    self.setConfigIvars()
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
#@-node:ekr.20090124174652.10:__init__ (nativeTree)
#@+node:ekr.20090129062500.10:busy (nativeTree)
def busy (self):

    '''Return True (actually, a debugging string)
    if any lockout is set.'''

    trace = False
    table = (
        (self.contracting,  'contracting'),
        (self.expanding,    'expanding'),
        (self.redrawing,    'redrawing'),
        (self.selecting,    'selecting'))

    item = self.getCurrentItem()

    aList = []
    for ivar,kind in table:
        if ivar:
            aList.append(kind)
    kinds = ','.join(aList)

    if aList and trace:
        g.trace(self.traceItem(item),kinds,g.callers(4))

    return kinds # Return the string for debugging
#@-node:ekr.20090129062500.10:busy (nativeTree)
#@+node:ekr.20090124174652.53:afterSelectHint (nativeTree)
def afterSelectHint (self,p,old_p):

    trace = False and not g.unitTesting
    c = self.c

    self.selecting = False

    if self.busy():
        self.error('afterSelectHint busy!: %s' % self.busy())

    if not p:
        return self.error('no p')
    if p != c.currentPosition():
        return self.error('p is not c.currentPosition()')

    if trace: g.trace(p and p.h,g.callers(4))

    # We don't redraw during unit testing: an important speedup.
    if c.expandAllAncestors(p) and not g.unitTesting:
        self.full_redraw(p)
    else:
        c.outerUpdate() # Bring the tree up to date.
        self.setItemForCurrentPosition(scroll=False)
#@-node:ekr.20090124174652.53:afterSelectHint (nativeTree)
#@+node:ekr.20090124174652.56:editLabel (nativeTree)
def editLabel (self,p,selectAll=False,selection=None):

    """Start editing p's headline."""

    trace = False ; verbose = False

    if self.busy():
        return

    c = self.c

    if trace: g.trace('***',p and p.h,g.callers(4))

    c.outerUpdate()
        # Do any scheduled redraw.
        # This won't do anything in the new redraw scheme.

    item = self.position2item(p)
    if item:
        e = self.editLabelHelper(item,selectAll,selection)
    else:
        e = None
        self.error('no item for %s' % p)

    # A nice hack: just set the focus request.
    if e: c.requestedFocusWidget = e
#@-node:ekr.20090124174652.56:editLabel (nativeTree)
#@+node:ekr.20090124174652.40:onItemCollapsed (nativeTree)
def onItemCollapsed (self,item):

    trace = False
    verbose = False

    if self.busy(): return

    c = self.c
    if trace: g.trace(self.traceItem(item))
    p = self.item2position(item)

    if p:
        # Important: do not set lockouts here.
        # Only methods that actually generate events should set lockouts.
        p.contract()
        self.select(p) # Calls before/afterSelectHint.    
    else:
        self.error('no p')

    c.outerUpdate()
#@-node:ekr.20090124174652.40:onItemCollapsed (nativeTree)
#@+node:ekr.20090124174652.42:onItemExpanded (nativeTree)
def onItemExpanded (self,item):

    '''Handle and tree-expansion event.'''

    trace = False
    verbose = False

    if self.busy(): return

    c = self.c
    if trace: g.trace(self.traceItem(item))
    p = self.item2position(item)

    if p:
        # Important: do not set lockouts here.
        # Only methods that actually generate events should set lockouts.
        if not p.isExpanded():
            p.expand()
            self.select(p) # Calls before/afterSelectHint.
            self.full_redraw()
        else:
            self.select(p)
    else:
        self.error('no p')

    c.outerUpdate()
#@-node:ekr.20090124174652.42:onItemExpanded (nativeTree)
#@+node:ekr.20090124174652.43:onTreeSelect (nativeTree)
def onTreeSelect(self):

    '''Select the proper position when a tree node is selected.'''

    trace = False and not g.unitTesting
    verbose = False

    if self.busy(): return

    c = self.c

    item = self.getCurrentItem()
    p = self.item2position(item)

    if p:
        # Important: do not set lockouts here.
        # Only methods that actually generate events should set lockouts.
        if trace: g.trace(self.traceItem(item))
        self.select(p) # Calls before/afterSelectHint.
    else:
        self.error('no p for item: %s' % item,g.callers(4))

    c.outerUpdate()
#@-node:ekr.20090124174652.43:onTreeSelect (nativeTree)
#@+node:ekr.20090124174652.44:setItemForCurrentPosition (nativeTree)
def setItemForCurrentPosition (self,scroll=True):

    '''Select the item for c.currentPosition()'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; p = c.currentPosition()

    if self.busy(): return

    if not p:
        if trace and verbose: g.trace('** no p')
        return None

    item = self.position2item(p)

    if not item:
        # This is not necessarily an error.
        # We often attempt to select an item before redrawing it.
        if trace and verbose: g.trace('** no item for',p)
        return None

    item2 = self.getCurrentItem()
    if item == item2:
        if trace and verbose: g.trace('no change',self.traceItem(item))
        if scroll:
            self.scrollToItem(item)
    else:
        try:
            self.selecting = True
            # This generates gui events, so we must use a lockout.
            self.setCurrentItemHelper(item)
            if scroll:
                if trace: g.trace(self.traceItem(item),g.callers(4))
                self.scrollToItem(item)
        finally:
            self.selecting = False

    return item
#@-node:ekr.20090124174652.44:setItemForCurrentPosition (nativeTree)
#@+node:ekr.20090124174652.76:setItemIcon (nativeTree)
def setItemIcon (self,item,icon):

    trace = False

    valid = item and self.isValidItem(item)

    if icon and valid:
        # Important: do not set lockouts here.
        # This will generate changed events,
        # but there is no itemChanged event handler.
        self.setItemIconHelper(item,icon)
    elif trace:
        # Apparently, icon can be None due to recent icon changes.
        if icon:
            g.trace('** item %s, valid: %s, icon: %s' % (
                item and id(item) or '<no item>',valid,icon),
                g.callers(4))
#@-node:ekr.20090124174652.76:setItemIcon (nativeTree)
#@+node:ekr.20090124174652.17:full_redraw & helpers
# forceDraw not used. It is used in the Tk code.

def full_redraw (self,p=None,scroll=True,forceDraw=False):

    '''Redraw all visible nodes of the tree.

    Preserve the vertical scrolling unless scroll is True.'''

    trace = False and not g.app.unitTesting
    verbose = True
    c = self.c

    if self.busy():
        return g.trace('*** full_redraw: busy!',g.callers(5))

    if p is None:   p = c.currentPosition()
    else:           c.setCurrentPosition(p)

    self.redrawCount += 1
    if trace: t1 = g.getTime()
    self.initData()
    self.nodeDrawCount = 0
    try:
        self.redrawing = True
        self.drawTopTree(p,scroll)
    finally:
        self.redrawing = False

    self.setItemForCurrentPosition(scroll=True)
    c.requestRedrawFlag= False

    if trace:
        theTime = g.timeSince(t1)
        callers = g.choose(verbose,g.callers(5),'')
        g.trace('%s: drew %3s nodes in %s' % (
            self.redrawCount,self.nodeDrawCount,theTime),callers)

# Compatibility
redraw = full_redraw 
redraw_now = full_redraw
#@+node:ekr.20090124174652.19:drawChildren
def drawChildren (self,p,parent_item):

    trace = False and not g.unitTesting

    if trace: g.trace('children? %5s expanded? %5s %s' % (
        p.hasChildren(),p.isExpanded(),p.h))

    if not p:
        return g.trace('can not happen: no p')

    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child,parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child,parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
#@-node:ekr.20090124174652.19:drawChildren
#@+node:ekr.20090124174652.20:drawNode
def drawNode (self,p,parent_item):

    trace = False
    c = self.c 
    self.nodeDrawCount += 1

    # Allocate the item.
    item = self.createTreeItem(p,parent_item) 

    # Do this now, so self.isValidItem will be true in setItemIcon.
    self.rememberItem(p,item)

    # Set the headline and maybe the icon.
    self.setItemText(item,p.h)
    if p:
        self.drawItemIcon(p,item)

    if trace: g.trace(self.traceItem(item))

    return item
#@-node:ekr.20090124174652.20:drawNode
#@+node:ekr.20090129062500.12:drawTopTree
def drawTopTree (self,p,scroll):

    c = self.c
    hPos,vPos = self.getScroll()
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p ; h = p.h
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()

    self.setHScroll(hPos)
    if scroll:
        pass
    else:
        # Retain former scroll position.
        self.setVScroll(vPos)

    self.repaint()
#@nonl
#@-node:ekr.20090129062500.12:drawTopTree
#@+node:ekr.20090124174652.21:drawTree
def drawTree (self,p,parent_item=None):

    # Draw the (visible) parent node.
    item = self.drawNode(p,parent_item)

    # Draw all the visible children.
    self.drawChildren(p,parent_item=item)


#@-node:ekr.20090124174652.21:drawTree
#@+node:ekr.20090124174652.22:initData
def initData (self):

    # g.trace('*****')

    self.item2vnodeDict = {}
    self.tnode2itemsDict = {}
    self.vnode2itemsDict = {}
#@-node:ekr.20090124174652.22:initData
#@+node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
def rememberItem (self,p,item):

    self.rememberVnodeItem(p.v,item)

def rememberVnodeItem (self,v,item):

    # Update item2vnodeDict.
    self.item2vnodeDict[item] = v

    # Update tnode2itemsDict & vnode2itemsDict.
    table = (
        (self.tnode2itemsDict,v.t),
        (self.vnode2itemsDict,v))

    for d,key in table:
        aList = d.get(key,[])
        if item in aList:
            g.trace('*** ERROR *** item already in list: %s, %s' % (item,aList))
        else:
            aList.append(item)
        d[key] = aList
#@nonl
#@-node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
#@-node:ekr.20090124174652.17:full_redraw & helpers
#@-node:ekr.20090129125507.10:Fixed (??) body pane corruption
#@+node:ekr.20090203081015.10:Hooked up icondclick events
# used QTreeWidget.itemDoubleClicked event.
# There seems to be no way to connect events to individual tree items.
#@+node:ekr.20090124174652.120:qtTree.initAfterLoad
def initAfterLoad (self):

    '''Do late-state inits.'''

    # Called by Leo's core.

    c = self.c ; frame = c.frame
    w = c.frame.top ; tw = self.treeWidget

    if not leoQtTree.callbacksInjected:
        leoQtTree.callbacksInjected = True
        self.injectCallbacks() # A base class method.

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemDoubleClicked(QTreeWidgetItem*, int)"),
        self.onItemDoubleClicked)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemSelectionChanged()"),
        self.onTreeSelect)

    # We don't need this.  Hooray!
    # w.connect(self.treeWidget,QtCore.SIGNAL(
            # "itemChanged(QTreeWidgetItem*, int)"),
        # self.onItemChanged)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemCollapsed(QTreeWidgetItem*)"),
        self.onItemCollapsed)

    w.connect(self.treeWidget,QtCore.SIGNAL(
            "itemExpanded(QTreeWidgetItem*)"),
        self.onItemExpanded)

    self.ev_filter = leoQtEventFilter(c,w=self,tag='tree')
    tw.installEventFilter(self.ev_filter)

    c.setChanged(False)
#@-node:ekr.20090124174652.120:qtTree.initAfterLoad
#@+node:ekr.20090124174652.35:Icon Box... (nativeTree)
# For Qt, there seems to be no way to trigger these events.
#@nonl
#@+node:ekr.20090124174652.36:onIconBoxClick
def onIconBoxClick (self,event,p=None):

    if self.busy(): return

    c = self.c

    g.doHook("iconclick1",c=c,p=p,v=p,event=event)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)

    c.outerUpdate()
#@-node:ekr.20090124174652.36:onIconBoxClick
#@+node:ekr.20090124174652.37:onIconBoxRightClick
def onIconBoxRightClick (self,event,p=None):

    """Handle a right click in any outline widget."""

    if self.busy(): return

    c = self.c

    g.doHook("iconrclick1",c=c,p=p,v=p,event=event)
    g.doHook("iconrclick2",c=c,p=p,v=p,event=event)

    c.outerUpdate()
#@-node:ekr.20090124174652.37:onIconBoxRightClick
#@+node:ekr.20090124174652.38:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event,p=None):

    if self.busy(): return

    c = self.c

    g.doHook("icondclick1",c=c,p=p,v=p,event=event)
    g.doHook("icondclick2",c=c,p=p,v=p,event=event)

    c.outerUpdate()
#@-node:ekr.20090124174652.38:onIconBoxDoubleClick
#@-node:ekr.20090124174652.35:Icon Box... (nativeTree)
#@+node:ekr.20090124174652.112:setItemIconHelper (qtTree)
def setItemIconHelper (self,item,icon):

    # Generates an item-changed event.
    item.setIcon(0,icon)
#@-node:ekr.20090124174652.112:setItemIconHelper (qtTree)
#@+node:ekr.20090124174652.41:onItemDoubleClicked (nativeTree)
def onItemDoubleClicked (self,item,col):

    trace = False
    verbose = False

    if self.busy(): return

    c = self.c

    if trace: g.trace(col,self.traceItem(item),g.callers(4))

    try:
        self.selecting = True

        e = self.createTreeEditorForItem(item)
        if not e: g.trace('*** no e')

        p = self.item2position(item)
        if p:
            event = None
            g.doHook("icondclick1",c=c,p=p,v=p,event=event)
            g.doHook("icondclick2",c=c,p=p,v=p,event=event)
        else:
            g.trace('*** no p')

        c.outerUpdate()
    finally:
        self.selecting = False
#@-node:ekr.20090124174652.41:onItemDoubleClicked (nativeTree)
#@-node:ekr.20090203081015.10:Hooked up icondclick events
#@+node:ekr.20090201080444.1:Improved scrolling
#@+node:ekr.20090124174652.16:Entry points (nativeTree)
#@+node:ekr.20090124174652.17:full_redraw & helpers
# forceDraw not used. It is used in the Tk code.

def full_redraw (self,p=None,scroll=True,forceDraw=False):

    '''Redraw all visible nodes of the tree.

    Preserve the vertical scrolling unless scroll is True.'''

    trace = False and not g.app.unitTesting
    verbose = True
    c = self.c

    if self.busy():
        return g.trace('*** full_redraw: busy!',g.callers(5))

    if p is None:   p = c.currentPosition()
    else:           c.setCurrentPosition(p)

    self.redrawCount += 1
    if trace: t1 = g.getTime()
    self.initData()
    self.nodeDrawCount = 0
    try:
        self.redrawing = True
        self.drawTopTree(p,scroll)
    finally:
        self.redrawing = False

    self.setItemForCurrentPosition(scroll=True)
    c.requestRedrawFlag= False

    if trace:
        theTime = g.timeSince(t1)
        callers = g.choose(verbose,g.callers(5),'')
        g.trace('%s: drew %3s nodes in %s' % (
            self.redrawCount,self.nodeDrawCount,theTime),callers)

# Compatibility
redraw = full_redraw 
redraw_now = full_redraw
#@+node:ekr.20090124174652.19:drawChildren
def drawChildren (self,p,parent_item):

    trace = False and not g.unitTesting

    if trace: g.trace('children? %5s expanded? %5s %s' % (
        p.hasChildren(),p.isExpanded(),p.h))

    if not p:
        return g.trace('can not happen: no p')

    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child,parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child,parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
#@-node:ekr.20090124174652.19:drawChildren
#@+node:ekr.20090124174652.20:drawNode
def drawNode (self,p,parent_item):

    trace = False
    c = self.c 
    self.nodeDrawCount += 1

    # Allocate the item.
    item = self.createTreeItem(p,parent_item) 

    # Do this now, so self.isValidItem will be true in setItemIcon.
    self.rememberItem(p,item)

    # Set the headline and maybe the icon.
    self.setItemText(item,p.h)
    if p:
        self.drawItemIcon(p,item)

    if trace: g.trace(self.traceItem(item))

    return item
#@-node:ekr.20090124174652.20:drawNode
#@+node:ekr.20090129062500.12:drawTopTree
def drawTopTree (self,p,scroll):

    c = self.c
    hPos,vPos = self.getScroll()
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p ; h = p.h
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()

    self.setHScroll(hPos)
    if scroll:
        pass
    else:
        # Retain former scroll position.
        self.setVScroll(vPos)

    self.repaint()
#@nonl
#@-node:ekr.20090129062500.12:drawTopTree
#@+node:ekr.20090124174652.21:drawTree
def drawTree (self,p,parent_item=None):

    # Draw the (visible) parent node.
    item = self.drawNode(p,parent_item)

    # Draw all the visible children.
    self.drawChildren(p,parent_item=item)


#@-node:ekr.20090124174652.21:drawTree
#@+node:ekr.20090124174652.22:initData
def initData (self):

    # g.trace('*****')

    self.item2vnodeDict = {}
    self.tnode2itemsDict = {}
    self.vnode2itemsDict = {}
#@-node:ekr.20090124174652.22:initData
#@+node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
def rememberItem (self,p,item):

    self.rememberVnodeItem(p.v,item)

def rememberVnodeItem (self,v,item):

    # Update item2vnodeDict.
    self.item2vnodeDict[item] = v

    # Update tnode2itemsDict & vnode2itemsDict.
    table = (
        (self.tnode2itemsDict,v.t),
        (self.vnode2itemsDict,v))

    for d,key in table:
        aList = d.get(key,[])
        if item in aList:
            g.trace('*** ERROR *** item already in list: %s, %s' % (item,aList))
        else:
            aList.append(item)
        d[key] = aList
#@nonl
#@-node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
#@-node:ekr.20090124174652.17:full_redraw & helpers
#@+node:ekr.20090124174652.24:redraw_after_contract
def redraw_after_contract (self,p=None):

    if self.redrawing:
        return

    item = self.position2item(p)

    if item:
        self.contractItem(item)
    else:
        # This is not an error.
        # We may have contracted a node that was not, in fact, visible.
        self.full_redraw(scroll=False)
#@-node:ekr.20090124174652.24:redraw_after_contract
#@+node:ekr.20090124174652.25:redraw_after_expand
def redraw_after_expand (self,p=None):

    # Important, setting scrolling to False makes the problem *worse*
    self.full_redraw (p,scroll=True)
#@-node:ekr.20090124174652.25:redraw_after_expand
#@+node:ekr.20090124174652.26:redraw_after_head_changed
def redraw_after_head_changed (self):

    trace = False and not g.unitTesting

    if self.busy(): return

    c = self.c ; p = c.currentPosition()
    ew = self.edit_widget(p)

    if trace: g.trace(p.h)

    currentItem = self.getCurrentItem()

    if p:
        for item in self.tnode2items(p.v.t):
            if self.isValidItem(item):
                self.setItemText(item,p.h)
#@-node:ekr.20090124174652.26:redraw_after_head_changed
#@+node:ekr.20090124174652.27:redraw_after_icons_changed
def redraw_after_icons_changed (self):

    trace = False and not g.unitTesting

    if self.busy(): return

    self.redrawCount += 1 # To keep a unit test happy.

    c = self.c

    if trace: g.trace(c.p.h,g.callers(4))

    # Suppress call to setHeadString in onItemChanged!
    self.redrawing = True
    try:
        item = self.getCurrentItem()
        for p in c.rootPosition().self_and_siblings_iter():
            self.updateVisibleIcons(p)
    finally:
        self.redrawing = False
#@-node:ekr.20090124174652.27:redraw_after_icons_changed
#@+node:ekr.20090124174652.28:redraw_after_select
# Important: this can not replace before/afterSelectHint.

def redraw_after_select (self,p=None):

    '''Redraw the entire tree when an invisible node
    is selected.'''

    trace = False and not g.unitTesting

    if trace: g.trace('(leoQtTree) busy? %s %s' % (
        self.busy(),p and p.h or '<no p>'),g.callers(4))

    # Prevent the selecting lockout from disabling the redraw.
    oldSelecting = self.selecting
    self.selecting = False
    try:
        if not self.busy():
            self.full_redraw(p,scroll=False)
    finally:
        self.selecting = oldSelecting

    # c.redraw_after_select calls tree.select indirectly.
    # Do not call it again here.
#@-node:ekr.20090124174652.28:redraw_after_select
#@-node:ekr.20090124174652.16:Entry points (nativeTree)
#@+node:ekr.20090124174652.53:afterSelectHint (nativeTree)
def afterSelectHint (self,p,old_p):

    trace = False and not g.unitTesting
    c = self.c

    self.selecting = False

    if self.busy():
        self.error('afterSelectHint busy!: %s' % self.busy())

    if not p:
        return self.error('no p')
    if p != c.currentPosition():
        return self.error('p is not c.currentPosition()')

    if trace: g.trace(p and p.h,g.callers(4))

    # We don't redraw during unit testing: an important speedup.
    if c.expandAllAncestors(p) and not g.unitTesting:
        self.full_redraw(p)
    else:
        c.outerUpdate() # Bring the tree up to date.
        self.setItemForCurrentPosition(scroll=False)
#@-node:ekr.20090124174652.53:afterSelectHint (nativeTree)
#@+node:ekr.20090201080444.12:scrollToItem
def scrollToItem (self,item):

    w = self.treeWidget

    # g.trace(self.traceItem(item),g.callers(4))

    hPos,vPos = self.getScroll()

    w.scrollToItem(item,w.PositionAtCenter)

    self.setHScroll(0)
#@-node:ekr.20090201080444.12:scrollToItem
#@+node:ekr.20090124174652.44:setItemForCurrentPosition (nativeTree)
def setItemForCurrentPosition (self,scroll=True):

    '''Select the item for c.currentPosition()'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; p = c.currentPosition()

    if self.busy(): return

    if not p:
        if trace and verbose: g.trace('** no p')
        return None

    item = self.position2item(p)

    if not item:
        # This is not necessarily an error.
        # We often attempt to select an item before redrawing it.
        if trace and verbose: g.trace('** no item for',p)
        return None

    item2 = self.getCurrentItem()
    if item == item2:
        if trace and verbose: g.trace('no change',self.traceItem(item))
        if scroll:
            self.scrollToItem(item)
    else:
        try:
            self.selecting = True
            # This generates gui events, so we must use a lockout.
            self.setCurrentItemHelper(item)
            if scroll:
                if trace: g.trace(self.traceItem(item),g.callers(4))
                self.scrollToItem(item)
        finally:
            self.selecting = False

    return item
#@-node:ekr.20090124174652.44:setItemForCurrentPosition (nativeTree)
#@-node:ekr.20090201080444.1:Improved scrolling
#@+node:ekr.20090215160745.10:Improved speed for scanning color directives
#@+node:ekr.20081205131308.24:updateSyntaxColorer
def updateSyntaxColorer (self,p):

    trace = False and not g.unitTesting
    p = p.copy()

    # self.flag is True unless an unambiguous @nocolor is seen.
    self.flag = self.useSyntaxColoring(p)
    self.scanColorDirectives(p)

    if trace: g.trace(self.flag,self.language,p.h)
    return self.flag
#@-node:ekr.20081205131308.24:updateSyntaxColorer
#@+node:ekr.20081205131308.23:useSyntaxColoring & helper
def useSyntaxColoring (self,p):

    """Return True unless p is unambiguously under the control of @nocolor."""

    trace = False and not g.unitTesting
    if not p:
        if trace: g.trace('no p',repr(p))
        return False

    p = p.copy()
    first = True ; kind = None ; val = True
    self.killColorFlag = False
    for p in p.self_and_parents_iter():
        d = self.findColorDirectives(p)
        color,no_color = 'color' in d,'nocolor' in d
        # An @nocolor-node in the first node disabled coloring.
        if first and 'nocolor-node' in d:
            kind = '@nocolor-node'
            self.killColorFlag = True
            val = False ; break
        # A killcolor anywhere disables coloring.
        elif 'killcolor' in d:
            kind = '@killcolor %s' % p.h
            self.killColorFlag = True
            val = False ; break
        # A color anywhere in the target enables coloring.
        elif color and first:
            kind = 'color %s' % p.h
            val = True ; break
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            kind = '@nocolor %s' % p.h
            val = False ; break
        elif color and not no_color:
            kind = '@color %s' % p.h
            val = True ; break
        first = False

    if trace: g.trace(val,kind)
    return val
#@+node:ekr.20090214075058.12:findColorDirectives
color_directives_pat = re.compile(
    # Order is important: put longest matches first.
    r'(^@color|^@killcolor|^@nocolor-node|^@nocolor)'
    ,re.MULTILINE)

def findColorDirectives (self,p):

    '''Scan p for @color, @killcolor, @nocolor and @nocolor-node directives.

    Return a dict containing pointers to the start of each directive.'''

    trace = False and not g.unitTesting

    d = {}
    anIter = self.color_directives_pat.finditer(p.b)
    for m in anIter:
        # Remove leading '@' for compatibility with
        # functions in leoGlobals.py.
        word = m.group(0)[1:]
        d[word] = word

    if trace: g.trace(d)
    return d
#@-node:ekr.20090214075058.12:findColorDirectives
#@-node:ekr.20081205131308.23:useSyntaxColoring & helper
#@+node:ekr.20090214075058.12:findColorDirectives
color_directives_pat = re.compile(
    # Order is important: put longest matches first.
    r'(^@color|^@killcolor|^@nocolor-node|^@nocolor)'
    ,re.MULTILINE)

def findColorDirectives (self,p):

    '''Scan p for @color, @killcolor, @nocolor and @nocolor-node directives.

    Return a dict containing pointers to the start of each directive.'''

    trace = False and not g.unitTesting

    d = {}
    anIter = self.color_directives_pat.finditer(p.b)
    for m in anIter:
        # Remove leading '@' for compatibility with
        # functions in leoGlobals.py.
        word = m.group(0)[1:]
        d[word] = word

    if trace: g.trace(d)
    return d
#@-node:ekr.20090214075058.12:findColorDirectives
#@-node:ekr.20090215160745.10:Improved speed for scanning color directives
#@+node:ekr.20090217121624.10:Fixed bad startup bug
# The problem was that @chapter nodes were not expanded if they should be selected.
#@nonl
#@+node:ekr.20090124174652.28:redraw_after_select
# Important: this can not replace before/afterSelectHint.

def redraw_after_select (self,p=None):

    '''Redraw the entire tree when an invisible node
    is selected.'''

    trace = False and not g.unitTesting

    if trace: g.trace('(leoQtTree) busy? %s %s' % (
        self.busy(),p and p.h or '<no p>'),g.callers(4))

    # Prevent the selecting lockout from disabling the redraw.
    oldSelecting = self.selecting
    self.selecting = False
    try:
        if not self.busy():
            self.full_redraw(p,scroll=False)
    finally:
        self.selecting = oldSelecting

    # c.redraw_after_select calls tree.select indirectly.
    # Do not call it again here.
#@-node:ekr.20090124174652.28:redraw_after_select
#@+node:ekr.20090124174652.17:full_redraw & helpers
# forceDraw not used. It is used in the Tk code.

def full_redraw (self,p=None,scroll=True,forceDraw=False):

    '''Redraw all visible nodes of the tree.

    Preserve the vertical scrolling unless scroll is True.'''

    trace = False and not g.app.unitTesting
    verbose = True
    c = self.c

    if self.busy():
        return g.trace('*** full_redraw: busy!',g.callers(5))

    if p is None:   p = c.currentPosition()
    else:           c.setCurrentPosition(p)

    self.redrawCount += 1
    if trace: t1 = g.getTime()
    self.initData()
    self.nodeDrawCount = 0
    try:
        self.redrawing = True
        self.drawTopTree(p,scroll)
    finally:
        self.redrawing = False

    self.setItemForCurrentPosition(scroll=True)
    c.requestRedrawFlag= False

    if trace:
        theTime = g.timeSince(t1)
        callers = g.choose(verbose,g.callers(5),'')
        g.trace('%s: drew %3s nodes in %s' % (
            self.redrawCount,self.nodeDrawCount,theTime),callers)

# Compatibility
redraw = full_redraw 
redraw_now = full_redraw
#@+node:ekr.20090124174652.19:drawChildren
def drawChildren (self,p,parent_item):

    trace = False and not g.unitTesting

    if trace: g.trace('children? %5s expanded? %5s %s' % (
        p.hasChildren(),p.isExpanded(),p.h))

    if not p:
        return g.trace('can not happen: no p')

    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child,parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child,parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
#@-node:ekr.20090124174652.19:drawChildren
#@+node:ekr.20090124174652.20:drawNode
def drawNode (self,p,parent_item):

    trace = False
    c = self.c 
    self.nodeDrawCount += 1

    # Allocate the item.
    item = self.createTreeItem(p,parent_item) 

    # Do this now, so self.isValidItem will be true in setItemIcon.
    self.rememberItem(p,item)

    # Set the headline and maybe the icon.
    self.setItemText(item,p.h)
    if p:
        self.drawItemIcon(p,item)

    if trace: g.trace(self.traceItem(item))

    return item
#@-node:ekr.20090124174652.20:drawNode
#@+node:ekr.20090129062500.12:drawTopTree
def drawTopTree (self,p,scroll):

    c = self.c
    hPos,vPos = self.getScroll()
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p ; h = p.h
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()

    self.setHScroll(hPos)
    if scroll:
        pass
    else:
        # Retain former scroll position.
        self.setVScroll(vPos)

    self.repaint()
#@nonl
#@-node:ekr.20090129062500.12:drawTopTree
#@+node:ekr.20090124174652.21:drawTree
def drawTree (self,p,parent_item=None):

    # Draw the (visible) parent node.
    item = self.drawNode(p,parent_item)

    # Draw all the visible children.
    self.drawChildren(p,parent_item=item)


#@-node:ekr.20090124174652.21:drawTree
#@+node:ekr.20090124174652.22:initData
def initData (self):

    # g.trace('*****')

    self.item2vnodeDict = {}
    self.tnode2itemsDict = {}
    self.vnode2itemsDict = {}
#@-node:ekr.20090124174652.22:initData
#@+node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
def rememberItem (self,p,item):

    self.rememberVnodeItem(p.v,item)

def rememberVnodeItem (self,v,item):

    # Update item2vnodeDict.
    self.item2vnodeDict[item] = v

    # Update tnode2itemsDict & vnode2itemsDict.
    table = (
        (self.tnode2itemsDict,v.t),
        (self.vnode2itemsDict,v))

    for d,key in table:
        aList = d.get(key,[])
        if item in aList:
            g.trace('*** ERROR *** item already in list: %s, %s' % (item,aList))
        else:
            aList.append(item)
        d[key] = aList
#@nonl
#@-node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
#@-node:ekr.20090124174652.17:full_redraw & helpers
#@-node:ekr.20090217121624.10:Fixed bad startup bug
#@+node:ekr.20090226094019.1:Fixed bug: No headline selected after return
#@+node:ekr.20090126093408.855:setCurrentItemHelper
def setCurrentItemHelper(self,item):

    w = self.treeWidget
    w.SelectItem(item)
#@-node:ekr.20090126093408.855:setCurrentItemHelper
#@+node:ekr.20090124174652.26:redraw_after_head_changed
def redraw_after_head_changed (self):

    trace = False and not g.unitTesting

    if self.busy(): return

    c = self.c ; p = c.currentPosition()
    ew = self.edit_widget(p)

    if trace: g.trace(p.h)

    currentItem = self.getCurrentItem()

    if p:
        for item in self.tnode2items(p.v.t):
            if self.isValidItem(item):
                self.setItemText(item,p.h)
#@-node:ekr.20090124174652.26:redraw_after_head_changed
#@+node:ekr.20090124174652.28:redraw_after_select
# Important: this can not replace before/afterSelectHint.

def redraw_after_select (self,p=None):

    '''Redraw the entire tree when an invisible node
    is selected.'''

    trace = False and not g.unitTesting

    if trace: g.trace('(leoQtTree) busy? %s %s' % (
        self.busy(),p and p.h or '<no p>'),g.callers(4))

    # Prevent the selecting lockout from disabling the redraw.
    oldSelecting = self.selecting
    self.selecting = False
    try:
        if not self.busy():
            self.full_redraw(p,scroll=False)
    finally:
        self.selecting = oldSelecting

    # c.redraw_after_select calls tree.select indirectly.
    # Do not call it again here.
#@-node:ekr.20090124174652.28:redraw_after_select
#@-node:ekr.20090226094019.1:Fixed bug: No headline selected after return
#@+node:ekr.20090303084544.10:Syntax coloring problem
# OMG, the problem was in a match_mark_prev.
# The solution: set self.prev to False in recolor.
#@nonl
#@+node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
def setSplitDirection (self,orientation='vertical'):

    vert = orientation and orientation.lower().startswith('v')

    orientation1 = g.choose(vert,QtCore.Qt.Horizontal, QtCore.Qt.Vertical)
    orientation2 = g.choose(vert,QtCore.Qt.Vertical, QtCore.Qt.Horizontal)
    self.splitter.setOrientation(orientation1)
    self.splitter_2.setOrientation(orientation2)

    # g.trace('vert',vert)

#@-node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
#@+node:ekr.20081206062411.12:recolor & helpers
def recolor (self,s):

    '''Recolor line s.'''

    trace = False and not g.unitTesting
    verbose = False ; traceMatch = False

    # Return immediately if syntax coloring has been disabled.
    # if self.colorizer.killColorFlag or not self.colorizer.enabled:
        # self.highlighter.setCurrentBlockState(-1)
        # if trace and (self.initFlag or verbose):
            # self.initFlag = False
            # g.trace('immediate return')
        # return

    # Reload all_s if the widget's text is known to have changed.
    if self.initFlag:
        self.initFlag = False
        self.all_s = self.w.getAllText()
        if trace and verbose:
            g.trace('**** set all_s: %s' % len(self.all_s),g.callers(5))

    all_s = self.all_s
    if not all_s: return

    # Update the counts.
    self.recolorCount += 1
    self.totalChars += len(s)

    # Init values that do not depend on all_s.
    offset = self.highlighter.currentBlock().position()
    b = self.getPrevState()
    lastFunc,lastMatch = b.lastFunc,b.lastMatch
    lastN,minimalMatch = 0,'' # Not used until there is a match.
    lastFlag = b.lastFlag
    if lastFlag is not None:
        # g.trace('***** set flag',lastFlag)
        self.colorizer.flag = lastFlag
    if trace and verbose and lastFunc: g.trace('prevState',b)
    i = g.choose(lastFunc,lastMatch,offset)

    # Make sure we are in synch with all_s.
    # Reload all_s if we are not.
    if not self.checkRecolor(offset,s):
        return g.trace('**** resych failure',s)

    # Set the values that depend on all_s.
    all_s = self.all_s
    j = min(offset + len(s),len(all_s))
    self.global_i,self.global_j = offset,j

    if trace:
        g.trace('%3s %5s %-40s %s' % (
            self.recolorCount,self.colorizer.flag,b.stateName,s))

    # The main colorizing loop.
    self.prev = None
    while i < j:
        loopFlag = self.colorizer.flag
        assert 0 <= i < len(all_s)
        progress = i
        functions = self.rulesDict.get(all_s[i],[])
        self.minimalMatch = ''
        for f in functions:
            n = f(self,all_s,i)
            if n is None:
                g.trace('Can not happen' % (repr(n),repr(f)))
                break
            elif n > 0: # Success.
                if trace and traceMatch:
                    g.trace('match: offset %3s, i %3s, n %3s, f %s %s' % (
                        offset,i,n,f.__name__,repr(s[i:i+n])))
                lastFunc,lastMatch,lastN,minimalMatch = f,i,n,self.minimalMatch
                i += n
                break # Stop searching the functions.
            elif n < 0: # Fail and skip n chars.
                # match_keyword now sets n < 0 on first failure.
                i += -n # Don't set lastMatch on failure!
                break # Stop searching the functions.
            else: # Fail.  Go on to the next f in functions.
                pass # Do not break or change i!
        else:
            i += 1 # Don't set lastMatch on failure!
        assert i > progress

    self.setCurrentState(s,offset,len(s)+1,
        lastFunc,lastMatch,lastN,minimalMatch)
#@+node:ekr.20090213102946.10:checkRecolor
def checkRecolor (self,offset,s):

    '''Return True if s can be synched with self.all_s.'''

    trace = False and not g.unitTesting

    all_s = self.all_s
    j = min(offset + len(s),len(all_s))
    s2 = all_s[offset:j]

    # The first check is allowed to fail.
    if s == s2: return True

    if trace: g.trace('**resynch**')

    # Assume we should have re-inited all_s
    self.all_s = all_s = self.w.getAllText()
    j = min(offset + len(s),len(all_s))
    s2 = all_s[offset:j]

    # Check again. This should never fail.
    if s != s2:
        g.trace('**** mismatch! offset %s len %s %s\n%s\n%s' % (
           offset,len(all_s),g.callers(5),repr(s),repr(s2)))
    return s == s2
#@-node:ekr.20090213102946.10:checkRecolor
#@+node:ekr.20090211072718.14:computeStateName
def computeStateName (self,lastFunc,lastMatch,lastN,minimalMatch):

    if self.colorizer.killColorFlag:
        colorState = 'killcolor.'
    else:
        colorState = g.choose(
            self.colorizer.flag in (True,None),'','nocolor.')

    if lastFunc:
        matchString = g.choose(minimalMatch,
            minimalMatch,
            self.all_s[lastMatch:lastMatch+lastN])
        name = '%s%s:%s' % (
            colorState,lastFunc.__name__,matchString)
    else:
        name = '%s%s' % (colorState,self.defaultState)

    # g.trace(repr(lastFlag),name)

    return name
#@-node:ekr.20090211072718.14:computeStateName
#@+node:ekr.20090211072718.2:getPrevState
def getPrevState (self):

    h = self.highlighter
    n = h.previousBlockState()

    if n == -1:
        return g.Bunch(
            lastKillColorFlag=None,
            lastFlag=None,
            lastFunc=None,
            lastMatch=0,
            lastN=0,
            stateName = self.defaultState)
    else:
        bunch = self.stateDict.get(n)
        assert bunch,'n=%s' % (n)
        return bunch
#@nonl
#@-node:ekr.20090211072718.2:getPrevState
#@+node:ekr.20090211072718.3:setCurrentState
def setCurrentState (self,s,offset,limit,
    lastFunc,lastMatch,lastN,minimalMatch):

    trace = False and not g.unitTesting
    verbose = True
    h = self.highlighter
    flag = self.colorizer.flag
    killColorFlag = self.colorizer.killColorFlag

    self.stateCount += 1
    oldN = h.currentBlockState()
    active = bool(
        killColorFlag or flag is False or 
        (lastFunc and lastMatch + lastN > offset + limit))

    if active:
        b = self.stateDict.get(oldN)
        if b:
            changeState = (
                b.lastFlag != flag or
                b.lastKillColorFlag != killColorFlag or
                b.lastFunc != lastFunc or
                b.lastN != lastN)
        else:
            changeState = True
    else:
        flag,lastFunc,lastMatch,lastN,minimalMatch = None,None,None,None,None
        changeState = oldN != -1 #### or not flag or killColorFlag 

    stateName = self.computeStateName(
        lastFunc,lastMatch,lastN,minimalMatch)

    if trace and (changeState or active or verbose):
        g.trace('%2d ** active %5s changed %5s %-20s %s' % (
            self.stateCount,active,changeState,stateName,s))

    if not changeState:
        return

    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.nextState += 1
        self.totalStates += 1
        self.maxStateNumber = max(n,self.maxStateNumber)

    state = g.bunch(
        lastKillColorFlag = killColorFlag,
        lastFlag=flag,
        lastFunc=lastFunc,
        lastMatch=lastMatch,
        lastN=lastN,
        stateName=stateName,)

    self.stateNameDict[stateName] = n
    self.stateDict[n] = state

    h.setCurrentBlockState(n)
#@-node:ekr.20090211072718.3:setCurrentState
#@+node:ekr.20081206062411.14:setTag
tagCount = 0

def setTag (self,tag,s,i,j):

    trace = False and not g.unitTesting
    verbose = False
    w = self.w
    colorName = w.configDict.get(tag)

    if not self.colorizer.flag:
        # We are under the influence of @nocolor
        if trace: g.trace('in range of @nocolor',tag)
        return

    # Munch the color name.
    if not colorName:
        if trace: g.trace('no color for %s' % tag)
        return
    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[:-1]

    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name',colorName)

    # Clip the colorizing to the global bounds.
    offset = self.global_i
    lim_i,lim_j = self.global_i,self.global_j
    clip_i = max(i,lim_i)
    clip_j = min(j,lim_j)
    ok = clip_i < clip_j

    if trace:
        self.tagCount += 1
        # kind = g.choose(ok,' ','***')
        s2 = g.choose(ok,s[clip_i:clip_j],self.all_s[i:j])

        if verbose:
            g.trace('%3s %3s %3s %3s %3s %3s %3s %s' % (
                self.tagCount,tag,offset,i,j,lim_i,lim_j,s2),
                g.callers(4))
        else:
            g.trace('%3s %7s %s' % (self.tagCount,tag,s2))

    if ok:
        self.highlighter.setFormat(clip_i-offset,clip_j-clip_i,color)
#@-node:ekr.20081206062411.14:setTag
#@-node:ekr.20081206062411.12:recolor & helpers
#@-node:ekr.20090303084544.10:Syntax coloring problem
#@+node:ekr.20090223065019.12:Swap scroll bars when orientation changes
#@+node:ekr.20081121105001.200:class  DynamicWindow
from PyQt4 import uic

class DynamicWindow(QtGui.QMainWindow):

    '''A class representing all parts of the main Qt window
    as created by Designer.

    c.frame.top is a Window object.

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    '''

    @others

#@+node:ekr.20081121105001.201: ctor (Window)
# Called from leoQtFrame.finishCreate.

def __init__(self,c,parent=None):

    '''Create Leo's main window, c.frame.top'''

    self.c = c ; top = c.frame.top
    # print('DynamicWindow.__init__ %s' % c)

    # Init both base classes.

    ui_file_name = c.config.getString('qt_ui_file_name')
    if not ui_file_name:
        ui_file_name = 'qt_main.ui'

    ui_description_file = g.app.loadDir + "/../plugins/" + ui_file_name
    # g.pr('DynamicWindw.__init__,ui_description_file)
    assert g.os_path_exists(ui_description_file)

    QtGui.QMainWindow.__init__(self,parent)        
    self.ui = uic.loadUi(ui_description_file, self)

    # Init the QDesigner elements.
    #self.setupUi(self)

    ivars = """
    tabWidget treeWidget stackedWidget richTextEdit lineEdit
    findPattern findChange checkBoxWholeWord checkBoxIgnoreCase
    checkBoxWrapAround checkBoxReverse checkBoxRexexp checkBoxMarkFinds
    checkBoxEntireOutline checkBoxSubroutineOnly checkBoxNodeOnly
    checkBoxSearchHeadline checkBoxSearchBody checkBoxMarkChanges
    setWindowIcon setWindowTitle show setGeometry windowTitle
    menuBar

    """.strip().split()

    #for v in ivars:
    #    setattr(self, v, getattr(self.ui, v))

    self.iconBar = self.addToolBar("IconBar")
    self.menubar = self.menuBar()
    self.statusBar = QtGui.QStatusBar()
    self.setStatusBar(self.statusBar)

    orientation = c.config.getString('initial_split_orientation')
    self.setSplitDirection(orientation)
    self.setStyleSheets()
#@+node:leohag.20081203210510.17:do_leo_spell_btn_*
def doSpellBtn(self, btn):
    getattr(self.c.spellCommands.handler.tab, btn)() 

def do_leo_spell_btn_Add(self):
    self.doSpellBtn('onAddButton')

def do_leo_spell_btn_Change(self):
    self.doSpellBtn('onChangeButton')

def do_leo_spell_btn_Find(self):
    self.doSpellBtn('onFindButton')

def do_leo_spell_btn_FindChange(self):
    self.doSpellBtn('onChangeThenFindButton')

def do_leo_spell_btn_Hide(self):
    self.doSpellBtn('onHideButton')

def do_leo_spell_btn_Ignore(self):
    self.doSpellBtn('onIgnoreButton')
#@-node:leohag.20081203210510.17:do_leo_spell_btn_*
#@-node:ekr.20081121105001.201: ctor (Window)
#@+node:ekr.20081121105001.202:closeEvent (qtFrame)
def closeEvent (self,event):

    c = self.c

    if c.inCommand:
        # g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        ok = g.app.closeLeoWindow(c.frame)
        # g.trace('ok',ok)
        if ok:
            event.accept()
        else:
            event.ignore()
#@-node:ekr.20081121105001.202:closeEvent (qtFrame)
#@+node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
def setSplitDirection (self,orientation='vertical'):

    vert = orientation and orientation.lower().startswith('v')

    orientation1 = g.choose(vert,QtCore.Qt.Horizontal, QtCore.Qt.Vertical)
    orientation2 = g.choose(vert,QtCore.Qt.Vertical, QtCore.Qt.Horizontal)
    self.splitter.setOrientation(orientation1)
    self.splitter_2.setOrientation(orientation2)

    # g.trace('vert',vert)

#@-node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
#@+node:ekr.20081121105001.203:setStyleSheets & helper
styleSheet_inited = False

def setStyleSheets(self):

    trace = False
    c = self.c

    sheet = c.config.getData('qt-gui-plugin-style-sheet')
    if sheet:
        sheet = '\n'.join(sheet)
        if trace: g.trace(len(sheet))
        self.ui.setStyleSheet(sheet or self.default_sheet())
    else:
        if trace: g.trace('no style sheet')
#@nonl
#@+node:ekr.20081121105001.204:defaultStyleSheet
def defaultStyleSheet (self):

    '''Return a reasonable default style sheet.'''

    # Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords
    return '''\

/* A QWidget: supports only background attributes.*/
QSplitter::handle {

    background-color: #CAE1FF; /* Leo's traditional lightSteelBlue1 */
}
QSplitter {
    border-color: white;
    background-color: white;
    border-width: 3px;
    border-style: solid;
}
QTreeWidget {
    background-color: #ffffec; /* Leo's traditional tree color */
}
/* Not supported. */
QsciScintilla {
    background-color: pink;
}
'''
#@-node:ekr.20081121105001.204:defaultStyleSheet
#@-node:ekr.20081121105001.203:setStyleSheets & helper
#@-node:ekr.20081121105001.200:class  DynamicWindow
#@+node:ekr.20090303084544.1:setupUi
def setupUi(self, MainWindow):
    MainWindow.setObjectName("MainWindow")
    MainWindow.resize(957, 778)
    self.centralwidget = QtGui.QWidget(MainWindow)
    self.centralwidget.setObjectName("centralwidget")
    self.verticalLayout = QtGui.QVBoxLayout(self.centralwidget)
    self.verticalLayout.setObjectName("verticalLayout")
    self.splitter_2 = QtGui.QSplitter(self.centralwidget)
    self.splitter_2.setOrientation(QtCore.Qt.Vertical)
    self.splitter_2.setObjectName("splitter_2")
    self.splitter = QtGui.QSplitter(self.splitter_2)
    self.splitter.setOrientation(QtCore.Qt.Horizontal)
    self.splitter.setObjectName("splitter")
    self.treeWidget = QtGui.QTreeWidget(self.splitter)
    self.treeWidget.setObjectName("treeWidget")
    self.tabWidget = QtGui.QTabWidget(self.splitter)
    self.tabWidget.setObjectName("tabWidget")
    self.tab = QtGui.QWidget()
    self.tab.setObjectName("tab")
    self.verticalLayout_3 = QtGui.QVBoxLayout(self.tab)
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.textBrowser = QtGui.QTextBrowser(self.tab)
    self.textBrowser.setObjectName("textBrowser")
    self.verticalLayout_3.addWidget(self.textBrowser)
    self.tabWidget.addTab(self.tab, "")
    self.tab_2 = QtGui.QWidget()
    self.tab_2.setObjectName("tab_2")
    self.gridLayout = QtGui.QGridLayout(self.tab_2)
    self.gridLayout.setObjectName("gridLayout")
    self.findPattern = QtGui.QLineEdit(self.tab_2)
    self.findPattern.setObjectName("findPattern")
    self.gridLayout.addWidget(self.findPattern, 0, 1, 1, 1)
    self.findChange = QtGui.QLineEdit(self.tab_2)
    self.findChange.setObjectName("findChange")
    self.gridLayout.addWidget(self.findChange, 1, 1, 1, 1)
    self.checkBoxWholeWord = QtGui.QCheckBox(self.tab_2)
    self.checkBoxWholeWord.setObjectName("checkBoxWholeWord")
    self.gridLayout.addWidget(self.checkBoxWholeWord, 2, 0, 1, 1)
    self.checkBoxEntireOutline = QtGui.QCheckBox(self.tab_2)
    self.checkBoxEntireOutline.setObjectName("checkBoxEntireOutline")
    self.gridLayout.addWidget(self.checkBoxEntireOutline, 2, 1, 1, 1)
    self.checkBoxIgnoreCase = QtGui.QCheckBox(self.tab_2)
    self.checkBoxIgnoreCase.setObjectName("checkBoxIgnoreCase")
    self.gridLayout.addWidget(self.checkBoxIgnoreCase, 3, 0, 1, 1)
    self.checkBoxSubroutineOnly = QtGui.QCheckBox(self.tab_2)
    self.checkBoxSubroutineOnly.setObjectName("checkBoxSubroutineOnly")
    self.gridLayout.addWidget(self.checkBoxSubroutineOnly, 3, 1, 1, 1)
    self.checkBoxWrapAround = QtGui.QCheckBox(self.tab_2)
    self.checkBoxWrapAround.setObjectName("checkBoxWrapAround")
    self.gridLayout.addWidget(self.checkBoxWrapAround, 4, 0, 1, 1)
    self.checkBoxNodeOnly = QtGui.QCheckBox(self.tab_2)
    self.checkBoxNodeOnly.setObjectName("checkBoxNodeOnly")
    self.gridLayout.addWidget(self.checkBoxNodeOnly, 4, 1, 1, 1)
    self.checkBoxReverse = QtGui.QCheckBox(self.tab_2)
    self.checkBoxReverse.setObjectName("checkBoxReverse")
    self.gridLayout.addWidget(self.checkBoxReverse, 5, 0, 1, 1)
    self.checkBoxSearchHeadline = QtGui.QCheckBox(self.tab_2)
    self.checkBoxSearchHeadline.setObjectName("checkBoxSearchHeadline")
    self.gridLayout.addWidget(self.checkBoxSearchHeadline, 5, 1, 1, 1)
    self.checkBoxRexexp = QtGui.QCheckBox(self.tab_2)
    self.checkBoxRexexp.setObjectName("checkBoxRexexp")
    self.gridLayout.addWidget(self.checkBoxRexexp, 6, 0, 1, 1)
    self.checkBoxSearchBody = QtGui.QCheckBox(self.tab_2)
    self.checkBoxSearchBody.setObjectName("checkBoxSearchBody")
    self.gridLayout.addWidget(self.checkBoxSearchBody, 6, 1, 1, 1)
    self.checkBoxMarkFinds = QtGui.QCheckBox(self.tab_2)
    self.checkBoxMarkFinds.setObjectName("checkBoxMarkFinds")
    self.gridLayout.addWidget(self.checkBoxMarkFinds, 7, 0, 1, 1)
    self.checkBoxMarkChanges = QtGui.QCheckBox(self.tab_2)
    self.checkBoxMarkChanges.setObjectName("checkBoxMarkChanges")
    self.gridLayout.addWidget(self.checkBoxMarkChanges, 7, 1, 1, 1)
    self.label_2 = QtGui.QLabel(self.tab_2)
    self.label_2.setObjectName("label_2")
    self.gridLayout.addWidget(self.label_2, 0, 0, 1, 1)
    self.label_3 = QtGui.QLabel(self.tab_2)
    self.label_3.setObjectName("label_3")
    self.gridLayout.addWidget(self.label_3, 1, 0, 1, 1)
    self.tabWidget.addTab(self.tab_2, "")
    self.tab_3 = QtGui.QWidget()
    self.tab_3.setObjectName("tab_3")
    self.tabWidget.addTab(self.tab_3, "")
    self.stackedWidget = QtGui.QStackedWidget(self.splitter_2)
    self.stackedWidget.setAcceptDrops(True)
    self.stackedWidget.setObjectName("stackedWidget")
    self.page = QtGui.QWidget()
    self.page.setObjectName("page")
    self.verticalLayout_2 = QtGui.QVBoxLayout(self.page)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.textEdit = Qsci.QsciScintilla(self.page)
    self.textEdit.setObjectName("textEdit")
    self.verticalLayout_2.addWidget(self.textEdit)
    self.stackedWidget.addWidget(self.page)
    self.page_2 = QtGui.QWidget()
    self.page_2.setObjectName("page_2")
    self.verticalLayout_4 = QtGui.QVBoxLayout(self.page_2)
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.richTextEdit = QtGui.QTextEdit(self.page_2)
    self.richTextEdit.setObjectName("richTextEdit")
    self.verticalLayout_4.addWidget(self.richTextEdit)
    self.stackedWidget.addWidget(self.page_2)
    self.verticalLayout.addWidget(self.splitter_2)
    self.horizontalLayout = QtGui.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.label = QtGui.QLabel(self.centralwidget)
    self.label.setObjectName("label")
    self.horizontalLayout.addWidget(self.label)
    self.lineEdit = QtGui.QLineEdit(self.centralwidget)
    self.lineEdit.setObjectName("lineEdit")
    self.horizontalLayout.addWidget(self.lineEdit)
    self.verticalLayout.addLayout(self.horizontalLayout)
    MainWindow.setCentralWidget(self.centralwidget)
    self.menubar = QtGui.QMenuBar(MainWindow)
    self.menubar.setGeometry(QtCore.QRect(0, 0, 957, 22))
    self.menubar.setObjectName("menubar")
    MainWindow.setMenuBar(self.menubar)
    self.statusbar = QtGui.QStatusBar(MainWindow)
    self.statusbar.setObjectName("statusbar")
    MainWindow.setStatusBar(self.statusbar)
    self.actionOpen = QtGui.QAction(MainWindow)
    self.actionOpen.setObjectName("actionOpen")
    self.actionSave = QtGui.QAction(MainWindow)
    self.actionSave.setObjectName("actionSave")
    self.actionIPython = QtGui.QAction(MainWindow)
    self.actionIPython.setObjectName("actionIPython")
    self.label.setBuddy(self.lineEdit)

    self.retranslateUi(MainWindow)
    self.tabWidget.setCurrentIndex(1)
    self.stackedWidget.setCurrentIndex(0)
    QtCore.QObject.connect(self.treeWidget, QtCore.SIGNAL("itemSelectionChanged()"), MainWindow.showNormal)
    QtCore.QMetaObject.connectSlotsByName(MainWindow)

#@-node:ekr.20090303084544.1:setupUi
#@+node:ekr.20081121105001.207: ctor (qtBody)
def __init__ (self,frame,parentFrame):

    trace = False and not g.unitTesting

    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)

    c = self.c
    assert c.frame == frame and frame.c == c

    self.useScintilla = c.config.getBool('qt-use-scintilla')

    # Set the actual gui widget.
    if self.useScintilla:
        self.widget = w = leoQScintillaWidget(
            c.frame.top.textEdit,
            name='body',c=c)
        self.bodyCtrl = w # The widget as seen from Leo's core.
        self.colorizer = leoColor.nullColorizer(c)
    else:
        top = c.frame.top
        sw = top.ui.stackedWidget
        qtWidget = top.ui.richTextEdit # A QTextEdit.
        sw.setCurrentIndex(1)
        self.widget = w = leoQTextEditWidget(
            qtWidget,name = 'body',c=c)
        self.bodyCtrl = w # The widget as seen from Leo's core.

        # Hook up the QSyntaxHighlighter
        self.colorizer = leoQtColorizer(c,w.widget)
        w.acceptRichText = False

    # Config stuff.
    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    wrap = c.config.getBool('body_pane_wraps')
    # g.trace('wrap',wrap,self.widget.widget)
    if self.useScintilla:
        pass
    else:
        self.widget.widget.setWordWrapMode(g.choose(wrap,
            QtGui.QTextOption.WordWrap,
            QtGui.QTextOption.NoWrap))
    wrap = g.choose(wrap,"word","none")
    self.wrapState = wrap

    # For multiple body editors.
    self.editor_name = None
    self.editor_v = None
    self.numberOfEditors = 1
    self.totalNumberOfEditors = 1

    if trace: print('qtBody.__init__ %s' % self.widget)
#@-node:ekr.20081121105001.207: ctor (qtBody)
#@+node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
def setSplitDirection (self,orientation='vertical'):

    vert = orientation and orientation.lower().startswith('v')

    orientation1 = g.choose(vert,QtCore.Qt.Horizontal, QtCore.Qt.Vertical)
    orientation2 = g.choose(vert,QtCore.Qt.Vertical, QtCore.Qt.Horizontal)
    self.splitter.setOrientation(orientation1)
    self.splitter_2.setOrientation(orientation2)

    # g.trace('vert',vert)

#@-node:edward.20081129091117.1:setSplitDirection (dynamicWindow)
#@+node:ekr.20081121105001.572: class leoQTextEditWidget
class leoQTextEditWidget (leoQtBaseTextWidget):

    @others
#@+node:ekr.20081121105001.573:Birth
#@+node:ekr.20081121105001.574:ctor
def __init__ (self,widget,name,c=None):

    # widget is a QTextEdit.

    # Init the base class.
    leoQtBaseTextWidget.__init__(self,widget,name,c=c)

    self.baseClassName='leoQTextEditWidget'

    widget.setUndoRedoEnabled(False)

    self.setConfig()
    self.setFontFromConfig()
    self.setColorFromConfig()
    # self.setScrollBarOrientation()

    # Override the mouse handler
    #### widget.mouseReleaseEvent = self.mouseReleaseEvent
#@-node:ekr.20081121105001.574:ctor
#@+node:ekr.20081121105001.575:setFontFromConfig
def setFontFromConfig (self,w=None):

    '''Set the font in the widget w (a body editor).'''

    c = self.c
    if not w: w = self.widget

    font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    # w.configure(font=font)

    # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
#@-node:ekr.20081121105001.575:setFontFromConfig
#@+node:ekr.20081121105001.576:setColorFromConfig
def setColorFromConfig (self,w=None):

    '''Set the font in the widget w (a body editor).'''

    c = self.c
    if w is None: w = self.widget

    bg = c.config.getColor("body_text_background_color") or 'white'
    try:
        pass ### w.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()

    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try:
        pass ### w.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try:
            pass ### w.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()

    sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    try:
        pass ### w.configure(selectbackground=sel_bg)
    except Exception:
        g.es("exception setting body pane text selection background color")
        g.es_exception()

    sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    try:
        pass ### w.configure(selectforeground=sel_fg)
    except Exception:
        g.es("exception setting body pane text selection foreground color")
        g.es_exception()

    # if sys.platform != "win32": # Maybe a Windows bug.
        # fg = c.config.getColor("body_cursor_foreground_color")
        # bg = c.config.getColor("body_cursor_background_color")
        # if fg and bg:
            # cursor="xterm" + " " + fg + " " + bg
            # try:
                # pass ### w.configure(cursor=cursor)
            # except:
                # import traceback ; traceback.print_exc()
#@-node:ekr.20081121105001.576:setColorFromConfig
#@+node:ekr.20081121105001.577:setConfig
def setConfig (self):

    c = self.c ; w = self.widget

    n = c.config.getInt('qt-rich-text-zoom-in')

    w.setWordWrapMode(QtGui.QTextOption.NoWrap)

    # w.zoomIn(1)
    # w.updateMicroFocus()
    if n not in (None,0):
        # This only works when there is no style sheet.
        # g.trace('zoom-in',n)
        w.zoomIn(n)
        w.updateMicroFocus()

    # tab stop in pixels - no config for this (yet)        
    w.setTabStopWidth(24)


#@-node:ekr.20081121105001.577:setConfig
#@+node:ekr.20090303095630.10:setScrollBarOrientation (QTextEdit)
# def setScrollBarOrientation (self):

    # c = self.c
    # orientation = c.config.getString(jk13ab02xy04)
#@-node:ekr.20090303095630.10:setScrollBarOrientation (QTextEdit)
#@-node:ekr.20081121105001.573:Birth
#@+node:ekr.20090322092751.1:mouseReleaseEvent (not used)
def mouseReleaseEvent (self,event):

    '''An override of the self.widget.mouseReleaseEvent,
    monkey-patched by the leoQTextEditWidget ctor.'''

    g.trace(self,event,self.widget)
    # self.c.frame.tree.endEditLabel()
    self.c.endEditing()
    event.ignore()
#@-node:ekr.20090322092751.1:mouseReleaseEvent (not used)
#@+node:ekr.20081121105001.578:Widget-specific overrides (QTextEdit)
#@+node:ekr.20090205153624.11:delete (avoid call to setAllText)
def delete(self,i,j=None):

    trace = False and not g.unitTesting
    c,w = self.c,self.widget
    colorer = c.frame.body.colorizer.highlighter.colorer
    n = colorer.recolorCount

    i = self.toGuiIndex(i)
    if j is None: j = i+1
    j = self.toGuiIndex(j)

    # Set a hook for the colorer.
    colorer.initFlag = True

    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    cursor = w.textCursor()
    cursor.setPosition(i)
    moveCount = abs(j-i)
    cursor.movePosition(cursor.Right,cursor.KeepAnchor,moveCount)
    cursor.removeSelectedText()
    sb.setSliderPosition(pos)

    if trace:
        g.trace('%s calls to recolor' % (
            colorer.recolorCount-n))
#@-node:ekr.20090205153624.11:delete (avoid call to setAllText)
#@+node:ekr.20081121105001.579:flashCharacter (leoQTextEditWidget)
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):

    # numbered color names don't work in Ubuntu 8.10, so...
    if bg[-1].isdigit() and bg[0] != '#':
        bg = bg[:-1]
    if fg[-1].isdigit() and fg[0] != '#':
        fg = fg[:-1]

    # This might causes problems during unit tests.
    # The selection point isn't restored in time.
    if g.app.unitTesting: return

    w = self.widget # A QTextEdit.
    e = QtGui.QTextCursor

    def after(func):
        QtCore.QTimer.singleShot(delay,func)

    def addFlashCallback(self=self,w=w):
        n,i = self.flashCount,self.flashIndex

        cursor = w.textCursor() # Must be the widget's cursor.
        cursor.setPosition(i)
        cursor.movePosition(e.Right,e.KeepAnchor,1)

        extra = w.ExtraSelection()
        extra.cursor = cursor
        if self.flashBg: extra.format.setBackground(QtGui.QColor(self.flashBg))
        if self.flashFg: extra.format.setForeground(QtGui.QColor(self.flashFg))
        self.extraSelList = [extra] # keep the reference.
        w.setExtraSelections(self.extraSelList)

        self.flashCount -= 1
        after(removeFlashCallback)

    def removeFlashCallback(self=self,w=w):
        w.setExtraSelections([])
        if self.flashCount > 0:
            after(addFlashCallback)
        else:
            w.setFocus()

    # g.trace(flashes,fg,bg)
    self.flashCount = flashes
    self.flashIndex = i
    self.flashBg = g.choose(bg.lower()=='same',None,bg)
    self.flashFg = g.choose(fg.lower()=='same',None,fg)

    addFlashCallback()
#@-node:ekr.20081121105001.579:flashCharacter (leoQTextEditWidget)
#@+node:ekr.20081121105001.580:getAllText (leoQTextEditWidget)
def getAllText(self):

    w = self.widget
    s = unicode(w.toPlainText())

    # Doesn't work: gets only the line containing the cursor.
    # s = unicode(w.textCursor().block().text())

    # g.trace(repr(s))
    return s
#@nonl
#@-node:ekr.20081121105001.580:getAllText (leoQTextEditWidget)
#@+node:ekr.20081121105001.581:getInsertPoint
def getInsertPoint(self):

    return self.widget.textCursor().position()
#@-node:ekr.20081121105001.581:getInsertPoint
#@+node:ekr.20081121105001.582:getSelectionRange
def getSelectionRange(self,sort=True):

    w = self.widget
    tc = w.textCursor()
    i,j = tc.selectionStart(),tc.selectionEnd()
    # g.trace(i,j,g.callers(4))
    return i,j
#@nonl
#@-node:ekr.20081121105001.582:getSelectionRange
#@+node:ekr.20081121105001.583:getYScrollPosition
def getYScrollPosition(self):

    w = self.widget
    sb = w.verticalScrollBar()
    i = sb.sliderPosition()

    # Return a tuple, only the first of which is used.
    return i,i 
#@-node:ekr.20081121105001.583:getYScrollPosition
#@+node:ekr.20081121105001.584:hasSelection
def hasSelection(self):

    return self.widget.textCursor().hasSelection()
#@-node:ekr.20081121105001.584:hasSelection
#@+node:ekr.20090205153624.12:insert (avoid call to setAllText)
def insert(self,i,s):

    trace = False and not g.unitTesting
    c,w = self.c,self.widget
    colorer = c.frame.body.colorizer.highlighter.colorer
    n = colorer.recolorCount

    # Set a hook for the colorer.
    colorer.initFlag = True

    i = self.toGuiIndex(i)

    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    cursor = w.textCursor()
    cursor.setPosition(i)
    cursor.insertText(s) # This cause an incremental call to recolor.
    sb.setSliderPosition(pos)

    if trace:
        g.trace('%s calls to recolor' % (
            colorer.recolorCount-n))
#@-node:ekr.20090205153624.12:insert (avoid call to setAllText)
#@+node:ekr.20081121105001.585:see
def see(self,i):

    self.widget.ensureCursorVisible()
#@nonl
#@-node:ekr.20081121105001.585:see
#@+node:ekr.20081121105001.586:seeInsertPoint
def seeInsertPoint (self):

    self.widget.ensureCursorVisible()
#@-node:ekr.20081121105001.586:seeInsertPoint
#@+node:ekr.20081121105001.587:setAllText
def setAllText(self,s,insert=None):

    '''Set the text of the widget.

    If insert is None, the insert point, selection range and scrollbars are initied.
    Otherwise, the scrollbars are preserved.'''

    trace = False and not g.unitTesting
    c,w = self.c,self.widget
    colorizer = c.frame.body.colorizer
    highlighter = colorizer.highlighter
    colorer = highlighter.colorer

    # Set a hook for the colorer.
    colorer.initFlag = True

    sb = w.verticalScrollBar()
    if insert is None: i,pos = 0,0
    else: i,pos = insert,sb.sliderPosition()

    if trace: t1 = g.getTime()
    w.setPlainText(s)
    if trace: g.trace(g.timeSince(t1))

    self.setSelectionRange(i,i,insert=i)
    sb.setSliderPosition(pos)
#@nonl
#@-node:ekr.20081121105001.587:setAllText
#@+node:ekr.20081121105001.588:setInsertPoint
def setInsertPoint(self,i):

    w = self.widget

    s = w.toPlainText()
    i = max(0,min(i,len(s)))
    cursor = w.textCursor()

    # block = cursor.block()
    # i = max(0,min(i,block.length()))

    cursor.setPosition(i)
    w.setTextCursor(cursor)
#@-node:ekr.20081121105001.588:setInsertPoint
#@+node:ekr.20081121105001.589:setSelectionRangeHelper & helper
def setSelectionRangeHelper(self,i,j,insert):

    w = self.widget
    # g.trace('i',i,'j',j,'insert',insert,g.callers(4))
    e = QtGui.QTextCursor
    if i > j: i,j = j,i
    n = self.lengthHelper()
    # s = w.toPlainText() ; n = len(s)
    i = max(0,min(i,n))
    j = max(0,min(j,n))
    k = max(0,min(j-i,n))
    cursor = w.textCursor()
    if i == j:
        cursor.setPosition(i)
    elif insert in (j,None):
        cursor.setPosition(i)
        cursor.movePosition(e.Right,e.KeepAnchor,k)
    else:
        cursor.setPosition(j)
        cursor.movePosition(e.Left,e.KeepAnchor,k)

    w.setTextCursor(cursor)
#@+node:ekr.20081121105001.590:lengthHelper
def lengthHelper(self):

    '''Return the length of the text.'''

    w = self.widget
    cursor = w.textCursor()
    cursor.movePosition(QtGui.QTextCursor.End)
    n = cursor.position()
    return n

#@-node:ekr.20081121105001.590:lengthHelper
#@-node:ekr.20081121105001.589:setSelectionRangeHelper & helper
#@+node:ekr.20081121105001.591:setYScrollPosition
def setYScrollPosition(self,pos):

    # g.trace('pos',pos)

    w = self.widget
    sb = w.verticalScrollBar()
    if pos is None: pos = 0
    elif type(pos) == types.TupleType:
        pos = pos[0]
    sb.setSliderPosition(pos)
#@-node:ekr.20081121105001.591:setYScrollPosition
#@-node:ekr.20081121105001.578:Widget-specific overrides (QTextEdit)
#@-node:ekr.20081121105001.572: class leoQTextEditWidget
#@+node:ekr.20081121105001.310:toggleSplitDirection (qtFrame)
# The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.

def toggleSplitDirection (self,event=None):

    '''Toggle the split direction in the present Leo window.'''

    frame = self ; top = frame.top

    for w in (top.splitter,top.splitter_2):
        w.setOrientation(
            g.choose(w.orientation() == QtCore.Qt.Horizontal,
                QtCore.Qt.Vertical,QtCore.Qt.Horizontal))
#@nonl
#@+node:ekr.20081121105001.311:toggleQtSplitDirection
def toggleQtSplitDirection (self,verticalFlag):

    # Abbreviations.
    frame = self
    # bar1 = self.bar1 ; bar2 = self.bar2
    # split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
    # split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
    # # Reconfigure the bars.
    # bar1.place_forget()
    # bar2.place_forget()
    # self.configureBar(bar1,verticalFlag)
    # self.configureBar(bar2,not verticalFlag)
    # # Make the initial placements again.
    # self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
    # self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
    # # Adjust the log and body panes to give more room around the bars.
    # self.reconfigurePanes()
    # # Redraw with an appropriate ratio.
    # vflag,ratio,secondary_ratio = frame.initialRatios()
    # self.resizePanesToRatio(ratio,secondary_ratio)
#@-node:ekr.20081121105001.311:toggleQtSplitDirection
#@-node:ekr.20081121105001.310:toggleSplitDirection (qtFrame)
#@-node:ekr.20090223065019.12:Swap scroll bars when orientation changes
#@+node:ekr.20090128113654.1:Fixed bug re: duplicate recent-files menu
@nocolor

Using r1372 and the Qt plugin, I get strange results with the recent-
files menu item.  To reproduce:

1. open a leo window (call this window 1)
2. open an existing .leo file using file->open... (this opens a new window, window 2)
3. go to the file->Recent-files menu item of window 1.  The file-list is duplicated.
4. repeat step 2.  Now window 1's recent-files list is duplicated twice...

** Affects: leo-editor
    Importance: Undecided
        Status: New

--
recent-files menu item list is duplicated
https://bugs.launchpad.net/bugs/313320
You received this bug notification because you are a member of The Leo
editor team, which is subscribed to leo-editor.

Status in Leo: a programmer's editor and more: New

Bug description:
Using r1372 and the Qt plugin, I get strange results with the recent-files menu item.  To reproduce:

1. open a leo window (call this window 1)
2. open an existing .leo file using file->open... (this opens a new window, window 2)
3. go to the file->Recent-files menu item of window 1.  The file-list is duplicated.
4. repeat step 2.  Now window 1's recent-files list is duplicated twice...

@color
#@nonl
#@+node:ekr.20081215074704.18:Report
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/51edf3b44d6a587e

revno: 1259.1.10
revision-id: terry_n_brown@yahoo.com-20081130181632-ci0ioaksewdvc257

I added code so that this no longer derails the initialization process,
i.e. just catch the exception and continue.  I don't know what's wrong
except I first noticed it after a tkinter update from Ubuntu.  I
think.  Anyway, that's my story :)

When I added the "clean recent files" menu option long before this
traceback showed up I had a heap of trouble deleting just the file
entries on the recent files menu.  It was originally hardwired that the
menu have a "Clear list" item, and then the file entries, but I wanted
to make it get it's command entries from @menu @settings and add the
files afterward and that was a lot of fiddling.  I.e. originally it
deleted everything and added the "Clear list" item before rebuilding
the file list, now it either tries to delete only the file entries, or
stores the entries before the files (from @menu) and adds them back
before the files each time, I forget which finally worked.

What's my point?  It would be nice if delete_range "just worked".  It's
a 'pass' in qt, and I would guess recent files is the only thing in the
entire code base that uses it.

The menu tree seems to me to be "write only", i.e. not readable, at
least from the Leo API, of course you can walk it in a gui specific
way.  Not necessarily a problem, but would be nice if it was more
robustly dynamic.  Or maybe I'm missing something, but I've only seen
functions which find a menu based on knowing it exists before hand.
#@nonl
#@-node:ekr.20081215074704.18:Report
#@+node:ekr.20081121105001.469:class qtMenuWrapper (QMenu,leoQtMenu)
class qtMenuWrapper (QtGui.QMenu,leoQtMenu):

    def __init__ (self,c,frame,parent):

        assert c
        assert frame
        QtGui.QMenu.__init__(self,parent)
        leoQtMenu.__init__(self,frame)

    def __repr__(self):

        return '<qtMenuWrapper %s>' % self.leo_label or 'unlabeled'
#@-node:ekr.20081121105001.469:class qtMenuWrapper (QMenu,leoQtMenu)
#@+node:ekr.20081121105001.354:class leoQtMenu (leoMenu)
class leoQtMenu (leoMenu.leoMenu):

    @others
#@+node:ekr.20081121105001.355:leoQtMenu.__init__
def __init__ (self,frame):

    assert frame
    assert frame.c

    # Init the base class.
    leoMenu.leoMenu.__init__(self,frame)

    # g.pr('leoQtMenu.__init__',g.callers(4))

    self.frame = frame
    self.c = c = frame.c
    self.leo_label = '<no leo_label>'

    self.menuBar = c.frame.top.menuBar()
    assert self.menuBar

    # Inject this dict into the commander.
    if not hasattr(c,'menuAccels'):
        setattr(c,'menuAccels',{})

    if 0:
        self.font = c.config.getFontFromParams(
            'menu_text_font_family', 'menu_text_font_size',
            'menu_text_font_slant',  'menu_text_font_weight',
            c.config.defaultMenuFontSize)
#@-node:ekr.20081121105001.355:leoQtMenu.__init__
#@+node:ekr.20081121105001.356:Activate menu commands (to do)
#@+node:ekr.20081121105001.357:qtMenu.activateMenu
def activateMenu (self,menuName):

    c = self.c ;  top = c.frame.top
    # topx,topy = top.winfo_rootx(),top.winfo_rooty()
    # menu = c.frame.menu.getMenu(menuName)

    # if menu:
        # d = self.computeMenuPositions()
        # x = d.get(menuName)
        # if x is None:
            # x = 0 ; g.trace('oops, no menu offset: %s' % menuName)

        # menu.tk_popup(topx+d.get(menuName,0),topy) # Fix by caugm.  Thanks!
    # else:
        # g.trace('oops, no menu: %s' % menuName)
#@-node:ekr.20081121105001.357:qtMenu.activateMenu
#@+node:ekr.20081121105001.358:qtMenu.computeMenuPositions
def computeMenuPositions (self):

    # A hack.  It would be better to set this when creating the menus.
    menus = ('File','Edit','Outline','Plugins','Cmds','Window','Help')

    # Compute the *approximate* x offsets of each menu.
    d = {}
    n = 0
    # for z in menus:
        # menu = self.getMenu(z)
        # fontName = menu.cget('font')
        # font = tkFont.Font(font=fontName)
        # # g.pr('%8s' % (z),menu.winfo_reqwidth(),menu.master,menu.winfo_x())
        # d [z] = n
        # # A total hack: sorta works on windows.
        # n += font.measure(z+' '*4)+1

    return d
#@-node:ekr.20081121105001.358:qtMenu.computeMenuPositions
#@-node:ekr.20081121105001.356:Activate menu commands (to do)
#@+node:ekr.20081121105001.359:Tkinter menu bindings
# See the Tk docs for what these routines are to do
#@+node:ekr.20081121105001.360:Methods with Tk spellings
#@+node:ekr.20081121105001.361:add_cascade
def add_cascade (self,parent,label,menu,underline):

    """Wrapper for the Tkinter add_cascade menu method.

    Adds a submenu to the parent menu, or the menubar."""

    c = self.c ; leoFrame = c.frame
    n = underline
    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]

    menu.setTitle(label)
    menu.leo_label = label

    if parent:
        parent.addMenu(menu)
    else:
        self.menuBar.addMenu(menu)

    return menu
#@-node:ekr.20081121105001.361:add_cascade
#@+node:ekr.20081121105001.362:add_command (qt)
def add_command (self,**keys):

    """Wrapper for the Tkinter add_command menu method."""

    c = self.c
    accel = keys.get('accelerator') or ''
    command = keys.get('command')
    label = keys.get('label')
    n = keys.get('underline')
    menu = keys.get('menu') or self
    if not label: return

    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    if accel:
        label = '%s\t%s' % (label,accel)

    if menu.leo_label == 'File': g.trace(label,g.callers(4))

    action = menu.addAction(label)

    if command:
        def add_command_callback(label=label,command=command):
            return command()

        QtCore.QObject.connect(action,
            QtCore.SIGNAL("triggered()"),add_command_callback)
#@-node:ekr.20081121105001.362:add_command (qt)
#@+node:ekr.20081121105001.363:add_separator
def add_separator(self,menu):

    """Wrapper for the Tkinter add_separator menu method."""

    if menu:
        menu.addSeparator()
#@-node:ekr.20081121105001.363:add_separator
#@+node:ekr.20081121105001.364:delete
def delete (self,menu,realItemName):

    """Wrapper for the Tkinter delete menu method."""

    # if menu:
        # return menu.delete(realItemName)
#@-node:ekr.20081121105001.364:delete
#@+node:ekr.20081121105001.365:delete_range (leoQtMenu)
def delete_range (self,menu,n1,n2):

    """Wrapper for the Tkinter delete menu method."""

    # Menu is a subclass of QMenu and leoQtMenu.

    # g.trace(menu,n1,n2,g.callers(4))

    for z in menu.actions()[n1:n2]:
        menu.removeAction(z)
#@-node:ekr.20081121105001.365:delete_range (leoQtMenu)
#@+node:ekr.20081121105001.366:destroy
def destroy (self,menu):

    """Wrapper for the Tkinter destroy menu method."""

    # if menu:
        # return menu.destroy()
#@-node:ekr.20081121105001.366:destroy
#@+node:ekr.20081121105001.367:insert
def insert (self,menuName,position,label,command,underline=None):

    # g.trace(menuName,position,label,command,underline)

    menu = self.getMenu(menuName)
    if menu and label:
        n = underline
        if -1 > n > len(label):
            label = label[:n] + '&' + label[n:]
        action = menu.addAction(label)
        if command:
            def insert_callback(label=label,command=command):
                command()
            QtCore.QObject.connect(
                action,QtCore.SIGNAL("triggered()"),insert_callback)
#@-node:ekr.20081121105001.367:insert
#@+node:ekr.20081121105001.368:insert_cascade
def insert_cascade (self,parent,index,label,menu,underline):

    """Wrapper for the Tkinter insert_cascade menu method."""

    g.trace(label,menu)

    menu.setTitle(label)
    menu.leo_label = label

    if parent:
        parent.addMenu(menu)
    else:
        self.menuBar.addMenu(menu)

    return menu
#@-node:ekr.20081121105001.368:insert_cascade
#@+node:ekr.20081121105001.369:new_menu (qt)
def new_menu(self,parent,tearoff=False,label=''): # label is for debugging.

    """Wrapper for the Tkinter new_menu menu method."""

    c = self.c ; leoFrame = self.frame

    # g.trace(parent,label)

    # Parent can be None, in which case it will be added to the menuBar.
    menu = qtMenuWrapper(c,leoFrame,parent)

    return menu
#@nonl
#@-node:ekr.20081121105001.369:new_menu (qt)
#@-node:ekr.20081121105001.360:Methods with Tk spellings
#@+node:ekr.20081121105001.370:Methods with other spellings (Qtmenu)
#@+node:ekr.20081121105001.371:clearAccel
def clearAccel(self,menu,name):

    pass

    # if not menu:
        # return

    # realName = self.getRealMenuName(name)
    # realName = realName.replace("&","")

    # menu.entryconfig(realName,accelerator='')
#@-node:ekr.20081121105001.371:clearAccel
#@+node:ekr.20081121105001.372:createMenuBar (Qtmenu)
def createMenuBar(self,frame):

    '''Create all top-level menus.
    The menuBar itself has already been created.'''

    self.createMenusFromTables()
#@-node:ekr.20081121105001.372:createMenuBar (Qtmenu)
#@+node:ekr.20081121105001.373:createOpenWithMenu
def createOpenWithMenu(self,parent,label,index,amp_index):

    '''Create a submenu.'''

    c = self.c ; leoFrame = c.frame

    g.trace()

    # menu = qtMenuWrapper(c,leoFrame,parent)
    # self.insert_cascade(parent,index,label,menu,underline=amp_index)

    # menu = Tk.Menu(parent,tearoff=0)
    # if menu:
        # parent.insert_cascade(index,label=label,menu=menu,underline=amp_index)
    # return menu
#@-node:ekr.20081121105001.373:createOpenWithMenu
#@+node:ekr.20081121105001.374:disableMenu
def disableMenu (self,menu,name):

    if not menu:
        return

    # try:
        # menu.entryconfig(name,state="disabled")
    # except: 
        # try:
            # realName = self.getRealMenuName(name)
            # realName = realName.replace("&","")
            # menu.entryconfig(realName,state="disabled")
        # except:
            # g.pr("disableMenu menu,name:",menu,name)
            # g.es_exception()
#@-node:ekr.20081121105001.374:disableMenu
#@+node:ekr.20081121105001.375:enableMenu
# Fail gracefully if the item name does not exist.

def enableMenu (self,menu,name,val):

    if not menu:
        return

    # state = g.choose(val,"normal","disabled")
    # try:
        # menu.entryconfig(name,state=state)
    # except:
        # try:
            # realName = self.getRealMenuName(name)
            # realName = realName.replace("&","")
            # menu.entryconfig(realName,state=state)
        # except:
            # g.pr("enableMenu menu,name,val:",menu,name,val)
            # g.es_exception()
#@nonl
#@-node:ekr.20081121105001.375:enableMenu
#@+node:ekr.20081121105001.376:getMenuLabel
def getMenuLabel (self,menu,name):

    '''Return the index of the menu item whose name (or offset) is given.
    Return None if there is no such menu item.'''

    g.trace('menu',menu,'name',name)

    actions = menu.actions()
    for action in actions:
        g.trace(action.label())

    # try:
        # index = menu.index(name)
    # except:
        # index = None

    # return index
#@-node:ekr.20081121105001.376:getMenuLabel
#@+node:ekr.20081121105001.377:setMenuLabel
def setMenuLabel (self,menu,name,label,underline=-1):

    def munge(s):
        s = g.app.gui.toUnicode(s)
        return s.replace('&','')

    # menu is a qtMenuWrapper.

    # g.trace('menu',menu,'name: %20s label: %s' % (name,label))

    if not menu: return

    realName  = munge(self.getRealMenuName(name))
    realLabel = self.getRealMenuName(label)
    for action in menu.actions():
        s = munge(action.text())
        s = s.split('\t')[0]
        if s == realName:
            action.setText(realLabel)
            break
#@-node:ekr.20081121105001.377:setMenuLabel
#@-node:ekr.20081121105001.370:Methods with other spellings (Qtmenu)
#@-node:ekr.20081121105001.359:Tkinter menu bindings
#@+node:ekr.20081121105001.378:getMacHelpMenu
def getMacHelpMenu (self,table):

    return None

    # defaultTable = [
            # # &: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
            # ('&About Leo...',           'about-leo'),
            # ('Online &Home Page',       'open-online-home'),
            # '*open-online-&tutorial',
            # '*open-&users-guide',
            # '-',
            # ('Open Leo&Docs.leo',       'open-leoDocs-leo'),
            # ('Open Leo&Plugins.leo',    'open-leoPlugins-leo'),
            # ('Open Leo&Settings.leo',   'open-leoSettings-leo'),
            # ('Open &myLeoSettings.leo', 'open-myLeoSettings-leo'),
            # ('Open scr&ipts.leo',       'open-scripts-leo'),
            # '-',
            # '*he&lp-for-minibuffer',
            # '*help-for-&command',
            # '-',
            # '*&apropos-autocompletion',
            # '*apropos-&bindings',
            # '*apropos-&debugging-commands',
            # '*apropos-&find-commands',
            # '-',
            # '*pri&nt-bindings',
            # '*print-c&ommands',
        # ]

    # try:
        # topMenu = self.getMenu('top')
        # # Use the name argument to create the special Macintosh Help menu.
        # helpMenu = Tk.Menu(topMenu,name='help',tearoff=0)
        # self.add_cascade(topMenu,label='Help',menu=helpMenu,underline=0)
        # self.createMenuEntries(helpMenu,table or defaultTable)
        # return helpMenu

    # except Exception:
        # g.trace('Can not get MacOS Help menu')
        # g.es_exception()
        # return None
#@-node:ekr.20081121105001.378:getMacHelpMenu
#@-node:ekr.20081121105001.354:class leoQtMenu (leoMenu)
#@+node:ekr.20081121105001.365:delete_range (leoQtMenu)
def delete_range (self,menu,n1,n2):

    """Wrapper for the Tkinter delete menu method."""

    # Menu is a subclass of QMenu and leoQtMenu.

    # g.trace(menu,n1,n2,g.callers(4))

    for z in menu.actions()[n1:n2]:
        menu.removeAction(z)
#@-node:ekr.20081121105001.365:delete_range (leoQtMenu)
#@-node:ekr.20090128113654.1:Fixed bug re: duplicate recent-files menu
#@+node:ekr.20090304084841.14:isearch now works for tkinter
# The fix was in k.showStateAndMode:
# it does nothing when in isearch mode.
#@nonl
#@-node:ekr.20090304084841.14:isearch now works for tkinter
#@+node:ekr.20090306060335.1:Fixed "missing children" bug
@nocolor-node

- Made several changes to Leo's core. The new pattern is to call c.redraw or
  c.redraw_after_select after c.selectPosition. That is, c.selectPosition no
  longer does an automatic redraw.

- **However**, qtGui.redraw_after_select *does* do a redraw if the selected node
  was not previously visible.
#@nonl
#@+node:ekr.20090306060335.2:Report
@nocolor-node

create @button totop

p = g.findTopLevelNode(c, 'toplevel')
c.selectPosition(g.findNodeInChildren(c, p, 'one'))

Create a top level node "toplevel"
give it two children, "one", and "two"
give "one" two children, "foo" and "bar"
Leaving "one" expanded, collapse "toplevel"
save the file
reload the file
click the "totop" button.

"one" appears to have no children... !
collapse and expand "toplevel", phew, the children have returned
#@nonl
#@-node:ekr.20090306060335.2:Report
#@+node:ekr.20090124174652.52:Selecting & editing... (nativeTree)
#@+node:ekr.20090124174652.53:afterSelectHint (nativeTree)
def afterSelectHint (self,p,old_p):

    trace = False and not g.unitTesting
    c = self.c

    self.selecting = False

    if self.busy():
        self.error('afterSelectHint busy!: %s' % self.busy())

    if not p:
        return self.error('no p')
    if p != c.currentPosition():
        return self.error('p is not c.currentPosition()')

    if trace: g.trace(p and p.h,g.callers(4))

    # We don't redraw during unit testing: an important speedup.
    if c.expandAllAncestors(p) and not g.unitTesting:
        self.full_redraw(p)
    else:
        c.outerUpdate() # Bring the tree up to date.
        self.setItemForCurrentPosition(scroll=False)
#@-node:ekr.20090124174652.53:afterSelectHint (nativeTree)
#@+node:ekr.20090124174652.54:beforeSelectHint (nativeTree)
def beforeSelectHint (self,p,old_p):

    trace = False and not g.unitTesting

    if self.busy(): return

    if trace: g.trace(p and p.h)

    # Disable onTextChanged.
    self.selecting = True
#@-node:ekr.20090124174652.54:beforeSelectHint (nativeTree)
#@+node:ekr.20090124174652.55:edit_widget (nativeTree)
def edit_widget (self,p):

    """Returns the edit widget for position p."""

    trace = False and not g.unitTesting
    verbose = True

    c = self.c
    item = self.position2item(p)
    if item:
        e = self.getTreeEditorForItem(item)
        if e:
            # Create a wrapper widget for Leo's core.
            w = self.headlineWrapper(widget=e,name='head',c=c)
            # if trace: g.trace(e,p and p.h)
            return w
        else:
            # This is not an error
            # But warning: calling this method twice might not work!
            if trace and verbose: g.trace('no e for %s' % (p))
            return None
    else:
        if trace and verbose: self.error('no item for %s' % (p))
        return None
#@nonl
#@-node:ekr.20090124174652.55:edit_widget (nativeTree)
#@+node:ekr.20090124174652.56:editLabel (nativeTree)
def editLabel (self,p,selectAll=False,selection=None):

    """Start editing p's headline."""

    trace = False ; verbose = False

    if self.busy():
        return

    c = self.c

    if trace: g.trace('***',p and p.h,g.callers(4))

    c.outerUpdate()
        # Do any scheduled redraw.
        # This won't do anything in the new redraw scheme.

    item = self.position2item(p)
    if item:
        e = self.editLabelHelper(item,selectAll,selection)
    else:
        e = None
        self.error('no item for %s' % p)

    # A nice hack: just set the focus request.
    if e: c.requestedFocusWidget = e
#@-node:ekr.20090124174652.56:editLabel (nativeTree)
#@+node:ekr.20090124174652.57:editPosition (nativeTree)
def editPosition(self):

    c = self.c ; p = c.currentPosition()
    ew = self.edit_widget(p)
    return ew and p or None
#@-node:ekr.20090124174652.57:editPosition (nativeTree)
#@+node:ekr.20090124174652.58:endEditLabel (nativeTree)
def endEditLabel (self):

    '''Override leoTree.endEditLabel.

    End editing of the presently-selected headline.'''

    c = self.c ; p = c.currentPosition()

    self.onHeadChanged(p)
#@nonl
#@-node:ekr.20090124174652.58:endEditLabel (nativeTree)
#@+node:ekr.20090124174652.59:onHeadChanged (nativeTree)
# Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None,e=None):

    '''Officially change a headline.'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; u = c.undoer
    if not p:
        if trace: g.trace('** no p')
        return

    item = self.getCurrentItem()
    if not e:
        e = self.getTreeEditorForItem(item)
    if not e:
        if trace and verbose: g.trace('** not editing')
        return

    s = unicode(e.text())
    self.closeEditorHelper(e,item)
    oldHead = p.h
    changed = s != oldHead
    if trace: g.trace('new',repr(s),'old',p.h,g.callers())
    if changed:
        p.initHeadString(s)
        item.setText(0,s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p,oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)

    # This is a crucial shortcut.
    if g.unitTesting: return

    self.redraw_after_head_changed()

    if self.stayInTree:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
    c.outerUpdate()
#@-node:ekr.20090124174652.59:onHeadChanged (nativeTree)
#@+node:ekr.20090124174652.44:setItemForCurrentPosition (nativeTree)
def setItemForCurrentPosition (self,scroll=True):

    '''Select the item for c.currentPosition()'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; p = c.currentPosition()

    if self.busy(): return

    if not p:
        if trace and verbose: g.trace('** no p')
        return None

    item = self.position2item(p)

    if not item:
        # This is not necessarily an error.
        # We often attempt to select an item before redrawing it.
        if trace and verbose: g.trace('** no item for',p)
        return None

    item2 = self.getCurrentItem()
    if item == item2:
        if trace and verbose: g.trace('no change',self.traceItem(item))
        if scroll:
            self.scrollToItem(item)
    else:
        try:
            self.selecting = True
            # This generates gui events, so we must use a lockout.
            self.setCurrentItemHelper(item)
            if scroll:
                if trace: g.trace(self.traceItem(item),g.callers(4))
                self.scrollToItem(item)
        finally:
            self.selecting = False

    return item
#@-node:ekr.20090124174652.44:setItemForCurrentPosition (nativeTree)
#@+node:ekr.20090124174652.60:setHeadline (nativeTree)
def setHeadline (self,p,s):

    '''Force the actual text of the headline widget to p.h.'''

    trace = False and not g.unitTesting

    # This is used by unit tests to force the headline and p into alignment.
    if not p:
        if trace: g.trace('*** no p')
        return

    # Don't do this here: the caller should do it.
    # p.setHeadString(s)
    e = self.edit_widget(p)
    if e:
        if trace: g.trace('e',s)
        e.setAllText(s)
    else:
        item = self.position2item(p)
        if item:
            if trace: g.trace('item',s)
            self.setItemText(item,s)
        else:
            if trace: g.trace('*** failed. no item for %s' % p.h)
#@-node:ekr.20090124174652.60:setHeadline (nativeTree)
#@-node:ekr.20090124174652.52:Selecting & editing... (nativeTree)
#@+node:ekr.20090129062500.10:busy (nativeTree)
def busy (self):

    '''Return True (actually, a debugging string)
    if any lockout is set.'''

    trace = False
    table = (
        (self.contracting,  'contracting'),
        (self.expanding,    'expanding'),
        (self.redrawing,    'redrawing'),
        (self.selecting,    'selecting'))

    item = self.getCurrentItem()

    aList = []
    for ivar,kind in table:
        if ivar:
            aList.append(kind)
    kinds = ','.join(aList)

    if aList and trace:
        g.trace(self.traceItem(item),kinds,g.callers(4))

    return kinds # Return the string for debugging
#@-node:ekr.20090129062500.10:busy (nativeTree)
#@+node:ekr.20090124174652.16:Entry points (nativeTree)
#@+node:ekr.20090124174652.17:full_redraw & helpers
# forceDraw not used. It is used in the Tk code.

def full_redraw (self,p=None,scroll=True,forceDraw=False):

    '''Redraw all visible nodes of the tree.

    Preserve the vertical scrolling unless scroll is True.'''

    trace = False and not g.app.unitTesting
    verbose = True
    c = self.c

    if self.busy():
        return g.trace('*** full_redraw: busy!',g.callers(5))

    if p is None:   p = c.currentPosition()
    else:           c.setCurrentPosition(p)

    self.redrawCount += 1
    if trace: t1 = g.getTime()
    self.initData()
    self.nodeDrawCount = 0
    try:
        self.redrawing = True
        self.drawTopTree(p,scroll)
    finally:
        self.redrawing = False

    self.setItemForCurrentPosition(scroll=True)
    c.requestRedrawFlag= False

    if trace:
        theTime = g.timeSince(t1)
        callers = g.choose(verbose,g.callers(5),'')
        g.trace('%s: drew %3s nodes in %s' % (
            self.redrawCount,self.nodeDrawCount,theTime),callers)

# Compatibility
redraw = full_redraw 
redraw_now = full_redraw
#@+node:ekr.20090124174652.19:drawChildren
def drawChildren (self,p,parent_item):

    trace = False and not g.unitTesting

    if trace: g.trace('children? %5s expanded? %5s %s' % (
        p.hasChildren(),p.isExpanded(),p.h))

    if not p:
        return g.trace('can not happen: no p')

    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child,parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child,parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
#@-node:ekr.20090124174652.19:drawChildren
#@+node:ekr.20090124174652.20:drawNode
def drawNode (self,p,parent_item):

    trace = False
    c = self.c 
    self.nodeDrawCount += 1

    # Allocate the item.
    item = self.createTreeItem(p,parent_item) 

    # Do this now, so self.isValidItem will be true in setItemIcon.
    self.rememberItem(p,item)

    # Set the headline and maybe the icon.
    self.setItemText(item,p.h)
    if p:
        self.drawItemIcon(p,item)

    if trace: g.trace(self.traceItem(item))

    return item
#@-node:ekr.20090124174652.20:drawNode
#@+node:ekr.20090129062500.12:drawTopTree
def drawTopTree (self,p,scroll):

    c = self.c
    hPos,vPos = self.getScroll()
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p ; h = p.h
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()

    self.setHScroll(hPos)
    if scroll:
        pass
    else:
        # Retain former scroll position.
        self.setVScroll(vPos)

    self.repaint()
#@nonl
#@-node:ekr.20090129062500.12:drawTopTree
#@+node:ekr.20090124174652.21:drawTree
def drawTree (self,p,parent_item=None):

    # Draw the (visible) parent node.
    item = self.drawNode(p,parent_item)

    # Draw all the visible children.
    self.drawChildren(p,parent_item=item)


#@-node:ekr.20090124174652.21:drawTree
#@+node:ekr.20090124174652.22:initData
def initData (self):

    # g.trace('*****')

    self.item2vnodeDict = {}
    self.tnode2itemsDict = {}
    self.vnode2itemsDict = {}
#@-node:ekr.20090124174652.22:initData
#@+node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
def rememberItem (self,p,item):

    self.rememberVnodeItem(p.v,item)

def rememberVnodeItem (self,v,item):

    # Update item2vnodeDict.
    self.item2vnodeDict[item] = v

    # Update tnode2itemsDict & vnode2itemsDict.
    table = (
        (self.tnode2itemsDict,v.t),
        (self.vnode2itemsDict,v))

    for d,key in table:
        aList = d.get(key,[])
        if item in aList:
            g.trace('*** ERROR *** item already in list: %s, %s' % (item,aList))
        else:
            aList.append(item)
        d[key] = aList
#@nonl
#@-node:ekr.20090124174652.23:rememberItem & rememberVnodeItem
#@-node:ekr.20090124174652.17:full_redraw & helpers
#@+node:ekr.20090124174652.24:redraw_after_contract
def redraw_after_contract (self,p=None):

    if self.redrawing:
        return

    item = self.position2item(p)

    if item:
        self.contractItem(item)
    else:
        # This is not an error.
        # We may have contracted a node that was not, in fact, visible.
        self.full_redraw(scroll=False)
#@-node:ekr.20090124174652.24:redraw_after_contract
#@+node:ekr.20090124174652.25:redraw_after_expand
def redraw_after_expand (self,p=None):

    # Important, setting scrolling to False makes the problem *worse*
    self.full_redraw (p,scroll=True)
#@-node:ekr.20090124174652.25:redraw_after_expand
#@+node:ekr.20090124174652.26:redraw_after_head_changed
def redraw_after_head_changed (self):

    trace = False and not g.unitTesting

    if self.busy(): return

    c = self.c ; p = c.currentPosition()
    ew = self.edit_widget(p)

    if trace: g.trace(p.h)

    currentItem = self.getCurrentItem()

    if p:
        for item in self.tnode2items(p.v.t):
            if self.isValidItem(item):
                self.setItemText(item,p.h)
#@-node:ekr.20090124174652.26:redraw_after_head_changed
#@+node:ekr.20090124174652.27:redraw_after_icons_changed
def redraw_after_icons_changed (self):

    trace = False and not g.unitTesting

    if self.busy(): return

    self.redrawCount += 1 # To keep a unit test happy.

    c = self.c

    if trace: g.trace(c.p.h,g.callers(4))

    # Suppress call to setHeadString in onItemChanged!
    self.redrawing = True
    try:
        item = self.getCurrentItem()
        for p in c.rootPosition().self_and_siblings_iter():
            self.updateVisibleIcons(p)
    finally:
        self.redrawing = False
#@-node:ekr.20090124174652.27:redraw_after_icons_changed
#@+node:ekr.20090124174652.28:redraw_after_select
# Important: this can not replace before/afterSelectHint.

def redraw_after_select (self,p=None):

    '''Redraw the entire tree when an invisible node
    is selected.'''

    trace = False and not g.unitTesting

    if trace: g.trace('(leoQtTree) busy? %s %s' % (
        self.busy(),p and p.h or '<no p>'),g.callers(4))

    # Prevent the selecting lockout from disabling the redraw.
    oldSelecting = self.selecting
    self.selecting = False
    try:
        if not self.busy():
            self.full_redraw(p,scroll=False)
    finally:
        self.selecting = oldSelecting

    # c.redraw_after_select calls tree.select indirectly.
    # Do not call it again here.
#@-node:ekr.20090124174652.28:redraw_after_select
#@-node:ekr.20090124174652.16:Entry points (nativeTree)
#@+node:ekr.20090124174652.18:contractItem & expandItem
def contractItem (self,item):

    # g.trace(g.callers(4))

    self.treeWidget.collapseItem(item)

def expandItem (self,item):

    # g.trace(g.callers(4))

    self.treeWidget.expandItem(item)
#@-node:ekr.20090124174652.18:contractItem & expandItem
#@+node:ekr.20090124174652.53:afterSelectHint (nativeTree)
def afterSelectHint (self,p,old_p):

    trace = False and not g.unitTesting
    c = self.c

    self.selecting = False

    if self.busy():
        self.error('afterSelectHint busy!: %s' % self.busy())

    if not p:
        return self.error('no p')
    if p != c.currentPosition():
        return self.error('p is not c.currentPosition()')

    if trace: g.trace(p and p.h,g.callers(4))

    # We don't redraw during unit testing: an important speedup.
    if c.expandAllAncestors(p) and not g.unitTesting:
        self.full_redraw(p)
    else:
        c.outerUpdate() # Bring the tree up to date.
        self.setItemForCurrentPosition(scroll=False)
#@-node:ekr.20090124174652.53:afterSelectHint (nativeTree)
#@+node:ekr.20090124174652.44:setItemForCurrentPosition (nativeTree)
def setItemForCurrentPosition (self,scroll=True):

    '''Select the item for c.currentPosition()'''

    trace = False and not g.unitTesting
    verbose = False

    c = self.c ; p = c.currentPosition()

    if self.busy(): return

    if not p:
        if trace and verbose: g.trace('** no p')
        return None

    item = self.position2item(p)

    if not item:
        # This is not necessarily an error.
        # We often attempt to select an item before redrawing it.
        if trace and verbose: g.trace('** no item for',p)
        return None

    item2 = self.getCurrentItem()
    if item == item2:
        if trace and verbose: g.trace('no change',self.traceItem(item))
        if scroll:
            self.scrollToItem(item)
    else:
        try:
            self.selecting = True
            # This generates gui events, so we must use a lockout.
            self.setCurrentItemHelper(item)
            if scroll:
                if trace: g.trace(self.traceItem(item),g.callers(4))
                self.scrollToItem(item)
        finally:
            self.selecting = False

    return item
#@-node:ekr.20090124174652.44:setItemForCurrentPosition (nativeTree)
#@-node:ekr.20090306060335.1:Fixed "missing children" bug
#@+node:ekr.20090307110717.1:Fixed @color/@nocolor interaction
Nodes that contain @color and @nocolor are colored properly,
but incremental coloring doesn allway work properly.

And @color and @nocolor should only be colored at the start of a line.
#@nonl
#@+node:ekr.20090214075058.12:findColorDirectives
color_directives_pat = re.compile(
    # Order is important: put longest matches first.
    r'(^@color|^@killcolor|^@nocolor-node|^@nocolor)'
    ,re.MULTILINE)

def findColorDirectives (self,p):

    '''Scan p for @color, @killcolor, @nocolor and @nocolor-node directives.

    Return a dict containing pointers to the start of each directive.'''

    trace = False and not g.unitTesting

    d = {}
    anIter = self.color_directives_pat.finditer(p.b)
    for m in anIter:
        # Remove leading '@' for compatibility with
        # functions in leoGlobals.py.
        word = m.group(0)[1:]
        d[word] = word

    if trace: g.trace(d)
    return d
#@-node:ekr.20090214075058.12:findColorDirectives
#@+node:ekr.20081205131308.52:addLeoRules
def addLeoRules (self,theDict):

    '''Put Leo-specific rules to theList.'''

    table = (
        # Rules added at front are added in **reverse** order.
        ('@',  self.match_leo_keywords,True), # Called after all other Leo matchers.
            # Debatable: Leo keywords override langauge keywords.
        ('@',  self.match_at_color,    True),
        ('@',  self.match_at_killcolor,True),
        ('@',  self.match_at_nocolor,  True),
        ('@',  self.match_at_nocolor_node,True),
        ('@',  self.match_doc_part,    True), 
        ('<',  self.match_section_ref, True), # Called **first**.
        # Rules added at back are added in normal order.
        (' ',  self.match_blanks,      False),
        ('\t', self.match_tabs,        False),
    )

    for ch, rule, atFront, in table:

        # Replace the bound method by an unbound method.
        rule = rule.im_func
        # g.trace(rule)

        theList = theDict.get(ch,[])
        if rule not in theList:
            if atFront:
                theList.insert(0,rule)
            else:
                theList.append(rule)
            theDict [ch] = theList

    # g.trace(g.listToString(theDict.get('@')))
#@-node:ekr.20081205131308.52:addLeoRules
#@+node:ekr.20081204090029.1:Syntax coloring
#@+node:ekr.20081205131308.15:leoQtColorizer
# This is c.frame.body.colorizer

class leoQtColorizer:

    '''An adaptor class that interfaces Leo's core to two class:

    1. a subclass of QSyntaxHighlighter,

    2. the jEditColorizer class that contains the
       pattern-matchin code from the threading colorizer plugin.'''

    @others

#@+node:ekr.20081205131308.16: ctor (leoQtColorizer)
def __init__ (self,c,w):

    # g.pr('leoQtColorizer.__init__',c,w,g.callers(4))

    self.c = c
    self.w = w

    # Step 1: create the ivars.
    self.count = 0 # For unit testing.
    self.enabled = c.config.getBool('use_syntax_coloring')
    self.error = False # Set if there is an error in jeditColorizer.recolor
    self.flag = True # Per-node enable/disable flag.
    self.killColorFlag = False
    self.language = 'python' # set by scanColorDirectives.

    # Step 2: create the highlighter.
    self.highlighter = leoQtSyntaxHighlighter(c,w,colorizer=self)
    self.colorer = self.highlighter.colorer

    # Step 3: finish enabling.
    if self.enabled:
        self.enabled = hasattr(self.highlighter,'currentBlock')
#@-node:ekr.20081205131308.16: ctor (leoQtColorizer)
#@+node:ekr.20081205131308.18:colorize (leoQtColorizer)
def colorize(self,p,incremental=False,interruptable=True):

    '''The main colorizer entry point.'''

    trace = False and not g.unitTesting

    if trace:
        g.trace('*** incremental %s' % (incremental))

    self.count += 1 # For unit testing.

    if self.enabled:
        self.updateSyntaxColorer(p) # sets self.flag.
        if self.flag and not incremental:
            self.highlighter.rehighlight(p)

    return "ok" # For unit testing.
#@-node:ekr.20081205131308.18:colorize (leoQtColorizer)
#@+node:ekr.20090302125215.10:enable/disable
def disable (self,p):

    g.trace(g.callers(4))

    if self.enabled:
        self.flag = False
        self.enabled = False
        self.highlighter.rehighlight(p) # Do a full recolor (to black)

def enable (self,p):

    g.trace(g.callers(4))

    if not self.enabled:
        self.enabled = True
        self.flag = True
        # Do a full recolor, but only if we aren't changing nodes.
        if self.c.currentPosition() == p:
            self.highlighter.rehighlight(p)
#@-node:ekr.20090302125215.10:enable/disable
#@+node:ekr.20081207061047.10:minor entry points
def interrupt(self):
    pass

def isSameColorState (self):
    return True # Disable some logic in leoTree.select.

def kill (self):
    pass
#@-node:ekr.20081207061047.10:minor entry points
#@+node:ekr.20090226105328.12:scanColorDirectives (leoQtColorizer)
def scanColorDirectives(self,p):

    trace = False and not g.unitTesting

    p = p.copy() ; c = self.c
    if c == None: return # self.c may be None for testing.

    self.language = language = c.target_language
    self.rootMode = None # None, "code" or "doc"

    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        << Test for @language >>
        << Test for @root, @root-doc or @root-code >>

    if trace: g.trace(self.language)

    return self.language # For use by external routines.
#@+node:ekr.20090226105328.13:<< Test for @language >>
if 'language' in theDict:
    s = theDict["language"]
    i = g.skip_ws(s,0)
    j = g.skip_c_id(s,i)
    self.language = s[i:j].lower()
    break
#@-node:ekr.20090226105328.13:<< Test for @language >>
#@+node:ekr.20090226105328.14:<< Test for @root, @root-doc or @root-code >>
if 'root' in theDict and not self.rootMode:

    s = theDict["root"]
    if g.match_word(s,0,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,0,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@nonl
#@-node:ekr.20090226105328.14:<< Test for @root, @root-doc or @root-code >>
#@-node:ekr.20090226105328.12:scanColorDirectives (leoQtColorizer)
#@+node:ekr.20090216070256.11:setHighlighter
def setHighlighter (self,p):

    trace = False and not g.unitTesting
    if trace: g.trace(p.h,g.callers(4))

    c = self.c

    if self.enabled:
        self.flag = self.updateSyntaxColorer(p)
        if self.flag:
            # Do a full recolor, but only if we aren't changing nodes.
            if self.c.currentPosition() == p:
                self.highlighter.rehighlight(p)
        else:
            self.highlighter.rehighlight(p) # Do a full recolor (to black)
    else:
        self.highlighter.rehighlight(p) # Do a full recolor (to black)

    # g.trace(flag,p.h)
#@-node:ekr.20090216070256.11:setHighlighter
#@+node:ekr.20081205131308.24:updateSyntaxColorer
def updateSyntaxColorer (self,p):

    trace = False and not g.unitTesting
    p = p.copy()

    # self.flag is True unless an unambiguous @nocolor is seen.
    self.flag = self.useSyntaxColoring(p)
    self.scanColorDirectives(p)

    if trace: g.trace(self.flag,self.language,p.h)
    return self.flag
#@-node:ekr.20081205131308.24:updateSyntaxColorer
#@+node:ekr.20081205131308.23:useSyntaxColoring & helper
def useSyntaxColoring (self,p):

    """Return True unless p is unambiguously under the control of @nocolor."""

    trace = False and not g.unitTesting
    if not p:
        if trace: g.trace('no p',repr(p))
        return False

    p = p.copy()
    first = True ; kind = None ; val = True
    self.killColorFlag = False
    for p in p.self_and_parents_iter():
        d = self.findColorDirectives(p)
        color,no_color = 'color' in d,'nocolor' in d
        # An @nocolor-node in the first node disabled coloring.
        if first and 'nocolor-node' in d:
            kind = '@nocolor-node'
            self.killColorFlag = True
            val = False ; break
        # A killcolor anywhere disables coloring.
        elif 'killcolor' in d:
            kind = '@killcolor %s' % p.h
            self.killColorFlag = True
            val = False ; break
        # A color anywhere in the target enables coloring.
        elif color and first:
            kind = 'color %s' % p.h
            val = True ; break
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            kind = '@nocolor %s' % p.h
            val = False ; break
        elif color and not no_color:
            kind = '@color %s' % p.h
            val = True ; break
        first = False

    if trace: g.trace(val,kind)
    return val
#@+node:ekr.20090214075058.12:findColorDirectives
color_directives_pat = re.compile(
    # Order is important: put longest matches first.
    r'(^@color|^@killcolor|^@nocolor-node|^@nocolor)'
    ,re.MULTILINE)

def findColorDirectives (self,p):

    '''Scan p for @color, @killcolor, @nocolor and @nocolor-node directives.

    Return a dict containing pointers to the start of each directive.'''

    trace = False and not g.unitTesting

    d = {}
    anIter = self.color_directives_pat.finditer(p.b)
    for m in anIter:
        # Remove leading '@' for compatibility with
        # functions in leoGlobals.py.
        word = m.group(0)[1:]
        d[word] = word

    if trace: g.trace(d)
    return d
#@-node:ekr.20090214075058.12:findColorDirectives
#@-node:ekr.20081205131308.23:useSyntaxColoring & helper
#@-node:ekr.20081205131308.15:leoQtColorizer
#@+node:ekr.20081205131308.27:leoQtSyntaxHighlighter
# This is c.frame.body.colorizer.highlighter

class leoQtSyntaxHighlighter(QtGui.QSyntaxHighlighter):

    '''A subclass of QSyntaxHighlighter that overrides
    the highlightBlock and rehighlight methods.

    All actual syntax coloring is done in the jeditColorer class.'''

    @others
#@+node:ekr.20081205131308.1:ctor (leoQtSyntaxHighlighter)
def __init__ (self,c,w,colorizer):

    self.c = c
    self.w = w

    # print('leoQtSyntaxHighlighter.__init__',w)

    # Not all versions of Qt have the crucial currentBlock method.
    self.hasCurrentBlock = hasattr(self,'currentBlock')

    # Init the base class.
    QtGui.QSyntaxHighlighter.__init__(self,w)

    self.colorizer = colorizer

    self.colorer = jEditColorizer(c,
        colorizer=colorizer,
        highlighter=self,
        w=c.frame.body.bodyCtrl)
#@-node:ekr.20081205131308.1:ctor (leoQtSyntaxHighlighter)
#@+node:ekr.20090216070256.10:enable/disable & disabledRehighlight
# def enable (self,p):

    # if not self.enabled:
        # self.enabled = True
        # self.colorer.flag = True
        # # Do a full recolor, but only if we aren't changing nodes.
        # if self.c.currentPosition() == p:
            # self.rehighlight(p)

# def disable (self,p):

    # if self.enabled:
        # self.enabled = False
        # self.colorer.flag = False
        # self.rehighlight(p) # Do a full recolor (to black)
#@nonl
#@-node:ekr.20090216070256.10:enable/disable & disabledRehighlight
#@+node:ekr.20081205131308.11:highlightBlock
def highlightBlock (self,s):
    """ Called by QSyntaxHiglighter """

    if self.hasCurrentBlock:
        colorer = self.colorer
        s = unicode(s)
        colorer.recolor(s)
#@-node:ekr.20081205131308.11:highlightBlock
#@+node:ekr.20081206062411.15:rehighlight
def rehighlight (self,p):

    '''Override base rehighlight method'''

    trace = False and not g.unitTesting

    s = unicode(self.w.toPlainText())
    self.colorer.init(p,s)
    n = self.colorer.recolorCount

    if trace: g.trace('** enabled',self.colorizer.enabled)

    # Call the base class method, but *only*
    # if the crucial 'currentBlock' method exists.
    if self.colorizer.enabled and self.hasCurrentBlock:
        QtGui.QSyntaxHighlighter.rehighlight(self)

    if trace:
        g.trace('%s calls to recolor' % (
            self.colorer.recolorCount-n))



#@-node:ekr.20081206062411.15:rehighlight
#@-node:ekr.20081205131308.27:leoQtSyntaxHighlighter
#@+node:ekr.20081205131308.48:class jeditColorizer
# This is c.frame.body.colorizer.highlighter.colorer

class jEditColorizer:

    '''This class contains the pattern matching code
    from the threading_colorizer plugin, adapted for
    use with QSyntaxHighlighter.'''

    @others
#@+node:ekr.20081205131308.49: Birth & init
#@+node:ekr.20081205131308.50:__init__ (jeditColorizer)
def __init__(self,c,colorizer,highlighter,w):

    # Basic data...
    self.c = c
    self.colorizer = colorizer
    self.highlighter = highlighter # a QSyntaxHighlighter
    self.p = None
    self.w = w
    assert(w == self.c.frame.body.bodyCtrl)

    # Used by recolor and helpers...
    self.all_s = '' # The cached string to be colored.
    self.actualColorDict = {} # Used only by setTag.
    self.global_i,self.global_j = 0,0 # The global bounds of colorizing.
    self.global_offset = 0
    self.hyperCount = 0
    self.initFlag = False # True if recolor must reload self.all_s.
    self.defaultState = u'default-state:' # The name of the default state.
    self.minimalMatch = ''
    self.nextState = 1 # Dont use 0.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.

    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Config settings...
    self.showInvisibles = False # True: show "invisible" characters.
    self.underline_undefined = c.config.getBool("underline_undefined_section_names")
    self.use_hyperlinks = c.config.getBool("use_hyperlinks")
    # Debugging...
    self.count = 0 # For unit testing.
    self.allow_mark_prev = True # The new colorizer tolerates this nonsense :-)
    self.trace = False or c.config.getBool('trace_colorizer')
    self.trace_leo_matches = False
    self.trace_match_flag = False # (Useful) True: trace all matching methods.
    self.verbose = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalChars = 0 # The total number of characters examined by recolor.
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.setFontFromConfig()
    self.tags = [
        "blank","comment","cwebName","docPart","keyword","leoKeyword",
        "latexModeBackground","latexModeKeyword",
        "latexBackground","latexKeyword",
        "link","name","nameBrackets","pp","string",
        "elide","bold","bolditalic","italic", # new for wiki styling.
        "tab",
        # Leo jEdit tags...
        '@color', '@nocolor', 'doc_part', 'section_ref',
        # jEdit tags.
        'bracketRange',
        'comment1','comment2','comment3','comment4',
        'function',
        'keyword1','keyword2','keyword3','keyword4',
        'label','literal1','literal2','literal3','literal4',
        'markup','operator',
    ]

    << define leoKeywordsDict >>
    << define default_colors_dict >>
    << define default_font_dict >>

    # New in Leo 4.6: configure tags only once here.
    # Some changes will be needed for multiple body editors.
    self.configure_tags() # Must do this every time to support multiple editors.
#@+node:ekr.20081205131308.35:<< define leoKeywordsDict >>
self.leoKeywordsDict = {}

for key in g.globalDirectiveList:
    self.leoKeywordsDict [key] = 'leoKeyword'
#@nonl
#@-node:ekr.20081205131308.35:<< define leoKeywordsDict >>
#@+node:ekr.20081205131308.36:<< define default_colors_dict >>
# These defaults are sure to exist.

self.default_colors_dict = {
    # tag name       :(     option name,           default color),
    'comment'        :('comment_color',               'red'),
    'cwebName'       :('cweb_section_name_color',     'red'),
    'pp'             :('directive_color',             'blue'),
    'docPart'        :('doc_part_color',              'red'),
    'keyword'        :('keyword_color',               'blue'),
    'leoKeyword'     :('leo_keyword_color',           'blue'),
    'link'           :('section_name_color',          'red'),
    'nameBrackets'   :('section_name_brackets_color', 'blue'),
    'string'         :('string_color',                '#00aa00'), # Used by IDLE.
    'name'           :('undefined_section_name_color','red'),
    'latexBackground':('latex_background_color',      'white'),

    # Tags used by forth.
    'keyword5'       :('keyword5_color',              'blue'),
    'bracketRange'   :('bracket_range_color',         'orange'),
    # jEdit tags.

    'comment1'       :('comment1_color', 'red'),
    'comment2'       :('comment2_color', 'red'),
    'comment3'       :('comment3_color', 'red'),
    'comment4'       :('comment4_color', 'red'),
    'function'       :('function_color', 'black'),
    'keyword1'       :('keyword1_color', 'blue'),
    'keyword2'       :('keyword2_color', 'blue'),
    'keyword3'       :('keyword3_color', 'blue'),
    'keyword4'       :('keyword4_color', 'blue'),
    'label'          :('label_color',    'black'),
    'literal1'       :('literal1_color', '#00aa00'),
    'literal2'       :('literal2_color', '#00aa00'),
    'literal3'       :('literal3_color', '#00aa00'),
    'literal4'       :('literal4_color', '#00aa00'),
    'markup'         :('markup_color',   'red'),
    'null'           :('null_color',     'black'),
    'operator'       :('operator_color', 'black'),
    }
#@-node:ekr.20081205131308.36:<< define default_colors_dict >>
#@+node:ekr.20081205131308.37:<< define default_font_dict >>
self.default_font_dict = {
    # tag name      : option name
    'comment'       :'comment_font',
    'cwebName'      :'cweb_section_name_font',
    'pp'            :'directive_font',
    'docPart'       :'doc_part_font',
    'keyword'       :'keyword_font',
    'leoKeyword'    :'leo_keyword_font',
    'link'          :'section_name_font',
    'nameBrackets'  :'section_name_brackets_font',
    'string'        :'string_font',
    'name'          :'undefined_section_name_font',
    'latexBackground':'latex_background_font',

    # Tags used by forth.
    'bracketRange'   :'bracketRange_font',
    'keyword5'       :'keyword5_font',

     # jEdit tags.
    'comment1'      :'comment1_font',
    'comment2'      :'comment2_font',
    'comment3'      :'comment3_font',
    'comment4'      :'comment4_font',
    'function'      :'function_font',
    'keyword1'      :'keyword1_font',
    'keyword2'      :'keyword2_font',
    'keyword3'      :'keyword3_font',
    'keyword4'      :'keyword4_font',
    'keyword5'      :'keyword5_font',
    'label'         :'label_font',
    'literal1'      :'literal1_font',
    'literal2'      :'literal2_font',
    'literal3'      :'literal3_font',
    'literal4'      :'literal4_font',
    'markup'        :'markup_font',
    # 'nocolor' This tag is used, but never generates code.
    'null'          :'null_font',
    'operator'      :'operator_font',
    }
#@-node:ekr.20081205131308.37:<< define default_font_dict >>
#@-node:ekr.20081205131308.50:__init__ (jeditColorizer)
#@+node:ekr.20081205131308.51:addImportedRules
def addImportedRules (self,mode,rulesDict,rulesetName):

    '''Append any imported rules at the end of the rulesets specified in mode.importDict'''

    if self.importedRulesets.get(rulesetName):
        return
    else:
        self.importedRulesets [rulesetName] = True

    names = hasattr(mode,'importDict') and mode.importDict.get(rulesetName,[]) or []

    for name in names:
        savedBunch = self.modeBunch
        ok = self.init_mode(name)
        if ok:
            rulesDict2 = self.rulesDict
            for key in rulesDict2.keys():
                aList = self.rulesDict.get(key,[])
                aList2 = rulesDict2.get(key)
                if aList2:
                    # Don't add the standard rules again.
                    rules = [z for z in aList2 if z not in aList]
                    if rules:
                        # g.trace([z.__name__ for z in rules])
                        aList.extend(rules)
                        self.rulesDict [key] = aList
        # g.trace('***** added rules for %s from %s' % (name,rulesetName))
        self.initModeFromBunch(savedBunch)
#@nonl
#@-node:ekr.20081205131308.51:addImportedRules
#@+node:ekr.20081205131308.52:addLeoRules
def addLeoRules (self,theDict):

    '''Put Leo-specific rules to theList.'''

    table = (
        # Rules added at front are added in **reverse** order.
        ('@',  self.match_leo_keywords,True), # Called after all other Leo matchers.
            # Debatable: Leo keywords override langauge keywords.
        ('@',  self.match_at_color,    True),
        ('@',  self.match_at_killcolor,True),
        ('@',  self.match_at_nocolor,  True),
        ('@',  self.match_at_nocolor_node,True),
        ('@',  self.match_doc_part,    True), 
        ('<',  self.match_section_ref, True), # Called **first**.
        # Rules added at back are added in normal order.
        (' ',  self.match_blanks,      False),
        ('\t', self.match_tabs,        False),
    )

    for ch, rule, atFront, in table:

        # Replace the bound method by an unbound method.
        rule = rule.im_func
        # g.trace(rule)

        theList = theDict.get(ch,[])
        if rule not in theList:
            if atFront:
                theList.insert(0,rule)
            else:
                theList.append(rule)
            theDict [ch] = theList

    # g.trace(g.listToString(theDict.get('@')))
#@-node:ekr.20081205131308.52:addLeoRules
#@+node:ekr.20081205131308.53:configure_tags
def configure_tags (self):

    c = self.c ; w = self.w ; trace = False

    if w and hasattr(w,'start_tag_configure'):
        w.start_tag_configure()

    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont

    # Configure fonts.
    keys = self.default_font_dict.keys() ; keys.sort()
    for key in keys:
        option_name = self.default_font_dict[key]
        # First, look for the language-specific setting, then the general setting.
        for name in ('%s_%s' % (self.colorizer.language,option_name),(option_name)):
            font = self.fonts.get(name)
            if font:
                if trace: g.trace('found',name,id(font))
                w.tag_config(key,font=font)
                break
            else:
                family = c.config.get(name + '_family','family')
                size   = c.config.get(name + '_size',  'size')   
                slant  = c.config.get(name + '_slant', 'slant')
                weight = c.config.get(name + '_weight','weight')
                if family or slant or weight or size:
                    family = family or g.app.config.defaultFontFamily
                    size   = size or c.config.defaultBodyFontSize
                    slant  = slant or 'roman'
                    weight = weight or 'normal'
                    font = g.app.gui.getFontFromParams(family,size,slant,weight)
                    # Save a reference to the font so it 'sticks'.
                    self.fonts[name] = font 
                    if trace: g.trace(key,name,family,size,slant,weight,id(font))
                    w.tag_config(key,font=font)
                    break
        else: # Neither the general setting nor the language-specific setting exists.
            if self.fonts.keys(): # Restore the default font.
                if trace: g.trace('default',key)
                w.tag_config(key,font=defaultBodyfont)

    keys = self.default_colors_dict.keys() ; keys.sort()
    for name in keys:
        option_name,default_color = self.default_colors_dict[name]
        color = (
            c.config.getColor('%s_%s' % (self.colorizer.language,option_name)) or
            c.config.getColor(option_name) or
            default_color
        )
        if trace: g.trace(option_name,color)

        # Must use foreground, not fg.
        try:
            w.tag_configure(name, foreground=color)
        except: # Recover after a user error.
            g.es_exception()
            w.tag_configure(name, foreground=default_color)

    # underline=var doesn't seem to work.
    if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
        w.tag_configure("link",underline=1) # defined
        w.tag_configure("name",underline=0) # undefined
    else:
        w.tag_configure("link",underline=0)
        if self.underline_undefined:
            w.tag_configure("name",underline=1)
        else:
            w.tag_configure("name",underline=0)

    self.configure_variable_tags()

    # Colors for latex characters.  Should be user options...

    if 1: # Alas, the selection doesn't show if a background color is specified.
        w.tag_configure("latexModeBackground",foreground="black")
        w.tag_configure("latexModeKeyword",foreground="blue")
        w.tag_configure("latexBackground",foreground="black")
        w.tag_configure("latexKeyword",foreground="blue")
    else: # Looks cool, and good for debugging.
        w.tag_configure("latexModeBackground",foreground="black",background="seashell1")
        w.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
        w.tag_configure("latexBackground",foreground="black",background="white")
        w.tag_configure("latexKeyword",foreground="blue",background="white")

    # Tags for wiki coloring.
    w.tag_configure("bold",font=self.bold_font)
    w.tag_configure("italic",font=self.italic_font)
    w.tag_configure("bolditalic",font=self.bolditalic_font)
    for name in self.color_tags_list:
        w.tag_configure(name,foreground=name)

    try:
        w.end_tag_configure()
    except AttributeError:
        pass
#@-node:ekr.20081205131308.53:configure_tags
#@+node:ekr.20081205131308.54:configure_variable_tags
def configure_variable_tags (self):

    c = self.c ; w = self.w

    # g.trace()

    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80"),
        ("elide", None,                                   "yellow"),
    ):
        if self.showInvisibles:
            color = option_name and c.config.getColor(option_name) or default_color
        else:
            option_name,default_color = self.default_colors_dict.get(name,(None,None),)
            color = option_name and c.config.getColor(option_name) or ''
        try:
            w.tag_configure(name,background=color)
        except: # A user error.
            w.tag_configure(name,background=default_color)

    # Special case:
    if not self.showInvisibles:
        w.tag_configure("elide",elide="1")
#@-node:ekr.20081205131308.54:configure_variable_tags
#@+node:ekr.20081205131308.74:init (jeditColorizer)
def init (self,p,s):

    trace = False and not g.unitTesting

    if p: self.p = p.copy()
    self.all_s = s or ''

    if trace: g.trace('***',p and p.h,len(self.all_s),g.callers(4))

    # State info.
    self.all_s = s
    self.global_i,self.global_j = 0,0
    self.global_offset = 0
    self.initFlag = False
    self.nextState = 1 # Dont use 0.
    self.stateDict = {}
    self.stateNameDict = {}
    self.init_mode(self.colorizer.language)

    # Used by matchers.
    self.prev = None

    ####
    # self.configure_tags() # Must do this every time to support multiple editors.
#@-node:ekr.20081205131308.74:init (jeditColorizer)
#@+node:ekr.20081205131308.55:init_mode & helpers
def init_mode (self,name):

    '''Name may be a language name or a delegate name.'''

    trace = False and not g.unitTesting

    if not name: return False
    language,rulesetName = self.nameToRulesetName(name)
    bunch = self.modes.get(rulesetName)
    if bunch:
        if trace: g.trace('found',language,rulesetName)
        self.initModeFromBunch(bunch)
        return True
    else:
        if trace: g.trace('****',language,rulesetName)
        path = g.os_path_join(g.app.loadDir,'..','modes')
        # Bug fix: 2008/2/10: Don't try to import a non-existent language.
        fileName = g.os_path_join(path,'%s.py' % (language))
        if g.os_path_exists(fileName):
            mode = g.importFromPath (language,path)
        else: mode = None

        if mode:
            # A hack to give modes/forth.py access to c.
            if hasattr(mode,'pre_init_mode'):
                mode.pre_init_mode(self.c)
        else:
            # Create a dummy bunch to limit recursion.
            self.modes [rulesetName] = self.modeBunch = g.Bunch(
                attributesDict  = {},
                defaultColor    = None,
                keywordsDict    = {},
                language        = language,
                mode            = mode,
                properties      = {},
                rulesDict       = {},
                rulesetName     = rulesetName)
            # g.trace('No colorizer file: %s.py' % language)
            return False
        self.colorizer.language = language
        self.rulesetName = rulesetName
        self.properties = hasattr(mode,'properties') and mode.properties or {}
        self.keywordsDict = hasattr(mode,'keywordsDictDict') and mode.keywordsDictDict.get(rulesetName,{}) or {}
        self.setKeywords()
        self.attributesDict = hasattr(mode,'attributesDictDict') and mode.attributesDictDict.get(rulesetName) or {}
        self.setModeAttributes()
        self.rulesDict = hasattr(mode,'rulesDictDict') and mode.rulesDictDict.get(rulesetName) or {}
        self.addLeoRules(self.rulesDict)

        self.defaultColor = 'null'
        self.mode = mode
        self.modes [rulesetName] = self.modeBunch = g.Bunch(
            attributesDict  = self.attributesDict,
            defaultColor    = self.defaultColor,
            keywordsDict    = self.keywordsDict,
            language        = self.colorizer.language,
            mode            = self.mode,
            properties      = self.properties,
            rulesDict       = self.rulesDict,
            rulesetName     = self.rulesetName)
        # Do this after 'officially' initing the mode, to limit recursion.
        self.addImportedRules(mode,self.rulesDict,rulesetName)
        self.updateDelimsTables()

        initialDelegate = self.properties.get('initialModeDelegate')
        if initialDelegate:
            # g.trace('initialDelegate',initialDelegate)
            # Replace the original mode by the delegate mode.
            self.init_mode(initialDelegate)
            language2,rulesetName2 = self.nameToRulesetName(initialDelegate)
            self.modes[rulesetName] = self.modes.get(rulesetName2)
        return True
#@+node:ekr.20081205131308.56:nameToRulesetName
def nameToRulesetName (self,name):

    '''Compute language and rulesetName from name, which is either a language or a delegate name.'''

    if not name: return ''

    i = name.find('::')
    if i == -1:
        language = name
        rulesetName = '%s_main' % (language)
    else:
        language = name[:i]
        delegate = name[i+2:]
        rulesetName = self.munge('%s_%s' % (language,delegate))

    # g.trace(name,language,rulesetName)
    return language,rulesetName
#@nonl
#@-node:ekr.20081205131308.56:nameToRulesetName
#@+node:ekr.20081205131308.57:setKeywords
def setKeywords (self):

    '''Initialize the keywords for the present language.

     Set self.word_chars ivar to string.letters + string.digits
     plus any other character appearing in any keyword.'''

    # Add any new user keywords to leoKeywordsDict.
    d = self.keywordsDict
    keys = d.keys()
    for s in g.globalDirectiveList:
        key = '@' + s
        if key not in keys:
            d [key] = 'leoKeyword'

    # Create a temporary chars list.  It will be converted to a dict later.
    chars = [g.toUnicode(ch,encoding='UTF-8')
        for ch in (string.letters + string.digits)]

    for key in d.keys():
        for ch in key:
            if ch not in chars:
                chars.append(g.toUnicode(ch,encoding='UTF-8'))

    # jEdit2Py now does this check, so this isn't really needed.
    # But it is needed for forth.py.
    for ch in (' ', '\t'):
        if ch in chars:
            # g.es_print('removing %s from word_chars' % (repr(ch)))
            chars.remove(ch)

    # g.trace(self.colorizer.language,[str(z) for z in chars])

    # Convert chars to a dict for faster access.
    self.word_chars = {}
    for z in chars:
        self.word_chars[z] = z
#@-node:ekr.20081205131308.57:setKeywords
#@+node:ekr.20081205131308.58:setModeAttributes
def setModeAttributes (self):

    '''Set the ivars from self.attributesDict,
    converting 'true'/'false' to True and False.'''

    d = self.attributesDict
    aList = (
        ('default',         'null'),
	    ('digit_re',        ''),
        ('escape',          ''), # New in Leo 4.4.2.
	    ('highlight_digits',True),
	    ('ignore_case',     True),
	    ('no_word_sep',     ''),
    )

    for key, default in aList:
        val = d.get(key,default)
        if val in ('true','True'): val = True
        if val in ('false','False'): val = False
        setattr(self,key,val)
        # g.trace(key,val)
#@nonl
#@-node:ekr.20081205131308.58:setModeAttributes
#@+node:ekr.20081205131308.59:initModeFromBunch
def initModeFromBunch (self,bunch):

    self.modeBunch = bunch
    self.attributesDict = bunch.attributesDict
    self.setModeAttributes()
    self.defaultColor   = bunch.defaultColor
    self.keywordsDict   = bunch.keywordsDict
    self.colorizer.language = bunch.language
    self.mode           = bunch.mode
    self.properties     = bunch.properties
    self.rulesDict      = bunch.rulesDict
    self.rulesetName    = bunch.rulesetName

    # g.trace(self.rulesetName)
#@nonl
#@-node:ekr.20081205131308.59:initModeFromBunch
#@+node:ekr.20081205131308.60:updateDelimsTables
def updateDelimsTables (self):

    '''Update g.app.language_delims_dict if no entry for the language exists.'''

    d = self.properties
    lineComment = d.get('lineComment')
    startComment = d.get('commentStart')
    endComment = d.get('commentEnd')

    if lineComment and startComment and endComment:
        delims = '%s %s %s' % (lineComment,startComment,endComment)
    elif startComment and endComment:
        delims = '%s %s' % (startComment,endComment)
    elif lineComment:
        delims = '%s' % lineComment
    else:
        delims = None

    if delims:
        d = g.app.language_delims_dict
        if not d.get(self.colorizer.language):
            d [self.colorizer.language] = delims
            # g.trace(self.colorizer.language,'delims:',repr(delims))
#@-node:ekr.20081205131308.60:updateDelimsTables
#@-node:ekr.20081205131308.55:init_mode & helpers
#@+node:ekr.20081205131308.106:munge
def munge(self,s):

    '''Munge a mode name so that it is a valid python id.'''

    valid = string.ascii_letters + string.digits + '_'

    return ''.join([g.choose(ch in valid,ch.lower(),'_') for ch in s])
#@nonl
#@-node:ekr.20081205131308.106:munge
#@+node:ekr.20081205131308.111:setFontFromConfig
def setFontFromConfig (self):

    c = self.c
    # isQt = g.app.gui.guiName() == 'qt'

    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize) # , tag = "colorer bold")

    # if self.bold_font and not isQt:
        # self.bold_font.configure(weight="bold")

    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize) # , tag = "colorer italic")

    # if self.italic_font and not isQt:
        # self.italic_font.configure(slant="italic",weight="normal")

    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize) # , tag = "colorer bold italic")

    # if self.bolditalic_font and not isQt:
        # self.bolditalic_font.configure(weight="bold",slant="italic")

    self.color_tags_list = []
    # self.image_references = []
#@nonl
#@-node:ekr.20081205131308.111:setFontFromConfig
#@-node:ekr.20081205131308.49: Birth & init
#@+node:ekr.20081206062411.13:colorRangeWithTag
def colorRangeWithTag (self,s,i,j,tag,delegate='',exclude_match=False):

    '''Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.'''

    trace = False
    if self.colorizer.killColorFlag or not self.colorizer.flag: return

    if delegate:
        if trace: g.trace('delegate',delegate,i,j,tag,g.callers(3))
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        # Color everything now, using the same indices as the caller.
        while i < j:
            progress = i
            assert j >= 0, 'colorRangeWithTag: negative j'
            for f in self.rulesDict.get(s[i],[]):
                n = f(self,s,i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n > 0:
                    if trace: g.trace('delegate',delegate,i,n,f.__name__,repr(s[i:i+n]))
                    i += n ; break
            else:
                # New in Leo 4.6: Use the default chars for everything else.
                self.setTag(tag,s,i,i+1)
                i += 1
            assert i > progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        self.setTag(tag,s,i,j)
#@nonl
#@-node:ekr.20081206062411.13:colorRangeWithTag
#@+node:ekr.20081205131308.87:pattern matchers
@nocolor-node
@

The following jEdit matcher methods return the length of the matched text if the
match succeeds, and zero otherwise.  In most cases, these methods colorize all the matched text.

The following arguments affect matching:

- at_line_start         True: sequence must start the line.
- at_whitespace_end     True: sequence must be first non-whitespace text of the line.
- at_word_start         True: sequence must start a word.
- hash_char             The first character that must match in a regular expression.
- no_escape:            True: ignore an 'end' string if it is preceded by the ruleset's escape character.
- no_line_break         True: the match will not succeed across line breaks.
- no_word_break:        True: the match will not cross word breaks.

The following arguments affect coloring when a match succeeds:

- delegate              A ruleset name. The matched text will be colored recursively by the indicated ruleset.
- exclude_match         If True, the actual text that matched will not be colored.
- kind                  The color tag to be applied to colored text.
@c
@color
#@+node:ekr.20081205131308.105:dump
def dump (self,s):

    if s.find('\n') == -1:
        return s
    else:
        return '\n' + s + '\n'
#@nonl
#@-node:ekr.20081205131308.105:dump
#@+node:ekr.20081205131308.38:Leo rule functions
#@+node:ekr.20081205131308.39:match_at_color
def match_at_color (self,s,i):

    if self.trace_leo_matches: g.trace()

    seq = '@color'

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n': return 0

    if g.match_word(s,i,seq):
        self.colorizer.flag = True # Enable coloring.
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,'leoKeyword')
        return j - i
    else:
        return 0
#@nonl
#@-node:ekr.20081205131308.39:match_at_color
#@+node:ekr.20081205131308.40:match_at_nocolor
def match_at_nocolor (self,s,i):

    if self.trace_leo_matches: g.trace()

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0
    if g.match(s,i,'@nocolor-'):
        return 0
    if not g.match_word(s,i,'@nocolor'):
        return 0

    j = i + len('@nocolor')
    k = s.find('\n@color',j)
    if k == -1:
        # No later @color: don't color the @nocolor directive.
        self.colorizer.flag = False # Disable coloring.
        return len(s) - j
    else:
        # A later @color: do color the @nocolor directive.
        self.colorRangeWithTag(s,i,j,'leoKeyword')
        self.colorizer.flag = False # Disable coloring.
        return k+2-j

#@-node:ekr.20081205131308.40:match_at_nocolor
#@+node:ekr.20090308163450.10:match_at_killcolor (NEW)
def match_at_killcolor (self,s,i):

    if self.trace_leo_matches: g.trace()

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@killcolor'

    if g.match_word(s,i,tag):
        j = i + len(tag)
        self.colorizer.flag = False # Disable coloring.
        self.colorizer.killColorFlag = True
        self.minimalMatch = tag
        return len(s) - j # Match everything.
    else:
        return 0

#@-node:ekr.20090308163450.10:match_at_killcolor (NEW)
#@+node:ekr.20090308163450.11:match_at_nocolor_node (NEW)
def match_at_nocolor_node (self,s,i):

    if self.trace_leo_matches: g.trace()

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@nocolor-node'

    if g.match_word(s,i,tag):
        j = i + len(tag)
        self.colorizer.flag = False # Disable coloring.
        self.colorizer.killColorFlag = True
        self.minimalMatch = tag
        return len(s) - j # Match everything.
    else:
        return 0
#@-node:ekr.20090308163450.11:match_at_nocolor_node (NEW)
#@+node:ekr.20081205131308.45:match_blanks
def match_blanks (self,s,i):

    # g.trace(self,s,i)

    j = i ; n = len(s)

    while j < n and s[j] == ' ':
        j += 1

    if j > i:
        # g.trace(i,j)
        if self.showInvisibles:
            self.colorRangeWithTag(s,i,j,'blank')
        return j - i
    else:
        return 0
#@-node:ekr.20081205131308.45:match_blanks
#@+node:ekr.20081205131308.41:match_doc_part
def match_doc_part (self,s,i):

    # New in Leo 4.5: only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    if g.match_word(s,i,'@doc'):
        j = i+4
        self.minimalMatch = '@doc'
        self.colorRangeWithTag(s,i,j,'leoKeyword')
    elif g.match(s,i,'@') and (i+1 >= len(s) or s[i+1] in (' ','\t','\n')):
        j = i + 1
        self.minimalMatch = '@'
        self.colorRangeWithTag(s,i,j,'leoKeyword')
    else: return 0

    i = j ; n = len(s)
    while j < n:
        k = s.find('@c',j)
        if k == -1:
            # g.trace('i,len(s)',i,len(s))
            j = n+1 # Bug fix: 2007/12/14
            self.colorRangeWithTag(s,i,j,'docPart')
            return j - i
        if s[k-1] == '\n' and (g.match_word(s,k,'@c') or g.match_word(s,k,'@code')):
            j = k
            self.colorRangeWithTag(s,i,j,'docPart')
            return j - i
        else:
            j = k + 2
    j = n - 1
    return max(0,j - i) # Bug fix: 2008/2/10
#@-node:ekr.20081205131308.41:match_doc_part
#@+node:ekr.20081205131308.42:match_leo_keywords
def match_leo_keywords(self,s,i):

    '''Succeed if s[i:] is a Leo keyword.'''

    # g.trace(i,g.get_line(s,i))

    self.totalLeoKeywordsCalls += 1

    # We must be at the start of a word.
    if i > 0 and s[i-1] in self.word_chars:
        return 0

    if s[i] != '@':
        return 0

    # Get the word as quickly as possible.
    j = i+1
    while j < len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i+1:j] # Bug fix: 10/17/07: entries in leoKeywordsDict do not start with '@'

    if self.leoKeywordsDict.get(word):
        kind = 'leoKeyword'
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j-i+1 # Bug fix: skip the last character.
        self.trace_match(kind,s,i,j)
        return result
    else:
        return -(j-i+1) # An important optimization.
#@-node:ekr.20081205131308.42:match_leo_keywords
#@+node:ekr.20081205131308.43:match_section_ref
def match_section_ref (self,s,i):

    if self.trace_leo_matches: g.trace()
    c = self.c ; p = c.currentPosition()
    w = self.w

    if not g.match(s,i,'<<'):
        return 0
    k = g.find_on_line(s,i+2,'>>')
    if k is not None:
        j = k + 2
        self.colorRangeWithTag(s,i,i+2,'nameBrackets')
        ref = g.findReference(c,s[i:j],p)
        if ref:
            if self.use_hyperlinks:
                << set the hyperlink >>
            else:
                self.colorRangeWithTag(s,i+2,k,'link')
        else:
            self.colorRangeWithTag(s,i+2,k,'name')
        self.colorRangeWithTag(s,k,j,'nameBrackets')
        return j - i
    else:
        return 0
#@nonl
#@+node:ekr.20081205131308.44:<< set the hyperlink >>
# Set the bindings to vnode callbacks.
# Create the tag.
# Create the tag name.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
w.tag_delete(tagName)
w.tag_add(tagName,i+2,j)

ref.tagName = tagName
c.tag_bind(w,tagName,"<Control-1>",ref.OnHyperLinkControlClick)
c.tag_bind(w,tagName,"<Any-Enter>",ref.OnHyperLinkEnter)
c.tag_bind(w,tagName,"<Any-Leave>",ref.OnHyperLinkLeave)
#@nonl
#@-node:ekr.20081205131308.44:<< set the hyperlink >>
#@-node:ekr.20081205131308.43:match_section_ref
#@+node:ekr.20081205131308.46:match_tabs
def match_tabs (self,s,i):

    if self.trace_leo_matches: g.trace()

    j = i ; n = len(s)

    while j < n and s[j] == '\t':
        j += 1

    if j > i:
        # g.trace(i,j)
        self.colorRangeWithTag(s,i,j,'tab')
        return j - i
    else:
        return 0
#@nonl
#@-node:ekr.20081205131308.46:match_tabs
#@-node:ekr.20081205131308.38:Leo rule functions
#@+node:ekr.20081205131308.88:match_eol_span
def match_eol_span (self,s,i,
    kind=None,seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if seq matches s[i:]'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        return 0 # 7/5/2008

    if g.match(s,i,seq):
        #j = g.skip_line(s,i) # Include the newline so we don't get a flash at the end of the line.
        j = self.skip_line(s,i)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        self.minimalMatch = seq
        return j - i
    else:
        return 0
#@-node:ekr.20081205131308.88:match_eol_span
#@+node:ekr.20081205131308.89:match_eol_span_regexp
def match_eol_span_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if the regular expression regex matches s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,regexp)
    if n > 0:
        # j = g.skip_line(s,i) # Include the newline so we don't get a flash at the end of the line.
        j = self.skip_line(s,i)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        self.minimalMatch = s[i:i+n] # Bug fix: 2009/3/2.
        return j - i
    else:
        return 0
#@nonl
#@-node:ekr.20081205131308.89:match_eol_span_regexp
#@+node:ekr.20081205131308.91:match_keywords
# This is a time-critical method.
def match_keywords (self,s,i):

    '''Succeed if s[i:] is a keyword.'''

    self.totalKeywordsCalls += 1

    # Important.  Return -len(word) for failure greatly reduces
    # the number of times this method is called.

    # We must be at the start of a word.
    if i > 0 and s[i-1] in self.word_chars:
        return 0

    trace = False

    # Get the word as quickly as possible.
    j = i ; n = len(s) ; chars = self.word_chars
    while j < n and s[j] in chars:
        j += 1

    word = s[i:j]
    if self.ignore_case: word = word.lower()
    kind = self.keywordsDict.get(word)
    if kind:
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j - i
        if trace: g.trace('success',word,kind,j-i)
        # g.trace('word in self.keywordsDict.keys()',word in self.keywordsDict.keys())
        self.trace_match(kind,s,i,j)
        return result
    else:
        if trace: g.trace('fail',word,kind)
        # g.trace('word in self.keywordsDict.keys()',word in self.keywordsDict.keys())
        return -len(word) # An important new optimization.
#@-node:ekr.20081205131308.91:match_keywords
#@+node:ekr.20081205131308.92:match_mark_following & getNextToken
def match_mark_following (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    if not self.allow_mark_prev: return 0

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(pattern) + 1 < len(s) and s[i+len(pattern)] in self.word_chars:
        return 0 # 7/5/2008

    if g.match(s,i,pattern):
        j = i + len(pattern)
        self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
        k = self.getNextToken(s,j)
        if k > j:
            self.colorRangeWithTag(s,j,k,kind,exclude_match=False)
            j = k
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        self.minimalMatch = pattern
        return j - i
    else:
        return 0
#@+node:ekr.20081205131308.93:getNextToken
def getNextToken (self,s,i):

    '''Return the index of the end of the next token for match_mark_following.

    The jEdit docs are not clear about what a 'token' is, but experiments with jEdit
    show that token means a word, as defined by word_chars.'''

    while i < len(s) and s[i] in self.word_chars:
        i += 1

    return min(len(s),i+1)
#@nonl
#@-node:ekr.20081205131308.93:getNextToken
#@-node:ekr.20081205131308.92:match_mark_following & getNextToken
#@+node:ekr.20081205131308.94:match_mark_previous
def match_mark_previous (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Return the length of a matched SEQ or 0 if no match.

    'at_line_start':    True: sequence must start the line.
    'at_whitespace_end':True: sequence must be first non-whitespace text of the line.
    'at_word_start':    True: sequence must start a word.'''

    if not self.allow_mark_prev: return 0

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(pattern) + 1 < len(s) and s[i+len(pattern)] in self.word_chars:
        return 0 # 7/5/2008

    if g.match(s,i,pattern):
        j = i + len(pattern)
        # Color the previous token.
        if self.prev:
            i2,j2,kind2 = self.prev
            # g.trace(i2,j2,kind2)
            self.colorRangeWithTag(s,i2,j2,kind2,exclude_match=False)
        if not exclude_match:
            self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        self.minimalMatch = pattern
        return j - i
    else:
        return 0
#@-node:ekr.20081205131308.94:match_mark_previous
#@+node:ekr.20081205131308.95:match_regexp_helper
def match_regexp_helper (self,s,i,pattern):

    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'pattern',pattern)
    trace = False

    try:
        flags = re.MULTILINE
        if self.ignore_case: flags|= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        # Bug fix: 2007/11/07: do not call g.es here!
        g.trace('Invalid regular expression: %s' % (pattern))
        return 0

    # Match succeeds or fails more quickly than search.
    # g.trace('before')
    self.match_obj = mo = re_obj.match(s,i) # re_obj.search(s,i) 
    # g.trace('after')

    if mo is None:
        return 0
    else:
        start, end = mo.start(), mo.end()
        if start != i: # Bug fix 2007-12-18: no match at i
            return 0
        if trace:
            g.trace('pattern',pattern)
            g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
            g.trace('groups',mo.groups())
        return end - start
#@-node:ekr.20081205131308.95:match_regexp_helper
#@+node:ekr.20081205131308.96:match_seq
def match_seq (self,s,i,
    kind='',seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if s[:] mathces seq.'''

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:  # 7/5/2008
        j = i
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        j = i # 7/5/2008
    elif g.match(s,i,seq):
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        self.minimalMatch = seq
    else:
        j = i
    return j - i
#@nonl
#@-node:ekr.20081205131308.96:match_seq
#@+node:ekr.20081205131308.97:match_seq_regexp
def match_seq_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if the regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008

    # g.trace('before')
    n = self.match_regexp_helper(s,i,regexp)
    # g.trace('after')
    j = i + n # Bug fix: 2007-12-18
    assert (j-i == n)
    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
    self.prev = (i,j,kind)
    self.trace_match(kind,s,i,j)
    return j - i
#@nonl
#@-node:ekr.20081205131308.97:match_seq_regexp
#@+node:ekr.20081205131308.98:match_span & helper
def match_span (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False,no_word_break=False):

    '''Succeed if s[i:] starts with 'begin' and contains a following 'end'.'''

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars: # 7/5/2008
        j = i
    elif at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        j = i # 7/5/2008
    elif not g.match(s,i,begin):
        j = i
    else:
        j = self.match_span_helper(s,i+len(begin),end,no_escape,no_line_break,no_word_break=no_word_break)
        if j == -1:
            j = i
        else:
            i2 = i + len(begin) ; j2 = j + len(end)
            # g.trace(i,j,s[i:j2],kind)
            if delegate:
                self.colorRangeWithTag(s,i,i2,kind,delegate=None,    exclude_match=exclude_match)
                self.colorRangeWithTag(s,i2,j,kind,delegate=delegate,exclude_match=exclude_match)
                self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
            else: # avoid having to merge ranges in addTagsToList.
                self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
            j = j2
            self.prev = (i,j,kind)
            self.minimalMatch = begin

    self.trace_match(kind,s,i,j)
    return j - i
#@+node:ekr.20081205131308.99:match_span_helper
def match_span_helper (self,s,i,pattern,no_escape,no_line_break,no_word_break=False):

    '''Return n >= 0 if s[i] ends with a non-escaped 'end' string.'''

    esc = self.escape

    while 1:
        j = s.find(pattern,i)
        if j == -1:
            # Match to end of text if not found and no_line_break is False
            if no_line_break:
                return -1
            else:
                return len(s)
        elif no_word_break and j > 0 and s[j-1] in self.word_chars:
            return -1 # New in Leo 4.5.
        elif no_line_break and '\n' in s[i:j]:
            return -1
        elif esc and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == esc:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # Continue searching past the escaped pattern string.
                i = j + len(pattern) # Bug fix: 7/25/07.
                # g.trace('escapes',escapes,repr(s[i:]))
            else:
                return j
        else:
            return j
#@nonl
#@-node:ekr.20081205131308.99:match_span_helper
#@-node:ekr.20081205131308.98:match_span & helper
#@+node:ekr.20081205131308.100:match_span_regexp
def match_span_regexp (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False, no_word_break=False,
):

    '''Succeed if s[i:] starts with 'begin' (a regular expression) and contains a following 'end'.'''

    if self.verbose: g.trace('begin',repr(begin),'end',repr(end),self.dump(s[i:]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,begin)
    # We may have to allow $n here, in which case we must use a regex object?
    if n > 0:
        j = i + n
        j2 = s.find(end,j)
        if j2 == -1: return 0
        if self.escape and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == self.escape:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # An escaped end **aborts the entire match**:
                # there is no way to 'restart' the regex.
                return 0
        i2 = j2 - len(end)
        if delegate:
            self.colorRangeWithTag(s,i,j,kind, delegate=None,     exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,i2,kind, delegate=delegate,exclude_match=False)
            self.colorRangeWithTag(s,i2,j2,kind,delegate=None,    exclude_match=exclude_match)
        else: # avoid having to merge ranges in addTagsToList.
            self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j2)
        return j2 - i
    else: return 0
#@-node:ekr.20081205131308.100:match_span_regexp
#@+node:ekr.20081205131308.101:match_word_and_regexp
def match_word_and_regexp (self,s,i,
    kind1='',word='',
    kind2='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    if not self.allow_mark_prev: return 0

    if (False or self.verbose): g.trace(i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(word) + 1 < len(s) and s[i+len(word)] in self.word_chars:
        j = i # 7/5/2008

    if not g.match(s,i,word):
        return 0

    j = i + len(word)
    n = self.match_regexp_helper(s,j,pattern)
    # g.trace(j,pattern,n)
    if n == 0:
        return 0
    self.colorRangeWithTag(s,i,j,kind1,exclude_match=exclude_match)
    k = j + n
    self.colorRangeWithTag(s,j,k,kind2,exclude_match=False)    
    self.prev = (j,k,kind2)
    self.trace_match(kind1,s,i,j)
    self.trace_match(kind2,s,j,k)
    return k - i
#@-node:ekr.20081205131308.101:match_word_and_regexp
#@+node:ekr.20081205131308.102:skip_line
def skip_line (self,s,i):

    if self.escape:
        escape = self.escape + '\n'
        n = len(escape)
        while i < len(s):
            j = g.skip_line(s,i)
            if not g.match(s,j-n,escape):
                return j
            # g.trace('escape',s[i:j])
            i = j
        return i
    else:
        return g.skip_line(s,i)
            # Include the newline so we don't get a flash at the end of the line.
#@nonl
#@-node:ekr.20081205131308.102:skip_line
#@+node:ekr.20081205131308.112:trace_match
def trace_match(self,kind,s,i,j):

    if j != i and self.trace_match_flag:
        g.trace(kind,i,j,g.callers(2),self.dump(s[i:j]))
#@nonl
#@-node:ekr.20081205131308.112:trace_match
#@-node:ekr.20081205131308.87:pattern matchers
#@+node:ekr.20081206062411.12:recolor & helpers
def recolor (self,s):

    '''Recolor line s.'''

    trace = False and not g.unitTesting
    verbose = False ; traceMatch = False

    # Return immediately if syntax coloring has been disabled.
    # if self.colorizer.killColorFlag or not self.colorizer.enabled:
        # self.highlighter.setCurrentBlockState(-1)
        # if trace and (self.initFlag or verbose):
            # self.initFlag = False
            # g.trace('immediate return')
        # return

    # Reload all_s if the widget's text is known to have changed.
    if self.initFlag:
        self.initFlag = False
        self.all_s = self.w.getAllText()
        if trace and verbose:
            g.trace('**** set all_s: %s' % len(self.all_s),g.callers(5))

    all_s = self.all_s
    if not all_s: return

    # Update the counts.
    self.recolorCount += 1
    self.totalChars += len(s)

    # Init values that do not depend on all_s.
    offset = self.highlighter.currentBlock().position()
    b = self.getPrevState()
    lastFunc,lastMatch = b.lastFunc,b.lastMatch
    lastN,minimalMatch = 0,'' # Not used until there is a match.
    lastFlag = b.lastFlag
    if lastFlag is not None:
        # g.trace('***** set flag',lastFlag)
        self.colorizer.flag = lastFlag
    if trace and verbose and lastFunc: g.trace('prevState',b)
    i = g.choose(lastFunc,lastMatch,offset)

    # Make sure we are in synch with all_s.
    # Reload all_s if we are not.
    if not self.checkRecolor(offset,s):
        return g.trace('**** resych failure',s)

    # Set the values that depend on all_s.
    all_s = self.all_s
    j = min(offset + len(s),len(all_s))
    self.global_i,self.global_j = offset,j

    if trace:
        g.trace('%3s %5s %-40s %s' % (
            self.recolorCount,self.colorizer.flag,b.stateName,s))

    # The main colorizing loop.
    self.prev = None
    while i < j:
        loopFlag = self.colorizer.flag
        assert 0 <= i < len(all_s)
        progress = i
        functions = self.rulesDict.get(all_s[i],[])
        self.minimalMatch = ''
        for f in functions:
            n = f(self,all_s,i)
            if n is None:
                g.trace('Can not happen' % (repr(n),repr(f)))
                break
            elif n > 0: # Success.
                if trace and traceMatch:
                    g.trace('match: offset %3s, i %3s, n %3s, f %s %s' % (
                        offset,i,n,f.__name__,repr(s[i:i+n])))
                lastFunc,lastMatch,lastN,minimalMatch = f,i,n,self.minimalMatch
                i += n
                break # Stop searching the functions.
            elif n < 0: # Fail and skip n chars.
                # match_keyword now sets n < 0 on first failure.
                i += -n # Don't set lastMatch on failure!
                break # Stop searching the functions.
            else: # Fail.  Go on to the next f in functions.
                pass # Do not break or change i!
        else:
            i += 1 # Don't set lastMatch on failure!
        assert i > progress

    self.setCurrentState(s,offset,len(s)+1,
        lastFunc,lastMatch,lastN,minimalMatch)
#@+node:ekr.20090213102946.10:checkRecolor
def checkRecolor (self,offset,s):

    '''Return True if s can be synched with self.all_s.'''

    trace = False and not g.unitTesting

    all_s = self.all_s
    j = min(offset + len(s),len(all_s))
    s2 = all_s[offset:j]

    # The first check is allowed to fail.
    if s == s2: return True

    if trace: g.trace('**resynch**')

    # Assume we should have re-inited all_s
    self.all_s = all_s = self.w.getAllText()
    j = min(offset + len(s),len(all_s))
    s2 = all_s[offset:j]

    # Check again. This should never fail.
    if s != s2:
        g.trace('**** mismatch! offset %s len %s %s\n%s\n%s' % (
           offset,len(all_s),g.callers(5),repr(s),repr(s2)))
    return s == s2
#@-node:ekr.20090213102946.10:checkRecolor
#@+node:ekr.20090211072718.14:computeStateName
def computeStateName (self,lastFunc,lastMatch,lastN,minimalMatch):

    if self.colorizer.killColorFlag:
        colorState = 'killcolor.'
    else:
        colorState = g.choose(
            self.colorizer.flag in (True,None),'','nocolor.')

    if lastFunc:
        matchString = g.choose(minimalMatch,
            minimalMatch,
            self.all_s[lastMatch:lastMatch+lastN])
        name = '%s%s:%s' % (
            colorState,lastFunc.__name__,matchString)
    else:
        name = '%s%s' % (colorState,self.defaultState)

    # g.trace(repr(lastFlag),name)

    return name
#@-node:ekr.20090211072718.14:computeStateName
#@+node:ekr.20090211072718.2:getPrevState
def getPrevState (self):

    h = self.highlighter
    n = h.previousBlockState()

    if n == -1:
        return g.Bunch(
            lastKillColorFlag=None,
            lastFlag=None,
            lastFunc=None,
            lastMatch=0,
            lastN=0,
            stateName = self.defaultState)
    else:
        bunch = self.stateDict.get(n)
        assert bunch,'n=%s' % (n)
        return bunch
#@nonl
#@-node:ekr.20090211072718.2:getPrevState
#@+node:ekr.20090211072718.3:setCurrentState
def setCurrentState (self,s,offset,limit,
    lastFunc,lastMatch,lastN,minimalMatch):

    trace = False and not g.unitTesting
    verbose = True
    h = self.highlighter
    flag = self.colorizer.flag
    killColorFlag = self.colorizer.killColorFlag

    self.stateCount += 1
    oldN = h.currentBlockState()
    active = bool(
        killColorFlag or flag is False or 
        (lastFunc and lastMatch + lastN > offset + limit))

    if active:
        b = self.stateDict.get(oldN)
        if b:
            changeState = (
                b.lastFlag != flag or
                b.lastKillColorFlag != killColorFlag or
                b.lastFunc != lastFunc or
                b.lastN != lastN)
        else:
            changeState = True
    else:
        flag,lastFunc,lastMatch,lastN,minimalMatch = None,None,None,None,None
        changeState = oldN != -1 #### or not flag or killColorFlag 

    stateName = self.computeStateName(
        lastFunc,lastMatch,lastN,minimalMatch)

    if trace and (changeState or active or verbose):
        g.trace('%2d ** active %5s changed %5s %-20s %s' % (
            self.stateCount,active,changeState,stateName,s))

    if not changeState:
        return

    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.nextState += 1
        self.totalStates += 1
        self.maxStateNumber = max(n,self.maxStateNumber)

    state = g.bunch(
        lastKillColorFlag = killColorFlag,
        lastFlag=flag,
        lastFunc=lastFunc,
        lastMatch=lastMatch,
        lastN=lastN,
        stateName=stateName,)

    self.stateNameDict[stateName] = n
    self.stateDict[n] = state

    h.setCurrentBlockState(n)
#@-node:ekr.20090211072718.3:setCurrentState
#@+node:ekr.20081206062411.14:setTag
tagCount = 0

def setTag (self,tag,s,i,j):

    trace = False and not g.unitTesting
    verbose = False
    w = self.w
    colorName = w.configDict.get(tag)

    if not self.colorizer.flag:
        # We are under the influence of @nocolor
        if trace: g.trace('in range of @nocolor',tag)
        return

    # Munch the color name.
    if not colorName:
        if trace: g.trace('no color for %s' % tag)
        return
    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[:-1]

    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name',colorName)

    # Clip the colorizing to the global bounds.
    offset = self.global_i
    lim_i,lim_j = self.global_i,self.global_j
    clip_i = max(i,lim_i)
    clip_j = min(j,lim_j)
    ok = clip_i < clip_j

    if trace:
        self.tagCount += 1
        # kind = g.choose(ok,' ','***')
        s2 = g.choose(ok,s[clip_i:clip_j],self.all_s[i:j])

        if verbose:
            g.trace('%3s %3s %3s %3s %3s %3s %3s %s' % (
                self.tagCount,tag,offset,i,j,lim_i,lim_j,s2),
                g.callers(4))
        else:
            g.trace('%3s %7s %s' % (self.tagCount,tag,s2))

    if ok:
        self.highlighter.setFormat(clip_i-offset,clip_j-clip_i,color)
#@-node:ekr.20081206062411.14:setTag
#@-node:ekr.20081206062411.12:recolor & helpers
#@-node:ekr.20081205131308.48:class jeditColorizer
#@-node:ekr.20081204090029.1:Syntax coloring
#@+node:ekr.20081205131308.38:Leo rule functions
#@+node:ekr.20081205131308.39:match_at_color
def match_at_color (self,s,i):

    if self.trace_leo_matches: g.trace()

    seq = '@color'

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n': return 0

    if g.match_word(s,i,seq):
        self.colorizer.flag = True # Enable coloring.
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,'leoKeyword')
        return j - i
    else:
        return 0
#@nonl
#@-node:ekr.20081205131308.39:match_at_color
#@+node:ekr.20081205131308.40:match_at_nocolor
def match_at_nocolor (self,s,i):

    if self.trace_leo_matches: g.trace()

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0
    if g.match(s,i,'@nocolor-'):
        return 0
    if not g.match_word(s,i,'@nocolor'):
        return 0

    j = i + len('@nocolor')
    k = s.find('\n@color',j)
    if k == -1:
        # No later @color: don't color the @nocolor directive.
        self.colorizer.flag = False # Disable coloring.
        return len(s) - j
    else:
        # A later @color: do color the @nocolor directive.
        self.colorRangeWithTag(s,i,j,'leoKeyword')
        self.colorizer.flag = False # Disable coloring.
        return k+2-j

#@-node:ekr.20081205131308.40:match_at_nocolor
#@+node:ekr.20090308163450.10:match_at_killcolor (NEW)
def match_at_killcolor (self,s,i):

    if self.trace_leo_matches: g.trace()

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@killcolor'

    if g.match_word(s,i,tag):
        j = i + len(tag)
        self.colorizer.flag = False # Disable coloring.
        self.colorizer.killColorFlag = True
        self.minimalMatch = tag
        return len(s) - j # Match everything.
    else:
        return 0

#@-node:ekr.20090308163450.10:match_at_killcolor (NEW)
#@+node:ekr.20090308163450.11:match_at_nocolor_node (NEW)
def match_at_nocolor_node (self,s,i):

    if self.trace_leo_matches: g.trace()

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@nocolor-node'

    if g.match_word(s,i,tag):
        j = i + len(tag)
        self.colorizer.flag = False # Disable coloring.
        self.colorizer.killColorFlag = True
        self.minimalMatch = tag
        return len(s) - j # Match everything.
    else:
        return 0
#@-node:ekr.20090308163450.11:match_at_nocolor_node (NEW)
#@+node:ekr.20081205131308.45:match_blanks
def match_blanks (self,s,i):

    # g.trace(self,s,i)

    j = i ; n = len(s)

    while j < n and s[j] == ' ':
        j += 1

    if j > i:
        # g.trace(i,j)
        if self.showInvisibles:
            self.colorRangeWithTag(s,i,j,'blank')
        return j - i
    else:
        return 0
#@-node:ekr.20081205131308.45:match_blanks
#@+node:ekr.20081205131308.41:match_doc_part
def match_doc_part (self,s,i):

    # New in Leo 4.5: only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    if g.match_word(s,i,'@doc'):
        j = i+4
        self.minimalMatch = '@doc'
        self.colorRangeWithTag(s,i,j,'leoKeyword')
    elif g.match(s,i,'@') and (i+1 >= len(s) or s[i+1] in (' ','\t','\n')):
        j = i + 1
        self.minimalMatch = '@'
        self.colorRangeWithTag(s,i,j,'leoKeyword')
    else: return 0

    i = j ; n = len(s)
    while j < n:
        k = s.find('@c',j)
        if k == -1:
            # g.trace('i,len(s)',i,len(s))
            j = n+1 # Bug fix: 2007/12/14
            self.colorRangeWithTag(s,i,j,'docPart')
            return j - i
        if s[k-1] == '\n' and (g.match_word(s,k,'@c') or g.match_word(s,k,'@code')):
            j = k
            self.colorRangeWithTag(s,i,j,'docPart')
            return j - i
        else:
            j = k + 2
    j = n - 1
    return max(0,j - i) # Bug fix: 2008/2/10
#@-node:ekr.20081205131308.41:match_doc_part
#@+node:ekr.20081205131308.42:match_leo_keywords
def match_leo_keywords(self,s,i):

    '''Succeed if s[i:] is a Leo keyword.'''

    # g.trace(i,g.get_line(s,i))

    self.totalLeoKeywordsCalls += 1

    # We must be at the start of a word.
    if i > 0 and s[i-1] in self.word_chars:
        return 0

    if s[i] != '@':
        return 0

    # Get the word as quickly as possible.
    j = i+1
    while j < len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i+1:j] # Bug fix: 10/17/07: entries in leoKeywordsDict do not start with '@'

    if self.leoKeywordsDict.get(word):
        kind = 'leoKeyword'
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j-i+1 # Bug fix: skip the last character.
        self.trace_match(kind,s,i,j)
        return result
    else:
        return -(j-i+1) # An important optimization.
#@-node:ekr.20081205131308.42:match_leo_keywords
#@+node:ekr.20081205131308.43:match_section_ref
def match_section_ref (self,s,i):

    if self.trace_leo_matches: g.trace()
    c = self.c ; p = c.currentPosition()
    w = self.w

    if not g.match(s,i,'<<'):
        return 0
    k = g.find_on_line(s,i+2,'>>')
    if k is not None:
        j = k + 2
        self.colorRangeWithTag(s,i,i+2,'nameBrackets')
        ref = g.findReference(c,s[i:j],p)
        if ref:
            if self.use_hyperlinks:
                << set the hyperlink >>
            else:
                self.colorRangeWithTag(s,i+2,k,'link')
        else:
            self.colorRangeWithTag(s,i+2,k,'name')
        self.colorRangeWithTag(s,k,j,'nameBrackets')
        return j - i
    else:
        return 0
#@nonl
#@+node:ekr.20081205131308.44:<< set the hyperlink >>
# Set the bindings to vnode callbacks.
# Create the tag.
# Create the tag name.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
w.tag_delete(tagName)
w.tag_add(tagName,i+2,j)

ref.tagName = tagName
c.tag_bind(w,tagName,"<Control-1>",ref.OnHyperLinkControlClick)
c.tag_bind(w,tagName,"<Any-Enter>",ref.OnHyperLinkEnter)
c.tag_bind(w,tagName,"<Any-Leave>",ref.OnHyperLinkLeave)
#@nonl
#@-node:ekr.20081205131308.44:<< set the hyperlink >>
#@-node:ekr.20081205131308.43:match_section_ref
#@+node:ekr.20081205131308.46:match_tabs
def match_tabs (self,s,i):

    if self.trace_leo_matches: g.trace()

    j = i ; n = len(s)

    while j < n and s[j] == '\t':
        j += 1

    if j > i:
        # g.trace(i,j)
        self.colorRangeWithTag(s,i,j,'tab')
        return j - i
    else:
        return 0
#@nonl
#@-node:ekr.20081205131308.46:match_tabs
#@-node:ekr.20081205131308.38:Leo rule functions
#@+node:ekr.20081206062411.12:recolor & helpers
def recolor (self,s):

    '''Recolor line s.'''

    trace = False and not g.unitTesting
    verbose = False ; traceMatch = False

    # Return immediately if syntax coloring has been disabled.
    # if self.colorizer.killColorFlag or not self.colorizer.enabled:
        # self.highlighter.setCurrentBlockState(-1)
        # if trace and (self.initFlag or verbose):
            # self.initFlag = False
            # g.trace('immediate return')
        # return

    # Reload all_s if the widget's text is known to have changed.
    if self.initFlag:
        self.initFlag = False
        self.all_s = self.w.getAllText()
        if trace and verbose:
            g.trace('**** set all_s: %s' % len(self.all_s),g.callers(5))

    all_s = self.all_s
    if not all_s: return

    # Update the counts.
    self.recolorCount += 1
    self.totalChars += len(s)

    # Init values that do not depend on all_s.
    offset = self.highlighter.currentBlock().position()
    b = self.getPrevState()
    lastFunc,lastMatch = b.lastFunc,b.lastMatch
    lastN,minimalMatch = 0,'' # Not used until there is a match.
    lastFlag = b.lastFlag
    if lastFlag is not None:
        # g.trace('***** set flag',lastFlag)
        self.colorizer.flag = lastFlag
    if trace and verbose and lastFunc: g.trace('prevState',b)
    i = g.choose(lastFunc,lastMatch,offset)

    # Make sure we are in synch with all_s.
    # Reload all_s if we are not.
    if not self.checkRecolor(offset,s):
        return g.trace('**** resych failure',s)

    # Set the values that depend on all_s.
    all_s = self.all_s
    j = min(offset + len(s),len(all_s))
    self.global_i,self.global_j = offset,j

    if trace:
        g.trace('%3s %5s %-40s %s' % (
            self.recolorCount,self.colorizer.flag,b.stateName,s))

    # The main colorizing loop.
    self.prev = None
    while i < j:
        loopFlag = self.colorizer.flag
        assert 0 <= i < len(all_s)
        progress = i
        functions = self.rulesDict.get(all_s[i],[])
        self.minimalMatch = ''
        for f in functions:
            n = f(self,all_s,i)
            if n is None:
                g.trace('Can not happen' % (repr(n),repr(f)))
                break
            elif n > 0: # Success.
                if trace and traceMatch:
                    g.trace('match: offset %3s, i %3s, n %3s, f %s %s' % (
                        offset,i,n,f.__name__,repr(s[i:i+n])))
                lastFunc,lastMatch,lastN,minimalMatch = f,i,n,self.minimalMatch
                i += n
                break # Stop searching the functions.
            elif n < 0: # Fail and skip n chars.
                # match_keyword now sets n < 0 on first failure.
                i += -n # Don't set lastMatch on failure!
                break # Stop searching the functions.
            else: # Fail.  Go on to the next f in functions.
                pass # Do not break or change i!
        else:
            i += 1 # Don't set lastMatch on failure!
        assert i > progress

    self.setCurrentState(s,offset,len(s)+1,
        lastFunc,lastMatch,lastN,minimalMatch)
#@+node:ekr.20090213102946.10:checkRecolor
def checkRecolor (self,offset,s):

    '''Return True if s can be synched with self.all_s.'''

    trace = False and not g.unitTesting

    all_s = self.all_s
    j = min(offset + len(s),len(all_s))
    s2 = all_s[offset:j]

    # The first check is allowed to fail.
    if s == s2: return True

    if trace: g.trace('**resynch**')

    # Assume we should have re-inited all_s
    self.all_s = all_s = self.w.getAllText()
    j = min(offset + len(s),len(all_s))
    s2 = all_s[offset:j]

    # Check again. This should never fail.
    if s != s2:
        g.trace('**** mismatch! offset %s len %s %s\n%s\n%s' % (
           offset,len(all_s),g.callers(5),repr(s),repr(s2)))
    return s == s2
#@-node:ekr.20090213102946.10:checkRecolor
#@+node:ekr.20090211072718.14:computeStateName
def computeStateName (self,lastFunc,lastMatch,lastN,minimalMatch):

    if self.colorizer.killColorFlag:
        colorState = 'killcolor.'
    else:
        colorState = g.choose(
            self.colorizer.flag in (True,None),'','nocolor.')

    if lastFunc:
        matchString = g.choose(minimalMatch,
            minimalMatch,
            self.all_s[lastMatch:lastMatch+lastN])
        name = '%s%s:%s' % (
            colorState,lastFunc.__name__,matchString)
    else:
        name = '%s%s' % (colorState,self.defaultState)

    # g.trace(repr(lastFlag),name)

    return name
#@-node:ekr.20090211072718.14:computeStateName
#@+node:ekr.20090211072718.2:getPrevState
def getPrevState (self):

    h = self.highlighter
    n = h.previousBlockState()

    if n == -1:
        return g.Bunch(
            lastKillColorFlag=None,
            lastFlag=None,
            lastFunc=None,
            lastMatch=0,
            lastN=0,
            stateName = self.defaultState)
    else:
        bunch = self.stateDict.get(n)
        assert bunch,'n=%s' % (n)
        return bunch
#@nonl
#@-node:ekr.20090211072718.2:getPrevState
#@+node:ekr.20090211072718.3:setCurrentState
def setCurrentState (self,s,offset,limit,
    lastFunc,lastMatch,lastN,minimalMatch):

    trace = False and not g.unitTesting
    verbose = True
    h = self.highlighter
    flag = self.colorizer.flag
    killColorFlag = self.colorizer.killColorFlag

    self.stateCount += 1
    oldN = h.currentBlockState()
    active = bool(
        killColorFlag or flag is False or 
        (lastFunc and lastMatch + lastN > offset + limit))

    if active:
        b = self.stateDict.get(oldN)
        if b:
            changeState = (
                b.lastFlag != flag or
                b.lastKillColorFlag != killColorFlag or
                b.lastFunc != lastFunc or
                b.lastN != lastN)
        else:
            changeState = True
    else:
        flag,lastFunc,lastMatch,lastN,minimalMatch = None,None,None,None,None
        changeState = oldN != -1 #### or not flag or killColorFlag 

    stateName = self.computeStateName(
        lastFunc,lastMatch,lastN,minimalMatch)

    if trace and (changeState or active or verbose):
        g.trace('%2d ** active %5s changed %5s %-20s %s' % (
            self.stateCount,active,changeState,stateName,s))

    if not changeState:
        return

    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.nextState += 1
        self.totalStates += 1
        self.maxStateNumber = max(n,self.maxStateNumber)

    state = g.bunch(
        lastKillColorFlag = killColorFlag,
        lastFlag=flag,
        lastFunc=lastFunc,
        lastMatch=lastMatch,
        lastN=lastN,
        stateName=stateName,)

    self.stateNameDict[stateName] = n
    self.stateDict[n] = state

    h.setCurrentBlockState(n)
#@-node:ekr.20090211072718.3:setCurrentState
#@+node:ekr.20081206062411.14:setTag
tagCount = 0

def setTag (self,tag,s,i,j):

    trace = False and not g.unitTesting
    verbose = False
    w = self.w
    colorName = w.configDict.get(tag)

    if not self.colorizer.flag:
        # We are under the influence of @nocolor
        if trace: g.trace('in range of @nocolor',tag)
        return

    # Munch the color name.
    if not colorName:
        if trace: g.trace('no color for %s' % tag)
        return
    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[:-1]

    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name',colorName)

    # Clip the colorizing to the global bounds.
    offset = self.global_i
    lim_i,lim_j = self.global_i,self.global_j
    clip_i = max(i,lim_i)
    clip_j = min(j,lim_j)
    ok = clip_i < clip_j

    if trace:
        self.tagCount += 1
        # kind = g.choose(ok,' ','***')
        s2 = g.choose(ok,s[clip_i:clip_j],self.all_s[i:j])

        if verbose:
            g.trace('%3s %3s %3s %3s %3s %3s %3s %s' % (
                self.tagCount,tag,offset,i,j,lim_i,lim_j,s2),
                g.callers(4))
        else:
            g.trace('%3s %7s %s' % (self.tagCount,tag,s2))

    if ok:
        self.highlighter.setFormat(clip_i-offset,clip_j-clip_i,color)
#@-node:ekr.20081206062411.14:setTag
#@-node:ekr.20081206062411.12:recolor & helpers
#@-node:ekr.20090307110717.1:Fixed @color/@nocolor interaction
#@+node:ekr.20090313075003.2:Fixed (?) new unicode problem
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/eb22a9d0f363954e

working with revno 1633 and qt gui I've found a couple of unicode
problems:

a) when I press the keys "" or "" of my (Spanish) keyboard the
following errors appears in the console (but not in the log pane):

vmas@rachael$ Traceback (most recent call last):
  File "/usr/local/src/leo-editor/leo/plugins/qtGui.py", line 4805, in
eventFilter
    tkKey,ch,ignore = self.toTkKey(event)
  File "/usr/local/src/leo-editor/leo/plugins/qtGui.py", line 4929, in
toTkKey
    keynum,text,toString,ch = self.qtKey(event)
  File "/usr/local/src/leo-editor/leo/plugins/qtGui.py", line 4956, in
qtKey
    ch       = g.app.gui.toUnicode(ch)
  File "/usr/local/src/leo-editor/leo/plugins/qtGui.py", line 4453, in
toUnicode
    return unicode(s)
UnicodeDecodeError: 'ascii' codec can't decode byte 0xd1 in position
0: ordinal not in range(128)
Traceback (most recent call last):
  File "/usr/local/src/leo-editor/leo/plugins/qtGui.py", line 4805, in
eventFilter
    tkKey,ch,ignore = self.toTkKey(event)
  File "/usr/local/src/leo-editor/leo/plugins/qtGui.py", line 4929, in
toTkKey
    keynum,text,toString,ch = self.qtKey(event)
  File "/usr/local/src/leo-editor/leo/plugins/qtGui.py", line 4956, in
qtKey
    ch       = g.app.gui.toUnicode(ch)
  File "/usr/local/src/leo-editor/leo/plugins/qtGui.py", line 4453, in
toUnicode
    return unicode(s)
UnicodeDecodeError: 'ascii' codec can't decode byte 0xd1 in position
0: ordinal not in range(128)
Traceback (most recent call last):
  File "/usr/local/src/leo-editor/leo/plugins/qtGui.py", line 4805, in
eventFilter
    tkKey,ch,ignore = self.toTkKey(event)
  File "/usr/local/src/leo-editor/leo/plugins/qtGui.py", line 4929, in
toTkKey
    keynum,text,toString,ch = self.qtKey(event)
  File "/usr/local/src/leo-editor/leo/plugins/qtGui.py", line 4956, in
qtKey
    ch       = g.app.gui.toUnicode(ch)
  File "/usr/local/src/leo-editor/leo/plugins/qtGui.py", line 4453, in
toUnicode
    return unicode(s)
UnicodeDecodeError: 'ascii' codec can't decode byte 0xd1 in position
0: ordinal not in range(128)

The other observed errors are more complex.

b) Suppose I've a node with no characters out of range(128) in its
headline. I edit the headline and put
something like "Ejecuci immediata". Then select a different node,
save the file (everything seems fine),
close it and open it again. The node headline has been reverted to its
initial value.

c) Suppose I've a node with no characters out of range(128) in its
headline. I edit the headline and put
something like "Ejecuci immediata". Then, while the node still has
the keyboard focus, I save the file or press
Enter. The node headline becomes "Ejecuci?immediata". Then close the
file and open it again. The node
headline is *not* reverted,
it is still  "Ejecuci?immediata".
#@+node:ekr.20081121105001.502:toUnicode (qtGui)
def toUnicode (self,s,encoding='utf-8',reportErrors=True):

    return unicode(s)
#@nonl
#@-node:ekr.20081121105001.502:toUnicode (qtGui)
#@+node:ekr.20081121105001.172:qtKey
def qtKey (self,event):

    '''Return the components of a Qt key event.'''

    trace = False and not g.unitTesting
    keynum = event.key()
    text   = event.text() # This is the unicode text.
    toString = QtGui.QKeySequence(keynum).toString()
    toUnicode = unicode

    try:
        ch1 = chr(keynum)
    except ValueError:
        ch1 = ''

    try:
        ch = toUnicode(ch1)
    except UnicodeError:
        ch = ch1

    text     = toUnicode(text)
    toString = toUnicode(toString)

    if trace: g.trace('keynum %s ch %s ch1 %s toString %s' % (
        repr(keynum),repr(ch),repr(ch1),repr(toString)))

    return keynum,text,toString,ch

#@-node:ekr.20081121105001.172:qtKey
#@+node:ekr.20081121105001.166:class leoQtEventFilter
class leoQtEventFilter(QtCore.QObject):

    << about internal bindings >>

    @others
#@+node:ekr.20081121105001.167:<< about internal bindings >>
@nocolor-node
@

Here are the rules for translating key bindings (in leoSettings.leo) into keys for k.bindingsDict:

1.  The case of plain letters is significant:  a is not A.

2. The Shift- prefix can be applied *only* to letters. Leo will ignore (with a
warning) the shift prefix applied to any other binding, e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is *not*
significant. Thus, the Shift- prefix is required if you want an upper-case
letter (with the exception of 'bare' uppercase letters.)

The following table illustrates these rules. In each row, the first entry is the
key (for k.bindingsDict) and the other entries are equivalents that the user may
specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam

This table is consistent with how Leo already works (because it is consistent
with Tk's key-event specifiers). It is also, I think, the least confusing set of
rules.
#@nonl
#@-node:ekr.20081121105001.167:<< about internal bindings >>
#@+node:ekr.20081121105001.180: ctor
def __init__(self,c,w,tag=''):

    # Init the base class.
    QtCore.QObject.__init__(self)

    self.c = c
    self.w = w      # A leoQtX object, *not* a Qt object.
    self.tag = tag

    # Pretend there is a binding for these characters.
    close_flashers = c.config.getString('close_flash_brackets') or ''
    open_flashers  = c.config.getString('open_flash_brackets') or ''
    self.flashers = open_flashers + close_flashers


#@-node:ekr.20081121105001.180: ctor
#@+node:ekr.20081121105001.168:eventFilter
def eventFilter(self, obj, event):

    trace = False and not g.unitTesting
    verbose = False
    traceFocus = False and not g.unitTesting
    c = self.c ; k = c.k
    eventType = event.type()
    ev = QtCore.QEvent
    gui = g.app.gui
    kinds = [ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease]
    if traceFocus:
        table = (
            (ev.FocusIn,        'focus-in'),
            (ev.FocusOut,       'focus-out'),
            (ev.WindowActivate, 'activate'),
            (ev.WindowDeactivate,'deactivate'),
        )
        for evKind,kind in table:
            if eventType == evKind:
                g.trace('%11s %s %s' % (
                    (kind,id(obj),
                    # event.reason(),
                    g.app.gui.widget_name(obj) or obj)))
        # else: g.trace('unknown kind: %s' % eventType)

    if eventType == ev.WindowActivate:
        gui.onActivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
        # g.trace(g.app.gui.get_focus(c))
    elif eventType == ev.WindowDeactivate:
        gui.onDeactivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    #### Dangerous
    # elif eventType == ev.FocusIn:
        # if self.tag.startswith('tree'):
            # # g.trace('FocusIn',self.tag,c.p.h)
            # c.frame.tree.onHeadChanged(c.p)
        # override = False ; tkKey = None
    elif eventType in kinds:
        tkKey,ch,ignore = self.toTkKey(event)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])
        if ignore:
            override = False
        elif self.isSpecialOverride(tkKey,ch):
            override = True
        elif k.inState():
            override = not ignore # allow all keystrokes.
        # elif safe_mode:
            # override = len(aList) > 0 and not self.isDangerous(tkKey,ch)
        else:
            override = len(aList) > 0
    else:
        override = False ; tkKey = '<no key>'

    # A hack. QLineEdit generates ev.KeyRelease only.
    if eventType in (ev.KeyPress,ev.KeyRelease):
        p = c.currentPosition()
        isEditWidget = obj == c.frame.tree.edit_widget(p)
        keyIsActive = g.choose(
            isEditWidget,
            eventType == ev.KeyRelease,
            eventType == ev.KeyPress)
    else:
        keyIsActive = False

    if keyIsActive:
        if override:
            w = self.w # Pass the wrapper class, not the wrapped widget.
            stroke = self.toStroke(tkKey,ch)
            leoEvent = leoKeyEvent(event,c,w,ch,tkKey,stroke)
            ret = k.masterKeyHandler(leoEvent,stroke=stroke)
            c.outerUpdate()
        else:
            if True or trace and verbose:
                stroke = self.toStroke(tkKey,ch)
                if (stroke and not stroke.startswith('Alt+') and 
                    not stroke.startswith('Ctrl+') and
                    not stroke in ('PgDn','PgUp')
                ):
                    g.trace(self.tag,'unbound',tkKey,stroke)

    if trace: self.traceEvent(obj,event,tkKey,override)

    return override
#@-node:ekr.20081121105001.168:eventFilter
#@+node:ekr.20081121105001.181:isDangerous
def isDangerous (self,tkKey,ch):

    c = self.c

    if not c.frame.body.useScintilla: return False

    arrows = ('home','end','left','right','up','down')
    special = ('tab','backspace','period','parenright','parenleft')

    key = tkKey.lower()
    ch = ch.lower()
    isAlt = key.find('alt') > -1
    w = g.app.gui.get_focus()
    inTree = w == self.c.frame.tree.treeWidget

    val = (
        key in special or
        ch in arrows and not inTree and not isAlt or
        key == 'return' and not inTree # Just barely works.
    )

    # g.trace(tkKey,ch,val)
    return val
#@-node:ekr.20081121105001.181:isDangerous
#@+node:ekr.20081121105001.182:isSpecialOverride
def isSpecialOverride (self,tkKey,ch):

    # g.trace(repr(tkKey),repr(ch))
    c = self.c
    d = c.k.guiBindNamesDict

    table = [d.get(key) for key in d]
    table.append('Tab')
    table.append('Shift+Tab')

    if tkKey in table:
        return True
    elif len(tkKey) == 1:
        return True # Must process all ascii keys.
    elif ch in self.flashers:
        return True
    else:
        return False
#@-node:ekr.20081121105001.182:isSpecialOverride
#@+node:ekr.20081121105001.169:toStroke
def toStroke (self,tkKey,ch):

    trace = False and not g.unitTesting
    k = self.c.k ; s = tkKey

    special = ('Alt','Ctrl','Control',)
    isSpecial = [True for z in special if s.find(z) > -1]

    if not isSpecial:
        # Keep the Tk spellings for special keys.
        ch2 = k.guiBindNamesDict.get(ch) # was inverseDict
        if trace: g.trace('ch',repr(ch),'ch2',repr(ch2))
        if ch2: s = s.replace(ch,ch2)

    table = (
        ('Alt-','Alt+'),
        ('Ctrl-','Ctrl+'),
        ('Control-','Ctrl+'),
        # Use Alt+Key-1, etc.  Sheesh.
        # ('Key-','Key+'),
        ('Shift-','Shift+')
    )
    for a,b in table:
        s = s.replace(a,b)

    if trace: g.trace('tkKey',tkKey,'-->',s)
    return s
#@-node:ekr.20081121105001.169:toStroke
#@+node:ekr.20081121105001.170:toTkKey
def toTkKey (self,event):

    mods = self.qtMods(event)

    keynum,text,toString,ch = self.qtKey(event)

    tkKey,ch,ignore = self.tkKey(
        event,mods,keynum,text,toString,ch)

    return tkKey,ch,ignore
#@+node:ekr.20081121105001.171:isFKey
def isFKey(self,ch):

    return (
        ch and len(ch) in (2,3) and
        ch[0].lower() == 'f' and
        ch[1:].isdigit()
    )
#@-node:ekr.20081121105001.171:isFKey
#@+node:ekr.20081121105001.172:qtKey
def qtKey (self,event):

    '''Return the components of a Qt key event.'''

    trace = False and not g.unitTesting
    keynum = event.key()
    text   = event.text() # This is the unicode text.
    toString = QtGui.QKeySequence(keynum).toString()
    toUnicode = unicode

    try:
        ch1 = chr(keynum)
    except ValueError:
        ch1 = ''

    try:
        ch = toUnicode(ch1)
    except UnicodeError:
        ch = ch1

    text     = toUnicode(text)
    toString = toUnicode(toString)

    if trace: g.trace('keynum %s ch %s ch1 %s toString %s' % (
        repr(keynum),repr(ch),repr(ch1),repr(toString)))

    return keynum,text,toString,ch

#@-node:ekr.20081121105001.172:qtKey
#@+node:ekr.20081121105001.173:qtMods
def qtMods (self,event):

    modifiers = event.modifiers()

    # The order of this table is significant.
    # It must the order of modifiers in bindings
    # in k.masterGuiBindingsDict

    table = (
        (QtCore.Qt.AltModifier,     'Alt'),
        (QtCore.Qt.ControlModifier, 'Control'),
        (QtCore.Qt.MetaModifier,    'Meta'),
        (QtCore.Qt.ShiftModifier,   'Shift'),
    )

    mods = [b for a,b in table if (modifiers & a)]

    return mods
#@-node:ekr.20081121105001.173:qtMods
#@+node:ekr.20081121105001.174:tkKey & helpers
def tkKey (self,event,mods,keynum,text,toString,ch):

    '''Carefully convert the Qt key to a 
    Tk-style binding compatible with Leo's core
    binding dictionaries.'''

    trace = False and not g.unitTesting
    k = self.c.k

    # Thanks to Jesse Aldridge for additional entries.
    special = {
       'Backspace': 'BackSpace',
       'Backtab':   'Shift+Tab',
       'Esc':       'Escape',
       'Del':       'Delete',
       'Ins':       'Insert',
       # Use these to pass the key to the QTextWidget.
       'PgDown':    'PgDn',
       'PgUp':      'PgUp', # The entry must exist.
       # Use these to enable Leo's page-up/down commands.
       # 'PgDown':    'Next',
       # 'PgUp':      'Prior',
    }

    # Convert '&' to 'ampersand', for example.
    ch2 = k.guiBindNamesDict.get(ch or toString)

    if not ch: ch = ch2
    if not ch: ch = ''

    # Handle special cases.
    ch3 = special.get(toString)
    if ch3: ch = ch3

    ch4 = k.guiBindNamesDict.get(ch)
    if ch4: ch = ch4

    if 'Shift' in mods:
        mods,ch = self.shifted(mods,ch)
    elif len(ch) == 1:
        ch = ch.lower()

    if ('Alt' in mods or 'Control' in mods) and ch and ch in string.digits:
        mods.append('Key')

    tkKey = '%s%s%s' % ('-'.join(mods),mods and '-' or '',ch)
    ignore = not ch

    if trace: g.trace(
'keynum: %s, mods: %s text: %s, toString: %s, '
'tkKey: %s ignore: %5s ch: %s, ch2: %s, ch3: %s, ch4: %s' % (
keynum,mods,repr(text),toString,
repr(tkKey),bool(ignore),
repr(ch),repr(ch2),repr(ch3),repr(ch4)))

    ch = text or toString # was ch
    return tkKey,ch,ignore
#@+node:ekr.20081121105001.175:keyboardUpper1
def keyboardUpper1 (self,ch):

    '''A horrible, keyboard-dependent hack.

    Return the upper-case version of the given character
    whose original spelling has length == 1.'''

    d = {
        '1':'exclam',
        '2':'at',
        '3':'numbersign',
        '4':'dollar',
        '5':'percent',
        '6':'asciicircum',
        '7':'ampersand',
        '8':'asterisk',
        '9':'parenleft',
        '0':'parenright',
    }

    # g.trace(ch,d.get(ch))
    return d.get(ch)

#@-node:ekr.20081121105001.175:keyboardUpper1
#@+node:ekr.20081121105001.176:keyboardUpperLong
def keyboardUpperLong (self,ch):

    '''A horrible, keyboard-dependent hack.

    Return the upper-case version of the given character
    whose original spelling has length > 1.'''

    d = {
        '1':'exclam',
        '2':'at',
        '3':'numbersign',
        '4':'dollar',
        '5':'percent',
        '6':'asciicircum',
        '7':'ampersand',
        '8':'asterisk',
        '9':'parenleft',
        '0':'parenright',
        "quoteleft":    "asciitilde",
        "minus":        "underscore",
        "equal":        "plus",
        "bracketleft":  "braceleft",
        "bracketright": "braceright",
        "semicolon":    "colon",
        "quoteright":   "quotedbl",
        "backslash":    "bar",
        "comma":        "less",
        "period":       "greater",
        "slash":        "question",
        "parenleft":    "parenleft", # Bug fix: 2008/11/24
        "parenright":   "parenright", # Bug fix: 2008/11/24
    }
    # g.trace(ch,d.get(ch))
    return d.get(ch)
#@-node:ekr.20081121105001.176:keyboardUpperLong
#@+node:ekr.20081121105001.177:shifted
def shifted (self,mods,ch):
    '''
        A horrible, keyboard-dependent kludge.
        return the shifted version of the letter.
        return mods, ch.
    '''

    # Special tk symbols, like '&' have already
    # been converted to names like 'ampersand'.

    # These special characters should be handled in Leo's core.
    noShiftList = ('Return','BackSpace','Tab',)

    special = ('Home','End','Right','Left','Up','Down',)

    if len(ch) == 1:
        ch2 = self.keyboardUpper1(ch)
        if ch2:
            mods.remove('Shift')
            ch = ch2
        elif len(ch) == 1:
            # Correct regardless of alt/ctrl mods.
            mods.remove('Shift')
            ch = ch.upper()
        elif len(mods) == 1: # No alt/ctrl.
            mods.remove('Shift')
        else:
            pass
        # g.trace('ch',ch,'ch2',ch2,mods)
    else:
        ch3 = self.keyboardUpperLong(ch)
        if ch3: ch = ch3

        if ch3 or ch in noShiftList:
            mods.remove('Shift')
        elif ch in special:
            pass # Allow the shift.
        elif len(mods) == 1: # No alt/ctrl.
            mods.remove('Shift')
        else:
            pass # Retain shift modifier for all special keys.

    return mods,ch
#@-node:ekr.20081121105001.177:shifted
#@-node:ekr.20081121105001.174:tkKey & helpers
#@-node:ekr.20081121105001.170:toTkKey
#@+node:ekr.20081121105001.179:traceEvent
def traceEvent (self,obj,event,tkKey,override):

    c = self.c ; e = QtCore.QEvent

    eventType = event.type()

    if 0: # Show focus events.
        show = (
            (e.FocusIn,'focus-in'),(e.FocusOut,'focus-out'),
            (e.Enter,'enter'),(e.Leave,'leave'),
        )

    else:
        show = (
            (e.KeyPress,'key-press'),(e.KeyRelease,'key-release'),
            (e.ShortcutOverride,'shortcut-override'),
        )

    ignore = (
        e.ToolTip,
        e.FocusIn,e.FocusOut,e.Enter,e.Leave,
        e.MetaCall,e.Move,e.Paint,e.Resize,
        e.Polish,e.PolishRequest,
    )

    for val,kind in show:
        if eventType == val:
            if override:
                g.trace(
                    'tag: %s, kind: %s, in-state: %s, key: %s, override: %s' % (
                    self.tag,kind,repr(c.k.inState()),tkKey,override))
            return

    # if trace: g.trace(self.tag,
        # 'bound in state: %s, key: %s, returns: %s' % (
        # k.getState(),tkKey,ret))

    if False and eventType not in ignore:
        g.trace('%3s:%s' % (eventType,'unknown'))
#@-node:ekr.20081121105001.179:traceEvent
#@-node:ekr.20081121105001.166:class leoQtEventFilter
#@-node:ekr.20090313075003.2:Fixed (?) new unicode problem
#@+node:ekr.20090317102300.13:Fixed new unicode/copy-outline problem
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/85560a3d5bc933c

When I try to ctrl+shift+C a node with unicode chars, I get an exception:

Traceback (most recent call last):

  File "/home/ville/leo-editor/leo/core/leoCommands.py", line 358, in doCommand
    val = command(event)

  File "/home/ville/leo-editor/leo/core/leoCommands.py", line 3421, in
copyOutline
    g.app.gui.replaceClipboardWith(s)

  File "/home/ville/leo-editor/leo/plugins/qtGui.py", line 4020, in
replaceClipboardWith
    reportErrors=True)

  File "/home/ville/leo-editor/leo/plugins/qtGui.py", line 4469, in toUnicode
    return unicode(s)

UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position
220: ordinal not in range(128)

This is because (I suppose because of Tk?) copyOutline calls
replaceClipboardWith() with non-unicode data (created with
putLeoOutline).

There are several alternative fix approaches, none of which involve
(IMHO) doing any kind of decoding in app.gui.toUnicode. The easiest
would be, in replaceClipboardWith, to call g.toUnicode if (and only
if)  the arg is str (so we can always tell it comes from copyOutline
in core). 
#@nonl
#@+node:ekr.20081121105001.502:toUnicode (qtGui)
def toUnicode (self,s,encoding='utf-8',reportErrors=True):

    return unicode(s)
#@nonl
#@-node:ekr.20081121105001.502:toUnicode (qtGui)
#@+node:ekr.20081121105001.183:Clipboard (qtGui)
def replaceClipboardWith (self,s):

    '''Replace the clipboard with the string s.'''

    trace = False and not g.unitTesting
    cb = self.qtApp.clipboard()
    if cb:
        # cb.clear()  # unnecessary, breaks on some Qt versions
        if type(s) == type(''):
            s = g.app.gui.toUnicode(s)
        cb.setText(s)
        if trace: g.trace(len(s),type(s))
    else:
        g.trace('no clipboard!')

def getTextFromClipboard (self):

    '''Get a unicode string from the clipboard.'''

    trace = False and not g.unitTesting
    cb = self.qtApp.clipboard()
    if cb:
        s = cb.text()
        if trace: g.trace (len(s),type(s))
        s = g.app.gui.toUnicode(s)
        return s
    else:
        g.trace('no clipboard!')
        return ''
#@-node:ekr.20081121105001.183:Clipboard (qtGui)
#@-node:ekr.20090317102300.13:Fixed new unicode/copy-outline problem
#@-node:ekr.20090124101344.1:Recent
#@+node:ekr.20081208155215.12:Unused
#@+node:ekr.20090303081428.10:clearLine
# blackColor = None

# def clearLine (self,s):

    # trace = False and not g.unitTesting
    # if trace: g.trace(s)

    # if not self.blackColor:
        # self.blackColor = QtGui.QColor('black')

    # self.highlighter.setFormat(0,len(s),self.blackColor)
#@-node:ekr.20090303081428.10:clearLine
#@-node:ekr.20081208155215.12:Unused
#@-all
#@nonl
#@-node:ekr.20081121105001.147:@thin qtNotes.txt
#@-leo
