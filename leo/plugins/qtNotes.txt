#@+leo-ver=4-thin
#@+node:ekr.20081016072304.13:@thin qtNotes.txt
#@+all
#@+node:ekr.20081010070648.5: To do
@nocolor-node

Urgent:
- Fix key problems:
    - Ctrl-Shift-9 is the same as Ctrl-(
    - Ctrl-tab gets put into text.
    - Shift-Backspace puts "Shift-Backspace" in text.
    - Esc does not terminate minibuffer.
* Hook up undo menu.

Most important:
- Re-enable syntax coloring.
- Reading/saving a window does not properly set its size.
* Can not open the settings file twice.
- Changes to headline do not stick after, e.g., ctrl-r.
- Redraw all icons after save (but not save-as or save-to).


Next:
- Shift-tab is Smart home.
- multiline strings to the log pane are not treated properly.
- print-settings does not print to a tab and is very slow.
- Fix failing unit tests. 
- Support Icon area.
- Do gui-dependent commands (in leoQtFrame)
- Complete dialogs in leoQtGui.
- Finish w.flashCharacter.

Minor bugs:
- https://bugs.launchpad.net/leo-editor/+bug/286493
  File "qtGui.py", line 745, in delete
    s = s[:i] + s[j+1:]
    TypeError: slice indices must be integers or None or have an __index__ method
    (Must convert indices to ints.)
Cleanup:
    - Clean up text classes.
        - Finish leoQtTextWidget class.
        - Add subclasses for QLineEdit, QScintilla, etc.
Later:
    - Experiment with sending <shift-tab> directly to QScintilla.
    - Call setLexer(0) for nocolor nodes.
    - Add settings for syntax coloring.
         - Make Scintilla handle Leo markup.
    - Support multiple body editors.
    - Support chapters
    - Handle pane orientation:
        A popular arrangement would be editor and outline
        in top pane with the log along the bottom.
    - Remove old-style Leo settings?
    - Make tkinter code a plugin.
        - If no gui specified on command line,
          use the first gui that can be imported.
    - Support @ifgui in settings trees.

Done, but not resolved:
- (done) Is it possible to specify QScintilla styles with a stylesheet?
- (done) Can I specify a zoom-in factor for QTextEdit?
#@nonl
#@-node:ekr.20081010070648.5: To do
#@+node:ekr.20081019082316.10:New features in the core
@nocolor-node

- Added support for --gui=qt and --gui=tk command-line options.
#@nonl
#@-node:ekr.20081019082316.10:New features in the core
#@+node:ekr.20081017015442.15:pylint errors
# Hard to fix
W0221:4426:leoQtMenu.add_command: Arguments number differs from overridden method
W0221:4607:leoQtMenu.getMenuLabel: Arguments number differs from overridden method
#@+node:ekr.20081017015442.19:qtGui dialogs
E0602:2793:leoQtGui.runAboutLeoDialog: Undefined variable 'qtAboutLeo'
E0602:2798:leoQtGui.runAskLeoIDDialog: Undefined variable 'qtAskLeoID'
E0602:2803:leoQtGui.runAskOkDialog: Undefined variable 'qtAskOk'
E0602:2808:leoQtGui.runAskOkCancelNumberDialog: Undefined variable 'qtAskOkCancelNumber'
E0602:2813:leoQtGui.runAskOkCancelStringDialog: Undefined variable 'qtAskOkCancelString'
E0602:2818:leoQtGui.runAskYesNoDialog: Undefined variable 'qtAskYesNo'
E0602:2824:leoQtGui.runAskYesNoCancelDialog: Undefined variable 'qtAskYesNoCancel'

E1101:2955:leoQtGui.runFileDialog: Module 'PyQt4.QtCore' has no 'STOCK_CANCEL' member
E1101:2955:leoQtGui.runFileDialog: Module 'PyQt4.QtCore' has no 'RESPONSE_CANCEL' member
E1101:2956:leoQtGui.runFileDialog: Module 'PyQt4.QtCore' has no 'TOCK_OPEN' member
E1101:2956:leoQtGui.runFileDialog: Module 'PyQt4.QtCore' has no 'RESPONSE_OK' member
E1101:2960:leoQtGui.runFileDialog: Module 'PyQt4.QtCore' has no 'STOCK_CANCEL' member
E1101:2960:leoQtGui.runFileDialog: Module 'PyQt4.QtCore' has no 'RESPONSE_CANCEL' member
E1101:2961:leoQtGui.runFileDialog: Module 'PyQt4.QtCore' has no 'STOCK_SAVE' member
E1101:2961:leoQtGui.runFileDialog: Module 'PyQt4.QtCore' has no 'RESPONSE_OK' member
E1101:2966:leoQtGui.runFileDialog: Module 'PyQt4.QtCore' has no 'FILE_CHOOSER_ACTION_SAVE' member
E1101:2967:leoQtGui.runFileDialog: Module 'PyQt4.QtCore' has no 'FILE_CHOOSER_ACTION_OPEN' member
E1101:2970:leoQtGui.runFileDialog: Module 'PyQt4.QtGui' has no 'FileChooserDialog' member
E1101:2974:leoQtGui.runFileDialog: Module 'PyQt4.QtCore' has no 'RESPONSE_OK' member
E1101:2983:leoQtGui.runFileDialog: Module 'PyQt4.QtGui' has no 'FileFilter' member
E1101:2991:leoQtGui.runFileDialog: Module 'PyQt4.QtCore' has no 'RESPONSE_OK' member
E1101:2998:leoQtGui.runFileDialog: Module 'PyQt4.QtCore' has no 'RESPONSE_CANCEL' member
#@nonl
#@-node:ekr.20081017015442.19:qtGui dialogs
#@-node:ekr.20081017015442.15:pylint errors
#@+node:ekr.20081014095718.13:Recent projects...
#@+node:ekr.20081015062931.10:Focus stuff...
#@+node:ekr.20081014095718.15:get_name (qtTree)
def getName (self):

    return 'canvas(tree)' # Must start with 'canvas'
#@-node:ekr.20081014095718.15:get_name (qtTree)
#@+node:ekr.20081004172422.621:Qt bindings... (qtFrame)
def bringToFront (self):        pass 
def deiconify (self):           pass
def getFocus(self):             return g.app.gui.get_focus() 
def get_window_info(self):      return 0,0,0,0
def iconify(self):              pass
def lift (self):                pass
def update (self):              pass

def getTitle (self):
    return g.toUnicode(self.top.windowTitle(),'utf-8')

def setTitle (self,s):
    self.top.setWindowTitle(s)
#@-node:ekr.20081004172422.621:Qt bindings... (qtFrame)
#@+node:ekr.20081004172422.865:add_command
def add_command (self,**keys):

    """Wrapper for the Tkinter add_command menu method."""

    c = self.c
    accel = keys.get('accelerator') or ''
    command = keys.get('command')
    label = keys.get('label')
    n = keys.get('underline')
    menu = keys.get('menu') or self
    if not label: return

    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    if accel:
        label = '%s\t%s' % (label,accel)

    action = menu.addAction(label)
    # if shortcut: action.setShortcut(shortcut)

    if command:
        def add_command_callback(label=label,command=command):
            return command()

        QtCore.QObject.connect(action,
            QtCore.SIGNAL("triggered()"),add_command_callback)
#@-node:ekr.20081004172422.865:add_command
#@+node:ekr.20081004102201.676:class leoKeyEvent
class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c,w,tkKey):

        # The main ivars.
        self.actualEvent = event
        self.c      = c
        self.char   = tkKey 
        self.keysym = tkKey
        self.w = self.widget = w # A leoQtX object

        # Auxiliary info.
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0
        # Support for fastGotoNode plugin
        self.x_root = hasattr(event,'x_root') and event.x_root or 0
        self.y_root = hasattr(event,'y_root') and event.y_root or 0

    def __repr__ (self):

        return 'qtGui.leoKeyEvent: char: %s, keysym: %s' % (repr(self.char),repr(self.keysym))
#@-node:ekr.20081004102201.676:class leoKeyEvent
#@+node:ekr.20081004172422.510:Focus (qtBody)
def getFocus(self):

    g.trace('leoQtBody',self.widget,g.callers(4))
    return g.app.gui.get_focus()

findFocus = getFocus

def hasFocus (self):

    val = self.widget == g.app.gui.get_focus(self.c)
    # g.trace('leoQtBody returns',val,self.widget,g.callers(4))
    return val

def setFocus (self):

    # g.trace('leoQtBody',self.widget,g.callers(4))
    g.app.gui.set_focus(self.c,self.widget)
#@-node:ekr.20081004172422.510:Focus (qtBody)
#@+node:ekr.20081004102201.657:Focus (qtGui)
def get_focus(self,c=None):

    """Returns the widget that has focus."""

    w = QtGui.QApplication.focusWidget()
    # g.trace('leoQtGui',w)
    return w

def set_focus(self,c,w):

    """Put the focus on the widget."""

    if w:
        # g.trace('leoQtGui',w,g.callers(4))
        w.setFocus()
#@-node:ekr.20081004102201.657:Focus (qtGui)
#@+node:ekr.20081015062931.11:widget_name (qtGui
def widget_name (self,w):

    # First try the widget's getName method.
    if not 'w':
        name = '<no widget>'
    elif hasattr(w,'objectName'):
        name = str(w.objectName())
        if name == 'treeWidget':
            name = 'canvas(treeWidget)'
    elif hasattr(w,'getName'):
        name = w.getName()
    elif hasattr(w,'_name'):
        name = w._name
    else:
        name = repr(w)

    # g.trace(name,w)
    return name
#@-node:ekr.20081015062931.11:widget_name (qtGui
#@+node:ekr.20081004102201.628:class leoQtEventFilter
class leoQtEventFilter(QtCore.QObject):

    << about internal bindings >>

    @others
#@+node:ekr.20081007115148.6:<< about internal bindings >>
@nocolor-node
@

Here are the rules for translating key bindings (in leoSettings.leo) into keys for k.bindingsDict:

1.  The case of plain letters is significant:  a is not A.

2. The Shift- prefix can be applied *only* to letters. Leo will ignore (with a
warning) the shift prefix applied to any other binding, e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is *not*
significant. Thus, the Shift- prefix is required if you want an upper-case
letter (with the exception of 'bare' uppercase letters.)

The following table illustrates these rules. In each row, the first entry is the
key (for k.bindingsDict) and the other entries are equivalents that the user may
specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam

This table is consistent with how Leo already works (because it is consistent
with Tk's key-event specifiers). It is also, I think, the least confusing set of
rules.
#@nonl
#@-node:ekr.20081007115148.6:<< about internal bindings >>
#@+node:ekr.20081018155359.10: ctor
def __init__(self,c,w,tag=''):

    # Init the base class.
    QtCore.QObject.__init__(self)

    self.c = c
    self.w = w      # A leoQtX object, *not* a Qt object.
    self.tag = tag
#@-node:ekr.20081018155359.10: ctor
#@+node:ekr.20081013143507.12:eventFilter
def eventFilter(self, obj, event):

    c = self.c ; k = c.k ; e = QtCore.QEvent 
    trace = False ; verbose = True
    eventType = event.type()

    if eventType in (e.ShortcutOverride,e.KeyPress,e.KeyRelease):
        tkKey,ch,ignore = self.toTkKey(event)
        # if trace and verbose: g.trace(tkKey,ch)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])

        if not c.frame.body.useScintilla:
            override = not ignore # Send all non-ignored keystrokes to the widget.
        elif k.inState():
            override = not ignore # allow all keystroke.
        elif safe_mode:
            override = len(aList) > 0 and not self.isDangerous(tkKey,ch)
        else:
            override = len(aList) > 0
    else:
        override = False ; tkKey = '<no key>'

    if eventType == e.KeyPress:
        if override:
            w = self.w # Pass the wrapper class, not the wrapped widget.
            stroke = self.toStroke(tkKey,ch)
            leoEvent = leoKeyEvent(event,c,w,stroke)
            ret = k.masterKeyHandler(leoEvent,stroke=stroke)
            if trace: g.trace(self.tag,
                g.choose(k.inState(),'in-state','bound'),tkKey,'ret',ret)
        else:
            if trace and verbose: g.trace(self.tag,'unbound',tkKey)

    if trace: self.traceEvent(obj,event,tkKey,override)

    return override
#@-node:ekr.20081013143507.12:eventFilter
#@+node:ekr.20081015132934.10:isDangerous
def isDangerous (self,tkKey,ch):


    c = self.c

    if not c.frame.body.useScintilla: return False

    arrows = ('home','end','left','right','up','down')
    special = ('tab','backspace','period','parenright','parenleft')

    key = tkKey.lower()
    ch = ch.lower()
    isAlt = key.find('alt') > -1
    w = g.app.gui.get_focus()
    inTree = w == self.c.frame.tree.treeWidget

    val = (
        key in special or
        ch in arrows and not inTree and not isAlt or
        key == 'return' and not inTree # Just barely works.
    )

    # g.trace(tkKey,ch,val)
    return val
#@-node:ekr.20081015132934.10:isDangerous
#@+node:ekr.20081024164012.10:isFKey
def isFKey(self,ch):

    return (
        ch and len(ch) in (2,3) and
        ch[0].lower() == 'f' and
        ch[1:].isdigit()
    )
#@-node:ekr.20081024164012.10:isFKey
#@+node:ekr.20081011152302.10:toStroke
def toStroke (self,tkKey,ch):

    k = self.c.k ; s = tkKey

    special = ('Alt','Ctrl','Control',)
    isSpecial = [True for z in special if s.find(z) > -1]

    if not isSpecial:
        # Keep the Tk spellings for special keys.
        ch2 = k.guiBindNamesInverseDict.get(ch)
        if ch2: s = s.replace(ch,ch2)

    table = (
        ('Alt-','Alt+'),
        ('Ctrl-','Ctrl+'),
        ('Control-','Ctrl+'),
        # Use Alt+Key-1, etc.  Sheesh.
        # ('Key-','Key+'),
        ('Shift-','Shift+')
    )
    for a,b in table:
        s = s.replace(a,b)

    # g.trace('tkKey',tkKey,'-->',s)
    return s
#@-node:ekr.20081011152302.10:toStroke
#@+node:ekr.20081008084746.1:toTkKey
def toTkKey (self,event):

    c = self.c ; k = c.k ; trace = False ; verbose = True

    allowShiftList = ('Down','End','Home','Left','Right','Up')

    keynum = event.key() ; allowShift = True ; isKnown = False
    try:
        ch = chr(keynum)
        if trace and verbose: g.trace(ch,keynum)
    except ValueError:
        ch = event.text()
        if not ch:
            ch = QtGui.QKeySequence(keynum).toString()
            isKnown = True
        if not ch:
            ch = "<unknown char: %s>" % (keynum)
        ch = g.toUnicode(ch,g.app.tkEncoding)
        if trace and verbose:
            g.trace('special',ch) # munge.

    # Convert special characters to Tk Spellings.
    if   ch in ('\r','\n'): ch = 'Return'
    elif ch == '\t': ch = 'Tab'
    elif ch == '\b': ch = 'BackSpace'
    else:
        ch2 = k.guiBindNamesDict.get(ch)
        if ch2:
            if not isKnown:
                allowShift = ch in allowShiftList
            if trace and verbose: g.trace('ch',ch,'ch2',ch2)
            ch = ch2

    # Convert to Tk style binding.
    mods = [] ; alt,ctrl = False,False
    if event.modifiers() & QtCore.Qt.AltModifier:
        mods.append("Alt")
    if event.modifiers() & QtCore.Qt.ControlModifier:
        mods.append("Control")
    if event.modifiers() & QtCore.Qt.ShiftModifier:
        # g.trace('allowShift',allowShift,'ch')
        if not allowShift:
            pass
        elif len(ch) == 1:
            ch = ch.upper()
        else:
            mods.append("Shift")
    elif len(ch) == 1: ch = ch.lower()

    if 'Alt' in mods and ch in string.digits:
        mods.append('Key')

    tkKey = '%s%s%s' % ('-'.join(mods),mods and '-' or '',ch)

    # If the documentation is to be believed,
    # this definition of ignore should be portable.
    if ch in allowShiftList or self.isFKey(ch):
        ignore = False
    else:
        ignore = not g.toUnicode(event.text(),'utf-8')
    if trace: g.trace('ch',repr(ch),'tkKey',repr(tkKey),'ignore',ignore)

    return tkKey,ch,ignore
#@-node:ekr.20081008084746.1:toTkKey
#@+node:ekr.20081013143507.11:traceEvent
def traceEvent (self,obj,event,tkKey,override):

    c = self.c ; e = QtCore.QEvent

    eventType = event.type()

    if False and not self.dumped:
        self.dumped = True
        g.trace(len(c.k.masterGuiBindingsDict.keys()))

    if 0: # Show focus events.
        show = (
            (e.FocusIn,'focus-in'),(e.FocusOut,'focus-out'),
            (e.Enter,'enter'),(e.Leave,'leave'),
        )

    else:
        show = (
            (e.KeyPress,'key-press'),(e.KeyRelease,'key-release'),
            (e.ShortcutOverride,'shortcut-override'),
        )

    ignore = (
        e.ToolTip,
        e.FocusIn,e.FocusOut,e.Enter,e.Leave,
        e.MetaCall,e.Move,e.Paint,e.Resize,
        e.Polish,e.PolishRequest,
    )

    for val,kind in show:
        if eventType == val:
            g.trace(
                # 'val: %-3s' %(val),
                'kind',kind,'key',tkKey,'override',override)
            return

    if False and eventType not in ignore:
        g.trace('%3s:%s' % (eventType,'unknown'))
#@-node:ekr.20081013143507.11:traceEvent
#@-node:ekr.20081004102201.628:class leoQtEventFilter
#@+node:ekr.20081004172422.846:editLabel
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c

    # g.trace(p.headString(),selectAll)
    w = self.treeWidget
    data = self.vnodeDict.get(p.v)
    if not data: return

    it = data [0][1]

    w.editItem(it)
    if not selectAll:
        editWidget = w.itemWidget(it,0) # A QLineEdit
        s = editWidget.text()
        editWidget.setSelection(len(s),0)

    # A nice hack: just clear the focus request.
    c.requestedFocusWidget = None

    # g.trace('leoQtTree','it',it,p and p.headString())

    # if p and p != self.editPosition():
        # self.endEditLabel()
        # # This redraw *is* required so the c.edit_widget(p) will exist.
        # c.redraw()
        # c.outerUpdate()

    # self.setEditPosition(p) # That is, self._editPosition = p
    # w = c.edit_widget(p)
    # if p and w:
        # self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        # self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        # c.headlineWantsFocus(p) # Make sure the focus sticks.
        # c.k.showStateAndMode(w)
#@-node:ekr.20081004172422.846:editLabel
#@-node:ekr.20081015062931.10:Focus stuff...
#@+node:ekr.20081018155359.12:Problems with multiple windows
#@+node:ekr.20081004102201.629:class  Window
class Window(QtGui.QMainWindow, qt_main.Ui_MainWindow):

    '''A class representing all parts of the main Qt window
    as created by Designer.

    c.frame.top is a Window object.

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    '''

    @others

#@+node:ekr.20081004172422.884: ctor (Window)
# Called from leoQtFrame.finishCreate.

def __init__(self,c,parent=None):

    '''Create Leo's main window, c.frame.top'''

    self.c = c

    # g.trace('Window')

    # Init both base classes.
    QtGui.QMainWindow.__init__(self,parent)
    qt_main.Ui_MainWindow.__init__(self)

    # Init the QDesigner elements.
    self.setupUi(self)

    # The following ivars (and more) are inherited from UiMainWindow:
        # self.lineEdit   = QtGui.QLineEdit(self.centralwidget) # The minibuffer.
        # self.menubar    = QtGui.QMenuBar(MainWindow)          # The menu bar.
        # self.tabWidget  = QtGui.QTabWidget(self.splitter)     # The log pane.
        # self.textEdit   = Qsci.QsciScintilla(self.splitter_2) # The body pane.
        # self.treeWidget = QtGui.QTreeWidget(self.splitter)    # The tree pane.

    self.buttons = self.addToolBar("Buttons")
    self.buttons.addAction(self.actionSave)

    self.setStyleSheets()
#@-node:ekr.20081004172422.884: ctor (Window)
#@+node:ekr.20081020075840.11:closeEvent
def closeEvent (self,event):

    # g.trace('Window',event)

    c = self.c

    if c.changed:
        veto = c.frame.promptForSave()
        if veto:
            event.ignore()
        else:
            event.accept()
    else:
        event.accept()

#@-node:ekr.20081020075840.11:closeEvent
#@+node:ekr.20081016072304.14:setStyleSheets & helper
styleSheet_inited = False

def setStyleSheets(self):

    c = self.c

    sheet = c.config.getData('qt-gui-plugin-style-sheet')
    if sheet: sheet = '\n'.join(sheet)
    self.setStyleSheet(sheet or self.default_sheet())
#@nonl
#@+node:ekr.20081018053140.10:defaultStyleSheet
def defaultStyleSheet (self):

    '''Return a reasonable default style sheet.'''

    # Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords
    return '''\

/* A QWidget: supports only background attributes.*/
QSplitter::handle {

    background-color: #CAE1FF; /* Leo's traditional lightSteelBlue1 */
}
QSplitter {
    border-color: white;
    background-color: white;
    border-width: 3px;
    border-style: solid;
}
QTreeWidget {
    background-color: #ffffec; /* Leo's traditional tree color */
}
/* Not supported. */
QsciScintilla {
    background-color: pink;
}
'''
#@-node:ekr.20081018053140.10:defaultStyleSheet
#@-node:ekr.20081016072304.14:setStyleSheets & helper
#@-node:ekr.20081004102201.629:class  Window
#@-node:ekr.20081018155359.12:Problems with multiple windows
#@+node:ekr.20081020075840.21:Suppress updates until init complete
#@+node:ekr.20081020075840.20:initCompleteHint
def initCompleteHint (self):

    '''A kludge: called to enable text changed events.'''

    self.initComplete = True
    # g.trace(self.c)
#@-node:ekr.20081020075840.20:initCompleteHint
#@+node:ekr.20081011035036.1:onTextChanged
def onTextChanged (self):

    '''Update Leo after the body has been changed.

    self.selecting is guaranteed to be True during
    the entire selection process.'''

    c = self.c ; p = c.currentPosition()
    tree = c.frame.tree ; w = self
    trace = True ; verbose = False

    if tree.selecting:
        if trace and verbose: g.trace('selecting')
        return
    if tree.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if not p:
        return g.trace('*** no p')

    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText() # Converts to unicode.

    # Get the previous values from the tnode.
    oldText = g.toUnicode(p.v.t._bodyString,"utf-8")
    if oldText == newText:
        if trace: g.trace('*** unexpected non-change',color="red")
        return

    if trace and verbose: g.trace(p.headString(),len(oldText),len(newText))

    oldIns  = p.v.t.insertSpot
    i,j = p.v.t.selectionStart,p.v.t.selectionLength
    oldSel  = (i,j-i)
    oldYview = None
    undoType = 'changed event'
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,
        oldSel=oldSel,newSel=newSel,oldYview=oldYview)

    # Update the tnode.
    p.v.setBodyString(newText)
    p.v.t.insertSpot = newInsert
    i,j = newSel
    if i > j: i,j = j,i
    p.v.t.selectionStart,p.v.t.selectionLength = (i,j-i)

    # No need to redraw the screen.
    if not self.useScintilla:
        c.recolor()
    if not c.changed and c.frame.initComplete:
        c.setChanged(True)
    self.updateEditors()
    c.frame.tree.updateIcon(p)
    c.outerUpdate()
#@-node:ekr.20081011035036.1:onTextChanged
#@-node:ekr.20081020075840.21:Suppress updates until init complete
#@+node:ekr.20081022151429.10:Fixed startup crasher
Traceback (most recent call last):
 File "launchLeo.py", line 8, in ?
   leo.core.runLeo.run()
 File "/transfer/qt-plugin/leo/core/runLeo.py", line 120, in run
   c,frame = createFrame(fileName,relativeFileName,script)
 File "/transfer/qt-plugin/leo/core/runLeo.py", line 170, in
createFrame
   c.chapterController.finishCreate()
 File "/transfer/qt-plugin/leo/core/leoChapters.py", line 50, in
finishCreate
   cc.createChaptersNode()
 File "/transfer/qt-plugin/leo/core/leoChapters.py", line 473, in
createChaptersNode
   p = root.insertAsLastChild()
 File "/transfer/qt-plugin/leo/core/leoNodes.py", line 2307, in
insertAsLastChild
   n = p.numberOfChildren()
 File "/transfer/qt-plugin/leo/core/leoNodes.py", line 1263, in
numberOfChildren
   return len(p.v.t.children)
AttributeError: 'NoneType' object has no attribute 't'
#@+node:ekr.20081004172422.528:qtFrame.finishCreate & helpers
def finishCreate (self,c):

    f = self ; f.c = c

    # g.trace('***qtFrame')

    self.bigTree           = c.config.getBool('big_outline_pane')
    self.trace_status_line = c.config.getBool('trace_status_line')
    self.use_chapters      = c.config.getBool('use_chapters')
    self.use_chapter_tabs  = c.config.getBool('use_chapter_tabs')

    f.top = Window(c)
    g.app.gui.attachLeoIcon(f.top)
    f.top.setWindowTitle(self.title)
    f.top.show()

    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    # # f.createOuterFrames()
    # # f.createIconBar()
    # # f.createLeoSplitters(f.outerFrame)
    f.createSplitterComponents()
    # # f.createStatusLine()
    f.createFirstTreeNode() # Call the base-class method.
    f.menu = leoQtMenu(f)
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = leoQtMinibuffer(c)
    c.bodyWantsFocusNow()
#@+node:ekr.20081004172422.530:createSplitterComponents (qtFrame)
def createSplitterComponents (self):

    f = self ; c = f.c

    f.tree  = leoQtTree(c,f)
    f.log   = leoQtLog(f,None)
    f.body  = leoQtBody(f,None)

    if f.use_chapters:
        c.chapterController = cc = leoChapters.chapterController(c)

    # # Create the canvas, tree, log and body.
    # if f.use_chapters:
        # c.chapterController = cc = leoChapters.chapterController(c)

    # # split1.pane1 is the secondary splitter.

    # if self.bigTree: # Put outline in the main splitter.
        # if self.use_chapters and self.use_chapter_tabs:
            # cc.tt = leoQtTreeTab(c,f.split1Pane2,cc)
        # f.canvas = f.createCanvas(f.split1Pane1)
        # f.tree  = leoQtTree(c,f,f.canvas)
        # f.log   = leoQtLog(f,f.split2Pane2)
        # f.body  = leoQtBody(f,f.split2Pane1)
    # else:
        # if self.use_chapters and self.use_chapter_tabs:
            # cc.tt = leoQtTreeTab(c,f.split2Pane1,cc)
        # f.canvas = f.createCanvas(f.split2Pane1)
        # f.tree   = leoQtTree(c,f,f.canvas)
        # f.log    = leoQtLog(f,f.split2Pane2)
        # f.body   = leoQtBody(f,f.split1Pane2)

    # # Yes, this an "official" ivar: this is a kludge.
    # # f.bodyCtrl = f.body.bodyCtrl

    # # Configure.
    # f.setTabWidth(c.tab_width)
    # f.reconfigurePanes()
    # f.body.setFontFromConfig()
    # f.body.setColorFromConfig()
#@-node:ekr.20081004172422.530:createSplitterComponents (qtFrame)
#@-node:ekr.20081004172422.528:qtFrame.finishCreate & helpers
#@-node:ekr.20081022151429.10:Fixed startup crasher
#@+node:ekr.20081023060109.10:Make the body pane a richTextEdit
I added the stackedWidget and richTextWidget (for demo purposes). The
layout is not quite optimal yet (the border around the body pane is a
bit too big). You can test it by running this script (ctrl+b):

w = c.frame.top
sw = w.stackedWidget
rted = w.richTextEdit
rted.setHtml("This is <b>rich text</b>")
sw.setCurrentIndex(1)

We should not rig widgets like this to the core,
and notably not install the event filter for these (since the wanted
behaviour should be dictated by the current widget). 
#@nonl
#@+node:ekr.20081004172422.504: ctor (qtBody)
def __init__ (self,frame,parentFrame):

    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)

    c = self.c
    assert c.frame == frame and frame.c == c

    self.useScintilla = c.config.getBool('qt-use-scintilla')
    # g.trace('leoQtBody: useScintilla:',self.useScintilla)

    # Set the actual gui widget.
    if self.useScintilla:
        self.widget = c.frame.top.textEdit
    else:
        top = c.frame.top ; sw = top.stackedWidget
        sw.setCurrentIndex(1)
        self.widget = w = top.richTextEdit # A QTextEdit.
        w.acceptRichText = False
    # g.trace('qtBody',self.widget)

    self.bodyCtrl = self # The widget as seen from Leo's core.
    ### self.body_p = None

    # Config stuff.
    self.tags = {}
    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    self.wrapState = wrap
    # parentFrame.configure(bg='LightSteelBlue1')

    # For multiple body editors.
    self.editor_name = None
    self.editor_v = None
    self.numberOfEditors = 1
    self.totalNumberOfEditors = 1

    # Finish initing.
    self.colorizer = leoColor.nullColorizer(c)
    self.injectIvars()
    self.setBodyConfig()
    self.setFontFromConfig()
    self.setColorFromConfig()

    # Hook up qt events.
    self.ev_filter = leoQtEventFilter(c,w=self,tag='body')
    self.widget.installEventFilter(self.ev_filter)

    self.widget.connect(self.widget,
        QtCore.SIGNAL("textChanged()"),self.onTextChanged)
#@-node:ekr.20081004172422.504: ctor (qtBody)
#@+node:ekr.20081004172422.884: ctor (Window)
# Called from leoQtFrame.finishCreate.

def __init__(self,c,parent=None):

    '''Create Leo's main window, c.frame.top'''

    self.c = c

    # g.trace('Window')

    # Init both base classes.
    QtGui.QMainWindow.__init__(self,parent)
    qt_main.Ui_MainWindow.__init__(self)

    # Init the QDesigner elements.
    self.setupUi(self)

    # The following ivars (and more) are inherited from UiMainWindow:
        # self.lineEdit   = QtGui.QLineEdit(self.centralwidget) # The minibuffer.
        # self.menubar    = QtGui.QMenuBar(MainWindow)          # The menu bar.
        # self.tabWidget  = QtGui.QTabWidget(self.splitter)     # The log pane.
        # self.textEdit   = Qsci.QsciScintilla(self.splitter_2) # The body pane.
        # self.treeWidget = QtGui.QTreeWidget(self.splitter)    # The tree pane.

    self.buttons = self.addToolBar("Buttons")
    self.buttons.addAction(self.actionSave)

    self.setStyleSheets()
#@-node:ekr.20081004172422.884: ctor (Window)
#@+node:ekr.20081023131208.10:Coloring
def forceFullRecolor (self):            pass
def update_idletasks(self):             pass

def removeAllTags(self):
    return ###
    w = self.widget
    format = QtGui.QTextCharFormat()
    color = QtGui.QColor('black')
    brush = QtGui.QBrush(color)
    format.setForeground(brush)
    a,b = self.getSelectionRange()
    self.selectAllText()
    w.setCurrentCharFormat(format)
    self.setSelectionRange(a,b)

def tag_add(self,tag,x1,x2):
    return ###
    if tag == 'comment1':
        # g.trace(tag,x1,x2)
        w = self.widget
        color = QtGui.QColor('firebrick')
        sb = w.verticalScrollBar()
        pos = sb.sliderPosition()
        a,b = self.getSelectionRange()
        ins = self.getInsertPoint()
        self.setSelectionRange(x1,x2)
        w.setTextColor(color)
        self.setSelectionRange(a,b,insert=ins)
        sb.setSliderPosition(pos)

def tag_config (self,*args,**keys):
    if len(args) == 1:
        key = args[0]
        # g.trace(key,keys)
        self.tags[key] = keys
    else:
        g.trace('oops',args,keys)

tag_configure = tag_config

def tag_names (self):
    return []
#@-node:ekr.20081023131208.10:Coloring
#@+node:ekr.20081004172422.516:Idle time
def after_idle(self,func,threadCount):
    return ###
    # g.trace(func.__name__,'threadCount',threadCount)
    return func(threadCount)

def after(self,n,func,threadCount):
    return ###
    def after_callback(func=func,threadCount=threadCount):
        # g.trace(func.__name__,threadCount)
        return func(threadCount)
    QtCore.QTimer.singleShot(n,after_callback)

def scheduleIdleTimeRoutine (self,function,*args,**keys):
    g.trace()
    # if not g.app.unitTesting:
        # self.widget.after_idle(function,*args,**keys)
#@-node:ekr.20081004172422.516:Idle time
#@+node:ekr.20081011035036.10:setBodyConfig
def setBodyConfig (self):

    c = self.c

    if self.useScintilla:
        self.setScintillaConfig()
    else:
        self.setRichTextConfig()
        self.colorizer = leoColor.colorizer(c)
#@nonl
#@+node:ekr.20081023060109.11:setScintillaConfi
def setScintillaConfig (self):

    c = self.c ; w = self.widget
    tag = 'qt-scintilla-styles'
    qcolor,qfont = QtGui.QColor,QtGui.QFont

    def oops(s): g.trace('bad @data %s: %s' % (tag,s))

    # To do: make this configurable the leo way
    if 0: # Suppress lexing.
        w.setLexer()
        lexer = w.lexer()
    else:
        lexer = Qsci.QsciLexerPython(w)
        # A small font size, to be magnified.
        font = qfont("Courier New",8,qfont.Bold)
        lexer.setFont(font)
        table = None
        aList = c.config.getData('qt-scintilla-styles')
        if aList:
            aList = [s.split(',') for s in aList]
            table = []
            for z in aList:
                if len(z) == 2:
                    color,style = z
                    table.append((color.strip(),style.strip()),)
                else: oops('entry: %s' % z)
            # g.trace(g.printList(table))

        if not table:
            table = (
                ('red','Comment'),
                ('green','SingleQuotedString'),
                ('green','DoubleQuotedString'),
                ('green','TripleSingleQuotedString'),
                ('green','TripleDoubleQuotedString'),
                ('green','UnclosedString'),
                ('blue','Keyword'),
            )
        for color,style in table:
            if hasattr(lexer,style):
                style = getattr(lexer,style)
                try:
                    lexer.setColor(qcolor(color),style)
                except Exception:
                     oops('bad color: %s' % color)
            else: oops('bad style: %s' % style)

    w.setLexer(lexer)

    n = c.config.getInt('qt-scintilla-zoom-in')
    if n not in (None,0): w.zoomIn(n)

    w.setIndentationWidth(4)
    w.setIndentationsUseTabs(False)
    w.setAutoIndent(True)
#@-node:ekr.20081023060109.11:setScintillaConfi
#@+node:ekr.20081023060109.12:setRichTextConfig
def setRichTextConfig (self):

    c = self.c ; w = self.widget

    n = c.config.getInt('qt-rich-text-zoom-in')

    w.setWordWrapMode(QtGui.QTextOption.NoWrap)

    # w.zoomIn(1)
    # w.updateMicroFocus()
    if n not in (None,0):
        # This only works when there is no style sheet.
        # g.trace('zoom-in',n)
        w.zoomIn(n)
        w.updateMicroFocus()
#@-node:ekr.20081023060109.12:setRichTextConfig
#@-node:ekr.20081011035036.10:setBodyConfig
#@-node:ekr.20081023060109.10:Make the body pane a richTextEdit
#@+node:ekr.20081025124450.10:Switching nodes reliably
#@+node:ekr.20081004172422.844:Selecting & editing... (qtTree)
#@+node:ekr.20081025124450.14:beforeSelectHint
def beforeSelectHint (self,p,old_p):

    w = self.treeWidget ; trace = True

    if self.selecting:
        return g.trace('*** Error: already selecting',g.callers(4))

    if self.redrawing:
        if trace: g.trace('already redrawing')
        return

    # Disable onTextChanged.
    self.selecting = True
#@-node:ekr.20081025124450.14:beforeSelectHint
#@+node:ekr.20081025124450.15:afterSelectHint
def afterSelectHint (self,p,old_p):

    self.selecting = False

    self.redraw_after_select()
#@-node:ekr.20081025124450.15:afterSelectHint
#@+node:ekr.20081004172422.846:editLabel
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c

    # g.trace(p.headString(),selectAll)
    w = self.treeWidget
    data = self.vnodeDict.get(p.v)
    if not data: return

    it = data [0][1]

    w.editItem(it)
    if not selectAll:
        editWidget = w.itemWidget(it,0) # A QLineEdit
        s = editWidget.text()
        editWidget.setSelection(len(s),0)

    # A nice hack: just clear the focus request.
    c.requestedFocusWidget = None

    # g.trace('leoQtTree','it',it,p and p.headString())

    # if p and p != self.editPosition():
        # self.endEditLabel()
        # # This redraw *is* required so the c.edit_widget(p) will exist.
        # c.redraw()
        # c.outerUpdate()

    # self.setEditPosition(p) # That is, self._editPosition = p
    # w = c.edit_widget(p)
    # if p and w:
        # self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        # self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        # c.headlineWantsFocus(p) # Make sure the focus sticks.
        # c.k.showStateAndMode(w)
#@-node:ekr.20081004172422.846:editLabel
#@+node:ekr.20081004172422.854:setHeadline
def setHeadline (self,p,s):

    '''Set the actual text of the headline widget.

    This is called from the undo/redo logic to change the text before redrawing.'''

    # w = self.edit_widget(p)
    # if w:
        # w.configure(state='normal')
        # w.delete(0,'end')
        # if s.endswith('\n') or s.endswith('\r'):
            # s = s[:-1]
        # w.insert(0,s)
        # self.revertHeadline = s
        # # g.trace(repr(s),w.getAllText())
    # else:
        # g.trace('-'*20,'oops')
#@-node:ekr.20081004172422.854:setHeadline
#@-node:ekr.20081004172422.844:Selecting & editing... (qtTree)
#@+node:ekr.20081010070648.19:Drawing... (qtTree)
#@+node:ekr.20081011035036.12:allAncestorsExpanded
def allAncestorsExpanded (self,p):

    for p in p.self_and_parents_iter():
        if not p.isExpanded():
            return False
    else:
        return True
#@-node:ekr.20081011035036.12:allAncestorsExpanded
#@+node:ekr.20081021043407.23:full_redraw & helpers
def full_redraw (self,scroll=False,forceDraw=False): # forceDraw not used.

    '''Redraw all visible nodes of the tree'''

    c = self.c ; w = self.treeWidget
    trace = False; verbose = False
    if not w: return
    if self.redrawing:
        g.trace('***** already drawing',g.callers(5))
        return

    self.redrawCount += 1
    if trace and verbose: tstart()

    # Init the data structures.
    self.initData()
    self.nodeDrawCount = 0
    self.redrawing = True
    self.fullDrawing = True # To suppress some traces.
    try:
        w.clear()
        # Draw all top-level nodes and their visible descendants.
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()
    finally:
        if not self.selecting:
            item = self.setCurrentItem()
            if item:
                if 0: # Annoying.
                    w.scrollToItem(item,
                        QtGui.QAbstractItemView.PositionAtCenter)
            elif p and self.redrawCount > 1:
                g.trace('Error: no current item: %s' % (p.headString()))

        # Necessary to get the tree drawn initially.
        w.repaint()

        c.requestRedrawFlag= False
        self.redrawing = False
        self.fullDrawing = False
        if trace:
            if verbose: tstop()
            g.trace('%s: drew %3s nodes' % (
                self.redrawCount,self.nodeDrawCount))

redraw = full_redraw # Compatibility
redraw_now = full_redraw
#@+node:ekr.20081021043407.30:initData
def initData (self):

    self.tnodeDict = {} # keys are tnodes, values are lists of items (p,it)
    self.vnodeDict = {} # keys are vnodes, values are lists of items (p,it)
    self.itemsDict = {} # keys are items, values are positions
    self.parentsDict = {}
#@-node:ekr.20081021043407.30:initData
#@+node:ekr.20081021043407.24:drawNode
def drawNode (self,p,dummy=False):

    w = self.treeWidget ; trace = False
    self.nodeDrawCount += 1

    # Allocate the qt tree item.
    parent = p.parent()
    it = self.parentsDict.get(parent and parent.v,w)

    if trace and not self.fullDrawing:
        g.trace(id(it),parent and parent.headString())

    it = QtGui.QTreeWidgetItem(it)
    it.setFlags(it.flags() | QtCore.Qt.ItemIsEditable)

    # Draw the headline and the icon.
    it.setText(0,p.headString())
    icon = self.getIcon(p)
    if icon: it.setIcon(0,icon)

    if dummy: return it

    # Remember the associatiation of it with p, and vice versa.
    self.itemsDict[it] = p.copy()
    self.parentsDict[p.v] = it 

    # Remember the association of p.v with (p,it)
    aList = self.vnodeDict.get(p.v,[])
    data = p.copy(),it
    aList.append(data)
    self.vnodeDict[p.v] = aList

    # Remember the association of p.v.t with (p,it).
    aList = self.tnodeDict.get(p.v.t,[])
    data = p.copy(),it
    aList.append(data)
    self.tnodeDict[p.v.t] = aList

    return it
#@-node:ekr.20081021043407.24:drawNode
#@+node:ekr.20081021043407.25:drawTree
def drawTree (self,p):

    c = self.c ; w = self.treeWidget

    p = p.copy()

    # g.trace(p.headString())

    # Draw the (visible) parent node.
    it = self.drawNode(p)

    if p.hasChildren():
        if p.isExpanded():
            w.expandItem(it)
            child = p.firstChild()
            while child:
                self.drawTree(child)
                child.moveToNext()
        else:
            if 0:
                # Just draw one dummy child.
                # This doesn't work with the new expansion code.
                self.drawNode(p.firstChild(),dummy=True)
            else:
                # Draw the hidden children.
                child = p.firstChild()
                while child:
                    self.drawNode(child)
                    child.moveToNext()
            w.collapseItem(it)
    else:
        w.collapseItem(it)
#@-node:ekr.20081021043407.25:drawTree
#@+node:ekr.20081027082521.12:setCurrentItem
def setCurrentItem (self):

    c = self.c ; p = c.currentPosition()
    trace = False
    w = self.treeWidget

    if self.expanding:
        if trace: g.trace('already expanding')
        return None
    if self.selecting:
        if trace: g.trace('already selecting')
        return None

    aList = self.vnodeDict.get(p.v,[])
    h = p and p.headString() or '<no p!>'
    if trace: g.trace(h)
    if not p: return False

    for p2,item in aList:
        if p == p2:
            if trace:
                g.trace('found item: %s for: %s' % (
                    id(item),h))

            self.selecting = True
            try:
                w.setCurrentItem(item)
            finally:
                self.selecting = False
            return item
    else:
        return None
#@-node:ekr.20081027082521.12:setCurrentItem
#@-node:ekr.20081021043407.23:full_redraw & helpers
#@+node:ekr.20081010070648.14:getIcon & getIconImage
def getIcon(self,p):

    '''Return the proper icon for position p.'''

    p.v.iconVal = val = p.v.computeIcon()
    return self.getIconImage(val)

def getIconImage(self,val):

    return g.app.gui.getIconImage(
        "box%02d.GIF" % val)

#@-node:ekr.20081010070648.14:getIcon & getIconImage
#@+node:ekr.20081021043407.4:redraw_after_clone
def redraw_after_clone (self):

    self.full_redraw()
#@-node:ekr.20081021043407.4:redraw_after_clone
#@+node:ekr.20081021043407.5:redraw_after_contract
def redraw_after_contract (self):

    self.full_redraw()
#@-node:ekr.20081021043407.5:redraw_after_contract
#@+node:ekr.20081021043407.6:redraw_after_delete
def redraw_after_delete (self):

    self.full_redraw()


#@-node:ekr.20081021043407.6:redraw_after_delete
#@+node:ekr.20081021043407.7:redraw_after_expand & helper
def redraw_after_expand (self):

    # This is reasonable now that we only allocate
    # one dummy node in collapsed trees.
    return self.full_redraw()

    # trace = True ; verbose = False
    # c = self.c ; p = c.currentPosition()
    # w = self.treeWidget

    # if self.redrawing:
        # if trace: g.trace('already drawing',p.headString())
        # return
    # self.redrawCount += 1
    # if trace: g.trace(self.redrawCount,p.headString())
    # it = self.parentsDict.get(p.v)
    # if not it:
        # g.trace('can not happen: no item for %s' % p.headString())
        # return self.full_redraw()
    # self.nodeDrawCount = 0
    # self.redrawing = True
    # self.expanding = True
    # try:
        # w.expandItem(it)
        # # Delete all the children from the tree.
        # items = it.takeChildren()
        # if trace and verbose:
            # g.trace(id(it),len(items),p.headString())
        # # Delete all descendant entries from dictionaries.
        # for child in p.children_iter():
            # for z in child.self_and_subtree_iter():
                # self.removeFromDicts(z)
        # # Redraw all descendants.
        # for child in p.children_iter():
            # self.drawTree(child)
    # finally:
        # w.setCurrentItem(it)
        # self.redrawing = False
        # self.expanding = False
        # c.requestRedrawFlag= False
        # if trace:
            # g.trace('drew %3s nodes' %self.nodeDrawCount)
#@+node:ekr.20081021043407.28:removeFromDicts
def removeFromDicts (self,p):

    # Important: items do not necessarily exist.

    # Remove item from parentsDict.
    it = self.parentsDict.get(p.v)
    if it: del self.parentsDict[p.v]

    # Remove position from itemsDict.
    p2 = self.itemsDict.get(it)
    if p2 == p: del self.itemsDict[it]

    # Remove items from vnodeDict
    aList = self.vnodeDict.get(p.v,[])
    # aList = [z for z in aList if z[1] != it] # Wrong
    aList = [z for z in aList if z[0] != p]
    self.vnodeDict[p.v] = aList

    # Remove items from tnodeDict
    aList = self.tnodeDict.get(p.v.t,[])
    # aList = [z for z in aList if z[1] != it] # Wrong
    aList = [z for z in aList if z[0] != p]
    self.tnodeDict[p.v.t] = aList
#@-node:ekr.20081021043407.28:removeFromDicts
#@-node:ekr.20081021043407.7:redraw_after_expand & helper
#@+node:ekr.20081021043407.3:redraw_after_icons_changed
def redraw_after_icons_changed (self,all=False):

    g.trace('should not be called',g.callers(4))

    c = self.c ; p = c.currentPosition()

    if all:
        self.full_redraw()
    else:
        self.updateIcon(p)


#@-node:ekr.20081021043407.3:redraw_after_icons_changed
#@+node:ekr.20081021043407.8:redraw_after_insert
def redraw_after_insert (self):

    self.full_redraw()
#@-node:ekr.20081021043407.8:redraw_after_insert
#@+node:ekr.20081021043407.9:redraw_after_move_down
def redraw_after_move_down (self):

    self.full_redraw()
#@nonl
#@-node:ekr.20081021043407.9:redraw_after_move_down
#@+node:ekr.20081021043407.10:redraw_after_move_left
def redraw_after_move_left (self):

    self.full_redraw()
#@nonl
#@-node:ekr.20081021043407.10:redraw_after_move_left
#@+node:ekr.20081021043407.11:redraw_after_move_right
def redraw_after_move_right (self):

    if 0: # now done in c.moveOutlineRight.
        c = self.c ; p = c.currentPosition()
        parent = p.parent()
        if parent: parent.expand()


    # g.trace('parent',c.currentPosition().parent() or "non")

    self.full_redraw()
#@-node:ekr.20081021043407.11:redraw_after_move_right
#@+node:ekr.20081021043407.12:redraw_after_move_up
def redraw_after_move_up (self):

    self.full_redraw()
#@-node:ekr.20081021043407.12:redraw_after_move_up
#@+node:ekr.20081021043407.13:redraw_after_select
def redraw_after_select (self):

    '''Redraw the screen after selecting a node.'''

    w = self.treeWidget ; trace = False
    c = self.c ; p = c.currentPosition()

    if not p:
        return g.trace('Error: no p')
    if self.selecting:
        if trace: g.trace('already selecting')
        return
    if self.redrawing:
        return g.trace('Error: already redrawing')

    if trace: g.trace(p.headString(),g.callers(4))

    # setCurrentItem sets .selecting ivar
    self.setCurrentItem()
#@-node:ekr.20081021043407.13:redraw_after_select
#@+node:ekr.20081011035036.11:updateIcon
def updateIcon (self,p):

    '''Update p's icon.'''

    if not p: return

    val = p.v.computeIcon()
    if p.v.iconVal == val: return

    icon = self.getIconImage(val)
    aList = self.tnodeDict.get(p.v.t,[])
    for p,it in aList:
        # g.trace(id(it),p.headString())
        it.setIcon(0,icon)
#@-node:ekr.20081011035036.11:updateIcon
#@-node:ekr.20081010070648.19:Drawing... (qtTree)
#@+node:ekr.20081011035036.1:onTextChanged
def onTextChanged (self):

    '''Update Leo after the body has been changed.

    self.selecting is guaranteed to be True during
    the entire selection process.'''

    c = self.c ; p = c.currentPosition()
    tree = c.frame.tree ; w = self
    trace = True ; verbose = False

    if tree.selecting:
        if trace and verbose: g.trace('selecting')
        return
    if tree.redrawing:
        if trace and verbose: g.trace('redrawing')
        return
    if not p:
        return g.trace('*** no p')

    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText() # Converts to unicode.

    # Get the previous values from the tnode.
    oldText = g.toUnicode(p.v.t._bodyString,"utf-8")
    if oldText == newText:
        if trace: g.trace('*** unexpected non-change',color="red")
        return

    if trace and verbose: g.trace(p.headString(),len(oldText),len(newText))

    oldIns  = p.v.t.insertSpot
    i,j = p.v.t.selectionStart,p.v.t.selectionLength
    oldSel  = (i,j-i)
    oldYview = None
    undoType = 'changed event'
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,
        oldSel=oldSel,newSel=newSel,oldYview=oldYview)

    # Update the tnode.
    p.v.setBodyString(newText)
    p.v.t.insertSpot = newInsert
    i,j = newSel
    if i > j: i,j = j,i
    p.v.t.selectionStart,p.v.t.selectionLength = (i,j-i)

    # No need to redraw the screen.
    if not self.useScintilla:
        c.recolor()
    if not c.changed and c.frame.initComplete:
        c.setChanged(True)
    self.updateEditors()
    c.frame.tree.updateIcon(p)
    c.outerUpdate()
#@-node:ekr.20081011035036.1:onTextChanged
#@-node:ekr.20081025124450.10:Switching nodes reliably
#@+node:ekr.20081026084658.1:Update icons properly...
#@+node:ekr.20081021043407.3:redraw_after_icons_changed
def redraw_after_icons_changed (self,all=False):

    g.trace('should not be called',g.callers(4))

    c = self.c ; p = c.currentPosition()

    if all:
        self.full_redraw()
    else:
        self.updateIcon(p)


#@-node:ekr.20081021043407.3:redraw_after_icons_changed
#@+node:ekr.20081011035036.11:updateIcon
def updateIcon (self,p):

    '''Update p's icon.'''

    if not p: return

    val = p.v.computeIcon()
    if p.v.iconVal == val: return

    icon = self.getIconImage(val)
    aList = self.tnodeDict.get(p.v.t,[])
    for p,it in aList:
        # g.trace(id(it),p.headString())
        it.setIcon(0,icon)
#@-node:ekr.20081011035036.11:updateIcon
#@+node:ekr.20081010070648.14:getIcon & getIconImage
def getIcon(self,p):

    '''Return the proper icon for position p.'''

    p.v.iconVal = val = p.v.computeIcon()
    return self.getIconImage(val)

def getIconImage(self,val):

    return g.app.gui.getIconImage(
        "box%02d.GIF" % val)

#@-node:ekr.20081010070648.14:getIcon & getIconImage
#@-node:ekr.20081026084658.1:Update icons properly...
#@+node:ekr.20081027082521.11:Redraw crashes & problems
#@clone 2
#@+node:ekr.20081021043407.23:full_redraw & helpers
def full_redraw (self,scroll=False,forceDraw=False): # forceDraw not used.

    '''Redraw all visible nodes of the tree'''

    c = self.c ; w = self.treeWidget
    trace = False; verbose = False
    if not w: return
    if self.redrawing:
        g.trace('***** already drawing',g.callers(5))
        return

    self.redrawCount += 1
    if trace and verbose: tstart()

    # Init the data structures.
    self.initData()
    self.nodeDrawCount = 0
    self.redrawing = True
    self.fullDrawing = True # To suppress some traces.
    try:
        w.clear()
        # Draw all top-level nodes and their visible descendants.
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()
    finally:
        if not self.selecting:
            item = self.setCurrentItem()
            if item:
                if 0: # Annoying.
                    w.scrollToItem(item,
                        QtGui.QAbstractItemView.PositionAtCenter)
            elif p and self.redrawCount > 1:
                g.trace('Error: no current item: %s' % (p.headString()))

        # Necessary to get the tree drawn initially.
        w.repaint()

        c.requestRedrawFlag= False
        self.redrawing = False
        self.fullDrawing = False
        if trace:
            if verbose: tstop()
            g.trace('%s: drew %3s nodes' % (
                self.redrawCount,self.nodeDrawCount))

redraw = full_redraw # Compatibility
redraw_now = full_redraw
#@+node:ekr.20081021043407.30:initData
def initData (self):

    self.tnodeDict = {} # keys are tnodes, values are lists of items (p,it)
    self.vnodeDict = {} # keys are vnodes, values are lists of items (p,it)
    self.itemsDict = {} # keys are items, values are positions
    self.parentsDict = {}
#@-node:ekr.20081021043407.30:initData
#@+node:ekr.20081021043407.24:drawNode
def drawNode (self,p,dummy=False):

    w = self.treeWidget ; trace = False
    self.nodeDrawCount += 1

    # Allocate the qt tree item.
    parent = p.parent()
    it = self.parentsDict.get(parent and parent.v,w)

    if trace and not self.fullDrawing:
        g.trace(id(it),parent and parent.headString())

    it = QtGui.QTreeWidgetItem(it)
    it.setFlags(it.flags() | QtCore.Qt.ItemIsEditable)

    # Draw the headline and the icon.
    it.setText(0,p.headString())
    icon = self.getIcon(p)
    if icon: it.setIcon(0,icon)

    if dummy: return it

    # Remember the associatiation of it with p, and vice versa.
    self.itemsDict[it] = p.copy()
    self.parentsDict[p.v] = it 

    # Remember the association of p.v with (p,it)
    aList = self.vnodeDict.get(p.v,[])
    data = p.copy(),it
    aList.append(data)
    self.vnodeDict[p.v] = aList

    # Remember the association of p.v.t with (p,it).
    aList = self.tnodeDict.get(p.v.t,[])
    data = p.copy(),it
    aList.append(data)
    self.tnodeDict[p.v.t] = aList

    return it
#@-node:ekr.20081021043407.24:drawNode
#@+node:ekr.20081021043407.25:drawTree
def drawTree (self,p):

    c = self.c ; w = self.treeWidget

    p = p.copy()

    # g.trace(p.headString())

    # Draw the (visible) parent node.
    it = self.drawNode(p)

    if p.hasChildren():
        if p.isExpanded():
            w.expandItem(it)
            child = p.firstChild()
            while child:
                self.drawTree(child)
                child.moveToNext()
        else:
            if 0:
                # Just draw one dummy child.
                # This doesn't work with the new expansion code.
                self.drawNode(p.firstChild(),dummy=True)
            else:
                # Draw the hidden children.
                child = p.firstChild()
                while child:
                    self.drawNode(child)
                    child.moveToNext()
            w.collapseItem(it)
    else:
        w.collapseItem(it)
#@-node:ekr.20081021043407.25:drawTree
#@+node:ekr.20081027082521.12:setCurrentItem
def setCurrentItem (self):

    c = self.c ; p = c.currentPosition()
    trace = False
    w = self.treeWidget

    if self.expanding:
        if trace: g.trace('already expanding')
        return None
    if self.selecting:
        if trace: g.trace('already selecting')
        return None

    aList = self.vnodeDict.get(p.v,[])
    h = p and p.headString() or '<no p!>'
    if trace: g.trace(h)
    if not p: return False

    for p2,item in aList:
        if p == p2:
            if trace:
                g.trace('found item: %s for: %s' % (
                    id(item),h))

            self.selecting = True
            try:
                w.setCurrentItem(item)
            finally:
                self.selecting = False
            return item
    else:
        return None
#@-node:ekr.20081027082521.12:setCurrentItem
#@-node:ekr.20081021043407.23:full_redraw & helpers
#@+node:ekr.20081025124450.15:afterSelectHint
def afterSelectHint (self,p,old_p):

    self.selecting = False

    self.redraw_after_select()
#@-node:ekr.20081025124450.15:afterSelectHint
#@+node:ekr.20081027124640.10:sig_itemCollapsed
def sig_itemCollapsed (self,item):

    c = self.c ; p = c.currentPosition() ; w = self.treeWidget
    trace = False ; verbose = False

    # Ignore events generated by redraws.
    if self.redrawing:
        if trace and verbose: g.trace('already redrawing',g.callers(4))
        return
    if self.expanding:
        if trace and verbose: g.trace('already expanding',g.callers(4))
        return
    if self.selecting:
        if trace and verbose: g.trace('already selecting',g.callers(4))
        return

    if trace: g.trace(p.headString() or "<no p>",g.callers(4))

    p2 = self.itemsDict.get(item)
    if p2:
        p2.contract()
        c.setCurrentPosition(p2)
        item = self.setCurrentItem()
        if 0: # Annoying.
            w.scrollToItem(item,
                QtGui.QAbstractItemView.PositionAtCenter)
    else:
        g.trace('Error no p2')
#@-node:ekr.20081027124640.10:sig_itemCollapsed
#@+node:ekr.20081021043407.26:sig_itemExpanded
def sig_itemExpanded (self,item):

    '''Handle and tree-expansion event.'''

    # The difficult case is when the user clicks the expansion box.

    c = self.c ; p = c.currentPosition() ; w = self.treeWidget
    trace = False ; verbose = False

    # Ignore events generated by redraws.
    if self.redrawing:
        if trace and verbose: g.trace('already redrawing',g.callers(4))
        return
    if self.expanding:
        if trace and verbose: g.trace('already expanding',g.callers(4))
        return
    if self.selecting:
        if trace and verbose: g.trace('already selecting',g.callers(4))
        return

    if trace: g.trace(p.headString() or "<no p>",g.callers(4))

    self.expanding = True
    try:
        redraw = False
        p2 = self.itemsDict.get(item)
        if p2:
            if trace: g.trace(p2)
            if not p2.isExpanded():
                p2.expand()
            c.setCurrentPosition(p2)
            self.full_redraw()
            redraw = True
        else:
            g.trace('Error no p2')

    finally:
        self.expanding = False
        if redraw:
            item = self.setCurrentItem()
            if item:
                w.scrollToItem(item,
                    QtGui.QAbstractItemView.PositionAtCenter)
#@-node:ekr.20081021043407.26:sig_itemExpanded
#@+node:ekr.20081021043407.13:redraw_after_select
def redraw_after_select (self):

    '''Redraw the screen after selecting a node.'''

    w = self.treeWidget ; trace = False
    c = self.c ; p = c.currentPosition()

    if not p:
        return g.trace('Error: no p')
    if self.selecting:
        if trace: g.trace('already selecting')
        return
    if self.redrawing:
        return g.trace('Error: already redrawing')

    if trace: g.trace(p.headString(),g.callers(4))

    # setCurrentItem sets .selecting ivar
    self.setCurrentItem()
#@-node:ekr.20081021043407.13:redraw_after_select
#@+node:ekr.20081021043407.11:redraw_after_move_right
def redraw_after_move_right (self):

    if 0: # now done in c.moveOutlineRight.
        c = self.c ; p = c.currentPosition()
        parent = p.parent()
        if parent: parent.expand()


    # g.trace('parent',c.currentPosition().parent() or "non")

    self.full_redraw()
#@-node:ekr.20081021043407.11:redraw_after_move_right
#@+node:ekr.20081027082521.12:setCurrentItem
def setCurrentItem (self):

    c = self.c ; p = c.currentPosition()
    trace = False
    w = self.treeWidget

    if self.expanding:
        if trace: g.trace('already expanding')
        return None
    if self.selecting:
        if trace: g.trace('already selecting')
        return None

    aList = self.vnodeDict.get(p.v,[])
    h = p and p.headString() or '<no p!>'
    if trace: g.trace(h)
    if not p: return False

    for p2,item in aList:
        if p == p2:
            if trace:
                g.trace('found item: %s for: %s' % (
                    id(item),h))

            self.selecting = True
            try:
                w.setCurrentItem(item)
            finally:
                self.selecting = False
            return item
    else:
        return None
#@-node:ekr.20081027082521.12:setCurrentItem
#@-node:ekr.20081027082521.11:Redraw crashes & problems
#@-node:ekr.20081014095718.13:Recent projects...
#@+node:ekr.20081013210935.1:Unit tests
@killcolor

*** Skipped leoColor
#@nonl
#@+node:ekr.20081013210935.2:Pass
#@+node:ekr.20081013210935.3:Doctests
*** Doctests

found  2 doctests for leoGlobals
found  1 doctests for leoTest
...
----------------------------------------------------------------------
Ran 3 tests in 0.094s

OK
#@-node:ekr.20081013210935.3:Doctests
#@+node:ekr.20081013210935.4:Unit tests for .leo files.
*** Unit tests for .leo files.

creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
........
----------------------------------------------------------------------
Ran 8 tests in 26.156s

OK
#@nonl
#@-node:ekr.20081013210935.4:Unit tests for .leo files.
#@+node:ekr.20081013210935.5:Check base classes
*** Check base classes

creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
........
----------------------------------------------------------------------
Ran 8 tests in 0.046s

OK
#@nonl
#@-node:ekr.20081013210935.5:Check base classes
#@+node:ekr.20081013210935.6:General
*** General

creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
...
End of general unit tests
.
----------------------------------------------------------------------
Ran 4 tests in 3.453s

OK
#@-node:ekr.20081013210935.6:General
#@+node:ekr.20081013210935.7:leoBridge
*** leoBridge

creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
#@nonl
#@-node:ekr.20081013210935.7:leoBridge
#@+node:ekr.20081013210935.8:leoConfig
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
...
End of leoConfig tests
.
----------------------------------------------------------------------
Ran 4 tests in 0.015s

OK
#@nonl
#@-node:ekr.20081013210935.8:leoConfig
#@+node:ekr.20081013210935.9:leoDialog
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
#@nonl
#@-node:ekr.20081013210935.9:leoDialog
#@+node:ekr.20081013210935.26:leoGlobals (no tnodeList)
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
----- read error. line: 1, file: ../test/unittest/at-path-test1.py
no tnodeList for <vnode 25482160:'@file ../test/unittest/at-path-test1.py'>
findChild4: no tnodeList for  <vnode 25482160:'@file ../test/unittest/at-path-test1.py'> openWithFileName,open,getLeoFile,readAll,read,readO
penFile,scanText4,readStartNode
----- read error. line: 1, file: at-path-test2.py
no tnodeList for <vnode 25482480:'@file at-path-test2.py'>
findChild4: no tnodeList for  <vnode 25482480:'@file at-path-test2.py'> openWithFileName,open,getLeoFile,readAll,read,readOpenFile,scanText4
,readStartNode
----- read error. line: 1, file: at-path-test3.py
no tnodeList for <vnode 25482896:'@file at-path-test3.py'>
findChild4: no tnodeList for  <vnode 25482896:'@file at-path-test3.py'> openWithFileName,open,getLeoFile,readAll,read,readOpenFile,scanText4
,readStartNode
..test of at.printError: La Pea
.................................................
----------------------------------------------------------------------
Ran 51 tests in 0.359s

OK
#@nonl
#@-node:ekr.20081013210935.26:leoGlobals (no tnodeList)
#@+node:ekr.20081013210935.27:leoGui
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
....
----------------------------------------------------------------------
Ran 4 tests in 0.016s

OK
#@nonl
#@-node:ekr.20081013210935.27:leoGui
#@+node:ekr.20081013210935.28:leoKeys
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
.....
----------------------------------------------------------------------
Ran 5 tests in 0.031s

OK
#@nonl
#@-node:ekr.20081013210935.28:leoKeys
#@+node:ekr.20081013210935.29:leoPlugins
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
#@nonl
#@-node:ekr.20081013210935.29:leoPlugins
#@+node:ekr.20081013210935.30:leoTangle
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
..
----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK
#@nonl
#@-node:ekr.20081013210935.30:leoTangle
#@+node:ekr.20081013210935.31:leoTest
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
.
----------------------------------------------------------------------
Ran 1 test in 0.015s

OK
#@nonl
#@-node:ekr.20081013210935.31:leoTest
#@-node:ekr.20081013210935.2:Pass
#@+node:ekr.20081013210935.32:Fail
#@+node:ekr.20081013210935.10:plugins
*** Unit tests for plugins 

creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
@suite run all plugin test routines
unexpected exception in g.importFromPath(dyna_menu)
Traceback (most recent call last):

Traceback (most recent call last):

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\plugins\dyna_menu.py", line 72, in <module>
    Tk   = g.importExtension('Tkinter',pluginName=__name__,verbose=True)

  File "C:\leo.repo\qt-plugin\leo\plugins\dyna_menu.py", line 72, in <module>
    Tk   = g.importExtension('Tkinter',pluginName=__name__,verbose=True)

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5300, in importExtension
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5300, in importExtension
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

AttributeError: 'NoneType' object has no attribute 'importModule'

AttributeError: 'NoneType' object has no attribute 'importModule'

unexpected exception in g.importFromPath(dynacommon)
Traceback (most recent call last):

Traceback (most recent call last):

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\plugins\dynacommon.py", line 1164, in <module>
    pypath = g.os_path_split(sys.executable)[0]

  File "C:\leo.repo\qt-plugin\leo\plugins\dynacommon.py", line 1164, in <module>
    pypath = g.os_path_split(sys.executable)[0]

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 3398, in os_path_split
    path = g.toUnicodeFileEncoding(path,encoding)

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 3398, in os_path_split
    path = g.toUnicodeFileEncoding(path,encoding)

AttributeError: 'NoneType' object has no attribute 'toUnicodeFileEncoding'

AttributeError: 'NoneType' object has no attribute 'toUnicodeFileEncoding'

unexpected exception in g.importFromPath(newButtons)
Traceback (most recent call last):

Traceback (most recent call last):

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\plugins\newButtons.py", line 385

  File "C:\leo.repo\qt-plugin\leo\plugins\newButtons.py", line 385

    self.getResult = lambda None:None

    self.getResult = lambda None:None

SyntaxError: assignment to None

SyntaxError: assignment to None

unexpected exception in g.importFromPath(override_commands)
Traceback (most recent call last):

Traceback (most recent call last):

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\plugins\override_commands.py", line 22, in <module>
    if not g.app.unitTesting: # Not for unit testing: overrides core methods.

  File "C:\leo.repo\qt-plugin\leo\plugins\override_commands.py", line 22, in <module>
    if not g.app.unitTesting: # Not for unit testing: overrides core methods.

AttributeError: 'NoneType' object has no attribute 'unitTesting'

AttributeError: 'NoneType' object has no attribute 'unitTesting'

unexpected exception in g.importFromPath(rst)
Traceback (most recent call last):

Traceback (most recent call last):

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\plugins\rst.py", line 224, in <module>
    g.plugin_signon(__name__)

  File "C:\leo.repo\qt-plugin\leo\plugins\rst.py", line 224, in <module>
    g.plugin_signon(__name__)

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 2909, in plugin_signon
    m = g.Bunch()

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 2909, in plugin_signon
    m = g.Bunch()

AttributeError: 'NoneType' object has no attribute 'Bunch'

AttributeError: 'NoneType' object has no attribute 'Bunch'

unexpected exception in g.importFromPath(rst2)
Traceback (most recent call last):

Traceback (most recent call last):

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\plugins\rst2.py", line 1030, in <module>
    g.plugin_signon(__name__)

  File "C:\leo.repo\qt-plugin\leo\plugins\rst2.py", line 1030, in <module>
    g.plugin_signon(__name__)

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 2909, in plugin_signon
    m = g.Bunch()

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 2909, in plugin_signon
    m = g.Bunch()

AttributeError: 'NoneType' object has no attribute 'Bunch'

AttributeError: 'NoneType' object has no attribute 'Bunch'

unexpected exception in g.importFromPath(usetemacs)
Traceback (most recent call last):

Traceback (most recent call last):

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 5457, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\leo.repo\qt-plugin\leo\plugins\usetemacs.py", line 53, in <module>
    g.es( "temacs not loadable. Aborting load of usetemacs because of: " + str( x ))

  File "C:\leo.repo\qt-plugin\leo\plugins\usetemacs.py", line 53, in <module>
    g.es( "temacs not loadable. Aborting load of usetemacs because of: " + str( x ))

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 2958, in es
    log = app.log

  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 2958, in es
    log = app.log

AttributeError: 'NoneType' object has no attribute 'log'

AttributeError: 'NoneType' object has no attribute 'log'

makeTestSuite: Exception creating test cases for @suite plugins tests
Traceback (most recent call last):

Traceback (most recent call last):

  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 215, in makeTestSuite
    exec(script + '\n',{'c':c,'g':g,'p':p})

  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 215, in makeTestSuite
    exec(script + '\n',{'c':c,'g':g,'p':p})

  File "<string>", line 106

  File "<string>", line 106

    self.openFlag,'opening','open')

    self.openFlag,'opening','open')

       ^

       ^

SyntaxError: invalid syntax

SyntaxError: invalid syntax

@suite test syntax of all plugins

All plugins tests complete.
..........................................................................................................................F...
End of plugins unit tests
.
======================================================================
FAIL: @test openURL

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 9, in <module>
    assert url == 'http://webpages.charter.net/edreamleo/front.html','Got:%s' % repr(url)
AssertionError: Got:None

----------------------------------------------------------------------
Ran 127 tests in 9.578s

FAILED (failures=1)


All plugins tests complete.
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
#@nonl
#@-node:ekr.20081013210935.10:plugins
#@+node:ekr.20081013210935.11:leoAtFile (gnx's don't match)
*** leoAtFile

creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
......
 --------------------
result...
 18 u'#@+leo-ver=4-thin\n'
 38 u'#@+node:ekr.20081013210925.115:#@thin\n'
  7 u'Line 1\n'
  1 u'\n'
  8 u'#@@last\n'
  7 u'#@nonl\n'
 38 u'#@-node:ekr.20081013210925.115:#@thin\n'
  7 u'#@-leo\n'
 23 u'last line 1: no newline'
--------------------
expected...
 18 u'#@+leo-ver=4-thin\n'
 37 u'#@+node:ekr.20040707141957.13:#@thin\n'
  7 u'Line 1\n'
  1 u'\n'
  8 u'#@@last\n'
  7 u'#@nonl\n'
 37 u'#@-node:ekr.20040707141957.13:#@thin\n'
  7 u'#@-leo\n'
 23 u'last line 1: no newline'
--------------------
F.....wrote:     C:\leo.repo\qt-plugin\leo\test\xyzzy2
.unchanged: C:\leo.repo\qt-plugin\leo\test\xyzzy2
.created:   C:\leo.repo\qt-plugin\leo\test\xyzzy2
...
End of leoAtFile tests
.
======================================================================
FAIL: @test @thin

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 5, in <module>
    leoTest.runAtFileTest(c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 909, in runAtFileTest
    assert(result == expected)
AssertionError

----------------------------------------------------------------------
Ran 18 tests in 0.141s

FAILED (failures=1)
#@-node:ekr.20081013210935.11:leoAtFile (gnx's don't match)
#@+node:ekr.20081013210935.12:leoCommands
*** LeoCommands
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
.................................F.\End of leoColor tests
.
======================================================================
FAIL: @test scanColorDirectives

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 8, in <module>
    assert language == 'python','got:%s' % language
AssertionError: got:None

----------------------------------------------------------------------
Ran 36 tests in 0.188s

FAILED (failures=1)
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
.......the current node is not a clone
....FFFFFFFFFFFFFF........
End of leoCommands tests
.
======================================================================
FAIL: @test noTrailingNewline (pass)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    leoTest.singleParagraphTest(c,p,2,24)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1474, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1483, in runTest
    self.checkText()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1362, in checkText
    + "\n  Actual text: " + repr(newLines[i])
AssertionError: Mismatch on line 0.
Expected text: u'This line is over forty characters long,\n'
  Actual text: u'This line is over forty characters long, at least it seems to be.'

======================================================================
FAIL: @test trailingNewline (pass)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 8, in <module>
    leoTest.singleParagraphTest(c,p,3,0)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1474, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1483, in runTest
    self.checkText()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1362, in checkText
    + "\n  Actual text: " + repr(newLines[i])
AssertionError: Mismatch on line 0.
Expected text: u'This line is over forty characters long,\n'
  Actual text: u'This line is over forty characters long, at least it seems to be.\n'

======================================================================
FAIL: @test mixedLineLengths

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    leoTest.singleParagraphTest(c,p,4,10)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1474, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1483, in runTest
    self.checkText()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1362, in checkText
    + "\n  Actual text: " + repr(newLines[i])
AssertionError: Mismatch on line 0.
Expected text: u'This line is over forty characters long,\n'
  Actual text: u'This line is over forty characters long, at least it seems to be.\n'

======================================================================
FAIL: @test mixedLinesWithLeadingWS

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    leoTest.singleParagraphTest(c,p,4,12)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1474, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1483, in runTest
    self.checkText()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1362, in checkText
    + "\n  Actual text: " + repr(newLines[i])
AssertionError: Mismatch on line 0.
Expected text: u'This line is over forty characters long,\n'
  Actual text: u'This line is over forty characters long, at least it seems to be.\n'

======================================================================
FAIL: @test noChangeRequired

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    leoTest.singleParagraphTest(c,p,1,28)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1474, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1484, in runTest
    self.checkPosition(self.finalRow,self.finalCol)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1345, in checkPosition
    assert expCol == col, "Got column %d.  Expected %d" % (col,expCol)
AssertionError: Got column 0.  Expected 28

======================================================================
FAIL: @test honorLeadingWS

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    leoTest.singleParagraphTest(c,p,5,16)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1474, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1483, in runTest
    self.checkText()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1362, in checkText
    + "\n  Actual text: " + repr(newLines[i])
AssertionError: Mismatch on line 0.
Expected text: u'   This line is over forty characters\n'
  Actual text: u'   This line is over forty characters long, at least it seems to be.\n'

======================================================================
FAIL: @test honorLeadingWSVar1

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    leoTest.singleParagraphTest(c,p,5,16)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1474, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1483, in runTest
    self.checkText()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1362, in checkText
    + "\n  Actual text: " + repr(newLines[i])
AssertionError: Mismatch on line 0.
Expected text: u'   This line is over forty characters\n'
  Actual text: u'   This line is over forty characters long, at least it seems to be.\n'

======================================================================
FAIL: @test simpleHangingIndent

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    leoTest.singleParagraphTest(c,p,5,8)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1474, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1483, in runTest
    self.checkText()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1362, in checkText
    + "\n  Actual text: " + repr(newLines[i])
AssertionError: Mismatch on line 0.
Expected text: u'Honor this line that has a hanging\n'
  Actual text: u'Honor this line that has a hanging indentation, please.  Hanging\n'

======================================================================
FAIL: @test testSimpleHangingIndentVar1

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    leoTest.singleParagraphTest(c,p,5,8)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1474, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1483, in runTest
    self.checkText()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1362, in checkText
    + "\n  Actual text: " + repr(newLines[i])
AssertionError: Mismatch on line 0.
Expected text: u'Honor this line that has a hanging\n'
  Actual text: u'Honor this line that has\n'

======================================================================
FAIL: @test simpleHangingIndentVar2

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    leoTest.singleParagraphTest(c,p,5,8)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1474, in __init__
    reformatParagraphTest.__init__(self,c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1483, in runTest
    self.checkText()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1362, in checkText
    + "\n  Actual text: " + repr(newLines[i])
AssertionError: Mismatch on line 0.
Expected text: u'Honor this line that has a hanging\n'
  Actual text: u'Honor this line that \n'

======================================================================
FAIL: @test multiParagraphTest

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    leoTest.multiParagraphTest(c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1496, in runTest
    self.checkPosition(13,0)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1347, in checkPosition
    assert expRow == row, "Got row %d.  Expected %d" % (row,expRow)
AssertionError: Got row 1.  Expected 13

======================================================================
FAIL: @test multiParagraphWithListTest

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 8, in <module>
    leoTest.multiParagraphWithListTest(c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1518, in runTest
    self.checkPosition(4,0)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1347, in checkPosition
    assert expRow == row, "Got row %d.  Expected %d" % (row,expRow)
AssertionError: Got row 1.  Expected 4

======================================================================
FAIL: @test leadingWSOnEmptyLinesTest

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 18, in <module>
    leoTest.leadingWSOnEmptyLinesTest(c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1544, in runTest
    self.checkPosition(4,0)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1347, in checkPosition
    assert expRow == row, "Got row %d.  Expected %d" % (row,expRow)
AssertionError: Got row 1.  Expected 4

======================================================================
FAIL: @test directiveBreaksParagraphTest

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 5, in <module>
    leoTest.directiveBreaksParagraphTest(c,p)
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1329, in __init__
    self.go()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1336, in go
    self.runTest()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1570, in runTest
    self.checkPosition(13,0) # at next paragraph
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1347, in checkPosition
    assert expRow == row, "Got row %d.  Expected %d" % (row,expRow)
AssertionError: Got row 1.  Expected 13

----------------------------------------------------------------------
Ran 34 tests in 0.313s

FAILED (failures=14)
#@nonl
#@-node:ekr.20081013210935.12:leoCommands
#@+node:ekr.20081013210935.13:leoEditCommands
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
EFFFEEFFEE...........................................................................................FF............F..EF.....F....FFFFFFFFFF
FFTraceback (most recent call last):

Traceback (most recent call last):

  File "C:\leo.repo\qt-plugin\leo\core\leoKeys.py", line 4710, in showStateColors
    w.configure(bg=bg,fg=fg)

  File "C:\leo.repo\qt-plugin\leo\core\leoKeys.py", line 4710, in showStateColors
    w.configure(bg=bg,fg=fg)

AttributeError: stringTextWidget instance has no attribute 'configure'

AttributeError: stringTextWidget instance has no attribute 'configure'

..FFF.
End of leoEditCommands tests.
.
======================================================================
ERROR: @test goto_countlines n = 3

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 5, in <module>
    target = g.findNodeInTree(c,root,h)
  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 4248, in findNodeInTree
    for p in p.subtree_iter():
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1916, in subtree_iter
    return self.subtree_iter_class(self,copy,includeSelf=False)
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1880, in __init__
    elif p.hasChildren():
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1256, in hasChildren
    return len(p.v.t.children) > 0
AttributeError: 'NoneType' object has no attribute 't'

======================================================================
ERROR: @test goto_findGnx

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 5, in <module>
    target = g.findNodeInTree(c,root,h)
  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 4248, in findNodeInTree
    for p in p.subtree_iter():
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1916, in subtree_iter
    return self.subtree_iter_class(self,copy,includeSelf=False)
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1880, in __init__
    elif p.hasChildren():
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1256, in hasChildren
    return len(p.v.t.children) > 0
AttributeError: 'NoneType' object has no attribute 't'

======================================================================
ERROR: @test goto_findVnode

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 5, in <module>
    target = g.findNodeInTree(c,root,h)
  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 4248, in findNodeInTree
    for p in p.subtree_iter():
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1916, in subtree_iter
    return self.subtree_iter_class(self,copy,includeSelf=False)
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1880, in __init__
    elif p.hasChildren():
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1256, in hasChildren
    return len(p.v.t.children) > 0
AttributeError: 'NoneType' object has no attribute 't'

======================================================================
ERROR: @test goto_findRoot (root in ancestors)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 5, in <module>
    target = g.findNodeInTree(c,root,h)
  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 4248, in findNodeInTree
    for p in p.subtree_iter():
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1916, in subtree_iter
    return self.subtree_iter_class(self,copy,includeSelf=False)
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1880, in __init__
    elif p.hasChildren():
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1256, in hasChildren
    return len(p.v.t.children) > 0
AttributeError: 'NoneType' object has no attribute 't'

======================================================================
ERROR: @test goto_findRoot (root not in ancestors)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 6, in <module>
    clones = g.findNodeInTree(c,root,'goto-line-number tests: clones')
  File "C:\leo.repo\qt-plugin\leo\core\leoGlobals.py", line 4248, in findNodeInTree
    for p in p.subtree_iter():
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1916, in subtree_iter
    return self.subtree_iter_class(self,copy,includeSelf=False)
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1880, in __init__
    elif p.hasChildren():
  File "C:\leo.repo\qt-plugin\leo\core\leoNodes.py", line 1256, in hasChildren
    return len(p.v.t.children) > 0
AttributeError: 'NoneType' object has no attribute 't'

======================================================================
ERROR: @test findWordInLine

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 14, in <module>
    assert i == 2, 'expected 2, got' % (i)
TypeError: not all arguments converted during string formatting

======================================================================
FAIL: @test goto_countlines n = 20

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 5, in <module>
    assert root
AssertionError

======================================================================
FAIL: @test goto_setup n = 3

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 5, in <module>
    assert root1
AssertionError

======================================================================
FAIL: @test goto_setup with scriptData

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 5, in <module>
    assert root1
AssertionError

======================================================================
FAIL: @test goto_setup n = 3 (@shadow)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 5, in <module>
    assert root1
AssertionError

======================================================================
FAIL: @test goto_setup n = 3 (@nosent)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 5, in <module>
    assert root1
AssertionError

======================================================================
FAIL: @test selfInsertCommand-2 (replacing tabs)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 13, in <module>
    assert result.endswith('\n    abcdef'),'last line:%s' % repr(result.split('\n')[-1])
AssertionError: last line:u''

======================================================================
FAIL: @test set-fill-prefix

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 9, in <module>
    assert c.editCommands.fillPrefix == 'xxxx.yyyy'
AssertionError

======================================================================
FAIL: @test capitalizeHelper

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 12, in <module>
    assert word == result, 'Expected %s, got: %s' % (result,repr(word))
AssertionError: Expected Targetword, got: u'fore\naaaY1'

======================================================================
FAIL: @test findWord

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 14, in <module>
    assert i == 10, 'expected 15, got %s' % (i)
AssertionError: expected 15, got 0

======================================================================
FAIL: @test selfInsertCommand-2 (replacing tabs)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 11, in <module>
    assert result.endswith('\n    abcdef'),'last line:%s' % repr(result.split('\n')[-1])
AssertionError: last line:u'after'

======================================================================
FAIL: @test paste at end of headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 9, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test typing and undo in headline - at end

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 10, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test paste and undo in headline - at end

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 8, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test paste and undo in headline - with selection

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 8, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test selecting new node retains typing in headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 10, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test paste from menu into body sticks

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 8, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test paste from menu into headline sticks

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 6, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test paste from menu to body recolors the body

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test typing in headline recomputes width

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test selecting new node retains paste in headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 8, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test typing in empty body text redraws the screen (and icon)

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test typing in non-empty body text does not redraw the screen

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 7, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test undoing insert node restores previous node's body text

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 6, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test <Delete> key sticks in body

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 6, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

======================================================================
FAIL: @test <Delete> key sticks in headline

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 6, in <module>
    assert p,'node not found: %s' % h
AssertionError: node not found: Test headline abc

----------------------------------------------------------------------
Ran 149 tests in 1.171s

FAILED (failures=25, errors=6)
#@nonl
#@-node:ekr.20081013210935.13:leoEditCommands
#@+node:ekr.20081013210935.14:leoFileCommands
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
.FF......
End of leoFileCommands tests.
.
======================================================================
FAIL: @test minimal test of putTnodeList

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 15, in <module>
    assert s == expected, 'expected: %s, got: %s' % (repr(expected),repr(s))
AssertionError: expected: ' tnodeList="ekr.20061001124008,ekr.20061001124008.1,ekr.20061001124008.2"', got: ' tnodeList="ekr.20081013210925.
762,ekr.20081013210925.763,ekr.20081013210925.764"'

======================================================================
FAIL: @test putDescendentTnodeUas

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 21, in <module>
    assert s == expected, 'expected: %s, got: %s' % (repr(expected),repr(s))
AssertionError: expected: ' descendentTnodeUnknownAttributes="7d7100285514656b722e32303036313030313039313634372e3171017d71025514756e69745f74
6573745f6772616e646368696c64710355047778797a7104735512656b722e323030363130303130393136343771057d7106550f756e69745f746573745f6368696c64710755
0461626364710873752e"', got: ' descendentTnodeUnknownAttributes="7d7100285516656b722e32303038313031333231303932352e37363771017d71025514756e6
9745f746573745f6772616e646368696c64710355047778797a7104735516656b722e32303038313031333231303932352e37363671057d7106550f756e69745f746573745f6
368696c647107550461626364710873752e"'

----------------------------------------------------------------------
Ran 10 tests in 0.125s

FAILED (failures=2)
#@nonl
#@-node:ekr.20081013210935.14:leoFileCommands
#@+node:ekr.20081013210935.24:leoFind
@enabled-plugins found in leoSettings.leo
EEEE.
======================================================================
ERROR: @test minbuffer find commands

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 14, in <module>
    c.k.simulateCommand(command)
  File "C:\leo.repo\qt-plugin\leo\core\leoKeys.py", line 3049, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "C:\leo.repo\qt-plugin\leo\core\leoKeys.py", line 2534, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "C:\leo.repo\qt-plugin\leo\core\leoCommands.py", line 319, in doCommand
    val = command(event)
  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7909, in reSearchForward
    self.getHandler().reSearchForward(event)
  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7808, in getHandler
    self.openFindTab(show=show)
  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7749, in openFindTab
    self.findTabHandler = g.app.gui.createFindTab(c,f)
  File "C:\leo.repo\qt-plugin\leo\core\leoGui.py", line 582, in createFindTab
    return leoFind.nullFindTab(c,parentFrame)
  File "C:\leo.repo\qt-plugin\leo\core\leoFind.py", line 1437, in __init__
    self.init(c) # New in 4.3: init only once.
  File "C:\leo.repo\qt-plugin\leo\core\leoFind.py", line 1624, in init
    svar = self.svarDict[ivar].get()
KeyError: 'entire-outline'

======================================================================
ERROR: @test set find mode commands

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 13, in <module>
    c.k.simulateCommand(command)
  File "C:\leo.repo\qt-plugin\leo\core\leoKeys.py", line 3049, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "C:\leo.repo\qt-plugin\leo\core\leoKeys.py", line 2534, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "C:\leo.repo\qt-plugin\leo\core\leoCommands.py", line 319, in doCommand
    val = command(event)
  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7820, in setFindScopeEveryWhere
    return self.setFindScope('entire-outline')
  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7875, in setFindScope
    def setFindScope (self, where):  self.getHandler().setFindScope(where)
  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7215, in setFindScope
    var = h.svarDict['radio-search-scope'].get()
AttributeError: 'NoneType' object has no attribute 'svarDict'

======================================================================
ERROR: @test show-find-options

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 3, in <module>
    c.k.simulateCommand('show-find-options')
  File "C:\leo.repo\qt-plugin\leo\core\leoKeys.py", line 3049, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "C:\leo.repo\qt-plugin\leo\core\leoKeys.py", line 2534, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "C:\leo.repo\qt-plugin\leo\core\leoCommands.py", line 319, in doCommand
    val = command(event)
  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7832, in showFindOptions
    self.getHandler().showFindOptions()
  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7235, in showFindOptions
    head  = self.getOption('search_headline')
  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7224, in getOption
    def getOption (self,ivar):          return self.finder.getOption(ivar)
AttributeError: 'NoneType' object has no attribute 'getOption'

======================================================================
ERROR: @test togle find options commands

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 17, in <module>
    c.k.simulateCommand(command)
  File "C:\leo.repo\qt-plugin\leo\core\leoKeys.py", line 3049, in simulateCommand
    k.masterCommand(event,func,stroke)
  File "C:\leo.repo\qt-plugin\leo\core\leoKeys.py", line 2534, in masterCommand
    c.doCommand(func,commandName,event=event)
  File "C:\leo.repo\qt-plugin\leo\core\leoCommands.py", line 319, in doCommand
    val = command(event)
  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7844, in toggleIgnoreCaseOption
    return self.toggleOption('ignore_case')
  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7876, in toggleOption
    def toggleOption (self, ivar):   self.getHandler().toggleOption(ivar)
  File "C:\leo.repo\qt-plugin\leo\core\leoEditCommands.py", line 7226, in toggleOption
    def toggleOption (self,ivar):       self.finder.toggleOption(ivar)
AttributeError: 'NoneType' object has no attribute 'toggleOption'

----------------------------------------------------------------------
Ran 5 tests in 0.032s

FAILED (errors=4)
C:\leo.repo\qt-plugin>
#@nonl
#@-node:ekr.20081013210935.24:leoFind
#@+node:ekr.20081013210935.25:leoFrame **
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
..FFF....
======================================================================
FAIL: @test c.frame.pasteText

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 13, in <module>
    assert len(s2) == len(s) + len('target')
AssertionError

======================================================================
FAIL: @test c.frame.pasteText 2

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 10, in <module>
    assert s == s2, 'w.getAllText() != p.bodyString(): len(w)=%d, len(p)=%d' % (len(s),len(s2))
AssertionError: w.getAllText() != p.bodyString(): len(w)=0, len(p)=611

======================================================================
FAIL: @test leoBody.getInsertLines

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 11, in <module>
    assert before == '# line 1\n','Got %s' % repr(before)
AssertionError: Got u''

----------------------------------------------------------------------
Ran 9 tests in 0.046s

FAILED (failures=3)
#@nonl
#@-node:ekr.20081013210935.25:leoFrame **
#@+node:ekr.20081013210935.33:leoImport
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
makeTestSuite: Exception creating test cases for @suite Export tests
Traceback (most recent call last):

Traceback (most recent call last):

  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 215, in makeTestSuite
    exec(script + '\n',{'c':c,'g':g,'p':p})

  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 215, in makeTestSuite
    exec(script + '\n',{'c':c,'g':g,'p':p})

  File "<string>", line 12, in <module>

  File "<string>", line 12, in <module>

  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1110, in makeImportExportSuite
    assert(parent)

  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1110, in makeImportExportSuite
    assert(parent)

AssertionError

AssertionError

makeTestSuite: Exception creating test cases for @suite Import tests
Traceback (most recent call last):

Traceback (most recent call last):

  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 215, in makeTestSuite
    exec(script + '\n',{'c':c,'g':g,'p':p})

  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 215, in makeTestSuite
    exec(script + '\n',{'c':c,'g':g,'p':p})

  File "<string>", line 11, in <module>

  File "<string>", line 11, in <module>

  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1110, in makeImportExportSuite
    assert(parent)

  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1110, in makeImportExportSuite
    assert(parent)

AssertionError

AssertionError

..........................................first mismatched line at line 36
original line:          /**

generated line:     /**

input...
  0 /*
  1  * $Header: /cvs/leo/test/unitTest.leo,v 1.247 2008/02/14 14:59:04 edream Exp $
  2  *
  3  * Copyright (c) OSGi Alliance (2000, 2005). All Rights Reserved.
  4  *
  5  * This program and the accompanying materials are made available under the
  6  * terms of the Eclipse Public License v1.0 which accompanies this
  7  * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html.
  8  */
  9
 10 package org.osgi.framework;
 11
 12 /**
 13  * A Framework exception used to indicate that a bundle lifecycle problem
 14  * occurred.
 15  *
 16  * <p>
 17  * <code>BundleException</code> object is created by the Framework to denote
 18  * an exception condition in the lifecycle of a bundle.
 19  * <code>BundleException</code>s should not be created by bundle developers.
 20  *
 21  * <p>
 22  * This exception is updated to conform to the general purpose exception
 23  * chaining mechanism.
 24  *
 25  * @version $Revision: 1.247 $
 26  */
 27
 28 public class BundleException extends Exception {
 29     static final long       serialVersionUID        = 3571095144220455665L;
 30     /**
 31      * Nested exception.
 32      */
 33     private Throwable       cause;
 34
 35     /**
 36      * Creates a <code>BundleException</code> that wraps another exception.
 37      *
 38      * @param msg The associated message.
 39      * @param cause The cause of this exception.
 40      */
 41     public BundleException(String msg, Throwable cause) {
 42             super(msg);
 43             this.cause = cause;
 44     }
 45 }
 46
output...
  0 /*
  1  * $Header: /cvs/leo/test/unitTest.leo,v 1.247 2008/02/14 14:59:04 edream Exp $
  2  *
  3  * Copyright (c) OSGi Alliance (2000, 2005). All Rights Reserved.
  4  *
  5  * This program and the accompanying materials are made available under the
  6  * terms of the Eclipse Public License v1.0 which accompanies this
  7  * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html.
  8  */
  9
 10 package org.osgi.framework;
 11
 12 /**
 13  * A Framework exception used to indicate that a bundle lifecycle problem
 14  * occurred.
 15  *
 16  * <p>
 17  * <code>BundleException</code> object is created by the Framework to denote
 18  * an exception condition in the lifecycle of a bundle.
 19  * <code>BundleException</code>s should not be created by bundle developers.
 20  *
 21  * <p>
 22  * This exception is updated to conform to the general purpose exception
 23  * chaining mechanism.
 24  *
 25  * @version $Revision: 1.247 $
 26  */
 27
 28 public class BundleException extends Exception {
 29     static final long       serialVersionUID        = 3571095144220455665L;
 30     /**
 31      * Nested exception.
 32      */
 33     private Throwable       cause;
 34
 35     /**
 36      * Creates a <code>BundleException</code> that wraps another exception.
 37      *
 38      * @param msg The associated message.
 39      * @param cause The cause of this exception.
 40      */
 41     public BundleException(String msg, Throwable cause) {
 42             super(msg);
 43             this.cause = cause;
 44     }
 45 }
 46
scannerUnitTest: result False actualErrors 1 expectedErrors 0 actualMismatchLine 36 expectedMismatchLine None
actualErrorMessage   import command did not import @file C:\leo.repo\qt-plugin\leo\test\from BundleException.java perfectly
first mismatched line: 36
u'    /**\n'
expectedErrorMessage None
F..........
End of leoImport tests.
.
======================================================================
FAIL: @test from BundleException.java

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 57, in <module>
    c.importCommands.javaUnitTest(p,s=s,showTree=False)
  File "C:\leo.repo\qt-plugin\leo\core\leoImport.py", line 1444, in javaUnitTest
    return self.scannerUnitTest (p,atAuto=False,fileName=fileName,s=s,showTree=showTree,ext='.java')
  File "C:\leo.repo\qt-plugin\leo\core\leoImport.py", line 1513, in scannerUnitTest
    assert ok
AssertionError

----------------------------------------------------------------------
Ran 54 tests in 1.954s

FAILED (failures=1)
#@nonl
#@-node:ekr.20081013210935.33:leoImport
#@+node:ekr.20081013210935.34:leoNodes
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
..................F......E.F................
End of leoNodes tests.
.
======================================================================
ERROR: @test create-chapter

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 13, in <module>
    c.chapterController.createChapterByName('new-chapter',p,undoType)
AttributeError: 'NoneType' object has no attribute 'createChapterByName'

======================================================================
FAIL: @test p.setBodyStringOrPane

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 15, in <module>
    "c.setBodyString failed: %s, %s" % (repr(s),repr(after))
AssertionError: c.setBodyString failed: u'', 'after'

======================================================================
FAIL: @test deleting the root should select another node

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 175, in runTest
    execfile(scriptFile,d)
  File "C:\leo.repo\qt-plugin\leo\test\scriptFile.py", line 18, in <module>
    assert next.headString() == 'Startup', 'fail 2: next: %s' % next
AssertionError: fail 2: next: <pos 25416400 childIndex: 1 lvl: 0 [0] All unit tests>

----------------------------------------------------------------------
Ran 45 tests in 0.390s

FAILED (failures=2, errors=1)
#@nonl
#@-node:ekr.20081013210935.34:leoNodes
#@+node:ekr.20081013210935.35:leoShadow (can't find test)
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
makeTestSuite: Exception creating test cases for @suite run @shadow-test nodes in the @shadow-tests tree
Traceback (most recent call last):

Traceback (most recent call last):

  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 215, in makeTestSuite
    exec(script + '\n',{'c':c,'g':g,'p':p})

  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 215, in makeTestSuite
    exec(script + '\n',{'c':c,'g':g,'p':p})

  File "<string>", line 13, in <module>

  File "<string>", line 13, in <module>

AssertionError: Node not found: @shadow-tests

AssertionError: Node not found: @shadow-tests

................
----------------------------------------------------------------------
Ran 16 tests in 0.125s

OK
#@nonl
#@-node:ekr.20081013210935.35:leoShadow (can't find test)
#@+node:ekr.20081013210935.36:leoUndo
creating: dynamicUnitTest.leo
Using menus from leoSettings.leo
reading C:\Documents and Settings\HP_Administrator\My Documents\Edward\.leo\.leoRecentFiles.txt
@enabled-plugins found in leoSettings.leo
@enabled-plugins found in leoSettings.leo
no text selected
compareOutlines failed
p1 <pos 25434576 childIndex: 0 lvl: 3 [3] tempNode> <vnode 25416784:'tempNode'>
p2 <pos 25476752 childIndex: 1 lvl: 4 [4] after> <vnode 25417104:'after'>
p1.body
u'@language python\n\ndef addCommentTest():\n\n    if 1:\n        a = 2\n        b = 3\n        \n    pass'
p2.body
u'@language python\n\ndef addCommentTest():\n\n    # if 1:\n        # a = 2\n        # b = 3\n        \n    pass'
FcompareOutlines failed
p1 <pos 25435632 childIndex: 0 lvl: 3 [3] tempNode> <vnode 25416784:'tempNode'>
p2 <pos 25476752 childIndex: 1 lvl: 4 [4] after> <vnode 25417488:'after'>
p1.body
u'@tabwidth -4\n\nline 1\n    line 2\n      line 3\nline4'
p2.body
u'@tabwidth -4\n\nline 1\n\tline 2\n\t  line 3\nline4'
FcompareOutlines failed
p1 <pos 25435856 childIndex: 0 lvl: 3 [3] tempNode> <vnode 25416784:'tempNode'>
p2 <pos 25476752 childIndex: 1 lvl: 4 [4] after> <vnode 25417872:'after'>
p1.body
u'@tabwidth -4\n\nline 1\n\tline 2\n\t  line 3\nline4'
p2.body
u'@tabwidth -4\n\nline 1\n    line 2\n      line 3\nline4'
FcompareOutlines failed
p1 <pos 25435632 childIndex: 0 lvl: 3 [3] tempNode> <vnode 25416784:'tempNode'>
p2 <pos 25476752 childIndex: 1 lvl: 4 [4] after> <vnode 25418256:'after'>
p1.body
u'@tabwidth -4\n\nline 1\n    line 2\n      line 3\nline4'
p2.body
u'@tabwidth -4\n\nline 1\n\tline 2\n\t  line 3\nline4'
FcompareOutlines failed
p1 <pos 25435568 childIndex: 0 lvl: 3 [3] tempNode> <vnode 25416784:'tempNode'>
p2 <pos 25476752 childIndex: 1 lvl: 4 [4] after> <vnode 25418640:'after'>
p1.body
u'@tabwidth -4\n\nline 1\n\tline 2\n\t  line 3\nline4'
p2.body
u'@tabwidth -4\n\nline 1\n    line 2\n      line 3\nline4'
FcompareOutlines failed
p1 <pos 25435600 childIndex: 0 lvl: 3 [3] tempNode> <vnode 25416784:'tempNode'>
p2 <pos 25476752 childIndex: 1 lvl: 4 [4] after> <vnode 25419024:'after'>
p1.body
u'line 1\n    line 2\n    line 3\nline 4'
p2.body
u'line 1\nline 2\nline 3\nline 4'
Fno text selected
compareOutlines failed
p1 <pos 25435888 childIndex: 0 lvl: 3 [3] tempNode> <vnode 25416784:'tempNode'>
p2 <pos 25476752 childIndex: 1 lvl: 4 [4] after> <vnode 25419408:'after'>
p1.body
u'@language python\n\ndef deleteCommentTest():\n\n    # if 1:\n        # a = 2\n        # b = 3\n        \n    pass'
p2.body
u'@language python\n\ndef deleteCommentTest():\n\n    if 1:\n        a = 2\n        b = 3\n        \n    pass'
FcompareOutlines failed
p1 <pos 25435888 childIndex: 0 lvl: 3 [3] tempNode> <vnode 25416784:'tempNode'>
p2 <pos 25435632 childIndex: 1 lvl: 4 [4] after> <vnode 25473072:'after'>
p1.numberOfChildren()=0, p2.numberOfChildren()=1
p1.body
u'before\n    << section >>\n    sec line 1\n        sec line 2 indented\nsec line 3\nafter'
p2.body
u'before\nafter'
F.compareOutlines failed
p1 <pos 25435632 childIndex: 0 lvl: 3 [3] tempNode> <vnode 25416784:'tempNode'>
p2 <pos 25476752 childIndex: 1 lvl: 4 [4] after> <vnode 25473936:'after'>
p1.numberOfChildren()=0, p2.numberOfChildren()=1
p1.body
u'before\n    << section >>\n    sec line 1\n        sec line 2 indented\nsec line 3\nafter'
p2.body
u'before\n    << section >>\nafter'
F.
End of leoUndo tests.
.
======================================================================
FAIL: runTest (leo.core.leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1045, in runTest
    self.editBody()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1034, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: addComments: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1045, in runTest
    self.editBody()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1034, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: convertAllBlanks: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1045, in runTest
    self.editBody()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1034, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: convertAllTabs: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1045, in runTest
    self.editBody()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1034, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: convertBlanks: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1045, in runTest
    self.editBody()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1034, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: convertTabs: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1045, in runTest
    self.editBody()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1034, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: dedentBody: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1045, in runTest
    self.editBody()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1034, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: deleteComments: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1045, in runTest
    self.editBody()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1034, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: extract: before undo1

======================================================================
FAIL: runTest (leo.core.leoTest.editBodyTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1045, in runTest
    self.editBody()
  File "C:\leo.repo\qt-plugin\leo\core\leoTest.py", line 1034, in editBody
    assert u.compareOutlines(self.tempNode,self.after,compareHeadlines=False),'%s: before undo1' % commandName
AssertionError: extractSection: before undo1

----------------------------------------------------------------------
Ran 12 tests in 0.031s

FAILED (failures=9)
#@-node:ekr.20081013210935.36:leoUndo
#@-node:ekr.20081013210935.32:Fail
#@-node:ekr.20081013210935.1:Unit tests
#@+node:ekr.20081018155359.11:Unused
#@+node:ekr.20081021043407.2:OLDredraw_now
def OLDredraw_now (self,scroll=False,forceDraw=False):

    '''Redraw immediately: used by Find so a redraw doesn't mess up selections in headlines.'''

    c = self.c ; w = self.treeWidget ; trace = True ; verbose = False
    if not w: return
    if self.redrawing:
        return g.trace('already drawing')

    # Traces...
    self.redrawCount += 1
    current = c.currentPosition()
    if trace: g.trace(self.redrawCount,current and current.headString())

    # Loop init.
    found_current = None
    self.vnodeDict = {} # keys are vnodes, values are lists of items (p,it)
    self.itemsDict = {} # keys are id(it), values are positions
    parentsDict = {}

    self.redrawing = True
    try:
        w.clear()
        for p in c.allNodes_iter():
            it = parentsDict.get(p.parent().v,w)
            it = QtGui.QTreeWidgetItem(it)
            icon = self.getIcon(p)
            if icon: it.setIcon(0,icon)
            it.setFlags(it.flags() | QtCore.Qt.ItemIsEditable)
            self.itemsDict[id(it)] = p.copy() # Valid.
            parentsDict[p.v] = it # Just barely valid for drawing.
            # More accurate info, for use by selectHint.
            aList = self.vnodeDict.get(p.v,[])
            data = p.copy(),it
            aList.append(data)
            self.vnodeDict[p.v] = aList
            it.setText(0,p.headString())
            if p.hasChildren() and p.isExpanded() and self.allAncestorsExpanded(p):
                w.expandItem(it)
            else:
                w.collapseItem(it)

            if p == current:
                w.setCurrentItem(it) ; found_current = it
    finally:
        if found_current is None:
            if self.redrawCount > 1:
                g.trace('** no current item: %s' % (p and p.headString()))
        else:
            w.scrollToItem(found_current, QtGui.QAbstractItemView.PositionAtCenter)

        # Necessary to get the tree drawn initially.
        if self.redrawCount == 1:
            # g.trace('***repaint')
            w.repaint()

        self.redrawing = False

redraw = redraw_now # Compatibility
#@-node:ekr.20081021043407.2:OLDredraw_now
#@+node:ekr.20081021043407.33:partial_redraw_after_expand & helper
def partial_redraw_after_expand (self):

    c = self.c ; p = c.currentPosition()
    w = self.treeWidget ; trace = True ; verbose = True
    it = self.parentsDict.get(p.v)
    if it:
        self.nodeDrawCount = 0
        self.redrawing = True
        self.expanding = True
        self.selecting = True
        try:
            if p.hasChildren() and p.isExpanded():
                w.expandItem(it)
                # Delete all the children from the tree.
                items = it.takeChildren()
                if trace and verbose: g.trace(
                    id(it),len(items),p.headString(),g.callers(4))

                # Delete all descendant from dictionaries.
                for child in p.children_iter():
                    for z in child.self_and_subtree_iter():
                        self.removeFromDicts(z)

                # Redraw all descendants.
                child = p.firstChild()
                while child:
                    self.drawTree(child)
                    child.moveToNext()
            else:
                # Don't change anything!
                g.trace('no change')
                w.collapseItem(it)
        finally:
            w.setCurrentItem(it)
            self.redrawing = False
            self.expanding = False
            self.selecting = False
            c.requestRedrawFlag= False
            if trace: g.trace(
                'drew %3s nodes' % self.nodeDrawCount) # ,g.callers(4))
    else:
        g.trace('can not happen: no item for %s' % p.headString())
        self.full_redraw()
#@-node:ekr.20081021043407.33:partial_redraw_after_expand & helper
#@+node:ekr.20081010070648.17:setTreeFont
def setTreeFont (self):

    c = self.c ; w = self.treeWidget

    font = c.config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight",
        c.config.defaultTreeFontSize)

    if not font:
        # g.trace('*** no font, using default')
        font = QtGui.QFont("SansSerif",12, QtGui.QFont.Normal)

    w.setFont(font)
#@-node:ekr.20081010070648.17:setTreeFont
#@+node:ekr.20081010070648.15:setTreeColors
def setTreeColors (self):

    pass # Style sheets now work.

    # p = QtGui.QPalette ; w = self.treeWidget
    # black = QtGui.QColor('black')
    # red   = QtGui.QColor('red')
    # white = QtGui.QColor('white')

    # # Create a single palette.
    # palette = p()

    # # Selected, not editing.
    # fg    = self.headline_text_selected_foreground_color or black
    # bg    = self.headline_text_selected_background_color or 'grey80'
    # selfg = self.headline_text_editing_selection_foreground_color
    # selbg = self.headline_text_editing_selection_background_color

    # # Selected, editing
    # fg    = self.headline_text_editing_foreground_color or black
    # bg    = self.headline_text_editing_background_color or white
    # selfg = self.headline_text_editing_selection_foreground_color or white
    # selbg = self.headline_text_editing_selection_background_color or black

    # # Not selected.
    # fg = self.headline_text_unselected_foreground_color or black
    # bg = self.headline_text_unselected_background_color or white

    # # Assign colors to the single palette.
    # palette.setColor(p.Active,p.Background,red)

    # # w.setPalette(palette)
#@-node:ekr.20081010070648.15:setTreeColors
#@+node:ekr.20081025124450.16:OLDonTextChanged
def onTextChanged (self):

    '''Update Leo after the body has been changed.

    self.selecting is guaranteed to be True during the entire selection process.'''

    c = self.c ; tree = c.frame.tree ; w = self
    trace = True ; verbose = False
    old_p,new_p = tree.old_p,tree.new_p

    if tree.selecting:
        if trace and verbose: g.trace('selecting')
        return
    if tree.redrawing:
        if trace and verbose: g.trace('redrawing')
        return

    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText() # Converts to unicode.

    select = new_p and new_p != self.body_p
    if select:
        if trace and verbose:
            g.trace('** select',tree.new_p.headString())
        self.body_p = new_p.copy()
        return

    p = self.body_p
    if not p: return g.trace('***: no p')

    # Get the previous values from the tnode.
    oldText = g.toUnicode(p.v.t._bodyString,"utf-8")
    if oldText == newText: return

    if trace: g.trace('****changed',p.headString(),len(oldText),len(newText))

    oldIns  = p.v.t.insertSpot
    i,j = p.v.t.selectionStart,p.v.t.selectionLength
    oldSel  = (i,j-i)
    oldYview = None
    undoType = 'changed event'
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,
        oldSel=oldSel,newSel=newSel,oldYview=oldYview)

    # Update the tnode.
    p.v.setBodyString(newText)
    p.v.t.insertSpot = newInsert
    i,j = newSel
    if i > j: i,j = j,i
    new_p.v.t.selectionStart,new_p.v.t.selectionLength = (i,j-i)

    # No need to redraw the screen.
    if not self.useScintilla:
        c.recolor()
    if not c.changed and c.frame.initComplete:
        c.setChanged(True)
    self.updateEditors()
    c.frame.tree.updateIcon(p)
    c.outerUpdate()
#@-node:ekr.20081025124450.16:OLDonTextChanged
#@+node:ekr.20081009055104.11:selectHint (no longer used)
# def selectHint (self,p,old_p):

    # w = self.treeWidget ; trace = False

    # if self.redrawing:
        # if trace: g.trace('already redrawing')
        # return
    # if self.selecting:
        # if trace: g.trace('already selecting')
        # return

    # aList = self.vnodeDict.get(p.v,[])
    # h = p.headString()

    # self.new_p = p.copy()
    # self.old_p = old_p.copy()

    # if trace: g.trace(
        # p and p.headString(),
        # old_p and old_p.headString())

    # for p2,it in aList:
        # if p == p2:
            # if trace:
                # g.trace('found item: %s for: %s' % (
                    # id(it),h),g.callers())
            # self.selecting = True
            # try:
                # w.setCurrentItem(it)
            # finally:
                # self.selecting = False
            # break
    # else:
        # if aList:
            # g.trace('redrawing',self.redrawing,g.callers())
            # g.trace('not found %s in %s' % (aList,h))
        # self.full_redraw() ###
#@-node:ekr.20081009055104.11:selectHint (no longer used)
#@-node:ekr.20081018155359.11:Unused
#@+node:ekr.20081024175359.10:Scripts
#@+node:ekr.20081022172620.10:Script to display Qt font database
import PyQt4.QtGui as QtGui

db = QtGui.QFontDatabase()
for family in db.families():
    print family
    for style in db.styles(family):
        print '\t',style,db.smoothSizes(family,style)
#@-node:ekr.20081022172620.10:Script to display Qt font database
#@+node:ekr.20081020151747.10:dump guiBindNamesInverseDict
print g.dictToString(c.k.guiBindNamesInverseDict)

@
   BackSpace: 'BackSpace'
       Begin: 'Begin'
       Break: 'Break'
   Caps_Lock: 'Caps_Lock'
       Clear: 'Clear'
      Delete: 'Delete'
        Down: 'Down'
         End: 'End'
      Escape: 'Escape'
          F1: 'F1'
         F10: 'F10'
         F11: 'F11'
         F12: 'F12'
          F2: 'F2'
          F3: 'F3'
          F4: 'F4'
          F5: 'F5'
          F6: 'F6'
          F7: 'F7'
          F8: 'F8'
          F9: 'F9'
        Home: 'Home'
        Left: 'Left'
    Linefeed: 'Linefeed'
        Next: 'Next'
    Num_Lock: 'Num_Lock'
       Prior: 'Prior'
      Return: 'Return'
       Right: 'Right'
         Tab: 'Tab'
          Up: 'Up'
   ampersand: '&'
 asciicircum: '^'
  asciitilde: '~'
    asterisk: '*'
          at: '@'
   backslash: '\\'
         bar: '|'
   braceleft: '{'
  braceright: '}'
 bracketleft: '['
bracketright: ']'
       colon: ':'
       comma: ','
      dollar: '$'
       equal: '='
      exclam: '!'
     greater: '>'
        less: '<'
       minus: '-'
  numbersign: '#'
   parenleft: '('
  parenright: ')'
     percent: '%'
      period: '.'
        plus: '+'
    question: '?'
    quotedbl: '"'
   quoteleft: '`'
  quoteright: "'"
   semicolon: ';'
       slash: '/'
       space: ' '
  underscore: '_'
#@nonl
#@-node:ekr.20081020151747.10:dump guiBindNamesInverseDict
#@-node:ekr.20081024175359.10:Scripts
#@-all
#@nonl
#@-node:ekr.20081016072304.13:@thin qtNotes.txt
#@-leo
