<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20160122104302.1"><vh>Startup</vh>
<v t="ekr.20160510132151.1"><vh>@button backup</vh></v>
<v t="ekr.20170811173231.1"><vh>@button backup-repo</vh></v>
<v t="ekr.20170203054655.1"><vh>@ignore unused buttons</vh>
<v t="ekr.20161122014821.1"><vh>@button make-importer</vh>
<v t="ekr.20161122020451.1"><vh>&lt;&lt; define run &amp; helpers &gt;&gt;</vh>
<v t="ekr.20161122020932.1"><vh>copy_tree</vh></v>
<v t="ekr.20161122021006.1"><vh>make_substitutions</vh></v>
<v t="ekr.20161122023427.1"><vh>run</vh></v>
<v t="ekr.20161122021342.1"><vh>substitue</vh></v>
</v>
<v t="ekr.20161122023554.1"><vh>@@file importers/{{name}}.py</vh>
<v t="ekr.20161122023554.2"><vh>class {{cap_name}}_Importer</vh>
<v t="ekr.20161122023554.3"><vh>{{name}}.Overrides</vh>
<v t="ekr.20161122023554.4"><vh>{{name}}.clean_headline</vh></v>
<v t="ekr.20161122023554.5"><vh>{{name}}.clean_nodes</vh></v>
</v>
</v>
<v t="ekr.20161122023554.6"><vh>class {{cap_name}}_ScanState</vh>
<v t="ekr.20161122023554.7"><vh>{{name}}_state.level</vh></v>
<v t="ekr.20161122023554.8"><vh>{{name}}_state.update</vh></v>
</v>
</v>
</v>
<v t="ekr.20161030154232.1"><vh>@button pep8 @key=Ctrl-5</vh>
<v t="ekr.20161031124905.1"><vh>class Pep8</vh>
<v t="ekr.20161031053537.1"><vh>change_all &amp; helpers</vh>
<v t="ekr.20161031074727.1"><vh>change_body</vh></v>
<v t="ekr.20161031075018.1"><vh>change_headline</vh></v>
</v>
<v t="ekr.20161031051319.1"><vh>get_name</vh></v>
<v t="ekr.20161031125119.1"><vh>run</vh></v>
<v t="ekr.20161031051342.1"><vh>to_pep8</vh></v>
</v>
<v t="ekr.20161031065339.1"><vh>clear</vh></v>
</v>
<v t="ekr.20160412101845.1"><vh>@button test-jup-export</vh></v>
<v t="ekr.20160412101537.1"><vh>@button test-jup-import</vh></v>
</v>
<v t="ekr.20160122104400.1"><vh>@settings</vh>
<v t="ekr.20170709095709.1"><vh>@@bool minibuffer_find_mode = True</vh></v>
<v t="ekr.20160122104357.1"><vh>@data history-list</vh></v>
</v>
<v t="ekr.20170420085814.1"><vh>Recursive import script</vh></v>
<v t="ekr.20181017164437.1"><vh>script: regularize settings</vh></v>
</v>
<v t="ekr.20090430075506.4"><vh>Notes</vh>
<v t="ekr.20090430075506.3"><vh>@file leoPluginNotes.txt</vh></v>
</v>
<v t="edream.110203113231.618"><vh>Plugins</vh>
<v t="EKR.20040517090508"><vh>  Enable plugins using @enabled-plugins nodes</vh></v>
<v t="ekr.20050303051035"><vh>  Templates</vh>
<v t="ekr.20041114102139"><vh>Notes for plugin writers</vh></v>
<v t="ekr.20050306071629"><vh>Template for plugins that override commander methods</vh>
<v t="ekr.20050306071629.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050306071629.3"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050306071629.4"><vh>init</vh></v>
<v t="ekr.20050306071540"><vh>onStart2</vh></v>
</v>
<v t="ekr.20050303051035.2"><vh>Template for plugins with per-commander controller class</vh>
<v t="ekr.20050303051035.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050303051101"><vh>init</vh></v>
<v t="ekr.20050303051150"><vh>onCreate</vh></v>
<v t="ekr.20050303051222"><vh>class pluginController</vh>
<v t="ekr.20050303051222.1"><vh>__init__</vh></v>
</v>
</v>
</v>
<v t="ekr.20100103093121.5365"><vh>Auto completion</vh>
<v t="ekr.20091118065749.5261"><vh>@file ctagscompleter.py</vh></v>
</v>
<v t="edream.110203113231.667"><vh>Commands &amp; directives</vh>
<v t="edream.110203113231.741"><vh>@file add_directives.py</vh></v>
<v t="ekr.20101110084839.5682"><vh>@file bzr_qcommands.py</vh></v>
<v t="EKR.20040517080049.1"><vh>@file empty_leo_file.py</vh></v>
<v t="edream.110203113231.669"><vh>@file import_cisco_config.py</vh></v>
<v t="ekr.20101110092851.5812"><vh>@file initinclass.py</vh></v>
<v t="ekr.20101110091234.5700"><vh>@file leo_interface.py</vh></v>
<v t="ekr.20040419105219"><vh>@file lineNumbers.py</vh></v>
<v t="ekr.20040916084945"><vh>@file macros.py</vh></v>
<v t="edream.110203113231.724"><vh>@file mod_autosave.py</vh></v>
<v t="ekr.20050301083306"><vh>@file mod_read_dir_outline.py</vh></v>
<v t="edream.110203113231.727"><vh>@file mod_timestamp.py</vh></v>
<v t="TL.20090225102340.32"><vh>@file nodeActions.py</vh></v>
<v t="edream.110203113231.720"><vh>@file outline_export.py</vh></v>
<v t="danr7.20060912105041.1"><vh>@file paste_as_headlines.py</vh></v>
<v t="ekr.20041021120118"><vh>@file pretty_print.py</vh></v>
<v t="tbrown.20070117104409"><vh>@file quickMove.py</vh></v>
<v t="ekr.20081214160729.1"><vh>@file setHomeDirectory.py</vh></v>
<v t="danr7.20061010105952.1"><vh>@file word_count.py</vh></v>
</v>
<v t="edream.110203113231.729"><vh>Debugging</vh>
<v t="ekr.20101110091234.5689"><vh>@file debugger_pudb.py</vh></v>
<v t="edream.110203113231.730"><vh>@file dump_globals.py</vh></v>
<v t="edream.110203113231.732"><vh>@file enable_gc.py</vh></v>
<v t="edream.110203113231.734"><vh>@file quit_leo.py</vh></v>
<v t="edream.110203113231.735"><vh>@file trace_gc_plugin.py</vh></v>
<v t="edream.110203113231.736"><vh>@file trace_keys.py</vh></v>
<v t="edream.110203113231.738"><vh>@file trace_tags.py</vh></v>
</v>
<v t="ekr.20041030092101"><vh>Dyna plugins by e</vh></v>
<v t="ekr.20040722141148"><vh>Examples</vh>
<v t="edream.110203113231.916"><vh>@file examples/override_classes.py</vh></v>
<v t="edream.110203113231.919"><vh>@file examples/override_commands.py</vh></v>
<v t="edream.110203113231.921"><vh>@file examples/redefine_put.py</vh></v>
<v t="ekr.20060621123339"><vh>@file examples/print_cp.py</vh></v>
<v t="ekr.20040828105233"><vh>@file examples/chinese_menu.py</vh></v>
<v t="EKR.20040517080202.3"><vh>@file examples/french_fm.py</vh></v>
<v t="ekr.20180119164431.1"><vh>@file patch_python_colorizer.py</vh></v>
</v>
<v t="ekr.20101110150056.9457"><vh>Experimental</vh>
<v t="ekr.20090704103932.5160"><vh>@file leo_pdf.py</vh></v>
<v t="danr7.20060902083957"><vh>@file leo_to_rtf.py</vh></v>
<v t="ekr.20040205071616"><vh>@file mnplugins.py</vh></v>
<v t="ekr.20101110094759.5843"><vh>@file mod_speedups.py</vh></v>
<v t="ekr.20190410171646.1"><vh>Unused: pyzo_support.py</vh>
<v t="ekr.20190412042616.1"><vh>&lt;&lt; copyright &gt;&gt;</vh></v>
<v t="ekr.20190410171905.1"><vh>init (pyzo_support.py)</vh></v>
<v t="ekr.20190418161712.1"><vh>class PyzoInterface</vh>
<v t="ekr.20190803175344.1"><vh>pyzo_x.patch_pyzo</vh></v>
</v>
</v>
<v t="ekr.20040910070811.1"><vh>@file run_nodes.py</vh></v>
<v t="ekr.20100103093121.5339"><vh>@file stickynotes_plus.py</vh></v>
<v t="ekr.20140225222704.16748"><vh>@file viewrendered2.py</vh></v>
<v t="ekr.20040331071919"><vh>Leo to AsciiDoc</vh>
<v t="ekr.20101110093449.5822"><vh>@file mod_leo2ascd.py</vh></v>
<v t="ekr.20101110150056.9445"><vh>@file mod_leo2ascd.txt</vh></v>
</v>
</v>
<v t="EKR.20040517075715"><vh>External programs</vh>
<v t="ekr.20110125103904.12504"><vh>@file gitarchive.py</vh></v>
<v t="EKR.20040517080049.4"><vh>@file open_shell.py</vh></v>
<v t="ville.20090503124249.1"><vh>@file tomboy_import.py</vh></v>
<v t="EKR.20040517075715.10"><vh>@file vim.py</vh></v>
<v t="EKR.20040517075715.12"><vh>@file xemacs.py</vh></v>
<v t="EKR.20040517075715.13"><vh>Word export</vh>
<v t="EKR.20040517075715.14"><vh>@file word_export.py</vh></v>
<v t="EKR.20040517075715.20"><vh>@file-nosent word_export.ini</vh></v>
</v>
</v>
<v t="edream.110203113231.872"><vh>Files and nodes</vh>
<v t="tbrown.20080613095157.2"><vh>@file active_path.py</vh></v>
<v t="edream.110203113231.873"><vh>@file at_folder.py</vh></v>
<v t="ekr.20040915085351"><vh>@file at_produce.py</vh></v>
<v t="ktenney.20041211072654.1"><vh>@file at_view.py</vh></v>
<v t="ekr.20170619151859.2"><vh>@file auto_colorize2_0.py</vh></v>
<v t="tbrown.20081223111325.3"><vh>@file backlink.py</vh></v>
<v t="tbrown.20070322113635"><vh>@file bookmarks.py</vh></v>
<v t="ekr.20060807103814.1"><vh>@file datenodes.py</vh></v>
<v t="ajones.20070122153625"><vh>@file expfolder.py</vh></v>
<v t="ekr.20040915105758.13"><vh>@file FileActions.py</vh></v>
<v t="ekr.20110110105526.5463"><vh>@file ftp.py</vh></v>
<v t="tbrown.20091214233510.5347"><vh>@file geotag.py</vh></v>
<v t="tbrown.20100228141752.5691"><vh>@file leocursor.py</vh></v>
<v t="ville.20120503224623.3574"><vh>@file leomylyn.py</vh></v>
<v t="ekr.20101110092851.5742"><vh>@file leoOPML.py</vh></v>
<v t="dan.20090217132953.1"><vh>@file mime.py</vh></v>
<v t="mork.20041018204908.1"><vh>@file multifile.py</vh></v>
<v t="ekr.20040331151007"><vh>@file niceNosent.py</vh></v>
<v t="edream.110203113231.876"><vh>@file read_only_nodes.py</vh></v>
<v t="ekr.20040828103325"><vh>@file startfile.py</vh></v>
<v t="ekr.20130808211520.15893"><vh>@file timestamp.py</vh></v>
<v t="tbrown.20110428144124.29061"><vh>@file xml_edit.py</vh></v>
<v t="mork.20041010095009"><vh>@file xsltWithNodes.py</vh></v>
</v>
<v t="ekr.20181030041436.1"><vh>Gui</vh>
<v t="ekr.20150107090324.1"><vh>@file cursesGui.py</vh></v>
<v t="ekr.20170419092835.1"><vh>@file cursesGui2.py</vh></v>
<v t="ekr.20181103094900.1"><vh>@file leoflexx.py</vh></v>
<v t="ekr.201811100000000.1"><vh>@file leoflexx_js.py</vh></v>
<v t="ekr.20190813161639.1"><vh>@file pyzo_in_leo.py</vh></v>
<v t="ekr.20190805022257.1"><vh>Unused: @file file pyzo_file_browser.py</vh>
<v t="ekr.20190809093446.1"><vh> &lt;&lt; pyzo_file_browser imports &gt;&gt;</vh></v>
<v t="ekr.20190809093459.1"><vh> top-level Leo functions</vh>
<v t="ekr.20190809093459.3"><vh>init</vh></v>
<v t="ekr.20190809093459.4"><vh>onCreate</vh></v>
<v t="ekr.20190814050007.1"><vh>make_dock</vh></v>
</v>
</v>
</v>
<v t="ekr.20140723122936.17925"><vh>Importer plugins</vh>
<v t="ekr.20140723122936.18139"><vh>@file importers/__init__.py</vh></v>
<v t="ekr.20140723122936.17926"><vh>@file importers/c.py</vh></v>
<v t="ekr.20160505094722.1"><vh>@file importers/coffeescript.py</vh></v>
<v t="ekr.20140723122936.18140"><vh>@file importers/csharp.py</vh></v>
<v t="tbrown.20140801105909.47549"><vh>@file importers/ctext.py</vh></v>
<v t="ekr.20141116100154.1"><vh>@file importers/dart.py</vh></v>
<v t="ekr.20140723122936.18141"><vh>@file importers/elisp.py</vh></v>
<v t="ekr.20140723122936.18138"><vh>@file importers/html.py</vh></v>
<v t="ekr.20140723122936.18142"><vh>@file importers/ini.py</vh></v>
<v t="ekr.20160412101008.1"><vh>@file importers/ipynb.py</vh></v>
<v t="ekr.20140723122936.18143"><vh>@file importers/java.py</vh></v>
<v t="ekr.20140723122936.18144"><vh>@file importers/javascript.py</vh></v>
<v t="ekr.20160504080826.1"><vh>@file importers/leo_json.py</vh></v>
<v t="ekr.20140723122936.18151"><vh>@file importers/leo_rst.py</vh></v>
<v t="ekr.20161108125620.1"><vh>@file importers/linescanner.py</vh></v>
<v t="ekr.20170530024520.2"><vh>@file importers/lua.py</vh></v>
<v t="ekr.20140725190808.18066"><vh>@file importers/markdown.py</vh></v>
<v t="ekr.20140723122936.18146"><vh>@file importers/org.py</vh></v>
<v t="ekr.20140723122936.18150"><vh>@file importers/otl.py</vh></v>
<v t="ekr.20140723122936.18147"><vh>@file importers/pascal.py</vh></v>
<v t="ekr.20161027100313.1"><vh>@file importers/perl.py</vh></v>
<v t="ekr.20140723122936.18148"><vh>@file importers/php.py</vh></v>
<v t="ekr.20140723122936.18149"><vh>@file importers/python.py</vh></v>
<v t="ekr.20170615153639.2"><vh>@file importers/tcl.py</vh></v>
<v t="ekr.20180201203240.2"><vh>@file importers/treepad.py</vh></v>
<v t="ekr.20140723122936.18152"><vh>@file importers/typescript.py</vh></v>
<v t="ekr.20140723122936.18137"><vh>@file importers/xml.py</vh></v>
</v>
<v t="ekr.20180504192522.1"><vh>leo_babel</vh>
<v t="ekr.20180504191650.34"><vh>@clean leo_babel/__init__.py</vh></v>
<v t="ekr.20180504191650.36"><vh>examples</vh>
<v t="bob.20170716135108.2"><vh>@file leo_babel/examples/slowOut.py</vh></v>
<v t="bob.20170716135108.3"><vh>@file leo_babel/examples/slowOutNoFlush.py</vh></v>
</v>
<v t="ekr.20180504191650.42"><vh>tests</vh>
<v t="ekr.20180504191650.68"><vh>@clean leo_babel/tests/__init__.py</vh></v>
<v t="bob.20180206123613.1"><vh>@file leo_babel/tests/idle_time.py</vh></v>
<v t="bob.20180205135005.1"><vh>@file leo_babel/tests/lib_test.py</vh></v>
<v t="bob.20180125160225.1"><vh>@file leo_babel/tests/tests.py</vh></v>
</v>
</v>
<v t="ekr.20130927050813.13031"><vh>Obsolete</vh>
<v t="ajones.20070122160142"><vh>@file textnode.py</vh></v>
<v t="ekr.20050817132814"><vh>rst3</vh>
<v t="ekr.20050805162550"><vh>@@file rst3.py</vh>
<v t="ekr.20050805162550.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050805162550.2"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050806162146"><vh>&lt;&lt; to do &gt;&gt;</vh>
<v t="ekr.20050804081215"><vh>More options</vh></v>
</v>
<v t="ekr.20050805162550.4"><vh>Module level</vh>
<v t="ekr.20050805162550.5"><vh> init</vh></v>
<v t="ekr.20050805162550.6"><vh>onCreate</vh></v>
<v t="ekr.20050806101253"><vh>code_block</vh></v>
<v t="ekr.20090429055156.63"><vh>runUnitTests</vh></v>
</v>
<v t="ekr.20050805162550.39"><vh>html parser classes</vh>
<v t="ekr.20050805162550.40"><vh> &lt;&lt; class linkAnchorParserClass &gt;&gt; (subclass of HTMLParser.HTMLParser)</vh>
<v t="ekr.20050805162550.41"><vh>__init__</vh></v>
<v t="ekr.20050805162550.42"><vh>is_anchor</vh></v>
<v t="ekr.20050805162550.43"><vh>is_link</vh></v>
<v t="ekr.20050815164715"><vh>is_node_marker</vh></v>
</v>
<v t="ekr.20050805162550.44"><vh>class htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.45"><vh>__init__</vh></v>
<v t="ekr.20050805162550.46"><vh>handle_starttag</vh>
<v t="ekr.20050815164715.1"><vh>&lt;&lt; trace the unknownAttribute &gt;&gt;</vh></v>
</v>
<v t="ekr.20050805162550.47"><vh>handle_endtag</vh></v>
<v t="ekr.20050805162550.49"><vh>feed</vh></v>
</v>
<v t="ekr.20050805162550.50"><vh>class anchor_htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.51"><vh> __init__</vh></v>
<v t="ekr.20050805162550.52"><vh>handle_starttag</vh></v>
</v>
<v t="ekr.20050805162550.53"><vh>class link_htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.54"><vh>__init__</vh></v>
<v t="ekr.20050805162550.55"><vh>handle_starttag</vh></v>
<v t="ekr.20050805162550.56"><vh>get_replacements</vh></v>
</v>
</v>
<v t="ekr.20050805162550.8"><vh>class rstClass</vh>
<v t="ekr.20050805162550.9"><vh> Birth &amp; init</vh>
<v t="ekr.20050805162550.10"><vh> ctor (rstClass)</vh>
<v t="ekr.20050805162550.11"><vh>&lt;&lt; init ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050805162550.12"><vh>addMenu (rstClass, rst3.py)</vh></v>
<v t="ekr.20050813083007"><vh>initHeadlineCommands</vh></v>
<v t="ekr.20050813085236"><vh>initSingleNodeOptions</vh></v>
<v t="ekr.20050808072943"><vh>munge</vh></v>
</v>
<v t="ekr.20050812122236"><vh>options...</vh>
<v t="ekr.20050808064245"><vh>createDefaultOptionsDict</vh></v>
<v t="ekr.20050812120933"><vh>dumpSettings (debugging)</vh></v>
<v t="ekr.20050814134351"><vh>getOption</vh></v>
<v t="ekr.20071015110830"><vh>initCodeBlockString</vh></v>
<v t="ekr.20050807120331.1"><vh>preprocessTree &amp; helpers</vh>
<v t="ekr.20051204070141"><vh>preprocessNode</vh></v>
<v t="ekr.20050808072943.1"><vh>parseOptionLine</vh></v>
<v t="ekr.20050808070018.2"><vh>scanForOptionDocParts</vh></v>
<v t="ekr.20050811173750"><vh>scanHeadlineForOptions</vh></v>
<v t="ekr.20050807120331.2"><vh>scanNodeForOptions</vh></v>
<v t="ekr.20050808070018"><vh>scanOption</vh></v>
<v t="ekr.20050808070018.1"><vh>scanOptions</vh></v>
</v>
<v t="ekr.20050808142313.28"><vh>scanAllOptions &amp; helpers</vh>
<v t="ekr.20050805162550.13"><vh>initOptionsFromSettings</vh></v>
<v t="ekr.20050810103731"><vh>handleSingleNodeOptions</vh></v>
</v>
<v t="ekr.20050811135526"><vh>setOption</vh></v>
</v>
<v t="ekr.20050809074827"><vh>write methods</vh>
<v t="ekr.20050809082854"><vh> Top-level write code</vh>
<v t="ekr.20050809075309"><vh>initWrite</vh></v>
<v t="ekr.20050809080925"><vh>writeNormalTree</vh></v>
<v t="ekr.20051121102358"><vh>processTopTree</vh></v>
<v t="ekr.20050805162550.17"><vh>processTree</vh></v>
<v t="ekr.20050805162550.21"><vh>writeSpecialTree</vh></v>
<v t="ekr.20050809082854.1"><vh>writeToDocutils (sets argv) &amp; helper</vh>
<v t="ekr.20090428082801.64"><vh>handleMissingStyleSheetArgs</vh></v>
</v>
<v t="ekr.20060525102337"><vh>writeNodeToString (New in 4.4.1)</vh></v>
</v>
<v t="ekr.20050811154552"><vh>getDocPart</vh>
<v t="ekr.20060610104435"><vh>&lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;</vh></v>
</v>
<v t="ekr.20050811102607"><vh>skip_literal_block</vh></v>
<v t="ekr.20050811101550.1"><vh>writeBody &amp; helpers</vh>
<v t="ekr.20050811150541"><vh>handleCodeMode &amp; helper</vh>
<v t="ekr.20050811152104"><vh>formatCodeModeLine</vh></v>
<v t="ekr.20050813155021"><vh>rstripList</vh></v>
<v t="ekr.20050813160208"><vh>finishCodePart</vh></v>
</v>
<v t="ekr.20060608094815"><vh>handleDocOnlyMode</vh></v>
<v t="ekr.20060608094815.1"><vh>isAnyDocPart</vh></v>
<v t="ekr.20050811153208"><vh>isSpecialDocPart</vh></v>
<v t="ekr.20050811163802"><vh>isAnySpecialDocPart</vh></v>
<v t="ekr.20050811105438"><vh>removeLeoDirectives</vh></v>
<v t="ekr.20050811105438.1"><vh>handleSpecialDocParts</vh></v>
<v t="ekr.20050805162550.30"><vh>replaceCodeBlockDirectives</vh></v>
</v>
<v t="ekr.20050805162550.26"><vh>writeHeadline &amp; helper</vh>
<v t="ekr.20060608102001"><vh>writeHeadlineHelper</vh></v>
</v>
<v t="ekr.20050810083057"><vh>writeNode</vh></v>
<v t="ekr.20071115061253"><vh>writePreformat</vh></v>
<v t="ekr.20050805162550.23"><vh>writeTree</vh></v>
</v>
<v t="ekr.20050810083314"><vh>Utils</vh>
<v t="ekr.20051202070028"><vh>computeOutputFileName</vh></v>
<v t="ekr.20050805162550.16"><vh>encode</vh></v>
<v t="ekr.20050805162550.20"><vh>report</vh></v>
<v t="ekr.20050810083856"><vh>rstComment</vh></v>
<v t="ekr.20050805162550.19"><vh>underline</vh></v>
<v t="ekr.20050809080031"><vh>write</vh></v>
</v>
<v t="ekr.20050805162550.33"><vh>Support for http plugin</vh>
<v t="ekr.20050815091008.1"><vh>http_addNodeMarker</vh></v>
<v t="ekr.20050805162550.34"><vh>http_endTree &amp; helpers</vh>
<v t="ekr.20050805162550.36"><vh>set_initial_http_attributes</vh></v>
<v t="ekr.20050805162550.38"><vh>find_anchors</vh></v>
<v t="ekr.20050805162550.37"><vh>relocate_references</vh></v>
<v t="ekr.20050805162550.35"><vh>http_attribute_iter</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20181028052650.1"><vh>@file leowapp.py</vh></v>
</v>
<v t="ekr.20190812072047.2"><vh>Pyzo sources</vh>
<v t="ekr.20190812072047.3"><vh>@clean yotonloader.py</vh>
<v t="ekr.20190812072047.4"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072047.5"><vh>@clean __init__.py</vh>
<v t="ekr.20190812074300.1"><vh>&lt;&lt; pyzo.__init__ docstring &gt;&gt;</vh></v>
<v t="ekr.20190812074328.1"><vh>&lt;&lt; pyzo.__init__ imports &gt;&gt;</vh></v>
<v t="ekr.20190812072047.7"><vh>class MyApp(QtWidgets.QApplication)</vh>
<v t="ekr.20190812072047.8"><vh>MyApp.event</vh></v>
</v>
<v t="ekr.20190812090629.1"><vh>banner (new)</vh></v>
<v t="ekr.20190812072047.9"><vh>pyzo_excepthook</vh></v>
<v t="ekr.20190812072047.10"><vh>getResourceDirs</vh></v>
<v t="ekr.20190812072047.11"><vh>resetConfig</vh></v>
<v t="ekr.20190812072047.12"><vh>loadConfig</vh></v>
<v t="ekr.20190812072047.13"><vh>saveConfig</vh></v>
<v t="ekr.20190812072047.14"><vh>pyzo.start</vh></v>
<v t="ekr.20190812074841.1"><vh>&lt;&lt; pyzo.__init__ late assignments &gt;&gt;</vh></v>
</v>
<v t="ekr.20190812072047.15"><vh>@clean __main__.py</vh>
<v t="ekr.20190812072047.17"><vh>main</vh></v>
</v>
<v t="ekr.20190812072047.19"><vh>pyzo/codeeditor</vh>
<v t="ekr.20190812072047.20"><vh>@clean base.py</vh>
<v t="ekr.20190812072047.21"><vh>Declarations</vh></v>
<v t="ekr.20190812072047.22"><vh>class CodeEditorBase(QtWidgets.QPlainTextEdit)</vh>
<v t="ekr.20190812072047.23"><vh>CodeEditorBase.__init__</vh></v>
<v t="ekr.20190812072047.24"><vh>CodeEditorBase._setHighlighter</vh></v>
<v t="ekr.20190812072047.25"><vh>CodeEditorBase.__getOptionSetters</vh></v>
<v t="ekr.20190812072047.26"><vh>CodeEditorBase.__setOptions</vh></v>
<v t="ekr.20190812072047.27"><vh>CodeEditorBase.__initOptions</vh></v>
<v t="ekr.20190812072047.28"><vh>CodeEditorBase.setOptions</vh></v>
<v t="ekr.20190812072047.29"><vh>CodeEditorBase.setFont</vh></v>
<v t="ekr.20190812072047.30"><vh>CodeEditorBase.setZoom</vh></v>
<v t="ekr.20190812072047.31"><vh>CodeEditorBase.getStyleElementDescriptions</vh></v>
<v t="ekr.20190812072047.32"><vh>CodeEditorBase.getStyleElementFormat</vh></v>
<v t="ekr.20190812072047.33"><vh>CodeEditorBase.setStyle</vh></v>
<v t="ekr.20190812072047.34"><vh>CodeEditorBase.showEvent</vh></v>
<v t="ekr.20190812072047.35"><vh>CodeEditorBase.__afterSetStyle</vh></v>
<v t="ekr.20190812072047.36"><vh>CodeEditorBase.indentWidth</vh></v>
<v t="ekr.20190812072047.37"><vh>CodeEditorBase.setIndentWidth</vh></v>
<v t="ekr.20190812072047.38"><vh>CodeEditorBase.indentUsingSpaces</vh></v>
<v t="ekr.20190812072047.39"><vh>CodeEditorBase.setIndentUsingSpaces</vh></v>
<v t="ekr.20190812072047.40"><vh>CodeEditorBase.gotoLine</vh></v>
<v t="ekr.20190812072047.41"><vh>CodeEditorBase.gotoBlock</vh></v>
<v t="ekr.20190812072047.42"><vh>CodeEditorBase.doForSelectedBlocks</vh></v>
<v t="ekr.20190812072047.43"><vh>CodeEditorBase.doForVisibleBlocks</vh></v>
<v t="ekr.20190812072047.44"><vh>CodeEditorBase.indentBlock</vh></v>
<v t="ekr.20190812072047.45"><vh>CodeEditorBase.dedentBlock</vh></v>
<v t="ekr.20190812072047.46"><vh>CodeEditorBase.indentSelection</vh></v>
<v t="ekr.20190812072047.47"><vh>CodeEditorBase.dedentSelection</vh></v>
<v t="ekr.20190812072047.48"><vh>CodeEditorBase.justifyText</vh></v>
<v t="ekr.20190812072047.49"><vh>CodeEditorBase.addLeftMargin</vh></v>
<v t="ekr.20190812072047.50"><vh>CodeEditorBase.getLeftMargin</vh></v>
<v t="ekr.20190812072047.51"><vh>CodeEditorBase.updateMargins</vh></v>
<v t="ekr.20190812072047.52"><vh>CodeEditorBase.toggleCase</vh></v>
</v>
</v>
<v t="ekr.20190812072047.53"><vh>@clean highlighter.py</vh>
<v t="ekr.20190812072047.54"><vh>Declarations</vh></v>
<v t="ekr.20190812072047.55"><vh>class BlockData(QtGui.QTextBlockUserData)</vh>
<v t="ekr.20190812072047.56"><vh>BlockData.__init__</vh></v>
</v>
<v t="ekr.20190812072047.57"><vh>class Highlighter(QtGui.QSyntaxHighlighter)</vh>
<v t="ekr.20190812072047.58"><vh>Highlighter.__init__</vh></v>
<v t="ekr.20190812072047.59"><vh>Highlighter.getCurrentBlockUserData</vh></v>
<v t="ekr.20190812072047.60"><vh>Highlighter.highlightBlock</vh></v>
</v>
</v>
<v t="ekr.20190812072047.61"><vh>@clean manager.py</vh>
<v t="ekr.20190812072047.63"><vh>class Manager</vh>
<v t="ekr.20190812072047.64"><vh>Manager._collectParsers</vh></v>
<v t="ekr.20190812072047.65"><vh>Manager.getParserNames</vh></v>
<v t="ekr.20190812072047.66"><vh>Manager.getParserByName</vh></v>
<v t="ekr.20190812072047.67"><vh>Manager.getStyleElementDescriptionsForAllParsers</vh></v>
<v t="ekr.20190812072047.68"><vh>Manager.suggestParserfromFilenameExtension</vh></v>
<v t="ekr.20190812072047.69"><vh>Manager.suggestParserfromText</vh></v>
<v t="ekr.20190812072047.70"><vh>Manager.suggestParser</vh></v>
<v t="ekr.20190812072047.71"><vh>Manager.registerFilenameExtension</vh></v>
<v t="ekr.20190812072047.72"><vh>Manager.registerShebangKeyword</vh></v>
<v t="ekr.20190812072047.73"><vh>Manager.fontNames</vh></v>
<v t="ekr.20190812072047.74"><vh>Manager.setDefaultFontFamily</vh></v>
<v t="ekr.20190812072047.75"><vh>Manager.defaultFont</vh></v>
</v>
</v>
<v t="ekr.20190812072047.76"><vh>@clean misc.py</vh>
<v t="ekr.20190812072047.77"><vh>Declarations</vh></v>
<v t="ekr.20190812072047.78"><vh>ce_option</vh></v>
<v t="ekr.20190812072047.79"><vh>class _CallbackEventHandler(QtCore.QObject)</vh>
<v t="ekr.20190812072047.80"><vh>_CallbackEventHandler.__init__</vh></v>
<v t="ekr.20190812072047.81"><vh>_CallbackEventHandler.customEvent</vh></v>
<v t="ekr.20190812072047.82"><vh>_CallbackEventHandler.postEventWithCallback</vh></v>
</v>
<v t="ekr.20190812072047.83"><vh>callLater</vh></v>
</v>
<v t="ekr.20190812072047.84"><vh>@clean qt.py</vh>
<v t="ekr.20190812072047.85"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072047.86"><vh>@clean style.py</vh>
<v t="ekr.20190812072047.87"><vh>Declarations</vh></v>
<v t="ekr.20190812072047.88"><vh>class StyleElementDescription</vh>
<v t="ekr.20190812072047.89"><vh>StyleElementDescription.__init__</vh></v>
<v t="ekr.20190812072047.90"><vh>StyleElementDescription.__repr__</vh></v>
<v t="ekr.20190812072047.91"><vh>StyleElementDescription.name</vh></v>
<v t="ekr.20190812072047.92"><vh>StyleElementDescription.key</vh></v>
<v t="ekr.20190812072047.93"><vh>StyleElementDescription.description</vh></v>
<v t="ekr.20190812072047.94"><vh>StyleElementDescription.defaultFormat</vh></v>
</v>
<v t="ekr.20190812072047.95"><vh>class StyleFormat</vh>
<v t="ekr.20190812072047.96"><vh>StyleFormat.__init__</vh></v>
<v t="ekr.20190812072047.97"><vh>StyleFormat._resetProperties</vh></v>
<v t="ekr.20190812072047.98"><vh>StyleFormat.__str__</vh></v>
<v t="ekr.20190812072047.99"><vh>StyleFormat.__repr__</vh></v>
<v t="ekr.20190812072047.100"><vh>StyleFormat.__getitem__</vh></v>
<v t="ekr.20190812072047.101"><vh>StyleFormat.__iter__</vh></v>
<v t="ekr.20190812072047.102"><vh>StyleFormat.update</vh></v>
<v t="ekr.20190812072047.103"><vh>StyleFormat._getValueSafe</vh></v>
<v t="ekr.20190812072047.104"><vh>StyleFormat.fore</vh></v>
<v t="ekr.20190812072047.105"><vh>StyleFormat.back</vh></v>
<v t="ekr.20190812072047.106"><vh>StyleFormat.bold</vh></v>
<v t="ekr.20190812072047.107"><vh>StyleFormat.italic</vh></v>
<v t="ekr.20190812072047.108"><vh>StyleFormat.underline</vh></v>
<v t="ekr.20190812072047.109"><vh>StyleFormat.linestyle</vh></v>
<v t="ekr.20190812072047.110"><vh>StyleFormat.textCharFormat</vh></v>
</v>
</v>
<v t="ekr.20190812072047.111"><vh>@clean textutils.py</vh>
<v t="ekr.20190812072047.112"><vh>class TextReshaper</vh>
<v t="ekr.20190812072047.113"><vh>TextReshaper.__init__</vh></v>
<v t="ekr.20190812072047.114"><vh>TextReshaper.reshapeText</vh></v>
<v t="ekr.20190812072047.115"><vh>TextReshaper.pushLine</vh></v>
<v t="ekr.20190812072047.116"><vh>TextReshaper.pushText</vh></v>
<v t="ekr.20190812072047.117"><vh>TextReshaper.popLines</vh></v>
<v t="ekr.20190812072047.118"><vh>TextReshaper.popText</vh></v>
<v t="ekr.20190812072047.119"><vh>TextReshaper._prefixString</vh></v>
<v t="ekr.20190812072047.120"><vh>TextReshaper._addWordToBuffer</vh></v>
<v t="ekr.20190812072047.121"><vh>TextReshaper._flush</vh></v>
<v t="ekr.20190812072047.122"><vh>TextReshaper._addNewParagraph</vh></v>
<v t="ekr.20190812072047.123"><vh>TextReshaper._popLine</vh></v>
</v>
</v>
<v t="ekr.20190812072047.124"><vh>@clean _test.py</vh>
<v t="ekr.20190812072047.125"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072047.126"><vh>@clean __init__.py</vh>
<v t="ekr.20190812072047.127"><vh>Declarations</vh></v>
<v t="ekr.20190812072047.128"><vh>class CodeEditor</vh></v>
</v>
<v t="ekr.20190812072047.130"><vh>codeeditor/extensions</vh>
<v t="ekr.20190812072047.131"><vh>@clean appearance.py</vh>
<v t="ekr.20190812072047.132"><vh>Declarations</vh></v>
<v t="ekr.20190812072047.133"><vh>class HighlightMatchingOccurrences(object)</vh>
<v t="ekr.20190812072047.134"><vh>HighlightMatchingOccurrences.highlightMatchingOccurrences</vh></v>
<v t="ekr.20190812072047.135"><vh>HighlightMatchingOccurrences.setHighlightMatchingOccurrences</vh></v>
<v t="ekr.20190812072047.136"><vh>HighlightMatchingOccurrences.paintEvent</vh></v>
<v t="ekr.20190812072047.137"><vh>HighlightMatchingOccurrences._doHighlight</vh></v>
</v>
<v t="ekr.20190812072047.138"><vh>class _ParenNotFound(Exception)</vh></v>
<v t="ekr.20190812072047.139"><vh>class _ParenIterator</vh>
<v t="ekr.20190812072047.140"><vh>_ParenIterator.__init__</vh></v>
<v t="ekr.20190812072047.141"><vh>_ParenIterator._getParenTokens</vh></v>
<v t="ekr.20190812072047.142"><vh>_ParenIterator.__iter__</vh></v>
<v t="ekr.20190812072047.143"><vh>_ParenIterator.__next__</vh></v>
</v>
<v t="ekr.20190812072047.144"><vh>class _PlainTextParenIterator</vh>
<v t="ekr.20190812072047.145"><vh>_PlainTextParenIterator.__init__</vh></v>
<v t="ekr.20190812072047.146"><vh>_PlainTextParenIterator.__iter__</vh></v>
<v t="ekr.20190812072047.147"><vh>_PlainTextParenIterator.__next__</vh></v>
</v>
<v t="ekr.20190812072047.148"><vh>class _MatchStatus(enum.Enum)</vh></v>
<v t="ekr.20190812072047.149"><vh>class _MatchResult</vh>
<v t="ekr.20190812072047.150"><vh>_MatchResult.__init__</vh></v>
</v>
<v t="ekr.20190812072047.151"><vh>class HighlightMatchingBracket(object)</vh>
<v t="ekr.20190812072047.152"><vh>HighlightMatchingBracket.highlightMatchingBracket</vh></v>
<v t="ekr.20190812072047.153"><vh>HighlightMatchingBracket.highlightMisMatchingBracket</vh></v>
<v t="ekr.20190812072047.154"><vh>HighlightMatchingBracket.paintEvent</vh></v>
<v t="ekr.20190812072047.155"><vh>HighlightMatchingBracket._highlightSingleChar</vh></v>
<v t="ekr.20190812072047.156"><vh>HighlightMatchingBracket._findMatchingBracket</vh></v>
<v t="ekr.20190812072047.157"><vh>HighlightMatchingBracket._cursorAt</vh></v>
<v t="ekr.20190812072047.158"><vh>HighlightMatchingBracket.setHighlightMatchingBracket</vh></v>
<v t="ekr.20190812072047.159"><vh>HighlightMatchingBracket.setHighlightMisMatchingBracket</vh></v>
</v>
<v t="ekr.20190812072047.160"><vh>class HighlightCurrentLine(object)</vh>
<v t="ekr.20190812072047.161"><vh>HighlightCurrentLine.highlightCurrentLine</vh></v>
<v t="ekr.20190812072047.162"><vh>HighlightCurrentLine.setHighlightCurrentLine</vh></v>
<v t="ekr.20190812072047.163"><vh>HighlightCurrentLine.paintEvent</vh></v>
</v>
<v t="ekr.20190812072047.164"><vh>class IndentationGuides(object)</vh>
<v t="ekr.20190812072047.165"><vh>IndentationGuides.showIndentationGuides</vh></v>
<v t="ekr.20190812072047.166"><vh>IndentationGuides.setShowIndentationGuides</vh></v>
<v t="ekr.20190812072047.167"><vh>IndentationGuides.paintEvent</vh></v>
</v>
<v t="ekr.20190812072047.168"><vh>class FullUnderlines(object)</vh>
<v t="ekr.20190812072047.169"><vh>FullUnderlines.paintEvent</vh></v>
</v>
<v t="ekr.20190812072047.170"><vh>class CodeFolding(object)</vh>
<v t="ekr.20190812072047.171"><vh>CodeFolding.paintEvent</vh></v>
</v>
<v t="ekr.20190812072047.172"><vh>class LongLineIndicator(object)</vh>
<v t="ekr.20190812072047.173"><vh>LongLineIndicator.longLineIndicatorPosition</vh></v>
<v t="ekr.20190812072047.174"><vh>LongLineIndicator.setLongLineIndicatorPosition</vh></v>
<v t="ekr.20190812072047.175"><vh>LongLineIndicator.paintEvent</vh></v>
</v>
<v t="ekr.20190812072047.176"><vh>class ShowWhitespace(object)</vh>
<v t="ekr.20190812072047.177"><vh>ShowWhitespace.showWhitespace</vh></v>
<v t="ekr.20190812072047.178"><vh>ShowWhitespace.setShowWhitespace</vh></v>
</v>
<v t="ekr.20190812072047.179"><vh>class ShowLineEndings(object)</vh>
<v t="ekr.20190812072047.180"><vh>ShowLineEndings.showLineEndings</vh></v>
<v t="ekr.20190812072047.181"><vh>ShowLineEndings.setShowLineEndings</vh></v>
</v>
<v t="ekr.20190812072047.182"><vh>class LineNumbers(object)</vh>
<v t="ekr.20190812072047.183"><vh>class __LineNumberArea(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072047.184"><vh>__LineNumberArea.__init__</vh></v>
<v t="ekr.20190812072047.185"><vh>__LineNumberArea._getY</vh></v>
<v t="ekr.20190812072047.186"><vh>__LineNumberArea.mousePressEvent</vh></v>
<v t="ekr.20190812072047.187"><vh>__LineNumberArea.mouseReleaseEvent</vh></v>
<v t="ekr.20190812072047.188"><vh>__LineNumberArea.mouseMoveEvent</vh></v>
<v t="ekr.20190812072047.189"><vh>__LineNumberArea._handleWholeBlockSelection</vh></v>
<v t="ekr.20190812072047.190"><vh>__LineNumberArea.mouseDoubleClickEvent</vh></v>
<v t="ekr.20190812072047.191"><vh>__LineNumberArea.showLineNumberChoser</vh></v>
<v t="ekr.20190812072047.192"><vh>__LineNumberArea.paintEvent</vh></v>
</v>
<v t="ekr.20190812072047.193"><vh>class LineNumberChoser(QtWidgets.QSpinBox)</vh>
<v t="ekr.20190812072047.194"><vh>LineNumberChoser.__init__</vh></v>
<v t="ekr.20190812072047.195"><vh>LineNumberChoser.reset</vh></v>
<v t="ekr.20190812072047.196"><vh>LineNumberChoser.focusOutEvent</vh></v>
<v t="ekr.20190812072047.197"><vh>LineNumberChoser.keyPressEvent</vh></v>
<v t="ekr.20190812072047.198"><vh>LineNumberChoser.onValueChanged</vh></v>
</v>
<v t="ekr.20190812072047.199"><vh>__init__</vh></v>
<v t="ekr.20190812072047.200"><vh>gotoLinePopup</vh></v>
<v t="ekr.20190812072047.201"><vh>showLineNumbers</vh></v>
<v t="ekr.20190812072047.202"><vh>setShowLineNumbers</vh></v>
<v t="ekr.20190812072047.203"><vh>getLineNumberAreaWidth</vh></v>
<v t="ekr.20190812072047.204"><vh>__onBlockCountChanged</vh></v>
<v t="ekr.20190812072047.205"><vh>resizeEvent</vh></v>
<v t="ekr.20190812072047.206"><vh>paintEvent</vh></v>
</v>
<v t="ekr.20190812072047.207"><vh>class BreakPoints(object)</vh>
<v t="ekr.20190812072047.208"><vh>class __BreakPointArea(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072047.209"><vh>__BreakPointArea.__init__</vh></v>
<v t="ekr.20190812072047.210"><vh>__BreakPointArea._getY</vh></v>
<v t="ekr.20190812072047.211"><vh>__BreakPointArea.mousePressEvent</vh></v>
<v t="ekr.20190812072047.212"><vh>__BreakPointArea.mouseMoveEvent</vh></v>
<v t="ekr.20190812072047.213"><vh>__BreakPointArea.leaveEvent</vh></v>
<v t="ekr.20190812072047.214"><vh>__BreakPointArea._toggleBreakPoint</vh></v>
<v t="ekr.20190812072047.215"><vh>__BreakPointArea.paintEvent</vh></v>
</v>
<v t="ekr.20190812072047.216"><vh>__init__</vh></v>
<v t="ekr.20190812072047.217"><vh>__onBlockCountChanged</vh></v>
<v t="ekr.20190812072047.218"><vh>breakPoints</vh></v>
<v t="ekr.20190812072047.219"><vh>toggleBreakpoint</vh></v>
<v t="ekr.20190812072047.220"><vh>setDebugLineIndicator</vh></v>
<v t="ekr.20190812072047.221"><vh>getBreakPointAreaWidth</vh></v>
<v t="ekr.20190812072047.222"><vh>showBreakPoints</vh></v>
<v t="ekr.20190812072047.223"><vh>setShowBreakPoints</vh></v>
<v t="ekr.20190812072047.224"><vh>resizeEvent</vh></v>
<v t="ekr.20190812072047.225"><vh>paintEvent</vh></v>
</v>
<v t="ekr.20190812072047.226"><vh>class Wrap(object)</vh>
<v t="ekr.20190812072047.227"><vh>Wrap.wrap</vh></v>
<v t="ekr.20190812072047.228"><vh>Wrap.setWrap</vh></v>
</v>
<v t="ekr.20190812072047.229"><vh>class SyntaxHighlighting(object)</vh>
<v t="ekr.20190812072047.230"><vh>SyntaxHighlighting.parser</vh></v>
<v t="ekr.20190812072047.231"><vh>SyntaxHighlighting.setParser</vh></v>
</v>
</v>
<v t="ekr.20190812072047.232"><vh>@clean autocompletion.py</vh>
<v t="ekr.20190812072047.233"><vh>Declarations</vh></v>
<v t="ekr.20190812072047.234"><vh>class CompletionListModel(QtCore.QStringListModel)</vh>
<v t="ekr.20190812072047.235"><vh>CompletionListModel.data</vh></v>
</v>
<v t="ekr.20190812072047.236"><vh>class AutoCompletion(object)</vh>
<v t="ekr.20190812072047.237"><vh>AutoCompletion.__init__</vh></v>
<v t="ekr.20190812072047.238"><vh>AutoCompletion._setHighlightedCompletion</vh></v>
<v t="ekr.20190812072047.239"><vh>AutoCompletion.recentCompletionsList</vh></v>
<v t="ekr.20190812072047.240"><vh>AutoCompletion.setRecentCompletionsList</vh></v>
<v t="ekr.20190812072047.241"><vh>AutoCompletion.completer</vh></v>
<v t="ekr.20190812072047.242"><vh>AutoCompletion.setAutoCompletionAcceptKeys</vh></v>
<v t="ekr.20190812072047.243"><vh>AutoCompletion.setAutocompletPopupSize</vh></v>
<v t="ekr.20190812072048.1"><vh>AutoCompletion.autocompleteShow</vh></v>
<v t="ekr.20190812072048.2"><vh>AutoCompletion.autocompleteAccept</vh></v>
<v t="ekr.20190812072048.3"><vh>AutoCompletion.autocompleteCancel</vh></v>
<v t="ekr.20190812072048.4"><vh>AutoCompletion.onAutoComplete</vh></v>
<v t="ekr.20190812072048.5"><vh>AutoCompletion.autocompleteActive</vh></v>
<v t="ekr.20190812072048.6"><vh>AutoCompletion.__positionAutocompleter</vh></v>
<v t="ekr.20190812072048.7"><vh>AutoCompletion.__updateAutocompleterPrefix</vh></v>
<v t="ekr.20190812072048.8"><vh>AutoCompletion.potentiallyAutoComplete</vh></v>
<v t="ekr.20190812072048.9"><vh>AutoCompletion.keyPressEvent</vh></v>
</v>
</v>
<v t="ekr.20190812072048.10"><vh>@clean behaviour.py</vh>
<v t="ekr.20190812072048.11"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.12"><vh>class MoveLinesUpDown(object)</vh>
<v t="ekr.20190812072048.13"><vh>MoveLinesUpDown.keyPressEvent</vh></v>
<v t="ekr.20190812072048.14"><vh>MoveLinesUpDown._swaplines</vh></v>
</v>
<v t="ekr.20190812072048.15"><vh>class ScrollWithUpDownKeys(object)</vh>
<v t="ekr.20190812072048.16"><vh>ScrollWithUpDownKeys.keyPressEvent</vh></v>
</v>
<v t="ekr.20190812072048.17"><vh>class HomeKey(object)</vh>
<v t="ekr.20190812072048.18"><vh>HomeKey.keyPressEvent</vh></v>
</v>
<v t="ekr.20190812072048.19"><vh>class EndKey(object)</vh>
<v t="ekr.20190812072048.20"><vh>EndKey.keyPressEvent</vh></v>
</v>
<v t="ekr.20190812072048.21"><vh>class NumpadPeriodKey(object)</vh>
<v t="ekr.20190812072048.22"><vh>NumpadPeriodKey.keyPressEvent</vh></v>
</v>
<v t="ekr.20190812072048.23"><vh>class Indentation(object)</vh>
<v t="ekr.20190812072048.24"><vh>Indentation.__cursorIsInLeadingWhitespace</vh></v>
<v t="ekr.20190812072048.25"><vh>Indentation.keyPressEvent</vh></v>
</v>
<v t="ekr.20190812072048.26"><vh>class AutoIndent(object)</vh>
<v t="ekr.20190812072048.27"><vh>AutoIndent.autoIndent</vh></v>
<v t="ekr.20190812072048.28"><vh>AutoIndent.setAutoIndent</vh></v>
</v>
<v t="ekr.20190812072048.29"><vh>class PythonAutoIndent(object)</vh>
<v t="ekr.20190812072048.30"><vh>PythonAutoIndent.keyPressEvent</vh></v>
</v>
<v t="ekr.20190812072048.31"><vh>class SmartCopyAndPaste(object)</vh>
<v t="ekr.20190812072048.32"><vh>SmartCopyAndPaste.__setCursorPositionAndAnchor</vh></v>
<v t="ekr.20190812072048.33"><vh>SmartCopyAndPaste.__ensureCursorBeforeAnchor</vh></v>
<v t="ekr.20190812072048.34"><vh>SmartCopyAndPaste.copy</vh></v>
<v t="ekr.20190812072048.35"><vh>SmartCopyAndPaste.cut</vh></v>
<v t="ekr.20190812072048.36"><vh>SmartCopyAndPaste.paste</vh></v>
<v t="ekr.20190812072048.37"><vh>SmartCopyAndPaste.pasteAndSelect</vh></v>
<v t="ekr.20190812072048.38"><vh>SmartCopyAndPaste._paste</vh></v>
</v>
<v t="ekr.20190812072048.39"><vh>class AutoCloseQuotesAndBrackets(object)</vh>
<v t="ekr.20190812072048.40"><vh>AutoCloseQuotesAndBrackets._get_token_at_cursor</vh></v>
<v t="ekr.20190812072048.41"><vh>AutoCloseQuotesAndBrackets.keyPressEvent</vh></v>
<v t="ekr.20190812072048.42"><vh>AutoCloseQuotesAndBrackets.__keyPressEvent</vh></v>
<v t="ekr.20190812072048.43"><vh>AutoCloseQuotesAndBrackets.__getNextCharacter</vh></v>
<v t="ekr.20190812072048.44"><vh>AutoCloseQuotesAndBrackets._moveCursorLeft</vh></v>
<v t="ekr.20190812072048.45"><vh>AutoCloseQuotesAndBrackets._moveCursorRight</vh></v>
</v>
</v>
<v t="ekr.20190812072048.46"><vh>@clean calltip.py</vh>
<v t="ekr.20190812072048.47"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.48"><vh>class Calltip(object)</vh>
<v t="ekr.20190812072048.49"><vh>class __CalltipLabel(QtWidgets.QLabel)</vh>
<v t="ekr.20190812072048.50"><vh>__CalltipLabel.__init__</vh></v>
<v t="ekr.20190812072048.51"><vh>__CalltipLabel.enterEvent</vh></v>
</v>
<v t="ekr.20190812072048.52"><vh>__init__</vh></v>
<v t="ekr.20190812072048.53"><vh>__afterSetStyle</vh></v>
<v t="ekr.20190812072048.54"><vh>calltipShow</vh></v>
<v t="ekr.20190812072048.55"><vh>calltipCancel</vh></v>
<v t="ekr.20190812072048.56"><vh>calltipActive</vh></v>
<v t="ekr.20190812072048.57"><vh>focusOutEvent</vh></v>
<v t="ekr.20190812072048.58"><vh>keyPressEvent</vh></v>
</v>
</v>
<v t="ekr.20190812072048.59"><vh>@clean __init__.py</vh></v>
</v>
<v t="ekr.20190812072048.61"><vh>codeeditor/parsers</vh>
<v t="ekr.20190812072048.121"><vh>@clean __init__.py</vh>
<v t="ekr.20190812072048.122"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.123"><vh>class BlockState(object)</vh>
<v t="ekr.20190812072048.124"><vh>BlockState.__init__</vh></v>
<v t="ekr.20190812072048.125"><vh>BlockState.state</vh></v>
<v t="ekr.20190812072048.126"><vh>BlockState.info</vh></v>
</v>
<v t="ekr.20190812072048.127"><vh>class Parser(object)</vh>
<v t="ekr.20190812072048.128"><vh>Parser.parseLine</vh></v>
<v t="ekr.20190812072048.129"><vh>Parser.name</vh></v>
<v t="ekr.20190812072048.130"><vh>Parser.__repr__</vh></v>
<v t="ekr.20190812072048.131"><vh>Parser.keywords</vh></v>
<v t="ekr.20190812072048.132"><vh>Parser.filenameExtensions</vh></v>
<v t="ekr.20190812072048.133"><vh>Parser.shebangKeywords</vh></v>
<v t="ekr.20190812072048.134"><vh>Parser.getStyleElementDescriptions</vh></v>
<v t="ekr.20190812072048.135"><vh>Parser.getUsedTokens</vh></v>
<v t="ekr.20190812072048.136"><vh>Parser._isTodoItem</vh></v>
</v>
</v>
<v t="ekr.20190812072048.66"><vh>@clean c_parser.py</vh>
<v t="ekr.20190812072048.67"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.68"><vh>class MultilineCommentToken(CommentToken)</vh></v>
<v t="ekr.20190812072048.69"><vh>class CharToken(Token)</vh></v>
<v t="ekr.20190812072048.70"><vh>class CParser(Parser)</vh>
<v t="ekr.20190812072048.71"><vh>CParser.parseLine</vh></v>
<v t="ekr.20190812072048.72"><vh>CParser._findEndOfComment</vh></v>
<v t="ekr.20190812072048.73"><vh>CParser._findEndOfString</vh></v>
<v t="ekr.20190812072048.74"><vh>CParser._findNextToken</vh></v>
</v>
</v>
<v t="ekr.20190812072048.62"><vh>@clean cython_parser.py</vh>
<v t="ekr.20190812072048.63"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.64"><vh>class CythonParser(PythonParser)</vh>
<v t="ekr.20190812072048.65"><vh>CythonParser._identifierState</vh></v>
</v>
</v>
<v t="ekr.20190812072048.75"><vh>@clean python_parser.py</vh>
<v t="ekr.20190812072048.76"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.77"><vh>class MultilineStringToken(StringToken)</vh></v>
<v t="ekr.20190812072048.78"><vh>class CellCommentToken(CommentToken)</vh></v>
<v t="ekr.20190812072048.79"><vh>class PythonParser(Parser)</vh>
<v t="ekr.20190812072048.80"><vh>PythonParser._identifierState</vh></v>
<v t="ekr.20190812072048.81"><vh>PythonParser.parseLine</vh></v>
<v t="ekr.20190812072048.82"><vh>PythonParser._findEndOfString</vh></v>
<v t="ekr.20190812072048.83"><vh>PythonParser._findNextToken</vh></v>
</v>
<v t="ekr.20190812072048.84"><vh>class Python2Parser(PythonParser)</vh></v>
<v t="ekr.20190812072048.85"><vh>class Python3Parser(PythonParser)</vh></v>
</v>
<v t="ekr.20190812072048.86"><vh>@clean s_expr_parser.py</vh>
<v t="ekr.20190812072048.87"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.88"><vh>class SExprParser(Parser)</vh>
<v t="ekr.20190812072048.89"><vh>SExprParser.parseLine</vh></v>
<v t="ekr.20190812072048.90"><vh>SExprParser._skip_whitespace</vh></v>
<v t="ekr.20190812072048.91"><vh>SExprParser._get_token_for_word</vh></v>
</v>
<v t="ekr.20190812072048.92"><vh>class WatParser(SExprParser)</vh></v>
</v>
<v t="ekr.20190812072048.93"><vh>@clean tokens.py</vh>
<v t="ekr.20190812072048.94"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.95"><vh>class Token(object)</vh>
<v t="ekr.20190812072048.96"><vh>Token.__init__</vh></v>
<v t="ekr.20190812072048.97"><vh>Token.__str__</vh></v>
<v t="ekr.20190812072048.98"><vh>Token.__unicode__</vh></v>
<v t="ekr.20190812072048.99"><vh>Token.__repr__</vh></v>
<v t="ekr.20190812072048.100"><vh>Token.__len__</vh></v>
<v t="ekr.20190812072048.101"><vh>Token._getName</vh></v>
<v t="ekr.20190812072048.102"><vh>Token.getDefaultStyleFormat</vh></v>
<v t="ekr.20190812072048.103"><vh>Token.name</vh></v>
<v t="ekr.20190812072048.104"><vh>Token.description</vh></v>
</v>
<v t="ekr.20190812072048.105"><vh>class CommentToken(Token)</vh></v>
<v t="ekr.20190812072048.106"><vh>class TodoCommentToken(CommentToken)</vh></v>
<v t="ekr.20190812072048.107"><vh>class StringToken(Token)</vh></v>
<v t="ekr.20190812072048.108"><vh>class UnterminatedStringToken(StringToken)</vh></v>
<v t="ekr.20190812072048.109"><vh>class TextToken(Token)</vh></v>
<v t="ekr.20190812072048.110"><vh>class IdentifierToken(TextToken)</vh></v>
<v t="ekr.20190812072048.111"><vh>class NonIdentifierToken(TextToken)</vh></v>
<v t="ekr.20190812072048.112"><vh>class KeywordToken(IdentifierToken)</vh></v>
<v t="ekr.20190812072048.113"><vh>class BuiltinsToken(IdentifierToken)</vh></v>
<v t="ekr.20190812072048.114"><vh>class InstanceToken(IdentifierToken)</vh></v>
<v t="ekr.20190812072048.115"><vh>class NumberToken(IdentifierToken)</vh></v>
<v t="ekr.20190812072048.116"><vh>class FunctionNameToken(IdentifierToken)</vh></v>
<v t="ekr.20190812072048.117"><vh>class ClassNameToken(IdentifierToken)</vh></v>
<v t="ekr.20190812072048.118"><vh>class ParenthesisToken(TextToken)</vh></v>
<v t="ekr.20190812072048.119"><vh>class OpenParenToken(ParenthesisToken)</vh></v>
<v t="ekr.20190812072048.120"><vh>class CloseParenToken(ParenthesisToken)</vh></v>
</v>
</v>
</v>
<v t="ekr.20190812072048.138"><vh>pyzo/core</vh>
<v t="ekr.20190812072048.139"><vh>@clean about.py</vh>
<v t="ekr.20190812072048.140"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.141"><vh>class AboutDialog(QtWidgets.QDialog)</vh>
<v t="ekr.20190812072048.142"><vh>AboutDialog.__init__</vh></v>
<v t="ekr.20190812072048.143"><vh>AboutDialog.addTab</vh></v>
<v t="ekr.20190812072048.144"><vh>AboutDialog.createGeneralTab</vh></v>
<v t="ekr.20190812072048.145"><vh>AboutDialog.createContributorsTab</vh></v>
<v t="ekr.20190812072048.146"><vh>AboutDialog.createLicenseTab</vh></v>
</v>
</v>
<v t="ekr.20190812072048.147"><vh>@clean assistant.py</vh>
<v t="ekr.20190812072048.148"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.149"><vh>class Settings(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072048.150"><vh>Settings.__init__</vh></v>
<v t="ekr.20190812072048.151"><vh>Settings.add_doc</vh></v>
<v t="ekr.20190812072048.152"><vh>Settings.add_doc_do</vh></v>
<v t="ekr.20190812072048.153"><vh>Settings.del_doc</vh></v>
<v t="ekr.20190812072048.154"><vh>Settings.del_doc_do</vh></v>
</v>
<v t="ekr.20190812072048.155"><vh>class HelpBrowser(QtWidgets.QTextBrowser)</vh>
<v t="ekr.20190812072048.156"><vh>HelpBrowser.__init__</vh></v>
<v t="ekr.20190812072048.157"><vh>HelpBrowser.handle_url</vh></v>
<v t="ekr.20190812072048.158"><vh>HelpBrowser.loadResource</vh></v>
</v>
<v t="ekr.20190812072048.159"><vh>class PyzoAssistant(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072048.160"><vh>PyzoAssistant.__init__</vh></v>
<v t="ekr.20190812072048.161"><vh>PyzoAssistant.goSearch</vh></v>
<v t="ekr.20190812072048.162"><vh>PyzoAssistant.onIndexingStarted</vh></v>
<v t="ekr.20190812072048.163"><vh>PyzoAssistant.onIndexingFinished</vh></v>
<v t="ekr.20190812072048.164"><vh>PyzoAssistant.find_best_page</vh></v>
<v t="ekr.20190812072048.165"><vh>PyzoAssistant.onSearchFinish</vh></v>
<v t="ekr.20190812072048.166"><vh>PyzoAssistant.showHelpForTerm</vh></v>
</v>
</v>
<v t="ekr.20190812072048.167"><vh>@clean baseTextCtrl.py</vh>
<v t="ekr.20190812072048.168"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.169"><vh>normalizePath</vh></v>
<v t="ekr.20190812072048.170"><vh>parseLine_autocomplete</vh></v>
<v t="ekr.20190812072048.171"><vh>parseLine_signature</vh></v>
<v t="ekr.20190812072048.172"><vh>class KeyEvent</vh>
<v t="ekr.20190812072048.173"><vh>KeyEvent.__init__</vh></v>
</v>
<v t="ekr.20190812072048.174"><vh>makeBytes</vh></v>
<v t="ekr.20190812072048.175"><vh>getAllScintillas</vh></v>
<v t="ekr.20190812072048.176"><vh>class BaseTextCtrl(codeeditor.CodeEditor)</vh>
<v t="ekr.20190812072048.177"><vh>BaseTextCtrl.__init__</vh></v>
<v t="ekr.20190812072048.178"><vh>BaseTextCtrl.setAutoCompletionAcceptKeysFromStr</vh></v>
<v t="ekr.20190812072048.179"><vh>BaseTextCtrl._isValidPython</vh></v>
<v t="ekr.20190812072048.180"><vh>BaseTextCtrl.introspect</vh></v>
<v t="ekr.20190812072048.181"><vh>BaseTextCtrl._introspectNow</vh></v>
<v t="ekr.20190812072048.182"><vh>BaseTextCtrl.processCallTip</vh></v>
<v t="ekr.20190812072048.183"><vh>BaseTextCtrl.processAutoComp</vh></v>
<v t="ekr.20190812072048.184"><vh>BaseTextCtrl._onDoubleClick</vh></v>
<v t="ekr.20190812072048.185"><vh>BaseTextCtrl.processHelp</vh></v>
<v t="ekr.20190812072048.186"><vh>BaseTextCtrl.updateHelp</vh></v>
<v t="ekr.20190812072048.187"><vh>BaseTextCtrl.event</vh></v>
<v t="ekr.20190812072048.188"><vh>BaseTextCtrl.keyPressEvent</vh></v>
</v>
<v t="ekr.20190812072048.189"><vh>class CallTipObject</vh>
<v t="ekr.20190812072048.190"><vh>CallTipObject.__init__</vh></v>
<v t="ekr.20190812072048.191"><vh>CallTipObject.tryUsingBuffer</vh></v>
<v t="ekr.20190812072048.192"><vh>CallTipObject.finish</vh></v>
<v t="ekr.20190812072048.193"><vh>CallTipObject.setBuffer</vh></v>
<v t="ekr.20190812072048.194"><vh>CallTipObject._finish</vh></v>
</v>
<v t="ekr.20190812072048.195"><vh>class AutoCompObject</vh>
<v t="ekr.20190812072048.196"><vh>AutoCompObject.__init__</vh></v>
<v t="ekr.20190812072048.197"><vh>AutoCompObject.addNames</vh></v>
<v t="ekr.20190812072048.198"><vh>AutoCompObject.tryUsingBuffer</vh></v>
<v t="ekr.20190812072048.199"><vh>AutoCompObject.finish</vh></v>
<v t="ekr.20190812072048.200"><vh>AutoCompObject.setBuffer</vh></v>
<v t="ekr.20190812072048.201"><vh>AutoCompObject._finish</vh></v>
<v t="ekr.20190812072048.202"><vh>AutoCompObject.nameInImportNames</vh></v>
</v>
</v>
<v t="ekr.20190812072048.203"><vh>@clean codeparser.py</vh>
<v t="ekr.20190812072048.204"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.205"><vh>class Job</vh>
<v t="ekr.20190812072048.206"><vh>Job.__init__</vh></v>
</v>
<v t="ekr.20190812072048.207"><vh>class Result</vh>
<v t="ekr.20190812072048.208"><vh>Result.__init__</vh></v>
<v t="ekr.20190812072048.209"><vh>Result.isMatch</vh></v>
</v>
<v t="ekr.20190812072048.210"><vh>class Parser(threading.Thread)</vh>
<v t="ekr.20190812072048.211"><vh>Parser.__init__</vh></v>
<v t="ekr.20190812072048.212"><vh>Parser.stop</vh></v>
<v t="ekr.20190812072048.213"><vh>Parser.parseThis</vh></v>
<v t="ekr.20190812072048.214"><vh>Parser.getFictiveNameSpace</vh></v>
<v t="ekr.20190812072048.215"><vh>Parser.getFictiveClass</vh></v>
<v t="ekr.20190812072048.216"><vh>Parser.getFictiveSignature</vh></v>
<v t="ekr.20190812072048.217"><vh>Parser.getFictiveImports</vh></v>
<v t="ekr.20190812072048.218"><vh>Parser._getResult</vh></v>
<v t="ekr.20190812072048.219"><vh>Parser._getFictiveItem</vh></v>
<v t="ekr.20190812072048.220"><vh>Parser._getFictiveCurrentClass</vh></v>
<v t="ekr.20190812072048.221"><vh>Parser.run</vh></v>
<v t="ekr.20190812072048.222"><vh>Parser._analyze</vh></v>
</v>
<v t="ekr.20190812072048.223"><vh>class FictiveObject</vh>
<v t="ekr.20190812072048.224"><vh>FictiveObject.__init__</vh></v>
</v>
<v t="ekr.20190812072048.225"><vh>IsValidName</vh></v>
<v t="ekr.20190812072048.226"><vh>ParseImport</vh></v>
<v t="ekr.20190812072048.227"><vh>findString</vh></v>
<v t="ekr.20190812072048.228"><vh>_findString</vh></v>
<v t="ekr.20190812072048.229"><vh>washMultilineStrings</vh></v>
</v>
<v t="ekr.20190812072048.230"><vh>@clean commandline.py</vh>
<v t="ekr.20190812072048.231"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.232"><vh>class Server(RequestServer)</vh>
<v t="ekr.20190812072048.233"><vh>Server.handle_request</vh></v>
</v>
<v t="ekr.20190812072048.234"><vh>handle_command</vh></v>
<v t="ekr.20190812072048.235"><vh>handle_cmd_args</vh></v>
<v t="ekr.20190812072048.236"><vh>stop_our_server</vh></v>
<v t="ekr.20190812072048.237"><vh>is_our_server_running</vh></v>
<v t="ekr.20190812072048.238"><vh>is_pyzo_server_running</vh></v>
</v>
<v t="ekr.20190812072048.239"><vh>@clean compactTabWidget.py</vh>
<v t="ekr.20190812072048.240"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.241"><vh>class TabData</vh>
<v t="ekr.20190812072048.242"><vh>TabData.__init__</vh></v>
</v>
<v t="ekr.20190812072048.243"><vh>class CompactTabBar(QtWidgets.QTabBar)</vh>
<v t="ekr.20190812072048.244"><vh>CompactTabBar.__init__</vh></v>
<v t="ekr.20190812072048.245"><vh>CompactTabBar._compactTabBarData</vh></v>
<v t="ekr.20190812072048.246"><vh>CompactTabBar.mouseDoubleClickEvent</vh></v>
<v t="ekr.20190812072048.247"><vh>CompactTabBar.mousePressEvent</vh></v>
<v t="ekr.20190812072048.248"><vh>CompactTabBar.setTabData</vh></v>
<v t="ekr.20190812072048.249"><vh>CompactTabBar.tabData</vh></v>
<v t="ekr.20190812072048.250"><vh>CompactTabBar.setTabText</vh></v>
<v t="ekr.20190812072048.251"><vh>CompactTabBar.tabText</vh></v>
<v t="ekr.20190812072048.252"><vh>CompactTabBar.tabInserted</vh></v>
<v t="ekr.20190812072048.253"><vh>CompactTabBar.tabRemoved</vh></v>
<v t="ekr.20190812072048.254"><vh>CompactTabBar.resizeEvent</vh></v>
<v t="ekr.20190812072048.255"><vh>CompactTabBar.showEvent</vh></v>
<v t="ekr.20190812072048.256"><vh>CompactTabBar.alignTabs</vh></v>
<v t="ekr.20190812072048.257"><vh>CompactTabBar._alignRecursive</vh></v>
<v t="ekr.20190812072048.258"><vh>CompactTabBar._getAllNames</vh></v>
<v t="ekr.20190812072048.259"><vh>CompactTabBar._setMaxWidthOfAllItems</vh></v>
</v>
<v t="ekr.20190812072048.260"><vh>class CompactTabWidget(QtWidgets.QTabWidget)</vh>
<v t="ekr.20190812072048.261"><vh>CompactTabWidget.__init__</vh></v>
<v t="ekr.20190812072048.262"><vh>CompactTabWidget.setTabData</vh></v>
<v t="ekr.20190812072048.263"><vh>CompactTabWidget.tabData</vh></v>
<v t="ekr.20190812072048.264"><vh>CompactTabWidget.setTabText</vh></v>
<v t="ekr.20190812072048.265"><vh>CompactTabWidget.tabText</vh></v>
</v>
</v>
<v t="ekr.20190812072048.266"><vh>@clean editor.py</vh>
<v t="ekr.20190812072048.267"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.268"><vh>determineEncoding</vh></v>
<v t="ekr.20190812072048.269"><vh>determineLineEnding</vh></v>
<v t="ekr.20190812072048.270"><vh>determineIndentation</vh></v>
<v t="ekr.20190812072048.271"><vh>createEditor</vh></v>
<v t="ekr.20190812072048.272"><vh>class PyzoEditor(BaseTextCtrl)</vh>
<v t="ekr.20190812072048.273"><vh>PyzoEditor.__init__</vh></v>
<v t="ekr.20190812072048.274"><vh>PyzoEditor.name</vh></v>
<v t="ekr.20190812072048.275"><vh>PyzoEditor.filename</vh></v>
<v t="ekr.20190812072048.276"><vh>PyzoEditor.lineEndings</vh></v>
<v t="ekr.20190812072048.277"><vh>PyzoEditor.lineEndings</vh></v>
<v t="ekr.20190812072048.278"><vh>PyzoEditor.lineEndingsHumanReadable</vh></v>
<v t="ekr.20190812072048.279"><vh>PyzoEditor.encoding</vh></v>
<v t="ekr.20190812072048.280"><vh>PyzoEditor.encoding</vh></v>
<v t="ekr.20190812072048.281"><vh>PyzoEditor.justifyText</vh></v>
<v t="ekr.20190812072048.282"><vh>PyzoEditor.showRunCursor</vh></v>
<v t="ekr.20190812072048.283"><vh>PyzoEditor.id</vh></v>
<v t="ekr.20190812072048.284"><vh>PyzoEditor.focusInEvent</vh></v>
<v t="ekr.20190812072048.285"><vh>PyzoEditor.testWhetherFileWasChanged</vh></v>
<v t="ekr.20190812072048.286"><vh>PyzoEditor._onModificationChanged</vh></v>
<v t="ekr.20190812072048.287"><vh>PyzoEditor._onModified</vh></v>
<v t="ekr.20190812072048.288"><vh>PyzoEditor.dragMoveEvent</vh></v>
<v t="ekr.20190812072048.289"><vh>PyzoEditor.dropEvent</vh></v>
<v t="ekr.20190812072048.290"><vh>PyzoEditor.showEvent</vh></v>
<v t="ekr.20190812072048.291"><vh>PyzoEditor.setTitleInMainWindow</vh></v>
<v t="ekr.20190812072048.292"><vh>PyzoEditor.save</vh></v>
<v t="ekr.20190812072048.293"><vh>PyzoEditor.reload</vh></v>
<v t="ekr.20190812072048.294"><vh>PyzoEditor.deleteLines</vh></v>
<v t="ekr.20190812072048.295"><vh>PyzoEditor.duplicateLines</vh></v>
<v t="ekr.20190812072048.296"><vh>PyzoEditor.commentCode</vh></v>
<v t="ekr.20190812072048.297"><vh>PyzoEditor.uncommentCode</vh></v>
<v t="ekr.20190812072048.298"><vh>PyzoEditor.gotoDef</vh></v>
<v t="ekr.20190812072048.299"><vh>PyzoEditor.processCallTip</vh></v>
<v t="ekr.20190812072048.300"><vh>PyzoEditor.processAutoComp</vh></v>
</v>
</v>
<v t="ekr.20190812072048.301"><vh>@clean editorTabs.py</vh>
<v t="ekr.20190812072048.302"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.303"><vh>simpleDialog</vh></v>
<v t="ekr.20190812072048.304"><vh>get_shortest_unique_filename</vh></v>
<v t="ekr.20190812072048.305"><vh>class FileItem</vh>
<v t="ekr.20190812072048.306"><vh>FileItem.__init__</vh></v>
<v t="ekr.20190812072048.307"><vh>FileItem.editor</vh></v>
<v t="ekr.20190812072048.308"><vh>FileItem.id</vh></v>
<v t="ekr.20190812072048.309"><vh>FileItem.filename</vh></v>
<v t="ekr.20190812072048.310"><vh>FileItem.name</vh></v>
<v t="ekr.20190812072048.311"><vh>FileItem.dirty</vh></v>
<v t="ekr.20190812072048.312"><vh>FileItem.pinned</vh></v>
</v>
<v t="ekr.20190812072048.313"><vh>class FindReplaceWidget(QtWidgets.QFrame)</vh>
<v t="ekr.20190812072048.314"><vh>FindReplaceWidget.__init__</vh></v>
<v t="ekr.20190812072048.315"><vh>FindReplaceWidget.autoHideTimerReset</vh></v>
<v t="ekr.20190812072048.316"><vh>FindReplaceWidget.autoHideTimerCallback</vh></v>
<v t="ekr.20190812072048.317"><vh>FindReplaceWidget.hideMe</vh></v>
<v t="ekr.20190812072048.318"><vh>FindReplaceWidget.event</vh></v>
<v t="ekr.20190812072048.319"><vh>FindReplaceWidget.handleReplacePossible</vh></v>
<v t="ekr.20190812072048.320"><vh>FindReplaceWidget.startFind</vh></v>
<v t="ekr.20190812072048.321"><vh>FindReplaceWidget.notifyPassBeginEnd</vh></v>
<v t="ekr.20190812072048.322"><vh>FindReplaceWidget.resetAppearance</vh></v>
<v t="ekr.20190812072048.323"><vh>FindReplaceWidget.selectFindText</vh></v>
<v t="ekr.20190812072048.324"><vh>FindReplaceWidget.findNext</vh></v>
<v t="ekr.20190812072048.325"><vh>FindReplaceWidget.findPrevious</vh></v>
<v t="ekr.20190812072048.326"><vh>FindReplaceWidget.findSelection</vh></v>
<v t="ekr.20190812072048.327"><vh>FindReplaceWidget.findSelectionBw</vh></v>
<v t="ekr.20190812072048.328"><vh>FindReplaceWidget.find</vh></v>
<v t="ekr.20190812072048.329"><vh>FindReplaceWidget.replace</vh></v>
<v t="ekr.20190812072048.330"><vh>FindReplaceWidget.replaceOne</vh></v>
<v t="ekr.20190812072048.331"><vh>FindReplaceWidget.replaceAll</vh></v>
<v t="ekr.20190812072048.332"><vh>FindReplaceWidget.replaceInAllFiles</vh></v>
</v>
<v t="ekr.20190812072048.333"><vh>class FileTabWidget(CompactTabWidget)</vh>
<v t="ekr.20190812072048.334"><vh>FileTabWidget.__init__</vh></v>
<v t="ekr.20190812072048.335"><vh>FileTabWidget.setTitleInMainWindowWhenTabChanged</vh></v>
<v t="ekr.20190812072048.336"><vh>FileTabWidget.items</vh></v>
<v t="ekr.20190812072048.337"><vh>FileTabWidget.currentItem</vh></v>
<v t="ekr.20190812072048.338"><vh>FileTabWidget.getItemAt</vh></v>
<v t="ekr.20190812072048.339"><vh>FileTabWidget.mainItem</vh></v>
<v t="ekr.20190812072048.340"><vh>FileTabWidget.trackHistory</vh></v>
<v t="ekr.20190812072048.341"><vh>FileTabWidget.setCurrentItem</vh></v>
<v t="ekr.20190812072048.342"><vh>FileTabWidget.selectPreviousItem</vh></v>
<v t="ekr.20190812072048.343"><vh>FileTabWidget.onClose</vh></v>
<v t="ekr.20190812072048.344"><vh>FileTabWidget.removeTab</vh></v>
<v t="ekr.20190812072048.345"><vh>FileTabWidget.addItem</vh></v>
<v t="ekr.20190812072048.346"><vh>FileTabWidget.updateItemsFull</vh></v>
<v t="ekr.20190812072048.347"><vh>FileTabWidget.updateItems</vh></v>
</v>
<v t="ekr.20190812072048.348"><vh>class EditorTabs(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072048.349"><vh>EditorTabs.__init__</vh></v>
<v t="ekr.20190812072048.350"><vh>EditorTabs.addContextMenu</vh></v>
<v t="ekr.20190812072048.351"><vh>EditorTabs.contextMenuTriggered</vh></v>
<v t="ekr.20190812072048.352"><vh>EditorTabs.onCurrentChanged</vh></v>
<v t="ekr.20190812072048.353"><vh>EditorTabs.getCurrentEditor</vh></v>
<v t="ekr.20190812072048.354"><vh>EditorTabs.getMainEditor</vh></v>
<v t="ekr.20190812072048.355"><vh>EditorTabs.__iter__</vh></v>
<v t="ekr.20190812072048.356"><vh>EditorTabs.updateBreakPoints</vh></v>
<v t="ekr.20190812072048.357"><vh>EditorTabs.setDebugLineIndicators</vh></v>
<v t="ekr.20190812072048.358"><vh>EditorTabs.dragEnterEvent</vh></v>
<v t="ekr.20190812072048.359"><vh>EditorTabs.dropEvent</vh></v>
<v t="ekr.20190812072048.360"><vh>EditorTabs.newFile</vh></v>
<v t="ekr.20190812072048.361"><vh>EditorTabs.openFile</vh></v>
<v t="ekr.20190812072048.362"><vh>EditorTabs.openDir</vh></v>
<v t="ekr.20190812072048.363"><vh>EditorTabs.loadFile</vh></v>
<v t="ekr.20190812072048.364"><vh>EditorTabs.loadDir</vh></v>
<v t="ekr.20190812072048.365"><vh>EditorTabs.saveFileAs</vh></v>
<v t="ekr.20190812072048.366"><vh>EditorTabs.saveFile</vh></v>
<v t="ekr.20190812072048.367"><vh>EditorTabs.saveAllFiles</vh></v>
<v t="ekr.20190812072048.368"><vh>EditorTabs._get_action_texts</vh></v>
<v t="ekr.20190812072048.369"><vh>EditorTabs.askToSaveFileIfDirty</vh></v>
<v t="ekr.20190812072048.370"><vh>EditorTabs.closeFile</vh></v>
<v t="ekr.20190812072048.371"><vh>EditorTabs.closeAllFiles</vh></v>
<v t="ekr.20190812072048.372"><vh>EditorTabs.saveEditorState</vh></v>
<v t="ekr.20190812072048.373"><vh>EditorTabs.restoreEditorState</vh></v>
<v t="ekr.20190812072048.374"><vh>EditorTabs._getCurrentOpenFilesAsSsdfList</vh></v>
<v t="ekr.20190812072048.375"><vh>EditorTabs._setCurrentOpenFilesAsSsdfList</vh></v>
<v t="ekr.20190812072048.376"><vh>EditorTabs.closeAll</vh></v>
</v>
</v>
<v t="ekr.20190812072048.377"><vh>@clean history.py</vh>
<v t="ekr.20190812072048.378"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.379"><vh>class CommandHistory(QtCore.QObject)</vh>
<v t="ekr.20190812072048.380"><vh>CommandHistory.__init__</vh></v>
<v t="ekr.20190812072048.381"><vh>CommandHistory._load</vh></v>
<v t="ekr.20190812072048.382"><vh>CommandHistory.save</vh></v>
<v t="ekr.20190812072048.383"><vh>CommandHistory.get_commands</vh></v>
<v t="ekr.20190812072048.384"><vh>CommandHistory.append</vh></v>
<v t="ekr.20190812072048.385"><vh>CommandHistory.pop</vh></v>
<v t="ekr.20190812072048.386"><vh>CommandHistory.find_starting_with</vh></v>
<v t="ekr.20190812072048.387"><vh>CommandHistory.find_all</vh></v>
</v>
</v>
<v t="ekr.20190812072048.388"><vh>@clean icons.py</vh>
<v t="ekr.20190812072048.389"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.390"><vh>class IconArtist</vh>
<v t="ekr.20190812072048.391"><vh>IconArtist.__init__</vh></v>
<v t="ekr.20190812072048.392"><vh>IconArtist.finish</vh></v>
<v t="ekr.20190812072048.393"><vh>IconArtist._getPixmap</vh></v>
<v t="ekr.20190812072048.394"><vh>IconArtist.setPenColor</vh></v>
<v t="ekr.20190812072048.395"><vh>IconArtist.addLayer</vh></v>
<v t="ekr.20190812072048.396"><vh>IconArtist.addLine</vh></v>
<v t="ekr.20190812072048.397"><vh>IconArtist.addPoint</vh></v>
<v t="ekr.20190812072048.398"><vh>IconArtist.addMenuArrow</vh></v>
</v>
<v t="ekr.20190812072048.399"><vh>class TabCloseButton(QtWidgets.QToolButton)</vh>
<v t="ekr.20190812072048.400"><vh>TabCloseButton.__init__</vh></v>
<v t="ekr.20190812072048.401"><vh>TabCloseButton.mousePressEvent</vh></v>
<v t="ekr.20190812072048.402"><vh>TabCloseButton.enterEvent</vh></v>
<v t="ekr.20190812072048.403"><vh>TabCloseButton.leaveEvent</vh></v>
<v t="ekr.20190812072048.404"><vh>TabCloseButton._createCrossPixmap</vh></v>
<v t="ekr.20190812072048.405"><vh>TabCloseButton.getCrossIcon1</vh></v>
<v t="ekr.20190812072048.406"><vh>TabCloseButton.getCrossIcon2</vh></v>
</v>
<v t="ekr.20190812072048.407"><vh>class ToolButtonWithMenuIndication(QtWidgets.QToolButton)</vh>
<v t="ekr.20190812072048.408"><vh>ToolButtonWithMenuIndication.__init__</vh></v>
<v t="ekr.20190812072048.409"><vh>ToolButtonWithMenuIndication.mousePressEvent</vh></v>
<v t="ekr.20190812072048.410"><vh>ToolButtonWithMenuIndication.mouseMoveEvent</vh></v>
<v t="ekr.20190812072048.411"><vh>ToolButtonWithMenuIndication.mouseReleaseEvent</vh></v>
<v t="ekr.20190812072048.412"><vh>ToolButtonWithMenuIndication.enterEvent</vh></v>
<v t="ekr.20190812072048.413"><vh>ToolButtonWithMenuIndication.leaveEvent</vh></v>
<v t="ekr.20190812072048.414"><vh>ToolButtonWithMenuIndication.setIcon</vh></v>
<v t="ekr.20190812072048.415"><vh>ToolButtonWithMenuIndication._createMenuArrowPixmap</vh></v>
</v>
<v t="ekr.20190812072048.416"><vh>class TabToolButton(QtWidgets.QToolButton)</vh>
<v t="ekr.20190812072048.417"><vh>TabToolButton.__init__</vh></v>
<v t="ekr.20190812072048.418"><vh>TabToolButton.mousePressEvent</vh></v>
</v>
<v t="ekr.20190812072048.419"><vh>class TabToolButtonWithCloseButton(TabToolButton)</vh>
<v t="ekr.20190812072048.420"><vh>TabToolButtonWithCloseButton.__init__</vh></v>
<v t="ekr.20190812072048.421"><vh>TabToolButtonWithCloseButton._isOverCross</vh></v>
<v t="ekr.20190812072048.422"><vh>TabToolButtonWithCloseButton.mousePressEvent</vh></v>
<v t="ekr.20190812072048.423"><vh>TabToolButtonWithCloseButton.mouseReleaseEvent</vh></v>
<v t="ekr.20190812072048.424"><vh>TabToolButtonWithCloseButton.mouseMoveEvent</vh></v>
<v t="ekr.20190812072048.425"><vh>TabToolButtonWithCloseButton.leaveEvent</vh></v>
<v t="ekr.20190812072048.426"><vh>TabToolButtonWithCloseButton.setIcon</vh></v>
<v t="ekr.20190812072048.427"><vh>TabToolButtonWithCloseButton._createMenuArrowPixmap</vh></v>
<v t="ekr.20190812072048.428"><vh>TabToolButtonWithCloseButton._createCrossPixmap</vh></v>
<v t="ekr.20190812072048.429"><vh>TabToolButtonWithCloseButton.getCrossPixmap1</vh></v>
<v t="ekr.20190812072048.430"><vh>TabToolButtonWithCloseButton.getCrossPixmap2</vh></v>
</v>
<v t="ekr.20190812072048.431"><vh>class EditorTabToolButton(TabToolButtonWithCloseButton)</vh>
<v t="ekr.20190812072048.432"><vh>EditorTabToolButton.updateIcon</vh></v>
</v>
<v t="ekr.20190812072048.433"><vh>class ShellIconMaker</vh>
<v t="ekr.20190812072048.434"><vh>ShellIconMaker.__init__</vh></v>
<v t="ekr.20190812072048.435"><vh>ShellIconMaker.setIcon</vh></v>
<v t="ekr.20190812072048.436"><vh>ShellIconMaker._createBlobPixmap</vh></v>
<v t="ekr.20190812072048.437"><vh>ShellIconMaker._createLegsPixmap</vh></v>
<v t="ekr.20190812072048.438"><vh>ShellIconMaker.updateIcon</vh></v>
<v t="ekr.20190812072048.439"><vh>ShellIconMaker._nextIndex</vh></v>
<v t="ekr.20190812072048.440"><vh>ShellIconMaker._index1</vh></v>
<v t="ekr.20190812072048.441"><vh>ShellIconMaker._index2</vh></v>
<v t="ekr.20190812072048.442"><vh>ShellIconMaker.onTimer</vh></v>
<v t="ekr.20190812072048.443"><vh>ShellIconMaker.drawReady</vh></v>
<v t="ekr.20190812072048.444"><vh>ShellIconMaker.drawDebug</vh></v>
<v t="ekr.20190812072048.445"><vh>ShellIconMaker.drawDead</vh></v>
<v t="ekr.20190812072048.446"><vh>ShellIconMaker.drawInMotion</vh></v>
</v>
</v>
<v t="ekr.20190812072048.447"><vh>@clean kernelbroker.py</vh>
<v t="ekr.20190812072048.448"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.449"><vh>class KernelInfo(ssdf.Struct)</vh>
<v t="ekr.20190812072048.450"><vh>KernelInfo.__init__</vh></v>
<v t="ekr.20190812072048.451"><vh>KernelInfo.tostring</vh></v>
</v>
<v t="ekr.20190812072048.452"><vh>getCommandFromKernelInfo</vh></v>
<v t="ekr.20190812072048.453"><vh>getEnvFromKernelInfo</vh></v>
<v t="ekr.20190812072048.454"><vh>class KernelBroker</vh>
<v t="ekr.20190812072048.455"><vh>KernelBroker.__init__</vh></v>
<v t="ekr.20190812072048.456"><vh>KernelBroker._create_channels</vh></v>
<v t="ekr.20190812072048.457"><vh>KernelBroker._reset</vh></v>
<v t="ekr.20190812072048.458"><vh>KernelBroker.startKernelIfConnected</vh></v>
<v t="ekr.20190812072048.459"><vh>KernelBroker.startKernel</vh></v>
<v t="ekr.20190812072048.460"><vh>KernelBroker.hostConnectionForIDE</vh></v>
<v t="ekr.20190812072048.461"><vh>KernelBroker._onKernelTimedOut</vh></v>
<v t="ekr.20190812072048.462"><vh>KernelBroker._onKernelConnectionClose</vh></v>
<v t="ekr.20190812072048.463"><vh>KernelBroker._onKernelDied</vh></v>
<v t="ekr.20190812072048.464"><vh>KernelBroker.terminate</vh></v>
<v t="ekr.20190812072048.465"><vh>KernelBroker.isTerminating</vh></v>
<v t="ekr.20190812072048.466"><vh>KernelBroker.mainLoopIter</vh></v>
<v t="ekr.20190812072048.467"><vh>KernelBroker._commandInterrupt</vh></v>
<v t="ekr.20190812072048.468"><vh>KernelBroker._commandTerminate</vh></v>
<v t="ekr.20190812072048.469"><vh>KernelBroker._commandRestart</vh></v>
</v>
<v t="ekr.20190812072048.470"><vh>class KernelTerminator</vh>
<v t="ekr.20190812072048.471"><vh>KernelTerminator.__init__</vh></v>
<v t="ekr.20190812072048.472"><vh>KernelTerminator._do</vh></v>
<v t="ekr.20190812072048.473"><vh>KernelTerminator.next</vh></v>
<v t="ekr.20190812072048.474"><vh>KernelTerminator.getMessage</vh></v>
</v>
<v t="ekr.20190812072048.475"><vh>class StreamReader(threading.Thread)</vh>
<v t="ekr.20190812072048.476"><vh>StreamReader.__init__</vh></v>
<v t="ekr.20190812072048.477"><vh>StreamReader.stop</vh></v>
<v t="ekr.20190812072048.478"><vh>StreamReader.run</vh></v>
</v>
<v t="ekr.20190812072048.479"><vh>class Kernelmanager</vh>
<v t="ekr.20190812072048.480"><vh>Kernelmanager.__init__</vh></v>
<v t="ekr.20190812072048.481"><vh>Kernelmanager.createKernel</vh></v>
<v t="ekr.20190812072048.482"><vh>Kernelmanager.getKernelList</vh></v>
<v t="ekr.20190812072048.483"><vh>Kernelmanager.terminateAll</vh></v>
</v>
</v>
<v t="ekr.20190812072048.484"><vh>@clean main.py</vh>
<v t="ekr.20190812072048.485"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.486"><vh>class MainWindow(QtWidgets.QMainWindow)</vh>
<v t="ekr.20190812072048.487"><vh>MainWindow.__init__</vh></v>
<v t="ekr.20190812072048.488"><vh>MainWindow.paintEvent</vh></v>
<v t="ekr.20190812072048.489"><vh>MainWindow.paintNow</vh></v>
<v t="ekr.20190812072048.490"><vh>MainWindow._populate</vh></v>
<v t="ekr.20190812072048.491"><vh>MainWindow.setMainTitle</vh></v>
<v t="ekr.20190812072048.492"><vh>MainWindow.saveWindowState</vh></v>
<v t="ekr.20190812072048.493"><vh>MainWindow.restoreGeometry</vh></v>
<v t="ekr.20190812072048.494"><vh>MainWindow.restoreState</vh></v>
<v t="ekr.20190812072048.495"><vh>MainWindow.setQtStyle</vh></v>
<v t="ekr.20190812072048.496"><vh>MainWindow.closeEvent</vh></v>
<v t="ekr.20190812072048.497"><vh>MainWindow.restart</vh></v>
<v t="ekr.20190812072048.498"><vh>MainWindow.createPopupMenu</vh></v>
</v>
<v t="ekr.20190812072048.499"><vh>loadAppIcons</vh></v>
<v t="ekr.20190812072048.500"><vh>loadIcons</vh></v>
<v t="ekr.20190812072048.501"><vh>loadFonts</vh></v>
<v t="ekr.20190812072048.502"><vh>class _CallbackEventHandler(QtCore.QObject)</vh>
<v t="ekr.20190812072048.503"><vh>_CallbackEventHandler.__init__</vh></v>
<v t="ekr.20190812072048.504"><vh>_CallbackEventHandler.customEvent</vh></v>
<v t="ekr.20190812072048.505"><vh>_CallbackEventHandler.postEventWithCallback</vh></v>
</v>
<v t="ekr.20190812072048.506"><vh>callLater</vh></v>
<v t="ekr.20190812072048.507"><vh>screenshotExample</vh></v>
<v t="ekr.20190812072048.508"><vh>screenshot</vh></v>
<v t="ekr.20190812072048.509"><vh>_screenshot</vh></v>
</v>
<v t="ekr.20190812072048.510"><vh>@clean menu.py</vh>
<v t="ekr.20190812072048.511"><vh>Declarations</vh></v>
<v t="ekr.20190812072048.512"><vh>buildMenus</vh></v>
<v t="ekr.20190812072048.513"><vh>getShortcut</vh></v>
<v t="ekr.20190812072048.514"><vh>translateShortcutToOSNames</vh></v>
<v t="ekr.20190812072048.515"><vh>class KeyMapper(QtCore.QObject)</vh>
<v t="ekr.20190812072048.516"><vh>KeyMapper.setShortcut</vh></v>
</v>
<v t="ekr.20190812072048.517"><vh>unwrapText</vh></v>
<v t="ekr.20190812072048.518"><vh>class Menu(QtWidgets.QMenu)</vh>
<v t="ekr.20190812072048.519"><vh>Menu.__init__</vh></v>
<v t="ekr.20190812072048.520"><vh>Menu._createMenuPathName</vh></v>
<v t="ekr.20190812072048.521"><vh>Menu._addAction</vh></v>
<v t="ekr.20190812072048.522"><vh>Menu.build</vh></v>
<v t="ekr.20190812072048.523"><vh>Menu.addMenu</vh></v>
<v t="ekr.20190812072048.524"><vh>Menu.addItem</vh></v>
<v t="ekr.20190812072048.525"><vh>Menu.addGroupItem</vh></v>
<v t="ekr.20190812072048.526"><vh>Menu.addCheckItem</vh></v>
<v t="ekr.20190812072048.527"><vh>Menu.setCheckedOption</vh></v>
</v>
<v t="ekr.20190812072048.528"><vh>class GeneralOptionsMenu(Menu)</vh>
<v t="ekr.20190812072048.529"><vh>GeneralOptionsMenu.__init__</vh></v>
<v t="ekr.20190812072048.530"><vh>GeneralOptionsMenu.build</vh></v>
<v t="ekr.20190812072048.531"><vh>GeneralOptionsMenu.setOptions</vh></v>
</v>
<v t="ekr.20190812072048.532"><vh>class IndentationMenu(Menu)</vh>
<v t="ekr.20190812072048.533"><vh>IndentationMenu.build</vh></v>
<v t="ekr.20190812072048.534"><vh>IndentationMenu._setWidth</vh></v>
<v t="ekr.20190812072048.535"><vh>IndentationMenu._setStyle</vh></v>
</v>
<v t="ekr.20190812072048.536"><vh>class FileMenu(Menu)</vh>
<v t="ekr.20190812072048.537"><vh>FileMenu.build</vh></v>
<v t="ekr.20190812072048.538"><vh>FileMenu.setEnabled</vh></v>
<v t="ekr.20190812072048.539"><vh>FileMenu.onEditorsCurrentChanged</vh></v>
<v t="ekr.20190812072048.540"><vh>FileMenu._setParser</vh></v>
<v t="ekr.20190812072048.541"><vh>FileMenu._setLineEndings</vh></v>
<v t="ekr.20190812072048.542"><vh>FileMenu._updateEncoding</vh></v>
<v t="ekr.20190812072048.543"><vh>FileMenu._setEncoding</vh></v>
<v t="ekr.20190812072048.544"><vh>FileMenu._print</vh></v>
</v>
<v t="ekr.20190812072048.545"><vh>class EditMenu(Menu)</vh>
<v t="ekr.20190812072048.546"><vh>EditMenu.build</vh></v>
<v t="ekr.20190812072048.547"><vh>EditMenu._editItemCallback</vh></v>
</v>
<v t="ekr.20190812072048.548"><vh>class ZoomMenu(Menu)</vh>
<v t="ekr.20190812072048.549"><vh>ZoomMenu.build</vh></v>
<v t="ekr.20190812072048.550"><vh>ZoomMenu._setZoom</vh></v>
</v>
<v t="ekr.20190812072048.551"><vh>class FontMenu(Menu)</vh>
<v t="ekr.20190812072048.552"><vh>FontMenu.__init__</vh></v>
<v t="ekr.20190812072048.553"><vh>FontMenu._updateFonts</vh></v>
<v t="ekr.20190812072048.554"><vh>FontMenu._selectFont</vh></v>
</v>
<v t="ekr.20190812072048.555"><vh>class ViewMenu(Menu)</vh>
<v t="ekr.20190812072048.556"><vh>ViewMenu.build</vh></v>
<v t="ekr.20190812072048.557"><vh>ViewMenu.addEditorItem</vh></v>
<v t="ekr.20190812072048.558"><vh>ViewMenu._configEditor</vh></v>
<v t="ekr.20190812072048.559"><vh>ViewMenu._selectShell</vh></v>
<v t="ekr.20190812072048.560"><vh>ViewMenu._selectEditor</vh></v>
<v t="ekr.20190812072048.561"><vh>ViewMenu._setEdgeColumn</vh></v>
<v t="ekr.20190812072048.562"><vh>ViewMenu._setQtTheme</vh></v>
<v t="ekr.20190812072048.563"><vh>ViewMenu._previousCell</vh></v>
<v t="ekr.20190812072048.564"><vh>ViewMenu._nextCell</vh></v>
<v t="ekr.20190812072048.565"><vh>ViewMenu._previousTopLevelObject</vh></v>
<v t="ekr.20190812072048.566"><vh>ViewMenu._nextTopLevelObject</vh></v>
</v>
<v t="ekr.20190812072048.567"><vh>class ShellMenu(Menu)</vh>
<v t="ekr.20190812072048.568"><vh>ShellMenu.__init__</vh></v>
<v t="ekr.20190812072048.569"><vh>ShellMenu.onCurrentShellChanged</vh></v>
<v t="ekr.20190812072048.570"><vh>ShellMenu.buildShellActions</vh></v>
<v t="ekr.20190812072048.571"><vh>ShellMenu.buildShellDebugActions</vh></v>
<v t="ekr.20190812072048.572"><vh>ShellMenu.getShell</vh></v>
<v t="ekr.20190812072048.573"><vh>ShellMenu.build</vh></v>
<v t="ekr.20190812072048.574"><vh>ShellMenu._updateShells</vh></v>
<v t="ekr.20190812072048.575"><vh>ShellMenu._updateDebugButtons</vh></v>
<v t="ekr.20190812072048.576"><vh>ShellMenu._shellAction</vh></v>
<v t="ekr.20190812072048.577"><vh>ShellMenu._debugAction</vh></v>
<v t="ekr.20190812072048.578"><vh>ShellMenu._clearBreakPoints</vh></v>
<v t="ekr.20190812072048.579"><vh>ShellMenu._editConfig2</vh></v>
<v t="ekr.20190812072048.580"><vh>ShellMenu._newPythonEnv</vh></v>
</v>
<v t="ekr.20190812072048.581"><vh>class ShellButtonMenu(ShellMenu)</vh>
<v t="ekr.20190812072048.582"><vh>ShellButtonMenu.build</vh></v>
<v t="ekr.20190812072048.583"><vh>ShellButtonMenu._updateShells</vh></v>
</v>
<v t="ekr.20190812072048.584"><vh>class ShellContextMenu(ShellMenu)</vh>
<v t="ekr.20190812072048.585"><vh>ShellContextMenu.__init__</vh></v>
<v t="ekr.20190812072048.586"><vh>ShellContextMenu.build</vh></v>
<v t="ekr.20190812072048.587"><vh>ShellContextMenu.getShell</vh></v>
<v t="ekr.20190812072048.588"><vh>ShellContextMenu._editItemCallback</vh></v>
<v t="ekr.20190812072048.589"><vh>ShellContextMenu._updateShells</vh></v>
</v>
<v t="ekr.20190812072048.590"><vh>class ShellTabContextMenu(ShellContextMenu)</vh>
<v t="ekr.20190812072048.591"><vh>ShellTabContextMenu.build</vh></v>
<v t="ekr.20190812072048.592"><vh>ShellTabContextMenu._updateShells</vh></v>
</v>
<v t="ekr.20190812072048.593"><vh>class EditorContextMenu(Menu)</vh>
<v t="ekr.20190812072048.594"><vh>EditorContextMenu.__init__</vh></v>
<v t="ekr.20190812072048.595"><vh>EditorContextMenu.build</vh></v>
<v t="ekr.20190812072048.596"><vh>EditorContextMenu._editItemCallback</vh></v>
<v t="ekr.20190812072048.597"><vh>EditorContextMenu._runSelected</vh></v>
</v>
<v t="ekr.20190812072048.598"><vh>class EditorTabContextMenu(Menu)</vh>
<v t="ekr.20190812072048.599"><vh>EditorTabContextMenu.__init__</vh></v>
<v t="ekr.20190812072048.600"><vh>EditorTabContextMenu.setIndex</vh></v>
<v t="ekr.20190812072048.601"><vh>EditorTabContextMenu.build</vh></v>
<v t="ekr.20190812072048.602"><vh>EditorTabContextMenu._fileAction</vh></v>
</v>
<v t="ekr.20190812072048.603"><vh>class RunMenu(Menu)</vh>
<v t="ekr.20190812072048.604"><vh>RunMenu.build</vh></v>
<v t="ekr.20190812072048.605"><vh>RunMenu._cdonfileexec</vh></v>
<v t="ekr.20190812072048.606"><vh>RunMenu._showHelp</vh></v>
<v t="ekr.20190812072048.607"><vh>RunMenu._getShellAndEditor</vh></v>
<v t="ekr.20190812072048.608"><vh>RunMenu._advance</vh></v>
<v t="ekr.20190812072048.609"><vh>RunMenu._runSelectedAdvance</vh></v>
<v t="ekr.20190812072048.610"><vh>RunMenu._runSelected</vh></v>
<v t="ekr.20190812072048.611"><vh>RunMenu._runCellAdvance</vh></v>
<v t="ekr.20190812072048.612"><vh>RunMenu._runCell</vh></v>
<v t="ekr.20190812072048.613"><vh>RunMenu._showWhatToExecute</vh></v>
<v t="ekr.20190812072048.614"><vh>RunMenu._getCodeOfFile</vh></v>
<v t="ekr.20190812072048.615"><vh>RunMenu._runFile</vh></v>
<v t="ekr.20190812072048.616"><vh>RunMenu._runScript</vh></v>
</v>
<v t="ekr.20190812072048.617"><vh>class ToolsMenu(Menu)</vh>
<v t="ekr.20190812072048.618"><vh>ToolsMenu.__init__</vh></v>
<v t="ekr.20190812072048.619"><vh>ToolsMenu.build</vh></v>
<v t="ekr.20190812072048.620"><vh>ToolsMenu.onToolInstanceChange</vh></v>
</v>
<v t="ekr.20190812072048.621"><vh>class HelpMenu(Menu)</vh>
<v t="ekr.20190812072048.622"><vh>HelpMenu.build</vh></v>
<v t="ekr.20190812072048.623"><vh>HelpMenu.addUrlItem</vh></v>
<v t="ekr.20190812072048.624"><vh>HelpMenu._showPyzoWizard</vh></v>
<v t="ekr.20190812072048.625"><vh>HelpMenu._checkUpdates</vh></v>
<v t="ekr.20190812072048.626"><vh>HelpMenu._aboutPyzo</vh></v>
<v t="ekr.20190812072048.627"><vh>HelpMenu._showPyzoDocs</vh></v>
</v>
<v t="ekr.20190812072048.628"><vh>class AutocompMenu(Menu)</vh>
<v t="ekr.20190812072048.629"><vh>AutocompMenu.build</vh></v>
<v t="ekr.20190812072048.630"><vh>AutocompMenu._setAcceptKeys</vh></v>
<v t="ekr.20190812072048.631"><vh>AutocompMenu._setMode</vh></v>
<v t="ekr.20190812072048.632"><vh>AutocompMenu._setCompleteKeywords</vh></v>
<v t="ekr.20190812072048.633"><vh>AutocompMenu._setQuotes</vh></v>
<v t="ekr.20190812072048.634"><vh>AutocompMenu._setBrackets</vh></v>
</v>
<v t="ekr.20190812072048.635"><vh>class SettingsMenu(Menu)</vh>
<v t="ekr.20190812072048.636"><vh>SettingsMenu.build</vh></v>
<v t="ekr.20190812072048.637"><vh>SettingsMenu._editStyles</vh></v>
<v t="ekr.20190812072048.638"><vh>SettingsMenu._advancedSettings</vh></v>
<v t="ekr.20190812072048.639"><vh>SettingsMenu.addBoolSetting</vh></v>
<v t="ekr.20190812072048.640"><vh>SettingsMenu._selectLanguage</vh></v>
</v>
<v t="ekr.20190812072048.641"><vh>class KeyMapModel(QtCore.QAbstractItemModel)</vh>
<v t="ekr.20190812072048.642"><vh>KeyMapModel.__init__</vh></v>
<v t="ekr.20190812072048.643"><vh>KeyMapModel.setRootMenu</vh></v>
<v t="ekr.20190812072048.644"><vh>KeyMapModel.data</vh></v>
<v t="ekr.20190812072048.645"><vh>KeyMapModel.rowCount</vh></v>
<v t="ekr.20190812072048.646"><vh>KeyMapModel.columnCount</vh></v>
<v t="ekr.20190812072048.647"><vh>KeyMapModel.headerData</vh></v>
<v t="ekr.20190812072048.648"><vh>KeyMapModel.parent</vh></v>
<v t="ekr.20190812072048.649"><vh>KeyMapModel.hasChildren</vh></v>
<v t="ekr.20190812072048.650"><vh>KeyMapModel.index</vh></v>
</v>
<v t="ekr.20190812072048.651"><vh>class KeyMapLineEdit(QtWidgets.QLineEdit)</vh>
<v t="ekr.20190812072048.652"><vh>KeyMapLineEdit.__init__</vh></v>
<v t="ekr.20190812072048.653"><vh>KeyMapLineEdit.setText</vh></v>
<v t="ekr.20190812072048.654"><vh>KeyMapLineEdit.text</vh></v>
<v t="ekr.20190812072048.655"><vh>KeyMapLineEdit.clear</vh></v>
<v t="ekr.20190812072048.656"><vh>KeyMapLineEdit.focusInEvent</vh></v>
<v t="ekr.20190812072048.657"><vh>KeyMapLineEdit.event</vh></v>
<v t="ekr.20190812072048.658"><vh>KeyMapLineEdit.keyPressEvent</vh></v>
</v>
<v t="ekr.20190812072048.659"><vh>class KeyMapEditDialog(QtWidgets.QDialog)</vh>
<v t="ekr.20190812072048.660"><vh>KeyMapEditDialog.__init__</vh></v>
<v t="ekr.20190812072048.661"><vh>KeyMapEditDialog.setFullName</vh></v>
<v t="ekr.20190812072048.662"><vh>KeyMapEditDialog.onClear</vh></v>
<v t="ekr.20190812072048.663"><vh>KeyMapEditDialog.onEdit</vh></v>
<v t="ekr.20190812072048.664"><vh>KeyMapEditDialog.onAccept</vh></v>
</v>
<v t="ekr.20190812072048.665"><vh>class KeymappingDialog(QtWidgets.QDialog)</vh>
<v t="ekr.20190812072048.666"><vh>KeymappingDialog.__init__</vh></v>
<v t="ekr.20190812072048.667"><vh>KeymappingDialog.closeEvent</vh></v>
<v t="ekr.20190812072048.668"><vh>KeymappingDialog.onTabSelect</vh></v>
<v t="ekr.20190812072048.669"><vh>KeymappingDialog.onClickSelect</vh></v>
<v t="ekr.20190812072048.670"><vh>KeymappingDialog.onDoubleClick</vh></v>
<v t="ekr.20190812072048.671"><vh>KeymappingDialog.popupItem</vh></v>
</v>
</v>
<v t="ekr.20190812072049.1"><vh>@clean pyzoLogging.py</vh>
<v t="ekr.20190812072049.2"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.3"><vh>class DummyStd</vh>
<v t="ekr.20190812072049.4"><vh>DummyStd.__init__</vh></v>
<v t="ekr.20190812072049.5"><vh>DummyStd.write</vh></v>
<v t="ekr.20190812072049.6"><vh>DummyStd.encoding</vh></v>
<v t="ekr.20190812072049.7"><vh>DummyStd.closed</vh></v>
<v t="ekr.20190812072049.8"><vh>DummyStd.close</vh></v>
<v t="ekr.20190812072049.9"><vh>DummyStd.flush</vh></v>
</v>
<v t="ekr.20190812072049.10"><vh>print</vh></v>
<v t="ekr.20190812072049.11"><vh>splitConsole</vh></v>
<v t="ekr.20190812072049.12"><vh>class OutputStreamSplitter</vh>
<v t="ekr.20190812072049.13"><vh>OutputStreamSplitter.__init__</vh></v>
<v t="ekr.20190812072049.14"><vh>OutputStreamSplitter.dummyDeferFunction</vh></v>
<v t="ekr.20190812072049.15"><vh>OutputStreamSplitter.write</vh></v>
<v t="ekr.20190812072049.16"><vh>OutputStreamSplitter.flush</vh></v>
<v t="ekr.20190812072049.17"><vh>OutputStreamSplitter.closed</vh></v>
<v t="ekr.20190812072049.18"><vh>OutputStreamSplitter.close</vh></v>
<v t="ekr.20190812072049.19"><vh>OutputStreamSplitter.encoding</vh></v>
</v>
</v>
<v t="ekr.20190812072049.20"><vh>@clean shell.py</vh>
<v t="ekr.20190812072049.21"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.22"><vh>class YotonEmbedder(QtCore.QObject)</vh>
<v t="ekr.20190812072049.23"><vh>YotonEmbedder.__init__</vh></v>
<v t="ekr.20190812072049.24"><vh>YotonEmbedder.postYotonEvent</vh></v>
<v t="ekr.20190812072049.25"><vh>YotonEmbedder.customEvent</vh></v>
</v>
<v t="ekr.20190812072049.26"><vh>finishKernelInfo</vh></v>
<v t="ekr.20190812072049.27"><vh>class ShellHighlighter(Highlighter)</vh>
<v t="ekr.20190812072049.28"><vh>ShellHighlighter.highlightBlock</vh></v>
</v>
<v t="ekr.20190812072049.29"><vh>class BaseShell(BaseTextCtrl)</vh>
<v t="ekr.20190812072049.30"><vh>BaseShell.__init__</vh></v>
<v t="ekr.20190812072049.31"><vh>BaseShell.onCursorPositionChanged</vh></v>
<v t="ekr.20190812072049.32"><vh>BaseShell.ensureCursorAtEditLine</vh></v>
<v t="ekr.20190812072049.33"><vh>BaseShell.mousePressEvent</vh></v>
<v t="ekr.20190812072049.34"><vh>BaseShell.contextMenuEvent</vh></v>
<v t="ekr.20190812072049.35"><vh>BaseShell.mouseDoubleClickEvent</vh></v>
<v t="ekr.20190812072049.36"><vh>BaseShell._handleClickOnFilename</vh></v>
<v t="ekr.20190812072049.37"><vh>BaseShell.indentSelection</vh></v>
<v t="ekr.20190812072049.38"><vh>BaseShell.dedentSelection</vh></v>
<v t="ekr.20190812072049.39"><vh>BaseShell.keyPressEvent</vh></v>
<v t="ekr.20190812072049.40"><vh>BaseShell.cut</vh></v>
<v t="ekr.20190812072049.41"><vh>BaseShell.paste</vh></v>
<v t="ekr.20190812072049.42"><vh>BaseShell.dragEnterEvent</vh></v>
<v t="ekr.20190812072049.43"><vh>BaseShell.dragMoveEvent</vh></v>
<v t="ekr.20190812072049.44"><vh>BaseShell.dropEvent</vh></v>
<v t="ekr.20190812072049.45"><vh>BaseShell.clearScreen</vh></v>
<v t="ekr.20190812072049.46"><vh>BaseShell.deleteLines</vh></v>
<v t="ekr.20190812072049.47"><vh>BaseShell.clearCommand</vh></v>
<v t="ekr.20190812072049.48"><vh>BaseShell._handleBackspaces_split</vh></v>
<v t="ekr.20190812072049.49"><vh>BaseShell._handleBackspacesOnList</vh></v>
<v t="ekr.20190812072049.50"><vh>BaseShell._handleBackspaces</vh></v>
<v t="ekr.20190812072049.51"><vh>BaseShell._handleCarriageReturnOnList</vh></v>
<v t="ekr.20190812072049.52"><vh>BaseShell._handleCarriageReturn</vh></v>
<v t="ekr.20190812072049.53"><vh>BaseShell._splitLinesForPrinting</vh></v>
<v t="ekr.20190812072049.54"><vh>BaseShell.write</vh></v>
<v t="ekr.20190812072049.55"><vh>BaseShell._insertText</vh></v>
<v t="ekr.20190812072049.56"><vh>BaseShell.processLine</vh></v>
<v t="ekr.20190812072049.57"><vh>BaseShell.executeCommand</vh></v>
</v>
<v t="ekr.20190812072049.58"><vh>class PythonShell(BaseShell)</vh>
<v t="ekr.20190812072049.59"><vh>PythonShell.__init__</vh></v>
<v t="ekr.20190812072049.60"><vh>PythonShell.resetVariables</vh></v>
<v t="ekr.20190812072049.61"><vh>PythonShell.connectToKernel</vh></v>
<v t="ekr.20190812072049.62"><vh>PythonShell.get_kernel_cd</vh></v>
<v t="ekr.20190812072049.63"><vh>PythonShell._onReceivedStartupInfo</vh></v>
<v t="ekr.20190812072049.64"><vh>PythonShell.processCallTip</vh></v>
<v t="ekr.20190812072049.65"><vh>PythonShell._processCallTip_response</vh></v>
<v t="ekr.20190812072049.66"><vh>PythonShell.processAutoComp</vh></v>
<v t="ekr.20190812072049.67"><vh>PythonShell._processAutoComp_response</vh></v>
<v t="ekr.20190812072049.68"><vh>PythonShell.executeCommand</vh></v>
<v t="ekr.20190812072049.69"><vh>PythonShell.executeCode</vh></v>
<v t="ekr.20190812072049.70"><vh>PythonShell.sendBreakPoints</vh></v>
<v t="ekr.20190812072049.71"><vh>PythonShell.poll</vh></v>
<v t="ekr.20190812072049.72"><vh>PythonShell.interrupt</vh></v>
<v t="ekr.20190812072049.73"><vh>PythonShell.restart</vh></v>
<v t="ekr.20190812072049.74"><vh>PythonShell.terminate</vh></v>
<v t="ekr.20190812072049.75"><vh>PythonShell.closeShell</vh></v>
<v t="ekr.20190812072049.76"><vh>PythonShell._onConnectionClose</vh></v>
</v>
</v>
<v t="ekr.20190812072049.77"><vh>@clean shellInfoDialog.py</vh>
<v t="ekr.20190812072049.78"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.79"><vh>class ShellInfoLineEdit(QtWidgets.QLineEdit)</vh>
<v t="ekr.20190812072049.80"><vh>ShellInfoLineEdit.setTheText</vh></v>
<v t="ekr.20190812072049.81"><vh>ShellInfoLineEdit.getTheText</vh></v>
</v>
<v t="ekr.20190812072049.82"><vh>class ShellInfo_name(ShellInfoLineEdit)</vh>
<v t="ekr.20190812072049.83"><vh>ShellInfo_name.__init__</vh></v>
<v t="ekr.20190812072049.84"><vh>ShellInfo_name.setTheText</vh></v>
<v t="ekr.20190812072049.85"><vh>ShellInfo_name.onValueChanged</vh></v>
</v>
<v t="ekr.20190812072049.86"><vh>class ShellInfo_exe(QtWidgets.QComboBox)</vh>
<v t="ekr.20190812072049.87"><vh>ShellInfo_exe.__init__</vh></v>
<v t="ekr.20190812072049.88"><vh>ShellInfo_exe._interpreterName</vh></v>
<v t="ekr.20190812072049.89"><vh>ShellInfo_exe.setTheText</vh></v>
<v t="ekr.20190812072049.90"><vh>ShellInfo_exe.getTheText</vh></v>
</v>
<v t="ekr.20190812072049.91"><vh>class ShellInfo_ipython(QtWidgets.QCheckBox)</vh>
<v t="ekr.20190812072049.92"><vh>ShellInfo_ipython.__init__</vh></v>
<v t="ekr.20190812072049.93"><vh>ShellInfo_ipython.setTheText</vh></v>
<v t="ekr.20190812072049.94"><vh>ShellInfo_ipython.getTheText</vh></v>
</v>
<v t="ekr.20190812072049.95"><vh>class ShellInfo_gui(QtWidgets.QComboBox)</vh>
<v t="ekr.20190812072049.96"><vh>ShellInfo_gui.setTheText</vh></v>
<v t="ekr.20190812072049.97"><vh>ShellInfo_gui.getTheText</vh></v>
</v>
<v t="ekr.20190812072049.98"><vh>class ShellinfoWithSystemDefault(QtWidgets.QVBoxLayout)</vh>
<v t="ekr.20190812072049.99"><vh>ShellinfoWithSystemDefault.__init__</vh></v>
<v t="ekr.20190812072049.100"><vh>ShellinfoWithSystemDefault.onEditChanged</vh></v>
<v t="ekr.20190812072049.101"><vh>ShellinfoWithSystemDefault.onCheckChanged</vh></v>
<v t="ekr.20190812072049.102"><vh>ShellinfoWithSystemDefault.setTheText</vh></v>
<v t="ekr.20190812072049.103"><vh>ShellinfoWithSystemDefault.getTheText</vh></v>
</v>
<v t="ekr.20190812072049.104"><vh>class ShellInfo_pythonPath(ShellinfoWithSystemDefault)</vh>
<v t="ekr.20190812072049.105"><vh>ShellInfo_pythonPath.__init__</vh></v>
<v t="ekr.20190812072049.106"><vh>ShellInfo_pythonPath.getWidgetText</vh></v>
<v t="ekr.20190812072049.107"><vh>ShellInfo_pythonPath.setWidgetText</vh></v>
</v>
<v t="ekr.20190812072049.108"><vh>class ShellInfo_startupScript(QtWidgets.QVBoxLayout)</vh>
<v t="ekr.20190812072049.109"><vh>ShellInfo_startupScript.__init__</vh></v>
<v t="ekr.20190812072049.110"><vh>ShellInfo_startupScript.onEditChanged</vh></v>
<v t="ekr.20190812072049.111"><vh>ShellInfo_startupScript.onCheckChanged</vh></v>
<v t="ekr.20190812072049.112"><vh>ShellInfo_startupScript.setTheText</vh></v>
<v t="ekr.20190812072049.113"><vh>ShellInfo_startupScript.setWidgetText</vh></v>
<v t="ekr.20190812072049.114"><vh>ShellInfo_startupScript.getTheText</vh></v>
</v>
<v t="ekr.20190812072049.115"><vh>class ShellInfo_startDir(ShellInfoLineEdit)</vh>
<v t="ekr.20190812072049.116"><vh>ShellInfo_startDir.__init__</vh></v>
</v>
<v t="ekr.20190812072049.117"><vh>class ShellInfo_argv(ShellInfoLineEdit)</vh>
<v t="ekr.20190812072049.118"><vh>ShellInfo_argv.__init__</vh></v>
</v>
<v t="ekr.20190812072049.119"><vh>class ShellInfo_environ(QtWidgets.QTextEdit)</vh>
<v t="ekr.20190812072049.120"><vh>ShellInfo_environ.__init__</vh></v>
<v t="ekr.20190812072049.121"><vh>ShellInfo_environ._cleanText</vh></v>
<v t="ekr.20190812072049.122"><vh>ShellInfo_environ.setTheText</vh></v>
<v t="ekr.20190812072049.123"><vh>ShellInfo_environ.getTheText</vh></v>
</v>
<v t="ekr.20190812072049.124"><vh>class ShellInfoTab(QtWidgets.QScrollArea)</vh>
<v t="ekr.20190812072049.125"><vh>ShellInfoTab.__init__</vh></v>
<v t="ekr.20190812072049.126"><vh>ShellInfoTab.setTabTitle</vh></v>
<v t="ekr.20190812072049.127"><vh>ShellInfoTab.setInfo</vh></v>
<v t="ekr.20190812072049.128"><vh>ShellInfoTab.getInfo</vh></v>
</v>
<v t="ekr.20190812072049.129"><vh>class ShellInfoDialog(QtWidgets.QDialog)</vh>
<v t="ekr.20190812072049.130"><vh>ShellInfoDialog.__init__</vh></v>
<v t="ekr.20190812072049.131"><vh>ShellInfoDialog.onAdd</vh></v>
<v t="ekr.20190812072049.132"><vh>ShellInfoDialog.onTabClose</vh></v>
<v t="ekr.20190812072049.133"><vh>ShellInfoDialog.applyAndClose</vh></v>
<v t="ekr.20190812072049.134"><vh>ShellInfoDialog.apply</vh></v>
</v>
</v>
<v t="ekr.20190812072049.135"><vh>@clean shellStack.py</vh>
<v t="ekr.20190812072049.136"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.137"><vh>shellTitle</vh></v>
<v t="ekr.20190812072049.138"><vh>class ShellStackWidget(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072049.139"><vh>ShellStackWidget.__init__ (no longer changed)</vh></v>
<v t="ekr.20190812072049.140"><vh>ShellStackWidget.__iter__</vh></v>
<v t="ekr.20190812072049.141"><vh>ShellStackWidget.showInterpreterHelper</vh></v>
<v t="ekr.20190812072049.142"><vh>ShellStackWidget.addShell</vh></v>
<v t="ekr.20190812072049.143"><vh>ShellStackWidget.removeShell</vh></v>
<v t="ekr.20190812072049.144"><vh>ShellStackWidget.onCurrentChanged</vh></v>
<v t="ekr.20190812072049.145"><vh>ShellStackWidget.onShellStateChange</vh></v>
<v t="ekr.20190812072049.146"><vh>ShellStackWidget.onShellDebugStateChange</vh></v>
<v t="ekr.20190812072049.147"><vh>ShellStackWidget.getCurrentShell</vh></v>
<v t="ekr.20190812072049.148"><vh>ShellStackWidget.getShells</vh></v>
<v t="ekr.20190812072049.149"><vh>ShellStackWidget.getShellAt</vh></v>
<v t="ekr.20190812072049.150"><vh>ShellStackWidget.addContextMenu</vh></v>
<v t="ekr.20190812072049.151"><vh>ShellStackWidget.contextMenuTriggered</vh></v>
<v t="ekr.20190812072049.152"><vh>ShellStackWidget.onShellAction</vh></v>
</v>
<v t="ekr.20190812072049.153"><vh>class ShellControl(QtWidgets.QToolButton)</vh>
<v t="ekr.20190812072049.154"><vh>ShellControl.__init__</vh></v>
<v t="ekr.20190812072049.155"><vh>ShellControl.updateShellMenu</vh></v>
<v t="ekr.20190812072049.156"><vh>ShellControl.onElapsedTimesTimer</vh></v>
</v>
<v t="ekr.20190812072049.157"><vh>class DebugStack(QtWidgets.QToolButton)</vh>
<v t="ekr.20190812072049.158"><vh>DebugStack.__init__</vh></v>
<v t="ekr.20190812072049.159"><vh>DebugStack.onTriggered</vh></v>
<v t="ekr.20190812072049.160"><vh>DebugStack.setTrace</vh></v>
<v t="ekr.20190812072049.161"><vh>DebugStack.debugFocus</vh></v>
</v>
<v t="ekr.20190812072049.162"><vh>class InterpreterHelper(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072049.163"><vh>InterpreterHelper.__init__</vh></v>
<v t="ekr.20190812072049.164"><vh>InterpreterHelper.refresh</vh></v>
<v t="ekr.20190812072049.165"><vh>InterpreterHelper.detect</vh></v>
<v t="ekr.20190812072049.166"><vh>InterpreterHelper.handle_link</vh></v>
<v t="ekr.20190812072049.167"><vh>InterpreterHelper.editShellConfig</vh></v>
<v t="ekr.20190812072049.168"><vh>InterpreterHelper.useFound</vh></v>
<v t="ekr.20190812072049.169"><vh>InterpreterHelper.hide_this</vh></v>
<v t="ekr.20190812072049.170"><vh>InterpreterHelper.restart_shell</vh></v>
</v>
</v>
<v t="ekr.20190812072049.171"><vh>@clean splash.py</vh>
<v t="ekr.20190812072049.172"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.173"><vh>class LogoWidget(QtWidgets.QFrame)</vh>
<v t="ekr.20190812072049.174"><vh>LogoWidget.__init__</vh></v>
</v>
<v t="ekr.20190812072049.175"><vh>class LabelWidget(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072049.176"><vh>LabelWidget.__init__</vh></v>
</v>
<v t="ekr.20190812072049.177"><vh>class SplashWidget(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072049.178"><vh>SplashWidget.__init__</vh></v>
</v>
</v>
<v t="ekr.20190812072049.179"><vh>@clean __init__.py</vh>
<v t="ekr.20190812072049.180"><vh>Declarations</vh></v>
</v>
</v>
<v t="ekr.20190812072049.182"><vh>pyzo/pyzokernel</vh>
<v t="ekr.20190812072049.366"><vh>@clean __init__.py</vh>
<v t="ekr.20190812072049.367"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.368"><vh>printDirect</vh></v>
</v>
<v t="ekr.20190812072049.355"><vh>@clean _nope.py</vh>
<v t="ekr.20190812072049.356"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.357"><vh>_utf8</vh></v>
<v t="ekr.20190812072049.358"><vh>n</vh></v>
<v t="ekr.20190812072049.359"><vh>C</vh></v>
<v t="ekr.20190812072049.360"><vh>beginActivityWithOptions</vh></v>
<v t="ekr.20190812072049.361"><vh>endActivity</vh></v>
<v t="ekr.20190812072049.362"><vh>nope</vh></v>
<v t="ekr.20190812072049.363"><vh>nap</vh></v>
<v t="ekr.20190812072049.364"><vh>napping_allowed</vh></v>
<v t="ekr.20190812072049.365"><vh>nope_scope</vh></v>
</v>
<v t="ekr.20190812072049.183"><vh>@clean debug.py</vh>
<v t="ekr.20190812072049.184"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.185"><vh>class Debugger(bdb.Bdb)</vh>
<v t="ekr.20190812072049.186"><vh>Debugger.__init__</vh></v>
<v t="ekr.20190812072049.187"><vh>Debugger.clear_all_breaks</vh></v>
<v t="ekr.20190812072049.188"><vh>Debugger.trace_dispatch</vh></v>
<v t="ekr.20190812072049.189"><vh>Debugger.interaction</vh></v>
<v t="ekr.20190812072049.190"><vh>Debugger.stopinteraction</vh></v>
<v t="ekr.20190812072049.191"><vh>Debugger.set_on</vh></v>
<v t="ekr.20190812072049.192"><vh>Debugger.message</vh></v>
<v t="ekr.20190812072049.193"><vh>Debugger.error</vh></v>
<v t="ekr.20190812072049.194"><vh>Debugger.writestatus</vh></v>
<v t="ekr.20190812072049.195"><vh>Debugger.set_break</vh></v>
<v t="ekr.20190812072049.196"><vh>Debugger.stop_here</vh></v>
<v t="ekr.20190812072049.197"><vh>Debugger.do_clear</vh></v>
<v t="ekr.20190812072049.198"><vh>Debugger.user_call</vh></v>
<v t="ekr.20190812072049.199"><vh>Debugger.user_line</vh></v>
<v t="ekr.20190812072049.200"><vh>Debugger.user_return</vh></v>
<v t="ekr.20190812072049.201"><vh>Debugger.user_exception</vh></v>
<v t="ekr.20190812072049.202"><vh>Debugger.do_help</vh></v>
<v t="ekr.20190812072049.203"><vh>Debugger.do_start</vh></v>
<v t="ekr.20190812072049.204"><vh>Debugger.do_frame</vh></v>
<v t="ekr.20190812072049.205"><vh>Debugger.do_up</vh></v>
<v t="ekr.20190812072049.206"><vh>Debugger.do_down</vh></v>
<v t="ekr.20190812072049.207"><vh>Debugger.do_stop</vh></v>
<v t="ekr.20190812072049.208"><vh>Debugger.do_where</vh></v>
<v t="ekr.20190812072049.209"><vh>Debugger.do_continue</vh></v>
<v t="ekr.20190812072049.210"><vh>Debugger.do_step</vh></v>
<v t="ekr.20190812072049.211"><vh>Debugger.do_next</vh></v>
<v t="ekr.20190812072049.212"><vh>Debugger.do_return</vh></v>
<v t="ekr.20190812072049.213"><vh>Debugger.do_events</vh></v>
</v>
</v>
<v t="ekr.20190812072049.214"><vh>@clean guiintegration.py</vh>
<v t="ekr.20190812072049.215"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.216"><vh>print_mainloop_warning</vh></v>
<v t="ekr.20190812072049.217"><vh>class App_base</vh>
<v t="ekr.20190812072049.218"><vh>App_base.process_events</vh></v>
<v t="ekr.20190812072049.219"><vh>App_base._keyboard_interrupt</vh></v>
<v t="ekr.20190812072049.220"><vh>App_base.run</vh></v>
<v t="ekr.20190812072049.221"><vh>App_base.quit</vh></v>
</v>
<v t="ekr.20190812072049.222"><vh>class App_asyncio(App_base)</vh>
<v t="ekr.20190812072049.223"><vh>App_asyncio.__init__</vh></v>
<v t="ekr.20190812072049.224"><vh>App_asyncio.stub_run_until_complete</vh></v>
<v t="ekr.20190812072049.225"><vh>App_asyncio.stub_run_forever</vh></v>
<v t="ekr.20190812072049.226"><vh>App_asyncio.stub_close</vh></v>
<v t="ekr.20190812072049.227"><vh>App_asyncio.process_events</vh></v>
<v t="ekr.20190812072049.228"><vh>App_asyncio.quit</vh></v>
</v>
<v t="ekr.20190812072049.229"><vh>class App_tk(App_base)</vh>
<v t="ekr.20190812072049.230"><vh>App_tk.__init__</vh></v>
<v t="ekr.20190812072049.231"><vh>App_tk.process_events</vh></v>
</v>
<v t="ekr.20190812072049.232"><vh>class App_fltk(App_base)</vh>
<v t="ekr.20190812072049.233"><vh>App_fltk.__init__</vh></v>
<v t="ekr.20190812072049.234"><vh>App_fltk.process_events</vh></v>
</v>
<v t="ekr.20190812072049.235"><vh>class App_fltk2(App_base)</vh>
<v t="ekr.20190812072049.236"><vh>App_fltk2.__init__</vh></v>
<v t="ekr.20190812072049.237"><vh>App_fltk2.process_events</vh></v>
</v>
<v t="ekr.20190812072049.238"><vh>class App_tornado(App_base)</vh>
<v t="ekr.20190812072049.239"><vh>App_tornado.__init__</vh></v>
<v t="ekr.20190812072049.240"><vh>App_tornado.process_events</vh></v>
<v t="ekr.20190812072049.241"><vh>App_tornado.run</vh></v>
<v t="ekr.20190812072049.242"><vh>App_tornado.quit</vh></v>
</v>
<v t="ekr.20190812072049.243"><vh>class App_qt(App_base)</vh>
<v t="ekr.20190812072049.244"><vh>App_qt.__init__</vh></v>
<v t="ekr.20190812072049.245"><vh>App_qt._excepthook</vh></v>
<v t="ekr.20190812072049.246"><vh>App_qt.process_events</vh></v>
<v t="ekr.20190812072049.247"><vh>App_qt.run</vh></v>
<v t="ekr.20190812072049.248"><vh>App_qt.quit</vh></v>
</v>
<v t="ekr.20190812072049.249"><vh>class App_pyqt5(App_qt)</vh>
<v t="ekr.20190812072049.250"><vh>App_pyqt5.importCoreAndGui</vh></v>
</v>
<v t="ekr.20190812072049.251"><vh>class App_pyqt4(App_qt)</vh>
<v t="ekr.20190812072049.252"><vh>App_pyqt4.importCoreAndGui</vh></v>
</v>
<v t="ekr.20190812072049.253"><vh>class App_pyside2(App_qt)</vh>
<v t="ekr.20190812072049.254"><vh>App_pyside2.importCoreAndGui</vh></v>
</v>
<v t="ekr.20190812072049.255"><vh>class App_pyside(App_qt)</vh>
<v t="ekr.20190812072049.256"><vh>App_pyside.importCoreAndGui</vh></v>
</v>
<v t="ekr.20190812072049.257"><vh>class App_wx(App_base)</vh>
<v t="ekr.20190812072049.258"><vh>App_wx.__init__</vh></v>
<v t="ekr.20190812072049.259"><vh>App_wx.process_events</vh></v>
</v>
<v t="ekr.20190812072049.260"><vh>class App_gtk(App_base)</vh>
<v t="ekr.20190812072049.261"><vh>App_gtk.__init__</vh></v>
<v t="ekr.20190812072049.262"><vh>App_gtk.process_events</vh></v>
</v>
</v>
<v t="ekr.20190812072049.263"><vh>@clean guisupport.py</vh>
<v t="ekr.20190812072049.264"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.265"><vh>get_app_wx</vh></v>
<v t="ekr.20190812072049.266"><vh>is_event_loop_running_wx</vh></v>
<v t="ekr.20190812072049.267"><vh>start_event_loop_wx</vh></v>
<v t="ekr.20190812072049.268"><vh>get_app_qt4</vh></v>
<v t="ekr.20190812072049.269"><vh>is_event_loop_running_qt4</vh></v>
<v t="ekr.20190812072049.270"><vh>start_event_loop_qt4</vh></v>
</v>
<v t="ekr.20190812072049.271"><vh>@clean interpreter.py</vh>
<v t="ekr.20190812072049.272"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.273"><vh>class PS1</vh>
<v t="ekr.20190812072049.274"><vh>PS1.__init__</vh></v>
<v t="ekr.20190812072049.275"><vh>PS1.__str__</vh></v>
</v>
<v t="ekr.20190812072049.276"><vh>class PS2</vh>
<v t="ekr.20190812072049.277"><vh>PS2.__init__</vh></v>
<v t="ekr.20190812072049.278"><vh>PS2.__str__</vh></v>
</v>
<v t="ekr.20190812072049.279"><vh>class PyzoInterpreter</vh>
<v t="ekr.20190812072049.280"><vh>PyzoInterpreter.__init__</vh></v>
<v t="ekr.20190812072049.281"><vh>PyzoInterpreter.run</vh></v>
<v t="ekr.20190812072049.282"><vh>PyzoInterpreter._prepare</vh></v>
<v t="ekr.20190812072049.283"><vh>PyzoInterpreter._prepare_environment</vh></v>
<v t="ekr.20190812072049.284"><vh>PyzoInterpreter._run_startup_code</vh></v>
<v t="ekr.20190812072049.285"><vh>PyzoInterpreter._integrate_gui</vh></v>
<v t="ekr.20190812072049.286"><vh>PyzoInterpreter._load_ipyhon</vh></v>
<v t="ekr.20190812072049.287"><vh>PyzoInterpreter.process_commands</vh></v>
<v t="ekr.20190812072049.288"><vh>PyzoInterpreter._process_commands</vh></v>
<v t="ekr.20190812072049.289"><vh>PyzoInterpreter._resetbuffer</vh></v>
<v t="ekr.20190812072049.290"><vh>PyzoInterpreter.pushline</vh></v>
<v t="ekr.20190812072049.291"><vh>PyzoInterpreter._runlines</vh></v>
<v t="ekr.20190812072049.292"><vh>PyzoInterpreter.runlargecode</vh></v>
<v t="ekr.20190812072049.293"><vh>PyzoInterpreter.runfile</vh></v>
<v t="ekr.20190812072049.294"><vh>PyzoInterpreter.compilecode</vh></v>
<v t="ekr.20190812072049.295"><vh>PyzoInterpreter.execcode</vh></v>
<v t="ekr.20190812072049.296"><vh>PyzoInterpreter.apply_breakpoints</vh></v>
<v t="ekr.20190812072049.297"><vh>PyzoInterpreter.ipython_pre_run_cell_hook</vh></v>
<v t="ekr.20190812072049.298"><vh>PyzoInterpreter.ipython_editor_hook</vh></v>
<v t="ekr.20190812072049.299"><vh>PyzoInterpreter.ipython_ask_exit</vh></v>
<v t="ekr.20190812072049.300"><vh>PyzoInterpreter.dbstop_handler</vh></v>
<v t="ekr.20190812072049.301"><vh>PyzoInterpreter.write</vh></v>
<v t="ekr.20190812072049.302"><vh>PyzoInterpreter.showsyntaxerror</vh></v>
<v t="ekr.20190812072049.303"><vh>PyzoInterpreter.showtraceback</vh></v>
<v t="ekr.20190812072049.304"><vh>PyzoInterpreter.correctfilenameandlineno</vh></v>
</v>
<v t="ekr.20190812072049.305"><vh>class ExecutedSourceCollection</vh>
<v t="ekr.20190812072049.306"><vh>ExecutedSourceCollection.__init__</vh></v>
<v t="ekr.20190812072049.307"><vh>ExecutedSourceCollection.store_source</vh></v>
<v t="ekr.20190812072049.308"><vh>ExecutedSourceCollection._patch</vh></v>
</v>
</v>
<v t="ekr.20190812072049.309"><vh>@clean introspection.py</vh>
<v t="ekr.20190812072049.310"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.311"><vh>class PyzoIntrospector(yoton.RepChannel)</vh>
<v t="ekr.20190812072049.312"><vh>PyzoIntrospector._getNameSpace</vh></v>
<v t="ekr.20190812072049.313"><vh>PyzoIntrospector._getSignature</vh></v>
<v t="ekr.20190812072049.314"><vh>PyzoIntrospector.dir</vh></v>
<v t="ekr.20190812072049.315"><vh>PyzoIntrospector.dir2</vh></v>
<v t="ekr.20190812072049.316"><vh>PyzoIntrospector.signature</vh></v>
<v t="ekr.20190812072049.317"><vh>PyzoIntrospector.doc</vh></v>
<v t="ekr.20190812072049.318"><vh>PyzoIntrospector.eval</vh></v>
<v t="ekr.20190812072049.319"><vh>PyzoIntrospector.interrupt</vh></v>
<v t="ekr.20190812072049.320"><vh>PyzoIntrospector.terminate</vh></v>
</v>
</v>
<v t="ekr.20190812072049.321"><vh>@clean magic.py</vh>
<v t="ekr.20190812072049.322"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.323"><vh>_should_not_interpret_as_magic</vh></v>
<v t="ekr.20190812072049.324"><vh>class Magician</vh>
<v t="ekr.20190812072049.325"><vh>Magician._eval</vh></v>
<v t="ekr.20190812072049.326"><vh>Magician.convert_command</vh></v>
<v t="ekr.20190812072049.327"><vh>Magician._convert_command</vh></v>
<v t="ekr.20190812072049.328"><vh>Magician.debug</vh></v>
<v t="ekr.20190812072049.329"><vh>Magician.cd</vh></v>
<v t="ekr.20190812072049.330"><vh>Magician.ls</vh></v>
<v t="ekr.20190812072049.331"><vh>Magician.timeit</vh></v>
<v t="ekr.20190812072049.332"><vh>Magician.who</vh></v>
<v t="ekr.20190812072049.333"><vh>Magician._justify</vh></v>
<v t="ekr.20190812072049.334"><vh>Magician.whos</vh></v>
<v t="ekr.20190812072049.335"><vh>Magician.cls</vh></v>
<v t="ekr.20190812072049.336"><vh>Magician.open</vh></v>
<v t="ekr.20190812072049.337"><vh>Magician.run</vh></v>
<v t="ekr.20190812072049.338"><vh>Magician._hasconda</vh></v>
<v t="ekr.20190812072049.339"><vh>Magician.install</vh></v>
<v t="ekr.20190812072049.340"><vh>Magician.update</vh></v>
<v t="ekr.20190812072049.341"><vh>Magician.remove</vh></v>
<v t="ekr.20190812072049.342"><vh>Magician.conda</vh></v>
<v t="ekr.20190812072049.343"><vh>Magician._check_imported_modules</vh></v>
<v t="ekr.20190812072049.344"><vh>Magician.pip</vh></v>
<v t="ekr.20190812072049.345"><vh>Magician.notebook</vh></v>
</v>
</v>
<v t="ekr.20190812072049.346"><vh>@clean pipper.py</vh>
<v t="ekr.20190812072049.347"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.348"><vh>subprocess_with_callback</vh></v>
<v t="ekr.20190812072049.349"><vh>print_</vh></v>
<v t="ekr.20190812072049.350"><vh>pip_command_exe</vh></v>
<v t="ekr.20190812072049.351"><vh>pip_command</vh></v>
</v>
<v t="ekr.20190812072049.352"><vh>@clean start.py</vh>
<v t="ekr.20190812072049.353"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.354"><vh>pyzo_excepthook</vh></v>
</v>
</v>
<v t="ekr.20190812072049.370"><vh>pyzo/resources</vh>
<v t="ekr.20190812072049.371"><vh>@clean tutorial.py</vh>
<v t="ekr.20190812072049.372"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.373"><vh>getNumber</vh></v>
<v t="ekr.20190812072049.374"><vh>foo</vh></v>
<v t="ekr.20190812072049.375"><vh>bar</vh></v>
</v>
</v>
<v t="ekr.20190812072049.381"><vh>pyzo/tools</vh>
<v t="ekr.20190812072049.474"><vh>@clean __init__.py</vh>
<v t="ekr.20190812081316.1"><vh>&lt;&lt; tools/__init__ docstring &gt;&gt;</vh></v>
<v t="ekr.20190812072049.476"><vh>class ToolDockWidget(QtWidgets.QDockWidget)</vh>
<v t="ekr.20190812072049.477"><vh>ToolDockWidget.__init__</vh></v>
<v t="ekr.20190812072049.478"><vh>ToolDockWidget.setTool</vh></v>
<v t="ekr.20190812072049.479"><vh>ToolDockWidget.closeEvent</vh></v>
<v t="ekr.20190812072049.480"><vh>ToolDockWidget.reload</vh></v>
</v>
<v t="ekr.20190812072049.481"><vh>class ToolDescription</vh>
<v t="ekr.20190812072049.482"><vh>ToolDescription.__init__</vh></v>
<v t="ekr.20190812072049.483"><vh>ToolDescription.menuLauncher</vh></v>
</v>
<v t="ekr.20190812072049.484"><vh>class ToolManager(QtCore.QObject)</vh>
<v t="ekr.20190812072049.485"><vh>ToolManager.__init__</vh></v>
<v t="ekr.20190812072049.486"><vh>ToolManager.loadToolInfo</vh></v>
<v t="ekr.20190812072049.487"><vh>ToolManager.updateToolInstances</vh></v>
<v t="ekr.20190812072049.488"><vh>ToolManager.getToolInfo</vh></v>
<v t="ekr.20190812072049.489"><vh>ToolManager.getToolClass</vh></v>
<v t="ekr.20190812072049.490"><vh>ToolManager.loadTool</vh></v>
<v t="ekr.20190812072049.491"><vh>ToolManager.reloadTools</vh></v>
<v t="ekr.20190812072049.492"><vh>ToolManager.closeTool</vh></v>
<v t="ekr.20190812072049.493"><vh>ToolManager.getTool</vh></v>
<v t="ekr.20190812072049.494"><vh>ToolManager.onToolClose</vh></v>
<v t="ekr.20190812072049.495"><vh>ToolManager.getLoadedTools</vh></v>
</v>
</v>
<v t="ekr.20190812072049.382"><vh>@clean pyzoHistoryViewer.py</vh>
<v t="ekr.20190812072049.383"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.384"><vh>class PyzoHistoryViewer(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072049.385"><vh>PyzoHistoryViewer.__init__</vh></v>
<v t="ekr.20190812072049.386"><vh>PyzoHistoryViewer._on_search</vh></v>
<v t="ekr.20190812072049.387"><vh>PyzoHistoryViewer._on_command_added</vh></v>
<v t="ekr.20190812072049.388"><vh>PyzoHistoryViewer._on_command_removed</vh></v>
<v t="ekr.20190812072049.389"><vh>PyzoHistoryViewer._on_commands_reset</vh></v>
<v t="ekr.20190812072049.390"><vh>PyzoHistoryViewer._onCustomContextMenuRequested</vh></v>
<v t="ekr.20190812072049.391"><vh>PyzoHistoryViewer.copy</vh></v>
<v t="ekr.20190812072049.392"><vh>PyzoHistoryViewer.removeSelection</vh></v>
<v t="ekr.20190812072049.393"><vh>PyzoHistoryViewer.runSelection</vh></v>
<v t="ekr.20190812072049.394"><vh>PyzoHistoryViewer._onDoubleClicked</vh></v>
</v>
</v>
<v t="ekr.20190812072049.395"><vh>@clean pyzoInteractiveHelp.py</vh>
<v t="ekr.20190812072049.396"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.397"><vh>get_title_text</vh></v>
<v t="ekr.20190812072049.398"><vh>class PyzoInteractiveHelp(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072049.399"><vh>PyzoInteractiveHelp.__init__</vh></v>
<v t="ekr.20190812072049.400"><vh>PyzoInteractiveHelp.onOptionsPress</vh></v>
<v t="ekr.20190812072049.401"><vh>PyzoInteractiveHelp.onOptionMenuTiggered</vh></v>
<v t="ekr.20190812072049.402"><vh>PyzoInteractiveHelp.setText</vh></v>
<v t="ekr.20190812072049.403"><vh>PyzoInteractiveHelp.setObjectName</vh></v>
<v t="ekr.20190812072049.404"><vh>PyzoInteractiveHelp.printDoc</vh></v>
<v t="ekr.20190812072049.405"><vh>PyzoInteractiveHelp.queryDoc</vh></v>
<v t="ekr.20190812072049.406"><vh>PyzoInteractiveHelp.queryDoc_response</vh></v>
<v t="ekr.20190812072049.407"><vh>PyzoInteractiveHelp.smartFormat</vh></v>
</v>
</v>
<v t="ekr.20190812072049.408"><vh>@clean pyzoLogger.py</vh>
<v t="ekr.20190812072049.409"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.410"><vh>class PyzoLogger(BaseShell)</vh>
<v t="ekr.20190812072049.411"><vh>PyzoLogger.__init__</vh></v>
<v t="ekr.20190812072049.412"><vh>PyzoLogger.executeCommand</vh></v>
<v t="ekr.20190812072049.413"><vh>PyzoLogger.writeErr</vh></v>
<v t="ekr.20190812072049.414"><vh>PyzoLogger.processAutoComp</vh></v>
</v>
</v>
<v t="ekr.20190812072049.415"><vh>@clean pyzoSourceStructure.py</vh>
<v t="ekr.20190812072049.416"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.417"><vh>class Navigation</vh>
<v t="ekr.20190812072049.418"><vh>Navigation.__init__</vh></v>
</v>
<v t="ekr.20190812072049.419"><vh>class PyzoSourceStructure(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072049.420"><vh>PyzoSourceStructure.__init__</vh></v>
<v t="ekr.20190812072049.421"><vh>PyzoSourceStructure.onOptionsPress</vh></v>
<v t="ekr.20190812072049.422"><vh>PyzoSourceStructure.onOptionMenuTiggered</vh></v>
<v t="ekr.20190812072049.423"><vh>PyzoSourceStructure.onEditorsCurrentChanged</vh></v>
<v t="ekr.20190812072049.424"><vh>PyzoSourceStructure._getCurrentNav</vh></v>
<v t="ekr.20190812072049.425"><vh>PyzoSourceStructure.onNavBack</vh></v>
<v t="ekr.20190812072049.426"><vh>PyzoSourceStructure.onNavForward</vh></v>
<v t="ekr.20190812072049.427"><vh>PyzoSourceStructure.onItemClick</vh></v>
<v t="ekr.20190812072049.428"><vh>PyzoSourceStructure._navigate_to_line</vh></v>
<v t="ekr.20190812072049.429"><vh>PyzoSourceStructure.updateStructure</vh></v>
</v>
</v>
<v t="ekr.20190812072049.430"><vh>@clean pyzoWebBrowser.py</vh>
<v t="ekr.20190812072049.431"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.432"><vh>class WebView(QtWidgets.QTextBrowser)</vh>
<v t="ekr.20190812072049.433"><vh>WebView.__init__</vh></v>
<v t="ekr.20190812072049.434"><vh>WebView.wheelEvent</vh></v>
<v t="ekr.20190812072049.435"><vh>WebView.url</vh></v>
<v t="ekr.20190812072049.436"><vh>WebView._getUrlParts</vh></v>
<v t="ekr.20190812072049.437"><vh>WebView.back</vh></v>
<v t="ekr.20190812072049.438"><vh>WebView.forward</vh></v>
<v t="ekr.20190812072049.439"><vh>WebView.load</vh></v>
<v t="ekr.20190812072049.440"><vh>WebView._load</vh></v>
</v>
<v t="ekr.20190812072049.441"><vh>class PyzoWebBrowser(QtWidgets.QFrame)</vh>
<v t="ekr.20190812072049.442"><vh>PyzoWebBrowser.__init__ (no longer changed)</vh></v>
<v t="ekr.20190812072049.443"><vh>PyzoWebBrowser.parseAddress</vh></v>
<v t="ekr.20190812072049.444"><vh>PyzoWebBrowser.go</vh></v>
<v t="ekr.20190812072049.445"><vh>PyzoWebBrowser.onLoadStart</vh></v>
<v t="ekr.20190812072049.446"><vh>PyzoWebBrowser.onLoadEnd</vh></v>
<v t="ekr.20190812072049.447"><vh>PyzoWebBrowser.onBack</vh></v>
<v t="ekr.20190812072049.448"><vh>PyzoWebBrowser.onForward</vh></v>
<v t="ekr.20190812072049.449"><vh>PyzoWebBrowser.wheelEvent</vh></v>
</v>
</v>
<v t="ekr.20190812072049.450"><vh>@clean pyzoWorkspace.py</vh>
<v t="ekr.20190812072049.451"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.452"><vh>splitName</vh></v>
<v t="ekr.20190812072049.453"><vh>joinName</vh></v>
<v t="ekr.20190812072049.454"><vh>class WorkspaceProxy(QtCore.QObject)</vh>
<v t="ekr.20190812072049.455"><vh>WorkspaceProxy.__init__</vh></v>
<v t="ekr.20190812072049.456"><vh>WorkspaceProxy.addNamePart</vh></v>
<v t="ekr.20190812072049.457"><vh>WorkspaceProxy.setName</vh></v>
<v t="ekr.20190812072049.458"><vh>WorkspaceProxy.goUp</vh></v>
<v t="ekr.20190812072049.459"><vh>WorkspaceProxy.onCurrentShellChanged</vh></v>
<v t="ekr.20190812072049.460"><vh>WorkspaceProxy.onCurrentShellStateChanged</vh></v>
<v t="ekr.20190812072049.461"><vh>WorkspaceProxy.processResponse</vh></v>
</v>
<v t="ekr.20190812072049.462"><vh>class WorkspaceItem(QtWidgets.QTreeWidgetItem)</vh>
<v t="ekr.20190812072049.463"><vh>WorkspaceItem.__lt__</vh></v>
</v>
<v t="ekr.20190812072049.464"><vh>class WorkspaceTree(QtWidgets.QTreeWidget)</vh>
<v t="ekr.20190812072049.465"><vh>WorkspaceTree.__init__</vh></v>
<v t="ekr.20190812072049.466"><vh>WorkspaceTree.contextMenuEvent</vh></v>
<v t="ekr.20190812072049.467"><vh>WorkspaceTree.contextMenuTriggered</vh></v>
<v t="ekr.20190812072049.468"><vh>WorkspaceTree.onItemExpand</vh></v>
<v t="ekr.20190812072049.469"><vh>WorkspaceTree.fillWorkspace</vh></v>
</v>
<v t="ekr.20190812072049.470"><vh>class PyzoWorkspace(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072049.471"><vh>PyzoWorkspace.__init__</vh></v>
<v t="ekr.20190812072049.472"><vh>PyzoWorkspace.onOptionsPress</vh></v>
<v t="ekr.20190812072049.473"><vh>PyzoWorkspace.onOptionMenuTiggered</vh></v>
</v>
</v>
<v t="ekr.20190812072049.497"><vh>tools/pyzoFileBrowser</vh>
<v t="ekr.20190812072050.183"><vh>@clean __init__.py</vh>
<v t="ekr.20190812072050.184"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.185"><vh>class PyzoFileBrowser(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072050.186"><vh>PyzoFileBrowser.__init__ (changed)</vh></v>
<v t="ekr.20190812072050.187"><vh>PyzoFileBrowser.path</vh></v>
<v t="ekr.20190812072050.188"><vh>PyzoFileBrowser.setPath</vh></v>
<v t="ekr.20190812072050.189"><vh>PyzoFileBrowser.getAddToPythonPath</vh></v>
<v t="ekr.20190812072050.190"><vh>PyzoFileBrowser.getDefaultSavePath</vh></v>
<v t="ekr.20190812072050.191"><vh>PyzoFileBrowser.closeEvent</vh></v>
</v>
</v>
<v t="ekr.20190812072049.498"><vh>@clean browser.py</vh>
<v t="ekr.20190812072049.499"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.500"><vh>class Browser(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072049.501"><vh>Browser.__init__</vh></v>
<v t="ekr.20190812072049.502"><vh>Browser.getImportWizard</vh></v>
<v t="ekr.20190812072049.503"><vh>Browser._layout</vh></v>
<v t="ekr.20190812072049.504"><vh>Browser.closeEvent</vh></v>
<v t="ekr.20190812072049.505"><vh>Browser.nameFilter</vh></v>
<v t="ekr.20190812072049.506"><vh>Browser.searchFilter</vh></v>
<v t="ekr.20190812072049.507"><vh>Browser.expandedDirs</vh></v>
<v t="ekr.20190812072049.508"><vh>Browser.starredDirs</vh></v>
<v t="ekr.20190812072049.509"><vh>Browser.dictForStarredDir</vh></v>
<v t="ekr.20190812072049.510"><vh>Browser.addStarredDir</vh></v>
<v t="ekr.20190812072049.511"><vh>Browser.removeStarredDir</vh></v>
<v t="ekr.20190812072049.512"><vh>Browser.test</vh></v>
<v t="ekr.20190812072049.513"><vh>Browser.currentProject</vh></v>
</v>
<v t="ekr.20190812072049.514"><vh>class LineEditWithToolButtons(QtWidgets.QLineEdit)</vh>
<v t="ekr.20190812072049.515"><vh>LineEditWithToolButtons.__init__</vh></v>
<v t="ekr.20190812072049.516"><vh>LineEditWithToolButtons.addButtonLeft</vh></v>
<v t="ekr.20190812072049.517"><vh>LineEditWithToolButtons.addButtonRight</vh></v>
<v t="ekr.20190812072049.518"><vh>LineEditWithToolButtons._addButton</vh></v>
<v t="ekr.20190812072049.519"><vh>LineEditWithToolButtons.setButtonVisible</vh></v>
<v t="ekr.20190812072049.520"><vh>LineEditWithToolButtons.resizeEvent</vh></v>
<v t="ekr.20190812072049.521"><vh>LineEditWithToolButtons.showEvent</vh></v>
<v t="ekr.20190812072049.522"><vh>LineEditWithToolButtons._updateGeometry</vh></v>
</v>
<v t="ekr.20190812072049.523"><vh>class PathInput(LineEditWithToolButtons)</vh>
<v t="ekr.20190812072049.524"><vh>PathInput.__init__</vh></v>
<v t="ekr.20190812072049.525"><vh>PathInput.setPath</vh></v>
<v t="ekr.20190812072049.526"><vh>PathInput.checkValid</vh></v>
<v t="ekr.20190812072049.527"><vh>PathInput.event</vh></v>
<v t="ekr.20190812072049.528"><vh>PathInput.onTextEdited</vh></v>
<v t="ekr.20190812072049.529"><vh>PathInput.focusOutEvent</vh></v>
</v>
<v t="ekr.20190812072049.530"><vh>class Projects(QtWidgets.QWidget)</vh>
<v t="ekr.20190812072049.531"><vh>Projects.__init__</vh></v>
<v t="ekr.20190812072049.532"><vh>Projects.currentDict</vh></v>
<v t="ekr.20190812072049.533"><vh>Projects.setPath</vh></v>
<v t="ekr.20190812072049.534"><vh>Projects.updateProjectList</vh></v>
<v t="ekr.20190812072049.535"><vh>Projects.buildMenu</vh></v>
<v t="ekr.20190812072049.536"><vh>Projects.onMenuTriggered</vh></v>
<v t="ekr.20190812072049.537"><vh>Projects.onButtonPressed</vh></v>
<v t="ekr.20190812072049.538"><vh>Projects.onProjectSelect</vh></v>
</v>
<v t="ekr.20190812072049.539"><vh>class NameFilter(LineEditWithToolButtons)</vh>
<v t="ekr.20190812072049.540"><vh>NameFilter.__init__</vh></v>
<v t="ekr.20190812072049.541"><vh>NameFilter.setText</vh></v>
<v t="ekr.20190812072049.542"><vh>NameFilter.checkFilterValue</vh></v>
<v t="ekr.20190812072049.543"><vh>NameFilter.onMenuTriggered</vh></v>
</v>
<v t="ekr.20190812072049.544"><vh>class SearchFilter(LineEditWithToolButtons)</vh>
<v t="ekr.20190812072049.545"><vh>SearchFilter.__init__</vh></v>
<v t="ekr.20190812072049.546"><vh>SearchFilter.onCancelPressed</vh></v>
<v t="ekr.20190812072049.547"><vh>SearchFilter.checkFilterValue</vh></v>
<v t="ekr.20190812072049.548"><vh>SearchFilter.forceFilterChanged</vh></v>
<v t="ekr.20190812072049.549"><vh>SearchFilter.updateCancelButton</vh></v>
<v t="ekr.20190812072049.550"><vh>SearchFilter.buildMenu</vh></v>
<v t="ekr.20190812072049.551"><vh>SearchFilter.onMenuTriggered</vh></v>
</v>
</v>
<v t="ekr.20190812072049.552"><vh>@clean importwizard.py</vh>
<v t="ekr.20190812072049.553"><vh>Declarations</vh></v>
<v t="ekr.20190812072049.554"><vh>class CodeView</vh></v>
<v t="ekr.20190812072049.555"><vh>class SelectFilePage(QtWidgets.QWizardPage)</vh>
<v t="ekr.20190812072049.556"><vh>SelectFilePage.__init__</vh></v>
<v t="ekr.20190812072049.557"><vh>SelectFilePage.onBrowseClicked</vh></v>
<v t="ekr.20190812072049.558"><vh>SelectFilePage.updatePreview</vh></v>
<v t="ekr.20190812072049.559"><vh>SelectFilePage.isComplete</vh></v>
</v>
<v t="ekr.20190812072049.560"><vh>class SetParametersPage(QtWidgets.QWizardPage)</vh>
<v t="ekr.20190812072049.561"><vh>SetParametersPage.__init__</vh></v>
<v t="ekr.20190812072049.562"><vh>SetParametersPage.columnNames</vh></v>
<v t="ekr.20190812072049.563"><vh>SetParametersPage.updateHorizontalHeaderLabels</vh></v>
<v t="ekr.20190812072049.564"><vh>SetParametersPage.onRowHeaderClicked</vh></v>
<v t="ekr.20190812072049.565"><vh>SetParametersPage.parseColumnNames</vh></v>
<v t="ekr.20190812072049.566"><vh>SetParametersPage.selectedColumns</vh></v>
<v t="ekr.20190812072049.567"><vh>SetParametersPage.initializePage</vh></v>
<v t="ekr.20190812072049.568"><vh>SetParametersPage.updatePreview</vh></v>
</v>
<v t="ekr.20190812072049.569"><vh>class ResultPage(QtWidgets.QWizardPage)</vh>
<v t="ekr.20190812072049.570"><vh>ResultPage.__init__</vh></v>
<v t="ekr.20190812072049.571"><vh>ResultPage.initializePage</vh></v>
<v t="ekr.20190812072049.572"><vh>ResultPage.updateCode</vh></v>
<v t="ekr.20190812072049.573"><vh>ResultPage.getCode</vh></v>
<v t="ekr.20190812072049.574"><vh>ResultPage.onBtnExecuteClicked</vh></v>
<v t="ekr.20190812072049.575"><vh>ResultPage.onBtnInsertClicked</vh></v>
</v>
<v t="ekr.20190812072049.576"><vh>class ImportWizard(QtWidgets.QWizard)</vh>
<v t="ekr.20190812072049.577"><vh>ImportWizard.__init__</vh></v>
<v t="ekr.20190812072049.578"><vh>ImportWizard.onCurrentIdChanged</vh></v>
<v t="ekr.20190812072049.579"><vh>ImportWizard.open</vh></v>
<v t="ekr.20190812072049.580"><vh>ImportWizard.field</vh></v>
<v t="ekr.20190812072049.581"><vh>ImportWizard.setPreviewData</vh></v>
<v t="ekr.20190812072049.582"><vh>ImportWizard.previewData</vh></v>
</v>
</v>
<v t="ekr.20190812072050.1"><vh>@clean proxies.py</vh>
<v t="ekr.20190812072050.2"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.3"><vh>class Task</vh>
<v t="ekr.20190812072050.4"><vh>Task.__init__</vh></v>
<v t="ekr.20190812072050.5"><vh>Task.process</vh></v>
<v t="ekr.20190812072050.6"><vh>Task._run</vh></v>
<v t="ekr.20190812072050.7"><vh>Task.result</vh></v>
</v>
<v t="ekr.20190812072050.8"><vh>class PathProxy(QtCore.QObject)</vh>
<v t="ekr.20190812072050.9"><vh>PathProxy.__init__</vh></v>
<v t="ekr.20190812072050.10"><vh>PathProxy.__repr__</vh></v>
<v t="ekr.20190812072050.11"><vh>PathProxy.path</vh></v>
<v t="ekr.20190812072050.12"><vh>PathProxy.track</vh></v>
<v t="ekr.20190812072050.13"><vh>PathProxy.push</vh></v>
<v t="ekr.20190812072050.14"><vh>PathProxy.cancel</vh></v>
<v t="ekr.20190812072050.15"><vh>PathProxy.pushTask</vh></v>
<v t="ekr.20190812072050.16"><vh>PathProxy._processTasks</vh></v>
</v>
<v t="ekr.20190812072050.17"><vh>class DirProxy(PathProxy)</vh>
<v t="ekr.20190812072050.18"><vh>DirProxy.__init__</vh></v>
<v t="ekr.20190812072050.19"><vh>DirProxy.dirs</vh></v>
<v t="ekr.20190812072050.20"><vh>DirProxy.files</vh></v>
<v t="ekr.20190812072050.21"><vh>DirProxy._process</vh></v>
</v>
<v t="ekr.20190812072050.22"><vh>class FileProxy(PathProxy)</vh>
<v t="ekr.20190812072050.23"><vh>FileProxy.__init__</vh></v>
<v t="ekr.20190812072050.24"><vh>FileProxy.modified</vh></v>
<v t="ekr.20190812072050.25"><vh>FileProxy._process</vh></v>
<v t="ekr.20190812072050.26"><vh>FileProxy.read</vh></v>
<v t="ekr.20190812072050.27"><vh>FileProxy.save</vh></v>
</v>
<v t="ekr.20190812072050.28"><vh>class BaseFSProxy(threading.Thread)</vh>
<v t="ekr.20190812072050.29"><vh>BaseFSProxy.__init__</vh></v>
<v t="ekr.20190812072050.30"><vh>BaseFSProxy._track</vh></v>
<v t="ekr.20190812072050.31"><vh>BaseFSProxy._unTrack</vh></v>
<v t="ekr.20190812072050.32"><vh>BaseFSProxy._push</vh></v>
<v t="ekr.20190812072050.33"><vh>BaseFSProxy.stop</vh></v>
<v t="ekr.20190812072050.34"><vh>BaseFSProxy.dir</vh></v>
<v t="ekr.20190812072050.35"><vh>BaseFSProxy.file</vh></v>
<v t="ekr.20190812072050.36"><vh>BaseFSProxy.run</vh></v>
<v t="ekr.20190812072050.37"><vh>BaseFSProxy._run</vh></v>
<v t="ekr.20190812072050.38"><vh>BaseFSProxy._idle</vh></v>
<v t="ekr.20190812072050.39"><vh>BaseFSProxy._processItem</vh></v>
<v t="ekr.20190812072050.40"><vh>BaseFSProxy.listDirs</vh></v>
<v t="ekr.20190812072050.41"><vh>BaseFSProxy.listFiles</vh></v>
<v t="ekr.20190812072050.42"><vh>BaseFSProxy.modified</vh></v>
<v t="ekr.20190812072050.43"><vh>BaseFSProxy.fileSize</vh></v>
<v t="ekr.20190812072050.44"><vh>BaseFSProxy.read</vh></v>
<v t="ekr.20190812072050.45"><vh>BaseFSProxy.write</vh></v>
<v t="ekr.20190812072050.46"><vh>BaseFSProxy.rename</vh></v>
<v t="ekr.20190812072050.47"><vh>BaseFSProxy.remove</vh></v>
<v t="ekr.20190812072050.48"><vh>BaseFSProxy.createDir</vh></v>
</v>
<v t="ekr.20190812072050.49"><vh>class NativeFSProxy(BaseFSProxy)</vh>
<v t="ekr.20190812072050.50"><vh>NativeFSProxy.listDirs</vh></v>
<v t="ekr.20190812072050.51"><vh>NativeFSProxy.listFiles</vh></v>
<v t="ekr.20190812072050.52"><vh>NativeFSProxy.modified</vh></v>
<v t="ekr.20190812072050.53"><vh>NativeFSProxy.fileSize</vh></v>
<v t="ekr.20190812072050.54"><vh>NativeFSProxy.read</vh></v>
<v t="ekr.20190812072050.55"><vh>NativeFSProxy.write</vh></v>
<v t="ekr.20190812072050.56"><vh>NativeFSProxy.rename</vh></v>
<v t="ekr.20190812072050.57"><vh>NativeFSProxy.remove</vh></v>
<v t="ekr.20190812072050.58"><vh>NativeFSProxy.createDir</vh></v>
</v>
</v>
<v t="ekr.20190812072050.59"><vh>@clean tasks.py</vh>
<v t="ekr.20190812072050.60"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.61"><vh>class SearchTask(proxies.Task)</vh>
<v t="ekr.20190812072050.62"><vh>SearchTask.process</vh></v>
<v t="ekr.20190812072050.63"><vh>SearchTask._getText</vh></v>
<v t="ekr.20190812072050.64"><vh>SearchTask._getIndicesRegExp</vh></v>
<v t="ekr.20190812072050.65"><vh>SearchTask._getIndicesNormal1</vh></v>
<v t="ekr.20190812072050.66"><vh>SearchTask._getIndicesNormal2</vh></v>
<v t="ekr.20190812072050.67"><vh>SearchTask._indicesToLines</vh></v>
<v t="ekr.20190812072050.68"><vh>SearchTask._determineLineEnding</vh></v>
</v>
<v t="ekr.20190812072050.69"><vh>class PeekTask(proxies.Task)</vh>
<v t="ekr.20190812072050.70"><vh>PeekTask.process</vh></v>
<v t="ekr.20190812072050.71"><vh>PeekTask._parseLines</vh></v>
</v>
<v t="ekr.20190812072050.72"><vh>class DocstringTask(proxies.Task)</vh>
<v t="ekr.20190812072050.73"><vh>DocstringTask.process</vh></v>
</v>
<v t="ekr.20190812072050.74"><vh>class RenameTask(proxies.Task)</vh>
<v t="ekr.20190812072050.75"><vh>RenameTask.process</vh></v>
</v>
<v t="ekr.20190812072050.76"><vh>class CreateTask(proxies.Task)</vh>
<v t="ekr.20190812072050.77"><vh>CreateTask.process</vh></v>
</v>
<v t="ekr.20190812072050.78"><vh>class RemoveTask(proxies.Task)</vh>
<v t="ekr.20190812072050.79"><vh>RemoveTask.process</vh></v>
</v>
</v>
<v t="ekr.20190812072050.80"><vh>@clean tree.py</vh>
<v t="ekr.20190812072050.81"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.82"><vh>addIconOverlays</vh></v>
<v t="ekr.20190812072050.83"><vh>_filterFileByName</vh></v>
<v t="ekr.20190812072050.84"><vh>createMounts</vh></v>
<v t="ekr.20190812072050.85"><vh>createItemsFun</vh></v>
<v t="ekr.20190812072050.86"><vh>filename2sortkey</vh></v>
<v t="ekr.20190812072050.87"><vh>class BrowserItem(QtWidgets.QTreeWidgetItem)</vh>
<v t="ekr.20190812072050.88"><vh>BrowserItem.__init__</vh></v>
<v t="ekr.20190812072050.89"><vh>BrowserItem.path</vh></v>
<v t="ekr.20190812072050.90"><vh>BrowserItem._createDummyItem</vh></v>
<v t="ekr.20190812072050.91"><vh>BrowserItem.onDestroyed</vh></v>
<v t="ekr.20190812072050.92"><vh>BrowserItem.clear</vh></v>
<v t="ekr.20190812072050.93"><vh>BrowserItem.onChanged</vh></v>
<v t="ekr.20190812072050.94"><vh>BrowserItem.onDeleted</vh></v>
<v t="ekr.20190812072050.95"><vh>BrowserItem.onErrored</vh></v>
<v t="ekr.20190812072050.96"><vh>BrowserItem.onTaskFinished</vh></v>
</v>
<v t="ekr.20190812072050.97"><vh>class DriveItem(BrowserItem)</vh>
<v t="ekr.20190812072050.98"><vh>DriveItem.__init__</vh></v>
<v t="ekr.20190812072050.99"><vh>DriveItem.setFileIcon</vh></v>
<v t="ekr.20190812072050.100"><vh>DriveItem.onActivated</vh></v>
</v>
<v t="ekr.20190812072050.101"><vh>class DirItem(BrowserItem)</vh>
<v t="ekr.20190812072050.102"><vh>DirItem.__init__</vh></v>
<v t="ekr.20190812072050.103"><vh>DirItem.setFileIcon</vh></v>
<v t="ekr.20190812072050.104"><vh>DirItem.onActivated</vh></v>
<v t="ekr.20190812072050.105"><vh>DirItem.onExpanded</vh></v>
<v t="ekr.20190812072050.106"><vh>DirItem.onCollapsed</vh></v>
<v t="ekr.20190812072050.107"><vh>DirItem.onChanged</vh></v>
</v>
<v t="ekr.20190812072050.108"><vh>class FileItem(BrowserItem)</vh>
<v t="ekr.20190812072050.109"><vh>FileItem.__init__</vh></v>
<v t="ekr.20190812072050.110"><vh>FileItem.setFileIcon</vh></v>
<v t="ekr.20190812072050.111"><vh>FileItem.searchContents</vh></v>
<v t="ekr.20190812072050.112"><vh>FileItem.onActivated</vh></v>
<v t="ekr.20190812072050.113"><vh>FileItem.onExpanded</vh></v>
<v t="ekr.20190812072050.114"><vh>FileItem.onCollapsed</vh></v>
<v t="ekr.20190812072050.115"><vh>FileItem.onChanged</vh></v>
<v t="ekr.20190812072050.116"><vh>FileItem.onTaskFinished</vh></v>
</v>
<v t="ekr.20190812072050.117"><vh>class SubFileItem(QtWidgets.QTreeWidgetItem)</vh>
<v t="ekr.20190812072050.118"><vh>SubFileItem.__init__</vh></v>
<v t="ekr.20190812072050.119"><vh>SubFileItem.path</vh></v>
<v t="ekr.20190812072050.120"><vh>SubFileItem.onActivated</vh></v>
</v>
<v t="ekr.20190812072050.121"><vh>class DocstringItem(QtWidgets.QTreeWidgetItem)</vh>
<v t="ekr.20190812072050.122"><vh>DocstringItem.__init__</vh></v>
<v t="ekr.20190812072050.123"><vh>DocstringItem.path</vh></v>
<v t="ekr.20190812072050.124"><vh>DocstringItem.onClicked</vh></v>
</v>
<v t="ekr.20190812072050.125"><vh>class ErrorItem(QtWidgets.QTreeWidgetItem)</vh>
<v t="ekr.20190812072050.126"><vh>ErrorItem.__init__</vh></v>
</v>
<v t="ekr.20190812072050.127"><vh>class SearchInfoItem(ErrorItem)</vh>
<v t="ekr.20190812072050.128"><vh>SearchInfoItem.__init__</vh></v>
<v t="ekr.20190812072050.129"><vh>SearchInfoItem.increaseTotal</vh></v>
<v t="ekr.20190812072050.130"><vh>SearchInfoItem.addFile</vh></v>
<v t="ekr.20190812072050.131"><vh>SearchInfoItem.updateCounts</vh></v>
</v>
<v t="ekr.20190812072050.132"><vh>class TemporaryDirItem</vh>
<v t="ekr.20190812072050.133"><vh>TemporaryDirItem.__init__</vh></v>
<v t="ekr.20190812072050.134"><vh>TemporaryDirItem.clear</vh></v>
<v t="ekr.20190812072050.135"><vh>TemporaryDirItem.onChanged</vh></v>
</v>
<v t="ekr.20190812072050.136"><vh>class TemporaryFileItem</vh>
<v t="ekr.20190812072050.137"><vh>TemporaryFileItem.__init__</vh></v>
<v t="ekr.20190812072050.138"><vh>TemporaryFileItem.search</vh></v>
<v t="ekr.20190812072050.139"><vh>TemporaryFileItem.onSearchResult</vh></v>
</v>
<v t="ekr.20190812072050.140"><vh>class Tree(QtWidgets.QTreeWidget)</vh>
<v t="ekr.20190812072050.141"><vh>Tree.__init__</vh></v>
<v t="ekr.20190812072050.142"><vh>Tree.path</vh></v>
<v t="ekr.20190812072050.143"><vh>Tree.setPath</vh></v>
<v t="ekr.20190812072050.144"><vh>Tree.setPathUp</vh></v>
<v t="ekr.20190812072050.145"><vh>Tree.clear</vh></v>
<v t="ekr.20190812072050.146"><vh>Tree.mouseDoubleClickEvent</vh></v>
<v t="ekr.20190812072050.147"><vh>Tree.onChanged</vh></v>
<v t="ekr.20190812072050.148"><vh>Tree.createItems</vh></v>
<v t="ekr.20190812072050.149"><vh>Tree.onErrored</vh></v>
<v t="ekr.20190812072050.150"><vh>Tree.onDeleted</vh></v>
<v t="ekr.20190812072050.151"><vh>Tree.onItemExpanded</vh></v>
<v t="ekr.20190812072050.152"><vh>Tree.onItemCollapsed</vh></v>
<v t="ekr.20190812072050.153"><vh>Tree.onItemClicked</vh></v>
<v t="ekr.20190812072050.154"><vh>Tree.onItemActivated</vh></v>
<v t="ekr.20190812072050.155"><vh>Tree._storeSelectionState</vh></v>
<v t="ekr.20190812072050.156"><vh>Tree._restoreSelectionState</vh></v>
<v t="ekr.20190812072050.157"><vh>Tree.contextMenuTriggered</vh></v>
</v>
<v t="ekr.20190812072050.158"><vh>class PopupMenu(pyzo.core.menu.Menu)</vh>
<v t="ekr.20190812072050.159"><vh>PopupMenu.__init__</vh></v>
<v t="ekr.20190812072050.160"><vh>PopupMenu.build</vh></v>
<v t="ekr.20190812072050.161"><vh>PopupMenu._star</vh></v>
<v t="ekr.20190812072050.162"><vh>PopupMenu._openOutsidePyzo</vh></v>
<v t="ekr.20190812072050.163"><vh>PopupMenu._showInFinder</vh></v>
<v t="ekr.20190812072050.164"><vh>PopupMenu._copyPath</vh></v>
<v t="ekr.20190812072050.165"><vh>PopupMenu._runAsScript</vh></v>
<v t="ekr.20190812072050.166"><vh>PopupMenu._runNotebook</vh></v>
<v t="ekr.20190812072050.167"><vh>PopupMenu._importData</vh></v>
<v t="ekr.20190812072050.168"><vh>PopupMenu.onDuplicate</vh></v>
<v t="ekr.20190812072050.169"><vh>PopupMenu.onRename</vh></v>
<v t="ekr.20190812072050.170"><vh>PopupMenu.onCreateFile</vh></v>
<v t="ekr.20190812072050.171"><vh>PopupMenu.onCreateDir</vh></v>
<v t="ekr.20190812072050.172"><vh>PopupMenu._createDirOrFile</vh></v>
<v t="ekr.20190812072050.173"><vh>PopupMenu._duplicateOrRename</vh></v>
<v t="ekr.20190812072050.174"><vh>PopupMenu.onDelete</vh></v>
</v>
</v>
<v t="ekr.20190812072050.175"><vh>@clean utils.py</vh>
<v t="ekr.20190812072050.176"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.177"><vh>cleanpath</vh></v>
<v t="ekr.20190812072050.178"><vh>isdir</vh></v>
<v t="ekr.20190812072050.179"><vh>ext</vh></v>
<v t="ekr.20190812072050.180"><vh>getMounts</vh></v>
<v t="ekr.20190812072050.181"><vh>getDrivesWin</vh></v>
<v t="ekr.20190812072050.182"><vh>hasHiddenAttribute</vh></v>
</v>
</v>
</v>
<v t="ekr.20190812072050.193"><vh>pyzo/util</vh>
<v t="ekr.20190812072050.194"><vh>@clean bootstrapconda.py</vh>
<v t="ekr.20190812072050.195"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.196"><vh>check_for_conda_env</vh></v>
<v t="ekr.20190812072050.197"><vh>class AskToInstallConda(QtWidgets.QDialog)</vh>
<v t="ekr.20190812072050.198"><vh>AskToInstallConda.__init__</vh></v>
</v>
<v t="ekr.20190812072050.199"><vh>class Installer(QtWidgets.QDialog)</vh>
<v t="ekr.20190812072050.200"><vh>Installer.__init__</vh></v>
<v t="ekr.20190812072050.201"><vh>Installer.setStatus</vh></v>
<v t="ekr.20190812072050.202"><vh>Installer.addOutput</vh></v>
<v t="ekr.20190812072050.203"><vh>Installer.addStatus</vh></v>
<v t="ekr.20190812072050.204"><vh>Installer.go</vh></v>
<v t="ekr.20190812072050.205"><vh>Installer.make_done</vh></v>
<v t="ekr.20190812072050.206"><vh>Installer.download</vh></v>
<v t="ekr.20190812072050.207"><vh>Installer.install</vh></v>
<v t="ekr.20190812072050.208"><vh>Installer.post_install</vh></v>
<v t="ekr.20190812072050.209"><vh>Installer.install_scipy</vh></v>
<v t="ekr.20190812072050.210"><vh>Installer._run_process</vh></v>
<v t="ekr.20190812072050.211"><vh>Installer.verify</vh></v>
</v>
<v t="ekr.20190812072050.212"><vh>is_64bit</vh></v>
<v t="ekr.20190812072050.213"><vh>py_exe</vh></v>
<v t="ekr.20190812072050.214"><vh>_chunk_read</vh></v>
<v t="ekr.20190812072050.215"><vh>_fetch_file</vh></v>
<v t="ekr.20190812072050.216"><vh>class StreamCatcher(threading.Thread)</vh>
<v t="ekr.20190812072050.217"><vh>StreamCatcher.__init__</vh></v>
<v t="ekr.20190812072050.218"><vh>StreamCatcher.run</vh></v>
<v t="ekr.20190812072050.219"><vh>StreamCatcher.output</vh></v>
</v>
</v>
<v t="ekr.20190812072050.220"><vh>@clean paths.py</vh>
<v t="ekr.20190812072050.221"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.222"><vh>is_frozen</vh></v>
<v t="ekr.20190812072050.223"><vh>temp_dir</vh></v>
<v t="ekr.20190812072050.224"><vh>user_dir</vh></v>
<v t="ekr.20190812072050.225"><vh>appdata_dir</vh></v>
<v t="ekr.20190812072050.226"><vh>common_appdata_dir</vh></v>
<v t="ekr.20190812072050.227"><vh>application_dir</vh></v>
<v t="ekr.20190812072050.228"><vh>pyzo_dirs</vh></v>
<v t="ekr.20190812072050.229"><vh>pyzo_dirs2</vh></v>
</v>
<v t="ekr.20190812072050.230"><vh>@clean pyzowizard.py</vh>
<v t="ekr.20190812072050.231"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.232"><vh>retranslate</vh></v>
<v t="ekr.20190812072050.233"><vh>class PyzoWizard(QtWidgets.QWizard)</vh>
<v t="ekr.20190812072050.234"><vh>PyzoWizard.__init__</vh></v>
<v t="ekr.20190812072050.235"><vh>PyzoWizard.show</vh></v>
</v>
<v t="ekr.20190812072050.236"><vh>class BasePyzoWizardPage(QtWidgets.QWizardPage)</vh>
<v t="ekr.20190812072050.237"><vh>BasePyzoWizardPage.__init__</vh></v>
<v t="ekr.20190812072050.238"><vh>BasePyzoWizardPage.initializePage</vh></v>
</v>
<v t="ekr.20190812072050.239"><vh>class IntroWizardPage(BasePyzoWizardPage)</vh>
<v t="ekr.20190812072050.240"><vh>IntroWizardPage.__init__</vh></v>
<v t="ekr.20190812072050.241"><vh>IntroWizardPage._setNewUser</vh></v>
<v t="ekr.20190812072050.242"><vh>IntroWizardPage.onLanguageChange</vh></v>
</v>
<v t="ekr.20190812072050.243"><vh>class TwocomponentsWizardPage(BasePyzoWizardPage)</vh></v>
<v t="ekr.20190812072050.244"><vh>class EditorWizardPage(BasePyzoWizardPage)</vh></v>
<v t="ekr.20190812072050.245"><vh>class ShellWizardPage1(BasePyzoWizardPage)</vh></v>
<v t="ekr.20190812072050.246"><vh>class ShellWizardPage2(BasePyzoWizardPage)</vh></v>
<v t="ekr.20190812072050.247"><vh>class RuncodeWizardPage1(BasePyzoWizardPage)</vh></v>
<v t="ekr.20190812072050.248"><vh>class RuncodeWizardPage2(BasePyzoWizardPage)</vh></v>
<v t="ekr.20190812072050.249"><vh>class ToolsWizardPage1(BasePyzoWizardPage)</vh></v>
<v t="ekr.20190812072050.250"><vh>class ToolsWizardPage2(BasePyzoWizardPage)</vh></v>
<v t="ekr.20190812072050.251"><vh>class FinalPage(BasePyzoWizardPage)</vh></v>
</v>
<v t="ekr.20190812072050.252"><vh>@clean zon.py</vh>
<v t="ekr.20190812072050.253"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.254"><vh>isidentifier</vh></v>
<v t="ekr.20190812072050.255"><vh>class Dict(_dict)</vh>
<v t="ekr.20190812072050.256"><vh>Dict.__repr__</vh></v>
<v t="ekr.20190812072050.257"><vh>Dict.__getattribute__</vh></v>
<v t="ekr.20190812072050.258"><vh>Dict.__setattr__</vh></v>
<v t="ekr.20190812072050.259"><vh>Dict.__dir__</vh></v>
</v>
<v t="ekr.20190812072050.260"><vh>isstruct</vh></v>
<v t="ekr.20190812072050.261"><vh>new</vh></v>
<v t="ekr.20190812072050.262"><vh>clear</vh></v>
<v t="ekr.20190812072050.263"><vh>copy</vh></v>
<v t="ekr.20190812072050.264"><vh>count</vh></v>
<v t="ekr.20190812072050.265"><vh>loads</vh></v>
<v t="ekr.20190812072050.266"><vh>load</vh></v>
<v t="ekr.20190812072050.267"><vh>saves</vh></v>
<v t="ekr.20190812072050.268"><vh>save</vh></v>
<v t="ekr.20190812072050.269"><vh>class ReaderWriter(object)</vh>
<v t="ekr.20190812072050.270"><vh>ReaderWriter.read</vh></v>
<v t="ekr.20190812072050.271"><vh>ReaderWriter.save</vh></v>
<v t="ekr.20190812072050.272"><vh>ReaderWriter.from_object</vh></v>
<v t="ekr.20190812072050.273"><vh>ReaderWriter.to_object</vh></v>
<v t="ekr.20190812072050.274"><vh>ReaderWriter.to_int_or_float</vh></v>
<v t="ekr.20190812072050.275"><vh>ReaderWriter.from_int</vh></v>
<v t="ekr.20190812072050.276"><vh>ReaderWriter.from_float</vh></v>
<v t="ekr.20190812072050.277"><vh>ReaderWriter.from_unicode</vh></v>
<v t="ekr.20190812072050.278"><vh>ReaderWriter.to_unicode</vh></v>
<v t="ekr.20190812072050.279"><vh>ReaderWriter.from_dict</vh></v>
<v t="ekr.20190812072050.280"><vh>ReaderWriter.to_dict</vh></v>
<v t="ekr.20190812072050.281"><vh>ReaderWriter.from_list</vh></v>
<v t="ekr.20190812072050.282"><vh>ReaderWriter.to_list</vh></v>
</v>
</v>
<v t="ekr.20190812072050.283"><vh>@clean _locale.py</vh>
<v t="ekr.20190812072050.284"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.285"><vh>getLocale</vh></v>
<v t="ekr.20190812072050.286"><vh>setLanguage</vh></v>
<v t="ekr.20190812072050.287"><vh>class Translation(str)</vh></v>
<v t="ekr.20190812072050.288"><vh>_splitMainAndTt</vh></v>
<v t="ekr.20190812072050.289"><vh>translate</vh></v>
<v t="ekr.20190812072050.290"><vh>lhelp</vh></v>
<v t="ekr.20190812072050.291"><vh>linguist</vh></v>
<v t="ekr.20190812072050.292"><vh>lupdate</vh></v>
<v t="ekr.20190812072050.293"><vh>lrelease</vh></v>
</v>
<v t="ekr.20190812072050.294"><vh>@clean __init__.py</vh>
<v t="ekr.20190812072050.295"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072050.297"><vh>util/interpreters</vh>
<v t="ekr.20190812072050.298"><vh>@clean inwinreg.py</vh>
<v t="ekr.20190812072050.299"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.300"><vh>class PythonInReg</vh>
<v t="ekr.20190812072050.301"><vh>PythonInReg.__init__</vh></v>
<v t="ekr.20190812072050.302"><vh>PythonInReg.__repr__</vh></v>
<v t="ekr.20190812072050.303"><vh>PythonInReg._root</vh></v>
<v t="ekr.20190812072050.304"><vh>PythonInReg._reg</vh></v>
<v t="ekr.20190812072050.305"><vh>PythonInReg.create</vh></v>
<v t="ekr.20190812072050.306"><vh>PythonInReg.delete</vh></v>
<v t="ekr.20190812072050.307"><vh>PythonInReg.setInstallPath</vh></v>
<v t="ekr.20190812072050.308"><vh>PythonInReg.installPath</vh></v>
<v t="ekr.20190812072050.309"><vh>PythonInReg.setPythonPath</vh></v>
<v t="ekr.20190812072050.310"><vh>PythonInReg.pythonPath</vh></v>
<v t="ekr.20190812072050.311"><vh>PythonInReg.version</vh></v>
</v>
<v t="ekr.20190812072050.312"><vh>get_interpreters_in_reg</vh></v>
<v t="ekr.20190812072050.313"><vh>_get_interpreter_in_reg</vh></v>
<v t="ekr.20190812072050.314"><vh>register_interpreter</vh></v>
</v>
<v t="ekr.20190812072050.315"><vh>@clean pythoninterpreter.py</vh>
<v t="ekr.20190812072050.316"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.317"><vh>make_abs</vh></v>
<v t="ekr.20190812072050.318"><vh>class PythonInterpreter</vh>
<v t="ekr.20190812072050.319"><vh>PythonInterpreter.__init__</vh></v>
<v t="ekr.20190812072050.320"><vh>PythonInterpreter.__repr__</vh></v>
<v t="ekr.20190812072050.321"><vh>PythonInterpreter.__hash__</vh></v>
<v t="ekr.20190812072050.322"><vh>PythonInterpreter.__eq__</vh></v>
<v t="ekr.20190812072050.323"><vh>PythonInterpreter.path</vh></v>
<v t="ekr.20190812072050.324"><vh>PythonInterpreter.prefix</vh></v>
<v t="ekr.20190812072050.325"><vh>PythonInterpreter.is_conda</vh></v>
<v t="ekr.20190812072050.326"><vh>PythonInterpreter.version</vh></v>
<v t="ekr.20190812072050.327"><vh>PythonInterpreter.version_info</vh></v>
<v t="ekr.20190812072050.328"><vh>PythonInterpreter.register</vh></v>
<v t="ekr.20190812072050.329"><vh>PythonInterpreter._getversion</vh></v>
</v>
<v t="ekr.20190812072050.330"><vh>versionStringToTuple</vh></v>
</v>
<v t="ekr.20190812072050.331"><vh>@clean __init__.py</vh>
<v t="ekr.20190812072050.332"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.333"><vh>get_interpreters</vh></v>
<v t="ekr.20190812072050.334"><vh>_select_interpreters</vh></v>
<v t="ekr.20190812072050.335"><vh>_get_interpreters_win</vh></v>
<v t="ekr.20190812072050.336"><vh>_get_interpreters_posix</vh></v>
<v t="ekr.20190812072050.337"><vh>_get_interpreters_pyzo</vh></v>
<v t="ekr.20190812072050.338"><vh>_get_interpreters_conda</vh></v>
<v t="ekr.20190812072050.339"><vh>_get_interpreters_relative</vh></v>
</v>
</v>
<v t="ekr.20190812072050.341"><vh>util/qt</vh>
<v t="ekr.20190812072050.342"><vh>@clean QtCore.py</vh>
<v t="ekr.20190812072050.343"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072050.344"><vh>@clean QtGui.py</vh>
<v t="ekr.20190812072050.345"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072050.346"><vh>@clean QtHelp.py</vh>
<v t="ekr.20190812072050.347"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072050.348"><vh>@clean QtPrintSupport.py</vh>
<v t="ekr.20190812072050.349"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072050.350"><vh>@clean QtWidgets.py</vh>
<v t="ekr.20190812072050.351"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072050.352"><vh>@clean uic.py</vh>
<v t="ekr.20190812072050.353"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072050.354"><vh>@clean _version.py</vh>
<v t="ekr.20190812072050.355"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072050.356"><vh>@clean __init__.py</vh>
<v t="ekr.20190812072050.357"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.358"><vh>class PythonQtError(Exception)</vh></v>
<v t="ekr.20190812072050.359"><vh>class PythonQtWarning(Warning)</vh></v>
</v>
<v t="ekr.20190812072050.361"><vh>util/qt/_patch</vh>
<v t="ekr.20190812072050.362"><vh>@clean qcombobox.py</vh>
<v t="ekr.20190812072050.363"><vh>patch_qcombobox</vh></v>
</v>
<v t="ekr.20190812072050.364"><vh>@clean qheaderview.py</vh>
<v t="ekr.20190812072050.365"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.366"><vh>introduce_renamed_methods_qheaderview</vh></v>
</v>
<v t="ekr.20190812072050.367"><vh>@clean __init__.py</vh></v>
</v>
</v>
</v>
<v t="ekr.20190812072050.369"><vh>pyzo/yoton</vh>
<v t="ekr.20190812072050.558"><vh>@clean __init__.py</vh>
<v t="ekr.20190812072050.559"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.560"><vh>class SimpleSocket(Context)</vh>
<v t="ekr.20190812072050.561"><vh>SimpleSocket.__init__</vh></v>
<v t="ekr.20190812072050.562"><vh>SimpleSocket.send</vh></v>
<v t="ekr.20190812072050.563"><vh>SimpleSocket.recv</vh></v>
</v>
</v>
<v t="ekr.20190812072050.370"><vh>@clean clientserver.py</vh>
<v t="ekr.20190812072050.371"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.372"><vh>class RequestServer(threading.Thread)</vh>
<v t="ekr.20190812072050.373"><vh>RequestServer.__init__</vh></v>
<v t="ekr.20190812072050.374"><vh>RequestServer.start</vh></v>
<v t="ekr.20190812072050.375"><vh>RequestServer.stop</vh></v>
<v t="ekr.20190812072050.376"><vh>RequestServer.run</vh></v>
<v t="ekr.20190812072050.377"><vh>RequestServer._handle_connection</vh></v>
<v t="ekr.20190812072050.378"><vh>RequestServer._really_handle_connection</vh></v>
<v t="ekr.20190812072050.379"><vh>RequestServer.handle_request</vh></v>
</v>
<v t="ekr.20190812072050.380"><vh>class SocketHandler(threading.Thread)</vh>
<v t="ekr.20190812072050.381"><vh>SocketHandler.__init__</vh></v>
<v t="ekr.20190812072050.382"><vh>SocketHandler.run</vh></v>
</v>
<v t="ekr.20190812072050.383"><vh>do_request</vh></v>
</v>
<v t="ekr.20190812072050.384"><vh>@clean connection.py</vh>
<v t="ekr.20190812072050.385"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.386"><vh>class ConnectionCollection(list)</vh>
<v t="ekr.20190812072050.387"><vh>ConnectionCollection.__getitem__</vh></v>
</v>
<v t="ekr.20190812072050.388"><vh>class Connection(object)</vh>
<v t="ekr.20190812072050.389"><vh>Connection.__init__</vh></v>
<v t="ekr.20190812072050.390"><vh>Connection.hostname1</vh></v>
<v t="ekr.20190812072050.391"><vh>Connection.hostname2</vh></v>
<v t="ekr.20190812072050.392"><vh>Connection.port1</vh></v>
<v t="ekr.20190812072050.393"><vh>Connection.port2</vh></v>
<v t="ekr.20190812072050.394"><vh>Connection.id1</vh></v>
<v t="ekr.20190812072050.395"><vh>Connection.id2</vh></v>
<v t="ekr.20190812072050.396"><vh>Connection.pid1</vh></v>
<v t="ekr.20190812072050.397"><vh>Connection.pid2</vh></v>
<v t="ekr.20190812072050.398"><vh>Connection.is_alive</vh></v>
<v t="ekr.20190812072050.399"><vh>Connection.is_connected</vh></v>
<v t="ekr.20190812072050.400"><vh>Connection.is_waiting</vh></v>
<v t="ekr.20190812072050.401"><vh>Connection.closed</vh></v>
<v t="ekr.20190812072050.402"><vh>Connection.timeout</vh></v>
<v t="ekr.20190812072050.403"><vh>Connection.timedout</vh></v>
<v t="ekr.20190812072050.404"><vh>Connection.name</vh></v>
<v t="ekr.20190812072050.405"><vh>Connection.flush</vh></v>
<v t="ekr.20190812072050.406"><vh>Connection.close</vh></v>
<v t="ekr.20190812072050.407"><vh>Connection.close_on_problem</vh></v>
<v t="ekr.20190812072050.408"><vh>Connection._general_close_method</vh></v>
<v t="ekr.20190812072050.409"><vh>Connection._bind</vh></v>
<v t="ekr.20190812072050.410"><vh>Connection._connect</vh></v>
<v t="ekr.20190812072050.411"><vh>Connection._flush</vh></v>
<v t="ekr.20190812072050.412"><vh>Connection._notify_other_end_of_closing</vh></v>
<v t="ekr.20190812072050.413"><vh>Connection._send_package</vh></v>
<v t="ekr.20190812072050.414"><vh>Connection._inject_package</vh></v>
<v t="ekr.20190812072050.415"><vh>Connection._set_status</vh></v>
</v>
<v t="ekr.20190812072050.416"><vh>class InterConnection(Connection)</vh></v>
<v t="ekr.20190812072050.417"><vh>class UDPConnection(Connection)</vh></v>
</v>
<v t="ekr.20190812072050.418"><vh>@clean connection_itc.py</vh>
<v t="ekr.20190812072050.419"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.420"><vh>class ItcConnection(Connection)</vh></v>
</v>
<v t="ekr.20190812072050.421"><vh>@clean connection_tcp.py</vh>
<v t="ekr.20190812072050.422"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.423"><vh>class TcpConnection(Connection)</vh>
<v t="ekr.20190812072050.424"><vh>TcpConnection.__init__</vh></v>
<v t="ekr.20190812072050.425"><vh>TcpConnection._set_status</vh></v>
<v t="ekr.20190812072050.426"><vh>TcpConnection._bind</vh></v>
<v t="ekr.20190812072050.427"><vh>TcpConnection._connect</vh></v>
<v t="ekr.20190812072050.428"><vh>TcpConnection._notify_other_end_of_closing</vh></v>
<v t="ekr.20190812072050.429"><vh>TcpConnection._flush</vh></v>
<v t="ekr.20190812072050.430"><vh>TcpConnection._send_package</vh></v>
<v t="ekr.20190812072050.431"><vh>TcpConnection._inject_package</vh></v>
</v>
<v t="ekr.20190812072050.432"><vh>class HostThread(threading.Thread)</vh>
<v t="ekr.20190812072050.433"><vh>HostThread.__init__</vh></v>
<v t="ekr.20190812072050.434"><vh>HostThread.run</vh></v>
<v t="ekr.20190812072050.435"><vh>HostThread._wait_for_connection</vh></v>
</v>
<v t="ekr.20190812072050.436"><vh>class HandShaker</vh>
<v t="ekr.20190812072050.437"><vh>HandShaker.__init__</vh></v>
<v t="ekr.20190812072050.438"><vh>HandShaker.shake_hands_as_host</vh></v>
<v t="ekr.20190812072050.439"><vh>HandShaker.shake_hands_as_client</vh></v>
<v t="ekr.20190812072050.440"><vh>HandShaker._send_during_handshaking</vh></v>
<v t="ekr.20190812072050.441"><vh>HandShaker._recv_during_handshaking</vh></v>
</v>
<v t="ekr.20190812072050.442"><vh>class BaseIOThread(threading.Thread)</vh>
<v t="ekr.20190812072050.443"><vh>BaseIOThread.__init__</vh></v>
<v t="ekr.20190812072050.444"><vh>BaseIOThread.run</vh></v>
<v t="ekr.20190812072050.445"><vh>BaseIOThread.run2</vh></v>
</v>
<v t="ekr.20190812072050.446"><vh>class SendingThread(BaseIOThread)</vh>
<v t="ekr.20190812072050.447"><vh>SendingThread._run</vh></v>
</v>
<v t="ekr.20190812072050.448"><vh>class ReceivingThread(BaseIOThread)</vh>
<v t="ekr.20190812072050.449"><vh>ReceivingThread._run</vh></v>
<v t="ekr.20190812072050.450"><vh>ReceivingThread._getPackage</vh></v>
<v t="ekr.20190812072050.451"><vh>ReceivingThread._recv_n_bytes</vh></v>
</v>
</v>
<v t="ekr.20190812072050.452"><vh>@clean context.py</vh>
<v t="ekr.20190812072050.453"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.454"><vh>class Context(object)</vh>
<v t="ekr.20190812072050.455"><vh>Context.__init__</vh></v>
<v t="ekr.20190812072050.456"><vh>Context.close</vh></v>
<v t="ekr.20190812072050.457"><vh>Context.close_channels</vh></v>
<v t="ekr.20190812072050.458"><vh>Context.connections_all</vh></v>
<v t="ekr.20190812072050.459"><vh>Context.connections</vh></v>
<v t="ekr.20190812072050.460"><vh>Context.connection_count</vh></v>
<v t="ekr.20190812072050.461"><vh>Context.id</vh></v>
<v t="ekr.20190812072050.462"><vh>Context.bind</vh></v>
<v t="ekr.20190812072050.463"><vh>Context.connect</vh></v>
<v t="ekr.20190812072050.464"><vh>Context.flush</vh></v>
<v t="ekr.20190812072050.465"><vh>Context._register_sending_channel</vh></v>
<v t="ekr.20190812072050.466"><vh>Context._register_receiving_channel</vh></v>
<v t="ekr.20190812072050.467"><vh>Context._unregister_channel</vh></v>
<v t="ekr.20190812072050.468"><vh>Context._send_package</vh></v>
<v t="ekr.20190812072050.469"><vh>Context._recv_package</vh></v>
<v t="ekr.20190812072050.470"><vh>Context._recv_context_package</vh></v>
</v>
</v>
<v t="ekr.20190812072050.471"><vh>@clean core.py</vh>
<v t="ekr.20190812072050.472"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.473"><vh>can_send</vh></v>
<v t="ekr.20190812072050.474"><vh>can_recv</vh></v>
<v t="ekr.20190812072050.475"><vh>send_all</vh></v>
<v t="ekr.20190812072050.476"><vh>recv_all</vh></v>
<v t="ekr.20190812072050.477"><vh>class Package(object)</vh>
<v t="ekr.20190812072050.478"><vh>Package.__init__</vh></v>
<v t="ekr.20190812072050.479"><vh>Package.parts</vh></v>
<v t="ekr.20190812072050.480"><vh>Package.__str__</vh></v>
<v t="ekr.20190812072050.481"><vh>Package.from_header</vh></v>
</v>
</v>
<v t="ekr.20190812072050.482"><vh>@clean events.py</vh>
<v t="ekr.20190812072050.483"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.484"><vh>class CallableObject(object)</vh>
<v t="ekr.20190812072050.485"><vh>CallableObject.__init__</vh></v>
<v t="ekr.20190812072050.486"><vh>CallableObject.isdead</vh></v>
<v t="ekr.20190812072050.487"><vh>CallableObject.compare</vh></v>
<v t="ekr.20190812072050.488"><vh>CallableObject.__str__</vh></v>
<v t="ekr.20190812072050.489"><vh>CallableObject.call</vh></v>
</v>
<v t="ekr.20190812072050.490"><vh>class Event(object)</vh>
<v t="ekr.20190812072050.491"><vh>Event.__init__</vh></v>
<v t="ekr.20190812072050.492"><vh>Event.dispatch</vh></v>
<v t="ekr.20190812072050.493"><vh>Event._on_timeout</vh></v>
</v>
<v t="ekr.20190812072050.494"><vh>class Signal</vh>
<v t="ekr.20190812072050.495"><vh>Signal.__init__</vh></v>
<v t="ekr.20190812072050.496"><vh>Signal.type</vh></v>
<v t="ekr.20190812072050.497"><vh>Signal.bind</vh></v>
<v t="ekr.20190812072050.498"><vh>Signal.unbind</vh></v>
<v t="ekr.20190812072050.499"><vh>Signal.emit</vh></v>
<v t="ekr.20190812072050.500"><vh>Signal.emit_now</vh></v>
</v>
<v t="ekr.20190812072050.501"><vh>class TheTimerThread(threading.Thread)</vh>
<v t="ekr.20190812072050.502"><vh>TheTimerThread.__init__</vh></v>
<v t="ekr.20190812072050.503"><vh>TheTimerThread.stop</vh></v>
<v t="ekr.20190812072050.504"><vh>TheTimerThread.add</vh></v>
<v t="ekr.20190812072050.505"><vh>TheTimerThread._sort</vh></v>
<v t="ekr.20190812072050.506"><vh>TheTimerThread.discard</vh></v>
<v t="ekr.20190812072050.507"><vh>TheTimerThread.run</vh></v>
<v t="ekr.20190812072050.508"><vh>TheTimerThread._mainloop</vh></v>
</v>
<v t="ekr.20190812072050.509"><vh>class Timer(Signal)</vh>
<v t="ekr.20190812072050.510"><vh>Timer.__init__</vh></v>
<v t="ekr.20190812072050.511"><vh>Timer.interval</vh></v>
<v t="ekr.20190812072050.512"><vh>Timer.oneshot</vh></v>
<v t="ekr.20190812072050.513"><vh>Timer.running</vh></v>
<v t="ekr.20190812072050.514"><vh>Timer.start</vh></v>
<v t="ekr.20190812072050.515"><vh>Timer.stop</vh></v>
<v t="ekr.20190812072050.516"><vh>Timer._on_timeout</vh></v>
</v>
<v t="ekr.20190812072050.517"><vh>class YotonApplication(object)</vh>
<v t="ekr.20190812072050.518"><vh>YotonApplication.call_later</vh></v>
<v t="ekr.20190812072050.519"><vh>YotonApplication.post_event</vh></v>
<v t="ekr.20190812072050.520"><vh>YotonApplication.post_event_asap</vh></v>
<v t="ekr.20190812072050.521"><vh>YotonApplication.post_event_later</vh></v>
<v t="ekr.20190812072050.522"><vh>YotonApplication.process_events</vh></v>
<v t="ekr.20190812072050.523"><vh>YotonApplication.start_event_loop</vh></v>
<v t="ekr.20190812072050.524"><vh>YotonApplication.stop_event_loop</vh></v>
<v t="ekr.20190812072050.525"><vh>YotonApplication.embed_event_loop</vh></v>
</v>
</v>
<v t="ekr.20190812072050.526"><vh>@clean misc.py</vh>
<v t="ekr.20190812072050.527"><vh>Declarations</vh></v>
<v t="ekr.20190812072050.528"><vh>Property</vh></v>
<v t="ekr.20190812072050.529"><vh>getErrorMsg</vh></v>
<v t="ekr.20190812072050.530"><vh>slot_hash</vh></v>
<v t="ekr.20190812072050.531"><vh>port_hash</vh></v>
<v t="ekr.20190812072050.532"><vh>split_address</vh></v>
<v t="ekr.20190812072050.533"><vh>class UID</vh>
<v t="ekr.20190812072050.534"><vh>UID.__init__</vh></v>
<v t="ekr.20190812072050.535"><vh>UID.__repr__</vh></v>
<v t="ekr.20190812072050.536"><vh>UID.get_hex</vh></v>
<v t="ekr.20190812072050.537"><vh>UID.get_bytes</vh></v>
<v t="ekr.20190812072050.538"><vh>UID.get_int</vh></v>
<v t="ekr.20190812072050.539"><vh>UID._get_random_int</vh></v>
<v t="ekr.20190812072050.540"><vh>UID._get_time_int</vh></v>
</v>
<v t="ekr.20190812072050.541"><vh>class PackageQueue(object)</vh>
<v t="ekr.20190812072050.542"><vh>class Empty(Exception)</vh>
<v t="ekr.20190812072050.543"><vh>Empty.__init__</vh></v>
</v>
<v t="ekr.20190812072050.544"><vh>__init__</vh></v>
<v t="ekr.20190812072050.545"><vh>full</vh></v>
<v t="ekr.20190812072050.546"><vh>empty</vh></v>
<v t="ekr.20190812072050.547"><vh>push</vh></v>
<v t="ekr.20190812072050.548"><vh>insert</vh></v>
<v t="ekr.20190812072050.549"><vh>pop</vh></v>
<v t="ekr.20190812072050.550"><vh>peek</vh></v>
<v t="ekr.20190812072050.551"><vh>__len__</vh></v>
<v t="ekr.20190812072050.552"><vh>clear</vh></v>
</v>
<v t="ekr.20190812072050.553"><vh>class TinyPackageQueue(PackageQueue)</vh>
<v t="ekr.20190812072050.554"><vh>TinyPackageQueue.__init__</vh></v>
<v t="ekr.20190812072050.555"><vh>TinyPackageQueue.push</vh></v>
<v t="ekr.20190812072050.556"><vh>TinyPackageQueue.pop</vh></v>
<v t="ekr.20190812072050.557"><vh>TinyPackageQueue.clear</vh></v>
</v>
</v>
<v t="ekr.20190812072051.2"><vh>yoton/channels</vh>
<v t="ekr.20190812072051.3"><vh>@clean channels_base.py</vh>
<v t="ekr.20190812072051.4"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.5"><vh>class BaseChannel(object)</vh>
<v t="ekr.20190812072051.6"><vh>BaseChannel.__init__</vh></v>
<v t="ekr.20190812072051.7"><vh>BaseChannel._init_slots</vh></v>
<v t="ekr.20190812072051.8"><vh>BaseChannel._messaging_patterns</vh></v>
<v t="ekr.20190812072051.9"><vh>BaseChannel.close</vh></v>
<v t="ekr.20190812072051.10"><vh>BaseChannel._send</vh></v>
<v t="ekr.20190812072051.11"><vh>BaseChannel._recv</vh></v>
<v t="ekr.20190812072051.12"><vh>BaseChannel._set_send_lock</vh></v>
<v t="ekr.20190812072051.13"><vh>BaseChannel._inject_package</vh></v>
<v t="ekr.20190812072051.14"><vh>BaseChannel._recv_package</vh></v>
<v t="ekr.20190812072051.15"><vh>BaseChannel._maybe_emit_received</vh></v>
<v t="ekr.20190812072051.16"><vh>BaseChannel._emit_received</vh></v>
<v t="ekr.20190812072051.17"><vh>BaseChannel.received</vh></v>
<v t="ekr.20190812072051.18"><vh>BaseChannel.pending</vh></v>
<v t="ekr.20190812072051.19"><vh>BaseChannel.closed</vh></v>
<v t="ekr.20190812072051.20"><vh>BaseChannel.slot_outgoing</vh></v>
<v t="ekr.20190812072051.21"><vh>BaseChannel.slot_incoming</vh></v>
</v>
</v>
<v t="ekr.20190812072051.22"><vh>@clean channels_file.py</vh>
<v t="ekr.20190812072051.23"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.24"><vh>class FileWrapper(object)</vh>
<v t="ekr.20190812072051.25"><vh>FileWrapper.__init__</vh></v>
<v t="ekr.20190812072051.26"><vh>FileWrapper.close</vh></v>
<v t="ekr.20190812072051.27"><vh>FileWrapper.encoding</vh></v>
<v t="ekr.20190812072051.28"><vh>FileWrapper.closed</vh></v>
<v t="ekr.20190812072051.29"><vh>FileWrapper.flush</vh></v>
<v t="ekr.20190812072051.30"><vh>FileWrapper.newlines</vh></v>
<v t="ekr.20190812072051.31"><vh>FileWrapper._set_softspace</vh></v>
<v t="ekr.20190812072051.32"><vh>FileWrapper._get_softspace</vh></v>
<v t="ekr.20190812072051.33"><vh>FileWrapper.read</vh></v>
<v t="ekr.20190812072051.34"><vh>FileWrapper.write</vh></v>
<v t="ekr.20190812072051.35"><vh>FileWrapper.writelines</vh></v>
<v t="ekr.20190812072051.36"><vh>FileWrapper.readline</vh></v>
<v t="ekr.20190812072051.37"><vh>FileWrapper.isatty</vh></v>
</v>
</v>
<v t="ekr.20190812072051.38"><vh>@clean channels_pubsub.py</vh>
<v t="ekr.20190812072051.39"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.40"><vh>class PubChannel(BaseChannel)</vh>
<v t="ekr.20190812072051.41"><vh>PubChannel.__init__</vh></v>
<v t="ekr.20190812072051.42"><vh>PubChannel._messaging_patterns</vh></v>
<v t="ekr.20190812072051.43"><vh>PubChannel.send</vh></v>
<v t="ekr.20190812072051.44"><vh>PubChannel._recv_package</vh></v>
</v>
<v t="ekr.20190812072051.45"><vh>class SubChannel(BaseChannel)</vh>
<v t="ekr.20190812072051.46"><vh>SubChannel.__init__</vh></v>
<v t="ekr.20190812072051.47"><vh>SubChannel._messaging_patterns</vh></v>
<v t="ekr.20190812072051.48"><vh>SubChannel.__iter__</vh></v>
<v t="ekr.20190812072051.49"><vh>SubChannel.__next__</vh></v>
<v t="ekr.20190812072051.50"><vh>SubChannel.next</vh></v>
<v t="ekr.20190812072051.51"><vh>SubChannel.set_sync_mode</vh></v>
<v t="ekr.20190812072051.52"><vh>SubChannel._send_block_message_to_senders</vh></v>
<v t="ekr.20190812072051.53"><vh>SubChannel._check_queue_status</vh></v>
<v t="ekr.20190812072051.54"><vh>SubChannel.recv</vh></v>
<v t="ekr.20190812072051.55"><vh>SubChannel.recv_all</vh></v>
<v t="ekr.20190812072051.56"><vh>SubChannel.recv_selected</vh></v>
<v t="ekr.20190812072051.57"><vh>SubChannel._get_pending_sequence_numbers</vh></v>
</v>
<v t="ekr.20190812072051.58"><vh>select_sub_channel</vh></v>
</v>
<v t="ekr.20190812072051.59"><vh>@clean channels_reqrep.py</vh>
<v t="ekr.20190812072051.60"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.61"><vh>class TimeoutError(Exception)</vh></v>
<v t="ekr.20190812072051.62"><vh>class CancelledError(Exception)</vh></v>
<v t="ekr.20190812072051.63"><vh>class Future(object)</vh>
<v t="ekr.20190812072051.64"><vh>Future.__init__</vh></v>
<v t="ekr.20190812072051.65"><vh>Future._send</vh></v>
<v t="ekr.20190812072051.66"><vh>Future._resend_if_necessary</vh></v>
<v t="ekr.20190812072051.67"><vh>Future.set_auto_cancel_timeout</vh></v>
<v t="ekr.20190812072051.68"><vh>Future.cancel</vh></v>
<v t="ekr.20190812072051.69"><vh>Future.cancelled</vh></v>
<v t="ekr.20190812072051.70"><vh>Future.running</vh></v>
<v t="ekr.20190812072051.71"><vh>Future.done</vh></v>
<v t="ekr.20190812072051.72"><vh>Future._wait</vh></v>
<v t="ekr.20190812072051.73"><vh>Future.result</vh></v>
<v t="ekr.20190812072051.74"><vh>Future.result_or_cancel</vh></v>
<v t="ekr.20190812072051.75"><vh>Future.exception</vh></v>
<v t="ekr.20190812072051.76"><vh>Future.add_done_callback</vh></v>
<v t="ekr.20190812072051.77"><vh>Future.set_running_or_notify_cancel</vh></v>
<v t="ekr.20190812072051.78"><vh>Future.set_result</vh></v>
<v t="ekr.20190812072051.79"><vh>Future.set_exception</vh></v>
</v>
<v t="ekr.20190812072051.80"><vh>class ReqChannel(BaseChannel)</vh>
<v t="ekr.20190812072051.81"><vh>ReqChannel.__init__</vh></v>
<v t="ekr.20190812072051.82"><vh>ReqChannel._messaging_patterns</vh></v>
<v t="ekr.20190812072051.83"><vh>ReqChannel.__getattr__</vh></v>
<v t="ekr.20190812072051.84"><vh>ReqChannel._handle_request</vh></v>
<v t="ekr.20190812072051.85"><vh>ReqChannel._resend_requests</vh></v>
<v t="ekr.20190812072051.86"><vh>ReqChannel._recv_item</vh></v>
<v t="ekr.20190812072051.87"><vh>ReqChannel._process_events_local</vh></v>
</v>
<v t="ekr.20190812072051.88"><vh>class RepChannel(BaseChannel)</vh>
<v t="ekr.20190812072051.89"><vh>RepChannel.__init__</vh></v>
<v t="ekr.20190812072051.90"><vh>RepChannel._messaging_patterns</vh></v>
<v t="ekr.20190812072051.91"><vh>RepChannel.set_mode</vh></v>
<v t="ekr.20190812072051.92"><vh>RepChannel._handle_request</vh></v>
<v t="ekr.20190812072051.93"><vh>RepChannel._acknowledge_next_pre_request</vh></v>
<v t="ekr.20190812072051.94"><vh>RepChannel._replier_iteration</vh></v>
<v t="ekr.20190812072051.95"><vh>RepChannel._process_events_local</vh></v>
<v t="ekr.20190812072051.96"><vh>RepChannel.echo</vh></v>
</v>
<v t="ekr.20190812072051.97"><vh>class ThreadForReqChannel(threading.Thread)</vh>
<v t="ekr.20190812072051.98"><vh>ThreadForReqChannel.__init__</vh></v>
<v t="ekr.20190812072051.99"><vh>ThreadForReqChannel.run</vh></v>
</v>
</v>
<v t="ekr.20190812072051.100"><vh>@clean channels_state.py</vh>
<v t="ekr.20190812072051.101"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.102"><vh>class StateChannel(BaseChannel)</vh>
<v t="ekr.20190812072051.103"><vh>StateChannel.__init__</vh></v>
<v t="ekr.20190812072051.104"><vh>StateChannel._messaging_patterns</vh></v>
<v t="ekr.20190812072051.105"><vh>StateChannel.send</vh></v>
<v t="ekr.20190812072051.106"><vh>StateChannel.send_last</vh></v>
<v t="ekr.20190812072051.107"><vh>StateChannel.recv</vh></v>
<v t="ekr.20190812072051.108"><vh>StateChannel._recv_package</vh></v>
<v t="ekr.20190812072051.109"><vh>StateChannel._inject_package</vh></v>
<v t="ekr.20190812072051.110"><vh>StateChannel._recv</vh></v>
</v>
</v>
<v t="ekr.20190812072051.111"><vh>@clean message_types.py</vh>
<v t="ekr.20190812072051.112"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.113"><vh>class MessageType(object)</vh>
<v t="ekr.20190812072051.114"><vh>MessageType.message_to_bytes</vh></v>
<v t="ekr.20190812072051.115"><vh>MessageType.message_from_bytes</vh></v>
<v t="ekr.20190812072051.116"><vh>MessageType.message_type_name</vh></v>
</v>
<v t="ekr.20190812072051.117"><vh>class BinaryMessageType(MessageType)</vh>
<v t="ekr.20190812072051.118"><vh>BinaryMessageType.message_type_name</vh></v>
<v t="ekr.20190812072051.119"><vh>BinaryMessageType.message_to_bytes</vh></v>
<v t="ekr.20190812072051.120"><vh>BinaryMessageType.message_from_bytes</vh></v>
</v>
<v t="ekr.20190812072051.121"><vh>class TextMessageType(MessageType)</vh>
<v t="ekr.20190812072051.122"><vh>TextMessageType.message_type_name</vh></v>
<v t="ekr.20190812072051.123"><vh>TextMessageType.message_to_bytes</vh></v>
<v t="ekr.20190812072051.124"><vh>TextMessageType.message_from_bytes</vh></v>
</v>
<v t="ekr.20190812072051.125"><vh>class ObjectMessageType(MessageType)</vh>
<v t="ekr.20190812072051.126"><vh>ObjectMessageType.message_type_name</vh></v>
<v t="ekr.20190812072051.127"><vh>ObjectMessageType.message_to_bytes</vh></v>
<v t="ekr.20190812072051.128"><vh>ObjectMessageType.message_from_bytes</vh></v>
</v>
<v t="ekr.20190812072051.129"><vh>class Packer</vh>
<v t="ekr.20190812072051.130"><vh>Packer.__init__</vh></v>
<v t="ekr.20190812072051.131"><vh>Packer.get_buffer</vh></v>
<v t="ekr.20190812072051.132"><vh>Packer.write</vh></v>
<v t="ekr.20190812072051.133"><vh>Packer.write_number</vh></v>
<v t="ekr.20190812072051.134"><vh>Packer.pack_object</vh></v>
</v>
<v t="ekr.20190812072051.135"><vh>class Unpacker</vh>
<v t="ekr.20190812072051.136"><vh>Unpacker.__init__</vh></v>
<v t="ekr.20190812072051.137"><vh>Unpacker.read</vh></v>
<v t="ekr.20190812072051.138"><vh>Unpacker.read_number</vh></v>
<v t="ekr.20190812072051.139"><vh>Unpacker.unpack</vh></v>
<v t="ekr.20190812072051.140"><vh>Unpacker.unpack_object</vh></v>
</v>
</v>
<v t="ekr.20190812072051.141"><vh>@clean __init__.py</vh>
<v t="ekr.20190812072051.142"><vh>Declarations</vh></v>
</v>
</v>
<v t="ekr.20190812072051.144"><vh>yoton/tests</vh>
<v t="ekr.20190812072051.145"><vh>@clean count_lines_of_code.py</vh>
<v t="ekr.20190812072051.146"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.147"><vh>count_lines</vh></v>
</v>
<v t="ekr.20190812072051.148"><vh>@clean event_driven1.py</vh>
<v t="ekr.20190829074237.1"><vh>&lt;&lt; define class Reducer &gt;&gt;</vh>
<v t="ekr.20190812072051.150"><vh>class Reducer(yoton.RepChannel)</vh>
<v t="ekr.20190812072051.151"><vh>Reducer.reduce</vh></v>
</v>
</v>
<v t="ekr.20190829074429.1"><vh>&lt;&lt; define reply_handler &gt;&gt;</vh>
<v t="ekr.20190812072051.152"><vh>reply_handler</vh></v>
</v>
</v>
<v t="ekr.20190812072051.153"><vh>@clean event_driven2.py</vh>
<v t="ekr.20190812072051.154"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.155"><vh>message_handler</vh></v>
</v>
<v t="ekr.20190812072051.156"><vh>@clean hello_world.py</vh>
<v t="ekr.20190812072051.157"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072051.158"><vh>@clean hops.py</vh>
<v t="ekr.20190812072051.159"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072051.160"><vh>@clean message_type.py</vh>
<v t="ekr.20190829074722.1"><vh>&lt;&lt; class NumberMessageType 1&gt;&gt;</vh>
<v t="ekr.20190812072051.162"><vh>class NumberMessageType(yoton.MessageType)</vh>
<v t="ekr.20190812072051.163"><vh>NumberMessageType.message_from_bytes</vh></v>
<v t="ekr.20190812072051.164"><vh>NumberMessageType.message_to_bytes</vh></v>
<v t="ekr.20190812072051.165"><vh>NumberMessageType.message_type_name</vh></v>
</v>
</v>
<v t="ekr.20190829074851.1"><vh>&lt;&lt; class NumberMessageType 2&gt;&gt;</vh>
<v t="ekr.20190829074851.2"><vh>class NumberMessageType(yoton.MessageType)</vh>
<v t="ekr.20190829074851.3"><vh>NumberMessageType.message_from_bytes</vh></v>
<v t="ekr.20190829074851.4"><vh>NumberMessageType.message_to_bytes</vh></v>
<v t="ekr.20190829074851.5"><vh>NumberMessageType.message_type_name</vh></v>
</v>
</v>
</v>
<v t="ekr.20190812072051.170"><vh>@clean reqrep.py</vh>
<v t="ekr.20190812072051.172"><vh>class Adder(yoton.RepChannel)</vh>
<v t="ekr.20190812072051.173"><vh>Adder.add</vh></v>
</v>
</v>
<v t="ekr.20190812072051.174"><vh>@clean routing_splitting.py</vh>
<v t="ekr.20190812072051.175"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072051.176"><vh>@clean status.py</vh>
<v t="ekr.20190812072051.177"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.178"><vh>on_new_state</vh></v>
</v>
<v t="ekr.20190812072051.179"><vh>@clean test_networkPackageQueue.py</vh>
<v t="ekr.20190812072051.180"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.181"><vh>class Sender(threading.Thread)</vh>
<v t="ekr.20190812072051.182"><vh>Sender.run</vh></v>
</v>
<v t="ekr.20190812072051.183"><vh>class Receiver(threading.Thread)</vh>
<v t="ekr.20190812072051.184"><vh>Receiver.run</vh></v>
<v t="ekr.20190812072051.185"><vh>Receiver.show</vh></v>
</v>
</v>
<v t="ekr.20190812072051.186"><vh>@clean test_rapid_reconnect.py</vh>
<v t="ekr.20190812072051.187"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.188"><vh>connect_test</vh></v>
</v>
<v t="ekr.20190812072051.189"><vh>@clean test_speed.py</vh>
<v t="ekr.20190812072051.190"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.191"><vh>logticks10</vh></v>
<v t="ekr.20190812072051.192"><vh>logticks2</vh></v>
</v>
<v t="ekr.20190812072051.193"><vh>@clean utest.py</vh>
<v t="ekr.20190812072051.194"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.195"><vh>class Tester(unittest.TestCase)</vh>
<v t="ekr.20190812072051.196"><vh>Tester.setUp</vh></v>
<v t="ekr.20190812072051.197"><vh>Tester.tearDown</vh></v>
<v t="ekr.20190812072051.198"><vh>Tester.test_connecting</vh></v>
<v t="ekr.20190812072051.199"><vh>Tester.test_closing_channel</vh></v>
<v t="ekr.20190812072051.200"><vh>Tester.test_pub_sub</vh></v>
<v t="ekr.20190812072051.201"><vh>Tester.test_pub_sub_select_channel</vh></v>
<v t="ekr.20190812072051.202"><vh>Tester.test_pubstate_substate</vh></v>
<v t="ekr.20190812072051.203"><vh>Tester.test_req_rep1</vh></v>
<v t="ekr.20190812072051.204"><vh>Tester.test_req_rep2</vh></v>
</v>
</v>
<v t="ekr.20190812072051.205"><vh>@clean _test_inExternalCode.py</vh>
<v t="ekr.20190812072051.206"><vh>Declarations</vh></v>
</v>
<v t="ekr.20190812072051.207"><vh>@clean _test_message_stuff.py</vh>
<v t="ekr.20190812072051.208"><vh>Declarations</vh></v>
<v t="ekr.20190812072051.209"><vh>class Message(str)</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20041001210557"><vh>Scripting</vh>
<v t="tbrown.20100226095909.12777"><vh>@file leoscreen.py</vh></v>
<v t="tbrown.20140806084727.30174"><vh>@file livecode.py</vh></v>
<v t="ekr.20060328125248"><vh>@file mod_scripting.py</vh></v>
<v t="edream.110203113231.925"><vh>@file script_io_to_body.py</vh></v>
</v>
<v t="ekr.20120309073937.9878"><vh>Searching</vh>
<v t="ekr.20120309073748.9872"><vh>@file bigdash.py</vh></v>
<v t="peckj.20140804114520.9427"><vh>@file nodetags.py</vh></v>
<v t="peckj.20131130132659.5964"><vh>@file nodewatch.py</vh></v>
</v>
<v t="ekr.20050111122605"><vh>Servers &amp; web stuff</vh>
<v t="ekr.20170925083314.1"><vh>@auto leo_cloud.py</vh></v>
<v t="ekr.20170925083853.1"><vh>@auto leo_cloud_server.py</vh></v>
<v t="ville.20110206142055.10640"><vh>@file leofeeds.py</vh></v>
<v t="ville.20110125222411.10536"><vh>@file leomail.py</vh></v>
<v t="ville.20091009202416.10040"><vh>@file leoremote.py</vh></v>
<v t="EKR.20040517080250.1"><vh>@file mod_http.py</vh></v>
<v t="ekr.20131004162848.11444"><vh>@file rss.py</vh></v>
<v t="peckj.20140811080604.9496"><vh>@file sftp.py</vh></v>
</v>
<v t="ekr.20101004082701.5674"><vh>Slideshows, screencasts &amp; screenshots</vh>
<v t="ekr.20170128213103.1"><vh>@file demo.py</vh></v>
<v t="ekr.20120913110135.10579"><vh>@file screencast.py</vh></v>
<v t="ekr.20101121031443.5330"><vh>@file screenshots.py</vh></v>
<v t="ekr.20060831165821"><vh>@file slideshow.py</vh></v>
</v>
<v t="ekr.20071113084440"><vh>Testing</vh>
<v t="ekr.20080214092357"><vh>@file test/ekr_test.py</vh></v>
<v t="ekr.20050130120433"><vh>@@file test/failed_import.py</vh></v>
<v t="ekr.20071113085315"><vh>@file test/failed_to_load_plugin.py</vh></v>
<v t="ekr.20051016160700"><vh>@file testRegisterCommand.py</vh></v>
</v>
<v t="ekr.20050306081349"><vh>Text formatting</vh>
<v t="timo.20050213160555"><vh>@file bibtex.py</vh></v>
<v t="ekr.20070119094733.1"><vh>@file dtest.py</vh></v>
<v t="ville.20110409151021.5699"><vh>@file jinjarender.py</vh></v>
<v t="danr7.20060902215215.1"><vh>@file leo_to_html.py</vh></v>
<v t="tbrown.20130930160706.23451"><vh>@file markup_inline.py</vh></v>
<v t="vitalije.20180804172140.1"><vh>@file md_docer.py</vh></v>
<v t="peckj.20140113150237.7083"><vh>@file nodediff.py</vh></v>
<v t="tbrown.20130813134319.11942"><vh>@file richtext.py</vh></v>
<v t="ekr.20170217164004.1"><vh>@file tables.py</vh></v>
</v>
<v t="ekr.20121126102050.10134"><vh>Threading</vh>
<v t="ekr.20121126095734.12418"><vh>@file threadutil.py</vh></v>
</v>
<v t="ekr.20040915073259"><vh>User interface</vh>
<v t="ekr.20101110150056.9453"><vh> Qt only plugins</vh>
<v t="tbrown.20091029123555.5319"><vh>@file attrib_edit.py</vh></v>
<v t="ville.20090310191936.10"><vh>@file colorize_headlines.py</vh></v>
<v t="ekr.20090701111504.5294"><vh>@file contextmenu.py</vh></v>
<v t="tbrown.20090206153748.1"><vh>@file graphcanvas.py</vh></v>
<v t="ville.20090518182905.5419"><vh>@file nav_qt.py</vh></v>
<v t="ville.20120604212857.4215"><vh>@file notebook.py</vh></v>
<v t="ekr.20090622063842.5264"><vh>@file projectwizard.py</vh></v>
<v t="ekr.20160928073518.1"><vh>@file pyplot_backend.py</vh></v>
<v t="ville.20090314215508.4"><vh>@file quicksearch.py</vh></v>
<v t="tbrown.20130420091241.44181"><vh>@file screen_capture.py</vh></v>
<v t="ville.20090815203828.5235"><vh>@file spydershell.py</vh></v>
<v t="ekr.20100103093121.5329"><vh>@file stickynotes.py</vh></v>
<v t="tbrown.20090119215428.2" descendentVnodeUnknownAttributes="7d71005808000000302e362e31332e3071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323031382d30382d313871077573732e"><vh>@file todo.py</vh></v>
<v t="ville.20110403115003.10348"><vh>@file valuespace.py</vh></v>
<v t="tbrown.20100318101414.5990"><vh>@file viewrendered.py</vh></v>
</v>
<v t="ekr.20061023142737"><vh> UNL plugin</vh>
<v t="ekr.20061023142737.1"><vh>Tests</vh>
<v t="rogererens.20041130095659"><vh>@url 'file: ./../../plugins/leoPlugins.leo#Plugins--&gt;UNL plugin--&gt;To do'</vh></v>
<v t="ekr.20061023141638"><vh>@url 'file:./../doc/leoDocs.leo#Users Guide--&gt;Basics--&gt;Customizing Leo'</vh></v>
</v>
</v>
<v t="ekr.20160519123329.1"><vh>@edit QNCalendarWidget.py</vh></v>
<v t="ekr.20060328125925"><vh>@file chapter_hoist.py</vh></v>
<v t="ville.20110115234843.8742"><vh>@file dragdropgoodies.py</vh></v>
<v t="tbrown.20090513125417.5244"><vh>@file interact.py</vh></v>
<v t="vitalije.20190928154420.1"><vh>@file history_tracer.py</vh></v>
<v t="vitalije.20170727201534.1"><vh>@file line_numbering.py</vh></v>
<v t="ekr.20040915073259.1"><vh>@file maximizeNewWindows.py</vh></v>
<v t="ekr.20101110093301.5818"><vh>@file mod_framesize.py</vh></v>
<v t="EKR.20040517080555.2"><vh>@file plugins_menu.py</vh></v>
<v t="peckj.20150428142633.1"><vh>@file python_terminal.py</vh></v>
<v t="edream.110203113231.924"><vh>@file redirect_to_log.py</vh></v>
<v t="EKR.20040517080555.36"><vh>@file scripts_menu.py</vh></v>
<v t="ekr.20170313020320.1"><vh>@file settings_finder.py</vh></v>
<v t="ville.20110304230157.6513"><vh>@file systray.py</vh></v>
<v t="tbrown.20141101114322.1"><vh>@file wikiview.py</vh></v>
<v t="ekr.20181004143535.1"><vh>@file xdb_pane.py</vh></v>
<v t="ekr.20101110095202.5882"><vh>@file zenity_file_dialogs.py</vh></v>
</v>
<v t="ekr.20140726091031.18071"><vh>Writer plugins</vh>
<v t="ekr.20140726091031.18152"><vh>@file writers/__init__.py</vh></v>
<v t="ekr.20140726091031.18143"><vh>@file writers/basewriter.py</vh></v>
<v t="tbrown.20140804103545.29975"><vh>@file writers/ctext.py</vh></v>
<v t="ekr.20141116100154.2"><vh>@file writers/dart.py</vh></v>
<v t="ekr.20160412101901.1"><vh>@file writers/ipynb.py</vh></v>
<v t="ekr.20160504083330.1"><vh>@file writers/leo_json.py</vh></v>
<v t="ekr.20180202053206.1"><vh>@file writers/treepad.py</vh></v>
<v t="ekr.20140726091031.18080"><vh>@file writers/leo_rst.py</vh></v>
<v t="ekr.20140726091031.18073"><vh>@file writers/markdown.py</vh></v>
<v t="ekr.20140726091031.18079"><vh>@file writers/org.py</vh></v>
<v t="ekr.20140726091031.18078"><vh>@file writers/otl.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040517075715"></t>
<t tx="EKR.20040517075715.13"></t>
<t tx="EKR.20040517075715.20">[Main]
use_styles = Yes
use_section_numbers = Yes
use_current_document = Yes
max_headings = 6
header_style = Heading
</t>
<t tx="EKR.20040517090508">@nocolor-node

Enable plugins by creating@enabled-plugins nodes in leoSettings files,
typically myLeoSettings.leo.See the node

Users Guide-- &gt; Chapter 8: Customizing Leo-- &gt;@rst
html\customizing.html-- &gt; Specifying settings-- &gt; Complex settings nodes

in LeoDocs.leo for full details.

**Important**: Leo no longer uses pluginsManager.txt to enable or disable plugins.
</t>
<t tx="edream.110203113231.618">@language python
@tabwidth -4
@pagewidth 80
</t>
<t tx="edream.110203113231.667"></t>
<t tx="edream.110203113231.729"></t>
<t tx="edream.110203113231.872">@nocolor-node

These plugins create new kinds of nodes, some of which affect the file system.</t>
<t tx="ekr.20040331071919"></t>
<t tx="ekr.20040722141148">@nocolor-node
@

You would typically not enable any of the following "plugins".

These plugins contain example code only.
</t>
<t tx="ekr.20040915073259">@nocolor-node

These plugins add buttons and other widgets to the icon area or
affect Leo's panes and windows in various ways.

</t>
<t tx="ekr.20041001210557"></t>
<t tx="ekr.20041030092101">@Notes by EKR: The dyna plugin is a remarkable body of work by 'e'. Have fun with it.

You may download the latest version at: http: // rclick.netfirms.com / dyna_menu.py.html
</t>
<t tx="ekr.20041114102139">@nocolor

Comments
--------

Most of the comments in the style guide are comments*about*the style guide.
You would replace these comments with your own, or eliminate them entirely in
your plugin.

Docstrings
----------

Several plugins show the docstring, so please take care to do a good job of
describing what the plugin does and how to use it.

Directives
----------

Please put the following at the end of the plugin's top-level node.

    @language python
    @tabwidth-4

Imports
-------

-Do* not*assume that modules like Qt are always available.

-Do* not*use from m import*

-Your code should test whether modules have been imported only if those modules
  may not be available on all platforms.

-To fail gracefully if the Qt gui is not in effect, put the following at
  the top level::

      g.assertUi('qt')

Exceptions
----------

It is usually best* not*to catch exceptions in plugins: doHook catches all
exceptions and disables further calls to plugins.

If a plugin catches exceptions during startup it should do either raise the
exception again or provide an init function at the top level that reports the
failure by returning False.

Use separate nodes
------------------

**Please**define each class, function or method in a separate node!To
make this work, just put@others in the root of your plugin as shown.Note
that@others may be nested, as shown in class myClass.
</t>
<t tx="ekr.20050111122605"></t>
<t tx="ekr.20050130120433">'''A plugin to test import problems.'''

import leo.core.leoGlobals as g

def onStart(tag,keywords):
    pass

# pylint: disable=unused-import
try:
    import xyzzy
except ImportError:
    g.cantImport('xyzzy',pluginName='failed_import')

def init():
    '''Return True if the plugin has loaded successfully.'''
    g.registerHandler("start2", onStart)
    g.plugin_signon(__name__)
    return True
</t>
<t tx="ekr.20050303051035">@nocolor-node

The following nodes show recommended style when writing plugins.</t>
<t tx="ekr.20050303051035.2">'''
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
'''
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4
</t>
<t tx="ekr.20050303051035.5">import leo.core.leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050303051101">def init():
    '''Return True if the plugin has loaded successfully.'''
    ok=g.app.gui.guiName() in('qt','qttabs')
    if ok:
        if 1: # Use this if you want to create the commander class before the frame is fully created.
            g.registerHandler('before-create-leo-frame',onCreate)
        else: # Use this if you want to create the commander class after the frame is fully created.
            g.registerHandler('after-create-leo-frame',onCreate)
    return ok</t>
<t tx="ekr.20050303051150">def onCreate(tag, keys):

    c=keys.get('c')
    if not c: return

    thePluginController=pluginController(c)
</t>
<t tx="ekr.20050303051222">class pluginController:

    @others</t>
<t tx="ekr.20050303051222.1">def __init__(self,c):

    self.c=c
    # Warning: hook handlers must use keywords.get('c'), NOT self.c.
</t>
<t tx="ekr.20050306071540">def onStart2(tag, keywords):

    """
    Showing how to define a global hook that affects all commanders.
    """

    log=c.frame.log.__class__

    # Replace frame.put with newPut (not shown).
    g.funcToMethod(newPut,log,"put")</t>
<t tx="ekr.20050306071629">'''
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
'''
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4</t>
<t tx="ekr.20050306071629.1">'''This docstring should be a clear, concise description of
what the plugin does and how to use it.
'''
</t>
<t tx="ekr.20050306071629.3">import leo.core.leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050306071629.4">def init():
    '''Return True if the plugin has loaded successfully.'''
    ok=True # This might depend on imports, etc.
    if ok:
        g.registerHandler('start2',onStart2)
    return ok</t>
<t tx="ekr.20050306081349"></t>
<t tx="ekr.20050804081215">@nocolor
@
http://sourceforge.net/forum/message.php?msg_id=3276408

Leo has great potential for smoothing some of the bumps
outside of learning the details of the markup.
Here is my wish list;

(done) - Section level handling.
  - one of the problems with using rst comes when a new
    section level is inserted into a document. Leo can
    take care of this effortlessly, providing a correct
   underline character for each section heading.

    Other than the section management, I want Leo to
    assume that I'm writing rst, and should be rendered
    as-is. If I want to include some pretty Python, I put
    it in a ..  python-code:: block (or some such)

    On top of this base could be built special case
    handling.

- Assist in viewing rendered output
  - easy access to the command to render a tree to  html.
  - I would like an option which automatically inserted
    a @url node which pointed to the rendered file, or
    some other trick to make switching between source
    and output painless.

- Assist in working with the CSS file
  - a CSS file is now required by docutils. A @setting
    could specify the file. I would like some kind of
    sugar which made it easy to edit the CSS file, maybe
    an option to create a @file node automatically,
    like the @url node above. Again, I want to be able
    to effortlessly edit the CSS and see the results.

- The third file of interest when writing rst is the config
   file which controls many behaviours of the renderer.
   Again, some intelligence which located it, made it
   convenient to edit it, maybe even linked to
   documentation for it, would be very nice.

(done) - I would like a setting which would save the file with the
  rst markup and make it easy to examine and edit.

- On the someday/maybe list would be a @publish
  feature, which configured a directory to ftp the rendered
  file to.
</t>
<t tx="ekr.20050805162550">&lt;&lt; docstring &gt;&gt;

# Original rst code by Josef Dalcolmo:
# contributed under the same licensed as Leo.py itself.
# rst3.py based on rst2.py v2.4.
# This has largely been superceded by leo.core.leoRst.

&lt;&lt; imports &gt;&gt;
&lt;&lt; to do &gt;&gt;

bwm_file = None
if 0:
    bwm_file = open("bwm_file", "w")
controllers = {} # For use by @button rst3 code.

@others
</t>
<t tx="ekr.20050805162550.1">''' Creates output files from Leo outlines containing rST (reStructuredText)
markup. This plugin has been superseded by Leo's core rst3 command.

This is a powerful plugin with many options.  The full documentation is at:
http://leoeditor.com//rstplugin3.html

The rst3 plugin adds the Write Restructured Text command to Leo's Edit menu. This
command searches the selected outline looking for **rst root nodes** whose
headline have the form @rst &lt;filename&gt;. The plugin then creates the named file
in various ways depending which rst3 options are in effect.

By default, the rst3 plugin creates rST headings automatically from outlines, so
the higher-level nodes in the outline correspond to higher-level sections in the
output. Creating rST headings automatically eliminates one of the most tedious
chores associated with rST markup.

To use this plugin effectively, Python's docutils module must be installed. The
rst3 plugin will use the SilverCity syntax coloring package if it installed.

This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.

rst3 options control most aspects of this plugin's operations. You can set
options in @settings trees, in headlines and in body text. There are too many
details to discuss here. For full details see:
http://leoeditor.com//rstplugin3.html

'''
</t>
<t tx="ekr.20050805162550.10">def __init__ (self,c):

    global SilverCity
    self.c = c
    &lt;&lt; init ivars &gt;&gt;

    self.createDefaultOptionsDict()
    self.initOptionsFromSettings() # Still needed.
    self.initHeadlineCommands() # Only needs to be done once.
    self.initSingleNodeOptions()
    self.addMenu()
</t>
<t tx="ekr.20050805162550.11">self.silverCityWarningGiven = False

# The options dictionary.
self.optionsDict = {}
self.option_prefix = '@rst-option'

# Formatting...
self.code_block_string = ''
self.node_counter = 0
self.toplevel = 0
self.topNode = None
self.use_alternate_code_block = SilverCity is None

# Http support...
self.nodeNumber = 0
# All nodes are numbered so that unique anchors can be generated.

self.http_map = {}
# Keys are named hyperlink targets.  Value are positions.
# The targets mark the beginning of the html code specific
# for this position.

self.anchor_map = {}
# Maps anchors (generated by this module) to positions

self.rst3_all = False
# Set to True by the button which processes all @rst trees.

# For writing.
self.defaultEncoding = 'utf-8'
self.leoDirectivesList = g.globalDirectiveList
self.encoding = self.defaultEncoding
self.ext = None # The file extension.
self.outputFileName = None # The name of the file being written.
self.outputFile = None # The open file being written.
self.path = '' # The path from any @path directive.
self.source = None # The written source as a string.
</t>
<t tx="ekr.20050805162550.12">def addMenu (self):

    c = self.c ; editMenu = c.frame.menu.getMenu('Edit')

    def rst3PluginCallback (event=None):
        self.processTopTree(c.p)

    c.k.registerCommand('write-restructured-text', rst3PluginCallback)
    table = (
        ("-",None,None),
        # ("Write Restructed Text","",rst3PluginCallback),
        '&amp;write-restructured-text',
    )
    c.frame.menu.createMenuEntries(editMenu,table,dynamicMenu=True)
</t>
<t tx="ekr.20050805162550.13">def initOptionsFromSettings (self):
    '''Init all options from settings.'''
    c = self.c
    d = self.defaultOptionsDict
    for key in sorted(d.keys()):
        for getter,kind in (
            (c.config.getBool,'@bool'),
            (c.config.getString,'@string'),
            (d.get,'default'),
        ):
            val = getter(key)
            if kind == 'default' or val is not None:
                self.setOption(key,val,'initOptionsFromSettings')
                break
    # Special case.
    if self.getOption('http_server_support') and not mod_http:
        g.error('No http_server_support: can not import mod_http plugin')
        self.setOption('http_server_support',False,tag='initOptionsFromSettings')
</t>
<t tx="ekr.20050805162550.16">def encode (self,s):

    return g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
</t>
<t tx="ekr.20050805162550.17">def processTree(self,p,ext,toString,justOneFile):

    '''Process all @rst nodes in a tree.'''

    self.preprocessTree(p)
    found = False ; self.stringOutput = ''
    p = p.copy() ; after= p.nodeAfterTree()
    while p and p != after:
        h = p.h.strip()
        if g.match_word(h,0,"@rst"):
            self.outputFileName = h[4:].strip()
            if (
                (self.outputFileName and self.outputFileName[0] != '-') or
                (toString and not self.outputFileName)
            ):
                found = True
                self.toplevel = p.level() # Define toplevel separately for each rst file.
                if toString:
                    self.ext = ext
                else:
                    self.ext = g.os_path_splitext(self.outputFileName)[1].lower()
                if self.ext in ('.htm','.html','.tex','.pdf'):
                    ok = self.writeSpecialTree(p,toString=toString,justOneFile=justOneFile)
                else:
                    ok = self.writeNormalTree(p,toString=toString)
                self.scanAllOptions(p) # Restore the top-level verbose setting.
                if toString:
                    return p.copy(),self.stringOutput
                else:
                    if ok: self.report(self.outputFileName)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else: p.moveToThreadNext()
    if not found:
        g.warning('No @rst nodes in selected tree')
    return None,None
</t>
<t tx="ekr.20050805162550.19">def underline (self,s,p):
    '''Return the underlining string to be used at the given level for string s.'''
    u = self.getOption('underline_characters') #  '''#=+*^~"'`-:&gt;&lt;_'''
    level = max(0,p.level()-self.toplevel)
    level = min(level+1,len(u)-1) # Reserve the first character for explicit titles.
    ch = u [level]
    n = max(4,len(s))
    return ch * n + '\n'
</t>
<t tx="ekr.20050805162550.2">import leo.core.leoGlobals as g

import html.parser as HTMLParser
import os
import pprint
import io
StringIO = io.StringIO
import sys

# Make sure the present directory in in sys.path.
dir,junk = os.path.split(__file__)
if dir not in sys.path: sys.path.append(dir)

try:
    import leo.plugins.mod_http as mod_http
except ImportError:
    mod_http = None

try:
    import docutils
    import docutils.parsers.rst
    import docutils.core
    import docutils.io
except ImportError:
    # This message given in init.
    # g.pr('rst3 plugin: can not import docutils')
    docutils = None

try:
    import SilverCity
except ImportError:
    if '--silent' not in sys.argv and not g.unitTesting and not g.app.batchMode:
        g.pr('rst3 plugin: SilverCity not loaded')
    SilverCity = None
</t>
<t tx="ekr.20050805162550.20">def report (self,name):

    if self.getOption('verbose'):

        name = g.os_path_finalize(name)

        g.blue('wrote: %s' % (name))
</t>
<t tx="ekr.20050805162550.21">def writeSpecialTree (self,p,toString,justOneFile):

    c = self.c
    isHtml = self.ext in ('.html','.htm')
    if isHtml and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            g.es('SilverCity not present so no syntax highlighting')

    self.initWrite(p)
        # was ,encoding=g.choose(isHtml,'utf-8','iso-8859-1'))
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if not toString:
        # Compute this here for use by intermediate file.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)

        # Create the directory if it doesn't exist.
        theDir, junk = g.os_path_split(self.outputFileName)
        theDir = c.os_path_finalize(theDir)
        if not g.os_path_exists(theDir):
            ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
            if not ok:
                g.error('did not create:',theDir)
                return False

        # if not os.access(theDir,os.F_OK):
            # os.mkdir(theDir)

        if self.getOption('write_intermediate_file'):
            name = self.outputFileName + '.txt'
            f = open(name,'w')
            f.write(self.source)
            f.close()
            self.report(name)

    try:
        output = self.writeToDocutils(self.source)
        ok = True
    except Exception:
        g.pr('Exception in docutils')
        g.es_exception()
        ok = False

    if ok:
        if isHtml:
            import re
            idxTitle = output.find('&lt;title&gt;&lt;/title&gt;')
            if idxTitle &gt; -1:
                m = re.search('&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;', output)
                if not m:
                    m = re.search('&lt;h1&gt;&lt;[^&gt;]+&gt;([^&lt;]*)&lt;/a&gt;&lt;/h1&gt;', output)
                if m:
                    output = output.replace(
                        '&lt;title&gt;&lt;/title&gt;',
                        '&lt;title&gt;%s&lt;/title&gt;' % m.group(1)
                    )


        if toString:
            self.stringOutput = output
        else:
            # Write the file to the directory containing the .leo file.
            f = open(self.outputFileName,'w')
            f.write(output)
            f.close()
            self.http_endTree(self.outputFileName, p, justOneFile=justOneFile)

    return ok
</t>
<t tx="ekr.20050805162550.23">def writeTree(self,p):
    '''Write p's tree to self.outputFile.'''
    self.scanAllOptions(p)
    if self.getOption('generate_rst'):
        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % self.outputFileName))
    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.writeNode(p)
</t>
<t tx="ekr.20050805162550.26">def writeHeadline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''

    docOnly             =  self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.writeHeadlineHelper(p)
</t>
<t tx="ekr.20050805162550.30">def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
</t>
<t tx="ekr.20050805162550.33"></t>
<t tx="ekr.20050805162550.34"># Was http_support_main

def http_endTree (self,filename,p,justOneFile):

    '''Do end-of-tree processing to support the http plugin.'''

    if (
        self.getOption('http_server_support') and
        self.getOption('generate_rst')
    ):
        self.set_initial_http_attributes(filename)
        self.find_anchors(p)
        if justOneFile:
            self.relocate_references(p.self_and_subtree)

        g.blue('html updated for http plugin')

        if self.getOption('clear_http_attributes'):
            g.es_print("http attributes cleared")
</t>
<t tx="ekr.20050805162550.35">def http_attribute_iter (self, p):
    """
    Iterator for all the nodes which have html code.
    Look at the descendents of p.
    Used for relocation.
    """

    for p1 in p.self_and_subtree():
        attr = mod_http.get_http_attribute(p1)
        if attr:
            yield (p1.copy(),attr)
</t>
<t tx="ekr.20050805162550.36">def set_initial_http_attributes (self,filename):

    f = open(filename)
    parser = htmlParserClass(self)

    for line in f.readlines():
        parser.feed(line)

    f.close()
</t>
<t tx="ekr.20050805162550.37">@ Relocate references here if we are only running for one file.

Otherwise we must postpone the relocation until we have processed all files.
@c

def relocate_references (self, iterator_generator):

    for p in iterator_generator():
        attr = mod_http.get_http_attribute(p)
        if not attr:
            continue
        if bwm_file:
            print &gt;&gt; bwm_file
            print &gt;&gt; bwm_file, "relocate_references(1): Position, attr:"
            pprint.pprint((p, attr), bwm_file)
        # http_lines = attr [3:]
        parser = link_htmlparserClass(self,p)
        for line in attr [3:]:
            try:
                parser.feed(line)
            except Exception:
                line = ''.join([ch for ch in line if ord(ch) &lt;= 127])
                parser.feed(line)
        replacements = parser.get_replacements()
        replacements.reverse()
        if not replacements:
            continue
        if bwm_file:
            print &gt;&gt; bwm_file, "relocate_references(2): Replacements:"
            pprint.pprint(replacements, bwm_file)
        for line, column, href, href_file, http_node_ref in replacements:
            if bwm_file:
                print &gt;&gt; bwm_file, ( "relocate_references(3): line:",
                    line, "Column:", column, "href:", href,
                    "href_file:", href_file, "http_node_ref:", http_node_ref)
            marker_parts = href.split("#")
            if len(marker_parts) == 2:
                marker = marker_parts [1]
                replacement = "%s#%s" % (http_node_ref,marker)
                try:
                    attr [line + 2] = attr [line + 2].replace(
                        'href="%s"' % href,'href="%s"' % replacement)
                except Exception:
                    g.es("Skipped ", attr[line + 2])
            else:
                # filename = marker_parts [0]
                try:
                    attr [line + 2] = attr [line + 2].replace(
                        'href="%s"' % href,
                        'href="%s"' % http_node_ref)
                except Exception:
                    g.es("Skipped", attr[line+2])
</t>
<t tx="ekr.20050805162550.38">def find_anchors (self, p):

    '''Find the anchors in all the nodes.'''

    for p1, attrs in self.http_attribute_iter(p):
        html = mod_http.reconstruct_html_from_attrs(attrs)
        parser = anchor_htmlParserClass(self, p1)
        for line in html:
            try:
                parser.feed(line)
            except Exception:
                line = ''.join([ch for ch in line if ord(ch) &lt;= 127])
                # filter out non-ascii characters.
                # bwm: not quite sure what's going on here.
                parser.feed(line)
</t>
<t tx="ekr.20050805162550.39">@
The parser classes are used to construct the html code for nodes. The algorithm has two phases:
    1. In the first phase, the html code for each node is identified.
    2. The second phase identifies all links and checks if these links need to be modified.
The first phase of scanning is done by the anchor_hmlParserClass. The second phase of this algorithm is
done with the link_htmlParserClass.
@code

&lt;&lt; class linkAnchorParserClass &gt;&gt;

@others
</t>
<t tx="ekr.20050805162550.4"></t>
<t tx="ekr.20050805162550.40">class linkAnchorParserClass (HTMLParser.HTMLParser):

    '''
    A class to recognize anchors and links in HTML documents.
    A special marker is the "node_marker" which demarkates the border between
    node and the next.
    '''

    @others
</t>
<t tx="ekr.20050805162550.41">def __init__(self,rst):

    super().__init__()
    self.rst = rst

    # Set ivars from options.  This works only if we don't change nodes!
    self.node_begin_marker      = rst.getOption('node_begin_marker')
    self.clear_http_attributes  = rst.getOption('clear_http_attributes')
    self.current_file = rst.outputFileName
</t>
<t tx="ekr.20050805162550.42">def is_anchor(self, tag, attrs):
    """
    Check if the current tag is an anchor.
    Returns *all* anchors.
    Works with docutils 0.4
    """

    if tag == 'a':
        return True

    if self.is_node_marker(attrs):
        return True
    return tag == "span"
</t>
<t tx="ekr.20050805162550.43">def is_link(self, tag, attrs):
    '''
    Return True if tag, attrs is represents a link.
    '''

    if tag != 'a':
        return False

    result = 'href' in dict(attrs)
    return result
</t>
<t tx="ekr.20050805162550.44">class htmlParserClass (linkAnchorParserClass):

    '''
    The responsibility of the html parser is:
        1. Find out which html code belongs to which node.
        2. Keep a stack of open tags which apply to the current node.
        3. Keep a list of tags which should be included in the nodes, even
           though they might be closed.
           The &lt;style&gt; tag is one example of that.

    Later, we have to relocate inter-file links: if a reference to another location
    is in a file, we must change the link.

    '''

    @others
</t>
<t tx="ekr.20050805162550.45">def __init__ (self,rst):

    super().__init__(rst) # Init the base class.

    self.stack = None
    # The stack contains lists of the form:
        # [text1, text2, previous].
        # text1 is the opening tag
        # text2 is the closing tag
        # previous points to the previous stack element

    self.node_marker_stack = []
    # self.node_marker_stack.pop() returns True for a closing
    # tag if the opening tag identified an anchor belonging to a vnode.

    self.node_code = []
        # Accumulated html code.
        # Once the hmtl code is assigned a vnode, it is deleted here.

    self.deleted_lines = 0 # Number of lines deleted in self.node_code

    self.endpos_pending = False
    # Do not include self.node_code[0:self.endpos_pending] in the html code.

    self.last_position = None
    # Last position; we must attach html code to this node.

    self.last_marker = None
</t>
<t tx="ekr.20050805162550.46">def handle_starttag (self,tag,attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If it is an anchor, we check if this anchor marks the beginning of a new
       node
    3. If a new node begins, then we might have to store html code for the previous
       node.
    4. In any case, put the new tag on the stack.
    '''
    is_node_marker = False
    if self.is_anchor(tag,attrs) and self.is_node_marker(attrs):
        is_node_marker = self.is_node_marker(attrs)
        line, column = self.getpos()
        if self.last_position:
            lines = self.node_code [:]
            lines [0] = lines [0] [self.startpos:]
            del lines [line-self.deleted_lines-1:]
            mod_http.get_http_attribute(self.last_position).extend(lines)
            &lt;&lt; trace the unknownAttribute &gt;&gt;
        if self.deleted_lines &lt; line-1:
            del self.node_code [: line-1-self.deleted_lines]
            self.deleted_lines = line-1
            self.endpos_pending = True
    starttag = self.get_starttag_text()
    self.stack = [starttag, None, self.stack]
    self.node_marker_stack.append(is_node_marker)
</t>
<t tx="ekr.20050805162550.47">def handle_endtag(self, tag):
    '''
    1. Set the second element of the current top of stack.
    2. If this is the end tag for an anchor for a node,
       store the current stack for that node.
    '''
    self.stack[1] = "&lt;/" + tag + "&gt;"

    if self.endpos_pending:
        line, column = self.getpos()
        self.startpos = self.node_code[0].find("&gt;", column) + 1
        self.endpos_pending = False

    is_node_marker = self.node_marker_stack.pop()

    if is_node_marker and not self.clear_http_attributes:
        self.last_position = self.rst.http_map[is_node_marker]
        if is_node_marker != self.last_marker:
            if bwm_file: print &gt;&gt; bwm_file, "Handle endtag:", is_node_marker, self.stack
            mod_http.set_http_attribute(self.rst.http_map[is_node_marker], self.stack)
            self.last_marker = is_node_marker
            #bwm: last_marker is not needed?

    self.stack = self.stack[2]
</t>
<t tx="ekr.20050805162550.49">def feed(self, line):

    self.node_code.append(line)

    HTMLParser.HTMLParser.feed(self, line) # Call the base class's feed().
</t>
<t tx="ekr.20050805162550.5">def init ():
    '''Return True if the plugin has loaded successfully.'''
    ok = docutils is not None # Ok for unit testing.
    if ok:
        g.registerHandler('after-create-leo-frame', onCreate)
        g.plugin_signon(__name__)
    else:
        g.error('rst3 plugin not loaded: can not load docutils')
    return ok
</t>
<t tx="ekr.20050805162550.50">class anchor_htmlParserClass (linkAnchorParserClass):

    '''
    This htmlparser does the first step of relocating: finding all the anchors within the html nodes.

    Each anchor is mapped to a tuple:
        (current_file, position).

    Filters out markers which mark the beginning of the html code for a node.
    '''

    @others
</t>
<t tx="ekr.20050805162550.51">def __init__ (self,rst,p):

    super().__init__(rst)

    self.p = p.copy()
    self.anchor_map = rst.anchor_map
</t>
<t tx="ekr.20050805162550.52">def handle_starttag(self, tag, attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If the current tag is an anchor, update the mapping;
         anchor -&gt; (filename, p)
    '''
    if not self.is_anchor(tag, attrs):
        return

    if self.current_file not in self.anchor_map:
        self.anchor_map[self.current_file] = (self.current_file, self.p)
        simple_name = g.os_path_split(self.current_file)[1]
        self.anchor_map[simple_name] = self.anchor_map[self.current_file]
        if bwm_file: print &gt;&gt; bwm_file, (
            "anchor(1): current_file:", self.current_file,
            "position:", self.p,
            "Simple name:", simple_name,
        )
        # Not sure what to do here, exactly. Do I need to manipulate
        # the pathname?

    for name, value in attrs:
        if name == 'name' or tag == 'span' and name == 'id':
            if not value.startswith(self.node_begin_marker):
                if bwm_file: print &gt;&gt; bwm_file, "anchor(2):", value, self.p
                self.anchor_map[value] = (self.current_file, self.p.copy())
</t>
<t tx="ekr.20050805162550.53">class link_htmlparserClass (linkAnchorParserClass):

    '''This html parser does the second step of relocating links:
    1. It scans the html code for links.
    2. If there is a link which links to a previously processed file
       then this link is changed so that it now refers to the node.
    '''

    @others
</t>
<t tx="ekr.20050805162550.54">def __init__ (self,rst,p):

    super().__init__(rst)

    self.p = p.copy()
    self.anchor_map = rst.anchor_map
    self.replacements = []
</t>
<t tx="ekr.20050805162550.55">def handle_starttag(self, tag, attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If the current tag is an anchor, update the mapping;
         anchor -&gt; p
        Update the list of replacements for the document.
    '''
    if bwm_file: print &gt;&gt; bwm_file, "Is link?", tag, attrs
    if not self.is_link(tag, attrs):
        return

    marker = self.node_begin_marker
    for name, value in attrs:
        if name == 'href':
            href = value
            href_parts = href.split("#")
            if len(href_parts) == 1:
                href_a = href_parts[0]
            else:
                href_a = href_parts[1]
            if bwm_file: print &gt;&gt; bwm_file, "link(1):", name, value, href_a
            if not href_a.startswith(marker):
                if href_a in self.anchor_map:
                    href_file, href_node = self.anchor_map[href_a]
                    http_node_ref = mod_http.node_reference(href_node)
                    line, column = self.getpos()
                    if bwm_file: print &gt;&gt; bwm_file, "link(2):", line, column, href, href_file, http_node_ref
                    self.replacements.append((line, column, href, href_file, http_node_ref))
</t>
<t tx="ekr.20050805162550.56">def get_replacements(self):

    return self.replacements
</t>
<t tx="ekr.20050805162550.6">def onCreate(tag, keywords):

    c = keywords.get('new_c') or keywords.get('c')
    if c:
        global controllers
        controllers[c] = rstClass(c)
        # Warning: Do not return anything but None here!
        # Doing so suppresses the loading of other 'new' or 'open2' hooks!
</t>
<t tx="ekr.20050805162550.8">class rstClass:

    '''A class to write rst markup in Leo outlines.'''

@ This plugin optionally stores information for the http plugin.

Each node can have one additional attribute, with the name rst_http_attributename, which is a list.

The first three elements are stack of tags, the rest is html code.

[&lt;tag n start&gt;, &lt;tag n end&gt;, &lt;other stack elements&gt;, &lt;html line 1&gt;, &lt;html line 2&gt;, ...]

&lt;other stack elements has the same structure:
    [&lt;tag n-1 start&gt;, &lt;tag n-1 end&gt;, &lt;other stack elements&gt;]
@c

    @others
</t>
<t tx="ekr.20050805162550.9"></t>
<t tx="ekr.20050806101253">def code_block (name,arguments,options,content,lineno,content_offset,block_text,state,state_machine):

    '''Implement the code-block directive for docutils.'''

    try:
        language = arguments [0]
        # See http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252170
        module = SilverCity and getattr(SilverCity,language)
        generator = module and getattr(module,language+"HTMLGenerator")
        if generator:
            io = StringIO()
            generator().generate_html(io,'\n'.join(content))
            html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n' % io.getvalue()
        else:
            html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n' % '&lt;br&gt;\n'.join(content)
        raw = docutils.nodes.raw('',html,format='html')
        return [raw]
    except Exception: # Return html as shown.  Lines are separated by &lt;br&gt; elements.
        g.es_trace('exception in rst3:code_block()')
        g.es_exception()
        return [None]

# See http://docutils.sourceforge.net/spec/howto/rst-directives.html
code_block.arguments = (
    1, # Number of required arguments.
    0, # Number of optional arguments.
    0) # True if final argument may contain whitespace.

# A mapping from option name to conversion function.
if docutils:
    code_block.options = {
        'language':
        docutils.parsers.rst.directives.unchanged # Return the text argument, unchanged.
    }
    code_block.content = 1 # True if content is allowed.

    # Register the directive with docutils.
    docutils.parsers.rst.directives.register_directive('code-block',code_block)
else:
    code_block.options = {}

</t>
<t tx="ekr.20050806162146">@nocolor
@

- Specify option for the spelling of special doc parts.
    - The present code assumes to much about these commands.
- Warn if option gets set twice in same vnode.

Later or never:
    - show_context option.
    - encoding option: can override @encoding directives
    - Support docutils config files.

@c

@others
</t>
<t tx="ekr.20050807120331.1">def preprocessTree (self,root):

    self.tnodeOptionDict = {}

    # Bug fix 12/4/05: must preprocess parents too.
    for p in root.parents():
        self.preprocessNode(p)

    for p in root.self_and_subtree():
        self.preprocessNode(p)

    if 0:
        g.trace(root.h)
        for key in self.tnodeOptionDict.keys():
            g.trace(key)
            g.printDict(self.tnodeOptionDict.get(key))
</t>
<t tx="ekr.20050807120331.2">def scanNodeForOptions (self,p):
    '''
    Return a dictionary containing all the option-name:value entries in p.

    Such entries may arise from @rst-option or @rst-options in the headline,
    or from @ @rst-options doc parts.
    '''
    d = self.scanHeadlineForOptions(p)
    d2 = self.scanForOptionDocParts(p,p.b)
    # A fine point: body options over-ride headline options.
    d.update(d2)
    return d
</t>
<t tx="ekr.20050808064245">def createDefaultOptionsDict(self):

    # Warning: changing the names of options changes the names of the corresponding ivars.

    self.defaultOptionsDict = {
        # Http options...
        'rst3_clear_http_attributes':   False,
        'rst3_http_server_support':     False,
        'rst3_http_attributename':      'rst_http_attribute',
        'rst3_node_begin_marker':       'http-node-marker-',
        # Path options...
        'rst3_default_path': None, # New in Leo 4.4a4 # Bug fix: must be None, not ''.
        'rst3_stylesheet_name': 'default.css',
        'rst3_stylesheet_path': None, # Bug fix: must be None, not ''.
        'rst3_publish_argv_for_missing_stylesheets': None,
        # Global options...
        'rst3_code_block_string': '',
        'rst3_number_code_lines': True,
        'rst3_underline_characters': '''#=+*^~"'`-:&gt;&lt;_''',
        'rst3_verbose':True,
        'rst3_write_intermediate_file': False, # Used only if generate_rst is True.
        # Mode options...
        'rst3_code_mode': False, # True: generate rst markup from @code and @doc parts.
        'rst3_doc_only_mode': False, # True: generate only from @doc parts.
        'rst3_generate_rst': True, # True: generate rst markup.  False: generate plain text.
        'rst3_generate_rst_header_comment': True,
            # True generate header comment (requires generate_rst option)
        # Formatting options that apply to both code and rst modes....
        'rst3_show_headlines': True,  # Can be set by @rst-no-head headlines.
        'rst3_show_organizer_nodes': True,
        'rst3_show_options_nodes': False,
        'rst3_show_sections': True,
        'rst3_strip_at_file_prefixes': True,
        'rst3_show_doc_parts_in_rst_mode': True,
        # Formatting options that apply only to code mode.
        'rst3_show_doc_parts_as_paragraphs': False,
        'rst3_show_leo_directives': True,
        'rst3_show_markup_doc_parts': False,
        'rst3_show_options_doc_parts': False,
        # *Names* of headline commands...
        'rst3_code_prefix':             '@rst-code',     # Enter code mode.
        'rst3_doc_only_prefix':         '@rst-doc-only', # Enter doc-only mode.
        'rst3_rst_prefix':              '@rst',          # Enter rst mode.
        'rst3_ignore_headline_prefix':  '@rst-no-head',
        'rst3_ignore_headlines_prefix': '@rst-no-headlines',
        'rst3_ignore_node_prefix':      '@rst-ignore-node',
        'rst3_ignore_prefix':           '@rst-ignore',
        'rst3_ignore_tree_prefix':      '@rst-ignore-tree',
        'rst3_option_prefix':           '@rst-option',
        'rst3_options_prefix':          '@rst-options',
        'rst3_preformat_prefix':        '@rst-preformat',
        'rst3_show_headline_prefix':    '@rst-head',
    }
</t>
<t tx="ekr.20050808070018">def scanOption (self,p,s):
    '''
    Return { name:val } if s is a line of the form name=val.
    Otherwise return {}
    '''
    if not s.strip() or s.strip().startswith('..'):
        return {}
    data = self.parseOptionLine(s)
    if data:
        name,val = data
        fullName = 'rst3_' + self.munge(name)
        if fullName in self.defaultOptionsDict.keys():
            if   val.lower() == 'true': val = True
            elif val.lower() == 'false': val = False
            return { self.munge(name): val }
        else:
            g.error('ignoring unknown option: %s' % (name))
            return {}
    else:
        g.trace(repr(s))
        g.error('bad rst3 option in %s: %s' % (p.h,s))
        return {}
</t>
<t tx="ekr.20050808070018.1">def scanOptions (self,p,s):

    '''Return a dictionary containing all the options in s.'''

    d = {}

    for line in g.splitLines(s):
        d2 = self.scanOption(p,line)
        if d2: d.update(d2)

    return d
</t>
<t tx="ekr.20050808070018.2">def scanForOptionDocParts (self,p,s):

    '''Return a dictionary containing all options from @rst-options doc parts in p.
    Multiple @rst-options doc parts are allowed: this code aggregates all options.
    '''

    d = {} ; n = 0 ; lines = g.splitLines(s)
    while n &lt; len(lines):
        line = lines[n] ; n += 1
        if line.startswith('@'):
            i = g.skip_ws(line,1)
            for kind in ('@rst-options','@rst-option'):
                if g.match_word(line,i,kind):
                    # Allow options on the same line.
                    line = line[i+len(kind):]
                    d.update(self.scanOption(p,line))
                    # Add options until the end of the doc part.
                    while n &lt; len(lines):
                        line = lines[n] ; n += 1 ; found = False
                        for stop in ('@c','@code', '@'):
                            if g.match_word(line,0,stop):
                                found = True ; break
                        if found:
                            break
                        else:
                            d.update(self.scanOption(p,line))
                    break
    return d
</t>
<t tx="ekr.20050808072943">def munge (self,name):

    '''Convert an option name to the equivalent ivar name.'''

    i = 3 if name.startswith('rst') else 0

    while i &lt; len(name) and name[i].isdigit():
        i += 1

    if i &lt; len(name) and name[i] == '_':
        i += 1

    s = name[i:].lower()
    s = s.replace('-','_')

    return s
</t>
<t tx="ekr.20050808072943.1">def parseOptionLine (self,s):
    '''
    Parse a line containing name=val and return (name,value) or None.
    If no value is found, default to True.
    '''
    s = s.strip()
    if s.endswith(','): s = s[:-1]
    # Get name.  Names may contain '-' and '_'.
    i = g.skip_id(s,0,chars='-_')
    name = s [:i]
    if not name:
        return None,'False'
    j = g.skip_ws(s,i)
    if g.match(s,j,'='):
        val = s [j+1:].strip()
        return name,val
    else:
        return name,'True'
</t>
<t tx="ekr.20050808142313.28"># Once an option is seen, no other related options in ancestor nodes have any effect.

def scanAllOptions(self,p):

    '''Scan position p and p's ancestors looking for options,
    setting corresponding ivars.
    '''

    self.initOptionsFromSettings()
        # Must be done on every node.
    self.handleSingleNodeOptions(p)
    seen = self.singleNodeOptions[:]
        # Suppress inheritance of single-node options.
    for p in p.self_and_parents():
        d = self.tnodeOptionDict.get(p.v,{})
        for key in d.keys():
            ivar = self.munge(key)
            if ivar not in seen:
                seen.append(ivar)
                val = d.get(key)
                self.setOption(key,val,p.h)
    # self.dumpSettings()
    if self.rst3_all:
        self.setOption("generate_rst", True, "rst3_all")
        self.setOption("generate_rst_header_comment",True, "rst3_all")
        self.setOption("http_server_support", True, "rst3_all")
        self.setOption("write_intermediate_file", True, "rst3_all")
</t>
<t tx="ekr.20050809074827"></t>
<t tx="ekr.20050809075309">def initWrite (self,p):

    self.initOptionsFromSettings() # Still needed.

    # Set the encoding from any parent @encoding directive.
    # This can be overridden by @rst-option encoding=whatever.
    c = self.c
    d = c.scanAllDirectives(p)
    self.encoding = d.get('encoding') or self.defaultEncoding
    self.path = d.get('path') or ''
</t>
<t tx="ekr.20050809080031">def write (self,s):

    s = self.encode(s)

    self.outputFile.write(s)
</t>
<t tx="ekr.20050809080925">def writeNormalTree (self,p,toString=False):

    self.initWrite(p)

    # Always write to a string first.
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.stringOutput = self.outputFile.getvalue()

    # Copy to a file if requested.
    if not toString:
        # Comput the output file name *after* calling writeTree.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)
        self.outputFile = open(self.outputFileName,'w')
        self.outputFile.write(self.stringOutput)
        self.outputFile.close()

    return True
</t>
<t tx="ekr.20050809082854"></t>
<t tx="ekr.20050809082854.1">def writeToDocutils (self,s):
    '''
    Send s to docutils using the writer implied by self.ext and return the
    result.
    '''
    # openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }
    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()
    writer = None
    for ext,writer in (
        ('.html','html'),
        ('.htm','html'),
        ('.tex','latex'),
        ('.pdf','leo_pdf'),
    ):
        if self.ext == ext:
            break
    else:
        g.error('unknown docutils extension: %s' % (self.ext))
        return ''

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if g.os_path_exists(path):
        if self.ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.error('stylesheet not found: %s' % (path))
    else:
        g.error('stylesheet not found\n',path)
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        res = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer_name=writer,
                settings_overrides=overrides)
    except docutils.ApplicationError as error:
        g.es_print('Error (%s): %s' % (error.__class__.__name__, error))
    return res
</t>
<t tx="ekr.20050810083057">def writeNode (self,p):

    '''Format a node according to the options presently in effect.'''

    self.initCodeBlockString(p)
    self.scanAllOptions(p)

    if 0:
        g.trace('%24s code_mode %s' % (p.h,self.getOption('code_mode')))

    h = p.h.strip()

    if self.getOption('preformat_this_node'):
        self.http_addNodeMarker(p)
        self.writePreformat(p)
        p.moveToThreadNext()
    elif self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.writeHeadline(p)
        self.writeBody(p)
        p.moveToThreadNext()
</t>
<t tx="ekr.20050810083314"></t>
<t tx="ekr.20050810083856">def rstComment (self,s):

    return '.. %s' % s
</t>
<t tx="ekr.20050810103731">def handleSingleNodeOptions (self,p):

    '''Init the settings of single-node options from the tnodeOptionsDict.

    All such options default to False.'''

    d = self.tnodeOptionDict.get(p.v, {} )

    for ivar in self.singleNodeOptions:
        val = d.get(ivar,False)
        self.setOption(ivar,val,p.h)

</t>
<t tx="ekr.20050811101550.1">def writeBody (self,p):

    # remove trailing cruft and split into lines.
    lines = p.b.rstrip().split('\n')

    if self.getOption('code_mode'):
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    s = '\n'.join(lines).strip()
    if s:
        self.write('%s\n\n' % s)
</t>
<t tx="ekr.20050811102607">def skip_literal_block (self,lines,n):

    s = lines[n] ; result = [s] ; n += 1
    indent = g.skip_ws(s,0)

    # Skip lines until a non-blank line is found with same or less indent.
    while n &lt; len(lines):
        s = lines[n]
        indent2 = g.skip_ws(s,0)
        if s and not s.isspace() and indent2 &lt;= indent:
            break # We will rescan lines [n]
        n += 1
        result.append(s)

    # g.printList(result,tag='literal block')
    return n, result
</t>
<t tx="ekr.20050811105438">def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,0,key):
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20050811105438.1">def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20050811135526">def setOption (self,name,val,tag):

    ivar = self.munge(name)
    self.optionsDict [ivar] = val
</t>
<t tx="ekr.20050811150541">def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or
            (self.getOption('show_doc_parts_as_paragraphs') and self.isSpecialDocPart(s,None))
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []
    return self.rstripList(result)
</t>
<t tx="ekr.20050811152104">def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
</t>
<t tx="ekr.20050811153208">def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) &gt; 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    return result
</t>
<t tx="ekr.20050811154552">def getDocPart (self,lines,n):

    result = []
    &lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
            break
        result.append(s)
    return n, result
</t>
<t tx="ekr.20050811163802">def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
</t>
<t tx="ekr.20050811173750">def scanHeadlineForOptions (self,p):

    '''Return a dictionary containing the options implied by p's headline.'''

    h = p.h.strip()

    if p == self.topNode:
        return {} # Don't mess with the root node.
    elif g.match_word(h,0,self.getOption('option_prefix')): # '@rst-option'
        s = h [len(self.option_prefix):]
        return self.scanOption(p,s)
    elif g.match_word(h,0,self.getOption('options_prefix')): # '@rst-options'
        return self.scanOptions(p,p.b)
    else:
        # Careful: can't use g.match_word because options may have '-' chars.
        i = g.skip_id(h,0,chars='@-')
        word = h[0:i]

        for prefix,ivar,val in (
            ('code_prefix','code_mode',True), # '@rst-code'
            ('doc_mode_prefix','doc_only_mode',True), # @rst-doc-only.
            ('default_path_prefix','default_prefix',''), # '@rst-default-path'
            ('rst_prefix','code_mode',False), # '@rst'
            ('ignore_headline_prefix','ignore_this_headline',True), # '@rst-no-head'
            ('show_headline_prefix','show_this_headline',True), # '@rst-head'
            ('ignore_headlines_prefix','show_headlines',False), # '@rst-no-headlines'
            ('ignore_prefix','ignore_this_tree',True),      # '@rst-ignore'
            ('ignore_node_prefix','ignore_this_node',True), # '@rst-ignore-node'
            ('ignore_tree_prefix','ignore_this_tree',True), # '@rst-ignore-tree'
            ('preformat_prefix','preformat_this_node',True), # '@rst-preformat
        ):
            prefix = self.getOption(prefix)
            if prefix and word == prefix: # Do _not_ munge this prefix!
                d = { ivar: val }
                if ivar != 'code_mode':
                    d ['code_mode'] = False # Enter rst mode.
                    d ['doc_only_mode'] = False
                # Special case: Treat a bare @rst like @rst-no-head
                if h == self.getOption('rst_prefix'):
                    d ['ignore_this_headline'] = True
                return d

        if h.startswith('@rst'):
            g.trace('word',word,'rst_prefix',self.getOption('rst_prefix'))
            g.trace('unknown kind of @rst headline',p.h)

        return {}
</t>
<t tx="ekr.20050812120933">def dumpSettings (self):

    d = self.optionsDict
    keys = list(d.keys())
    keys.sort()

    g.pr('present settings...')
    for key in keys:
        g.pr('%20s %s' % (key,d.get(key)))
</t>
<t tx="ekr.20050812122236"></t>
<t tx="ekr.20050813083007">def initHeadlineCommands (self):

    '''Init the list of headline commands used by writeHeadline.'''

    self.headlineCommands = [
        self.getOption('code_prefix'),
        self.getOption('doc_only_prefix'),
        self.getOption('default_path_prefix'),
        self.getOption('rst_prefix'),
        self.getOption('ignore_headline_prefix'),
        self.getOption('ignore_headlines_prefix'),
        self.getOption('ignore_node_prefix'),
        self.getOption('ignore_tree_prefix'),
        self.getOption('option_prefix'),
        self.getOption('options_prefix'),
        self.getOption('show_headline_prefix'),
        # # Suggested by Hemanth P.S.: prevent @file nodes from creating headings.
        # self.getOption('keep_at_file_prefix'),
        # self.getOption('strip_at_file_prefix'),
    ]
</t>
<t tx="ekr.20050813085236">def initSingleNodeOptions (self):

    self.singleNodeOptions = [
        'ignore_this_headline',
        'ignore_this_node',
        'ignore_this_tree',
        'preformat_this_node',
        'show_this_headline',
    ]
</t>
<t tx="ekr.20050813155021">def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    s = '\n'.join(theList).rstrip()
    return s.split('\n')
</t>
<t tx="ekr.20050813160208">def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
</t>
<t tx="ekr.20050814134351">def getOption (self,name):

    bwm = False
    if bwm:
        g.trace("bwm: getOption self:%s, name:%s, value:%s" % (
            self, name, self.optionsDict.get(name)))

    return self.optionsDict.get(name)
</t>
<t tx="ekr.20050815091008.1">def http_addNodeMarker (self,p):

    if (
        self.getOption('http_server_support') and
        self.getOption('generate_rst')
    ):
        self.nodeNumber += 1
        anchorname = "%s%s" % (self.getOption('node_begin_marker'),self.nodeNumber)
        s = "\n\n.. _%s:\n\n" % anchorname
        self.write(s)
        self.http_map [anchorname] = p.copy()
        if bwm_file: print &gt;&gt; bwm_file, "addNodeMarker", anchorname, p
</t>
<t tx="ekr.20050815164715">def is_node_marker (self,attrs):
    '''
    Return the name of the anchor, if this is an anchor for the beginning of a node,
    False otherwise.
    '''

    d = dict(attrs)
    result = 'id' in d and d['id'].startswith(self.node_begin_marker)
    if result:
        return d['id']
    return result
</t>
<t tx="ekr.20050815164715.1">if 0:
    g.pr("rst3: unknownAttributes[self.http_attributename]")
    g.pr("For:", self.last_position)
    pprint.pprint(mod_http.get_http_attribute(self.last_position))
</t>
<t tx="ekr.20050817132814">@nocolor-node

Important: the rst3 plugin has largely been superceded by similar
commands built into Leo's core.

To activate the rst3 plugin, do the following:

1. Go to http://silvercity.sourceforge.net/.
- Follow the link 'SilverCity Releases'.
- Download the release that fits to your Python version.
- Double-klick on the downloaded file.

2. Go to http://docutils.sourceforge.net/.
- Have a look for item 'Download'
- Get, as the editor says, the latest snapshot by following the link
  'docutils-snapshot.tgz'.
- Make sure you have a application that can handle this format. 7zip is doing this great.
- Unpack it to a temporary folder.
- Open a console window, go to the temporary folder and type 'setup.py install'
  or '&lt;path_to_python.exe&gt;\python setup.py install'.

3. Start up Leo
- Check in the menu 'Edit' for item 'Write-Restructured-Text'.
</t>
<t tx="ekr.20051121102358">def processTopTree (self,p,justOneFile=False):

    current = p.copy()
    for p in current.self_and_parents():
        h = p.h
        if h.startswith('@rst') and not h.startswith('@rst-'):
            self.processTree(p,
                ext=None,
                toString=False,
                justOneFile=justOneFile,
            )
            break
    else:
        self.processTree(current,
            ext=None,
            toString=False,
            justOneFile=justOneFile,
        )
    g.blue('done')
</t>
<t tx="ekr.20051202070028">def computeOutputFileName (self,fileName):

    openDirectory = self.c.frame.openDirectory
    default_path = self.getOption('default_path')
    if default_path:
        path = g.os_path_finalize_join(self.path,default_path,fileName)
    elif self.path:
        path = g.os_path_finalize_join(self.path,fileName)
    elif openDirectory:
        path = g.os_path_finalize_join(self.path,openDirectory,fileName)
    else:
        path = g.os_path_finalize_join(fileName)

    return path
</t>
<t tx="ekr.20051204070141">def preprocessNode (self,p):

    d = self.tnodeOptionDict.get(p.v)
    if d is None:
        d = self.scanNodeForOptions(p)
        self.tnodeOptionDict [p.v] = d
</t>
<t tx="ekr.20060525102337">def writeNodeToString (self,p=None,ext=None):
    '''
    Scan p's tree (defaults to presently selected tree) looking for @rst nodes.
    Convert the first node found to an ouput of the type specified by ext.

    The @rst may or may not be followed by a filename; the filename is *ignored*,
    and its type does not affect ext or the output generated in any way.

    ext should start with a period:  .html, .tex or None (specifies rst output).

    Returns p, s, where p is the position of the @rst node and s is the converted text.
    '''
    c = self.c
    current = p or c.p
    for p in current.self_and_parents():
        if p.h.startswith('@rst'):
            return self.processTree(p,ext=ext,toString=True,justOneFile=True)
    return self.processTree(current,ext=ext,toString=True,justOneFile=True)
</t>
<t tx="ekr.20060608094815">def handleDocOnlyMode (self,p,lines):
    '''
    Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.
    '''
    # ignore            = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')
    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            self.writeHeadlineHelper(p)
    return result
</t>
<t tx="ekr.20060608094815.1">def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
</t>
<t tx="ekr.20060608102001">def writeHeadlineHelper (self,p):

    h = p.h.strip()

    # Remove any headline command before writing the
    i = g.skip_id(h,0,chars='@-')
    word = h [:i]
    if word:
        # Never generate a section for @rst-option or @rst-options.
        if word in (self.getOption('option_prefix'),self.getOption('options_prefix')):
            return
        # Remove all other headline commands from the headline.
        for prefix in self.headlineCommands:
            if word == prefix:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write('%s\n%s\n' % (h,self.underline(h,p)))
        else:
            self.write('\n%s\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
</t>
<t tx="ekr.20060610104435">if n &gt; 0:
    line = lines[n-1]
    if line.startswith('@doc'):
        s = line[4:].lstrip()
    elif line.startswith('@'):
        s = line[1:].lstrip()
    else:
        s = ''

    # New in Leo 4.4.4: remove these special tags.
    for tag in ('@rst-options','@rst-option','@rst-markup'):
        if g.match_word(s,0,tag):
            s = s[len(tag):].strip()

    if s.strip():
        result.append(s)
</t>
<t tx="ekr.20061023141638"></t>
<t tx="ekr.20061023142737"></t>
<t tx="ekr.20061023142737.1"></t>
<t tx="ekr.20071015110830">def initCodeBlockString(self,p):

    # New in Leo 4.4.4: do this here, not in initWrite:
    c = self.c
    d = c.scanAllDirectives(p)
    language = d.get('language')
    if language is None:
        language = 'python'
    else:
        language = language.lower()
    syntax = SilverCity is not None
    s = self.getOption('code_block_string')
    if s:
        self.code_block_string = s.replace('\\n','\n')
    elif syntax and language in ('python','ruby','perl','c'):
        self.code_block_string = '**code**:\n\n.. code-block:: %s\n' % language.title()
    else:
        self.code_block_string = '**code**:\n\n.. class:: code\n..\n\n::\n'
</t>
<t tx="ekr.20071113084440"># These plugins are for testing Leo's own plugin loading logic.
# There is no reason ever to enable these plugins.</t>
<t tx="ekr.20071115061253">def writePreformat (self,p):

    '''Write p's body text lines as if preformatted.

     ::

        line 1
        line 2 etc.
    '''
    lines = p.b.split('\n')
    lines = [' '*4 + z for z in lines]
    lines.insert(0,'::\n')
    s = '\n'.join(lines)
    if s.strip():
        self.write('%s\n\n' % s)
</t>
<t tx="ekr.20090428082801.64">def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    d = {}
    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return d

    args = s.strip()
    if args.find(',') == -1:
        args = [args]
    else:
        args = args.split(',')

    for arg in args:
        data = arg.split('=')
        if len(data) == 1:
            key = data[0]
            d[str(key)] = ""
        elif len(data) == 2:
            key,value = data
            d[str(key)] = str(value)
        else:
            g.error('bad option: %s' % s)
            break

    return d
</t>
<t tx="ekr.20090429055156.63">def runUnitTests(c):

    rstClass(c)
    p = g.findNodeAnywhere(c,'UnitTests')
    if p:
        c.selectPosition(p)
        c.testManager.doTests(all=None, marked=None, verbosity=1)
</t>
<t tx="ekr.20090430075506.4">@nosearch</t>
<t tx="ekr.20100103093121.5365"># These are experimental plugins.
</t>
<t tx="ekr.20101004082701.5674"></t>
<t tx="ekr.20101110150056.9453"># Some of the most important recent plugins work only with the Qt gui.
</t>
<t tx="ekr.20101110150056.9457"></t>
<t tx="ekr.20120309073937.9878"></t>
<t tx="ekr.20121126102050.10134"></t>
<t tx="ekr.20130927050813.13031"></t>
<t tx="ekr.20140723122936.17925"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins now contain the importer code for all kinds of @auto nodes.
# Each plugin must define a top-level importer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20140726091031.18071"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins now contain the write code for all kinds special @auto nodes.
# Each plugin must define a top-level writer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20160122104302.1">@nosearch</t>
<t tx="ekr.20160122104357.1">pylint
beautify-node
beautify-tree
</t>
<t tx="ekr.20160122104400.1"></t>
<t tx="ekr.20160412101537.1">'''Imports c:\prog\Julia.ipynb to the node import-Julia.ipynb'''
import nbformat
@others
g.cls()
if 0:
    # fn = r'c:\test\Julia.ipynb'
    fn = r'c:\test\export-neural-networds.ipynb'
    h = 'import-Julia.ipynb'
else:
    h = fn = r'c:\test\04_Neural_Networks.ipynb'
root = g.findTopLevelNode(c, h)
if root:
    while root.hasChildren():
        root.lastChild().doDelete()
else:
    p = c.lastTopLevel()
    root = p.insertAfter()
    root.h = h
x = Import_IPYNB(c)
x.import_file(fn, root)
if not g.unitTesting:
    # These don't work when running unit tests.
    c.selectPosition(root)
    # c.expandAllSubheads()
    c.redraw() 
    g.es_print('done')
</t>
<t tx="ekr.20160412101845.1"># g.cls()
import re
import sys
if 1:
    h = 'import-neural-networks.ipynb'
    fn = r'c:\test\export-neural-networds.ipynb'
else:
    h = 'import-Julia.ipynb'
    fn = r'c:\test\export-julia.ipynb'
p = g.findTopLevelNode(c, h)
assert p, h
@others
Export_IPYNB(c).export_outline(p, fn=fn)
</t>
<t tx="ekr.20160510132151.1">c.backup_helper(sub_dir='leoPlugins')
</t>
<t tx="ekr.20161030154232.1">'''Converts the word at the cursor to pep8 style throughout a given tree.'''
# aTestExample notFoundExample.
import re
# clear()
table = (
    # 'BLS.new_scan',
    # 'BLS.Code generation',
    # 'class Importer',
)
@others
Pep8(table, change=True).run()
</t>
<t tx="ekr.20161031051319.1">def get_name(self):
    i, j = c.editCommands.extendToWord(event=None, select=False)
    w = c.frame.body.wrapper
    s = w.getAllText()
    name = s[i:j]
    return name
</t>
<t tx="ekr.20161031051342.1">def to_pep8(self, s):
    
    if len(s) &gt; 1 and s[0].islower() and s.lower() != s:
        result = []
        for ch in s:
            result.append(ch)
            if ch.isupper():
                result.pop()
                result.append('_%s' % (ch.lower()))
        return ''.join(result)
    else:
        return name</t>
<t tx="ekr.20161031053537.1">def change_all(self, name, new_name, root):
    '''Change name to new_name throughout root's tree.'''
    u = c.undoer
    bunch = u.beforeChangeTree(root)
    found = False
    self.pattern = re.compile(r'\b%s\b' % name)
    for p in root.self_and_subtree():
        found = self.change_headline(name, new_name, p) or found
        found = self.change_body(name, new_name, p) or found
    if found:
        u.afterChangeTree(root, 'pep8', bunch)
    return found
</t>
<t tx="ekr.20161031065339.1">def clear():
    g.cls()
    c.k.simulateCommand('clear-log')
</t>
<t tx="ekr.20161031074727.1">def change_body(self, name, new_name, p):
    indices = []
    for m in self.pattern.finditer(p.b):
        indices.append(str(m.start()))
    if indices:
        n = len(indices)
        g.es_print('%s change%s: %s' % (n, g.plural(n), p.h))
        s = p.b
        for i in reversed(indices):
            i = int(i)
            s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.b = s
            p.setDirty()
        else:
            g.es_print(s)
    return bool(indices)</t>
<t tx="ekr.20161031075018.1">def change_headline(self, name, new_name, p):
    m = self.pattern.search(p.h)
    if m:
        i = m.start()
        s = p.h
        s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.h = s
            p.setDirty()
            g.es_print('changed headline', s)
        else:
            g.es_print('headline', s)
    return bool(m)
</t>
<t tx="ekr.20161031124905.1">class Pep8:
    '''
    Convert the word under the cursor to pep8 style in all subtrees in
    table.
    '''
    
    def __init__ (self, table, change=False):
        '''Ctor for Pep8 class.'''
        self.change = change
        self.table = table
        
    @others
</t>
<t tx="ekr.20161031125119.1">def run(self):
    # self.clear()
    name = self.get_name()
    new_name = self.to_pep8(name)
    if len(name) &lt; 2:
        g.es_print('name too short:', name)
    elif new_name == name:
        g.es_print('already pep8:', name)
    else:
        g.es_print('%s -&gt; %s' % (name, new_name))
        c.findCommands.ftm.setFindText(new_name)
            # Preload the replacement text.
        found = False
        for target in table:
            root = g.findNodeAnywhere(c, target)
            if root:
                found = self.change_all(name, new_name, root) or found
            else:
                g.es_print('not found: %s' % target)
        if found:
            c.redraw()
        else:
            g.es_print('not found:', name)
</t>
<t tx="ekr.20161122014821.1">g.cls()
# define constants that describe the new language.
name = 'php'
    # The name of the file, and the prefix for classes.
language = 'php'
    # The name of the language, case doesn't matter.
extensions = ['.php',]
    # A list of file extensions supported by this importer.
strict = False
    # True if leading whitespace is particularly significant.
state_ivar = 'self.curlies'
    # 'self.indent' for python, coffeescript.
    # 'self.curlies' for many other languages
    # '(self, curlies, self.parens)' for more complex comparisons
&lt;&lt; define run &amp; helpers &gt;&gt;
run(extensions, language, name, state_ivar)
</t>
<t tx="ekr.20161122020451.1">@others</t>
<t tx="ekr.20161122020932.1">def copy_tree(source, root, h):
    '''Copy the source tree to the node after p, with headline h.'''
    p2 = root.insertAfter()
    source.copyTreeFromSelfTo(p2)
    p2.h = h
    return p2
 </t>
<t tx="ekr.20161122021006.1">def make_substitutions(destination, patterns):
    '''Make all substitutions in the destination tree.'''
    for p in destination.self_and_subtree():
        h = substitute(p.h, patterns)
        if p.h != h:
            # g.trace('CHANGED:', p.h, '==&gt;', h)
            p.h = h
        b = substitute(p.b, patterns)
        if p.b != b:
            # g.trace('CHANGED:', p.b, '==&gt;', b)
            p.b = b
</t>
<t tx="ekr.20161122021342.1">def substitute(s, patterns):
    '''Make all substitutions in s.'''
    for pattern in patterns:
        find = '{{%s}}' % pattern
        replace = patterns.get(pattern)
        i = 0
        while i &lt; len(s):
            progress = i
            j = s.find(find, i)
            if j == -1: break
            s = s[:j] + replace + s[j+len(find):]
            i = j+len(replace)
            assert progress &lt; i
    return s
</t>
<t tx="ekr.20161122023427.1">def run(extensions, language, name, state_ivar):
    '''The driver for this script.'''
    patterns = {
        'cap_name': name.capitalize(),
        'extensions': '[%s]' % ', '.join(["'%s'" % (z) for z in extensions]),
        'language': language.lower(),
        'name': name.lower(),
        'strict': 'True' if strict else 'False',
        'state_ivar': state_ivar,
    }
    h = '@button make-importer'
    root = g.findNodeAnywhere(c, h)
    assert root, h
    h = '@@file importers/{{name}}.py'
    source = g.findNodeInTree(c, root, h)
    assert source, h
    destination = copy_tree(source, root, h)
    make_substitutions(destination, patterns)
    c.contractAllHeadlines()
    c.redraw()</t>
<t tx="ekr.20161122023554.1">'''The @auto importer for the {{name}} language.'''
import leo.plugins.importers.linescanner as linescanner
Importer = linescanner.Importer
@others
importer_dict = {
    'class': {{cap_name}}_Importer,
    'extensions': {{extensions}},
}
@language python
@tabwidth -4


</t>
<t tx="ekr.20161122023554.2">class {{cap_name}}_Importer(Importer):
    '''The importer for the {{name}} lanuage.'''

    def __init__(self, importCommands, atAuto):
        '''{{cap_name}}_Importer.__init__'''
        # Init the base class.
        Importer.__init__(self,
            importCommands,
            atAuto = atAuto,
            language = '{{language}}',
            state_class = {{cap_name}}_ScanState,
            strict = {{strict}},
        )
        
    @others
</t>
<t tx="ekr.20161122023554.3"># These can be overridden in subclasses.
</t>
<t tx="ekr.20161122023554.4">### Define an override if desired...

if 0: # The base class
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        return s.strip()
        
if 0: # A more complex example, for the C language.
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        import re
        type1 = r'(static|extern)*'
        type2 = r'(void|int|float|double|char)*'
        class_pattern = r'\s*(%s)\s*class\s+(\w+)' % (type1)
        pattern = r'\s*(%s)\s*(%s)\s*(\w+)' % (type1, type2)
        m = re.match(class_pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            return '%sclass %s' % (prefix1, m.group(2))
        m = re.match(pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            prefix2 = '%s ' % (m.group(2)) if m.group(2) else ''
            h = m.group(3) or '&lt;no c function name&gt;'
            return '%s%s%s' % (prefix1, prefix2, h)
        else:
            return s
</t>
<t tx="ekr.20161122023554.5">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an examplle.
    '''
    pass
</t>
<t tx="ekr.20161122023554.6">class {{cap_name}}_ScanState:
    '''A class representing the state of the {{name}} line-oriented scan.'''
    
    def __init__(self, d=None):
        '''{{cap_name}}_ScanState.__init__'''
        if d:
            prev = d.get('prev')
            self.context = prev.context
            ### Adjust these by hand.
            self.curlies = prev.curlies
        else:
            self.context = ''
            ### Adjust these by hand.
            self.curlies = 0

    def __repr__(self):
        '''{{cap_name}}_ScanState.__repr__'''
        ### Adjust these by hand.
        return "{{cap_name}}_ScanState context: %r curlies: %s" % (
            self.context, self.curlies)

    __str__ = __repr__

    @others
</t>
<t tx="ekr.20161122023554.7">def level(self):
    '''{{cap_name}}_ScanState.level.'''
    return {{state_ivar}}

</t>
<t tx="ekr.20161122023554.8">def update(self, data):
    '''
    {{cap_name}}_ScanState.update

    Update the state using the 6-tuple returned by v2_scan_line.
    Return i = data[1]
    '''
    context, i, delta_c, delta_p, delta_s, bs_nl = data
    # All ScanState classes must have a context ivar.
    self.context = context
    self.curlies += delta_c  
    ### Update {{cap_name}}_ScanState ivars
    # self.bs_nl = bs_nl
    # self.parens += delta_p
    # self.squares += delta_s
    return i
</t>
<t tx="ekr.20170203054655.1"></t>
<t tx="ekr.20170420085814.1">'''Recursively import all python files in a directory and clean the result.'''
dir_ = r'C:\leo.repo\leo-editor\leo\plugins\pyzo'
g.cls()
c.recursiveImport(
    dir_ = dir_,
    kind = '@clean', # '@clean', #'@nosent','@auto','@file',
    recursive = True,
    safe_at_file = False,
    theTypes = ['.py',],
)
</t>
<t tx="ekr.20170709095709.1">**Temporary**: So I can fix #516 without going crazy.</t>
<t tx="ekr.20170811173231.1">@language python
import os
import subprocess
import sys
import time
win = sys.platform.startswith('win')
old_dir = g.os_path_abspath('.')
if win:
    new_dir = r'C:\leo.repo\leo-editor'
    path = r'C:\Users\edreamleo\Backup'
else:
    new_dir = '/home/edward/leo.repo/leo-editor'
    path = '/home/edward/Backup'
assert g.os_path_exists(new_dir), repr(new_dir)
assert g.os_path_exists(path), repr(path)
stamp = time.strftime("%Y%m%d-%H%M%S")
fn = g.os_path_finalize_join(path, 'leo-bundle-all-%s' % (stamp))
bundle_command = 'git bundle create %s --all' % fn
print(bundle_command)
os.chdir(new_dir)
# os.system(bundle_command)
proc = subprocess.Popen(bundle_command, shell=True)
proc.wait()
os.chdir(old_dir)
print('done! wrote %s' % fn)
</t>
<t tx="ekr.20180504191650.34"></t>
<t tx="ekr.20180504191650.36"></t>
<t tx="ekr.20180504191650.42"></t>
<t tx="ekr.20180504191650.68"></t>
<t tx="ekr.20180504192522.1"></t>
<t tx="ekr.20181017164437.1"># Replace underscore by - in settings names.
g.cls()
import re
kinds = (
    'Bool', 'Color',
    'Directory', 'Encoding', # Not found.
    'Float', 'Int',
    'Path', 'Ratio', # Not found.
    'String',
)
for kind in kinds:
    print('===== %s =====\n' % kind)
    pat = re.compile(r"get%s\s*\([\'\"]([\w_]+)[\'\"][,)]" % kind)
    for p in c.all_positions():
        s = p.b
        i, found = 0, False
        while True:
            m = pat.search(s[i:])
            if not m:
                break
            start, end = m.start(1), m.end(1)
            all = s[i+m.start(0):i+m.end(0)]
            word = s[i+start:i+end]
            if '_' in word:
                found = True
                print('')
                print('-----', p.h)
                print(all)
                s = s[:i+start] + word.replace('_','-') + s[i+end:]
                print(s[i+m.start(0):i+m.end(0)])
            i += end
        if found:
            assert p.b != s, p.h
            # print(s)
            p.b = s
            p.v.setDirty()
c.setChanged()
c.redraw()     </t>
<t tx="ekr.20181030041436.1"></t>
<t tx="ekr.20190410171646.1">@first # -*- coding: utf-8 -*-
'''
pyzo_support.py: Will probably be deleted.
'''
&lt;&lt; copyright &gt;&gt;
import leo.core.leoGlobals as g
assert g
@others
</t>
<t tx="ekr.20190410171905.1">def init():
    print('pyzo_support.py is not a real plugin')
    return False
</t>
<t tx="ekr.20190412042616.1">@
This file uses code from pyzo. Here is the pyzo copyright notice:

Copyright (C) 2013-2018, the Pyzo development team

Pyzo is distributed under the terms of the (new) BSD License.
The full license can be found in 'license.txt'.

Yoton is distributed under the terms of the (new) BSD License.
The full license can be found in 'license.txt'.
</t>
<t tx="ekr.20190418161712.1">class PyzoInterface:
    '''
    A class representing the singleton running instance of pyzo.
    
    Instantiated in the top-level init() function.
    '''

    @others
</t>
<t tx="ekr.20190803175344.1">def patch_pyzo(self):
    '''
    Called at the end of pyzo.start to embed Leo into pyzo.
    '''
</t>
<t tx="ekr.20190805022257.1">@first # -*- coding: utf-8 -*-
"""pyzo_file_browser.py: Experimental plugin that adds pyzo's file browser dock to Leo."""
&lt;&lt; pyzo_file_browser imports &gt;&gt;
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190809093446.1">import leo.core.leoGlobals as g
from leo.core.leoQt import QtCore
#
# Must patch sys.path here.
import sys
plugins_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
sys.path.insert(0, plugins_dir)
#
# Start pyzo, de-fanged.
import pyzo
# pylint: disable=no-member

</t>
<t tx="ekr.20190809093459.1"></t>
<t tx="ekr.20190809093459.3">init_warning_given = False

def init(): # pyzo_file_browser.py
    '''Return True if this plugin can be loaded.'''
    
    def oops(message):
        global init_warning_given
        if not init_warning_given:
            init_warning_given = True
            print('%s %s' % (__name__, message))
        return False
        
    if g.app.gui.guiName() != "qt":
        return oops('requires Qt gui')
    # if not pyzo:
        # return oops('requires pyzo')
    if not g.app.dock:
        return oops('is incompatible with --no-dock')
    g.plugin_signon(__name__)
    g.registerHandler('after-create-leo-frame', onCreate)
    return True
</t>
<t tx="ekr.20190809093459.4">def onCreate(tag, keys): # pyzo_file_browser.py
    '''Create a pyzo file browser in c's outline.'''
    c = keys.get('c')
    dw = c and c.frame and c.frame.top
    if not dw:
        return
    pyzo.start_pyzo_in_leo(c, pyzo)
    from pyzo.tools.pyzoFileBrowser import PyzoFileBrowser
    make_dock(c,
        name="File Browser",
        widget=PyzoFileBrowser(parent=None),
    )
</t>
<t tx="ekr.20190812072047.10">def getResourceDirs():
    """ getResourceDirs()
    Get the directories to the resources: (pyzoDir, appDataDir).
    Also makes sure that the appDataDir has a "tools" directory and
    a style file.
    """

#     # Get root of the Pyzo code. If frozen its in a subdir of the app dir
#     pyzoDir = paths.application_dir()
#     if paths.is_frozen():
#         pyzoDir = os.path.join(pyzoDir, 'source')
    pyzoDir = os.path.abspath(os.path.dirname(__file__))
    if '.zip' in pyzoDir:
        raise RuntimeError('The Pyzo package cannot be run from a zipfile.')

    # Get where the application data is stored (use old behavior on Mac)
    appDataDir = paths.appdata_dir('pyzo', roaming=True, macAsLinux=True)

    # Create tooldir if necessary
    toolDir = os.path.join(appDataDir, 'tools')
    if not os.path.isdir(toolDir):
        os.mkdir(toolDir)

    return pyzoDir, appDataDir
</t>
<t tx="ekr.20190812072047.100">def __getitem__(self, key):
    try:
        return self._parts[key]
    except KeyError:
        raise KeyError('Invalid part key for style format.')
</t>
<t tx="ekr.20190812072047.101">def __iter__(self):
    """ Yields a series of tuples (key, val).
    """
    parts = []
    for key in self._parts:
        parts.append( (key, self._parts[key]) )
    return parts.__iter__()
</t>
<t tx="ekr.20190812072047.102">def update(self, format):
    """ update(format)

    Update this style format with the given format.

    """

    # Reset buffered values
    self._resetProperties()

    # Make a string, so we update the format with the given one
    if isinstance(format, StyleFormat):
        format = str(format)

    # Split on ',' and ',', ignore spaces
    styleParts = [p for p in
                    format.replace('=',':').replace(';',',').split(',')]

    for stylePart in styleParts:

        # Make sure it consists of identifier and value pair
        # e.g. fore:#xxx, bold:yes, underline:no
        if not ':' in stylePart:
            if stylePart.startswith('#'):
                stylePart = 'foreandback:' + stylePart
            else:
                stylePart += ':yes'

        # Get key value and strip and make lowecase
        key, _, val = [i.strip().lower() for i in stylePart.partition(':')]

        # Store in parts
        if key == 'foreandback':
            self._parts['fore'] = val
            self._parts['back'] = val
        elif key:
            self._parts[key] = val

## Properties
</t>
<t tx="ekr.20190812072047.103">def _getValueSafe(self, key):
    try:
        return self._parts[key]
    except KeyError:
        return 'no'
</t>
<t tx="ekr.20190812072047.104">@property
def fore(self):
    if self._fore is None:
        self._fore = QtGui.QColor(self._parts['fore'])
    return self._fore
</t>
<t tx="ekr.20190812072047.105">@property
def back(self):
    if self._back is None:
        self._back = QtGui.QColor(self._parts['back'])
    return self._back
</t>
<t tx="ekr.20190812072047.106">@property
def bold(self):
    if self._bold is None:
        if self._getValueSafe('bold') in ['yes', 'true']:
            self._bold = True
        else:
            self._bold = False
    return self._bold
</t>
<t tx="ekr.20190812072047.107">@property
def italic(self):
    if self._italic is None:
        if self._getValueSafe('italic') in ['yes', 'true']:
            self._italic = True
        else:
            self._italic = False
    return self._italic
</t>
<t tx="ekr.20190812072047.108">@property
def underline(self):
    if self._underline is None:
        val = self._getValueSafe('underline')
        if val in ['yes', 'true']:
            self._underline = QtGui.QTextCharFormat.SingleUnderline
        elif val in ['dotted', 'dots', 'dotline']:
            self._underline = QtGui.QTextCharFormat.DotLine
        elif val in ['wave']:
            self._underline = QtGui.QTextCharFormat.WaveUnderline
        else:
            self._underline = QtGui.QTextCharFormat.NoUnderline
    return self._underline
</t>
<t tx="ekr.20190812072047.109">@property
def linestyle(self):
    if self._linestyle is None:
        val = self._getValueSafe('linestyle')
        if val in ['yes', 'true']:
            self._linestyle = Qt.SolidLine
        elif val in ['dotted', 'dot', 'dots', 'dotline']:
            self._linestyle = Qt.DotLine
        elif val in ['dashed', 'dash', 'dashes', 'dashline']:
            self._linestyle = Qt.DashLine
        else:
            self._linestyle = Qt.SolidLine # default to solid
    return self._linestyle
</t>
<t tx="ekr.20190812072047.11">def resetConfig(preserveState=True):
    """ resetConfig()
    Deletes the config file to revert to default and prevent Pyzo from storing
    its config on the next shutdown.
    """
    # Get filenames
    configFileName2 = os.path.join(appDataDir, 'config.ssdf')
    os.remove(configFileName2)
    global _saveConfigFile
    _saveConfigFile = False
    print("Deleted user config file. Restart Pyzo to revert to the default config.")
</t>
<t tx="ekr.20190812072047.110">@property
def textCharFormat(self):
    if self._textCharFormat is None:
        self._textCharFormat = QtGui.QTextCharFormat()
        self._textCharFormat.setForeground(self.fore)
        self._textCharFormat.setUnderlineStyle(self.underline)
        if self.bold:
            self._textCharFormat.setFontWeight(QtGui.QFont.Bold)
        if self.italic:
            self._textCharFormat.setFontItalic(True)
    return self._textCharFormat
</t>
<t tx="ekr.20190812072047.111">@path pyzo/codeeditor/
# -*- coding: utf-8 -*-
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072047.112">class TextReshaper:
    """ Object to reshape a piece of text, taking indentation, paragraphs,
    comments and bulletpoints into account.
    """

    @others
testText = """

# This is a piece
# of comment
Lorem ipsum dolor sit amet, consectetur
adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi
ut aliquip ex ea
commodo consequat. Duis aute irure dolor
in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat
non proident, sunt in culpa qui officia deserunt mollit anim
id est laborum.

        # Indented comments
        # should work
        # as well

skdb-a-very-long-word-ksdbfksasdvbassdfhjsdfbjdfbvhjdbvhjbdfhjvbdfjbvjdfbvjdfbvjdbfvj

   A change in indentation makes it a separate line
sdckj bsdkjcb sdc
sdckj  foo bar
aap noot mies

  * Bullet points are preserved
  * Even if they are very long the should be preserved. I know that brevity is a great virtue but you know,
    sometimes you just need those
    extra words to make a point.

"""

if __name__ == '__main__':
    print(TextReshaper.reshapeText(testText, 70))
</t>
<t tx="ekr.20190812072047.113">def __init__(self, lw, margin=3):
    self.lw = lw
    self.margin = margin

    self._lines1 = []
    self._lines2 = []

    self._wordBuffer = []
    self._charsInBuffer = -1 # First word ads one extra

    self._pendingPrefix = None # A one-shot prefix
    self._currentPrefix = None # The prefix used until a new prefix is set
</t>
<t tx="ekr.20190812072047.114">@classmethod
def reshapeText(cls, text, lw):
    tr = cls(lw)
    tr.pushText(text)
    return tr.popText()
</t>
<t tx="ekr.20190812072047.115">def pushLine(self, line):
    """ Push a single line to the input.
    """
    self._lines1.append(line.rstrip())
</t>
<t tx="ekr.20190812072047.116">def pushText(self, text):
    """ Push a (multiline) text to the input.
    """
    for line in text.splitlines():
        self.pushLine(line)
</t>
<t tx="ekr.20190812072047.117">def popLines(self):
    """ Get all available lines from the output.
    """
    try:
        while True:
            self._popLine()
    except StopIteration:
        self._flush()

    return [line for line in self._lines2]
</t>
<t tx="ekr.20190812072047.118">def popText(self):
    """ Get all text from the output (i.e. lines joined with newline).
    """
    return '\n'.join(self.popLines())
</t>
<t tx="ekr.20190812072047.119">def _prefixString(self):
    if self._pendingPrefix is not None:
        prefix = self._pendingPrefix
        self._pendingPrefix = None
        return prefix
    else:
        return self._currentPrefix or ''
</t>
<t tx="ekr.20190812072047.12">def loadConfig(defaultsOnly=False):
    """ loadConfig(defaultsOnly=False)
    Load default and site-wide configuration file(s) and that of the user (if it exists).
    Any missing fields in the user config are set to the defaults.
    """

    # Function to insert names from one config in another
    def replaceFields(base, new):
        for key in new:
            if key in base and isinstance(base[key], ssdf.Struct):
                replaceFields(base[key], new[key])
            else:
                base[key] = new[key]

    # Reset our pyzo.config structure
    ssdf.clear(config)

    # Load default and inject in the pyzo.config
    fname = os.path.join(pyzoDir, 'resources', 'defaultConfig.ssdf')
    defaultConfig = ssdf.load(fname)
    replaceFields(config, defaultConfig)

    # Platform specific keybinding: on Mac, Ctrl+Tab (actually Cmd+Tab) is a system shortcut
    if sys.platform == 'darwin':
        config.shortcuts2.view__select_previous_file = 'Alt+Tab,'

    # Load site-wide config if it exists and inject in pyzo.config
    fname = os.path.join(pyzoDir, 'resources', 'siteConfig.ssdf')
    if os.path.isfile(fname):
        try:
            siteConfig = ssdf.load(fname)
            replaceFields(config, siteConfig)
        except Exception:
            t = 'Error while reading config file %r, maybe its corrupt?'
            print(t % fname)
            raise

    # Load user config and inject in pyzo.config
    fname = os.path.join(appDataDir, "config.ssdf")
    if os.path.isfile(fname):
        try:
            userConfig = ssdf.load(fname)
            replaceFields(config, userConfig)
        except Exception:
            t = 'Error while reading config file %r, maybe its corrupt?'
            print(t % fname)
            raise
</t>
<t tx="ekr.20190812072047.120">def _addWordToBuffer(self, word):
    self._wordBuffer.append(word)
    self._charsInBuffer += len(word) + 1 # add one for space
</t>
<t tx="ekr.20190812072047.121">def _flush(self):
    if self._wordBuffer:
        self._lines2.append(self._prefixString() + ' '.join(self._wordBuffer))
    self._wordBuffer, self._charsInBuffer = [], -1
</t>
<t tx="ekr.20190812072047.122">def _addNewParagraph(self):
    # Flush remaining words
    self._flush()
    # Create empty line
    prefix = self._currentPrefix or ''
    prefix = ' ' * len(prefix)
    self._lines2.append(prefix)
    # Allow new prefix
    self._currentPrefix = None
</t>
<t tx="ekr.20190812072047.123">def _popLine(self):
    """ Pop a line from the input. Examine how it starts and convert it
    to words.
    """

    # Pop line
    try:
        line = self._lines1.pop(0)
    except IndexError:
        raise StopIteration()

    # Strip the line
    strippedline1 = line.lstrip()
    strippedline2 = line.lstrip(' \t#*')

    # Analyze this line (how does it start?)
    if not strippedline1:
        self._addNewParagraph()
        return
    elif strippedline1.startswith('* '):
        self._flush()
        indent = len(line) - len(strippedline1)
        linePrefix = line[:indent]
        self._pendingPrefix = linePrefix + '* '
        self._currentPrefix = linePrefix + '  '
    else:
        # Hey, an actual line! Determine prefix
        indent = len(line) - len(strippedline1)
        linePrefix = line[:indent]
        # Check comments
        if strippedline1.startswith('#'):
            linePrefix += '# '
        # What to do now?
        if linePrefix != self._currentPrefix:
            self._flush()
            self._currentPrefix = linePrefix

    # Process words one by one...
    for word in strippedline2.split(' '):
        self._addWordToBuffer(word)
        currentLineWidth = self._charsInBuffer + len(self._currentPrefix)

        if currentLineWidth &lt; self.lw:
            # Not enough words in buffer yet
            pass
        elif len(self._wordBuffer) &gt; 1:
            # Enough words to compose a line
            marginWith = currentLineWidth - self.lw
            marginWithout = self.lw - (currentLineWidth - len(word))
            if marginWith &lt; marginWithout and marginWith &lt; self.margin:
                # add all buffered words
                self._flush()
            else:
                # add all buffered words (except last)
                self._wordBuffer.pop(-1)
                self._flush()
                self._addWordToBuffer(word)
        else:
            # This single word covers more than one line
            self._flush()
</t>
<t tx="ekr.20190812072047.124">@path pyzo/codeeditor/
#!/usr/bin/env python
# -*- coding: utf-8 -*-
""" This script runs a test for the code editor component.
"""

@others
if __name__=='__main__':

    app = QtWidgets.QApplication([])

    # Create editor instance
    e = CodeEditor(highlightCurrentLine = True, longLineIndicatorPosition = 20,
        showIndentationGuides = True, showWhitespace = True,
        showLineEndings = True, wrap = True, showLineNumbers = True)

    QtWidgets.QShortcut(QtGui.QKeySequence("F1"), e).activated.connect(e.autocompleteShow)
    QtWidgets.QShortcut(QtGui.QKeySequence("F2"), e).activated.connect(e.autocompleteCancel)
    QtWidgets.QShortcut(QtGui.QKeySequence("F3"), e).activated.connect(lambda: e.calltipShow(0, 'test(foo, bar)'))
    QtWidgets.QShortcut(QtGui.QKeySequence("Shift+Tab"), e).activated.connect(e.dedentSelection) # Shift + Tab

    #TODO: somehow these shortcuts don't work in this test-app, but they do in
    # pyzo. May have something to do with overriding slots of Qt-native objects?
    QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+C"), e).activated.connect(e.copy)
    QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+X"), e).activated.connect(e.cut)
    QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+V"), e).activated.connect(e.paste)
    QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+Shift+V"), e).activated.connect(e.pasteAndSelect)
    QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+Z"), e).activated.connect(e.undo)
    QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+Y"), e).activated.connect(e.redo)

    e.setPlainText("foo(bar)\nfor bar in range(5):\n  print bar\n" +
                    "\nclass aap:\n  def monkey(self):\n    pass\n\n")

    # Run application
    e.show()
    s=QtWidgets.QSplitter()
    s.addWidget(e)
    s.addWidget(QtWidgets.QLabel('test'))
    s.show()
    app.exec_()
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072047.125">import os, sys
from qt import QtGui, QtCore, QtWidgets
Qt = QtCore.Qt

## Go up one directory and then import the codeeditor package

os.chdir('..')
sys.path.insert(0,'.')
from codeeditor import CodeEditor
</t>
<t tx="ekr.20190812072047.126">@path pyzo/codeeditor/
# -*- coding: utf-8 -*-
# flake8: noqa
@nopyflakes
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072047.127">""" CodeEditor
A full featured code editor component based on QPlainTextEdit.
"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('IMPORT pyzo.codeeditor')
except Exception:
    leo_g = None
from .manager import Manager
from .base import CodeEditorBase

from .extensions.appearance import (
    HighlightMatchingBracket,
    HighlightMatchingOccurrences,
    HighlightCurrentLine,
    FullUnderlines,
    IndentationGuides,
    CodeFolding,
    LongLineIndicator,
    ShowWhitespace,
    ShowLineEndings,
    Wrap,
    LineNumbers,
    SyntaxHighlighting,
    BreakPoints,
)
from .extensions.behaviour import (
    Indentation,
    HomeKey,
    EndKey,
    NumpadPeriodKey,
    AutoIndent,
    PythonAutoIndent,
    SmartCopyAndPaste,
    MoveLinesUpDown,
    ScrollWithUpDownKeys,
    AutoCloseQuotesAndBrackets,
)
from .extensions.autocompletion import AutoCompletion
from .extensions.calltip import Calltip

# Order of superclasses: first the extensions, then CodeEditorBase
# The first superclass is the first extension that gets to handle each key and
# the first to receive paint events.

</t>
<t tx="ekr.20190812072047.128">class CodeEditor( # tag:CodeEditor
    HighlightCurrentLine,
    HighlightMatchingOccurrences,
    HighlightMatchingBracket,
    FullUnderlines,
    IndentationGuides,
    CodeFolding,
    LongLineIndicator,
    ShowWhitespace,
    ShowLineEndings,
    Wrap,
    BreakPoints,
    LineNumbers,

    AutoCompletion, #Escape: first remove autocompletion,
    Calltip,               #then calltip

    Indentation,
    MoveLinesUpDown,
    ScrollWithUpDownKeys,
    HomeKey,
    EndKey,
    NumpadPeriodKey,

    AutoIndent,
    PythonAutoIndent,
    AutoCloseQuotesAndBrackets,
    SyntaxHighlighting,

    SmartCopyAndPaste, # overrides cut(), copy(), paste()

    CodeEditorBase, #CodeEditorBase must be the last one in the list

    ):
    """
    CodeEditor with all the extensions
    """
    pass
</t>
<t tx="ekr.20190812072047.13">def saveConfig():
    """ saveConfig()
    Save all configureations to file.
    """

    # Let the editorStack save its state
    if editors:
        editors.saveEditorState()

    # Let the main window save its state
    if main:
        main.saveWindowState()

    # Store config
    if _saveConfigFile:
        ssdf.save( os.path.join(appDataDir, "config.ssdf"), config )
</t>
<t tx="ekr.20190812072047.130"></t>
<t tx="ekr.20190812072047.131">@path pyzo/codeeditor/extensions/
# -*- coding: utf-8 -*-
"""
Code editor extensions that change its appearance
"""

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072047.132">from ..qt import QtGui,QtCore, QtWidgets
Qt = QtCore.Qt

from ..misc import ce_option
from ..manager import Manager

# todo: what about calling all extensions. CE_HighlightCurrentLine,
# or EXT_HighlightcurrentLine?

from ..parsers.tokens import ParenthesisToken
import enum
</t>
<t tx="ekr.20190812072047.133">class HighlightMatchingOccurrences(object): # tag:CodeEditor

    # Register style element
    _styleElements = [  (   'Editor.Highlight matching occurrences',
                            'The background color to highlight matching occurrences of the currently selected word.',
                            'back:#fdfda3',
                        ) ]

    @others
</t>
<t tx="ekr.20190812072047.134">def highlightMatchingOccurrences(self):
    """ highlightMatchingOccurrences()

    Get whether to highlight matching occurrences.

    """
    return self.__highlightMatchingOccurrences
</t>
<t tx="ekr.20190812072047.135">@ce_option(True)
def setHighlightMatchingOccurrences(self,value):
    """ setHighlightMatchingOccurrences(value)

    Set whether to highlight matching occurrences.

    """
    self.__highlightMatchingOccurrences = bool(value)
    self.viewport().update()
</t>
<t tx="ekr.20190812072047.136">def paintEvent(self, event):
    """ paintEvent(event)

    If there is a current selection, and the selected text is a valid Python
    identifier (no whitespace, starts with a letter), then highlight all the
    matching occurrences of the selected text in the current view.

    Paints behinds its super().

    """
    cursor = self.textCursor()
    if self.__highlightMatchingOccurrences and cursor.hasSelection():
        text = cursor.selectedText()
        if text.isidentifier():
            self._doHighlight(text)

    super(HighlightMatchingOccurrences, self).paintEvent(event)
</t>
<t tx="ekr.20190812072047.137">def _doHighlight(self, text):
    # make cursor at the beginning of the first visible block
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    doc = self.document()

    color = self.getStyleElementFormat('editor.highlightMatchingOccurrences').back
    painter = QtGui.QPainter()
    painter.begin(self.viewport())
    painter.setBrush(color)
    painter.setPen(color.darker(110))

    # find occurrences
    for i in range(500):
        cursor = doc.find(text, cursor,
            doc.FindCaseSensitively | doc.FindWholeWords)
        if cursor is None or cursor.isNull():
            # no more matches
            break

        # don't highlight the actual selection
        if cursor == self.textCursor():
            continue

        endRect = self.cursorRect(cursor)
        if endRect.bottom() &gt; self.height():
            # rest of document is not visible, don't bother highlighting
            break

        cursor.setPosition(min(cursor.position(), cursor.anchor()))
        startRect = self.cursorRect(cursor)
        width = endRect.left() - startRect.left()
        painter.drawRect(startRect.left(), startRect.top(), width,
            startRect.height())

        # move to end of word again, otherwise we never advance in the doc
        cursor.movePosition(cursor.EndOfWord)
    else:
        print('Matching selection highlighting did not break')

    painter.end()
</t>
<t tx="ekr.20190812072047.138">class _ParenNotFound(Exception) :
    pass
</t>
<t tx="ekr.20190812072047.139">class _ParenIterator :
    """ Iterates in given direction over parentheses in the document.
    Uses the stored token-list of the blocks.
    Iteration gives both a parenthesis and its global position."""
    @others
</t>
<t tx="ekr.20190812072047.14">def start():
    """ Run Pyzo.
    """
    if leo_g: leo_g.pr('BEGIN pyzo.start: sys.argv:', sys.argv)

    # Do some imports
    from pyzo.core import pyzoLogging  # noqa - to start logging asap
    assert pyzoLogging
    from pyzo.core.main import MainWindow

    # Apply users' preferences w.r.t. date representation etc
    # this is required for e.g. strftime("%c")
    # Just using '' does not seem to work on OSX. Thus
    # this odd loop.
    #locale.setlocale(locale.LC_ALL, "")
    for x in ('', 'C', 'en_US', 'en_US.utf8', 'en_US.UTF-8'):
        try:
            locale.setlocale(locale.LC_ALL, x)
            break
        except locale.Error:
            pass

    # Set to be aware of the systems native colors, fonts, etc.
    QtWidgets.QApplication.setDesktopSettingsAware(True)
    
    # Instantiate the application.
    QtWidgets.qApp = MyApp(sys.argv)  # QtWidgets.QApplication([])

    # Choose language, get locale
    appLocale = setLanguage(config.settings.language)

    # Create main window, using the selected locale
    MainWindow(None, appLocale)

    # Enter the main loop
    if leo_g: leo_g.pr('END pyzo.start\n')
    QtWidgets.qApp.exec_()
</t>
<t tx="ekr.20190812072047.140">def __init__(self, cursor, direction) :
    self.cur_block = cursor.block()
    self.cur_tokens = self._getParenTokens()
    self.direction = direction
    # We need to know where we start in the current token list
    k = 0
    try :
        while self.cur_tokens[k].end != cursor.positionInBlock() :
            k += 1
        self.cur_pos = k
    except IndexError :
        # If the parenthesis cannot be found, it means that it is not inluded
        # in any token, ie. it is part of a string or comment
        raise _ParenNotFound
</t>
<t tx="ekr.20190812072047.141">def _getParenTokens(self) :
    try:
        return list(filter(lambda x : isinstance(x, ParenthesisToken), self.cur_block.userData().tokens))
    except AttributeError:
        return []  # can be a piece of text that we do not tokenize (e.g. in shell)
</t>
<t tx="ekr.20190812072047.142">def __iter__(self) :
    return self
</t>
<t tx="ekr.20190812072047.143">def __next__(self) :
    self.cur_pos += self.direction
    while self.cur_pos &gt;= len(self.cur_tokens) or self.cur_pos &lt; 0 :
        if self.direction == 1 :
            self.cur_block = self.cur_block.next()
        else :
            self.cur_block = self.cur_block.previous()
        if not self.cur_block.isValid() :
            raise StopIteration
        self.cur_tokens = self._getParenTokens()
        if self.direction == 1 :
            self.cur_pos = 0
        else :
            self.cur_pos = len(self.cur_tokens) - 1
    return self.cur_tokens[self.cur_pos]._style, self.cur_block.position()+self.cur_tokens[self.cur_pos].end
</t>
<t tx="ekr.20190812072047.144">class _PlainTextParenIterator :
    """ Iterates in given direction over parentheses in the document.
    To be used when there is no parser.
    Iteration gives both a parenthesis and its global position."""
    @others
</t>
<t tx="ekr.20190812072047.145">def __init__(self, cursor, direction) :
    self.fulltext = cursor.document().toPlainText()
    self.position = cursor.position() - 1
    self.direction = direction
</t>
<t tx="ekr.20190812072047.146">def __iter__(self) :
    return self
</t>
<t tx="ekr.20190812072047.147">def __next__(self) :
    self.position += self.direction
    try :
        while self.fulltext[self.position] not in '([{)]}' :
            self.position += self.direction
            if self.position &lt; 0 :
                raise StopIteration
    except IndexError :
        raise StopIteration
    return self.fulltext[self.position], self.position + 1
</t>
<t tx="ekr.20190812072047.148">class _MatchStatus(enum.Enum) :
    NoMatch = 0
    Match = 1
    MisMatch = 2
</t>
<t tx="ekr.20190812072047.149">class _MatchResult :
    @others
</t>
<t tx="ekr.20190812072047.15">@path pyzo/
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""EKR:change-startup. Add leo/plugins/pyzo to sys.path and import pyzo."""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo.__main__.py')
except Exception:
    leo_g.pr('FAIL: import leo_g')
    leo_g = None
    
# import os
# import sys

# EKR:change-startup. We *are* running a script.
# However, it's probably already too late to do this.
    # thisDir = os.path.abspath(os.path.dirname(__file__))
    # sys.path.insert(0, os.path.split(thisDir)[0])
try:
    import pyzo
except ImportError:
    raise ImportError('Could not import leo/plugins/pyzo.') # EKR:change-message.

@others
###
    # if __name__ == '__main__':
        # main()
pyzo.start_pyzo_in_leo() # EKR: change-startup.
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072047.150">def __init__(self, status, corresponding = None, offending = None) :
    self.status = status
    self.corresponding = corresponding
    self.offending = offending
</t>
<t tx="ekr.20190812072047.151">class HighlightMatchingBracket(object): # tag:CodeEditor

    # Register style element
    _styleElements = [  (   'Editor.Highlight matching bracket',
                            'The background color to highlight matching brackets.',
                            'back:#ccc',
                        ),
                        (   'Editor.Highlight unmatched bracket',
                            'The background color to highlight unmatched brackets.',
                            'back:#F7BE81',
                        ),
                        (   'Editor.Highlight mismatching bracket',
                            'The background color to highlight mismatching brackets.',
                            'back:#F7819F',
                        )
                        ]

    @others
</t>
<t tx="ekr.20190812072047.152">def highlightMatchingBracket(self):
    """ highlightMatchingBracket()

    Get whether to highlight matching brackets.

    """
    return self.__highlightMatchingBracket
</t>
<t tx="ekr.20190812072047.153">def highlightMisMatchingBracket(self):
    """ highlightMisMatchingBracket()

    Get whether to highlight mismatching brackets.

    """
    return self.__highlightMisMatchingBracket
</t>
<t tx="ekr.20190812072047.154">def paintEvent(self, event):
    """ paintEvent(event)

    If the current cursor is positioned to the right of a bracket ()[]{},
    look for a matching one, and, if found, draw a highlighting rectangle
    around both brackets of the pair.

    Paints behinds its super().

    """
    if not self.__highlightMatchingBracket:
        super(HighlightMatchingBracket, self).paintEvent(event)
        return

    cursor = QtGui.QTextCursor(self.textCursor())
    if cursor.atBlockStart() :
        cursor.movePosition(cursor.Right)
        movedRight = True
    else :
        movedRight = False
    text = cursor.block().text()
    pos = cursor.positionInBlock() - 1

    if len(text) &gt; pos and len(text) &gt; 0:
        # get the character to the left of the cursor
        char = text[pos]

        if not movedRight and char not in '()[]{}' and len(text) &gt; pos+1 :
            # no brace to the left of cursor; try to the right
            cursor.movePosition(cursor.Right)
            char = text[pos+1]

        if char in '()[]{}':
            doc = cursor.document()
            try :
                match_res = self._findMatchingBracket(char, cursor)
                fm = QtGui.QFontMetrics(doc.defaultFont())
                width = fm.width(char) # assumes that both paren have the same width
                painter = QtGui.QPainter()
                painter.begin(self.viewport())
                if match_res.status == _MatchStatus.NoMatch :
                    self._highlightSingleChar(painter, cursor, width, 'editor.highlightUnmatchedBracket')
                elif match_res.status == _MatchStatus.Match :
                    self._highlightSingleChar(painter, cursor, width, 'editor.highlightMatchingBracket')
                    self._highlightSingleChar(painter, self._cursorAt(doc, match_res.corresponding), width, 'editor.highlightMatchingBracket')
                else : # this is a mismatch
                    if cursor.position() != match_res.offending or not self.highlightMisMatchingBracket() :
                        self._highlightSingleChar(painter, cursor, width, 'editor.highlightUnmatchedBracket')
                    if self.highlightMisMatchingBracket() :
                        self._highlightSingleChar(painter, self._cursorAt(doc, match_res.corresponding), width, 'editor.highlightMisMatchingBracket')
                        self._highlightSingleChar(painter, self._cursorAt(doc, match_res.offending), width, 'editor.highlightMisMatchingBracket')

                painter.end()
            except _ParenNotFound:
                # is raised when current parenthesis is not
                # found in its line token list, meaning it is in a string literal
                pass

    super(HighlightMatchingBracket, self).paintEvent(event)
</t>
<t tx="ekr.20190812072047.155">def _highlightSingleChar(self, painter, cursor, width, colorname):
        """ _highlightSingleChar(painter, cursor, width, colorname)

        Draws a highlighting rectangle around the single character to the
        left of the specified cursor.

        """
        cursor_rect = self.cursorRect(cursor)
        top = cursor_rect.top()
        left = cursor_rect.left() - width
        height = cursor_rect.bottom() - top + 1
        color = self.getStyleElementFormat(colorname).back
        painter.setBrush(color)
        painter.setPen(color.darker(110))
        painter.drawRect(QtCore.QRect(left, top, width, height))

_matchingBrackets = {'(':')', '[':']', '{':'}', ')':'(', ']':'[', '}':'{'}
</t>
<t tx="ekr.20190812072047.156">def _findMatchingBracket(self, char, cursor):
    """ _findMatchingBracket(char, cursor)

    Find a bracket that matches the specified char in the specified document.
    Return a _MatchResult object indicating whether this succeded and the
    positions of the parentheses causing this result.

    """
    if char in ')]}':
        direction = -1
        stacking = ')]}'
        unstacking = '([{'
    elif char in '([{':
        direction = 1
        stacking = '([{'
        unstacking = ')]}'
    else:
        raise ValueError('invalid bracket character: ' + char)

    stacked_paren = [(char, cursor.position())] # using a Python list as a stack
    # stack not empty because the _ParenIterator will not give back
    # the parenthesis we're matching
    our_iterator = _ParenIterator if self.parser() is not None and self.parser().name() != "" else _PlainTextParenIterator
    for (paren, pos) in our_iterator(cursor, direction) :
        if paren in stacking :
            stacked_paren.append((paren, pos))
        elif paren in unstacking :
            if self._matchingBrackets[stacked_paren[-1][0]] != paren :
                return _MatchResult(_MatchStatus.MisMatch, pos, stacked_paren[-1][1])
            else :
                stacked_paren.pop()

        if len(stacked_paren) == 0 :
            # we've found our match
            return _MatchResult(_MatchStatus.Match, pos)
    return _MatchResult(_MatchStatus.NoMatch)
</t>
<t tx="ekr.20190812072047.157">def _cursorAt(self, doc, pos) :
    new_cursor = QtGui.QTextCursor(doc)
    new_cursor.setPosition(pos)
    return new_cursor
</t>
<t tx="ekr.20190812072047.158">@ce_option(True)
def setHighlightMatchingBracket(self,value):
    """ setHighlightMatchingBracket(value)

    Set whether to highlight matching brackets.

    """
    self.__highlightMatchingBracket = bool(value)
    self.viewport().update()
</t>
<t tx="ekr.20190812072047.159">@ce_option(True)
def setHighlightMisMatchingBracket(self,value):
    """ setHighlightMisMatchingBracket(value)

    Set whether to highlight mismatching brackets.

    """
    self.__highlightMisMatchingBracket = bool(value)
    self.viewport().update()
</t>
<t tx="ekr.20190812072047.160">class HighlightCurrentLine(object): # tag:CodeEditor
    """
    Highlight the current line
    """

    # Register style element
    _styleElements = [  (   'Editor.Highlight current line',
                            'The background color of the current line highlight.',
                            'back:#ffff99',
                        ) ]

    @others
</t>
<t tx="ekr.20190812072047.161">def highlightCurrentLine(self):
    """ highlightCurrentLine()

    Get whether to highlight the current line.

    """
    return self.__highlightCurrentLine
</t>
<t tx="ekr.20190812072047.162">@ce_option(True)
def setHighlightCurrentLine(self,value):
    """ setHighlightCurrentLine(value)

    Set whether to highlight the current line.

    """
    self.__highlightCurrentLine = bool(value)
    self.viewport().update()
</t>
<t tx="ekr.20190812072047.163">def paintEvent(self,event):
    """ paintEvent(event)

    Paints a rectangle spanning the current block (in case of line wrapping, this
    means multiple lines)

    Paints behind its super()
    """
    if not self.highlightCurrentLine():
        super(HighlightCurrentLine, self).paintEvent(event)
        return

    # Get color
    color = self.getStyleElementFormat('editor.highlightCurrentLine').back

    #Find the top of the current block, and the height
    cursor = self.textCursor()
    cursor.movePosition(cursor.StartOfBlock)
    top = self.cursorRect(cursor).top()
    cursor.movePosition(cursor.EndOfBlock)
    height = self.cursorRect(cursor).bottom() - top + 1

    margin = self.document().documentMargin()
    painter = QtGui.QPainter()
    painter.begin(self.viewport())
    painter.fillRect(QtCore.QRect(margin, top,
        self.viewport().width() - 2*margin, height),
        color)
    painter.end()

    super(HighlightCurrentLine, self).paintEvent(event)

    # for debugging paint events
    #if 'log' not in self.__class__.__name__.lower():
    #    print(height, event.rect().width())
</t>
<t tx="ekr.20190812072047.164">class IndentationGuides(object): # tag:CodeEditor

    # Register style element
    _styleElements = [  (   'Editor.Indentation guides',
                            'The color and style of the indentation guides.',
                            'fore:#DDF,linestyle:solid',
                        ) ]

    @others
</t>
<t tx="ekr.20190812072047.165">def showIndentationGuides(self):
    """ showIndentationGuides()

    Get whether to show indentation guides.

    """
    return self.__showIndentationGuides
</t>
<t tx="ekr.20190812072047.166">@ce_option(True)
def setShowIndentationGuides(self, value):
    """ setShowIndentationGuides(value)

    Set whether to show indentation guides.

    """
    self.__showIndentationGuides = bool(value)
    self.viewport().update()
</t>
<t tx="ekr.20190812072047.167">def paintEvent(self,event):
    """ paintEvent(event)

    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    super(IndentationGuides, self).paintEvent(event)

    if not self.showIndentationGuides():
        return

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    # Get multiplication factor and indent width
    indentWidth = self.indentWidth()
    if self.indentUsingSpaces():
        factor = 1
    else:
        factor = indentWidth

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    format = self.getStyleElementFormat('editor.IndentationGuides')
    pen = QtGui.QPen(format.fore)
    pen.setStyle(format.linestyle)
    painter.setPen(pen)
    offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        bd = cursor.block().userData()
        if bd and hasattr(bd, 'indentation') and bd.indentation:
            for x in range(indentWidth, bd.indentation * factor, indentWidth):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)

    # Done
    painter.end()
</t>
<t tx="ekr.20190812072047.168">class FullUnderlines(object): # tag:CodeEditor

    @others
</t>
<t tx="ekr.20190812072047.169">def paintEvent(self,event):
    """ paintEvent(event)

    Paint a horizontal line for the blocks for which there is a
    syntax format that has underline:full. Whether this is the case
    is stored at the blocks user data.

    """
    super(FullUnderlines, self).paintEvent(event)

    painter = QtGui.QPainter()
    painter.begin(self.viewport())

    margin = self.document().documentMargin()
    w = self.viewport().width()

    def paintUnderline(cursor):
        y = self.cursorRect(cursor).bottom()

        bd = cursor.block().userData()
        try:
            fullUnderlineFormat = bd.fullUnderlineFormat
        except AttributeError:
            pass  # fullUnderlineFormat may not be an attribute
        else:
            if fullUnderlineFormat is not None:
                # Apply pen
                pen = QtGui.QPen(fullUnderlineFormat.fore)
                pen.setStyle(fullUnderlineFormat.linestyle)
                painter.setPen(pen)
                # Paint
                painter.drawLine(QtCore.QLine(margin, y, w - 2*margin, y))

    self.doForVisibleBlocks(paintUnderline)

    painter.end()
</t>
<t tx="ekr.20190812072047.17">def main():
    pyzo.start()
        # Defined in pyzo.__init__.
</t>
<t tx="ekr.20190812072047.170">class CodeFolding(object): # tag:CodeEditor
    @others
</t>
<t tx="ekr.20190812072047.171">def paintEvent(self,event):
    """ paintEvent(event)

    """
    super(CodeFolding, self).paintEvent(event)

    return # Code folding code is not yet complete

    painter = QtGui.QPainter()
    painter.begin(self.viewport())

    margin = self.document().documentMargin()

    def paintCodeFolders(cursor):
        y = self.cursorRect(cursor).top()
        h = self.cursorRect(cursor).height()
        rect = QtCore.QRect(margin, y, h, h)
        text = cursor.block().text()
        if text.rstrip().endswith(':'):
            painter.drawRect(rect)
            painter.drawText(rect, QtCore.Qt.AlignVCenter | QtCore.Qt.AlignHCenter, "-")
            # Apply pen

            # Paint
            #painter.drawLine(QtCore.QLine(margin, y, w - 2*margin, y))

    self.doForVisibleBlocks(paintCodeFolders)

    painter.end()
</t>
<t tx="ekr.20190812072047.172">class LongLineIndicator(object): # tag:CodeEditor

    # Register style element
    _styleElements = [  (   'Editor.Long line indicator',
                            'The color and style of the long line indicator.',
                            'fore:#BBB,linestyle:solid',
                        ) ]

    @others
</t>
<t tx="ekr.20190812072047.173">def longLineIndicatorPosition(self):
    """ longLineIndicatorPosition()

    Get the position of the long line indicator (aka edge column).
    A value of 0 or smaller means that no indicator is shown.

    """
    return self.__longLineIndicatorPosition
</t>
<t tx="ekr.20190812072047.174">@ce_option(80)
def setLongLineIndicatorPosition(self, value):
    """ setLongLineIndicatorPosition(value)

    Set the position of the long line indicator (aka edge column).
    A value of 0 or smaller means that no indicator is shown.

    """
    self.__longLineIndicatorPosition = int(value)
    self.viewport().update()
</t>
<t tx="ekr.20190812072047.175">def paintEvent(self, event):
    """ paintEvent(event)

    Paint the long line indicator. Paints behind its super()
    """
    if self.longLineIndicatorPosition()&lt;=0:
        super(LongLineIndicator, self).paintEvent(event)
        return

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    # Get position of long line
    fm = self.fontMetrics()
    # width of ('i'*length) not length * (width of 'i') b/c of
    # font kerning and rounding
    x = fm.width('i' * self.longLineIndicatorPosition())
    x += doc.documentMargin() + self.contentOffset().x()
    x += 1 # Move it a little next to the cursor

    # Prepate painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    format = self.getStyleElementFormat('editor.LongLineIndicator')
    pen = QtGui.QPen(format.fore)
    pen.setStyle(format.linestyle)
    painter.setPen(pen)

    # Draw line and end painter
    painter.drawLine(QtCore.QLine(x, 0, x, viewport.height()) )
    painter.end()

    # Propagate event
    super(LongLineIndicator, self).paintEvent(event)
</t>
<t tx="ekr.20190812072047.176">class ShowWhitespace(object): # tag:CodeEditor

    @others
</t>
<t tx="ekr.20190812072047.177">def showWhitespace(self):
    """Show or hide whitespace markers"""
    option=self.document().defaultTextOption()
    return bool(option.flags() &amp; option.ShowTabsAndSpaces)
</t>
<t tx="ekr.20190812072047.178">@ce_option(False)
def setShowWhitespace(self,value):
    option=self.document().defaultTextOption()
    if value:
        option.setFlags(option.flags() | option.ShowTabsAndSpaces)
    else:
        option.setFlags(option.flags() &amp; ~option.ShowTabsAndSpaces)
    self.document().setDefaultTextOption(option)
</t>
<t tx="ekr.20190812072047.179">class ShowLineEndings(object): # tag:CodeEditor

    @others
</t>
<t tx="ekr.20190812072047.180">@ce_option(False)
def showLineEndings(self):
    """ Get whether line ending markers are shown.
    """
    option=self.document().defaultTextOption()
    return bool(option.flags() &amp; option.ShowLineAndParagraphSeparators)
</t>
<t tx="ekr.20190812072047.181">def setShowLineEndings(self,value):
    option=self.document().defaultTextOption()
    if value:
        option.setFlags(option.flags() | option.ShowLineAndParagraphSeparators)
    else:
        option.setFlags(option.flags() &amp; ~option.ShowLineAndParagraphSeparators)
    self.document().setDefaultTextOption(option)
</t>
<t tx="ekr.20190812072047.182">class LineNumbers(object):  # tag:CodeEditor

    # Margin on both side of the line numbers
    _LineNumberAreaMargin = 3

    # Register style element
    _styleElements = [  (   'Editor.Line numbers',
                            'The text- and background-color of the line numbers.',
                            'fore:#222,back:#DDD',
                        ) ]

    @others
</t>
<t tx="ekr.20190812072047.183">class __LineNumberArea(QtWidgets.QWidget):
    """ This is the widget reponsible for drawing the line numbers.
    """

    @others
</t>
<t tx="ekr.20190812072047.184">def __init__(self, codeEditor):
    QtWidgets.QWidget.__init__(self, codeEditor)
    self.setCursor(QtCore.Qt.PointingHandCursor)
    self._pressedY = None
    self._lineNrChoser = None
</t>
<t tx="ekr.20190812072047.185">def _getY(self, pos):
    tmp = self.mapToGlobal(pos)
    return self.parent().viewport().mapFromGlobal(tmp).y()
</t>
<t tx="ekr.20190812072047.186">def mousePressEvent(self, event):
    self._pressedY = self._getY(event.pos())
</t>
<t tx="ekr.20190812072047.187">def mouseReleaseEvent(self, event):
    self._handleWholeBlockSelection( self._getY(event.pos()) )
</t>
<t tx="ekr.20190812072047.188">def mouseMoveEvent(self, event):
    self._handleWholeBlockSelection( self._getY(event.pos()) )
</t>
<t tx="ekr.20190812072047.189">def _handleWholeBlockSelection(self, y2):
    # Get y1 and sort (y1, y2)
    y1 = self._pressedY
    if y1 is None: y1 = y2
    y1, y2 = min(y1, y2), max(y1, y2)

    # Get cursor and two cursors corresponding to selected blocks
    editor = self.parent()
    cursor = editor.textCursor()
    c1 = editor.cursorForPosition(QtCore.QPoint(0,y1))
    c2 = editor.cursorForPosition(QtCore.QPoint(0,y2))

    # Make these two cursors select the whole block
    c1.movePosition(c1.StartOfBlock, c1.MoveAnchor)
    c2.movePosition(c2.EndOfBlock, c2.MoveAnchor)

    # Apply selection
    cursor.setPosition(c1.position(), cursor.MoveAnchor)
    cursor.setPosition(c2.position(), cursor.KeepAnchor)
    editor.setTextCursor(cursor)
</t>
<t tx="ekr.20190812072047.19"></t>
<t tx="ekr.20190812072047.190">def mouseDoubleClickEvent(self, event):
    self.showLineNumberChoser()
</t>
<t tx="ekr.20190812072047.191">def showLineNumberChoser(self):
    # Create line number choser if needed
    if self._lineNrChoser is None:
        self._lineNrChoser = LineNumbers.LineNumberChoser(self.parent())
    # Get editor and cursor
    editor = self.parent()
    cursor = editor.textCursor()
    # Get (x,y) pos and apply
    x, y = self.width()+4, editor.cursorRect(cursor).y()
    self._lineNrChoser.move(QtCore.QPoint(x,y))
    # Show/reset line number choser
    self._lineNrChoser.reset(cursor.blockNumber()+1)
</t>
<t tx="ekr.20190812072047.192">def paintEvent(self, event):
    editor = self.parent()

    if not editor.showLineNumbers():
        return

    # Get doc and viewport
    viewport = editor.viewport()

    # Get format and margin
    format = editor.getStyleElementFormat('editor.LineNumbers')
    margin = editor._LineNumberAreaMargin

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(self)

    # Get which part to paint. Just do all to avoid glitches
    w = editor.getLineNumberAreaWidth()
    y1, y2 = 0, editor.height()
    #y1, y2 = event.rect().top()-10, event.rect().bottom()+10

    # Get offset
    tmp = self.mapToGlobal(QtCore.QPoint(0,0))
    offset = viewport.mapFromGlobal(tmp).y()

    #Draw the background
    painter.fillRect(QtCore.QRect(0, y1, w, y2), format.back)

    # Get cursor
    cursor = editor.cursorForPosition(QtCore.QPoint(0,y1))

    # Prepare fonts
    font1 = editor.font()
    font2 = editor.font()
    font2.setBold(True)
    currentBlockNumber = editor.textCursor().block().blockNumber()

    # Init painter with font and color
    painter.setFont(font1)
    painter.setPen(format.fore)

    #Repainting always starts at the first block in the viewport,
    #regardless of the event.rect().y(). Just to keep it simple
    while True:
        blockNumber = cursor.block().blockNumber()

        y = editor.cursorRect(cursor).y()

        # Set font to bold if line number is the current
        if blockNumber == currentBlockNumber:
            painter.setFont(font2)

        painter.drawText(0, y-offset, w-margin, 50,
            Qt.AlignRight, str(blockNumber+1))

        # Set font back
        if blockNumber == currentBlockNumber:
            painter.setFont(font1)

        if y&gt;y2:
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text

        cursor.movePosition(cursor.NextBlock)

    # Done
    painter.end()
</t>
<t tx="ekr.20190812072047.193">class LineNumberChoser(QtWidgets.QSpinBox):
    @others
</t>
<t tx="ekr.20190812072047.194">def __init__(self, parent):
    QtWidgets.QSpinBox.__init__(self, parent)
    self._editor = parent

    ss = "QSpinBox { border: 2px solid #789; border-radius: 3px; padding: 4px; }"
    self.setStyleSheet(ss)

    self.setPrefix('Go to line: ')
    self.setAccelerated(True)
    self.setButtonSymbols(self.NoButtons)
    self.setCorrectionMode(self.CorrectToNearestValue)

    # Signal for when value changes, and flag to disbale it once
    self._ignoreSignalOnceFlag = False
    self.valueChanged.connect(self.onValueChanged)
</t>
<t tx="ekr.20190812072047.195">def reset(self, currentLineNumber):
    # Set value to (given) current line number
    self._ignoreSignalOnceFlag = True
    self.setRange(1, self._editor.blockCount())
    self.setValue(currentLineNumber)
    # Select text and focus so that the user can simply start typing
    self.selectAll()
    self.setFocus()
    # Make visible
    self.show()
    self.raise_()
</t>
<t tx="ekr.20190812072047.196">def focusOutEvent(self, event):
    self.hide()
</t>
<t tx="ekr.20190812072047.197">def keyPressEvent(self, event):
    if event.key() in [QtCore.Qt.Key_Escape, QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return]:
        self._editor.setFocus() # Moves focus away, thus hiding self
    else:
        QtWidgets.QSpinBox.keyPressEvent(self, event)
</t>
<t tx="ekr.20190812072047.198">def onValueChanged(self, nr):
    if self._ignoreSignalOnceFlag:
        self._ignoreSignalOnceFlag = False
    else:
        self._editor.gotoLine(nr)
</t>
<t tx="ekr.20190812072047.199">def __init__(self, *args, **kwds):
    self.__lineNumberArea = None
    super(LineNumbers, self).__init__(*args, **kwds)
    # Create widget that draws the line numbers
    self.__lineNumberArea = self.__LineNumberArea(self)
    # Issue an update when the font or amount of line numbers changes
    self.blockCountChanged.connect(self.__onBlockCountChanged)
    self.fontChanged.connect(self.__onBlockCountChanged)
    self.__onBlockCountChanged()
    self.addLeftMargin(LineNumbers, self.getLineNumberAreaWidth)
</t>
<t tx="ekr.20190812072047.2"># These are the actual pyzo sources,
# unmodified except for traces added, and @nopyflakes directives.

</t>
<t tx="ekr.20190812072047.20">@path pyzo/codeeditor/
# -*- coding: utf-8 -*-
@nopyflakes
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072047.200">def gotoLinePopup(self):
    """ Popup the little widget to quickly goto a certain line.
    Can also be achieved by double-clicking the line number area.
    """
    self.__lineNumberArea.showLineNumberChoser()
</t>
<t tx="ekr.20190812072047.201">def showLineNumbers(self):
    return self.__showLineNumbers
</t>
<t tx="ekr.20190812072047.202">@ce_option(True)
def setShowLineNumbers(self, value):
    self.__showLineNumbers = bool(value)
    # Note that this method is called before the __init__ is finished,
    # so that the __lineNumberArea is not yet created.
    if self.__lineNumberArea:
        if self.__showLineNumbers:
            self.__onBlockCountChanged()
            self.__lineNumberArea.show()
        else:
            self.__lineNumberArea.hide()
        self.updateMargins()
</t>
<t tx="ekr.20190812072047.203">def getLineNumberAreaWidth(self):
    """
    Count the number of lines, compute the length of the longest line number
    (in pixels)
    """
    if not self.__showLineNumbers:
        return 0
    lastLineNumber = self.blockCount()
    margin = self._LineNumberAreaMargin
    return self.fontMetrics().width(str(lastLineNumber)) + 2*margin
</t>
<t tx="ekr.20190812072047.204">def __onBlockCountChanged(self,count = None):
    """
    Update the line number area width. This requires to set the
    viewport margins, so there is space to draw the linenumber area
    """
    if self.__showLineNumbers:
        self.updateMargins()
</t>
<t tx="ekr.20190812072047.205">def resizeEvent(self,event):
    super(LineNumbers, self).resizeEvent(event)

    #On resize, resize the lineNumberArea, too
    rect=self.contentsRect()
    m = self.getLeftMargin(LineNumbers)
    w = self.getLineNumberAreaWidth()
    self.__lineNumberArea.setGeometry(  rect.x()+m, rect.y(),
                                        w, rect.height())
</t>
<t tx="ekr.20190812072047.206">def paintEvent(self,event):
    super(LineNumbers, self).paintEvent(event)
    #On repaint, update the complete line number area
    w = self.getLineNumberAreaWidth()
    self.__lineNumberArea.update(0, 0, w, self.height() )
</t>
<t tx="ekr.20190812072047.207">class BreakPoints(object):  # tag:CodeEditor

    _breakPointWidth = 11  # With of total bar, actual points are smaller

    # Register style element
    _styleElements = [  (   'Editor.BreakPoints',
                            'The fore- and background-color of the breakpoints.',
                            'fore:#F66,back:#dfdfe1',
                        ) ]

    @others
</t>
<t tx="ekr.20190812072047.208">class __BreakPointArea(QtWidgets.QWidget):
    """ This is the widget reponsible for drawing the break points.
    """

    @others
</t>
<t tx="ekr.20190812072047.209">def __init__(self, codeEditor):
    QtWidgets.QWidget.__init__(self, codeEditor)
    self.setCursor(QtCore.Qt.PointingHandCursor)
    self.setMouseTracking(True)
    self._virtualBreakpoint = 0
</t>
<t tx="ekr.20190812072047.21">"""
The base code editor class.

"""

"""
WRITING EXTENSIONS FOR THE CODE EDITOR

The Code Editor extension mechanism works solely based on inheritance.
Extensions can override event handlers (e.g. paintEvent, keyPressEvent). Their
default behaviour should be to call their super() event handler. This way,
events propagate through the extensions following Python's method resolution
order (http://www.python.org/download/releases/2.3/mro/).

A 'fancy' code editor with extensions is created like:

class FancyEditor( Extension1, Extension2, ... CodeEditorBase):
    pass

The order of the extensions does usually matter! If multiple Extensions process
the same key press, the first one has the first chance to consume it.

OVERRIDING __init__

An extensions' __init__ method (if required) should look like this:
class Extension:
    def __init__(self, *args, extensionParam1 = 1, extensionParam2 = 3, **kwds):
        super().__init__(*args, **kwds)
        some_extension_init_stuff()

Note the following points:
 - All parameters have default values
 - The use of *args passes all non-named arguments to its super(), which
   will therefore end up at the QPlainTextEdit constructor. As a consequence,
   the parameters of the exentsion can only be specified as named arguments
 - The use of **kwds ensures that parametes that are not defined by this
   extension, are passed to the next extension(s) in line.
 - The call to super().__init__ is the first thing to do, this ensures that at
   least the CodeEditorBase and QPlainTextEdit, of which the CodeEditorBase is
   derived, are initialized when the initialization of the extension is done

OVERRIDING keyPressEvent

When overriding keyPressEvent, the extension has several options when an event
arrives:
 - Ignore the event
     In this case, call super().keyPressEvent(event) for other extensions or the
     CodeEditorBase to process the event
 - Consume the event
     In order to prevent other next extensions or the CodeEditorBase to react
     on the event, return without calling the super().keyPressEvent
 - Do something based on the event, and do not let the event propagate
     In this case, do whatever action is defined by the extension, and do not
     call the super().keyPressEvent
 - Do something based on the event, and let the event propagate
     In this case, do whatever action is defined by the extension, and do call
     the super().keyEvent

In any case, the keyPressEvent should not return a value (i.e., return None).
Furthermore, an extension may also want to perform some action *after* the
event has been processed by the next extensions and the CodeEditorBase. In this
case, perform that action after calling super().keyPressEvent

OVERRIDING paintEvent

Then overriding the paintEvent, the extension may want to paint either behind or
in front of the CodeEditorBase text. In order to paint behind the text, first
perform the painting, and then call super().paintEvent. In order to paint in
front of the text, first call super().paintEvent, then perform the painting.

As a result, the total paint order is as follows for the example of the
FancyEditor defined above:
- First the extensions that draw behind the text (i.e. paint before calling
  super().paintEvent, in the order Extension1, Extension2, ...
- then the CodeEditorBase, with the text
- then the extensions that draw in front of the text (i.e. call
  super().paintEvent before painting), in the order ..., Extension2, Extension1

OVERRIDING OTHER EVENT HANDLERS

When overriding other event handlers, be sure to call the super()'s event
handler; either before or after your own actions, as appropriate

OTHER ISSUES

In order to avoid namespace clashes among the extensions, take the following
into account:
 - Private members should start with __ to make ensure no clashes will occur
 - Public members / methods should have names that clearly indicate which
   extension they belong to (e.g. not cancel but autocompleteCancel)
 - Arguments of the __init__ method should also have clearly destictive names

"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo/codeeditor/base.py')
except Exception:
    leo_g = None

#
# Do not do this!!! It's way too big a change to the imports.
    # import pyzo

from .qt import QtGui,QtCore, QtWidgets
Qt = QtCore.Qt

from .misc import DEFAULT_OPTION_NAME, DEFAULT_OPTION_NONE, ce_option
from .misc import callLater, ustr
from .manager import Manager
from .highlighter import Highlighter
from .style import StyleElementDescription

</t>
<t tx="ekr.20190812072047.210">def _getY(self, pos):
    tmp = self.mapToGlobal(pos)
    return self.parent().viewport().mapFromGlobal(tmp).y()
</t>
<t tx="ekr.20190812072047.211">def mousePressEvent(self, event):
    self._toggleBreakPoint( self._getY(event.pos()))
</t>
<t tx="ekr.20190812072047.212">def mouseMoveEvent(self, event):
    y = self._getY(event.pos())
    editor = self.parent()
    c1 = editor.cursorForPosition(QtCore.QPoint(0,y))
    self._virtualBreakpoint = c1.blockNumber() + 1
    self.update()
</t>
<t tx="ekr.20190812072047.213">def leaveEvent(self, event):
    self._virtualBreakpoint = 0
    self.update()
</t>
<t tx="ekr.20190812072047.214">def _toggleBreakPoint(self, y):
    # Get breakpoint corresponding to pressed pos
    editor = self.parent()
    c1 = editor.cursorForPosition(QtCore.QPoint(0,y))
    linenr = c1.blockNumber() + 1
    # Toggle
    self.parent().toggleBreakpoint(linenr)
</t>
<t tx="ekr.20190812072047.215">def paintEvent(self, event):
    editor = self.parent()

    if not editor.showBreakPoints():
        return

    # Get format and margin
    format = editor.getStyleElementFormat('editor.breakpoints')
    margin = 1
    w = editor._breakPointWidth
    bulletWidth = w - 2*margin

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(self)

    # Get which part to paint. Just do all to avoid glitches
    y1, y2 = 0, editor.height()

    #Draw the background
    painter.fillRect(QtCore.QRect(0, y1, w, y2), format.back)

    # Get debug indicator and list of sorted breakpoints
    debugBlockIndicator = editor._debugLineIndicator-1
    virtualBreakpoint = self._virtualBreakpoint-1
    blocknumbers = [i-1 for i in sorted(self.parent()._breakPoints)]
    if not (blocknumbers or
            editor._debugLineIndicator or
            editor._debugLineIndicators or
            virtualBreakpoint &gt; 0):
        return

    # Get cursor
    cursor = editor.cursorForPosition(QtCore.QPoint(0,y1))

    # Get start block number and bullet offset in pixels
    startBlockNumber = cursor.block().blockNumber()
    bulletOffset = editor.contentOffset().y() + bulletWidth * 0.25

    # Prepare painter
    painter.setPen(QtGui.QColor('#777'))
    painter.setBrush(format.fore)
    painter.setRenderHint(painter.Antialiasing)

    # Draw breakpoints
    for blockNumber in blocknumbers:
        if blockNumber &lt; startBlockNumber:
            continue
        # Get block
        block = editor.document().findBlockByNumber(blockNumber)
        if block.isValid():
            y = editor.blockBoundingGeometry(block).y() + bulletOffset
            painter.drawEllipse(margin, y, bulletWidth, bulletWidth)

    # Draw *the* debug marker
    if debugBlockIndicator &gt; 0:
        painter.setBrush(QtGui.QColor('#6F6'))
        # Get block
        block = editor.document().findBlockByNumber(debugBlockIndicator)
        if block.isValid():
            y = editor.blockBoundingGeometry(block).y() + bulletOffset
            y += 0.25 * bulletWidth
            painter.drawEllipse(margin, y, bulletWidth, 0.5*bulletWidth)

    # Draw other debug markers
    for debugLineIndicator in editor._debugLineIndicators:
        debugBlockIndicator = debugLineIndicator - 1
        painter.setBrush(QtGui.QColor('#DDD'))
        # Get block
        block = editor.document().findBlockByNumber(debugBlockIndicator)
        if block.isValid():
            y = editor.blockBoundingGeometry(block).y() + bulletOffset
            y += 0.25 * bulletWidth
            painter.drawEllipse(margin, y, bulletWidth, 0.5*bulletWidth)

    # Draw virtual break point
    if virtualBreakpoint &gt; 0:
        painter.setBrush(QtGui.QColor(0,0,0,0))
        # Get block
        block = editor.document().findBlockByNumber(virtualBreakpoint)
        if block.isValid():
            y = editor.blockBoundingGeometry(block).y() + bulletOffset
            painter.drawEllipse(margin, y, bulletWidth, bulletWidth)

    # Done
    painter.end()
</t>
<t tx="ekr.20190812072047.216">def __init__(self, *args, **kwds):
    self.__breakPointArea = None
    super(BreakPoints, self).__init__(*args, **kwds)
    # Create widget that draws the breakpoints
    self.__breakPointArea = self.__BreakPointArea(self)
    self.addLeftMargin(BreakPoints, self.getBreakPointAreaWidth)
    self._breakPoints = {}  # int -&gt; block
    self._debugLineIndicator = 0
    self._debugLineIndicators = set()
    self.blockCountChanged.connect(self.__onBlockCountChanged)
</t>
<t tx="ekr.20190812072047.217">def __onBlockCountChanged(self):
    """ Track breakpoints so we can update the number when text is inserted
    above.
    """
    newBreakPoints = {}

    for linenr in list(self._breakPoints):
        block, block_previous, block_next = self._breakPoints[linenr]
        block_linenr = block.blockNumber() + 1
        prev_ok = block.previous().blockNumber() == block_previous.blockNumber()
        next_ok = block.next().blockNumber() == block_next.blockNumber()

        if prev_ok or next_ok:
            if block_linenr == linenr:
                if prev_ok and next_ok:
                    pass # All is well
                else:
                    # Update refs
                    self._breakPoints[linenr] = block, block.previous(), block.next()
            else:
                # Update linenr - this is the only case where "move" th bp
                newBreakPoints[block_linenr] = self._breakPoints.pop(linenr)
        else:
            if block_linenr == linenr:
                # Just update refs
                self._breakPoints[linenr] = block, block.previous(), block.next()
            else:
                # Delete breakpoint? Meh, just update refs
                self._breakPoints[linenr] = block, block.previous(), block.next()

    if newBreakPoints:
        self._breakPoints.update(newBreakPoints)
        self.breakPointsChanged.emit(self)
        self.__breakPointArea.update()
</t>
<t tx="ekr.20190812072047.218">def breakPoints(self):
    """ A list of breakpoints for this editor.
    """
    return list(sorted(self._breakPoints))

    self._breakPoints = {}
    self.breakPointsChanged.emit(self)
    self.__breakPointArea.update()
</t>
<t tx="ekr.20190812072047.219">def toggleBreakpoint(self, linenr=None):
    """ Turn breakpoint on/off for given linenr of current line.
    """
    if linenr is None:
        linenr = self.textCursor().blockNumber() + 1
    if linenr in self._breakPoints:
        self._breakPoints.pop(linenr)
    else:
        c = self.textCursor()
        c.movePosition(c.Start)
        c.movePosition(c.NextBlock, c.MoveAnchor, linenr - 1)
        b = c.block()
        self._breakPoints[linenr] = b, b.previous(), b.next()

    self.breakPointsChanged.emit(self)
    self.__breakPointArea.update()
</t>
<t tx="ekr.20190812072047.22">class CodeEditorBase(QtWidgets.QPlainTextEdit): # tag:CodeEditor
    """ The base code editor class. Implements some basic features required
    by the extensions.

    """

    # Style element for default text and editor background
    _styleElements = [('Editor.text', 'The style of the default text. ' +
                        'One can set the background color here.',
                        'fore:#000,back:#fff',)]

    # Signal emitted after style has changed
    styleChanged = QtCore.Signal()

    # Signal emitted after font (or font size) has changed
    fontChanged = QtCore.Signal()

    # Signal to indicate a change in breakpoints. Only emitted if the
    # appropriate extension is in use
    breakPointsChanged = QtCore.Signal(object)

    @others
</t>
<t tx="ekr.20190812072047.220">def setDebugLineIndicator(self, linenr, active=True):
    """ Set the debug line indicator to the given line number.
    If None or 0, the indicator is hidden.
    """
    linenr = int(linenr or 0)
    if not linenr:
        # Remove all indicators
        if self._debugLineIndicator or self._debugLineIndicators:
            self._debugLineIndicator = 0
            self._debugLineIndicators = set()
            self.__breakPointArea.update()
    elif active:
        # Set *the* indicator
        if linenr != self._debugLineIndicator:
            self._debugLineIndicators.discard(linenr)
            self._debugLineIndicator = linenr
            self.__breakPointArea.update()
    else:
        # Add to set of indicators
        if linenr not in self._debugLineIndicators:
            self._debugLineIndicators.add(linenr)
            self.__breakPointArea.update()
</t>
<t tx="ekr.20190812072047.221">def getBreakPointAreaWidth(self):
    if not self.__showBreakPoints:
        return 0
    else:
        return self._breakPointWidth
</t>
<t tx="ekr.20190812072047.222">def showBreakPoints(self):
    return self.__showBreakPoints
</t>
<t tx="ekr.20190812072047.223">@ce_option(True)
def setShowBreakPoints(self, value):
    self.__showBreakPoints = bool(value)
    # Note that this method is called before the __init__ is finished,
    # so that the area is not yet created.
    if self.__breakPointArea:
        if self.__showBreakPoints:
            self.__breakPointArea.show()
        else:
            self.__breakPointArea.hide()
            self.clearBreakPoints()
        self.updateMargins()
</t>
<t tx="ekr.20190812072047.224">def resizeEvent(self,event):
    super(BreakPoints, self).resizeEvent(event)

    #On resize, resize the breakpointArea, too
    rect=self.contentsRect()
    m = self.getLeftMargin(BreakPoints)
    w = self.getBreakPointAreaWidth()
    self.__breakPointArea.setGeometry(  rect.x()+m, rect.y(),
                                        w, rect.height())
</t>
<t tx="ekr.20190812072047.225">def paintEvent(self,event):
    super(BreakPoints, self).paintEvent(event)
    #On repaint, update the complete breakPointArea
    w = self.getBreakPointAreaWidth()
    self.__breakPointArea.update(0, 0, w, self.height() )
</t>
<t tx="ekr.20190812072047.226">class Wrap(object): # tag:CodeEditor

    @others
</t>
<t tx="ekr.20190812072047.227">def wrap(self):
    """Enable or disable wrapping"""
    option=self.document().defaultTextOption()
    return not bool(option.wrapMode() == option.NoWrap)
</t>
<t tx="ekr.20190812072047.228">@ce_option(True)
def setWrap(self,value):
    option=self.document().defaultTextOption()
    if value:
        option.setWrapMode(option.WrapAtWordBoundaryOrAnywhere)
    else:
        option.setWrapMode(option.NoWrap)
    self.document().setDefaultTextOption(option)
</t>
<t tx="ekr.20190812072047.229"># todo: move this bit to base class?
# This functionality embedded in the highlighter and even has a designated
# subpackage. I feel that it should be a part of the base editor.
# Note: if we do this, remove the hasattr call in the highlighter.
class SyntaxHighlighting(object): # tag:CodeEditor
    """ Notes on syntax highlighting.

    The syntax highlighting/parsing is performed using three "components".

    The base component are the token instances. Each token simply represents
    a row of characters in the text the belong to each-other and should
    be styled in the same way. There is a token class for each particular
    "thing" in the code, such as comments, strings, keywords, etc. Some
    tokens are specific to a particular language.

    There is a function that produces a set of tokens, when given a line of
    text and a state parameter. There is such a function for each language.
    These "parsers" are defined in the parsers subpackage.

    And lastly, there is the Highlighter class, that applies the parser function
    to obtain the set of tokens and using the names of these tokens applies
    styling. The styling can be defined by giving a dict that maps token names
    to style representations.

    """

    # Register all syntax style elements
    _styleElements = Manager.getStyleElementDescriptionsForAllParsers()

    @others
</t>
<t tx="ekr.20190812072047.23">def __init__(self,*args, **kwds):
    super(CodeEditorBase, self).__init__(*args)
    # if leo_g: leo_g.pr('CodeEditorBase.__init__', args, kwds)

    # Set font (always monospace)
    self.__zoom = 0
    self.setFont()

    # Create highlighter class
    self.__highlighter = Highlighter(self, self.document())

    # Set some document options
    option = self.document().defaultTextOption()
    option.setFlags(    option.flags() | option.IncludeTrailingSpaces |
                        option.AddSpaceForLineAndParagraphSeparators )
    self.document().setDefaultTextOption(option)

    # When the cursor position changes, invoke an update, so that
    # the hihghlighting etc will work
    self.cursorPositionChanged.connect(self.viewport().update)

    # Init styles to default values
    self.__style = {}
    for element in self.getStyleElementDescriptions():
        self.__style[element.key] = element.defaultFormat

    # Connext style update
    self.styleChanged.connect(self.__afterSetStyle)
    self.__styleChangedPending = False

    # Init margins
    self._leftmargins = []

    # Init options now.
    # NOTE TO PEOPLE DEVELOPING EXTENSIONS:
    # If an extension has an __init__ in which it first calls the
    # super().__init__, this __initOptions() function will be called,
    # while the extension's init is not yet finished.
    self.__initOptions(kwds)

    # Define colors from Solarized theme
    # NOTE TO PEOPLE WANTING CUSTOM COLORS: ignore this and check the
    # commented lines near the bottom of this method.
    base03  = "#002b36"
    base02  = "#073642"
    base01  = "#586e75"
    base00  = "#657b83"
    base0   = "#839496"
    base1   = "#93a1a1"
    base2   = "#eee8d5"
    base3   = "#fdf6e3"
    yellow  = "#b58900"
    orange  = "#cb4b16"
    red     = "#dc322f"  # noqa
    magenta = "#d33682"
    violet  = "#6c71c4"
    blue    = "#268bd2"
    cyan    = "#2aa198"
    green   = "#859900"  # noqa

    if 1: # EKR:change: use a dark theme.
        back1, back2, back3 = base03, base02, base01
        fore1, fore2, fore3, fore4 = base0, base1, base2, base3  # noqa
    else:
        # Original code.
        #back1, back2, back3 = base3, base2, base1 # real solarised
        back1, back2, back3 = "#fff", base2, base1 # crispier
        fore1, fore2, fore3, fore4 = base00, base01, base02, base03

    # todo: proper testing of syntax style

    # Define style using "Solarized" colors
    S  = {}
    S["Editor.text"] = "back:%s, fore:%s" % (back1, fore1)
    S['Syntax.identifier'] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.nonidentifier"] = "fore:%s, bold:no, italic:no, underline:no" % fore2
    S["Syntax.keyword"] = "fore:%s, bold:yes, italic:no, underline:no" % fore2

    S["Syntax.builtins"] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.instance"] = "fore:%s, bold:no, italic:no, underline:no" % fore1

    S["Syntax.functionname"] = "fore:%s, bold:yes, italic:no, underline:no" % fore3
    S["Syntax.classname"] = "fore:%s, bold:yes, italic:no, underline:no" % orange

    S["Syntax.string"] = "fore:%s, bold:no, italic:no, underline:no" % violet
    S["Syntax.unterminatedstring"] = "fore:%s, bold:no, italic:no, underline:dotted" % violet
    S["Syntax.python.multilinestring"] = "fore:%s, bold:no, italic:no, underline:no" % blue

    S["Syntax.number"] = "fore:%s, bold:no, italic:no, underline:no" % cyan
    S["Syntax.comment"] = "fore:%s, bold:no, italic:no, underline:no" % yellow
    S["Syntax.todocomment"] = "fore:%s, bold:no, italic:yes, underline:no" % magenta
    S["Syntax.python.cellcomment"] = "fore:%s, bold:yes, italic:no, underline:full" % yellow

    S["Editor.Long line indicator"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Highlight current line"] = "back:%s" % back2
    S["Editor.Indentation guides"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Line numbers"] = "back:%s, fore:%s" % (back2, back3)

    # Define style using html color names. All 140 legal HTML colour
    # names can be used (in addition to HEX codes). A full list of
    # recognized colour names is available e.g. here
    # http://www.html-color-names.com/color-chart.php
#         S  = {}
#         S["Editor.text"] = "back: white, fore: black"
#         S['Syntax.identifier'] = "fore: black, bold:no, italic:no, underline:no"
#         S["Syntax.nonidentifier"] = "fore: blue, bold:no, italic:no, underline:no"
#         S["Syntax.keyword"] = "fore: blue, bold:yes, italic:no, underline:no"
#         S["Syntax.functionname"] = "fore: black, bold:yes, italic:no, underline:no"
#         S["Syntax.classname"] = "fore: magenta, bold:yes, italic:no, underline:no"
#         S["Syntax.string"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.unterminatedstring"] = "fore: red, bold:no, italic:no, underline:dotted"
#         S["Syntax.python.multilinestring"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.number"] = "fore: dark orange, bold:no, italic:no, underline:no"
#         S["Syntax.comment"] ="fore: green, bold:no, italic:yes, underline:no"
#         S["Syntax.todocomment"] = "fore: magenta, bold:no, italic:yes, underline:no"
#         S["Syntax.python.cellcomment"] = "fore: green, bold:yes, italic:no, underline:full"
#         S["Editor.Long line indicator"] = "linestyle:solid, fore: dark grey"
#         S["Editor.Highlight current line"] = "back: light grey"
#         S["Editor.Indentation guides"] = "linestyle:solid, fore: light grey"
#         S["Editor.Line numbers"] = "back: light grey, fore: black"

    # Apply style
    self.setStyle(S)
</t>
<t tx="ekr.20190812072047.230">def parser(self):
    """ parser()

    Get the parser instance currently in use to parse the code for
    syntax highlighting and source structure. Can be None.

    """
    try:
        return self.__parser
    except AttributeError:
        return None
</t>
<t tx="ekr.20190812072047.231">@ce_option(None)
def setParser(self, parserName=''):
    """ setParser(parserName='')

    Set the current parser by giving the parser name.

    """
    # Set parser
    self.__parser = Manager.getParserByName(parserName)

    # Restyle, use setStyle for lazy updating
    self.setStyle()
</t>
<t tx="ekr.20190812072047.232">@path pyzo/codeeditor/extensions/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072047.233"># -*- coding: utf-8 -*-
"""
Code editor extensions that provides autocompleter functionality
"""

from ..qt import QtGui,QtCore, QtWidgets
Qt = QtCore.Qt

import keyword

</t>
<t tx="ekr.20190812072047.234">#TODO: use this CompletionListModel to style the completion suggestions (class names, method names, keywords etc)
class CompletionListModel(QtCore.QStringListModel):
    @others
</t>
<t tx="ekr.20190812072047.235">def data(self, index, role):
    if role == Qt.ForegroundRole:
        # data = str(QtWidgets.QStringListModel.data(self, index, QtCore.Qt.DisplayRole))
        # return QtGui.QBrush(Qt.red)
        return None
    else:
        return QtCore.QStringListModel.data(self, index, role)
</t>
<t tx="ekr.20190812072047.236"># todo: use keywords from the parser
class AutoCompletion(object): # tag:CodeEditor
    @others
</t>
<t tx="ekr.20190812072047.237">def __init__(self,*args, **kwds):
    super(AutoCompletion, self).__init__(*args, **kwds)
    # Autocompleter
    self.__completerModel = QtCore.QStringListModel(keyword.kwlist)
    self.__completer = QtWidgets.QCompleter(self)
    self.__completer.setModel(self.__completerModel)
    self.__completer.setCaseSensitivity(Qt.CaseInsensitive)
    self.__completer.setWidget(self)
    self.__completerNames = []
    self.__recentCompletions = [] #List of recently selected completions

    # geometry
    self.__popupSize = 300, 100

    # Text position corresponding to first charcter of the word being completed
    self.__autocompleteStart = None

    self.__autocompleteDebug = False

    self.__autocompletionAcceptKeys = (Qt.Key_Tab,)

    #Connect signals
    self.__highlightedCompletion = None
    self.__completer.activated.connect(self.onAutoComplete)
    self.__completer.highlighted.connect(self._setHighlightedCompletion)
</t>
<t tx="ekr.20190812072047.238">def _setHighlightedCompletion(self, value):
    """ Keeping track of the highlighted item allows us
    to 'manually' perform an autocompletion.
    """
    self.__highlightedCompletion = value

## Properties
</t>
<t tx="ekr.20190812072047.239">def recentCompletionsList(self):
    """
    The list of recent auto-completions. This property may be set to a
    list that is shared among several editors, in order to share the notion
    of recent auto-completions
    """
    return self.__recentCompletions
</t>
<t tx="ekr.20190812072047.24">def _setHighlighter(self, highlighterClass):
    self.__highlighter = highlighterClass(self, self.document())

## Options
</t>
<t tx="ekr.20190812072047.240">def setRecentCompletionsList(self,value):
    self.__recentCompletions = value
</t>
<t tx="ekr.20190812072047.241">def completer(self):
    return self.__completer
</t>
<t tx="ekr.20190812072047.242">def setAutoCompletionAcceptKeys(self, *keys):
    """ Set the keys (Qt enums) that can accept an autocompletion.
    Like Tab, or Enter. Defaut Tab.
    """
    self.__autocompletionAcceptKeys = keys

## Autocompletion
</t>
<t tx="ekr.20190812072047.243">def setAutocompletPopupSize(self, width, height):
    """
    Set the size (width, heigth) of the automcompletion popup window.
    """
    self.__popupSize = width, height
</t>
<t tx="ekr.20190812072047.25">def __getOptionSetters(self):
    """ Get a dict that maps (lowercase) option names to the setter
    methods.
    """

    # Get all names that can be options
    allNames = set(dir(self))
    nativeNames = set(dir(QtWidgets.QPlainTextEdit))
    names = allNames.difference(nativeNames)

    # Init dict of setter members
    setters = {}

    for name in names:
        # Get name without set
        if name.lower().startswith('set'):
            name = name[3:]
        # Get setter and getter name
        name_set = 'set' + name[0].upper() + name[1:]
        name_get = name[0].lower() + name[1:]
        # Check if both present
        if not (name_set in names and name_get in names):
            continue
        # Get members
        member_set = getattr(self, name_set)
        member_get = getattr(self, name_get)
        # Check if option decorator was used and get default value
        for member in [member_set, member_get]:
            if hasattr(member, DEFAULT_OPTION_NAME):
                defaultValue = member.__dict__[DEFAULT_OPTION_NAME]
                break
        else:
            continue
        # Set default on both
        member_set.__dict__[DEFAULT_OPTION_NAME] = defaultValue
        member_get.__dict__[DEFAULT_OPTION_NAME] = defaultValue
        # Add to list
        setters[name.lower()] = member_set

    # Done
    return setters
</t>
<t tx="ekr.20190812072047.26">def __setOptions(self, setters, options):
    """ Sets the options, given the list-of-tuples methods and an
    options dict.
    """

    # List of invalid keys
    invalidKeys = []

    # Set options
    for key1 in options:
        key2 = key1.lower()
        # Allow using the setter name
        if key2.startswith('set'):
            key2 = key2[3:]
        # Check if exists. If so, call!
        if key2 in setters:
            fun = setters[key2]
            val = options[key1]
            fun(val)
        else:
            invalidKeys.append(key1)

    # Check if invalid keys were given
    if invalidKeys:
        print("Warning, invalid options given: " + ', '.join(invalidKeys))
</t>
<t tx="ekr.20190812072047.27">def __initOptions(self, options=None):
    """ Init the options with their default values.
    Also applies the docstrings of one to the other.
    """

    # Make options an empty dict if not given
    if not options:
        options = {}

    # Get setters
    setters = self.__getOptionSetters()

    # Set default value
    for member_set in setters.values():
        defaultVal = member_set.__dict__[DEFAULT_OPTION_NAME]
        if defaultVal != DEFAULT_OPTION_NONE:
            try:
                member_set(defaultVal)
            except Exception as why:
                print('Error initing option ', member_set.__name__)

    # Also set using given opions?
    if options:
        self.__setOptions(setters, options)
</t>
<t tx="ekr.20190812072047.28">def setOptions(self, options=None, **kwargs):
    """ setOptions(options=None, **kwargs)

    Set the code editor options (e.g. highlightCurrentLine) using
    a dict-like object, or using keyword arguments (options given
    in the latter overrule opions in the first).

    The keys in the dict are case insensitive and one can use the
    option's setter or getter name.

    """

    # Process options
    if options:
        D = {}
        for key in options:
            D[key] = options[key]
        D.update(kwargs)
    else:
        D = kwargs

    # Get setters
    setters = self.__getOptionSetters()

    # Go
    self.__setOptions(setters, D)

## Font
</t>
<t tx="ekr.20190812072047.29">def setFont(self, font=None):
    """ setFont(font=None)

    Set the font for the editor. Should be a monospace font. If not,
    Qt will select the best matching monospace font.

    """

    defaultFont = Manager.defaultFont()

    # Get font object
    if font is None:
        font = defaultFont
    elif isinstance(font, QtGui.QFont):
        pass
    elif isinstance(font, str):
        font = QtGui.QFont(font)
    else:
        raise ValueError("setFont accepts None, QFont or string.")

    # Hint Qt that it should be monospace
    font.setStyleHint(font.TypeWriter, font.PreferDefault)

    # Get family, fall back to default if qt could not produce monospace
    fontInfo = QtGui.QFontInfo(font)
    if fontInfo.fixedPitch():
        family = fontInfo.family()
    else:
        family = defaultFont.family()

    # Get size: default size + zoom
    size = defaultFont.pointSize() + self.__zoom

    # Create font instance
    font = QtGui.QFont(family, size)

    # Set, emit and return
    QtWidgets.QPlainTextEdit.setFont(self, font)
    self.fontChanged.emit()
    return font
</t>
<t tx="ekr.20190812072047.3">@path pyzo/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072047.30">def setZoom(self, zoom):
    """ setZoom(zoom)

    Set the zooming of the document. The font size is always the default
    font size + the zoom factor.

    The final zoom is returned, this may not be the same as the given
    zoom factor if the given factor is too small.

    """
    # Set zoom (limit such that final pointSize &gt;= 1)
    size = Manager.defaultFont().pointSize()
    self.__zoom = int(max(1-size,zoom))
    # Set font
    self.setFont(self.fontInfo().family())
    # Return zoom
    return self.__zoom

## Syntax / styling
</t>
<t tx="ekr.20190812072047.31">@classmethod
def getStyleElementDescriptions(cls):
    """ getStyleElementDescriptions()

    This classmethod returns a list of the StyleElementDescription
    instances used by this class. This includes the descriptions for
    the syntax highlighting of all parsers.

    """

    # Collect members by walking the class bases
    elements = []
    def collectElements(cls, iter=1):
        # Valid class?
        if cls is object or cls is QtWidgets.QPlainTextEdit:
            return
        # Check members
        if hasattr(cls, '_styleElements'):
            for element in cls._styleElements:
                elements.append(element)
        # Recurse
        for c in cls.__bases__:
            collectElements(c, iter+1)
    collectElements(cls)

    # Make style element descriptions
    # (Use a dict to ensure there are no duplicate keys)
    elements2 = {}
    for element in elements:
        # Check
        if isinstance(element, StyleElementDescription):
            pass
        elif isinstance(element, tuple):
            element = StyleElementDescription(*element)
        else:
            print('Warning: invalid element: ' + repr(element))
        # Store using the name as a key to prevent duplicates
        elements2[element.key] = element

    # Done
    return list(elements2.values())
</t>
<t tx="ekr.20190812072047.32">def getStyleElementFormat(self, name):
    """ getStyleElementFormat(name)

    Get the style format for the style element corresponding with
    the given name. The name is case insensitive and invariant to
    the use of spaces.

    """
    key = name.replace(' ','').lower()
    try:
        return self.__style[key]
    except KeyError:
        raise KeyError('Not a known style element name: "%s".' % name)
</t>
<t tx="ekr.20190812072047.33">def setStyle(self, style=None, **kwargs):
    """ setStyle(style=None, **kwargs)

    Updates the formatting per style element.

    The style consists of a dictionary that maps style names to
    style formats. The style names are case insensitive and invariant
    to the use of spaces.

    For convenience, keyword arguments may also be used. In this case,
    underscores are interpreted as dots.

    This function can also be called without arguments to force the
    editor to restyle (and rehighlight) itself.

    Use getStyleElementDescriptions() to get information about the
    available styles and their default values.

    Examples
    --------
    # To make the classname in underline, but keep the color and boldness:
    setStyle(syntax_classname='underline')
    # To set all values for function names:
    setStyle(syntax_functionname='#883,bold:no,italic:no')
    # To set line number and indent guides colors
    setStyle({  'editor.LineNumbers':'fore:#000,back:#777',
                'editor.indentationGuides':'#f88' })

    """

    # Combine user input
    D = {}
    if style:
        for key in style:
            D[key] = style[key]
    if True:
        for key in kwargs:
            key2 = key.replace('_', '.')
            D[key2] = kwargs[key]

    # List of given invalid style element names
    invalidKeys = []

    # Set style elements
    for key in D:
        normKey = key.replace(' ', '').lower()
        if normKey in self.__style:
            #self.__style[normKey] = StyleFormat(D[key])
            self.__style[normKey].update(D[key])
        else:
            invalidKeys.append(key)

    # Give warning for invalid keys
    if invalidKeys:
        print("Warning, invalid style names given: " +
                                                ','.join(invalidKeys))

    # Notify that style changed, adopt a lazy approach to make loading
    # quicker.
    if self.isVisible():
        callLater(self.styleChanged.emit)
        self.__styleChangedPending = False
    else:
        self.__styleChangedPending = True
</t>
<t tx="ekr.20190812072047.34">def showEvent(self, event):
    super(CodeEditorBase, self).showEvent(event)
    # Does the style need updating?
    if self.__styleChangedPending:
        callLater(self.styleChanged.emit)
        self.__styleChangedPending = False
</t>
<t tx="ekr.20190812072047.35">def __afterSetStyle(self):
    """ _afterSetStyle()

    Method to call after the style has been set.

    """

    # Set text style using editor style sheet
    format = self.getStyleElementFormat('editor.text')
    ss = 'QPlainTextEdit{ color:%s; background-color:%s; }' %  (
                        format['fore'], format['back'])
    self.setStyleSheet(ss)

    # Make sure the style is applied
    self.viewport().update()

    # Re-highlight
    callLater(self.__highlighter.rehighlight)

## Some basic options
</t>
<t tx="ekr.20190812072047.36">@ce_option(4)
def indentWidth(self):
    """ Get the width of a tab character, and also the amount of spaces
    to use for indentation when indentUsingSpaces() is True.
    """
    return self.__indentWidth
</t>
<t tx="ekr.20190812072047.37">def setIndentWidth(self, value):
    value = int(value)
    if value&lt;=0:
        raise ValueError("indentWidth must be &gt;0")
    self.__indentWidth = value
    self.setTabStopWidth(self.fontMetrics().width('i'*self.__indentWidth))
</t>
<t tx="ekr.20190812072047.38">@ce_option(False)
def indentUsingSpaces(self):
    """Get whether to use spaces (if True) or tabs (if False) to indent
    when the tab key is pressed
    """
    return self.__indentUsingSpaces
</t>
<t tx="ekr.20190812072047.39">def setIndentUsingSpaces(self, value):
    self.__indentUsingSpaces = bool(value)
    self.__highlighter.rehighlight()

## Misc
</t>
<t tx="ekr.20190812072047.4">"""
This is a bit awkward, but yoton is a package that is designed to work from
Python 2.4 to Python 3.x. As such, it does not have relative imports and
must be imported as an absolute package. That is what this module does...
"""
import os
import sys

try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo/yotonloader.py')
except Exception:
    leo_g = None

# Import yoton
sys.path.insert(0, os.path.dirname(__file__))
import yoton  # noqa
assert yoton

# Reset
sys.path.pop(0)

</t>
<t tx="ekr.20190812072047.40">def gotoLine(self, lineNumber):
    """ gotoLine(lineNumber)

    Move the cursor to the block given by the line number
    (first line is number 1) and show that line.

    """
    return self.gotoBlock(lineNumber-1)
</t>
<t tx="ekr.20190812072047.41">def gotoBlock(self, blockNumber):
    """ gotoBlock(blockNumber)

    Move the cursor to the block given by the block number
    (first block is number 0) and show that line.

    """
    # Two implementatios. I know that the latter works, so lets
    # just use that.

    cursor = self.textCursor()
    #block = self.document().findBlockByNumber( blockNumber )
    #cursor.setPosition(block.position())
    cursor.movePosition(cursor.Start) # move to begin of the document
    cursor.movePosition(cursor.NextBlock,n=blockNumber) # n blocks down

    try:
        self.setTextCursor(cursor)
    except Exception:
        pass # File is smaller then the caller thought

    # TODO make this user configurable (setting relativeMargin to anything above
    # 0.5 will cause cursor to center on each move)
    relativeMargin = 0.2    # 20% margin on both sides of the window
    margin = self.height() * relativeMargin
    cursorRect = self.cursorRect(cursor)
    if cursorRect.top() &lt; margin or cursorRect.bottom() + margin &gt; self.height():
        self.centerCursor()
</t>
<t tx="ekr.20190812072047.42">def doForSelectedBlocks(self, function):
    """ doForSelectedBlocks(function)

    Call the given function(cursor) for all blocks in the current selection
    A block is considered to be in the current selection if a part of it is in
    the current selection

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    #Note: a 'TextCursor' does not represent the actual on-screen cursor, so
    #movements do not move the on-screen cursor

    #Note 2: when the text is changed, the cursor and selection start/end
    #positions of all cursors are updated accordingly, so the screenCursor
    #stays in place even if characters are inserted at the editCursor

    screenCursor = self.textCursor() #For maintaining which region is selected
    editCursor = self.textCursor()   #For inserting the comment marks

    #Use beginEditBlock / endEditBlock to make this one undo/redo operation
    editCursor.beginEditBlock()

    try:
        editCursor.setPosition(screenCursor.selectionStart())
        editCursor.movePosition(editCursor.StartOfBlock)
        # &lt; :if selection end is at beginning of the block, don't include that
        #one, except when the selectionStart is same as selectionEnd
        while editCursor.position()&lt;screenCursor.selectionEnd() or \
                editCursor.position()&lt;=screenCursor.selectionStart():
            #Create a copy of the editCursor and call the user-supplied function
            editCursorCopy = QtGui.QTextCursor(editCursor)
            function(editCursorCopy)

            #Move to the next block
            if not editCursor.block().next().isValid():
                break #We reached the end of the document
            editCursor.movePosition(editCursor.NextBlock)
    finally:
        editCursor.endEditBlock()
</t>
<t tx="ekr.20190812072047.43">def doForVisibleBlocks(self, function):
    """ doForVisibleBlocks(function)

    Call the given function(cursor) for all blocks that are currently
    visible. This is used by several appearence extensions that
    paint per block.

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    # Start cursor at top line.
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    cursor.movePosition(cursor.StartOfBlock)

    if not self.isVisible():
        return

    while True:
        # Call the function with a copy of the cursor
        function(QtGui.QTextCursor(cursor))

        # Go to the next block (or not if we are done)
        y = self.cursorRect(cursor).bottom()
        if y &gt; self.height():
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text
        cursor.movePosition(cursor.NextBlock)
</t>
<t tx="ekr.20190812072047.44">def indentBlock(self, cursor, amount=1):
    """ indentBlock(cursor, amount=1)

    Indent the block given by cursor.

    The cursor specified is used to do the indentation; it is positioned
    at the beginning of the first non-whitespace position after completion
    May be overridden to customize indentation.

    """
    text = ustr(cursor.block().text())
    leadingWhitespace = text[:len(text)-len(text.lstrip())]

    #Select the leading whitespace
    cursor.movePosition(cursor.StartOfBlock)
    cursor.movePosition(cursor.Right,cursor.KeepAnchor,len(leadingWhitespace))

    #Compute the new indentation length, expanding any existing tabs
    indent = len(leadingWhitespace.expandtabs(self.indentWidth()))
    if self.indentUsingSpaces():
        # Determine correction, so we can round to multiples of indentation
        correction = indent % self.indentWidth()
        if correction and amount&lt;0:
            correction = - (self.indentWidth() - correction) # Flip
        # Add the indentation tabs
        indent += (self.indentWidth() * amount) - correction
        cursor.insertText(' '*max(indent,0))
    else:
        # Convert indentation to number of tabs, and add one
        indent = (indent // self.indentWidth()) + amount
        cursor.insertText('\t' * max(indent,0))
</t>
<t tx="ekr.20190812072047.45">def dedentBlock(self, cursor):
    """ dedentBlock(cursor)

    Dedent the block given by cursor.

    Calls indentBlock with amount = -1.
    May be overridden to customize indentation.

    """
    self.indentBlock(cursor, amount = -1)
</t>
<t tx="ekr.20190812072047.46">def indentSelection(self):
    """ indentSelection()

    Called when the current line/selection is to be indented.
    Calls indentLine(cursor) for each line in the selection.
    May be overridden to customize indentation.

    See also doForSelectedBlocks and indentBlock.

    """
    self.doForSelectedBlocks(self.indentBlock)
</t>
<t tx="ekr.20190812072047.47">def dedentSelection(self):
    """ dedentSelection()

    Called when the current line/selection is to be dedented.
    Calls dedentLine(cursor) for each line in the selection.
    May be overridden to customize indentation.

    See also doForSelectedBlocks and dedentBlock.

    """
    self.doForSelectedBlocks(self.dedentBlock)
</t>
<t tx="ekr.20190812072047.48">def justifyText(self, linewidth=70):
    """ justifyText(linewidth=70)
    """
    from .textutils import TextReshaper

    # Get cursor
    cursor = self.textCursor()

    # Make selection include whole lines
    pos1, pos2 = cursor.position(), cursor.anchor()
    pos1, pos2 = min(pos1, pos2), max(pos1, pos2)
    cursor.setPosition(pos1, cursor.MoveAnchor)
    cursor.movePosition(cursor.StartOfBlock, cursor.MoveAnchor)
    cursor.setPosition(pos2, cursor.KeepAnchor)
    cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)

    # Use reshaper to create replacement text
    reshaper = TextReshaper(linewidth)
    reshaper.pushText(cursor.selectedText())
    newText = reshaper.popText()

    # Update the selection
    #self.setTextCursor(cursor) for testing
    cursor.insertText(newText)
</t>
<t tx="ekr.20190812072047.49">def addLeftMargin(self, des, func):
    """ Add a margin to the left. Specify a description for the margin,
    and a function to get that margin. For internal use.
    """
    assert des is not None
    self._leftmargins.append((des, func))
</t>
<t tx="ekr.20190812072047.5">@path pyzo/

# EKR: The frozen version of pyzo does not use pyzo.__main__
&lt;&lt; pyzo.__init__ docstring &gt;&gt;
__version__ = '4.6.2'
&lt;&lt; pyzo.__init__ imports &gt;&gt;
@others
&lt;&lt; pyzo.__init__ late assignments &gt;&gt;

@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072047.50">def getLeftMargin(self, des=None):
    """ Get the left margin, relative to the given description (which
    should be the same as given to addLeftMargin). If des is omitted
    or None, the full left margin is returned.
    """
    margin = 0
    for d, func in self._leftmargins:
        if d == des:
            break
        margin += func()
    return margin
</t>
<t tx="ekr.20190812072047.51">def updateMargins(self):
    """ Force the margins to be recalculated and set the viewport
    accordingly.
    """
    leftmargin = self.getLeftMargin()
    # if leo_g:
        # leo_g.pr('----- CodeEditorBase.updateMargins', leftmargin)
        # leo_g.printObj(self._leftmargins, tag='CodeEditorBase._leftmargins')
    self.setViewportMargins(leftmargin , 0, 0, 0)
</t>
<t tx="ekr.20190812072047.52">def toggleCase(self):
    """ Change selected text to lower or upper case.
    """

    # Get cursor
    cursor = self.textCursor()
    position = cursor.position()
    start_pos = cursor.selectionStart()
    end_pos = cursor.selectionEnd()

    # Get selected text
    selection = cursor.selectedText()

    if selection.islower():
        newText = selection.upper()
    elif selection.isupper():
        newText = selection.lower()
    else:
        newText = selection.lower()

    # Update the selection
    cursor.insertText(newText)
    cursor.setPosition(start_pos)
    cursor.setPosition(end_pos, QtGui.QTextCursor.KeepAnchor)
    self.setTextCursor(cursor)
</t>
<t tx="ekr.20190812072047.53">@path pyzo/codeeditor/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072047.54"># -*- coding: utf-8 -*-
""" Module highlighter

Defines the highlighter class for the base code editor class. It will do
the styling when syntax highlighting is enabled. If it is not, will only
check out indentation.

"""

try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo.codeeditor.highlighter.py')
except Exception:
    leo_g = None

from .qt import QtGui, QtCore
Qt = QtCore.Qt

from . import parsers
from .misc import ustr

</t>
<t tx="ekr.20190812072047.55">class BlockData(QtGui.QTextBlockUserData):
    """ Class to represent the data for a block.
    """
    @others
</t>
<t tx="ekr.20190812072047.56">def __init__(self):
    QtGui.QTextBlockUserData.__init__(self)
    self.indentation = None
    self.fullUnderlineFormat = None
    self.tokens = []
</t>
<t tx="ekr.20190812072047.57"># The highlighter should be part of the base class, because
# some extensions rely on them (e.g. the indent guuides).
class Highlighter(QtGui.QSyntaxHighlighter):

    @others
</t>
<t tx="ekr.20190812072047.58">def __init__(self,codeEditor,*args):
    QtGui.QSyntaxHighlighter.__init__(self,*args)

    # Store reference to editor
    self._codeEditor = codeEditor
</t>
<t tx="ekr.20190812072047.59">def getCurrentBlockUserData(self):
    """ getCurrentBlockUserData()

    Gets the BlockData object. Creates one if necesary.

    """
    bd = self.currentBlockUserData()
    if not isinstance(bd, BlockData):
        bd = BlockData()
        self.setCurrentBlockUserData(bd)
    return bd
</t>
<t tx="ekr.20190812072047.60">def highlightBlock(self, line):
    """ highlightBlock(line)

    This method is automatically called when a line must be
    re-highlighted.

    If the code editor has an active parser. This method will use
    it to perform syntax highlighting. If not, it will only
    check out the indentation.

    """

    # Make sure this is a Unicode Python string
    line = ustr(line)

    # Get previous state
    previousState = self.previousBlockState()

    # Get parser
    parser = None
    if hasattr(self._codeEditor, 'parser'):
        parser = self._codeEditor.parser()

    # Get function to get format
    nameToFormat = self._codeEditor.getStyleElementFormat

    fullLineFormat = None
    tokens = []
    if parser:
        self.setCurrentBlockState(0)
        tokens = list(parser.parseLine(line, previousState))
        for token in tokens :
            # Handle block state
            if isinstance(token, parsers.BlockState):
                self.setCurrentBlockState(token.state)
            else:
                # Get format
                try:
                    styleFormat = nameToFormat(token.name)
                    charFormat = styleFormat.textCharFormat
                except KeyError:
                    #print(repr(nameToFormat(token.name)))
                    continue
                # Set format
                self.setFormat(token.start,token.end-token.start,charFormat)
                # Is this a cell?
                if (fullLineFormat is None) and styleFormat._parts.get('underline','') == 'full':
                    fullLineFormat = styleFormat

    # Get user data
    bd = self.getCurrentBlockUserData()

    # Store token list for future use (e.g. brace matching)
    bd.tokens = tokens

    # Handle underlines
    bd.fullUnderlineFormat = fullLineFormat

    # Get the indentation setting of the editors
    indentUsingSpaces = self._codeEditor.indentUsingSpaces()

    leadingWhitespace=line[:len(line)-len(line.lstrip())]
    if '\t' in leadingWhitespace and ' ' in leadingWhitespace:
        #Mixed whitespace
        bd.indentation = 0
        format=QtGui.QTextCharFormat()
        format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        format.setUnderlineColor(QtCore.Qt.red)
        format.setToolTip('Mixed tabs and spaces')
        self.setFormat(0,len(leadingWhitespace),format)
    elif ('\t' in leadingWhitespace and indentUsingSpaces) or \
        (' ' in leadingWhitespace and not indentUsingSpaces):
        #Whitespace differs from document setting
        bd.indentation = 0
        format=QtGui.QTextCharFormat()
        format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        format.setUnderlineColor(QtCore.Qt.blue)
        format.setToolTip('Whitespace differs from document setting')
        self.setFormat(0,len(leadingWhitespace),format)
    else:
        # Store info for indentation guides
        # amount of tabs or spaces
        bd.indentation = len(leadingWhitespace)
</t>
<t tx="ekr.20190812072047.61">@path pyzo/codeeditor/
# -*- coding: utf-8 -*-
@nopyflakes
""" Module manager

This module contains a static class that can be used for some
management tasks.

"""

import os, sys

from .qt import QtGui, QtCore, QtWidgets  # noqa
Qt = QtCore.Qt

from . import parsers
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072047.63">class Manager:
    """ Manager

    Static class to do some management tasks:
      * It manages the parsers
      * Getting style element descriptions of all parsers
      * Linking file extensions to parsers
      * Font information

    """

    _defaultFontFamily = 'dummy_font_family_name'

    # Static dict of all parsers
    _parserInstances = {}
    _fileExtensions = {}
    _shebangKeywords = {}

    ## Parsers

#     @classmethod
#     def collectParsersDynamically(cls):
#         """ insert the function is this module's namespace.
#         """
#
#         # Get the path of this subpackage
#         path = __file__
#         path = os.path.dirname( os.path.abspath(path) )
#
#         # Determine if we're in a zipfile
#         i = path.find('.zip')
#         if i&gt;0:
#             # get list of files from zipfile
#             path = path[:i+4]
#             z = zipfile.ZipFile(path)
#             files = [os.path.split(i)[-1] for i in z.namelist()
#                         if 'codeeditor' in i and 'parsers' in i]
#         else:
#             # get list of files from file system
#             files = os.listdir(path)
#
#         # Extract all parsers
#         parserModules = []
#         for file in files:
#
#             # Only python files
#             if file.endswith('.pyc'):
#                 if file[:-1] in files:
#                     continue # Only try import once
#             elif not file.endswith('.py'):
#                 continue
#             # Only syntax files
#             if '_parser.' not in file:
#                 continue
#
#             # Import module
#             fullfile = os.path.join(path, file)
#             modname = os.path.splitext(file)[0]
#             print('modname', modname)
#             mod = __import__("codeeditor.parsers."+modname, fromlist=[modname])
#             parserModules.append(mod)
#
#         print(parserModules)

    @others
# Init
try:
    Manager._collectParsers()
except Exception as why:
    print('Error collecting parsers')
    print(why)
</t>
<t tx="ekr.20190812072047.64">@classmethod
def _collectParsers(cls):
    """ _collectParsers()

    Collect all parser classes. This function is called on startup.

    """

    # Prepare (use a set to prevent duplicates)
    foundParsers = set()
    G = parsers.__dict__
    ModuleClass = os.__class__

    # Collect parser classes
    for module_name in G:
        # Check if it is indeed a module, and if it has the right name
        if not isinstance(G[module_name], ModuleClass):
            continue
        if not module_name.endswith('_parser'):
            continue
        # Collect all valid classes from the module
        moduleDict = G[module_name].__dict__
        for name_in_module in moduleDict:
            ob = moduleDict[name_in_module]
            if isinstance(ob, type) and issubclass(ob, parsers.Parser):
                foundParsers.add(ob)

    # Put in list with the parser names as keys
    parserInstances = {}
    for parserClass in foundParsers:
        name = parserClass.__name__
        if name.endswith('Parser') and len(name)&gt;6:

            # Get parser identifier name
            name = name[:-6].lower()

            # Try instantiating the parser
            try:
                parserInstances[name] = parserInstance = parserClass()
            except Exception:
                # We cannot get the exception object in a Python2/Python3
                # compatible way
                print('Could not instantiate parser "%s".'%name)
                continue

            # Register extensions and shebang keywords for this parser
            for ext in parserInstance.filenameExtensions():
                cls._fileExtensions[ext] = name
            for skw in parserInstance.shebangKeywords():
                cls._shebangKeywords[skw] = name

    # Store
    cls._parserInstances = parserInstances
</t>
<t tx="ekr.20190812072047.65">@classmethod
def getParserNames(cls):
    """ getParserNames()

    Get a list of all available parsers.

    """
    return list(cls._parserInstances.keys())
</t>
<t tx="ekr.20190812072047.66">@classmethod
def getParserByName(cls, parserName):
    """ getParserByName(parserName)

    Get the parser object corresponding to the given name.
    If no parser is known by the given name, a warning message
    is printed and None is returned.

    """
    if not parserName:
        return parsers.Parser() #Default dummy parser

    # Case insensitive
    parserName = parserName.lower()

    # Return instantiated parser object.
    if parserName in cls._parserInstances:
        return cls._parserInstances[parserName]
    else:
        print('Warning: no parser known by the name "%s".'%parserName)
        print('I know these: ', cls._parserInstances.keys())
        return parsers.Parser() #Default dummy parser
</t>
<t tx="ekr.20190812072047.67">@classmethod
def getStyleElementDescriptionsForAllParsers(cls):
    """ getStyleElementDescriptionsForAllParsers()

    Get all style element descriptions corresponding to
    the tokens of all parsers.

    This function is used by the code editor to register all syntax
    element styles to the code editor class.

    """
    descriptions = {}
    for parser in cls._parserInstances.values():
        for token in parser.getUsedTokens():
            description = token.description
            descriptions[description.key] = description

    return list(descriptions.values())

## File extensions
</t>
<t tx="ekr.20190812072047.68">@classmethod
def suggestParserfromFilenameExtension(cls, ext):
    """ suggestParserfromFilenameExtension(ext)

    Given a filename extension, returns the name of the suggested
    parser corresponding to the language of the file.

    See also registerFilenameExtension()
    """

    # Normalize ext
    ext = '.' + ext.lstrip('.').lower()

    # Get parser
    if ext in cls._fileExtensions:
        return cls._fileExtensions[ext]
    else:
        return ''
</t>
<t tx="ekr.20190812072047.69">@classmethod
def suggestParserfromText(cls, text) :
    """ suggestParserfromText(text)

    Given a text, returns the name of the suggested
    parser corresponding to the language of the file.

    See also registerShebangKeyword()
    """
    shebangline = None
    for line in text[:1000].splitlines() :
        line = line.strip()
        if line.startswith("#!") :
            shebangline = line
            break
    if shebangline is None :
        return ''
    shebangline = shebangline[2:].split() # takes care of eventual space after #!
    if len(shebangline) == 0 :
        return ""
    interpreter = os.path.basename(shebangline[0])
    if interpreter == "env" and len(shebangline) &gt; 1 :
        interpreter = shebangline[1]

    # Get parser
    if interpreter in cls._shebangKeywords:
        return cls._shebangKeywords[interpreter]
    else:
        return ''
</t>
<t tx="ekr.20190812072047.7">class MyApp(QtWidgets.QApplication):
    """ So we an open .py files on OSX.
    OSX is smart enough to call this on the existing process.
    """
    @others
assert MyApp
if not sys.platform.startswith('darwin'):
    MyApp = QtWidgets.QApplication  # noqa
    assert MyApp
## Install excepthook
# In PyQt5 exceptions in Python will cuase an abort
# http://pyqt.sourceforge.net/Docs/PyQt5/incompatibilities.html
</t>
<t tx="ekr.20190812072047.70">@classmethod
def suggestParser(cls, ext, text) :
    """ suggestParser(ext, text)

    Given a filename extension and text, returns the name of the suggested
    parser corresponding to the language of the file.

    See also registerFilenameExtension() and registerShebangKeyword()
    """
    parser = cls.suggestParserfromFilenameExtension(ext)
    if parser == "" :
        parser = cls.suggestParserfromText(text)
    return parser
</t>
<t tx="ekr.20190812072047.71">@classmethod
def registerFilenameExtension(cls, ext, parser):
    """ registerFilenameExtension(ext, parser)

    Registers the given filename extension to the given parser.
    The parser can be a Parser instance or its name.

    This function can be used to register extensions to parsers
    that are not registered by default.

    """
    # Normalize ext
    ext = '.' + ext.lstrip('.').lower()
    # Check parser
    if isinstance(parser, parsers.Parser):
        parser = parser.name()
    # Register
    cls._fileExtensions[ext] = parser
</t>
<t tx="ekr.20190812072047.72">@classmethod
def registerShebangKeyword(cls, shebangKeyword, parser):
    """ registerShebangKeyword(shebangKeyword, parser)

    Registers the given shebang keyword (interpreter) to the given parser.
    The parser can be a Parser instance or its name.

    This function can be used to register shebang keywords to parsers
    that are not registered by default.

    """
    # Check parser
    if isinstance(parser, parsers.Parser):
        parser = parser.name()
    # Register
    cls._shebangKeywords[shebangKeyword] = parser

## Fonts
</t>
<t tx="ekr.20190812072047.73">@classmethod
def fontNames(cls):
    """ fontNames()

    Get a list of all monospace fonts available on this system.

    """
    db = QtGui.QFontDatabase()
    QFont, QFontInfo = QtGui.QFont, QtGui.QFontInfo
    # fn = font_name (str)
    return [fn for fn in db.families() if QFontInfo(QFont(fn)).fixedPitch()]
</t>
<t tx="ekr.20190812072047.74">@classmethod
def setDefaultFontFamily(cls, name):
    """ setDefaultFontFamily(name)

    Set the default (monospace) font family name for this system.
    This should be set only once during startup.

    """
    cls._defaultFontFamily = name
</t>
<t tx="ekr.20190812072047.75">@classmethod
def defaultFont(cls):
    """ defaultFont()

    Get the default (monospace) font for this system. Returns a QFont
    object.

    """

    # Get font family
    f = QtGui.QFont(cls._defaultFontFamily)
    f.setStyleHint(f.TypeWriter, f.PreferDefault)
    fi = QtGui.QFontInfo(f)
    family = fi.family()

    # Get the font size
    size = 9
    if sys.platform.startswith('darwin'):
        # Account for Qt font size difference
        # http://qt-project.org/forums/viewthread/27201
        # Win/linux use 96 ppi, OS X uses 72 -&gt; 133% ratio
        size = int(size*1.33333+0.4999)

    # Done
    return QtGui.QFont(family, size)

</t>
<t tx="ekr.20190812072047.76">@path pyzo/codeeditor/
# -*- coding: utf-8 -*-
@nopyflakes
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072047.77">""" Module misc
Defined ustr (Unicode string) class and the option property decorator.
"""

import sys
from .qt import QtGui, QtCore, QtWidgets  # noqa

# Set Python version and get some names
PYTHON_VERSION = sys.version_info[0]
if PYTHON_VERSION &lt; 3:
    ustr = unicode  # noqa
    bstr = str
    from Queue import Queue, Empty
else:
    ustr = str
    bstr = bytes
    from queue import Queue, Empty

DEFAULT_OPTION_NAME = '_ce_default_value'
DEFAULT_OPTION_NONE = '_+_just some absurd value_+_'
</t>
<t tx="ekr.20190812072047.78">def ce_option(arg1):
    """ Decorator for properties of the code editor.

    It should be used on the setter function, with its default value
    as an argument. The default value is then  stored on the function
    object.

    At the end of the initialization, the base codeeditor class will
    check all members and (by using the default-value-attribute as a
    flag) select the ones that are options. These are then set to
    their default values.

    Similarly this information is used by the setOptions method to
    know which members are "options".

    """

    # If the decorator is used without arguments, arg1 is the function
    # being decorated. If arguments are used, arg1 is the argument, and
    # we should return a callable that is then used as a decorator.

    # Create decorator function.
    def decorator_fun(f):
        f.__dict__[DEFAULT_OPTION_NAME] = default
        return f

    # Handle
    default = DEFAULT_OPTION_NONE
    if hasattr(arg1, '__call__'):
        return decorator_fun(arg1)
    else:
        default = arg1
        return decorator_fun
</t>
<t tx="ekr.20190812072047.79">class _CallbackEventHandler(QtCore.QObject):
    """ Helper class to provide the callLater function.
    """

    @others
</t>
<t tx="ekr.20190812072047.8">def event(self, event):
    if isinstance(event, QtGui.QFileOpenEvent):
        fname = str(event.file())
        if fname and fname != 'pyzo':
            sys.argv[1:] = []
            sys.argv.append(fname)
            res = commandline.handle_cmd_args()
            if not commandline.is_our_server_running():
                print(res)
                sys.exit()
    return QtWidgets.QApplication.event(self, event)

</t>
<t tx="ekr.20190812072047.80">def __init__(self):
    QtCore.QObject.__init__(self)
    self.queue = Queue()
</t>
<t tx="ekr.20190812072047.81">def customEvent(self, event):
    while True:
        try:
            callback, args = self.queue.get_nowait()
        except Empty:
            break
        try:
            callback(*args)
        except Exception as why:
            print('callback failed: {}:\n{}'.format(callback, why))
</t>
<t tx="ekr.20190812072047.82">def postEventWithCallback(self, callback, *args):
    self.queue.put((callback, args))
    QtWidgets.qApp.postEvent(self, QtCore.QEvent(QtCore.QEvent.User))
</t>
<t tx="ekr.20190812072047.83">def callLater(callback, *args):
    """ callLater(callback, *args)

    Post a callback to be called in the main thread.

    """
    _callbackEventHandler.postEventWithCallback(callback, *args)

# Create callback event handler instance and insert function in Pyzo namespace
_callbackEventHandler = _CallbackEventHandler()
</t>
<t tx="ekr.20190812072047.84">@path pyzo/codeeditor/
# This is the one place where codeeditor depends on Pyzo itself
@others
@language python
@tabwidth -4
@nopyflakes
</t>
<t tx="ekr.20190812072047.85">from pyzo.util.qt import QtCore, QtGui, QtWidgets  # noqa
</t>
<t tx="ekr.20190812072047.86">@path pyzo/codeeditor/
# -*- coding: utf-8 -*-
""" Modyule style

Provides basic functionaliy for styling.

Styling is done using a dictionary of StyleFormat instances. Each
such instance reprsents a certain element being styled (e.g. keywords,
line numbers, indentation guides).

All possible style elements are represented using StyleElementDescription
instances. These have a name, description and default format, which
makes it easy to build a UI to allow the user to change the syle.

"""
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072047.87">from .qt import QtGui, QtCore
Qt = QtCore.Qt
</t>
<t tx="ekr.20190812072047.88">class StyleElementDescription:
    """ StyleElementDescription(name, defaultFormat, description)

    Describes a style element by its name, default format, and description.

    A style description is a simple placeholder for something
    that can be styled.

    """

    @others
</t>
<t tx="ekr.20190812072047.89">def __init__(self, name, description, defaultFormat):
    self._name = name
    self._description = description
    self._defaultFormat = StyleFormat(defaultFormat)
</t>
<t tx="ekr.20190812072047.9">if 0: # Leo now installs its own excepthook.

    def pyzo_excepthook(type, value, tb):

        out = 'Uncaught Python exception: ' + str(value) + '\n'
        out += ''.join(traceback.format_list(traceback.extract_tb(tb)))
        out += '\n'
        sys.stderr.write(out)
    
    sys.excepthook = pyzo_excepthook
## Define some functions

# todo: move some stuff out of this module ...
</t>
<t tx="ekr.20190812072047.90">def __repr__(self):
    return '&lt;"%s": "%s"&gt;' % (self.name, self.defaultFormat)
</t>
<t tx="ekr.20190812072047.91">@property
def name(self):
    return self._name
</t>
<t tx="ekr.20190812072047.92">@property
def key(self):
    return self._name.replace(' ', '').lower()
</t>
<t tx="ekr.20190812072047.93">@property
def description(self):
    return self._description
</t>
<t tx="ekr.20190812072047.94">@property
def defaultFormat(self):
    return self._defaultFormat
</t>
<t tx="ekr.20190812072047.95">class StyleFormat:
    """ StyleFormat(format='')

    Represents the style format for a specific style element.
    A "style" is a dictionary that maps names (of style elements)
    to StyleFormat instances.

    The given format can be a string or another StyleFormat instance.
    Style formats can be combined using their update() method.

    A style format consists of multiple parts, where each "part" consists
    of a key and a value. The keys can be anything, depending
    on what kind of thing is being styled. The value can be obtained using
    the index operator (e.g. styleFomat['fore'])

    For a few special keys, properties are defined that return the Qt object
    corresponding to the value. These values are also buffered to enable
    fast access. These keys are:
      * fore: (QColor) the foreground color
      * back: (QColor) the background color
      * bold: (bool) whether the text should be bold
      * italic: (bool) whether the text should be in italic
      * underline: (int) whether an underline should be used (and which one)
      * linestyle: (int) what line style to use (e.g. for indent guides)
      * textCharFOrmat: (QTextCharFormat) for the syntax styles

    The format neglects spaces and case. Parts are separated by commas
    or semicolons. If only a key is given it's value is interpreted
    as 'yes'. If only a color is given, its key is interpreted as 'fore'
    and back. Colors should be given using the '#' hex formatting.

    An example format string: 'fore:#334, bold, underline:dotLine'

    By calling str(styleFormatInstance) the string representing of the
    format can be obtained. By iterating over the instance, a series
    of key-value pairs is obtained.

    """

    @others
</t>
<t tx="ekr.20190812072047.96">def __init__(self, format=''):
    self._parts = {}
    self.update(format)
</t>
<t tx="ekr.20190812072047.97">def _resetProperties(self):
    self._fore = None
    self._back = None
    self._bold = None
    self._italic = None
    self._underline = None
    self._linestyle = None
    self._textCharFormat = None
</t>
<t tx="ekr.20190812072047.98">def __str__(self):
    """ Get a (cleaned up) string representation of this style format.
    """
    parts = []
    for key in self._parts:
        parts.append('%s:%s' % (key, self._parts[key]))
    return ', '.join(parts)
</t>
<t tx="ekr.20190812072047.99">def __repr__(self):
    return '&lt;StyleFormat "%s"&gt;' % str(self)
</t>
<t tx="ekr.20190812072048.1">def autocompleteShow(self, offset=0, names=None):
    """
    Pop-up the autocompleter (if not already visible) and position it at current
    cursor position minus offset. If names is given and not None, it is set
    as the list of possible completions.
    """
    #Pop-up the autocompleteList
    startcursor=self.textCursor()
    startcursor.movePosition(startcursor.Left, n=offset)

    if self.__autocompleteDebug:
        print('autocompleteShow called')

    if names is not None:
        #TODO: a more intelligent implementation that adds new items and removes
        #old ones
        if names != self.__completerNames:
            self.__completerModel.setStringList(names)
            self.__completerNames = names

    if not self.autocompleteActive() or \
        startcursor.position() != self.__autocompleteStart.position():

        self.__autocompleteStart=startcursor
        self.__autocompleteStart.setKeepPositionOnInsert(True)

        #Popup the autocompleter. Don't use .complete() since we want to
        #position the popup manually
        self.__positionAutocompleter()
        if self.__updateAutocompleterPrefix():
            self.__completer.popup().show()
        if self.__autocompleteDebug:
            print('self.__completer.popup().show() called')

    else:
        self.__updateAutocompleterPrefix()
</t>
<t tx="ekr.20190812072048.10">@path pyzo/codeeditor/extensions/
@nopyflakes
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.100">def __len__(self):
    # Defining a length also gives a Token a boolean value: True if there
    # are any characters (len!=0) and False if there are none
    return self.end - self.start
</t>
<t tx="ekr.20190812072048.101">def _getName(self):
    """ Get the name of this token. """
    nameParts = ['Syntax']
    if '_parser' in self.__module__:
        language = self.__module__.split('_')[0]
        language = language.split('.')[-1]
        nameParts.append( language[0].upper() + language[1:] )
    nameParts.append( self.__class__.__name__[:-5].lower() )
    return '.'.join(nameParts)
</t>
<t tx="ekr.20190812072048.102">def getDefaultStyleFormat(self):
    elements = []
    def collect(cls):
        if hasattr(cls, 'defaultStyle'):
            elements.append(cls.defaultStyle)
            for c in cls.__bases__:
                collect(c)
    collect(self.__class__)
    se = StyleFormat()
    for e in reversed(elements):
        se.update(e)
    return se
</t>
<t tx="ekr.20190812072048.103">@property
def name(self):
    """ The name of this token. Used to identify it and attach a style.
    """
    return self._name
</t>
<t tx="ekr.20190812072048.104">@property
def description(self):
    """ description()

    Returns a StyleElementDescription instance that describes the
    style element that this token represents.

    """
    format = self.getDefaultStyleFormat()
    des = 'syntax: ' + self.__doc__
    return StyleElementDescription(self.name, des, str(format))
</t>
<t tx="ekr.20190812072048.105">class CommentToken(Token):
    """ Characters representing a comment in the code. """
    defaultStyle = 'fore:#007F00'
</t>
<t tx="ekr.20190812072048.106">class TodoCommentToken(CommentToken):
    """ Characters representing a comment in the code. """
    defaultStyle = 'fore:#E00,italic'
</t>
<t tx="ekr.20190812072048.107">class StringToken(Token):
    """ Characters representing a textual string in the code. """
    defaultStyle = 'fore:#7F007F'
</t>
<t tx="ekr.20190812072048.108">class UnterminatedStringToken(StringToken):
    """ Characters belonging to an unterminated string. """
    defaultStyle = 'underline:dotted'

# todo: request from user: whitespace token
</t>
<t tx="ekr.20190812072048.109">class TextToken(Token):
    """ Anything that is not a string or comment. """
    defaultStyle = 'fore:#000'
</t>
<t tx="ekr.20190812072048.11"># -*- coding: utf-8 -*-
"""
Code editor extensions that change its behaviour (i.e. how it reacts to keys)
"""

from ..qt import QtGui,QtCore
Qt = QtCore.Qt

import pyzo
from ..misc import ustr, ce_option
from ..parsers.tokens import (CommentToken, IdentifierToken, NonIdentifierToken, ParenthesisToken,
                              StringToken, UnterminatedStringToken)
from ..parsers.python_parser import MultilineStringToken
from ..parsers import BlockState
</t>
<t tx="ekr.20190812072048.110">class IdentifierToken(TextToken):
    """ Characters representing normal text (i.e. words). """
    defaultStyle = ''
</t>
<t tx="ekr.20190812072048.111">class NonIdentifierToken(TextToken):
    """ Not a word (operators, whitespace, etc.). """
    defaultStyle = ''
</t>
<t tx="ekr.20190812072048.112">class KeywordToken(IdentifierToken):
    """ A keyword is a word with a special meaning to the language. """
    defaultStyle = 'fore:#00007F, bold:yes'
</t>
<t tx="ekr.20190812072048.113">class BuiltinsToken(IdentifierToken):
    """ Characters representing a builtins in the code. """
    defaultStyle = ''
</t>
<t tx="ekr.20190812072048.114">class InstanceToken(IdentifierToken):
    """ Characters representing a instance in the code. """
    defaultStyle = ''
</t>
<t tx="ekr.20190812072048.115">class NumberToken(IdentifierToken):
    """ Characters represening a number. """
    defaultStyle = 'fore:#007F7F'
</t>
<t tx="ekr.20190812072048.116">class FunctionNameToken(IdentifierToken):
    """ Characters represening the name of a function. """
    defaultStyle = 'fore:#007F7F, bold:yes'
</t>
<t tx="ekr.20190812072048.117">class ClassNameToken(IdentifierToken):
    """ Characters represening the name of a class. """
    defaultStyle = 'fore:#0000FF, bold:yes'
</t>
<t tx="ekr.20190812072048.118">class ParenthesisToken(TextToken) :
    """ Parenthesis (and square and curly brackets). """
    defaultStyle = ''
</t>
<t tx="ekr.20190812072048.119">class OpenParenToken(ParenthesisToken) :
    """ Opening parenthesis (and square and curly brackets). """
    defaultStyle = ''
</t>
<t tx="ekr.20190812072048.12">class MoveLinesUpDown(object): # tag:CodeEditor

    @others
</t>
<t tx="ekr.20190812072048.120">class CloseParenToken(ParenthesisToken) :
    """ Closing parenthesis (and square and curly brackets). """
    defaultStyle = ''
</t>
<t tx="ekr.20190812072048.121">@path pyzo/codeeditor/parsers/
@nopyflakes
@others
## Import parsers statically
# We could load the parser dynamically from the source files in the
# directory, but this takes quite some effort to get righ when apps
# are frozen. This is doable (I do it in Visvis) but it requires the
# user to specify the parser modules by hand when freezing an app.
#
# In summary: it takes a lot of trouble, which can be avoided by just
# listing all parsers here.
from . import (     python_parser,  # noqa
                    cython_parser,  # noqa
                    c_parser,  # noqa
                    s_expr_parser,  # noqa
              )
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.122"># -*- coding: utf-8 -*-
""" Subpackage parsers

This subpackage contains all the syntax parsers for the
different languages.

"""

""" CREATING PARSERS

Making a parser requires these things:
  * Place a module in the parsers directory, which has a name
    ending in "_parser.py"
  * In the module implement one or more classes that inherit
    from ..parsers.Parser (or a derived class), and
    implement the parseLine method.
  * The module should import all the tokens in whiches to use
    from ..parsers.tokens. New tokens can also be
    defined by subclassing one of the token classes.
  * In codeeditor/parsers/__init__.py, add the new module to the
    list of imported parsers.

"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('IMPORT pyzo.codeeditor.parsers')
except Exception:
    leo_g = None

import sys
from . import tokens

if sys.version_info[0] &gt;= 3:
    text_type = str
else:
    text_type = unicode  # noqa

</t>
<t tx="ekr.20190812072048.123">class BlockState(object):
    """ BlockState(state=0, info=None)

    The blockstate object should be used by parsers to
    return the block state of the processed line.

    This would typically be the last item to be yielded, but this
    it may also be yielded befor the last yielded token. One can even
    yield multiple of these items, in which case the last one considered
    valid.

    """
    isToken = False
    @others
</t>
<t tx="ekr.20190812072048.124">def __init__(self, state=0, info=None):
    self._state = int(state)
    self._info = info
</t>
<t tx="ekr.20190812072048.125">@property
def state(self):
    """ The integer value representing the block state.
    """
    return self._state
</t>
<t tx="ekr.20190812072048.126">@property
def info(self):
    """ Get the information corresponding to the block.
    """
    return self._info

</t>
<t tx="ekr.20190812072048.127"># Base parser class (needs to be defined before importing parser modules)
class Parser(object):
    """ Base parser class.
    All parsers should inherit from this class.
    This base class generates a 'TextToken' for each line
    """
    _extensions = []
    _shebangKeywords = []
    _keywords = []

    @others
</t>
<t tx="ekr.20190812072048.128">def parseLine(self, line, previousState=0):
    """ parseLine(line, previousState=0)

    The method that should be implemented by the parser. The
    previousState argument can be used to determine how
    the previous block ended (e.g. for multiline comments). It
    is an integer, the meaning of which is only known to the
    specific parser.

    This method should yield token instances. The last token can
    be a BlockState to specify the previousState for the
    next block.

    """

    yield tokens.TextToken(line,0,len(line))
</t>
<t tx="ekr.20190812072048.129">def name(self):
    """ name()

    Get the name of the parser.

    """
    name = self.__class__.__name__.lower()
    if name.endswith('parser'):
        name = name[:-6]
    return name
</t>
<t tx="ekr.20190812072048.13">def keyPressEvent(self,event):
    if event.key() in (Qt.Key_Up, Qt.Key_Down) and (
                                Qt.ControlModifier &amp; event.modifiers() and
                                Qt.ShiftModifier &amp; event.modifiers()):

        cursor = self.textCursor()
        cursor.beginEditBlock()
        try:
            self._swaplines(cursor, event.key())
        finally:
            cursor.endEditBlock()

    else:
        super().keyPressEvent(event)
</t>
<t tx="ekr.20190812072048.130">def __repr__(self):
    """ String representation of the parser.
    """
    return '&lt;Parser for "%s"&gt;' % self.name()
</t>
<t tx="ekr.20190812072048.131">def keywords(self):
    """ keywords()

    Get a list of keywords valid for this parser.

    """
    return [k for k in self._keywords]
</t>
<t tx="ekr.20190812072048.132">def filenameExtensions(self):
    """ filenameExtensions()

    Get a list of filename extensions for which this parser
    is appropriate.

    """
    return ['.'+e.lstrip('.').lower() for e in self._extensions]
</t>
<t tx="ekr.20190812072048.133">def shebangKeywords(self):
    """ shebangKeywords()

    Get a list of shebang keywords for which this parser
    is appropriate.

    """
    return self._shebangKeywords.copy()
</t>
<t tx="ekr.20190812072048.134">def getStyleElementDescriptions(cls):
    """ getStyleElementDescriptions()

    This method returns a list of the StyleElementDescription
    instances used by this parser.

    """
    descriptions = {}
    for token in cls.getUsedTokens(cls):
        descriptions[token.description.key] = token.description

    return list(descriptions.values())
</t>
<t tx="ekr.20190812072048.135">def getUsedTokens(self):
    """ getUsedTokens()

    Get a a list of token instances used by this parser.

    """

    # Get module object of the parser
    try:
        mod = sys.modules[self.__module__]
    except KeyError:
        return []

    # Get token classes from module
    tokenClasses = []
    for name in mod.__dict__:
        member = mod.__dict__[name]
        if isinstance(member, type) and \
                                issubclass(member, tokens.Token):
            if member is not tokens.Token:
                tokenClasses.append(member)

    # Return as instances
    return [t() for t in tokenClasses]
</t>
<t tx="ekr.20190812072048.136">def _isTodoItem(self, text):
    """ _isTodoItem(text)

    Get whether the given text (which should be a comment) represents
    a todo item. Todo items start with "todo", "2do" or "fixme",
    optionally with a colon at the end.

    """
    # Get first word
    word = text.lstrip().split(' ',1)[0].rstrip(':')
    # Test
    if word.lower() in ['todo', '2do', 'fixme']:
        return True
    else:
        return False

</t>
<t tx="ekr.20190812072048.138"></t>
<t tx="ekr.20190812072048.139">@path pyzo/core/

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.14">def _swaplines(self, cursor, key):

    # Get positions of selection
    start = cursor.selectionStart()
    end = cursor.selectionEnd()

    # Get text of selected blocks
    cursor.setPosition(start, cursor.MoveAnchor)
    cursor.movePosition(cursor.StartOfBlock, cursor.MoveAnchor)
    cursor.setPosition(end, cursor.KeepAnchor)
    cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
    text1 = cursor.selectedText()
    cursor.removeSelectedText()
    pos1 = cursor.position()

    # Move up/down
    other = [cursor.NextBlock, cursor.PreviousBlock][int(bool(key == Qt.Key_Up))]
    cursor.movePosition(other, cursor.MoveAnchor)

    # Select text of other block
    cursor.movePosition(cursor.StartOfBlock, cursor.MoveAnchor)
    cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
    text2 = cursor.selectedText()
    cursor.removeSelectedText()
    pos2 = cursor.position()

    # Insert text
    cursor.insertText(text1)
    pos3 = cursor.position()

    # Move back
    if key == Qt.Key_Up:
        cursor.movePosition(cursor.NextBlock, cursor.MoveAnchor)
    else:
        cursor.setPosition(pos1, cursor.MoveAnchor)
        pos2 += len(text2)
        pos3 += len(text2)

    # Replace text
    cursor.insertText(text2)

    # Leave original lines selected for continued movement
    cursor.setPosition(pos2, cursor.MoveAnchor)
    cursor.setPosition(pos3, cursor.KeepAnchor)
    self.setTextCursor(cursor)
</t>
<t tx="ekr.20190812072048.140">import os
import sys

from pyzo.util.qt import QtCore, QtGui, QtWidgets
from pyzo.util import qt

import pyzo
from pyzo.util import paths
</t>
<t tx="ekr.20190812072048.141">class AboutDialog(QtWidgets.QDialog):
    @others
if __name__ == '__main__':
    #pyzo.license = {'name': 'AK', 'company': ''}
    m = AboutDialog(None)
    m.show()
</t>
<t tx="ekr.20190812072048.142">def __init__(self, parent):
    QtWidgets.QDialog.__init__(self, parent)
    self.setWindowTitle(pyzo.translate("menu dialog", "About Pyzo"))
    self.resize(600,500)

    # Layout
    layout = QtWidgets.QVBoxLayout(self)
    self.setLayout(layout)

    # Create image and title
    im = QtGui.QPixmap( os.path.join(pyzo.pyzoDir,
                        'resources', 'appicons', 'pyzologo64.png') )
    imlabel = QtWidgets.QLabel(self)
    imlabel.setPixmap(im)
    textlabel = QtWidgets.QLabel(self)
    textlabel.setText('&lt;h3&gt;Pyzo: the Interactive Editor for Python&lt;/h3&gt;')
    #
    titleLayout = QtWidgets.QHBoxLayout()
    titleLayout.addWidget(imlabel, 0)
    titleLayout.addWidget(textlabel, 1)
    #
    layout.addLayout(titleLayout, 0)

    # Create tab bar
    self._tabs = QtWidgets.QTabWidget(self)
    self._tabs.setDocumentMode(True)
    layout.addWidget(self._tabs, 1)

    # Create button box
    self._butBox = QtWidgets.QDialogButtonBox(self)
    self._butBox.setOrientation(QtCore.Qt.Horizontal)
    self._butBox.setStandardButtons(self._butBox.Close)
    layout.addWidget(self._butBox, 0)

    # Signals
    self._butBox.rejected.connect(self.close)

    # Create tabs
    self.createGeneralTab()
    self.createContributorsTab()
    self.createLicenseTab()
</t>
<t tx="ekr.20190812072048.143">def addTab(self, title, text, rich=True):
    # Create label to show info
    label = QtWidgets.QTextEdit(self)
    label.setLineWrapMode(label.WidgetWidth)
    label.setReadOnly(True)
    # Set text
    if rich:
        label.setHtml(text)
    else:
        label.setText(text)
    # Add to tab bar
    self._tabs.addTab(label, title)
    # Done
    return label
</t>
<t tx="ekr.20190812072048.144">def createGeneralTab(self):
    aboutText = """
    {}&lt;br&gt;&lt;br&gt;

    &lt;b&gt;Version info&lt;/b&gt;&lt;br&gt;
    Pyzo version: &lt;u&gt;{}&lt;/u&gt;&lt;br&gt;
    Platform: {}&lt;br&gt;
    Python version: {}&lt;br&gt;
    Qt version: {}&lt;br&gt;
    {} version: {}&lt;br&gt;
    &lt;br&gt;

    &lt;b&gt;Pyzo directories&lt;/b&gt;&lt;br&gt;
    Pyzo source directory: {}&lt;br&gt;
    Pyzo userdata directory: {}&lt;br&gt;
    &lt;br&gt;

    &lt;b&gt;Acknowledgements&lt;/b&gt;&lt;br&gt;
    Pyzo is written in Python 3 and uses the Qt widget
    toolkit. Pyzo uses code and concepts that are inspired by
    IPython, Pype, and Spyder.
    Pyzo uses a (modified) subset of the silk icon set,
    by Mark James (http://www.famfamfam.com/lab/icons/silk/).
    """
    # Determine if this is PyQt4 or Pyside
    qtWrapper = qt.API_NAME
    qtVersion = qt.QT_VERSION
    qtWrapperVersion = qt.PYSIDE_VERSION or qt.PYQT_VERSION
    # Insert information texts
    if paths.is_frozen():
        versionText = pyzo.__version__ + ' (binary)'
    else:
        versionText = pyzo.__version__ + ' (source)'
    aboutText = aboutText.format('Pyzo - Python to the people!',
                    versionText,
                    sys.platform,
                    sys.version.split(' ')[0],
                    qtVersion, qtWrapper, qtWrapperVersion,
                    pyzo.pyzoDir, pyzo.appDataDir)

    self.addTab("General", aboutText)
</t>
<t tx="ekr.20190812072048.145">def createContributorsTab(self):
    fname = os.path.join(pyzo.pyzoDir, 'contributors.txt')
    try:
        with open(fname, 'rb') as f:
            text = f.read().decode('utf-8', 'ignore').strip()
    except Exception as err:
        text = str(err)
    label = self.addTab('Contributors', text, False)
    # Decrease font
    font = label.font()
    font.setPointSize(int(font.pointSize()*0.9))
    label.setFont(font)
</t>
<t tx="ekr.20190812072048.146">def createLicenseTab(self):
    fname = os.path.join(pyzo.pyzoDir, 'license.txt')
    try:
        with open(fname, 'rb') as f:
            text = f.read().decode('utf-8', 'ignore').strip()
    except Exception as err:
        text = str(err)
    label = self.addTab('BSD license', text, False)
    # Decrease font
    font = label.font()
    font.setPointSize(int(font.pointSize()*0.9))
    label.setFont(font)
</t>
<t tx="ekr.20190812072048.147">@path pyzo/core/
# -*- coding: utf-8 -*-
# Author: Windel Bouwman
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.148">"""
Tool that can view qt help files via the qthelp engine.

Run make_docs.sh from:
https://bitbucket.org/windel/qthelpdocs

Copy the "docs" directory to the pyzo root!

"""

from pyzo.util.qt import QtCore, QtGui, QtWidgets  # noqa
from pyzo import getResourceDirs
import os

help_help = """
&lt;h1&gt;Documentation&lt;/h1&gt;
&lt;p&gt;
Welcome to the Pyzo assistant. Pyzo uses the Qt Help system for documentation.
This is also used by the Qt Assistant. You can use this viewer
to view documentation provided by other projects.
&lt;/p&gt;

&lt;h2&gt;Add documentation&lt;/h2&gt;
&lt;p&gt;
To add documentation to Pyzo, go to the settings tab and select add. Then
select a Qt Compressed Help file (*.qch). qch-files can be found in the Qt
installation directory (for example in /usr/share/doc/qt under linux). For
other projects you can download pre-build qch files from here:
&lt;a href="https://github.com/windelbouwman/qthelpdocs/releases"&gt;https://github.com/windelbouwman/qthelpdocs/releases&lt;/a&gt;.

&lt;/p&gt;

&lt;p&gt;
&lt;strong&gt;Note&lt;/strong&gt;
When a documentation file is added, it is not copied into the pyzo settings
dir, so you have to leave this file in place.
&lt;/p&gt;

"""

tool_name = "Assistant"
tool_summary = "Browse qt help documents"
</t>
<t tx="ekr.20190812072048.149">class Settings(QtWidgets.QWidget):
    @others
</t>
<t tx="ekr.20190812072048.15">class ScrollWithUpDownKeys(object): # tag:CodeEditor

    @others
</t>
<t tx="ekr.20190812072048.150">def __init__(self, engine):
    super().__init__()
    self._engine = engine
    layout = QtWidgets.QVBoxLayout(self)
    add_button = QtWidgets.QPushButton("Add")
    del_button = QtWidgets.QPushButton("Delete")
    self._view = QtWidgets.QListView()
    layout.addWidget(self._view)
    layout2 = QtWidgets.QHBoxLayout()
    layout2.addWidget(add_button)
    layout2.addWidget(del_button)
    layout.addLayout(layout2)
    self._model = QtCore.QStringListModel()
    self._view.setModel(self._model)

    self._model.setStringList(self._engine.registeredDocumentations())

    add_button.clicked.connect(self.add_doc)
    del_button.clicked.connect(self.del_doc)
</t>
<t tx="ekr.20190812072048.151">def add_doc(self):
    doc_file = QtWidgets.QFileDialog.getOpenFileName(
        self,
        "Select a compressed help file",
        filter="Qt compressed help files (*.qch)")
    if isinstance(doc_file, tuple):
        doc_file = doc_file[0]
    self.add_doc_do(doc_file)
</t>
<t tx="ekr.20190812072048.152">def add_doc_do(self, doc_file):
    ok = self._engine.registerDocumentation(doc_file)
    if ok:
        self._model.setStringList(self._engine.registeredDocumentations())
    else:
        QtWidgets.QMessageBox.critical(self, "Error", "Error loading doc")
</t>
<t tx="ekr.20190812072048.153">def del_doc(self):
    idx = self._view.currentIndex()
    if idx.isValid():
        doc_file = self._model.data(idx, QtCore.Qt.DisplayRole)
        self.del_doc_do(doc_file)
</t>
<t tx="ekr.20190812072048.154">def del_doc_do(self, doc_file):
    self._engine.unregisterDocumentation(doc_file)
    self._model.setStringList(self._engine.registeredDocumentations())
</t>
<t tx="ekr.20190812072048.155">class HelpBrowser(QtWidgets.QTextBrowser):
    """ Override textbrowser to implement load resource """
    @others
</t>
<t tx="ekr.20190812072048.156">def __init__(self, engine):
    super().__init__()
    self._engine = engine

    # Override default navigation behavior:
    self.anchorClicked.connect(self.handle_url)
    self.setOpenLinks(False)
</t>
<t tx="ekr.20190812072048.157">def handle_url(self, url):
    """ Open external urls not in this viewer """
    if url.scheme() in ['http', 'https']:
        QtGui.QDesktopServices.openUrl(url)
    else:
        self.setSource(url)
</t>
<t tx="ekr.20190812072048.158">def loadResource(self, typ, url):
    if url.scheme() == "qthelp":
        return self._engine.fileData(url)
    else:
        return super().loadResource(typ, url)
</t>
<t tx="ekr.20190812072048.159">class PyzoAssistant(QtWidgets.QWidget):
    """
        Show help contents and browse qt help files.
    """
    @others
if __name__ == '__main__':
    app = QtWidgets.QApplication([])
    view = PyzoAssistant()
    view.show()
    app.exec()
</t>
<t tx="ekr.20190812072048.16">def keyPressEvent(self,event):
    if event.key() in (Qt.Key_Up, Qt.Key_Down) and Qt.ControlModifier == event.modifiers():
        s = self.verticalScrollBar()
        # h = self.cursorRect(self.textCursor()).height()
        if event.key() == Qt.Key_Up:
            s.setValue(s.value() + 1)
        else:
            s.setValue(s.value() - 1)

    else:
        super().keyPressEvent(event)
</t>
<t tx="ekr.20190812072048.160">def __init__(self, parent=None, collection_filename=None):
    """
        Initializes an assistance instance.
        When collection_file is none, it is determined from the
        appDataDir.
    """
    from pyzo.util.qt import QtHelp
    super().__init__(parent)
    self.setWindowTitle('Help')
    pyzoDir, appDataDir = getResourceDirs()
    if collection_filename is None:
        # Collection file is stored in pyzo data dir:
        collection_filename = os.path.join(appDataDir, 'tools', 'docs.qhc')
    self._engine = QtHelp.QHelpEngine(collection_filename)

    # Important, call setup data to load the files:
    self._engine.setupData()

    # If no files are loaded, register at least the pyzo docs:
    if len(self._engine.registeredDocumentations()) == 0:
        doc_file = os.path.join(pyzoDir, 'resources', 'pyzo.qch')
        self._engine.registerDocumentation(doc_file)

    # The main players:
    self._content = self._engine.contentWidget()
    self._index = self._engine.indexWidget()
    self._indexTab = QtWidgets.QWidget()
    il = QtWidgets.QVBoxLayout(self._indexTab)
    filter_text = QtWidgets.QLineEdit()
    il.addWidget(filter_text)
    il.addWidget(self._index)

    self._helpBrowser = HelpBrowser(self._engine)
    self._searchEngine = self._engine.searchEngine()
    self._settings = Settings(self._engine)

    self._progress = QtWidgets.QWidget()
    pl = QtWidgets.QHBoxLayout(self._progress)
    bar = QtWidgets.QProgressBar()
    bar.setMaximum(0)
    pl.addWidget(QtWidgets.QLabel('Indexing'))
    pl.addWidget(bar)

    self._searchResultWidget = self._searchEngine.resultWidget()
    self._searchQueryWidget = self._searchEngine.queryWidget()
    self._searchTab = QtWidgets.QWidget()
    search_layout = QtWidgets.QVBoxLayout(self._searchTab)
    search_layout.addWidget(self._searchQueryWidget)
    search_layout.addWidget(self._searchResultWidget)

    tab = QtWidgets.QTabWidget()
    tab.addTab(self._content, "Contents")
    tab.addTab(self._indexTab, "Index")
    tab.addTab(self._searchTab, "Search")
    tab.addTab(self._settings, "Settings")

    splitter = QtWidgets.QSplitter(self)
    splitter.addWidget(tab)
    splitter.addWidget(self._helpBrowser)

    layout = QtWidgets.QVBoxLayout(self)
    layout.addWidget(splitter)
    layout.addWidget(self._progress)

    # Connect clicks:
    self._content.linkActivated.connect(self._helpBrowser.setSource)
    self._index.linkActivated.connect(self._helpBrowser.setSource)
    self._searchEngine.searchingFinished.connect(self.onSearchFinish)
    self._searchEngine.indexingStarted.connect(self.onIndexingStarted)
    self._searchEngine.indexingFinished.connect(self.onIndexingFinished)
    filter_text.textChanged.connect(self._index.filterIndices)
    self._searchResultWidget.requestShowLink.connect(self._helpBrowser.setSource)
    self._searchQueryWidget.search.connect(self.goSearch)

    # Always re-index on startup:
    self._searchEngine.reindexDocumentation()

    self._search_term = None

    # Show initial page:
    # self.showHelpForTerm('welcome to pyzo')
    self._helpBrowser.setHtml(help_help)
</t>
<t tx="ekr.20190812072048.161">def goSearch(self):
    query = self._searchQueryWidget.query()
    self._searchEngine.search(query)
</t>
<t tx="ekr.20190812072048.162">def onIndexingStarted(self):
    self._progress.show()
</t>
<t tx="ekr.20190812072048.163">def onIndexingFinished(self):
    self._progress.hide()
</t>
<t tx="ekr.20190812072048.164">def find_best_page(self, hits):
    if self._search_term is None:
        url, _ = hits[0]
        return url

    try:
        # Try to find max with fuzzy wuzzy:
        from fuzzywuzzy import fuzz
        url, title = max(hits, key=lambda hit: fuzz.ratio(hit[1], self._search_term))
        return url
    except ImportError:
        pass

    # Find exact page title:
    for url2, page_title in hits:
        if page_title == self._search_term:
            url = url2
            return url

    for url2, page_title in hits:
        if self._search_term in page_title:
            url = url2
            return url

    # Pick first hit:
    url, _ = hits[0]
    return url
</t>
<t tx="ekr.20190812072048.165">def onSearchFinish(self, hits):
    if hits == 0:
        return
    hits = self._searchEngine.hits(0, hits)
    if not hits:
        return
    url = self.find_best_page(hits)
    self._helpBrowser.setSource(QtCore.QUrl(url))
</t>
<t tx="ekr.20190812072048.166">def showHelpForTerm(self, name):
    from pyzo.util.qt import QtHelp
    # Cache for later use:
    self._search_term = name

    # Create a query:
    query = QtHelp.QHelpSearchQuery(QtHelp.QHelpSearchQuery.DEFAULT, [name])
    self._searchEngine.search([query])
</t>
<t tx="ekr.20190812072048.167">@path pyzo/core/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.168"># -*- coding: utf-8 -*-
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo/core/baseTextCtrl.py')
except Exception:
    leo_g = None
""" Module baseTextCtrl

Defines the base text control to be inherited by the shell and editor
classes. Implements styling, introspection and a bit of other stuff that
is common for both shells and editors.

"""

import pyzo
import os, time
from pyzo.core.pyzoLogging import print
import pyzo.codeeditor.parsers.tokens as Tokens

from pyzo.util.qt import QtCore, QtGui, QtWidgets
qt = QtGui

# Define style stuff
subStyleStuff = {}

#subStyleStuff = {   'face': Qsci.QsciScintillaBase.SCI_STYLESETFONT ,
#                    'fore': Qsci.QsciScintillaBase.SCI_STYLESETFORE,
#                    'back': Qsci.QsciScintillaBase.SCI_STYLESETBACK,
#                    'size': Qsci.QsciScintillaBase.SCI_STYLESETSIZE,
#                    'bold': Qsci.QsciScintillaBase.SCI_STYLESETBOLD,
#                    'italic': Qsci.QsciScintillaBase.SCI_STYLESETITALIC,
#                    'underline': Qsci.QsciScintillaBase.SCI_STYLESETUNDERLINE}
</t>
<t tx="ekr.20190812072048.169">def normalizePath(path):
    """ Normalize the path given.
    All slashes will be made the same (and doubles removed)
    The real case as stored on the file system is recovered.
    Returns None on error.
    """

    # normalize
    path = os.path.abspath(path)  # make sure it is defined from the drive up
    path = os.path.normpath(path)

    # If does not exist, return as is.
    # This also happens if the path's case is incorrect and the
    # file system is case sensitive. That's ok, because the stuff we
    # do below is intended to get the path right on case insensitive
    # file systems.
    if not os.path.isfile(path):
        return path

    # split drive name from the rest
    drive, rest = os.path.splitdrive(path)
    fullpath = drive.upper() + os.sep

    # make lowercase and split in parts
    parts = rest.lower().split(os.sep)
    parts = [part for part in parts if part]

    for part in parts:
        options = [x for x in os.listdir(fullpath) if x.lower()==part]
        if len(options) &gt; 1:
            print("Error normalizing path: Ambiguous path names!")
            return path
        elif not options:
            print("Invalid path (part %s) in %s" % (part, fullpath))
            return path
        fullpath = os.path.join(fullpath, options[0])

    # remove last sep
    return fullpath
</t>
<t tx="ekr.20190812072048.17">class HomeKey(object): # tag:CodeEditor

    @others
</t>
<t tx="ekr.20190812072048.170">def parseLine_autocomplete(tokens):
    """ Given a list of tokens (from start to cursor position)
    returns a tuple (base, name).
    autocomp_parse("eat = banan") -&gt; "", "banan"
      ...("eat = food.fruit.ban") -&gt; "food.fruit", "ban"
    When no match found, both elements are an empty string.
    """
    if not len(tokens):
        return "",""

    if isinstance(tokens[-1],Tokens.NonIdentifierToken) and str(tokens[-1])=='.':
        name = ''
    elif isinstance(tokens[-1],(Tokens.IdentifierToken,Tokens.KeywordToken)):
        name = str(tokens[-1])
    else:
        return '',''

    needle = ''
    #Now go through the remaining tokens in reverse order
    for token in tokens[-2::-1]:
        if isinstance(token,Tokens.NonIdentifierToken) and str(token)=='.':
            needle = str(token) + needle
        elif isinstance(token,(Tokens.IdentifierToken,Tokens.KeywordToken)):
            needle = str(token) + needle
        else:
            break

    if needle.endswith('.'):
        needle = needle[:-1]

    return needle, name
</t>
<t tx="ekr.20190812072048.171">def parseLine_signature(tokens):
    """ Given a list of tokens (from start to cursor position)
    returns a tuple (name, needle, stats).
    stats is another tuple:
    - location of end bracket
    - amount of kommas till cursor (taking nested brackets into account)
    """

    openBraces = [] #Positions at which braces are opened
    for token in tokens:
        if not isinstance(token, (Tokens.NonIdentifierToken, Tokens.OpenParenToken)):
            continue
        for i, c in enumerate(str(token)):
            if c=='(':
                openBraces.append(token.start + i)
            elif c==')':
                if len(openBraces): openBraces.pop()

    if len(openBraces):
        i = openBraces[-1]
        # Now trim the token list up to (but not inculding) position of openBraces
        tokens = list(filter(lambda token: token.start &lt; i, tokens))

        # Trim the last token
        if len(tokens):
            tokens[-1].end = i

        name, needle = parseLine_autocomplete(tokens)
        return name, needle, (i,0) #TODO: implement stats

    return "","",(0,0)
</t>
<t tx="ekr.20190812072048.172">class KeyEvent:
    """ A simple class for easier key events. """
    @others
</t>
<t tx="ekr.20190812072048.173">def __init__(self, key):
    self.key = key
    try:
        self.char = chr(key)
    except ValueError:
        self.char = ""
</t>
<t tx="ekr.20190812072048.174">def makeBytes(text):
    """ Make sure the argument is bytes, converting with UTF-8 encoding
    if it is a string. """
    if isinstance(text, bytes):
        return text
    elif isinstance(text, str):
        return text.encode('utf-8')
    else:
        raise ValueError("Expected str or bytes!")

_allScintillas = []
</t>
<t tx="ekr.20190812072048.175">def getAllScintillas():
    """ Get a list of all the scintialla editing components that
    derive from BaseTextCtrl. Used mainly by the menu.
    """
    for i in reversed(range(len(_allScintillas))):
        e = _allScintillas[i]()
        if e is None:
            _allScintillas.pop(i)
        else:
            yield e
pyzo.getAllScintillas = getAllScintillas

from pyzo import codeeditor
</t>
<t tx="ekr.20190812072048.176">class BaseTextCtrl(codeeditor.CodeEditor):
    """ The base text control class.
    Inherited by the shell class and the Pyzo editor.
    The class implements autocompletion, calltips, and auto-help

    Inherits from QsciScintilla. I tried to clean up the rather dirty api
    by using more sensible names. Hereby I apply the following rules:
    - if you set something, the method starts with "set"
    - if you get something, the method starts with "get"
    - a position is the integer position fron the start of the document
    - a linenr is the number of a line, an index the position on that line
    - all the above indices apply to the bytes (encoded utf-8) in which the
      text is stored. If you have unicode text, they do not apply!
    - the method name mentions explicityly what you get. getBytes() returns the
      bytes of the document, getString() gets the unicode string that it
      represents. This applies to the get-methods. the set-methods use the
      term text, and automatically convert to bytes using UTF-8 encoding
      when a string is given.
    """

    @others
</t>
<t tx="ekr.20190812072048.177">def __init__(self, *args, **kwds):
    super().__init__(*args, **kwds)

    # Set font and zooming
    self.setFont(pyzo.config.view.fontname)
    self.setZoom(pyzo.config.view.zoom)

    # Create timer for autocompletion delay
    self._delayTimer = QtCore.QTimer(self)
    self._delayTimer.setSingleShot(True)
    self._delayTimer.timeout.connect(self._introspectNow)

    # For buffering autocompletion and calltip info
    self._callTipBuffer_name = ''
    self._callTipBuffer_time = 0
    self._callTipBuffer_result = ''
    self._autoCompBuffer_name = ''
    self._autoCompBuffer_time = 0
    self._autoCompBuffer_result = []

    self.setAutoCompletionAcceptKeysFromStr(pyzo.config.settings.autoComplete_acceptKeys)

    self.completer().highlighted.connect(self.updateHelp)
    self.setIndentUsingSpaces(pyzo.config.settings.defaultIndentUsingSpaces)
    self.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
    self.setAutocompletPopupSize(*pyzo.config.view.autoComplete_popupSize)
</t>
<t tx="ekr.20190812072048.178">def setAutoCompletionAcceptKeysFromStr(self, keys):
    """ Set the keys that can accept an autocompletion from a comma delimited string.
    """
    # Set autocomp accept key to default if necessary.
    # We force it to be string (see issue 134)
    if not isinstance(keys, str):
        keys = 'Tab'
    # Split
    keys = keys.replace(',', ' ').split(' ')
    keys = [key for key in keys if key]
    # Set autocomp accept keys
    qtKeys = []
    for key in keys:
        if len(key) &gt; 1:
            key = 'Key_' + key[0].upper() + key[1:].lower()
            qtkey = getattr(QtCore.Qt, key, None)
        else:
            qtkey = ord(key)
        if qtkey:
            qtKeys.append(qtkey)

    if QtCore.Qt.Key_Enter in qtKeys and QtCore.Qt.Key_Return not in qtKeys:
        qtKeys.append(QtCore.Qt.Key_Return)
    self.setAutoCompletionAcceptKeys(*qtKeys)
</t>
<t tx="ekr.20190812072048.179">def _isValidPython(self):
    """ _isValidPython()
    Check if the code at the cursor is valid python:
    - the active lexer is the python lexer
    - the style at the cursor is "default"
    """
    #TODO:
    return True
</t>
<t tx="ekr.20190812072048.18">def keyPressEvent(self,event):
    # Home or shift + home
    if event.key() == Qt.Key_Home and \
            event.modifiers() in (Qt.NoModifier, Qt.ShiftModifier):
        # Prepare
        cursor = self.textCursor()
        shiftDown = event.modifiers() == Qt.ShiftModifier
        moveMode = [cursor.MoveAnchor, cursor.KeepAnchor][shiftDown]
        # Get leading whitespace
        text = ustr(cursor.block().text())
        leadingWhitespace = text[:len(text)-len(text.lstrip())]
        # Get current position and move to start of whitespace
        i = cursor.positionInBlock()
        cursor.movePosition(cursor.StartOfBlock, moveMode)
        cursor.movePosition(cursor.Right, moveMode, len(leadingWhitespace))
        # If we were alread there, move to start of block
        if cursor.positionInBlock() == i:
            cursor.movePosition(cursor.StartOfBlock, moveMode)
        # Done
        self.setTextCursor(cursor)
    else:
        super().keyPressEvent(event)
</t>
<t tx="ekr.20190812072048.180">def introspect(self, tryAutoComp=False, delay=True):
    """ introspect(tryAutoComp=False, delay=True)

    The starting point for introspection (autocompletion and calltip).
    It will always try to produce a calltip. If tryAutoComp is True,
    will also try to produce an autocompletion list (which, on success,
    will hide the calltip).

    This method will obtain the line and (re)start a timer that will
    call _introspectNow() after a short while. This way, if the
    user types a lot of characters, there is not a stream of useless
    introspection attempts; the introspection is only really started
    after he stops typing for, say 0.1 or 0.5 seconds (depending on
    pyzo.config.autoCompDelay).

    The method _introspectNow() will parse the line to obtain
    information required to obtain the autocompletion and signature
    information. Then it calls processCallTip and processAutoComp
    which are implemented in the editor and shell classes.
    """

    # Find the tokens up to the cursor
    cursor = self.textCursor()

    # In order to find the tokens, we need the userState from the highlighter
    if cursor.block().previous().isValid():
        previousState = cursor.block().previous().userState()
    else:
        previousState = 0

    text = cursor.block().text()[:cursor.positionInBlock()]

    tokensUptoCursor = list(
            filter(lambda token:token.isToken, #filter to remove BlockStates
            self.parser().parseLine(text, previousState)))

    # TODO: Only proceed if valid python (no need to check for comments/
    # strings, this is done by the processing of the tokens). Check for python style

    # Is the char valid for auto completion?
    if tryAutoComp:
        if not text or not ( text[-1] in (Tokens.ALPHANUM + "._") ):
            self.autocompleteCancel()
            tryAutoComp = False

    # Store line and (re)start timer
    cursor.setKeepPositionOnInsert(True)
    self._delayTimer._tokensUptoCursor = tokensUptoCursor
    self._delayTimer._cursor = cursor
    self._delayTimer._tryAutoComp = tryAutoComp
    if delay:
        self._delayTimer.start(pyzo.config.advanced.autoCompDelay)
    else:
        self._delayTimer.start(1)  # self._introspectNow()
</t>
<t tx="ekr.20190812072048.181">def _introspectNow(self):
    """ This method is called a short while after introspect()
    by the timer. It parses the line and calls the specific methods
    to process the callTip and autoComp.
    """

    tokens = self._delayTimer._tokensUptoCursor

    if pyzo.config.settings.autoCallTip:
        # Parse the line, to get the name of the function we should calltip
        # if the name is empty/None, we should not show a signature
        name, needle, stats = parseLine_signature(tokens)

        if needle:
            # Compose actual name
            fullName = needle
            if name:
                fullName = name + '.' + needle
            # Process
            offset = self._delayTimer._cursor.positionInBlock() - stats[0] + len(needle)
            cto = CallTipObject(self, fullName, offset)
            self.processCallTip(cto)
        else:
            self.calltipCancel()

    if self._delayTimer._tryAutoComp and pyzo.config.settings.autoComplete:
        # Parse the line, to see what (partial) name we need to complete
        name, needle = parseLine_autocomplete(tokens)

        if name or needle:
            # Try to do auto completion
            aco = AutoCompObject(self, name, needle)
            self.processAutoComp(aco)
</t>
<t tx="ekr.20190812072048.182">def processCallTip(self, cto):
    """ Overridden in derive class """
    pass
</t>
<t tx="ekr.20190812072048.183">def processAutoComp(self, aco):
    """ Overridden in derive class """
    pass
</t>
<t tx="ekr.20190812072048.184">def _onDoubleClick(self):
    """ When double clicking on a name, autocomplete it. """
    self.processHelp()
</t>
<t tx="ekr.20190812072048.185">def processHelp(self, name=None, showError=False):
    """ Show help on the given full object name.
    - called when going up/down in the autocompletion list.
    - called when double clicking a name
    """
    # uses parse_autocomplete() to find baseName and objectName

    # Get help tool
    hw = pyzo.toolManager.getTool('pyzointeractivehelp')
    ass = pyzo.toolManager.getTool('pyzoassistant')
    # Get the shell
    shell = pyzo.shells.getCurrentShell()
    # Both should exist
    if not hw or not shell:
        return

    if not name:
        # Obtain name from current cursor position

        # Is this valid python?
        if self._isValidPython():
            # Obtain line from text
            cursor = self.textCursor()
            line = cursor.block().text()
            text = line[:cursor.positionInBlock()]
            # Obtain
            nameBefore, name = parseLine_autocomplete(text)
            if nameBefore:
                name = "%s.%s" % (nameBefore, name)

    if name:
        hw.setObjectName(name)
    if ass:
        ass.showHelpForTerm(name)

## Callbacks
</t>
<t tx="ekr.20190812072048.186">def updateHelp(self,name):
    """A name has been highlighted, show help on that name"""

    if self._autoCompBuffer_name:
        name = self._autoCompBuffer_name + '.' + name
    elif not self.completer().completionPrefix():
        # Dont update help if there is no dot or prefix;
        # the choice would be arbitrary
        return

    # Apply
    self.processHelp(name,True)
</t>
<t tx="ekr.20190812072048.187">def event(self,event):
    """ event(event)

    Overload main event handler so we can pass Ctrl-C Ctr-v etc, to the main
    window.

    """
    if isinstance(event, QtGui.QKeyEvent):
        # Ignore CTRL+{A-Z} since those keys are handled through the menu
        if (event.modifiers() &amp; QtCore.Qt.ControlModifier) and \
            (event.key()&gt;=QtCore.Qt.Key_A) and (event.key()&lt;=QtCore.Qt.Key_Z):
                event.ignore()
                return False

    # Default behavior
    codeeditor.CodeEditor.event(self, event)
    return True
</t>
<t tx="ekr.20190812072048.188">def keyPressEvent(self, event):
    """ Receive qt key event.
    From here we'l dispatch the event to perform autocompletion
    or other stuff...
    """

    # Get ordinal key
    ordKey = -1
    if event.text():
        ordKey = ord(event.text()[0])

    # Cancel any introspection in progress
    self._delayTimer._line = ''

    # Invoke autocomplete via tab key?
    if event.key() == QtCore.Qt.Key_Tab and not self.autocompleteActive():
        if pyzo.config.settings.autoComplete:
            cursor = self.textCursor()
            if cursor.position() == cursor.anchor():
                text = cursor.block().text()[:cursor.positionInBlock()]
                if text and (text[-1] in (Tokens.ALPHANUM + "._")):
                    self.introspect(True, False)
                    return

    super().keyPressEvent(event)

    # Analyse character/key to determine what introspection to fire
    if ordKey:
        if (ordKey &gt;= 48 or ordKey in [8, 46]) and pyzo.config.settings.autoComplete == 1:
            # If a char that allows completion or backspace or dot was pressed
            self.introspect(True)
        elif ordKey &gt;= 32:
            # Printable chars, only calltip
            self.introspect()
    elif event.key() in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Right]:
        self.introspect()
</t>
<t tx="ekr.20190812072048.189">class CallTipObject:
    """ Object to help the process of call tips.
    An instance of this class is created for each call tip action.
    """
    @others
</t>
<t tx="ekr.20190812072048.19">class EndKey(object): # tag:CodeEditor

    @others
</t>
<t tx="ekr.20190812072048.190">def __init__(self, textCtrl, name, offset):
    self.textCtrl = textCtrl
    self.name = name
    self.bufferName = name
    self.offset = offset
</t>
<t tx="ekr.20190812072048.191">def tryUsingBuffer(self):
    """ tryUsingBuffer()
    Try performing this callTip using the buffer.
    Returns True on success.
    """
    bufferName = self.textCtrl._callTipBuffer_name
    t = time.time() - self.textCtrl._callTipBuffer_time
    if ( self.bufferName == bufferName and t &lt; 0 ):
        self._finish(self.textCtrl._callTipBuffer_result)
        return True
    else:
        return False
</t>
<t tx="ekr.20190812072048.192">def finish(self, callTipText):
    """ finish(callTipText)
    Finish the introspection using the given calltipText.
    Will also automatically call setBuffer.
    """
    self.setBuffer(callTipText)
    self._finish(callTipText)
</t>
<t tx="ekr.20190812072048.193">def setBuffer(self, callTipText, timeout=4):
    """ setBuffer(callTipText)
    Sets the buffer with the provided text. """
    self.textCtrl._callTipBuffer_name = self.bufferName
    self.textCtrl._callTipBuffer_time = time.time() + timeout
    self.textCtrl._callTipBuffer_result = callTipText
</t>
<t tx="ekr.20190812072048.194">def _finish(self, callTipText):
    self.textCtrl.calltipShow(self.offset, callTipText, True)
</t>
<t tx="ekr.20190812072048.195">class AutoCompObject:
    """ Object to help the process of auto completion.
    An instance of this class is created for each auto completion action.
    """
    @others
if __name__=="__main__":
    app = QtWidgets.QApplication([])
    win = BaseTextCtrl(None)
#     win.setStyle('.py')
    tmp = "foo(bar)\nfor bar in range(5):\n  print bar\n"
    tmp += "\nclass aap:\n  def monkey(self):\n    pass\n\n"
    tmp += "a\u20acb\n"
    win.setPlainText(tmp)
    win.show()
    app.exec_()
</t>
<t tx="ekr.20190812072048.196">def __init__(self, textCtrl, name, needle):
    self.textCtrl = textCtrl
    self.bufferName = name # name to identify with
    self.name = name  # object to find attributes of
    self.needle = needle # partial name to look for
    self.names = set() # the names (use a set to prevent duplicates)
    self.importNames = []
    self.importLines = {}
</t>
<t tx="ekr.20190812072048.197">def addNames(self, names):
    """ addNames(names)
    Add a list of names to the collection.
    Duplicates are removed."""
    self.names.update(names)
</t>
<t tx="ekr.20190812072048.198">def tryUsingBuffer(self):
    """ tryUsingBuffer()
    Try performing this auto-completion using the buffer.
    Returns True on success.
    """
    bufferName = self.textCtrl._autoCompBuffer_name
    t = time.time() - self.textCtrl._autoCompBuffer_time
    if ( self.bufferName == bufferName and t &lt; 0 ):
        self._finish(self.textCtrl._autoCompBuffer_result)
        return True
    else:
        return False
</t>
<t tx="ekr.20190812072048.199">def finish(self):
    """ finish()
    Finish the introspection using the collected names.
    Will automatically call setBuffer.
    """
    # Remember at the object that started this introspection
    # and get sorted names
    names = self.setBuffer(self.names)
    # really finish
    self._finish(names)
</t>
<t tx="ekr.20190812072048.2">def autocompleteAccept(self):
    pass
</t>
<t tx="ekr.20190812072048.20">def keyPressEvent(self,event):
    if event.key() == Qt.Key_End and \
            event.modifiers() in (Qt.NoModifier, Qt.ShiftModifier):
        # Prepare
        cursor = self.textCursor()
        shiftDown = event.modifiers() == Qt.ShiftModifier
        moveMode = [cursor.MoveAnchor, cursor.KeepAnchor][shiftDown]
        # Get current position and move to end of line
        i = cursor.positionInBlock()
        cursor.movePosition(cursor.EndOfLine, moveMode)
        # If alread at end of line, move to end of block
        if cursor.positionInBlock() == i:
            cursor.movePosition(cursor.EndOfBlock, moveMode)
        # Done
        self.setTextCursor(cursor)
    else:
        super().keyPressEvent(event)
</t>
<t tx="ekr.20190812072048.200">def setBuffer(self, names=None, timeout=None):
    """ setBuffer(names=None)
    Sets the buffer with the provided names (or the collected names).
    Also returns a list with the sorted names. """
    # Determine timeout
    # Global namespaces change more often than local one, plus when
    # typing a xxx.yyy, the autocompletion buffer changes and is thus
    # automatically refreshed.
    # I've once encountered a wrong autocomp list on an object, but
    # haven' been able to reproduce it. It was probably some odity.
    if timeout is None:
        if self.bufferName:
            timeout = 5
        else:
            timeout = 1
    # Get names
    if names is None:
        names = self.names
    # Make list and sort
    names = list(names)
    names.sort(key=str.upper)
    # Store
    self.textCtrl._autoCompBuffer_name = self.bufferName
    self.textCtrl._autoCompBuffer_time = time.time() + timeout
    self.textCtrl._autoCompBuffer_result = names
    # Return sorted list
    return names
</t>
<t tx="ekr.20190812072048.201">def _finish(self, names):
    # Show completion list if required.
    self.textCtrl.autocompleteShow(len(self.needle), names)
</t>
<t tx="ekr.20190812072048.202">def nameInImportNames(self, importNames):
    """ nameInImportNames(importNames)
    Test whether the name, or a base part of it is present in the
    given list of names. Returns the (part of) the name that's in
    the list, or None otherwise.
    """
    baseName = self.name
    while baseName not in importNames:
        if '.' in baseName:
            baseName = baseName.rsplit('.',1)[0]
        else:
            baseName = None
            break
    return baseName
</t>
<t tx="ekr.20190812072048.203">@path pyzo/core/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.204"># -*- coding: utf-8 -*-
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo.core.codeparser.py')
except Exception:
    leo_g = None
""" Module codeparser

Analyses the source code to get the structure of a module/script.
This can be used for fictive introspection, and to display the
structure of a source file in for example a tree widget.

"""

#TODO: replace this module, get data from the syntax highlighter in the code editor

import time, threading, re
import pyzo

# Define regular expression patterns
classPattern  = r'^\s*' # Optional whitespace
classPattern += r'(cp?def\s+)?' # Cython preamble + whitespace
classPattern += r'class\s+'  # The class keyword + whitespace
classPattern += r'([a-zA-Z_][a-zA-Z_0-9]*)\s*' # The NAME + optional whitespace
classPattern += r'(\(.*?\))?' # The superclass(es)
classPattern += r'\s*:' # Optional whitespace and the colon
#
defPattern  = r'^\s*' # Optional whitespace
defPattern += r'(async )?' # Optional async keyword
defPattern += r'(cp?)?def\s+' # The Cython preamble, def keyword and whitespace
defPattern += r'([a-zA-Z_][\*a-zA-Z_0-9]*\s+)?' # Optional Cython return type
defPattern += r'([a-zA-Z_][a-zA-Z_0-9]*)\s*' # The NAME + optional whitespace
defPattern += r'\((.*?)\)' # The SIGNATURE
#defPattern += r'\s*:' # Optional whitespace and the colon
# Leave the colon, easier for cython
</t>
<t tx="ekr.20190812072048.205">class Job:
    """ Simple class to represent a job. """
    @others
</t>
<t tx="ekr.20190812072048.206">def __init__(self, text, editorId):
    self.text = text
    self.editorId = editorId
</t>
<t tx="ekr.20190812072048.207">class Result:
    """ Simple class to represent a parser result. """
    @others
</t>
<t tx="ekr.20190812072048.208">def __init__(self, rootItem, importList, editorId):
    self.rootItem = rootItem
    self.importList = importList
    self.editorId = editorId
</t>
<t tx="ekr.20190812072048.209">def isMatch(self, editorId):
    """ isMatch(editorId):
    Returns whether the result matches with the given editorId.
    The editorId can also be an editor instance. """
    if isinstance(editorId, int):
        return self.editorId == editorId
    else:
        return self.editorId == id(editorId)
</t>
<t tx="ekr.20190812072048.21">class NumpadPeriodKey(object): # tag:CodeEditor
    """
    If the numpad decimal separator key is pressed, always insert
    a period (.) even if due to localization that key is mapped to a
    comma (,). When editing code, period is the decimal separator
    independent of localization
    """
    @others
</t>
<t tx="ekr.20190812072048.210">class Parser(threading.Thread):
    """ Parser
    Parsing sourcecode in a separate thread, this class obtains
    introspection informarion. This class is also the interface
    to the parsed information; it has methods that can be used
    to extract information from the result.
    """

    @others
</t>
<t tx="ekr.20190812072048.211">def __init__(self):
    threading.Thread.__init__(self)

    # Reference current job
    self._job = None

    # Reference to last result
    self._result = None

    # Lock to enable save threading
    self._lock = threading.RLock()

    # Set deamon
    self.daemon = True
    self._exit = False
</t>
<t tx="ekr.20190812072048.212">def stop(self, timeout=1.0):
    self._exit = True
    self.join(timeout)
</t>
<t tx="ekr.20190812072048.213">def parseThis(self, editor):
    """ parseThis(editor)
    Give the parser new text to parse.
    If the parser is busy parsing text, it will stop doing that
    and start anew with the most recent version of the text.
    """

    # Get text
    text = editor.toPlainText()

    # Make job
    self._lock.acquire()
    self._job = Job(text, id(editor))
    self._lock.release()
</t>
<t tx="ekr.20190812072048.214">def getFictiveNameSpace(self, editor):
    """ getFictiveNameSpace(editor)
    Produce the fictive namespace, based on the current position.
    A list of names is returned.
    """

    # Obtain result
    result = self._getResult()
    if result is None or not result.isMatch(editor):
        return []

    # Get linenr and indent. These are used to establish the namespace
    # based on indentation.
    cursor = editor.textCursor()
    linenr = cursor.blockNumber()
    index = cursor.positionInBlock()

    # init empty namespace and item list
    namespace = []
    items = result.rootItem.children
    curIsClass = False  # to not add methods (of classes)

    while items:
        curitem = None
        for item in items:
            # append name
            if not curIsClass and item.type in ['class', 'def']:
                namespace.append( item.name )
            # check if this is the one only last one remains
            if (item.type in ['class', 'def'] and item.linenr &lt;= linenr and item.linenr2 &gt; linenr):
                curitem = item
        # prepare for next round
        if curitem and curitem.indent &lt; index:
            items = curitem.children
            if curitem.type=='class':
                curIsClass = True
            else:
                curIsClass = False
        else:
            items = []

    return namespace
</t>
<t tx="ekr.20190812072048.215">def getFictiveClass(self, name, editor, handleSelf=False):
    """ getFictiveClass(name, editor, handleSelf=False)
    Return the fictive class object of the given name, or None
    if it does not exist. If handleSelf is True, automatically
    handles "self." names.
    """
    return self._getFictiveItem(name, 'class', editor, handleSelf)
</t>
<t tx="ekr.20190812072048.216">def getFictiveSignature(self, name, editor, handleSelf=False):
    """ getFictiveSignature(name, editor, handleSelf=False)
    Get the signature of the fictive function or method of the
    given name. Returns None if the given name is not a known
    function or method. If handleSelf is True, automatically
    handles "self." names.
    """
    # Get item being a function
    item = self._getFictiveItem(name, 'def', editor, handleSelf)

    # Get item being a class
    if not item:
        item = self._getFictiveItem(name, 'class', editor, handleSelf)
        if item:
            for subItem in item.children:
                if subItem.name == '__init__' and subItem.type == 'def':
                    item = subItem
                    break
            else:
                item = None

    # Process or return None if there was no item
    if item:
        nameParts = name.split('.')
        return '{}({})'.format(nameParts[-1], item.sig)
    else:
        return None
</t>
<t tx="ekr.20190812072048.217">def getFictiveImports(self, editor):
    """ getFictiveImports(editor)
    Get the fictive imports of this source file.
    tuple:
    - list of names that are imported,
    - a dict with the line to import each name
    """

    # Obtain result
    result = self._getResult()
    if result is None or not result.isMatch(editor):
        return [], []

    # Extract list of names and dict of lines
    imports = []
    importlines = {}
    for item in result.importList:
        imports.append(item.name)
        importlines[item.name] = item.text
    return imports, importlines
</t>
<t tx="ekr.20190812072048.218">def _getResult(self):
    """ getResult()
    Savely Obtain result.
    """
    self._lock.acquire()
    result = self._result
    self._lock.release()
    return result
</t>
<t tx="ekr.20190812072048.219">def _getFictiveItem(self, name, type, editor, handleSelf=False):
    """ _getFictiveItem(name, type, editor, handleSelf=False)
    Obtain the fictive item of the given name and type.
    If handleSelf is True, will handle "self." correctly.
    Intended for internal use.
    """

    # Obtain result
    result = self._getResult()
    if result is None or not result.isMatch(editor):
        return None

    # Split name in parts
    nameParts = name.split('.')

    # Try if the first part represents a class instance
    if handleSelf:
        item = self._getFictiveCurrentClass(editor, nameParts[0])
        if item:
            nameParts[0] = item.name

    # Init
    name = nameParts.pop(0)
    items = result.rootItem.children
    theItem = None

    # Search for name
    while items:
        for item in items:
            if item.name == name:
                # Found it
                if nameParts:
                    # Go down one level
                    name = nameParts.pop(0)
                    items = item.children
                    break
                else:
                    # This is it, is it what we wanted?
                    if item.type == type:
                        theItem = item
                        items = []
                        break
        else:
            # Did not find it
            items = []

    return theItem
</t>
<t tx="ekr.20190812072048.22">def keyPressEvent(self,event):
    # Check for numpad comma
    if event.key() == QtCore.Qt.Key_Comma and \
            event.modifiers() &amp; QtCore.Qt.KeypadModifier:

        # Create a new QKeyEvent to substitute the original one
        event = QtGui.QKeyEvent(event.type(), QtCore.Qt.Key_Period,
            event.modifiers(), '.', event.isAutoRepeat(), event.count())

    super().keyPressEvent(event)
</t>
<t tx="ekr.20190812072048.220">def _getFictiveCurrentClass(self, editor, selfname):
    """ _getFictiveCurrentClass(editor, selfname)
    Get the fictive object for the class referenced
    using selfname (usually 'self').
    Intendef for internal use.
    """

    # Obtain result
    result = self._getResult()
    if result is None:
        return None

    # Get linenr and indent
    cursor = editor.textCursor()
    linenr = cursor.blockNumber()
    index = cursor.positionInBlock()

    # Init
    items = result.rootItem.children
    theclass = None

    while items:
        curitem = None
        for item in items:
            # check if this is the one only last one remains
            if item.linenr &lt;= linenr:
                if not item.linenr2 &gt; linenr:
                    continue
                curitem = item
                if item.type == 'def' and item.selfname==selfname:
                    theclass = item.parent
            else:
                break

        # prepare for next round
        if curitem and curitem.indent &lt; index:
            items = curitem.children
        else:
            items = []

    # return
    return theclass
</t>
<t tx="ekr.20190812072048.221">def run(self):
    """ run()
    This is the main loop.
    """

    time.sleep(0.5)
    try:
        while True:
            time.sleep(0.1)

            if self._exit:
                return

            if self._job:

                # Savely obtain job
                self._lock.acquire()
                job = self._job
                self._job = None
                self._lock.release()

                # Analyse job
                result = self._analyze(job)

                # Savely store result
                self._lock.acquire()
                self._result = result
                self._lock.release()

                # Notify
                if pyzo.editors is not None:
                    pyzo.editors.parserDone.emit()

    except AttributeError:
        pass # when python exits, time can be None...
</t>
<t tx="ekr.20190812072048.222">def _analyze(self, job):
    """ The core function.
    Analyses the source code.
    Produces:
    - a tree of FictiveObject objects.
    - a (flat) list of the same object
    - a list of imports
    """

    # Remove multiline strings
    text = washMultilineStrings(job.text)

    # Split text in lines
    lines = text.splitlines()
    lines.insert(0,"") # so the lines start at 1

    # The structure object. It will first only consist of class and defs
    # the rest will be inserted afterwards.
    root = FictiveObject("root", 0, -1, 'root')

    # Also keep a flat list (while running this function)
    flatList = []

    # Cells and imports are inserted in the structure afterwards
    leafs = []

    # Keep a list of imports
    importList = []

    # To know when to make something new when for instance a class is defined
    # in an if statement, we keep track of the last valid node/object:
    # Put inside a list, so we can set it from inside a subfuncion
    lastObject = [root]

    # Define funcion to put an item in the structure in the right parent
    def appendToStructure(object):
        # find position in structure to insert
        node = lastObject[0]
        while ( (object.indent &lt;= node.indent) and (node is not root) ):
            node = node.parent
        # insert object
        flatList.append(object)
        node.children.append(object)
        object.parent = node
        lastObject[0] = object

    # Find objects!
    # type can be: cell, class, def, import, var
    for i in range( len(lines) ):

        # Obtain line
        line = lines[i]

        # Should we stop?
        if self._job or self._exit:
            break

        # Remove indentation
        tmp = line.lstrip()
        indent = len(line) - len(tmp)
        line = tmp.rstrip()

        # Detect cells
        if line.startswith('##') or line.startswith('#%%') or line.startswith('# %%'):
            if line.startswith('##'):
                name = line[2:].lstrip()
            elif line.startswith('#%%'):
                name = line[3:].lstrip()
            else:
                name = line[4:].lstrip()
            item = FictiveObject('cell', i, indent, name)
            leafs.append(item)
            # Next! (we have to put this before the elif stuff below
            # because it looks like a comment!)
            continue

        # Split in line and comment
        line, tmp, cmnt = line.partition('#')
        line, cmnt = line.rstrip(), cmnt.lower().strip()

        # Detect todos
        if cmnt and (cmnt.startswith('todo:') or cmnt.startswith('2do:') ):
            item = FictiveObject('todo', i, indent, cmnt)
            item.linenr2 = i+1 # a todo is active at one line only
            leafs.append(item)

        # Continue of no line left
        if not line:
            continue

        # Find last valid node. As the indent of the root is set to -1,
        # this will always stop at the root
        while indent &lt;= lastObject[0].indent:
            lastObject[0].linenr2 = i # close object
            lastObject[0] = lastObject[0].parent

        # Make a lowercase version of the line
        foundSomething = False

        # Detect classes
        if not foundSomething:
            classResult = re.search(classPattern, line)

            if classResult:
                foundSomething = True
                # Get name
                name = classResult.group(2)
                item = FictiveObject('class', i, indent, name)
                appendToStructure(item)
                item.supers = []
                item.members = []
                # Get inheritance
                supers = classResult.group(3)
                if supers:
                    supers = supers[1:-1].split(',')
                    supers = [tmp.strip() for tmp in supers]
                    item.supers = [tmp for tmp in supers if tmp]

        # Detect functions and methods (also multiline)
        if (not foundSomething) and line.count('def '):
            # Get a multiline version (for long defs)
            multiLine = line
            for ii in range(1,5):
                if i+ii&lt;len(lines): multiLine += ' '+lines[i+ii].strip()
            # Get result
            defResult = re.search(defPattern, multiLine)
            if defResult:
                # Get name
                name = defResult.group(4)
                item = FictiveObject('def', i, indent, name)
                appendToStructure(item)
                item.selfname = None # will be filled in if a valid method
                item.sig = defResult.group(5)
                # is it a method? -&gt; add method to attr and find selfname
                if item.parent.type == 'class':
                    item.parent.members.append(name)

                    # Find what is used as "self"
                    i2 = line.find('(')
                    i4 = line.find(",",i2)
                    if i4 &lt; 0:
                        i4 = line.find(")",i2)
                    if i4 &lt; 0:
                        i4 = i2
                    selfname = line[i2+1:i4].strip()
                    if selfname:
                        item.selfname = selfname

        elif line.count('import '):
            if line.startswith("import "):
                for name in ParseImport(line[7:]):
                    item = FictiveObject('import', i, indent, name)
                    item.text = line
                    item.linenr2 = i+1 # an import is active at one line only
                    leafs.append(item)
                    importList.append(item)

            elif line.startswith("from "):
                i1 = line.find(" import ")
                for name in ParseImport(line[i1+8:]):
                    if not IsValidName(name):
                        continue # we cannot do that!
                    item = FictiveObject('import', i, indent, name)
                    item.text = line
                    item.linenr2 = i+1 # an import is active at one line only
                    leafs.append(item)
                    importList.append(item)

        elif not indent and line.startswith('if __name__ ==') and '__main__' in line:
            item = FictiveObject('nameismain', i, indent, '__main__')
            item.text = line
            appendToStructure(item)

        elif line.count('='):
            if lastObject[0].type=='def' and lastObject[0].selfname:
                selfname = lastObject[0].selfname + "."
                line = line.partition("=")[0]
                if line.count(selfname):
                    # A lot of ifs here. If we got here, the line is part of
                    # a valid method and contains the selfname before the =.
                    # Now we need to establish whether there is a valid
                    # assignment done here...
                    parts = line.split(",") # handle tuples
                    for part in parts:
                        part = part.strip()
                        part2 = part[len(selfname):]
                        if part.startswith(selfname) and IsValidName(part2):
                            # add to the list if not already present
                            defItem = lastObject[0]
                            classItem = lastObject[0].parent
                            #
                            item = FictiveObject('attribute', i, indent, part2)
                            item.parent = defItem
                            defItem.children.append(item)
                            if part2 not in classItem.members:
                                classItem.members.append(part2)

    ## Post processing

    def getTwoItems(series, linenr):
        """ Return the two items just above and below the
        given linenr. The object always is a class or def.
        """
        # find object after linenr
        object1, object2 = None, None # if no items at all
        i = -1
        for i in range(len(series)):
            object = series[i]
            if object.type not in ['class','def']:
                continue
            if object.linenr &gt; linenr:
                object2 = object
                break
        # find object just before linenr
        for ii in range(i,-1,-1):
            object = series[ii]
            if object.type not in ['class','def']:
                continue
            if object.linenr &lt; linenr:
                object1 = object
                break
        # return result
        return object1, object2

    # insert the leafs (backwards as the last inserted is at the top)
    for leaf in reversed(leafs):
        ob1, ob2 = getTwoItems(flatList, leaf.linenr)
        if ob1 is None: # also if ob2 is None
            # insert in root
            root.children.insert(0,leaf)
            leaf.parent = root
            continue
        if ob2 is None:
            ob2parent = root
        else:
            ob2parent = ob2.parent

        # get the object IN which to insert it: ob1
        sibling = None
        while 1:
            canGoDeeper = ob1 is not ob2parent
            canGoDeeper = canGoDeeper and ob1 is not root
            shouldGoDeeper = ob1.indent &gt;= leaf.indent
            shouldGoDeeper = shouldGoDeeper or ob1.linenr2 &lt; leaf.linenr
            if canGoDeeper and shouldGoDeeper:
                sibling = ob1
                ob1 = ob1.parent
            else:
                break

        # insert into ob1, after sibling (if available)
        L = ob1.children
        if sibling:
            i = L.index(sibling)
            L.insert(i+1,leaf)
        else:
            L.insert(0,leaf)

    # Return result
    return Result(root, importList, job.editorId)
</t>
<t tx="ekr.20190812072048.223">## Helper classes and functions

class FictiveObject:
    """ An un-instantiated object.
    type can be class, def, import, cell, todo
    extra stuff:
    class   - supers, members
    def     - selfname
    imports - text
    cell    -
    todo    -
    attribute -
    """
    @others
namechars = 'abcdefghijklmnopqrstuvwxyz_0123456789'
</t>
<t tx="ekr.20190812072048.224">def __init__(self, type, linenr, indent, name):
    self.children = []
    self.type = type
    self.linenr = linenr # at which line this object starts
    self.linenr2 = 9999999 # at which line it ends
    self.indent = indent
    self.name = name
    self.sig = ''  # for functions and methods
</t>
<t tx="ekr.20190812072048.225">def IsValidName(name):
    """ Given a string, checks whether it is a
    valid name (dots are not valid!)
    """
    if not name:
        return False
    name = name.lower()
    if name[0] not in namechars[0:-10]:
        return False
    tmp = map(lambda x: x not in namechars, name[2:])
    return sum(tmp)==0
</t>
<t tx="ekr.20190812072048.226">def ParseImport(names):
    for part in names.split(","):
        i1 = part.find(' as ')
        if i1&gt;0:
            name = part[i1+3:].strip()
        else:
            name = part.strip()
        yield name
</t>
<t tx="ekr.20190812072048.227">def findString(text, s, i):
    """ findString(text, s)
    Find s in text, but only if s is not in a string or commented
    Helper function for washMultilineStrings """

    while True:
        i = _findString(text, s, i)
        if i&lt;-1:
            i = -i+1
        else:
            break
    return i
</t>
<t tx="ekr.20190812072048.228">def _findString(text, s, i):
    """ Helper function of findString, which is called recursively
    until a match is found, or it is clear there is no match. """

    # Find occurrence
    i2 = text.find(s, i)
    if i2&lt;0:
        return -1

    # Find newline  (if none, we're done)
    i1 = text.rfind('\n', 0, i2)
    if i1&lt;0:
        return i2

    # Extract the part on the line up to the match
    line = text[i1:i2]

    # Count quotes, we're done if we found none
    if not line.count('"') and not line.count("'") and not line.count('#'):
        return i2

    # So we found quotes, now really count them ...
    prev = ''
    inString = '' # this is a boolean combined with a flag which quote was used
    isComment = False
    for c in line:
        if c == '#':
            if not inString:
                isComment = True
                break
        elif c in "\"\'":
            if not inString:
                inString = c
            elif prev != '\\':
                if inString == c:
                    inString = '' # exit string
                else:
                    pass # the other quote can savely be used inside this string
        prev = c

    # If we are in a string, this match is false ...
    if inString or isComment:
        return -i2 # indicate failure and where to continue
    else:
        return i2 # all's right
</t>
<t tx="ekr.20190812072048.229">def washMultilineStrings(text):
    """ washMultilineStrings(text)
    Replace all text within multiline strings with dummy chars
    so that it is not parsed.
    """
    i=0
    s1 = "'''"
    s2 = '"""'
    while i&lt;len(text):
        # Detect start of a multiline comment (there are two versions)
        i1 = findString(text, s1, i)
        i2 = findString(text, s2, i)
        # Stop if nothing found ...
        if i1 == -1 and i2 == -1:
            break
        else:
            # Make no result be very large
            if i1==-1:
                i1 = 2**60
            if i2==-1:
                i2 = 2**60
            # Find end of the multiline comment
            if i1 &lt; i2:
                i3 = i1+3
                i4 = text.find(s1, i3)
            else:
                i3 = i2+3
                i4 = text.find(s2, i3)
            # No end found -&gt; take all text, unclosed string!
            if i4==-1:
                i4 = 2**32
            # Leave only the first two quotes of the start of the comment
            i3 -= 1
            i4 += 3
            # Replace all non-newline chars
            tmp = re.sub(r'\S', ' ', text[i3:i4])
            text = text[:i3] + tmp + text[i3+len(tmp):]
            # Prepare for next round
            i = i4+1
    return text

"""
## testing skipping of multiline strings
def ThisShouldNotBeVisible():
  pass
class ThisShouldNotBeVisibleEither():
  pass
"""
</t>
<t tx="ekr.20190812072048.23">class Indentation(object): # tag:CodeEditor

    @others
</t>
<t tx="ekr.20190812072048.230">@path pyzo/core/
@others
if sys.platform.startswith('win'):
    _try_start_server = not is_pyzo_server_running()

# Create server
server_err = None
server = None
try:
    if _try_start_server:
        server = Server(ADDRESS)
        server.start()
except OSError as err:
    server_err = err
    server = None

@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.231"># -*- coding: utf-8 -*-
""" Module to deal with command line arguments.

In specific, this allows doing "pyzo some_file.py" and the file will be
opened in an existing pyzo window (if available) or a new pyzo process
is started to open the file.

This module is used at the very early stages of starting pyzo, and also
in main.py to apply any command line args for the current process, and
to closse down the server when pyzo is closed.
"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo/core/commandline.py')
except Exception:
    leo_g = None

import sys
import os

from yoton.clientserver import RequestServer, do_request
import pyzo

# Local address to host on. we use yoton's port hash to have an arbitrary port
ADDRESS = 'localhost:pyzoserver'

</t>
<t tx="ekr.20190812072048.232">class Server(RequestServer):
    """ Server that listens on a port for commands.
    The commands can be send by executing the Pyzo executable with
    command line arguments.
    """

    @others
</t>
<t tx="ekr.20190812072048.233">def handle_request(self, request):
    """ This is where the requests enter.
    """
    # Get command
    request = request.strip()
    command, _, arg = request.partition(' ')

    # Handle command
    try:
        reply = handle_command(command, arg)
    except Exception as err:
        msg = 'Error handling request %r:\n%s' % (request, str(err))
        pyzo.callLater(print, msg)
        return msg
    else:
        pyzo.callLater(print, 'Request:', request)
        pyzo.callLater(print, 'Reply:', reply)
        return reply
</t>
<t tx="ekr.20190812072048.234">def handle_command(command, arg):
    """ Function that handles all pyzo commands.
    This gets called either from the server, or from the code that
    processed command line args.
    """
    if not command:
        return 'empty command?'

    elif command == 'testerr':
        return 1/0

    elif command == 'stopserver':
        # For efficiently stopping the server
        if server:
            server.stop()
            return 'Stopped the server'

    elif command == 'echo':
        # For testing
        return 'echo %r' % arg

    elif command == 'open':
        # Open a file in the editor
        if not arg:
            return 'The open command requires a filename.'
        pyzo.callLater(pyzo.editors.loadFile, arg)
        return 'Opened file %r' % arg

    elif command == 'new':
        # Open a new (temp) file in the editor
        pyzo.callLater(pyzo.editors.newFile)
        return 'Created new file'

    elif command == 'close':
        # Close pyzo
        pyzo.callLater(pyzo.main.close)
        return 'Closing Pyzo'

    else:
        # Assume the user wanted to open a file
        fname = (command + ' ' + arg).rstrip()
        if not pyzo.editors:
            return 'Still warming up ...'
        else:
            pyzo.callLater(pyzo.editors.loadFile, fname)
            return 'Try opening file %r' % fname

    # We should always return. So if we get here, it is a bug.
    # Return something so that we can be aware.
    return 'error ' + command
</t>
<t tx="ekr.20190812072048.235">def handle_cmd_args():
    """ Handle command line arguments by sending them to the server.
    Returns a result string if any commands were processed, and None
    otherwise.
    """
    args = sys.argv[1:]
    request = ' '.join(args)
    if 'psn_' in request and not os.path.isfile(request):
        request = ' '.join(args[1:])  # An OSX thing when clicking app icon
    request = request.strip()
    #
    if not request:
        return None
    else:
        # Always send to server, even if we are the ones that run the server
        try:
            return do_request(ADDRESS, request, 0.4).rstrip()
        except Exception as err:
            print('Could not process command line args:\n%s' % str(err))
            return None
</t>
<t tx="ekr.20190812072048.236">def stop_our_server():
    """ Stop our server, for shutting down nicely.
    This is faster than calling server.stop(), because in the latter
    case the server will need to timeout (0.25 s) before it sees that
    it needs to stop.
    """
    if is_our_server_running():
        try:
            server.stop()  # Post a stop message
            do_request(ADDRESS, 'stopserver', 0.1)  # trigger
            print('Stopped our command server.')
        except Exception as err:
            print('Failed to stop command server:')
            print(err)
</t>
<t tx="ekr.20190812072048.237">def is_our_server_running():
    """ Return True if our server is running. If it is, this process
    is the main Pyzo; the first Pyzo that was started. If the server is
    not running, this is probably not the first Pyzo, but there might
    also be problem with starting the server.
    """
    return server and server.isAlive()
</t>
<t tx="ekr.20190812072048.238">def is_pyzo_server_running():
    """ Test whether the Pyzo server is running *somewhere* (not
    necesarily in this process).
    """
    try:
        res = do_request(ADDRESS, 'echo', 0.2)
        return res.startswith('echo')
    except Exception:
        return False


# Should we start the server?
_try_start_server = True
</t>
<t tx="ekr.20190812072048.239">@path pyzo/core/
@others
@language python
@tabwidth -4
@nopyflakes
</t>
<t tx="ekr.20190812072048.24">def __cursorIsInLeadingWhitespace(self,cursor = None):
    """
    Checks wether the given cursor is in the leading whitespace of a block, i.e.
    before the first non-whitespace character. The cursor is not modified.
    If the cursor is not given or is None, the current textCursor is used
    """
    if cursor is None:
        cursor = self.textCursor()

    # Get the text of the current block up to the cursor
    textBeforeCursor = ustr(cursor.block().text())[:cursor.positionInBlock()]
    return textBeforeCursor.lstrip() == '' #If we trim it and it is empty, it's all whitespace

</t>
<t tx="ekr.20190812072048.240"># -*- coding: utf-8 -*-
""" compact tab widget class

See docs of the tab widget.

"""

from pyzo.util.qt import QtCore, QtGui, QtWidgets  # noqa
import sys

if sys.version_info[0] &lt; 3:
    str = unicode  # noqa
    ELLIPSIS = unichr(8230)  # noqa
else:
    ELLIPSIS = chr(8230)

# Constants for the alignments of tabs
MIN_NAME_WIDTH = 4
MAX_NAME_WIDTH = 64

## Define style sheet for the tabs

STYLESHEET = """
QTabWidget::pane { /* The tab widget frame */
    border-top: 0px solid #A09B90;
}

QTabWidget::tab-bar {
    left: 0px; /* move to the right by x px */
}

/* Style the tab using the tab sub-control. Note that
 it reads QTabBar _not_ QTabWidget */
QTabBar::tab {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                stop: 0.0 rgba(220,220,220,128),
                stop: 0.4 rgba(200,200,200,128),
                stop: 1.0 rgba(100,100,100,128) );
    border: 1px solid #A09B90;
    border-bottom-color: #DAD5CC; /* same as the pane color */
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    min-width: 5ex;
    padding-bottom: PADDING_BOTTOMpx;
    padding-top: PADDING_TOPpx;
    padding-left: PADDING_LEFTpx;
    padding-right: PADDING_RIGHTpx;
    margin-right: -1px; /* "combine" borders */
}
QTabBar::tab:last {
    margin-right: 0px;
}

/* Style the selected tab, hoovered tab, and other tabs. */
QTabBar::tab:hover {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                stop: 0.0 rgba(245,250,255,128),
                stop: 0.4 rgba(210,210,210,128),
                stop: 1.0 rgba(200,200,200,128) );
}
QTabBar::tab:selected {
    background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
                stop: 0.0 rgba(0,0,128,128),
                stop: 0.12 rgba(0,0,128,128),
                stop: 0.120001 rgba(245,250,255,128),
                stop: 0.4 rgba(210,210,210,128),
                stop: 1.0 rgba(200,200,200,128) );
}

QTabBar::tab:selected {
    border-width: 1px;
    border-bottom-width: 0px;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
    border-color: #333;
}

QTabBar::tab:!selected {
    margin-top: 3px; /* make non-selected tabs look smaller */
}

"""

## Define tab widget class
</t>
<t tx="ekr.20190812072048.241">class TabData:
    """ To keep track of real names of the tabs, but also keep supporting
    tabData.
    """
    @others
</t>
<t tx="ekr.20190812072048.242">def __init__(self, name):
    self.name = name
    self.data = None
</t>
<t tx="ekr.20190812072048.243">class CompactTabBar(QtWidgets.QTabBar):
    """ CompactTabBar(parent, *args, padding=(4,4,6,6), preventEqualTexts=True)

    Tab bar corresponcing to the CompactTabWidget.

    With the "padding" argument the padding of the tabs can be chosen.
    It should be an integer, or a 4 element tuple specifying the padding
    for top, bottom, left, right. When a tab has a button,
    the padding is the space between button and text.

    With preventEqualTexts to True, will reduce the amount of eliding if
    two tabs have (partly) the same name, so that they can always be
    distinguished.

    """

    # Add signal to be notified of double clicks on tabs
    tabDoubleClicked = QtCore.Signal(int)
    barDoubleClicked = QtCore.Signal()

    @others
</t>
<t tx="ekr.20190812072048.244">def __init__(self, *args, padding=(4,4,6,6), preventEqualTexts=True):
    QtWidgets.QTabBar.__init__(self, *args)

    # Put tab widget in document mode
    self.setDocumentMode(True)

    # Widget needs to draw its background (otherwise Mac has a dark bg)
    self.setDrawBase(False)
    if sys.platform == 'darwin':
        self.setAutoFillBackground(True)

    # Set whether we want to prevent eliding for names that start the same.
    self._preventEqualTexts = preventEqualTexts

    # Allow moving tabs around
    self.setMovable(True)

    # Get padding
    if isinstance(padding, (int, float)):
        padding = padding, padding, padding, padding
    elif isinstance(padding, (tuple, list)):
        pass
    else:
        raise ValueError('Invalid value for padding.')

    # Set style sheet
    stylesheet = STYLESHEET
    stylesheet = stylesheet.replace('PADDING_TOP', str(padding[0]))
    stylesheet = stylesheet.replace('PADDING_BOTTOM', str(padding[1]))
    stylesheet = stylesheet.replace('PADDING_LEFT', str(padding[2]))
    stylesheet = stylesheet.replace('PADDING_RIGHT', str(padding[3]))
    self.setStyleSheet(stylesheet)

    # We do our own eliding
    self.setElideMode(QtCore.Qt.ElideNone)

    # Make tabs wider if there's plenty space?
    self.setExpanding(False)

    # If there's not enough space, use scroll buttons
    self.setUsesScrollButtons(True)

    # When a tab is removed, select previous
    self.setSelectionBehaviorOnRemove(self.SelectPreviousTab)

    # Init alignment parameters
    self._alignWidth = MIN_NAME_WIDTH  # Width in characters
    self._alignWidthIsReducing = False # Whether in process of reducing

    # Create timer for aligning
    self._alignTimer = QtCore.QTimer(self)
    self._alignTimer.setInterval(10)
    self._alignTimer.setSingleShot(True)
    self._alignTimer.timeout.connect(self._alignRecursive)
</t>
<t tx="ekr.20190812072048.245">def _compactTabBarData(self, i):
    """ _compactTabBarData(i)

    Get the underlying tab data for tab i. Only for internal use.

    """

    # Get current TabData instance
    tabData = QtWidgets.QTabBar.tabData(self, i)
    if (tabData is not None) and hasattr(tabData, 'toPyObject'):
        tabData = tabData.toPyObject() # Older version of Qt

    # If none, make it as good as we can
    if not tabData:
        name = str(QtWidgets.QTabBar.tabText(self, i))
        tabData = TabData( name )
        QtWidgets.QTabBar.setTabData(self, i, tabData)

    # Done
    return tabData

## Overload a few methods
</t>
<t tx="ekr.20190812072048.246">def mouseDoubleClickEvent(self, event):
    i = self.tabAt(event.pos())
    if i == -1:
        # There was no tab under the cursor
        self.barDoubleClicked.emit()
    else:
        # Tab was double clicked
        self.tabDoubleClicked.emit(i)
</t>
<t tx="ekr.20190812072048.247">def mousePressEvent(self, event):
    if event.button() == QtCore.Qt.MiddleButton:
        i = self.tabAt(event.pos())
        if i &gt;= 0:
            self.parent().tabCloseRequested.emit(i)
            return
    super().mousePressEvent(event)
</t>
<t tx="ekr.20190812072048.248">def setTabData(self, i, data):
    """ setTabData(i, data)

    Set the given object at the tab with index 1.

    """
    # Get underlying python instance
    tabData = self._compactTabBarData(i)

    # Attach given data
    tabData.data = data
</t>
<t tx="ekr.20190812072048.249">def tabData(self, i):
    """ tabData(i)

    Get the tab data at item i. Always returns a Python object.

    """

    # Get underlying python instance
    tabData = self._compactTabBarData(i)

    # Return stored data
    return tabData.data
</t>
<t tx="ekr.20190812072048.25">def keyPressEvent(self,event):
    key = event.key()
    modifiers = event.modifiers()
    #Tab key
    if key == Qt.Key_Tab:
        if modifiers == Qt.NoModifier:
            if self.textCursor().hasSelection(): #Tab pressed while some area was selected
                self.indentSelection()
                return
            elif self.__cursorIsInLeadingWhitespace():
                #If the cursor is in the leading whitespace, indent and move cursor to end of whitespace
                cursor = self.textCursor()
                self.indentBlock(cursor)
                self.setTextCursor(cursor)
                return

            elif self.indentUsingSpaces():
                #Insert space-tabs
                cursor=self.textCursor()
                w = self.indentWidth()
                cursor.insertText(' '*(w-((cursor.positionInBlock() + w ) % w)))
                return
            #else: default behaviour, insert tab character
        else: #Some other modifiers + Tab: ignore
            return

    # If backspace is pressed in the leading whitespace, (except for at the first
    # position of the line), and there is no selection
    # dedent that line and move cursor to end of whitespace
    if key == Qt.Key_Backspace and modifiers == Qt.NoModifier and \
            self.__cursorIsInLeadingWhitespace() and not self.textCursor().atBlockStart() \
            and not self.textCursor().hasSelection():
        # Create a cursor, dedent the block and move screen cursor to the end of the whitespace
        cursor = self.textCursor()
        self.dedentBlock(cursor)
        self.setTextCursor(cursor)
        return

    # todo: Same for delete, I think not (what to do with the cursor?)

    # Auto-unindent
    if event.key() == Qt.Key_Delete:
        cursor = self.textCursor()
        if not cursor.hasSelection():
            cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
            if not cursor.hasSelection() and cursor.block().next().isValid():
                cursor.beginEditBlock()
                cursor.movePosition(cursor.NextBlock)
                self.indentBlock(cursor, -99)  # dedent as much as we can
                cursor.deletePreviousChar()
                cursor.endEditBlock()
                return

    super().keyPressEvent(event)
</t>
<t tx="ekr.20190812072048.250">def setTabText(self, i, text):
    """ setTabText(i, text)

    Set the text for tab i.

    """
    tabData = self._compactTabBarData(i)
    if text != tabData.name:
        tabData.name = text
        self.alignTabs()
</t>
<t tx="ekr.20190812072048.251">def tabText(self, i):
    """ tabText(i)

    Get the title of the tab at index i.

    """
    tabData = self._compactTabBarData(i)
    return tabData.name

## Overload events and protected functions
</t>
<t tx="ekr.20190812072048.252">def tabInserted(self, i):
    QtWidgets.QTabBar.tabInserted(self, i)

    # Is called when a tab is inserted

    # Get given name and store
    name = str(QtWidgets.QTabBar.tabText(self, i))
    tabData = TabData(name)
    QtWidgets.QTabBar.setTabData(self, i, tabData)

    # Update
    self.alignTabs()
</t>
<t tx="ekr.20190812072048.253">def tabRemoved(self, i):
    QtWidgets.QTabBar.tabRemoved(self, i)

    # Update
    self.alignTabs()
</t>
<t tx="ekr.20190812072048.254">def resizeEvent(self, event):
    QtWidgets.QTabBar.resizeEvent(self, event)
    self.alignTabs()
</t>
<t tx="ekr.20190812072048.255">def showEvent(self, event):
    QtWidgets.QTabBar.showEvent(self, event)
    self.alignTabs()

## For aligning
</t>
<t tx="ekr.20190812072048.256">def alignTabs(self):
    """ alignTabs()

    Align the tab items. Their names are ellided if required so that
    all tabs fit on the tab bar if possible. When there is too little
    space, the QTabBar will kick in and draw scroll arrows.

    """

    # Set name widths correct (in case new names were added)
    self._setMaxWidthOfAllItems()

    # Start alignment process
    self._alignWidthIsReducing = False
    self._alignTimer.start()
</t>
<t tx="ekr.20190812072048.257">def _alignRecursive(self):
    """ _alignRecursive()

    Recursive alignment of the items. The alignment process
    should be initiated from alignTabs().

    """

    # Only if visible
    if not self.isVisible():
        return

    # Get tab bar and number of items
    N = self.count()

    # Get right edge of last tab and left edge of corner widget
    pos1 = self.tabRect(0).topLeft()
    pos2 = self.tabRect(N-1).topRight()
    cornerWidget = self.parent().cornerWidget()
    if cornerWidget:
        pos3 = cornerWidget.pos()
    else:
        pos3 = QtCore.QPoint(self.width(), 0)
    x1 = pos1.x()
    x2 = pos2.x()
    x3 = pos3.x()
    alignMargin = x3 - (x2-x1) -3  # Must be positive (has margin)

    # Are the tabs too wide?
    if alignMargin &lt; 0:
        # Tabs extend beyond corner widget

        # Reduce width then
        self._alignWidth -= 1
        self._alignWidth = max(self._alignWidth, MIN_NAME_WIDTH)

        # Apply
        self._setMaxWidthOfAllItems()
        self._alignWidthIsReducing = True

        # Try again if there's still room for reduction
        if self._alignWidth &gt; MIN_NAME_WIDTH:
            self._alignTimer.start()

    elif alignMargin &gt; 10 and not self._alignWidthIsReducing:
        # Gap between tabs and corner widget is a bit large

        # Increase width then
        self._alignWidth += 1
        self._alignWidth = min(self._alignWidth, MAX_NAME_WIDTH)

        # Apply
        itemsElided = self._setMaxWidthOfAllItems()

        # Try again if there's still room for increment
        if itemsElided and self._alignWidth &lt; MAX_NAME_WIDTH:
            self._alignTimer.start()
            #self._alignTimer.timeout.emit()

    else:
        pass # margin is good
</t>
<t tx="ekr.20190812072048.258">def _getAllNames(self):
    """ _getAllNames()

    Get a list of all (full) tab names.

    """
    return [self._compactTabBarData(i).name for i in range(self.count())]
</t>
<t tx="ekr.20190812072048.259">def _setMaxWidthOfAllItems(self):
    """ _setMaxWidthOfAllItems()

    Sets the maximum width of all items now, by eliding the names.
    Returns whether any items were elided.

    """

    # Get whether an item was reduced in size
    itemReduced = False

    for i in range(self.count()):

        # Get width
        w = self._alignWidth

        # Get name
        name = self._compactTabBarData(i).name

        # If its too long, first make it shorter by stripping dir names
        if (w+1) &lt; len(name) and '/' in name:
            name = name.split('/')[-1]

        # Check if we can reduce the name size, correct w if necessary
        if ( (w+1) &lt; len(name) ) and self._preventEqualTexts:

            # Increase w untill there are no names that start the same
            allNames = self._getAllNames()
            hasSimilarNames = True
            diff = 2
            w -= 1
            while hasSimilarNames and w &lt; len(name):
                w += 1
                w2 = w - (diff-1)
                shortName = name[:w2]
                similarnames = [n for n in allNames if n[:w2]==shortName]
                hasSimilarNames = len(similarnames)&gt;1

        # Check again, with corrected w
        if (w+1) &lt; len(name):
            name = name[:w] + ELLIPSIS
            itemReduced = True

        # Set text now
        QtWidgets.QTabBar.setTabText(self, i, name)

    # Done
    return itemReduced
</t>
<t tx="ekr.20190812072048.26">class AutoIndent(object): # tag:CodeEditor
    """
    Auto indentation. This extension only adds the autoIndent property, for the
    actual indentation, the editor should derive from some AutoIndenter object
    """

    @others
</t>
<t tx="ekr.20190812072048.260">class CompactTabWidget(QtWidgets.QTabWidget):
    """ CompactTabWidget(parent, *args, **kwargs)

    Implements a tab widget with a tabbar that is in document mode
    and has more compact tabs that conventional tab widgets, so more
    items fit on the same space.

    Further much care is taken to ellide the names in a smart way:
      * All items are allowed the same amount of characters instead of
        that the same amount of characters is removed from all names.
      * If there are two item with the same beginning, it is made
        sure that enough characters are shown such that the names
        can be distinguished.

    The kwargs are passed to the tab bar constructor. There are a few
    keywords arguments to influence the appearance of the tabs. See the
    CompactTabBar class.

    """

    @others
if __name__ == '__main__':

    w = CompactTabWidget()
    w.show()

    w.addTab(QtWidgets.QWidget(w), 'aapenootjedopje')
    w.addTab(QtWidgets.QWidget(w), 'aapenootjedropje')
    w.addTab( QtWidgets.QWidget(w), 'noot en mies')
    w.addTab( QtWidgets.QWidget(w), 'boom bijv een iep')
    w.addTab( QtWidgets.QWidget(w), 'roosemarijnus')
    w.addTab( QtWidgets.QWidget(w), 'vis')
    w.addTab( QtWidgets.QWidget(w), 'vuurvuurvuur')
</t>
<t tx="ekr.20190812072048.261">def __init__(self, *args, **kwargs):
    QtWidgets.QTabWidget.__init__(self, *args)

    # Set tab bar
    self.setTabBar(CompactTabBar(self, **kwargs))

    # Draw tabs at the top by default
    self.setTabPosition(QtWidgets.QTabWidget.North)
</t>
<t tx="ekr.20190812072048.262">def setTabData(self, i, data):
    """ setTabData(i, data)

    Set the given object at the tab with index 1.

    """
    self.tabBar().setTabData(i, data)
</t>
<t tx="ekr.20190812072048.263">def tabData(self, i):
    """ tabData(i)

    Get the tab data at item i. Always returns a Python object.

    """
    return self.tabBar().tabData(i)
</t>
<t tx="ekr.20190812072048.264">def setTabText(self, i, text):
    """ setTabText(i, text)

    Set the text for tab i.

    """
    self.tabBar().setTabText(i, text)
</t>
<t tx="ekr.20190812072048.265">def tabText(self, i):
    """ tabText(i)

    Get the title of the tab at index i.

    """
    return self.tabBar().tabText(i)
</t>
<t tx="ekr.20190812072048.266">@path pyzo/core/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.267"># -*- coding: utf-8 -*-
""" Module editor

Defines the PyzoEditor class which is used to edit documents.
This module/class also implements all the relatively low level
file loading/saving /reloading stuff.
"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo/core/editor.py')
except Exception:
    leo_g = None


import os, sys
import re, codecs

from pyzo.util.qt import QtCore, QtGui, QtWidgets
qt = QtGui

from pyzo.codeeditor import Manager
from pyzo.core.menu import EditorContextMenu
from pyzo.core.baseTextCtrl import BaseTextCtrl, normalizePath
from pyzo.core.pyzoLogging import print  # noqa
assert print
import pyzo

#
# Set default line ending (if not set)
if not pyzo.config.settings.defaultLineEndings:
    line_ending = 'CRLF' if sys.platform.startswith('win') else 'LF'
    pyzo.config.settings.defaultLineEndings = line_ending

</t>
<t tx="ekr.20190812072048.268">def determineEncoding(bb):
    """ Get the encoding used to encode a file.
    Accepts the bytes of the file. Returns the codec name. If the
    codec could not be determined, uses UTF-8.
    """

    # Init
    firstTwoLines = bb.split(b'\n', 2)[:2]
    encoding = 'UTF-8'

    for line in firstTwoLines:

        # Try to make line a string
        try:
            line = line.decode('ASCII').strip()
        except Exception:
            continue

        # Has comment?
        if line and line[0] == '#':

            # Matches regular expression given in PEP 0263?
            expression = "coding[:=]\s*([-\w.]+)"
            result = re.search(expression, line)
            if result:

                # Is it a known encoding? Correct name if it is
                candidate_encoding = result.group(1)
                try:
                    c = codecs.lookup(candidate_encoding)
                    candidate_encoding = c.name
                except Exception:
                    pass
                else:
                    encoding = candidate_encoding

    # Done
    return encoding
</t>
<t tx="ekr.20190812072048.269">def determineLineEnding(text):
    """ Get the line ending style used in the text.
    \n, \r, \r\n,
    The EOLmode is determined by counting the occurrences of each
    line ending...
    """
    # test line ending by counting the occurrence of each
    c_win = text.count("\r\n")
    c_mac = text.count("\r") - c_win
    c_lin = text.count("\n") - c_win
    # set the appropriate style
    if c_win &gt; c_mac and c_win &gt; c_lin:
        mode = '\r\n'
    elif c_mac &gt; c_win and c_mac &gt; c_lin:
        mode = '\r'
    else:
        mode = '\n'

    # return
    return mode
</t>
<t tx="ekr.20190812072048.27">def autoIndent(self):
    """ autoIndent()

    Get whether auto indentation is enabled.

    """
    return self.__autoIndent
</t>
<t tx="ekr.20190812072048.270">def determineIndentation(text):
    """ Get the indentation used in this document.
    The text is analyzed to find the most used
    indentations.
    The result is -1 if tab indents are most common.
    A positive result means spaces are used; the amount
    signifies the amount of spaces per indentation.
    0 is returned if the indentation could not be determined.
    """

    # create dictionary of indents, -1 means a tab
    indents = {}
    indents[-1] = 0

    lines = text.splitlines()
    lines.insert(0,"") # so the lines start at 1
    for i in range( len(lines) ):
        line = lines[i]

        # remove indentation
        tmp = line.lstrip()
        indent = len(line) - len(tmp)
        line = tmp.rstrip()

        if line.startswith('#'):
            continue
        else:
            # remove everything after the #
            line = line.split("#",1)[0].rstrip()
        if not line:
            # continue of no line left
            continue

        # a colon means there will be an indent
        # check the next line (or the one thereafter)
        # and calculate the indentation difference with THIS line.
        if line.endswith(":"):
            if len(lines) &gt; i+2:
                line2 = lines[i+1]
                tmp = line2.lstrip()
                if not tmp:
                    line2 = lines[i+2]
                    tmp = line2.lstrip()
                if tmp:
                    ind2 = len(line2)-len(tmp)
                    ind3 = ind2 - indent
                    if line2.startswith("\t"):
                        indents[-1] += 1
                    elif ind3&gt;0:
                        if not ind3 in indents:
                            indents[ind3] = 1
                        indents[ind3] += 1

    # find which was the most common tab width.
    indent, maxvotes = 0,0
    for nspaces in indents:
        if indents[nspaces] &gt; maxvotes:
            indent, maxvotes = nspaces, indents[nspaces]
    #print "found tabwidth %i" % indent
    return indent

# To give each new file a unique name
newFileCounter = 0
</t>
<t tx="ekr.20190812072048.271">def createEditor(parent, filename=None):
    """ Tries to load the file given by the filename and
    if succesful, creates an editor instance to put it in,
    which is returned.
    If filename is None, an new/unsaved/temp file is created.
    """
    
    # if leo_g: leo_g.pr('editor.py function.createEditor: %r' % filename)

    if filename is None:
        # Increase counter
        global newFileCounter
        newFileCounter  += 1
        # Create editor
        editor = PyzoEditor(parent)
        editor.document().setModified(True)
        # Set name
        editor._name = "&lt;tmp {}&gt;".format(newFileCounter)
    else:
        # check and normalize
        if not os.path.isfile(filename):
            raise IOError("File does not exist '%s'." % filename)
        # load file (as bytes)
        with open(filename, 'rb') as f:
            bb = f.read()
            f.close()
        # convert to text, be gentle with files not encoded with utf-8
        encoding = determineEncoding(bb)
        text = bb.decode(encoding,'replace')

        # process line endings
        lineEndings = determineLineEnding(text)

        # if we got here safely ...

        # create editor and set text
        editor = PyzoEditor(parent) # showlinenumbers=False)
        editor.setPlainText(text)
        editor.lineEndings = lineEndings
        editor.encoding = encoding
        editor.document().setModified(False)

        # store name and filename
        editor._filename = filename
        editor._name = os.path.split(filename)[1]

        # process indentation
        indentWidth = determineIndentation(text)
        if indentWidth == -1: #Tabs
            editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
            editor.setIndentUsingSpaces(False)
        elif indentWidth:
            editor.setIndentWidth(indentWidth)
            editor.setIndentUsingSpaces(True)

    if editor._filename:
        editor._modifyTime = os.path.getmtime(editor._filename)

    # Set parser
    if editor._filename:
        ext = os.path.splitext(editor._filename)[1]
        parser = Manager.suggestParser(ext, text)
        editor.setParser(parser)
    else:
        # todo: rename style -&gt; parser
        editor.setParser(pyzo.config.settings.defaultStyle)

    # return
    return editor
</t>
<t tx="ekr.20190812072048.272">class PyzoEditor(BaseTextCtrl):

    # called when dirty changed or filename changed, etc
    somethingChanged = QtCore.Signal()

    @others

### Don't allow this.
    # if __name__=="__main__":
        # # Do some stubbing to run this module as a unit separate from pyzo
        # # TODO: untangle pyzo from this module where possible
        # class DummyParser:
            # def parseThis(self, x):
                # pass
        # pyzo.parser = DummyParser()
        # EditorContextMenu = QtWidgets.QMenu  # noqa
        # app = QtWidgets.QApplication([])
        # win = PyzoEditor(None)
        # QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+C"), win).activated.connect(win.copy)
        # QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+X"), win).activated.connect(win.cut)
        # QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+V"), win).activated.connect(win.paste)
        # QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+Shift+V"), win).activated.connect(win.pasteAndSelect)
        # QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+Z"), win).activated.connect(win.undo)
        # QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+Y"), win).activated.connect(win.redo)
    
        # tmp = "foo(bar)\nfor bar in range(5):\n  print bar\n"
        # tmp += "\nclass aap:\n  def monkey(self):\n    pass\n\n"
        # win.setPlainText(tmp)
        # win.show()
        # app.exec_()
</t>
<t tx="ekr.20190812072048.273">def __init__(self, parent, **kwds):
    super().__init__(parent, showLineNumbers = True, **kwds)

    # Init filename and name
    self._filename = ''
    self._name = '&lt;TMP&gt;'

    # View settings
    self.setShowWhitespace(pyzo.config.view.showWhitespace)
    #TODO: self.setViewWrapSymbols(view.showWrapSymbols)
    self.setShowLineEndings(pyzo.config.view.showLineEndings)
    self.setShowIndentationGuides(pyzo.config.view.showIndentationGuides)
    #
    self.setWrap(bool(pyzo.config.view.wrap))
    self.setHighlightCurrentLine(pyzo.config.view.highlightCurrentLine)
    self.setLongLineIndicatorPosition(pyzo.config.view.edgeColumn)
    self.setHighlightMatchingBracket(pyzo.config.view.highlightMatchingBracket)
    #TODO: self.setFolding( int(view.codeFolding)*5 )
    # bracematch is set in baseTextCtrl, since it also applies to shells
    # dito for zoom and tabWidth

    # Set line endings to default
    self.lineEndings = pyzo.config.settings.defaultLineEndings

    # Set encoding to default
    self.encoding = 'UTF-8'

    # Modification time to test file change
    self._modifyTime = 0

    self.modificationChanged.connect(self._onModificationChanged)

    # To see whether the doc has changed to update the parser.
    self.textChanged.connect(self._onModified)

    # This timer is used to hide the marker that shows which code is executed
    self._showRunCursorTimer = QtCore.QTimer()

    # Add context menu (the offset is to prevent accidental auto-clicking)
    self._menu = EditorContextMenu(self)
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(lambda p: self._menu.popup(self.mapToGlobal(p)+QtCore.QPoint(0,3)))

## Properties
</t>
<t tx="ekr.20190812072048.274">@property
def name(self):
    return self._name
</t>
<t tx="ekr.20190812072048.275">@property
def filename(self):
    return self._filename
</t>
<t tx="ekr.20190812072048.276">@property
def lineEndings(self):
    """
    Line-endings style of this file. Setter accepts machine-readable (e.g. '\r') and human-readable (e.g. 'CR') input
    """
    return self._lineEndings
</t>
<t tx="ekr.20190812072048.277">@lineEndings.setter
def lineEndings(self,value):
    if value in ('\r','\n','\r\n'):
        self._lineEndings = value
        return
    try:
        self._lineEndings = {'CR': '\r', 'LF': '\n', 'CRLF': '\r\n'}[value]
    except KeyError:
        raise ValueError('Invalid line endings style %r' % value)
</t>
<t tx="ekr.20190812072048.278">@property
def lineEndingsHumanReadable(self):
    """
    Current line-endings style, human readable (e.g. 'CR')
    """
    return {'\r': 'CR', '\n': 'LF', '\r\n': 'CRLF'}[self.lineEndings]
</t>
<t tx="ekr.20190812072048.279">@property
def encoding(self):
    """ Encoding used to convert the text of this file to bytes.
    """
    return self._encoding

@encoding.setter
</t>
<t tx="ekr.20190812072048.28">@ce_option(True)
def setAutoIndent(self,value):
    """ setAutoIndent(value)

    Set whether to enable auto indentation.

    """
    self.__autoIndent = bool(value)
</t>
<t tx="ekr.20190812072048.280">def encoding(self, value):
    # Test given value, correct name if it exists
    try:
        c = codecs.lookup(value)
        value = c.name
    except Exception:
        value = codecs.lookup('UTF-8').name
    # Store
    self._encoding = value

##
</t>
<t tx="ekr.20190812072048.281">def justifyText(self):
    """ Overloaded version of justifyText to make it use our
    configurable justificationwidth.
    """
    super().justifyText(pyzo.config.settings.justificationWidth)
</t>
<t tx="ekr.20190812072048.282">def showRunCursor(self, cursor):
    """
    Momentarily highlight a piece of code to show that this is being executed
    """

    extraSelection = QtWidgets.QTextEdit.ExtraSelection()
    extraSelection.cursor = cursor
    extraSelection.format.setBackground(QtCore.Qt.gray)
    self.setExtraSelections([extraSelection])

    self._showRunCursorTimer.singleShot(200, lambda: self.setExtraSelections([]))
</t>
<t tx="ekr.20190812072048.283">def id(self):
    """ Get an id of this editor. This is the filename,
    or for tmp files, the name. """
    if self._filename:
        return self._filename
    else:
        return self._name
</t>
<t tx="ekr.20190812072048.284">def focusInEvent(self, event):
    """ Test whether the file has been changed 'behind our back'
    """
    # Act normally to the focus event
    BaseTextCtrl.focusInEvent(self, event)
    # Test file change
    self.testWhetherFileWasChanged()
</t>
<t tx="ekr.20190812072048.285">def testWhetherFileWasChanged(self):
    """ testWhetherFileWasChanged()
    Test to see whether the file was changed outside our backs,
    and let the user decide what to do.
    Returns True if it was changed.
    """

    # get the path
    path = self._filename
    if not os.path.isfile(path):
        # file is deleted from the outside
        return

    # test the modification time...
    mtime = os.path.getmtime(path)
    if mtime != self._modifyTime:

        # ask user
        dlg = QtWidgets.QMessageBox(self)
        dlg.setWindowTitle('File was changed')
        dlg.setText("File has been modified outside of the editor:\n"+
                    self._filename)
        dlg.setInformativeText("Do you want to reload?")
        t=dlg.addButton("Reload", QtWidgets.QMessageBox.AcceptRole) #0
        dlg.addButton("Keep this version", QtWidgets.QMessageBox.RejectRole) #1
        dlg.setDefaultButton(t)

        # whatever the result, we will reset the modified time
        self._modifyTime = os.path.getmtime(path)

        # get result and act
        result = dlg.exec_()
        if result == QtWidgets.QMessageBox.AcceptRole:
            self.reload()
        else:
            pass # when cancelled or explicitly said, do nothing

        # Return that indeed the file was changes
        return True
</t>
<t tx="ekr.20190812072048.286">def _onModificationChanged(self,changed):
    """Handler for the modificationChanged signal. Emit somethingChanged
    for the editorStack to update the modification notice."""
    self.somethingChanged.emit()
</t>
<t tx="ekr.20190812072048.287">def _onModified(self):
    pyzo.parser.parseThis(self)
</t>
<t tx="ekr.20190812072048.288">def dragMoveEvent(self, event):
    """ Otherwise cursor can get stuck.
    https://bitbucket.org/iep-project/iep/issue/252
    https://qt-project.org/forums/viewthread/3180
    """
    if event.mimeData().hasUrls():
        event.acceptProposedAction()
    else:
        BaseTextCtrl.dropEvent(self, event)
</t>
<t tx="ekr.20190812072048.289">def dropEvent(self, event):
    """ Drop files in the list. """
    if event.mimeData().hasUrls():
        # file: let the editorstack do the work.
        pyzo.editors.dropEvent(event)
    else:
        # text: act normal
        BaseTextCtrl.dropEvent(self, event)
</t>
<t tx="ekr.20190812072048.29">class PythonAutoIndent(object): # tag:CodeEditor

    @others
</t>
<t tx="ekr.20190812072048.290">def showEvent(self, event=None):
    """ Capture show event to change title. """
    # Act normally
    if event:
        BaseTextCtrl.showEvent(self, event)

    # Make parser update
    pyzo.parser.parseThis(self)
</t>
<t tx="ekr.20190812072048.291">def setTitleInMainWindow(self):
    """ set the title  text in the main window to show filename. """

    # compose title
    name, path = self._name, self._filename
    if path:
        pyzo.main.setMainTitle(path)
    else:
        pyzo.main.setMainTitle(name)
</t>
<t tx="ekr.20190812072048.292">def save(self, filename=None):
    """ Save the file. No checking is done. """

    # get filename
    if filename is None:
        filename = self._filename
    if not filename:
        raise ValueError("No filename specified, and no filename known.")

    # Test whether it was changed without us knowing. If so, dont save now.
    if self.testWhetherFileWasChanged():
        return

    # Get text and remember where we are
    text = self.toPlainText()
    cursor = self.textCursor()
    linenr = cursor.blockNumber() + 1
    index = cursor.positionInBlock()
    scroll = self.verticalScrollBar().value()

    # Convert line endings (optionally remove trailing whitespace
    if pyzo.config.settings.removeTrailingWhitespaceWhenSaving:
        lines = [line.rstrip() for line in text.split('\n')]
        if lines[-1]:
            lines.append('')  # Ensure the file ends in an empty line
        text = self.lineEndings.join(lines)
        self.setPlainText(text)
        # Go back to where we were
        cursor = self.textCursor()
        cursor.movePosition(cursor.Start) # move to begin of the document
        cursor.movePosition(cursor.NextBlock,n=linenr-1) # n blocks down
        index = min(index, cursor.block().length()-1)
        cursor.movePosition(cursor.Right,n=index) # n chars right
        self.setTextCursor(cursor)
        self.verticalScrollBar().setValue(scroll)
    else:
        text = text.replace('\n', self.lineEndings)

    # Make bytes
    bb = text.encode(self.encoding)

    # Store
    f = open(filename, 'wb')
    try:
        f.write(bb)
    finally:
        f.close()

    # Update stats
    self._filename = normalizePath( filename )
    self._name = os.path.split(self._filename)[1]
    self.document().setModified(False)
    self._modifyTime = os.path.getmtime(self._filename)

    # update title (in case of a rename)
    self.setTitleInMainWindow()

    # allow item to update its texts (no need: onModifiedChanged does this)
    #self.somethingChanged.emit()
</t>
<t tx="ekr.20190812072048.293">def reload(self):
    """ Reload text using the self._filename.
    We do not have a load method; we first try to load the file
    and only when we succeed create an editor to show it in...
    This method is only for reloading in case the file was changed
    outside of the editor. """

    # We can only load if the filename is known
    if not self._filename:
        return
    filename = self._filename

    # Remember where we are
    cursor = self.textCursor()
    linenr = cursor.blockNumber() + 1

    # Load file (as bytes)
    with open(filename, 'rb') as f:
        bb = f.read()

    # Convert to text
    text = bb.decode('UTF-8')

    # Process line endings (before setting the text)
    self.lineEndings= determineLineEnding(text)

    # Set text
    self.setPlainText(text)
    self.document().setModified(False)

    # Go where we were (approximately)
    self.gotoLine(linenr)
</t>
<t tx="ekr.20190812072048.294">def deleteLines(self):
    cursor = self.textCursor()
    # Find start and end of selection
    start = cursor.selectionStart()
    end = cursor.selectionEnd()
    # Expand selection: from start of first block to start of next block
    cursor.setPosition(start)
    cursor.movePosition(cursor.StartOfBlock)
    cursor.setPosition(end, cursor.KeepAnchor)
    cursor.movePosition(cursor.NextBlock, cursor.KeepAnchor)

    cursor.removeSelectedText()
</t>
<t tx="ekr.20190812072048.295">def duplicateLines(self):
    cursor = self.textCursor()
    # Find start and end of selection
    start = cursor.selectionStart()
    end = cursor.selectionEnd()
    # Expand selection: from start of first block to start of next block
    cursor.setPosition(start)
    cursor.movePosition(cursor.StartOfBlock)
    cursor.setPosition(end, cursor.KeepAnchor)
    cursor.movePosition(cursor.NextBlock, cursor.KeepAnchor)

    text = cursor.selectedText()
    cursor.setPosition(start)
    cursor.movePosition(cursor.StartOfBlock)
    cursor.insertText(text)
</t>
<t tx="ekr.20190812072048.296">def commentCode(self):
    """
    Comment the lines that are currently selected
    """
    indents = []

    def getIndent(cursor):
        text = cursor.block().text().rstrip()
        if text:
            indents.append(len(text) - len(text.lstrip()))

    def commentBlock(cursor):
        cursor.setPosition(cursor.block().position() + minindent)
        cursor.insertText('# ')

    self.doForSelectedBlocks(getIndent)
    minindent = min(indents) if indents else 0
    self.doForSelectedBlocks(commentBlock)
</t>
<t tx="ekr.20190812072048.297">def uncommentCode(self):
    """
    Uncomment the lines that are currently selected
    """
    #TODO: this should not be applied to lines that are part of a multi-line string

    #Define the uncomment function to be applied to all blocks
    def uncommentBlock(cursor):
        """
        Find the first # on the line; if there is just whitespace before it,
        remove the # and if it is followed by a space remove the space, too
        """
        text = cursor.block().text()
        commentStart = text.find('#')
        if commentStart == -1:
            return #No comment on this line
        if text[:commentStart].strip() != '':
            return #Text before the #
        #Move the cursor to the beginning of the comment
        cursor.setPosition(cursor.block().position() + commentStart)
        cursor.deleteChar()
        if text[commentStart:].startswith('# '):
            cursor.deleteChar()

    #Apply this function to all blocks
    self.doForSelectedBlocks(uncommentBlock)
</t>
<t tx="ekr.20190812072048.298">def gotoDef(self):
    """
    Goto the definition for the word under the cursor
    """

    # Get name of object to go to
    cursor = self.textCursor()
    if not cursor.hasSelection():
        cursor.select(cursor.WordUnderCursor)
    word = cursor.selection().toPlainText()

    # Send the open command to the shell
    s = pyzo.shells.getCurrentShell()
    if s is not None:
        if word and word.isidentifier():
            s.executeCommand('open %s\n'%word)
        else:
            s.write('Invalid identifier %r\n' % word)

## Introspection processing methods
</t>
<t tx="ekr.20190812072048.299">def processCallTip(self, cto):
    """ Processes a calltip request using a CallTipObject instance.
    """
    # Try using buffer first
    if cto.tryUsingBuffer():
        return

    # Try obtaining calltip from the source
    sig = pyzo.parser.getFictiveSignature(cto.name, self, True)
    if sig:
        # Done
        cto.finish(sig)
    else:
        # Try the shell
        shell = pyzo.shells.getCurrentShell()
        if shell:
            shell.processCallTip(cto)
</t>
<t tx="ekr.20190812072048.3">def autocompleteCancel(self):
    self.__completer.popup().hide()
    self.__autocompleteStart = None
</t>
<t tx="ekr.20190812072048.30">def keyPressEvent(self,event):
    super().keyPressEvent(event)
    if not self.autoIndent():
        return

    #This extension code is run *after* key is processed by QPlainTextEdit

    if event.key() in (Qt.Key_Enter,Qt.Key_Return):
        cursor=self.textCursor()

        # Prevent in-block newlines (issue #482)
        if not cursor.atBlockStart() and not cursor.hasSelection():
            cursor.deletePreviousChar()
            cursor.insertBlock()
            cursor=self.textCursor()

        previousBlock=cursor.block().previous()
        if previousBlock.isValid():
            line = ustr(previousBlock.text())
            indent=line[:len(line)-len(line.lstrip())]
            if line.endswith(':'):
                # We only need to add indent if the : is not in a (multiline)
                # string or comment. Therefore, find out what the syntax
                # highlighter thinks of the previous line.
                ppreviousBlock = previousBlock.previous() # the block before previous
                ppreviousState = ppreviousBlock.userState() if previousBlock.isValid() else 0
                lastElementToken = list(self.parser().parseLine(previousBlock.text(),ppreviousState))[-1]
                    # Because there's at least a : on that line, the list is never empty

                if (not isinstance(lastElementToken, (CommentToken, UnterminatedStringToken, BlockState))):
                    #TODO: check correct identation (no mixed space/tabs)
                    if self.indentUsingSpaces():
                        indent+=' '*self.indentWidth()
                    else:
                        indent+='\t'
            cursor.insertText(indent)
            #This prevents jump to start of line when up key is pressed
            self.setTextCursor(cursor)
</t>
<t tx="ekr.20190812072048.300">def processAutoComp(self, aco):
    """ Processes an autocomp request using an AutoCompObject instance.
    """

    # Try using buffer first
    if aco.tryUsingBuffer():
        return

    # Init name to poll by remote process (can be changed!)
    nameForShell = aco.name

    # Get normal fictive namespace
    fictiveNS = pyzo.parser.getFictiveNameSpace(self)
    fictiveNS = set(fictiveNS)

    # Add names
    if not aco.name:
        # "root" names
        aco.addNames(fictiveNS)
        # imports
        importNames, importLines = pyzo.parser.getFictiveImports(self)
        aco.addNames(importNames)
    else:
        # Prepare list of class names to check out
        classNames = [aco.name]
        handleSelf = True
        # Unroll supers
        while classNames:
            className = classNames.pop(0)
            if not className:
                continue
            if handleSelf or (className in fictiveNS):
                # Only the self list (only first iter)
                fictiveClass = pyzo.parser.getFictiveClass(
                    className, self, handleSelf)
                handleSelf = False
                if fictiveClass:
                    aco.addNames( fictiveClass.members )
                    classNames.extend(fictiveClass.supers)
            else:
                nameForShell = className
                break

    # If there's a shell, let it finish the autocompletion
    shell = pyzo.shells.getCurrentShell()
    if shell:
        aco.name = nameForShell # might be the same or a base class
        shell.processAutoComp(aco)
    else:
        # Otherwise we finish it ourselves
        aco.finish()
</t>
<t tx="ekr.20190812072048.301">@path pyzo/core/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.302"># -*- coding: utf-8 -*-
""" EditorTabs class

Replaces the earlier EditorStack class.

The editor tabs class represents the different open files. They can
be selected using a tab widget (with tabs placed north of the editor).
It also has a find/replace widget that is at the bottom of the editor.

"""

try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo/core/editorTabs.py')
except Exception:
    leo_g = None

import os, time, gc
from pyzo.util.qt import QtCore, QtGui, QtWidgets

import pyzo
from pyzo.core.compactTabWidget import CompactTabWidget
from pyzo.core.editor import createEditor
from pyzo.core.baseTextCtrl import normalizePath
from pyzo.core.pyzoLogging import print
from pyzo.core.icons import EditorTabToolButton
from pyzo import translate

# Constants for the alignments of tabs
MIN_NAME_WIDTH = 50
MAX_NAME_WIDTH = 200
</t>
<t tx="ekr.20190812072048.303">def simpleDialog(item, action, question, options, defaultOption):
    """ simpleDialog(editor, action, question, options, defaultOption)

    Options with special buttons
    ----------------------------
    ok, open, save, cancel, close, discard, apply, reset, restoredefaults,
    help, saveall, yes, yestoall, no, notoall, abort, retry, ignore.

    Returns the selected option as a string, or None if canceled.

    """

    # Get filename
    if isinstance(item, FileItem):
        filename = item.id
    else:
        filename = item.id()

    # create button map
    mb = QtWidgets.QMessageBox
    M = {   'ok':mb.Ok, 'open':mb.Open, 'save':mb.Save, 'cancel':mb.Cancel,
            'close':mb.Close, 'discard':mb.Discard, 'apply':mb.Apply,
            'reset':mb.Reset, 'restoredefaults':mb.RestoreDefaults,
            'help':mb.Help, 'saveall':mb.SaveAll, 'yes':mb.Yes,
            'yestoall':mb.YesToAll, 'no':mb.No, 'notoall':mb.NoToAll,
            'abort':mb.Abort, 'retry':mb.Retry, 'ignore':mb.Ignore}

    # setup dialog
    dlg = QtWidgets.QMessageBox(pyzo.main)
    dlg.setWindowTitle('Pyzo')
    dlg.setText(action + " file:\n{}".format(filename))
    dlg.setInformativeText(question)

    # process options
    buttons = {}
    for option in options:
        option_lower = option.lower()
        # Use standard button?
        if option_lower in M:
            button = dlg.addButton(M[option_lower])
        else:
            button = dlg.addButton(option, dlg.AcceptRole)
        buttons[button] = option
        # Set as default?
        if option_lower == defaultOption.lower():
            dlg.setDefaultButton(button)

    # get result
    dlg.exec_()
    button = dlg.clickedButton()
    if button in buttons:
        return buttons[button]
    else:
        return None
</t>
<t tx="ekr.20190812072048.304">def get_shortest_unique_filename(filename, filenames):
    """ Get a representation of filename in a way that makes it look
    unique compared to the other given filenames. The most unique part
    of the path is used, and every directory in between that part and the
    actual filename is represented with a slash.
    """

    # Normalize and avoid having filename itself in filenames
    filename1 = filename.replace('\\', '/')
    filenames = [fn.replace('\\', '/') for fn in filenames]
    filenames = [fn for fn in filenames if fn != filename1]

    # Prepare for finding uniqueness
    nameparts1 = filename1.split('/')
    uniqueness = [len(filenames) for i in nameparts1]

    # Establish what parts of the filename are not unique when compared to
    # each entry in filenames.
    for filename2 in filenames:
        nameparts2 = filename2.split('/')
        nonunique_for_this_filename = set()
        for i in range(len(nameparts1)):
            if i &lt; len(nameparts2):
                if nameparts2[i] == nameparts1[i]:
                    nonunique_for_this_filename.add(i)
                if nameparts2[-1-i] == nameparts1[-1-i]:
                    nonunique_for_this_filename.add(-i-1)
        for i in nonunique_for_this_filename:
            uniqueness[i] -= 1

    # How unique is the filename? If its not unique at all, use only base name
    max_uniqueness = max(uniqueness[:-1])
    if max_uniqueness == 0:
        return nameparts1[-1]

    # Produce display name based on base name and last most-unique part
    displayname = nameparts1[-1]
    for i in reversed(range(len(uniqueness)-1)):
        displayname = '/' + displayname
        if uniqueness[i] == max_uniqueness:
            displayname = nameparts1[i] + displayname
            break
    return displayname

# todo: some management stuff could (should?) go here
</t>
<t tx="ekr.20190812072048.305">class FileItem:
    """ FileItem(editor)

    A file item represents an open file. It is associated with an editing
    component and has a filename.

    """

    @others
</t>
<t tx="ekr.20190812072048.306">def __init__(self, editor):

    # Store editor
    self._editor = editor

    # Init pinned state
    self._pinned = False
</t>
<t tx="ekr.20190812072048.307">@property
def editor(self):
    """ Get the editor component corresponding to this item.
    """
    return self._editor
</t>
<t tx="ekr.20190812072048.308">@property
def id(self):
    """ Get an id of this editor. This is the filename,
    or for tmp files, the name. """
    if self.filename:
        return self.filename
    else:
        return self.name
</t>
<t tx="ekr.20190812072048.309">@property
def filename(self):
    """ Get the full filename corresponding to this item.
    """
    return self._editor.filename
</t>
<t tx="ekr.20190812072048.31">class SmartCopyAndPaste(object): # tag:CodeEditor
    """
    Smart copy and paste allows copying and pasting blocks

    """

    @others
</t>
<t tx="ekr.20190812072048.310">@property
def name(self):
    """ Get the name corresponding to this item.
    """
    return self._editor.name
</t>
<t tx="ekr.20190812072048.311">@property
def dirty(self):
    """ Get whether the file has been changed since it is changed.
    """
    return self._editor.document().isModified()
</t>
<t tx="ekr.20190812072048.312">@property
def pinned(self):
    """ Get whether this item is pinned (i.e. will not be closed
    when closing all files.
    """
    return self._pinned
</t>
<t tx="ekr.20190812072048.313"># todo: when this works with the new editor, put in own module.
class FindReplaceWidget(QtWidgets.QFrame):
    """ A widget to find and replace text. """

    @others
</t>
<t tx="ekr.20190812072048.314">def __init__(self, *args):
    QtWidgets.QFrame.__init__(self, *args)

    self.setFocusPolicy(QtCore.Qt.ClickFocus)

    # init layout
    layout = QtWidgets.QHBoxLayout(self)
    layout.setSpacing(0)
    self.setLayout(layout)

    # Create some widgets first to realize a correct tab order
    self._hidebut = QtWidgets.QToolButton(self)
    self._findText = QtWidgets.QLineEdit(self)
    self._replaceText = QtWidgets.QLineEdit(self)

    if True:
        # Create sub layouts
        vsubLayout = QtWidgets.QVBoxLayout()
        vsubLayout.setSpacing(0)
        layout.addLayout(vsubLayout, 0)

        # Add button
        self._hidebut.setFont( QtGui.QFont('helvetica',7) )
        self._hidebut.setToolTip(translate('search', 'Hide search widget (Escape)'))
        self._hidebut.setIcon( pyzo.icons.cancel )
        self._hidebut.setIconSize(QtCore.QSize(16,16))
        vsubLayout.addWidget(self._hidebut, 0)

        vsubLayout.addStretch(1)

    layout.addSpacing(10)

    if True:

        # Create sub layouts
        vsubLayout = QtWidgets.QVBoxLayout()
        hsubLayout = QtWidgets.QHBoxLayout()
        vsubLayout.setSpacing(0)
        hsubLayout.setSpacing(0)
        layout.addLayout(vsubLayout, 0)

        # Add find text
        self._findText.setToolTip(translate('search', 'Find pattern'))
        vsubLayout.addWidget(self._findText, 0)

        vsubLayout.addLayout(hsubLayout)

        # Add previous button
        self._findPrev = QtWidgets.QToolButton(self)
        t = translate('search', 'Previous ::: Find previous occurrence of the pattern.')
        self._findPrev.setText(t);  self._findPrev.setToolTip(t.tt)

        hsubLayout.addWidget(self._findPrev, 0)

        hsubLayout.addStretch(1)

        # Add next button
        self._findNext = QtWidgets.QToolButton(self)
        t = translate('search', 'Next ::: Find next occurrence of the pattern.')
        self._findNext.setText(t);  self._findNext.setToolTip(t.tt)
        #self._findNext.setDefault(True) # Not possible with tool buttons
        hsubLayout.addWidget(self._findNext, 0)

    layout.addSpacing(10)

    if True:

        # Create sub layouts
        vsubLayout = QtWidgets.QVBoxLayout()
        hsubLayout = QtWidgets.QHBoxLayout()
        vsubLayout.setSpacing(0)
        hsubLayout.setSpacing(0)
        layout.addLayout(vsubLayout, 0)

        # Add replace text
        self._replaceText.setToolTip(translate('search', 'Replace pattern'))
        vsubLayout.addWidget(self._replaceText, 0)

        vsubLayout.addLayout(hsubLayout)

        # Add replace button
        t = translate('search', 'Replace ::: Replace this match.')
        self._replaceBut = QtWidgets.QToolButton(self)
        self._replaceBut.setText(t)
        self._replaceBut.setToolTip(t.tt)
        hsubLayout.addWidget(self._replaceBut, 0)

        hsubLayout.addStretch(1)

        # Add replace kind combo
        self._replaceKind = QtWidgets.QComboBox(self)
        self._replaceKind.addItem(translate('search', 'one'))
        self._replaceKind.addItem(translate('search', 'all in this file'))
        self._replaceKind.addItem(translate('search', 'all in all files'))
        hsubLayout.addWidget(self._replaceKind, 0)

    layout.addSpacing(10)

    if True:

        # Create sub layouts
        vsubLayout = QtWidgets.QVBoxLayout()
        vsubLayout.setSpacing(0)
        layout.addLayout(vsubLayout, 0)

        # Add match-case checkbox
        t = translate('search', 'Match case ::: Find words that match case.')
        self._caseCheck = QtWidgets.QCheckBox(t, self)
        self._caseCheck.setToolTip(t.tt)
        vsubLayout.addWidget(self._caseCheck, 0)

        # Add regexp checkbox
        t = translate('search', 'RegExp ::: Find using regular expressions.')
        self._regExp = QtWidgets.QCheckBox(t, self)
        self._regExp.setToolTip(t.tt)
        vsubLayout.addWidget(self._regExp, 0)

    if True:

        # Create sub layouts
        vsubLayout = QtWidgets.QVBoxLayout()
        vsubLayout.setSpacing(0)
        layout.addLayout(vsubLayout, 0)

        # Add whole-word checkbox
        t = translate('search', 'Whole words ::: Find only whole words.')
        self._wholeWord = QtWidgets.QCheckBox(t, self)
        self._wholeWord.setToolTip(t.tt)
        self._wholeWord.resize(60, 16)
        vsubLayout.addWidget(self._wholeWord, 0)

        # Add autohide dropbox
        t = translate('search', 'Auto hide ::: Hide search/replace when unused for 10 s.')
        self._autoHide = QtWidgets.QCheckBox(t, self)
        self._autoHide.setToolTip(t.tt)
        self._autoHide.resize(60, 16)
        vsubLayout.addWidget(self._autoHide, 0)

    layout.addStretch(1)

    # Set placeholder texts
    for lineEdit in [self._findText, self._replaceText]:
        if hasattr(lineEdit, 'setPlaceholderText'):
            lineEdit.setPlaceholderText(lineEdit.toolTip())
        lineEdit.textChanged.connect(self.autoHideTimerReset)

    # Set focus policy
    for but in [self._findPrev, self._findNext,
                self._replaceBut,
                self._caseCheck, self._wholeWord, self._regExp]:
        #but.setFocusPolicy(QtCore.Qt.ClickFocus)
        but.clicked.connect(self.autoHideTimerReset)

    # create timer objects
    self._timerBeginEnd = QtCore.QTimer(self)
    self._timerBeginEnd.setSingleShot(True)
    self._timerBeginEnd.timeout.connect( self.resetAppearance )
    #
    self._timerAutoHide = QtCore.QTimer(self)
    self._timerAutoHide.setSingleShot(False)
    self._timerAutoHide.setInterval(500) # ms
    self._timerAutoHide.timeout.connect( self.autoHideTimerCallback )
    self._timerAutoHide_t0 = time.time()
    self._timerAutoHide.start()

    # create callbacks
    self._findText.returnPressed.connect(self.findNext)
    self._hidebut.clicked.connect(self.hideMe)
    self._findNext.clicked.connect(self.findNext)
    self._findPrev.clicked.connect(self.findPrevious)
    self._replaceBut.clicked.connect(self.replace)
    #
    self._regExp.stateChanged.connect(self.handleReplacePossible)

    # init case and regexp
    self._caseCheck.setChecked( bool(pyzo.config.state.find_matchCase) )
    self._regExp.setChecked( bool(pyzo.config.state.find_regExp) )
    self._wholeWord.setChecked(  bool(pyzo.config.state.find_wholeWord) )
    self._autoHide.setChecked(  bool(pyzo.config.state.find_autoHide) )

    # show or hide?
    if bool(pyzo.config.state.find_show):
        self.show()
    else:
        self.hide()
</t>
<t tx="ekr.20190812072048.315">def autoHideTimerReset(self):
    self._timerAutoHide_t0 = time.time()
</t>
<t tx="ekr.20190812072048.316">def autoHideTimerCallback(self):
    """ Check whether we should hide the tool.
    """
    timeout = pyzo.config.advanced.find_autoHide_timeout
    if self._autoHide.isChecked():
        if (time.time() - self._timerAutoHide_t0) &gt; timeout: # seconds
            # Hide if editor has focus
            self._replaceKind.setCurrentIndex(0)  # set replace to "one"
            es = self.parent() # editor stack
            editor = es.getCurrentEditor()
            if editor and editor.hasFocus():
                self.hide()
</t>
<t tx="ekr.20190812072048.317">def hideMe(self):
    """ Hide the find/replace widget. """
    self.hide()
    self._replaceKind.setCurrentIndex(0)  # set replace to "one"
    es = self.parent() # editor stack
    #es._boxLayout.activate()
    editor = es.getCurrentEditor()
    if editor:
        editor.setFocus()
</t>
<t tx="ekr.20190812072048.318">def event(self, event):
    """ Handle tab key and escape key. For the tab key we need to
    overload event instead of KeyPressEvent.
    """
    if isinstance(event, QtGui.QKeyEvent):
        if event.key() in (QtCore.Qt.Key_Tab, QtCore.Qt.Key_Backtab):
            event.accept() # focusNextPrevChild is called by Qt
            return True
        elif event.key() == QtCore.Qt.Key_Escape:
            self.hideMe()
            event.accept()
            return True
    # Otherwise ... handle in default manner
    return QtWidgets.QFrame.event(self, event)
</t>
<t tx="ekr.20190812072048.319">def handleReplacePossible(self, state):
    """ Disable replacing when using regular expressions.
    """
    for w in [self._replaceText, self._replaceBut, self._replaceKind]:
        w.setEnabled(not state)
</t>
<t tx="ekr.20190812072048.32">@staticmethod
def __setCursorPositionAndAnchor(cursor, position, anchor):
    cursor.setPosition(anchor)
    cursor.setPosition(position, cursor.KeepAnchor)
</t>
<t tx="ekr.20190812072048.320">def startFind(self,event=None):
    """ Use this rather than show(). It will check if anything is
    selected in the current editor, and if so, will set that as the
    initial search string
    """
    # show
    self.show()
    self.autoHideTimerReset()

    # get needle
    editor = self.parent().getCurrentEditor()
    if editor:
        needle = editor.textCursor().selectedText().replace('\u2029', '\n')
        if needle:
            self._findText.setText( needle )
    # select the find-text
    self.selectFindText()
</t>
<t tx="ekr.20190812072048.321">def notifyPassBeginEnd(self):
    self.setStyleSheet("QFrame { background:#f00; }")
    self._timerBeginEnd.start(300)
</t>
<t tx="ekr.20190812072048.322">def resetAppearance(self):
    self.setStyleSheet("QFrame {}")
</t>
<t tx="ekr.20190812072048.323">def selectFindText(self):
    """ Select the textcontrol for the find needle,
    and the text in it """
    # select text
    self._findText.selectAll()
    # focus
    self._findText.setFocus()
</t>
<t tx="ekr.20190812072048.324">def findNext(self, event=None):
    self.find()
    #self._findText.setFocus()
</t>
<t tx="ekr.20190812072048.325">def findPrevious(self, event=None):
    self.find(False)
    # self._findText.setFocus()
</t>
<t tx="ekr.20190812072048.326">def findSelection(self, event=None):
    self.startFind()
    self.findNext()
</t>
<t tx="ekr.20190812072048.327">def findSelectionBw(self, event=None):
    self.startFind()
    self.findPrevious()
</t>
<t tx="ekr.20190812072048.328">def find(self, forward=True, wrapAround=True, editor=None):
    """ The main find method.
    Returns True if a match was found. """

    # Reset timer
    self.autoHideTimerReset()

    # get editor
    if not editor:
        editor = self.parent().getCurrentEditor()
        if not editor:
            return

    # find flags
    flags = QtGui.QTextDocument.FindFlags()
    if self._caseCheck.isChecked():
        flags |= QtGui.QTextDocument.FindCaseSensitively
    if not forward:
        flags |= QtGui.QTextDocument.FindBackward
    #if self._wholeWord.isChecked():
    #    flags |= QtGui.QTextDocument.FindWholeWords

    # focus
    self.selectFindText()

    # get text to find
    needle = self._findText.text()
    if self._regExp.isChecked():
        #Make needle a QRegExp; speciffy case-sensitivity here since the
        #FindCaseSensitively flag is ignored when finding using a QRegExp
        needle = QtCore.QRegExp(needle,
            QtCore.Qt.CaseSensitive if self._caseCheck.isChecked() else
            QtCore.Qt.CaseInsensitive)
    elif self._wholeWord.isChecked():
        # Use regexp, because the default begaviour does not find
        # whole words correctly, see issue #276
        # it should *not* find this in this_word
        needle = QtCore.QRegExp(r'\b' + needle + r'\b',
            QtCore.Qt.CaseSensitive if self._caseCheck.isChecked() else
            QtCore.Qt.CaseInsensitive)

    # estblish start position
    cursor = editor.textCursor()
    result = editor.document().find(needle, cursor, flags)

    if not result.isNull():
        editor.setTextCursor(result)
    elif wrapAround:
        self.notifyPassBeginEnd()
        #Move cursor to start or end of document
        if forward:
            cursor.movePosition(cursor.Start)
        else:
            cursor.movePosition(cursor.End)
        #Try again
        result = editor.document().find(needle, cursor, flags)
        if not result.isNull():
            editor.setTextCursor(result)

    # done
    editor.setFocus()
    return not result.isNull()
</t>
<t tx="ekr.20190812072048.329">def replace(self, event=None):
    i = self._replaceKind.currentIndex()
    if i == 0:
        self.replaceOne(event)
    elif i == 1:
        self.replaceAll(event)
    elif i == 2:
        self.replaceInAllFiles(event)
    else:
        raise RuntimeError('Unexpected kind of replace %s' % i)
</t>
<t tx="ekr.20190812072048.33">@classmethod
def __ensureCursorBeforeAnchor(cls, cursor):
    """
    Given a cursor, modify it such that the cursor.position() is before or
    at cursor.anchor() and not the other way around.

    Returns: anchorBeforeCursor, i.e. whether originally the anchor was
    before the cursor
    """
    start = cursor.selectionStart()
    end = cursor.selectionEnd()
    # Remember whether the cursor is before or after the anchor
    anchorBeforeCursor = cursor.anchor() &lt; cursor.position()

    cls.__setCursorPositionAndAnchor(cursor, start, end)

    # Return wheter originally the cursor was before the anchor
    return anchorBeforeCursor
</t>
<t tx="ekr.20190812072048.330">def replaceOne(self, event=None, wrapAround=True, editor=None):
    """ If the currently selected text matches the find string,
    replaces that text. Then it finds and selects the next match.
    Returns True if a next match was found.
    """

    # get editor
    if not editor:
        editor = self.parent().getCurrentEditor()
        if not editor:
            return

    #Create a cursor to do the editing
    cursor = editor.textCursor()

    # matchCase
    matchCase = self._caseCheck.isChecked()

    # get text to find
    needle = self._findText.text()
    if not matchCase:
        needle = needle.lower()

    # get replacement
    replacement = self._replaceText.text()

    # get original text
    original = cursor.selectedText().replace('\u2029', '\n')
    if not original:
        original = ''
    if not matchCase:
        original = original.lower()

    # replace
    #TODO: &lt; line does not work for regexp-search!
    if original and original == needle:
        cursor.insertText( replacement )

    # next!
    return self.find(wrapAround=wrapAround, editor=editor)
</t>
<t tx="ekr.20190812072048.331">def replaceAll(self, event=None, editor=None):
    #TODO: share a cursor between all replaces, in order to
    #make this one undo/redo-step

    # get editor
    if not editor:
        editor = self.parent().getCurrentEditor()
        if not editor:
            return

    # get current position
    originalPosition = editor.textCursor()

    # Move to beginning of text and replace all
    # Make this a single undo operation
    cursor = editor.textCursor()
    cursor.beginEditBlock()
    try:
        cursor.movePosition(cursor.Start)
        editor.setTextCursor(cursor)
        while self.replaceOne(wrapAround=False, editor=editor):
            pass
    finally:
        cursor.endEditBlock()

    # reset position
    editor.setTextCursor(originalPosition)
</t>
<t tx="ekr.20190812072048.332">def replaceInAllFiles(self, event=None):

    for editor in pyzo.editors:
        self.replaceAll(event, editor)
</t>
<t tx="ekr.20190812072048.333">class FileTabWidget(CompactTabWidget):
    """ FileTabWidget(parent)

    The tab widget that contains the editors and lists all open files.

    """

    @others
</t>
<t tx="ekr.20190812072048.334">def __init__(self, parent):
    CompactTabWidget.__init__(self, parent, padding=(2,1,0,4))

    # Init main file
    self._mainFile = ''

    # Init item history
    self._itemHistory = []

    # EKR: These were underindented.
    #   # Create a corner widget
    #   but = QtWidgets.QToolButton()
    #   but.setIcon( pyzo.icons.cross )
    #   but.setIconSize(QtCore.QSize(16,16))
    #   but.clicked.connect(self.onClose)
    #   self.setCornerWidget(but)

    # Bind signal to update items and keep track of history
    self.currentChanged.connect(self.updateItems)
    self.currentChanged.connect(self.trackHistory)
    self.currentChanged.connect(self.setTitleInMainWindowWhenTabChanged)
    self.setTitleInMainWindowWhenTabChanged(-1)
</t>
<t tx="ekr.20190812072048.335">def setTitleInMainWindowWhenTabChanged(self, index):

    # Valid index?
    if index&lt;0 or index&gt;=self.count():
        pyzo.main.setMainTitle()  # No open file

    # Remove current item from history
    currentItem = self.currentItem()
    if currentItem:
        currentItem.editor.setTitleInMainWindow()

## Item management
</t>
<t tx="ekr.20190812072048.336">def items(self):
    """ Get the items in the tab widget. These are Item instances, and
    are in the order in which they are at the tab bar.
    """
    tabBar = self.tabBar()
    items = []
    for i in range(tabBar.count()):
        item = tabBar.tabData(i)
        if item is None:
            continue
        items.append(item)
    return items
</t>
<t tx="ekr.20190812072048.337">def currentItem(self):
    """ Get the item corresponding to the currently active tab.
    """
    i = self.currentIndex()
    if i&gt;=0:
        return self.tabBar().tabData(i)
</t>
<t tx="ekr.20190812072048.338">def getItemAt(self, i):
    return self.tabBar().tabData(i)
</t>
<t tx="ekr.20190812072048.339">def mainItem(self):
    """ Get the item corresponding to the "main" file. Returns None
    if there is no main file.
    """
    for item in self.items():
        if item.id == self._mainFile:
            return item
    else:
        return None
</t>
<t tx="ekr.20190812072048.34">def copy(self):
    """
    Smart copy: if selection is multi-line and in front of the start of the
    selection there is only whitespace, extend the selection to include only
    whitespace
    """
    cursor = self.textCursor()
    start = cursor.selectionStart()
    end = cursor.selectionEnd()

    # For our convenience, ensure that position is at start and
    # anchor is at the end, but remember whether originally the
    # anchor was before the cursor or the other way around
    anchorBeforeCursor = self.__ensureCursorBeforeAnchor(cursor)

    # Check if we have multi-line selection.
    block = cursor.block()
    # Use &gt; not &gt;= to ensure we don't count it as multi-line if the cursor
    # is just at the beginning of the next block (consistent with 'CodeEditor.doForSelectedLines')
    if end &gt; (block.position() + block.length()):

        # Now check if there is only whitespace before the start of selection
        # If so, include this whitespace in the selection and update the
        # selection of the editor
        textBeforeSelection = block.text()[:cursor.positionInBlock()]
        if len(textBeforeSelection.strip()) == 0:
            start = block.position() # Move start to include leading whitespace

            # Update the textcursor of our editor. If originally the
            # anchor was before the cursor, restore that situation
            if anchorBeforeCursor:
                self.__setCursorPositionAndAnchor(cursor, end, start)
            else:
                self.__setCursorPositionAndAnchor(cursor, start, end)

            self.setTextCursor(cursor)

    # Call our supers copy slot to do the actual copying
    super().copy()
</t>
<t tx="ekr.20190812072048.340">def trackHistory(self, index):
    """ trackHistory(index)

    Called when a tab is changed. Puts the current item on top of
    the history.

    """

    # Valid index?
    if index&lt;0 or index&gt;=self.count():
        return

    # Remove current item from history
    currentItem = self.currentItem()
    while currentItem in self._itemHistory:
        self._itemHistory.remove(currentItem)

    # Add current item to history
    self._itemHistory.insert(0, currentItem)

    # Limit history size
    self._itemHistory[10:] = []
</t>
<t tx="ekr.20190812072048.341">def setCurrentItem(self, item):
    """ _setCurrentItem(self, item)

    Set a FileItem instance to be the current. If the given item
    is not in the list, no action is taken.

    item can be an int, FileItem, or file name.
    """

    if isinstance(item, int):
        self.setCurrentIndex(item)

    elif isinstance(item, FileItem):

        items = self.items()
        for i in range(self.count()):
            if item is items[i]:
                self.setCurrentIndex(i)
                break

    elif isinstance(item, str):

        items = self.items()
        for i in range(self.count()):
            if item == items[i].filename:
                self.setCurrentIndex(i)
                break

    else:
        raise ValueError('item should be int, FileItem or file name.')
</t>
<t tx="ekr.20190812072048.342">def selectPreviousItem(self):
    """ Select the previously selected item. """

    # make an old item history
    if len(self._itemHistory)&gt;1 and self._itemHistory[1] is not None:
        item = self._itemHistory[1]
        self.setCurrentItem(item)

    # just select first one then ...
    elif self.count():
        item = 0
        self.setCurrentItem(item)

## Closing, adding and updating
</t>
<t tx="ekr.20190812072048.343">def onClose(self):
    """ onClose()

    Request to close the current tab.

    """

    self.tabCloseRequested.emit(self.currentIndex())
</t>
<t tx="ekr.20190812072048.344">def removeTab(self, which):
    """ removeTab(which)

    Removes the specified tab. which can be an integer, an item,
    or an editor.

    """

    # Init
    items = self.items()
    theIndex = -1

    # Find index
    if isinstance(which, int) and which&gt;=0 and which&lt;len(items):
        theIndex = which

    elif isinstance(which, FileItem):
        for i in range(self.count()):
            if items[i] is which:
                theIndex = i
                break

    elif isinstance(which, str):
        for i in range(self.count()):
            if items[i].filename == which:
                theIndex = i
                break

    elif hasattr(which, '_filename'):
        # if leo_g: leo_g.trace('LOOK FOR', which._filename)
        for i in range(self.count()):
            if items[i].filename == which._filename:
                # if leo_g: leo_g.trace('FOUND', which._filename)
                theIndex = i
                break
            # elif leo_g: leo_g.trace('NO MATCH', items[i].filename)

    else:
        raise ValueError('removeTab accepts a FileItem, integer, file name, or editor.')

    if theIndex &gt;= 0:

        # Close tab
        CompactTabWidget.removeTab(self, theIndex)

        # Delete editor
        items[theIndex].editor.destroy()
        gc.collect()
        
    # elif leo_g: leo_g.trace('NOT FOUND: not closing tab.')
</t>
<t tx="ekr.20190812072048.345">def addItem(self, item, update=True):
    """ addItem(item, update=True)

    Add item to the tab widget. Set update to false if you are
    calling this method many times in a row. Then use updateItemsFull()
    to update the tab widget.

    """
    
    # if leo_g: leo_g.pr('----- FileTabWidget.addItem', item)

    # Add tab and widget
    i = self.addTab(item.editor, item.name)
    tabBut = EditorTabToolButton(self.tabBar())
    self.tabBar().setTabButton(i, QtWidgets.QTabBar.LeftSide, tabBut)

    # Keep informed about changes
    item.editor.somethingChanged.connect(self.updateItems)
    item.editor.blockCountChanged.connect(self.updateItems)
    item.editor.breakPointsChanged.connect(self.parent().updateBreakPoints)

    # Store the item at the tab
    self.tabBar().setTabData(i, item)

    # Emit the currentChanged again (already emitted on addTab), because
    # now the itemdata is actually set
    self.currentChanged.emit(self.currentIndex())

    # Update
    if update:
        self.updateItems()
</t>
<t tx="ekr.20190812072048.346">def updateItemsFull(self):
    """ updateItemsFull()

    Update the appearance of the items and also updates names and
    re-aligns the items.

    """
    self.updateItems()
    self.tabBar().alignTabs()
</t>
<t tx="ekr.20190812072048.347">def updateItems(self):
    """ updateItems()

    Update the appearance of the items.

    """

    # Get items and tab bar
    items = self.items()
    tabBar = self.tabBar()

    # Check whether we have name clashes, which we can try to resolve
    namecounts = {}
    for i in range(len(items)):
        item = items[i]
        if item is None:
            continue
        xx = namecounts.setdefault(item.name, [])
        xx.append(item)

    for i in range(len(items)):

        # Get item
        item = items[i]
        if item is None:
            continue

        # Get display name
        items_with_this_name = namecounts[item.name]
        if len(items_with_this_name) &lt;= 1:
            display_name = item.name
        else:
            filenames = [j.filename for j in items_with_this_name]
            try:
                display_name = get_shortest_unique_filename(item.filename, filenames)
            except Exception as err:
                # Catch this, just in case ...
                print('could not get unique name for:\n%r' % filenames)
                print(err)
                display_name = item.name

        tabBar.setTabText(i, display_name)

        # Update name and tooltip
        if item.dirty:
            tabBar.setTabToolTip(i, item.filename + ' [modified]')
        else:
            tabBar.setTabToolTip(i, item.filename)

        # Determine text color. Is main file? Is current?
        if self._mainFile == item.id:
            tabBar.setTabTextColor(i, QtGui.QColor('#008'))
        elif i == self.currentIndex():
            tabBar.setTabTextColor(i, QtGui.QColor('#000'))
        else:
            tabBar.setTabTextColor(i, QtGui.QColor('#444'))

        # Get number of blocks
        nBlocks = item.editor.blockCount()
        if nBlocks == 1 and not item.editor.toPlainText():
            nBlocks = 0

        # Update appearance of icon
        but = tabBar.tabButton(i, QtWidgets.QTabBar.LeftSide)
        but.updateIcon(item.dirty, self._mainFile==item.id,
                    item.pinned, nBlocks)
</t>
<t tx="ekr.20190812072048.348">class EditorTabs(QtWidgets.QWidget):
    """ The EditorTabs instance manages the open files and corresponding
    editors. It does the saving loading etc.
    """

    # Signal to indicate that a breakpoint has changed, emits dict
    breakPointsChanged = QtCore.Signal(object)

    # Signal to notify that a different file was selected
    currentChanged = QtCore.Signal()

    # Signal to notify that the parser has parsed the text (emit by parser)
    parserDone = QtCore.Signal()

    @others
</t>
<t tx="ekr.20190812072048.349">def __init__(self, parent):
    QtWidgets.QWidget.__init__(self,parent)
    self.setObjectName('EditorTabs')

    # keep a booking of opened directories
    self._lastpath = ''

    # keep track of all breakpoints
    self._breakPoints = {}

    # create tab widget
    self._tabs = FileTabWidget(self)
    self._tabs.tabCloseRequested.connect(self.closeFile)
    self._tabs.currentChanged.connect(self.onCurrentChanged)

    # Double clicking a tab saves the file, clicking on the bar opens a new file
    self._tabs.tabBar().tabDoubleClicked.connect(self.saveFile)
    self._tabs.tabBar().barDoubleClicked.connect(self.newFile)

    # Create find/replace widget
    self._findReplace = FindReplaceWidget(self)

    # create box layout control and add widgets
    self._boxLayout = QtWidgets.QVBoxLayout(self)
    self._boxLayout.addWidget(self._tabs, 1)
    self._boxLayout.addWidget(self._findReplace, 0)
    # spacing of widgets
    self._boxLayout.setSpacing(0)
    # apply
    self.setLayout(self._boxLayout)

    #self.setAttribute(QtCore.Qt.WA_AlwaysShowToolTips,True)

    # accept drops
    self.setAcceptDrops(True)

    # restore state (call later so that the menu module can bind to the
    # currentChanged signal first, in order to set tab/indentation
    # checkmarks appropriately)
    # todo: Resetting the scrolling would work better if set after
    # the widgets are properly sized.
    pyzo.callLater(self.restoreEditorState)
</t>
<t tx="ekr.20190812072048.35">def cut(self):
    """
    Cutting with smart-copy: the part that is copies is the same as self.copy(),
    but the part that is removed is only the original selection

    see: Qt qtextcontrol.cpp, cut()
    """
    if (self.textInteractionFlags() &amp; QtCore.Qt.TextEditable) and \
            self.textCursor().hasSelection():

        cursor = self.textCursor()
        self.copy()
        # Restore original cursor
        self.setTextCursor(cursor)
        cursor.removeSelectedText()
</t>
<t tx="ekr.20190812072048.350">def addContextMenu(self):
    """ Adds a context menu to the tab bar """

    from pyzo.core.menu import EditorTabContextMenu
    self._menu = EditorTabContextMenu(self, "EditorTabMenu")
    self._tabs.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self._tabs.customContextMenuRequested.connect(self.contextMenuTriggered)
</t>
<t tx="ekr.20190812072048.351">def contextMenuTriggered(self, p):
    """ Called when context menu is clicked """

    # Get index of current tab
    index = self._tabs.tabBar().tabAt(p)
    self._menu.setIndex(index)

    # Show menu if item is available
    if index &gt;= 0:
        p = self._tabs.tabBar().tabRect(index).bottomLeft()
        self._menu.popup(self._tabs.tabBar().mapToGlobal(p))
</t>
<t tx="ekr.20190812072048.352">def onCurrentChanged(self):
    self.currentChanged.emit()
</t>
<t tx="ekr.20190812072048.353">def getCurrentEditor(self):
    """ Get the currently active editor. """
    item = self._tabs.currentItem()
    if item:
        return item.editor
    else:
        return None
</t>
<t tx="ekr.20190812072048.354">def getMainEditor(self):
    """ Get the editor that represents the main file, or None if
    there is no main file. """
    item = self._tabs.mainItem()
    if item:
        return item.editor
    else:
        return None
</t>
<t tx="ekr.20190812072048.355">def __iter__(self):
    tmp = [item.editor for item in self._tabs.items()]
    return tmp.__iter__()
</t>
<t tx="ekr.20190812072048.356">def updateBreakPoints(self, editor=None):
    # Get list of editors to update keypoints for
    if editor is None:
        editors = self
        self._breakPoints = {}  # Full reset
    else:
        editors = [editor]

    # Update our keypoints dict
    for editor in editors:
        fname = editor._filename or editor._name
        if not fname:
            continue
        linenumbers = editor.breakPoints()
        if linenumbers:
            self._breakPoints[fname] = linenumbers
        else:
            self._breakPoints.pop(fname, None)

    # Emit signal so shells can update the kernel
    self.breakPointsChanged.emit(self._breakPoints)
</t>
<t tx="ekr.20190812072048.357">def setDebugLineIndicators(self, *filename_linenr):
    """ Set the debug line indicator. There is one indicator
    global to pyzo, corresponding to the last shell for which we
    received the indicator.
    """
    if len(filename_linenr) and filename_linenr[0] is None:
        filename_linenr = []

    # Normalize case
    filename_linenr = [(os.path.normcase(i[0]), int(i[1])) for i in filename_linenr]

    for item in self._tabs.items():
        # Prepare
        editor = item._editor
        fname = editor._filename or editor._name
        fname = os.path.normcase(fname)
        # Reset
        editor.setDebugLineIndicator(None)
        # Set
        for filename, linenr in filename_linenr:
            if fname == filename:
                active = (filename, linenr) == filename_linenr[-1]
                editor.setDebugLineIndicator(linenr, active)

## Loading ad saving files
</t>
<t tx="ekr.20190812072048.358">def dragEnterEvent(self, event):
    if event.mimeData().hasUrls():
        event.acceptProposedAction()
</t>
<t tx="ekr.20190812072048.359">def dropEvent(self, event):
    """ Drop files in the list. """
    for qurl in event.mimeData().urls():
        path = str( qurl.toLocalFile() )
        if os.path.isfile(path):
            self.loadFile(path)
        elif os.path.isdir(path):
            self.loadDir(path)
        else:
            pass
</t>
<t tx="ekr.20190812072048.36">def paste(self):
    """
    Smart paste
    If you paste on a position that has only whitespace in front of it,
    remove the whitespace before pasting. Combined with smart copy,
    this ensure indentation of the
    """
    self._paste(keepSelection = False)
</t>
<t tx="ekr.20190812072048.360">def newFile(self):
    """ Create a new (unsaved) file. """

    # create editor
    editor = createEditor(self, None)
    editor.document().setModified(False)  # Start out as OK
    # add to list
    item = FileItem(editor)
    self._tabs.addItem(item)
    self._tabs.setCurrentItem(item)
    # set focus to new file
    editor.setFocus()

    return item
</t>
<t tx="ekr.20190812072048.361">def openFile(self):
    """ Create a dialog for the user to select a file. """

    # determine start dir
    # todo: better selection of dir, using project manager
    editor = self.getCurrentEditor()
    if editor and editor._filename:
        startdir = os.path.split(editor._filename)[0]
    else:
        startdir = self._lastpath
    if (not startdir) or (not os.path.isdir(startdir)):
        startdir = ''

    # show dialog
    msg = translate("editorTabs", "Select one or more files to open")
    filter =  "Python (*.py *.pyw);;"
    filter += "Pyrex (*.pyi *.pyx *.pxd);;"
    filter += "C (*.c *.h *.cpp *.c++);;"
    #filter += "Py+Cy+C (*.py *.pyw *.pyi *.pyx *.pxd *.c *.h *.cpp);;"
    filter += "All (*)"
    if True:
        filenames = QtWidgets.QFileDialog.getOpenFileNames(self,
            msg, startdir, filter)
        if isinstance(filenames, tuple): # PySide
            filenames = filenames[0]
    else:
        # Example how to preselect files, can be used when the users
        # opens a file in a project to select all files currently not
        # loaded.
        d = QtWidgets.QFileDialog(self, msg, startdir, filter)
        d.setFileMode(d.ExistingFiles)
        d.selectFile('"codeparser.py" "editorStack.py"')
        d.exec_()
        if d.result():
            filenames = d.selectedFiles()
        else:
            filenames = []

    # were some selected?
    if not filenames:
        return

    # load
    for filename in filenames:
        self.loadFile(filename)
</t>
<t tx="ekr.20190812072048.362">def openDir(self):
    """ Create a dialog for the user to select a directory. """

    # determine start dir
    editor = self.getCurrentEditor()
    if editor and editor._filename:
        startdir = os.path.split(editor._filename)[0]
    else:
        startdir = self._lastpath
    if not os.path.isdir(startdir):
        startdir = ''

    # show dialog
    msg = "Select a directory to open"
    dirname = QtWidgets.QFileDialog.getExistingDirectory(self, msg, startdir)

    # was a dir selected?
    if not dirname:
        return

    # load
    self.loadDir(dirname)
</t>
<t tx="ekr.20190812072048.363">def loadFile(self, filename, updateTabs=True):
    """ Load the specified file.
    On success returns the item of the file, also if it was
    already open."""
    
    if leo_g: leo_g.pr('EditorTabs.createEditor: %r' % filename)

    # Note that by giving the name of a tempfile, we can select that
    # temp file.

    # normalize path
    if filename[0] != '&lt;':
        filename = normalizePath(filename)
    if not filename:
        return None

    # if the file is already open...
    for item in self._tabs.items():
        if item.id == filename:
            # id gets _filename or _name for temp files
            break
    else:
        item = None
    if item:
        self._tabs.setCurrentItem(item)
        print("File already open: '{}'".format(filename))
        return item

    # create editor
    try:
        editor = createEditor(self, filename)
    except Exception as err:
        # Notify in logger
        print("Error loading file: ", err)
        # Make sure the user knows
        m = QtWidgets.QMessageBox(self)
        m.setWindowTitle("Error loading file")
        m.setText(str(err))
        m.setIcon(m.Warning)
        m.exec_()
        return None

    # create list item
    item = FileItem(editor)
    self._tabs.addItem(item, updateTabs)
    if updateTabs:
        self._tabs.setCurrentItem(item)

    # store the path
    self._lastpath = os.path.dirname(item.filename)

    return item
</t>
<t tx="ekr.20190812072048.364">def loadDir(self, path):
    """ Create a project with the dir's name and add all files
    contained in the directory to it.
    extensions is a komma separated list of extenstions of files
    to accept...
    """

    # if the path does not exist, stop
    path = os.path.abspath(path)
    if not os.path.isdir(path):
        print("ERROR loading dir: the specified directory does not exist!")
        return

    # get extensions
    extensions = pyzo.config.advanced.fileExtensionsToLoadFromDir
    extensions = extensions.replace(',',' ').replace(';',' ')
    extensions = ["."+a.lstrip(".").strip() for a in extensions.split(" ")]

    # init item
    item = None

    # open all qualified files...
    self._tabs.setUpdatesEnabled(False)
    try:
        filelist = os.listdir(path)
        for filename in filelist:
            filename = os.path.join(path, filename)
            ext = os.path.splitext(filename)[1]
            if str(ext) in extensions:
                item = self.loadFile(filename, False)
    finally:
        self._tabs.setUpdatesEnabled(True)
        self._tabs.updateItems()

    # return lastopened item
    return item
</t>
<t tx="ekr.20190812072048.365">def saveFileAs(self, editor=None):
    """ Create a dialog for the user to select a file.
    returns: True if succesfull, False if fails
    """

    # get editor
    if editor is None:
        editor = self.getCurrentEditor()
    if editor is None:
        return False

    # get startdir
    if editor._filename:
        startdir = os.path.dirname(editor._filename)
    else:
        startdir = self._lastpath
        # Try the file browser or project manager to suggest a path
        fileBrowser = pyzo.toolManager.getTool('pyzofilebrowser')
        projectManager = pyzo.toolManager.getTool('pyzoprojectmanager')
        if fileBrowser:
            startdir = fileBrowser.getDefaultSavePath()
        if projectManager and not startdir:
            startdir = projectManager.getDefaultSavePath()

    if not os.path.isdir(startdir):
        startdir = ''

    # show dialog
    msg = translate("editorTabs", "Select the file to save to")
    filter =  "Python (*.py *.pyw);;"
    filter += "Pyrex (*.pyi *.pyx *.pxd);;"
    filter += "C (*.c *.h *.cpp);;"
    #filter += "Py+Cy+C (*.py *.pyw *.pyi *.pyx *.pxd *.c *.h *.cpp);;"
    filter += "All (*.*)"
    filename = QtWidgets.QFileDialog.getSaveFileName(self,
        msg, startdir, filter)
    if isinstance(filename, tuple): # PySide
        filename = filename[0]

    # give python extension if it has no extension
    head, tail = os.path.split(filename)
    if tail and '.' not in tail:
        filename += '.py'

    # proceed or cancel
    if filename:
        return self.saveFile(editor, filename)
    else:
        return False # Cancel was pressed
</t>
<t tx="ekr.20190812072048.366">def saveFile(self, editor=None, filename=None):
    """ Save the file.
    returns: True if succesfull, False if fails
    """

    # get editor
    if editor is None:
        editor = self.getCurrentEditor()
    elif isinstance(editor, int):
        index = editor
        editor = None
        if index&gt;=0:
            item = self._tabs.items()[index]
            editor = item.editor
    if editor is None:
        return False

    # get filename
    if filename is None:
        filename = editor._filename
    if not filename:
        return self.saveFileAs(editor)

    # let the editor do the low level stuff...
    try:
        editor.save(filename)
    except Exception as err:
        # Notify in logger
        print("Error saving file:",err)
        # Make sure the user knows
        m = QtWidgets.QMessageBox(self)
        m.setWindowTitle("Error saving file")
        m.setText(str(err))
        m.setIcon(m.Warning)
        m.exec_()
        # Return now
        return False

    # get actual normalized filename
    filename = editor._filename

    # notify
    # TODO: message concerining line endings
    print("saved file: {} ({})".format(filename, editor.lineEndingsHumanReadable))
    self._tabs.updateItems()

    # todo: this is where we once detected whether the file being saved was a style file.

    # Notify done
    return True
</t>
<t tx="ekr.20190812072048.367">def saveAllFiles(self):
    """ Save all files"""
    for editor in self:
        self.saveFile(editor)

## Closing files / closing down
</t>
<t tx="ekr.20190812072048.368">def _get_action_texts(self):
    options = translate("editor", "Close, Discard, Cancel, Save").split(',')
    options = [i.strip() for i in options]
    try:
        close_txt, discard_txt, cancel_txt, save_txt = options
    except Exception:
        print('error in translation for close, discard, cancel, save.')
        close_txt, discard_txt, cancel_txt, save_txt = "Close", "Discard", "Cancel", "Save"
    return close_txt, discard_txt, cancel_txt, save_txt
</t>
<t tx="ekr.20190812072048.369">def askToSaveFileIfDirty(self, editor):
    """ askToSaveFileIfDirty(editor)

    If the given file is not saved, pop up a dialog
    where the user can save the file

    Returns 1 if file need not be saved.
    Returns 2 if file was saved.
    Returns 3 if user discarded changes.
    Returns 0 if cancelled.

    """

    # should we ask to save the file?
    if editor.document().isModified():

        # Ask user what to do
        close_txt, discard_txt, cancel_txt, save_txt = self._get_action_texts()
        result = simpleDialog(editor, translate("editor", "Closing"),
                              translate("editor", "Save modified file?"),
                              [discard_txt, cancel_txt, save_txt], save_txt)

        # Get result and act
        if result == save_txt:
            return 2 if self.saveFile(editor) else 0
        elif result == discard_txt:
            return 3
        else: # cancel
            return 0

    return 1
</t>
<t tx="ekr.20190812072048.37">def pasteAndSelect(self):
    """
    Smart paste
    Like paste(), but keep the part that was pasted selected. This allows
    you to change the indentation after pasting using tab / shift-tab
    """
    self._paste(keepSelection = True)
</t>
<t tx="ekr.20190812072048.370">def closeFile(self, editor=None):
    """ Close the selected (or current) editor.
    Returns same result as askToSaveFileIfDirty() """
    
    # get editor
    if editor is None:
        editor = self.getCurrentEditor()
        item = self._tabs.currentItem()
    elif isinstance(editor, int):
        index = editor
        editor, item = None, None
        if index&gt;=0:
            item = self._tabs.items()[index]
            editor = item.editor
    else:
        item = None
        for i in self._tabs.items():
            if i.editor is editor:
                item = i
    if editor is None or item is None:
        return

    # Ask if dirty
    result = self.askToSaveFileIfDirty(editor)

    # Ask if closing pinned file
    close_txt, discard_txt, cancel_txt, save_txt = self._get_action_texts()
    if result and item.pinned:
        result = simpleDialog(editor, translate("editor", "Closing pinned"),
            translate("editor", "Are you sure you want to close this pinned file?"),
            [close_txt, cancel_txt], cancel_txt)
        result = result == close_txt

    # ok, close...
    if result:
        if editor._name.startswith("&lt;tmp"):
            # Temp file, try to find its index
            for i in range(len(self._tabs.items())):
                if self._tabs.getItemAt(i).editor is editor:
                    self._tabs.removeTab(i)
                    break
        else:
            self._tabs.removeTab(editor)

    # Clear any breakpoints that it may have had
    self.updateBreakPoints()
    return result
</t>
<t tx="ekr.20190812072048.371">def closeAllFiles(self):
    """Close all files"""
    for editor in self:
        self.closeFile(editor)
</t>
<t tx="ekr.20190812072048.372">def saveEditorState(self):
    """ Save the editor's state configuration.
    """
    fr = self._findReplace
    pyzo.config.state.find_matchCase = fr._caseCheck.isChecked()
    pyzo.config.state.find_regExp = fr._regExp.isChecked()
    pyzo.config.state.find_wholeWord = fr._wholeWord.isChecked()
    pyzo.config.state.find_show = fr.isVisible()
    #
    pyzo.config.state.editorState2 = self._getCurrentOpenFilesAsSsdfList()
</t>
<t tx="ekr.20190812072048.373">def restoreEditorState(self):
    """ Restore the editor's state configuration.
    """
    
    # if leo_g: leo_g.printObj(pyzo.config.settings)
    
    if 1: ### Don't open the pyzo file.
        self.newFile()
        return
    
    # Restore opened editors
    if pyzo.config.state.editorState2:
        ok = self._setCurrentOpenFilesAsSsdfList(pyzo.config.state.editorState2)
        if not ok:
            self.newFile()
    else:
        self.newFile()

    # The find/replace state is set in the corresponding class during init
</t>
<t tx="ekr.20190812072048.374">def _getCurrentOpenFilesAsSsdfList(self):
    """ Get the state as it currently is as an ssdf list.
    The state entails all open files and their structure in the
    projects. The being collapsed of projects and their main files.
    The position of the cursor in the editors.
    """

    # Init
    state = []

    # Get items
    for item in self._tabs.items():

        # Get editor
        ed = item.editor
        if not ed._filename:
            continue

        # Init info
        info = []
        # Add filename, line number, and scroll distance
        info.append(ed._filename)
        info.append(int(ed.textCursor().position()))
        info.append(int(ed.verticalScrollBar().value()))
        # Add whether pinned or main file
        if item.pinned:
            info.append('pinned')
        if item.id == self._tabs._mainFile:
            info.append('main')

        # Add to state
        state.append( tuple(info) )

    # Get history
    history = [item for item in self._tabs._itemHistory]
    history.reverse() # Last one is current
    for item in history:
        if isinstance(item, FileItem):
            ed = item._editor
            if ed._filename:
                state.append( (ed._filename, 'hist') )

    # Done
    return state
</t>
<t tx="ekr.20190812072048.375">def _setCurrentOpenFilesAsSsdfList(self, state):
    """ Set the state of the editor in terms of opened files.
    The input should be a list object as returned by
    ._getCurrentOpenFilesAsSsdfList().
    """

    # Init dict
    fileItems = {}

    # Process items
    for item in state:
        fname = item[0]
        if os.path.exists(fname):
            if item[1] == 'hist':
                # select item (to make the history right)
                if fname in fileItems:
                    self._tabs.setCurrentItem( fileItems[fname] )
            elif fname:
                # a file item, create editor-item and store
                itm = self.loadFile(fname)
                fileItems[fname] = itm
                # set position
                if itm:
                    try:
                        ed = itm.editor
                        cursor = ed.textCursor()
                        cursor.setPosition(int(item[1]))
                        ed.setTextCursor(cursor)
                        # set scrolling
                        ed.verticalScrollBar().setValue(int(item[2]))
                        #ed.centerCursor() #TODO: this does not work properly yet
                        # set main and/or pinned?
                        if 'main' in item:
                            self._tabs._mainFile = itm.id
                        if 'pinned' in item:
                            itm._pinned = True
                    except Exception as err:
                        print('Could not set position for %s' % fname, err)

    return len(fileItems) != 0
</t>
<t tx="ekr.20190812072048.376">def closeAll(self):
    """ Close all files (well technically, we don't really close them,
    so that they are all stil there when the user presses cancel).
    Returns False if the user pressed cancel when asked for
    saving an unsaved file.
    """

    # try closing all editors.
    for editor in self:
        result = self.askToSaveFileIfDirty(editor)
        if not result:
            # if leo_g: leo_g.pr('EditorTabs.closeAll: editor returned False: %r' % editor)
            return False

    # we're good to go closing
    return True
</t>
<t tx="ekr.20190812072048.377">@path pyzo/core/
@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072048.378">import os
import datetime

import pyzo
from pyzo.util.qt import QtCore, QtGui, QtWidgets  # noqa
</t>
<t tx="ekr.20190812072048.379">class CommandHistory(QtCore.QObject):
    """ Keep track of a (global) history of commands.

    This kinda assumes Python commands, but should be easy enough to generalize.
    """

    max_commands = 2000

    command_added = QtCore.Signal(str)
    command_removed = QtCore.Signal(int)
    commands_reset = QtCore.Signal()

    @others
</t>
<t tx="ekr.20190812072048.38">def _paste(self, keepSelection):
    # Create a cursor of the current selection
    cursor = self.textCursor()

    # Ensure that position is at start and anchor is at the end.
    # This is required to ensure that with keepPositiobOnInsert
    # set, the cursor will equal the pasted text after the pasting
    self.__ensureCursorBeforeAnchor(cursor)

    # Change this cursor to let the position() stay at its place upon
    # inserting the new code; the anchor will move to the end of the insertion
    cursor.setKeepPositionOnInsert(True)
    super().paste()

    block = cursor.block()

    # Check if the thing to be pasted is multi-line. Use &gt; not &gt;=
    # to ensure we don't count it as multi-line if the cursor
    # is just at the beginning of the next block (consistent with
    # 'CodeEditor.doForSelectedLines')
    if cursor.selectionEnd() &gt; block.position() + block.length():

        # Now, check if in front of the current selection there is only whitespace
        if len(block.text()[:cursor.positionInBlock()].strip())==0:
            # Note that this 'smart pasting' will be a separate item on the
            # undo stack. This is intentional: the user can undo the 'smart paste'
            # without undoing the paste
            cursor2 = QtGui.QTextCursor(cursor)
            cursor2.setPosition(cursor2.position()) # put the anchor where the cursor is

            # Move cursor2 to beginning of the line (selecting the whitespace)
            # and remove the selection
            cursor2.movePosition(cursor2.StartOfBlock, cursor2.KeepAnchor)
            cursor2.removeSelectedText()

    # Set the textcursor of this editor to the just-pasted selection
    if keepSelection:
        cursor.setKeepPositionOnInsert(False)
        self.setTextCursor(cursor)
</t>
<t tx="ekr.20190812072048.380">def __init__(self, fname):
    super().__init__()
    self._commands = []
    self._fname = fname
    self._last_date = datetime.date(2000, 1, 1)
    self._load()
</t>
<t tx="ekr.20190812072048.381">def _load(self):
    """ Load commands from file.
    """
    if not self._fname:
        return

    assert not self._commands

    try:
        filename = os.path.join(pyzo.appDataDir, self._fname)
        if not os.path.isfile(filename):
            with open(filename, 'wb'):
                pass

        # Load lines and add to commands
        lines = open(filename, 'r', encoding='utf-8').read().splitlines()
        self._commands.extend([line.rstrip() for line in lines[-self.max_commands:]])

        # Resolve last date
        for c in reversed(lines):
            if c.startswith('# ==== '):
                try:
                    c = c.split('====')[1].strip()
                    self._last_date = datetime.datetime.strptime(c, '%Y-%m-%d').date()
                    break
                except Exception:
                    pass

    except Exception as e:
        print('An error occurred while loading the history: ' + str(e))
</t>
<t tx="ekr.20190812072048.382">def save(self):
    """ Save the commands to disk.
    """
    if not self._fname:
        return
    filename = os.path.join(pyzo.appDataDir, self._fname)
    try:
        with open(filename, 'wt', encoding='utf-8') as f:
            f.write('\n'.join(self._commands))
    except Exception:
        print('Could not save command history')
</t>
<t tx="ekr.20190812072048.383">def get_commands(self):
    """ Get a list of all commands (latest last).
    """
    return self._commands.copy()
</t>
<t tx="ekr.20190812072048.384">def append(self, command):
    """ Add a command to the list.
    """
    command = command.rstrip()
    if not command:
        return

    # Add date?
    today = datetime.date.today()
    if today &gt; self._last_date:
        self._last_date = today
        self._commands.append('# ==== ' + today.strftime('%Y-%m-%d'))
        self.command_added.emit(self._commands[-1])

    # Clear it
    try:
        index = self._commands.index(command)
    except ValueError:
        pass
    else:
        self._commands.pop(index)
        self.command_removed.emit(index)

    # Append
    self._commands.append(command)
    self.command_added.emit(self._commands[-1])

    # Reset?
    if len(self._commands) &gt; self.max_commands:
        self._commands[:self.max_commands // 2] = []
        self.commands_reset.emit()
</t>
<t tx="ekr.20190812072048.385">def pop(self, index):
    """ Remove a command by index.
    """
    self._commands.pop(index)
    self.command_removed.emit(index)
</t>
<t tx="ekr.20190812072048.386">def find_starting_with(self, firstpart, n=1):
    """ Find the nth (1-based) command that starts with firstpart, or None.
    """
    count = 0
    for c in reversed(self._commands):
        if c.startswith(firstpart):
            count += 1
            if count &gt;= n:
                return c
    return None
</t>
<t tx="ekr.20190812072048.387">def find_all(self, needle):
    """ Find all commands that contain the given text. In order
    of being used.
    """
    commands = []
    for c in reversed(self._commands):
        if needle in c:
            commands.append(c)
    return commands
</t>
<t tx="ekr.20190812072048.388">@path pyzo/core/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.389"># -*- coding: utf-8 -*-
""" Icons module

Defines functionality for creating icons by composing different overlays
and also by directly drawing into the pixmap. This allows making icons
that show information to the user in a very effective, yet subtle manner.

"""

try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo.core.icons.py')
except Exception:
    leo_g = None

from pyzo.util.qt import QtCore, QtGui, QtWidgets
import pyzo

</t>
<t tx="ekr.20190812072048.39">class AutoCloseQuotesAndBrackets(object): # tag:CodeEditor
    """
    Automatic insertion of quotes, parenthesis, braces and brackets

    """

    @others
</t>
<t tx="ekr.20190812072048.390">class IconArtist:
    """ IconArtist(icon=None)

    Object to draw icons with. Can be instantiated with an existing icon
    or as a blank icon. Perform operations and then use finish() to
    obtain the result.

    """

    @others
</t>
<t tx="ekr.20190812072048.391">def __init__(self, icon=None):

    # Get pixmap from given icon (None creates empty pixmap)
    self._pm = self._getPixmap(icon)

    # Instantiate painter for the pixmap
    self._painter = QtGui.QPainter()
    self._painter.begin(self._pm)
</t>
<t tx="ekr.20190812072048.392">def finish(self, icon=None):
    """ finish()
    Finish the drawing and return the resulting icon.
    """
    self._painter.end()
    return QtGui.QIcon(self._pm)
</t>
<t tx="ekr.20190812072048.393">def _getPixmap(self, icon):

    # Get icon if given by name
    if isinstance(icon, str):
        icon = pyzo.icons[icon]

    # Create pixmap
    if icon is None:
        pm = QtGui.QPixmap(16, 16)
        pm.fill(QtGui.QColor(0,0,0,0))
        return pm
    elif isinstance(icon, tuple):
        pm = QtGui.QPixmap(icon[0], icon[1])
        pm.fill(QtGui.QColor(0,0,0,0))
        return pm
    elif isinstance(icon, QtGui.QPixmap):
        return icon
    elif isinstance(icon, QtGui.QIcon):
        return icon.pixmap(16, 16)
    else:
        raise ValueError('Icon for IconArtis should be icon, pixmap or name.')
</t>
<t tx="ekr.20190812072048.394">def setPenColor(self, color):
    """ setPenColor(color)
    Set the color of the pen. Color can be anything that can be passed to
    Qcolor().
    """
    pen = QtGui.QPen()
    if isinstance(color, tuple):
        pen.setColor(QtGui.QColor(*color))
    else:
        pen.setColor(QtGui.QColor(color))
    self._painter.setPen(pen)
</t>
<t tx="ekr.20190812072048.395">def addLayer(self, overlay, x=0, y=0):
    """ addOverlay(overlay, x=0, y=0)
    Add an overlay icon to the icon (add the specified position).
    """
    pm = self._getPixmap(overlay)
    self._painter.drawPixmap(x, y, pm)
</t>
<t tx="ekr.20190812072048.396">def addLine(self, x1, y1, x2, y2):
    """ addLine( x1, y1, x2, y2)
    Add a line to the icon.
    """
    self._painter.drawLine(x1, y1, x2, y2)
</t>
<t tx="ekr.20190812072048.397">def addPoint(self, x, y):
    """ addPoint( x, y)
    Add a point to the icon.
    """
    self._painter.drawPoint(x, y)
</t>
<t tx="ekr.20190812072048.398">def addMenuArrow(self, strength=100):
    """ addMenuArrow()
    Adds a menu arrow to the icon to let the user know the icon
    is clickable.
    """
    x, y = 0, 12
    a1, a2 = int(strength/2), strength
    # Zeroth line of 3+2
    self.setPenColor((0,0,0,a1))
    self.addPoint(x+0,y-1); self.addPoint(x+4,y-1)
    self.setPenColor((0,0,0,a2))
    self.addPoint(x+1,y-1); self.addPoint(x+2,y-1); self.addPoint(x+3,y-1)
    # First line of 3+2
    self.setPenColor((0,0,0,a1))
    self.addPoint(x+0,y+0); self.addPoint(x+4,y+0)
    self.setPenColor((0,0,0,a2))
    self.addPoint(x+1,y+0); self.addPoint(x+2,y+0); self.addPoint(x+3,y+0)
    # Second line of 3
    self.addPoint(x+1,y+1); self.addPoint(x+2,y+1); self.addPoint(x+3,y+1)
    # Third line of 1+2
    self.addPoint(x+2,y+2)
    self.setPenColor((0,0,0,a1))
    self.addPoint(x+1,y+2); self.addPoint(x+3,y+2)
    # Fourth line of 1
    self.setPenColor((0,0,0,a2))
    self.addPoint(x+2,y+3)
</t>
<t tx="ekr.20190812072048.399"># todo: not used; remove me?
class TabCloseButton(QtWidgets.QToolButton):
    """ TabCloseButton

    This class implements a very compact close button to be used in tabs.
    It allows managing tab (the closing part of it) in a fast and intuitive
    fashion.

    """

    SIZE = 5,8

    @others
</t>
<t tx="ekr.20190812072048.4">def onAutoComplete(self, text=None):
    if text is None:
        text = self.__highlightedCompletion
    #Select the text from autocompleteStart until the current cursor
    cursor=self.textCursor()
    cursor.setPosition(self.__autocompleteStart.position(),cursor.KeepAnchor)
    #Replace it with the selected text
    cursor.insertText(text)
    self.autocompleteCancel() #Reset the completer

    #Update the recent completions list
    if text in self.__recentCompletions:
        self.__recentCompletions.remove(text)
    self.__recentCompletions.append(text)
</t>
<t tx="ekr.20190812072048.40">def _get_token_at_cursor(self, cursor=None, relpos=0):
    """ Get token at the (current or given) cursor position. Can be None.
    """
    if cursor is None:
        cursor = self.textCursor()
    pos = cursor.positionInBlock() + relpos
    tokens = cursor.block().userData().tokens
    token = None
    for token in tokens:
        if hasattr(token, 'start'):
            if token.start &gt;= pos:
                break
        elif getattr(token, 'state', 0) in (1, 2):
            token = MultilineStringToken()  # 1 and 2 are mls, by convention, sortof
    return token
</t>
<t tx="ekr.20190812072048.400">def __init__(self):
    QtWidgets.QToolButton.__init__(self)

    # Init
    self.setIconSize(QtCore.QSize(*self.SIZE))
    self.setStyleSheet("QToolButton{ border:none; padding:0px; margin:0px; }")
    self.setIcon(self.getCrossIcon1())
</t>
<t tx="ekr.20190812072048.401">def mousePressEvent(self, event):
    # Get tabs
    tabs = self.parent().parent()
    # Get index from position
    pos = self.mapTo(tabs, event.pos())
    index = tabs.tabBar().tabAt(pos)
    # Close it
    tabs.tabCloseRequested.emit(index)
</t>
<t tx="ekr.20190812072048.402">def enterEvent(self, event):
    QtWidgets.QToolButton.enterEvent(self, event)
    self.setIcon(self.getCrossIcon2())
</t>
<t tx="ekr.20190812072048.403">def leaveEvent(self, event):
    QtWidgets.QToolButton.leaveEvent(self, event)
    self.setIcon(self.getCrossIcon1())
</t>
<t tx="ekr.20190812072048.404">def _createCrossPixmap(self, alpha):
    artist = IconArtist(self.SIZE)
    #
    artist.setPenColor((0,0,0,alpha))
    #
    artist.addPoint(0,0); artist.addPoint(1,1)
    artist.addPoint(2,2); artist.addPoint(3,3)
    artist.addPoint(4,4)
    artist.addPoint(0,4); artist.addPoint(1,3)
    artist.addPoint(3,1); artist.addPoint(4,0)
    #
    artist.setPenColor((0,0,0,int(0.5*alpha)))
    #
    artist.addPoint(1,0); artist.addPoint(0,1)
    artist.addPoint(2,1); artist.addPoint(1,2)
    artist.addPoint(3,2); artist.addPoint(2,3)
    artist.addPoint(4,3); artist.addPoint(3,4)
    #
    artist.addPoint(0,3); artist.addPoint(1,4)
    artist.addPoint(3,0); artist.addPoint(4,1)
    #
    return artist.finish().pixmap(*self.SIZE)
</t>
<t tx="ekr.20190812072048.405">def getCrossIcon1(self):
    if hasattr(self, '_cross1'):
        pm = self._cross1
    else:
        pm = self._createCrossPixmap(80)
    return QtGui.QIcon(pm)
</t>
<t tx="ekr.20190812072048.406">def getCrossIcon2(self):
    if hasattr(self, '_cross2'):
        pm = self._cross2
    else:
        pm = self._createCrossPixmap(240)
    # Set
    return QtGui.QIcon(pm)
</t>
<t tx="ekr.20190812072048.407"># todo: not used; remove me?
class ToolButtonWithMenuIndication(QtWidgets.QToolButton):
    """ ToolButtonWithMenuIndication

    Tool button that wraps the icon in a slightly larger icon that
    contains a small arrow that lights up when hovering over the icon.

    The button itself is not drawn. If the icon is clicked, the
    customContextMenuRequested signal of the "grandparent" is emitted. In
    this way we realize a suble icon that can be clicked on to show a menu.

    """

    SIZE = 21, 16

    @others
</t>
<t tx="ekr.20190812072048.408">def __init__(self):
    QtWidgets.QToolButton.__init__(self)

    # Init
    self.setIconSize(QtCore.QSize(*self.SIZE))
    self.setStyleSheet("QToolButton{ border: none; }")

    # Create arrow pixmaps
    self._menuarrow1 = self._createMenuArrowPixmap(0)
    self._menuarrow2 = self._createMenuArrowPixmap(70)
    self._menuarrow = self._menuarrow1

    # Variable to keep icon
    self._icon = None

    # Variable to keep track of when the mouse was pressed, so that
    # we can allow dragging as well as clicking the menu.
    self._menuPressed = False
</t>
<t tx="ekr.20190812072048.409">def mousePressEvent(self, event):
    # Ignore event so that the tabbar will change to that tab
    event.ignore()
    self._menuPressed = event.pos()
</t>
<t tx="ekr.20190812072048.41">def keyPressEvent(self, event):
    try:
        self.__keyPressEvent(event)
    except Exception as err:
        # When there is a bug in our fancy autoclosing stuff, better print and
        # and have the plain behavior instead of not working ...
        print(err)
        super().keyPressEvent(event)
</t>
<t tx="ekr.20190812072048.410">def mouseMoveEvent(self, event):
    QtWidgets.QToolButton.mouseMoveEvent(self, event)
    if self._menuPressed:
        dragDist = QtWidgets.QApplication.startDragDistance()
        if (event.pos()-self._menuPressed).manhattanLength() &gt;= dragDist:
            self._menuPressed = False
</t>
<t tx="ekr.20190812072048.411">def mouseReleaseEvent(self, event):
    event.ignore()
    if self._menuPressed:
        tabs = self.parent().parent()
        pos = self.mapTo(tabs, event.pos())
        tabs.customContextMenuRequested.emit(pos)
</t>
<t tx="ekr.20190812072048.412">def enterEvent(self, event):
    QtWidgets.QToolButton.enterEvent(self, event)
    self._menuarrow = self._menuarrow2
    self.setIcon()
    self._menuPressed = False
</t>
<t tx="ekr.20190812072048.413">def leaveEvent(self, event):
    QtWidgets.QToolButton.leaveEvent(self, event)
    self._menuarrow = self._menuarrow1
    self.setIcon()
    self._menuPressed = False
</t>
<t tx="ekr.20190812072048.414">def setIcon(self, icon=None):

    # Store icon if given, otherwise use buffered version
    if icon is not None:
        self._icon = icon

    # Compose icon by superimposing the menuarrow pixmap
    artist = IconArtist(self.SIZE)
    if self._icon:
        artist.addLayer(self._icon, 5, 0)
    artist.addLayer(self._menuarrow, 0,0)
    icon = artist.finish()

    # Set icon
    QtWidgets.QToolButton.setIcon(self, icon)
</t>
<t tx="ekr.20190812072048.415">def _createMenuArrowPixmap(self, strength):
    artist = IconArtist()
    artist.addMenuArrow(strength)
    return artist.finish().pixmap(16,16)
</t>
<t tx="ekr.20190812072048.416">class TabToolButton(QtWidgets.QToolButton):
    """ TabToolButton

    Base menu for editor and shell tabs.

    """

    SIZE = 16, 16

    @others
</t>
<t tx="ekr.20190812072048.417">def __init__(self, *args):
    QtWidgets.QToolButton.__init__(self, *args)

    # Init
    self.setIconSize(QtCore.QSize(*self.SIZE))
    self.setStyleSheet("QToolButton{ border: none; }")
</t>
<t tx="ekr.20190812072048.418">def mousePressEvent(self, event):
    # Ignore event so that the tabbar will change to that tab
    event.ignore()
</t>
<t tx="ekr.20190812072048.419">class TabToolButtonWithCloseButton(TabToolButton):
    """ TabToolButtonWithCloseButton

    Tool button that wraps the icon in a slightly larger icon that
    contains a small cross that can be used to invoke a close request.

    """

    SIZE = 22, 16
    CROSS_OFFSET = 0, 2

    @others
</t>
<t tx="ekr.20190812072048.42">def __keyPressEvent(self, event):

    quotesKeys = [Qt.Key_Apostrophe, Qt.Key_QuoteDbl]
    openBrackets = [Qt.Key_BraceLeft,Qt.Key_BracketLeft, Qt.Key_ParenLeft]
    closeBrackets = [Qt.Key_BraceRight, Qt.Key_BracketRight, Qt.Key_ParenRight]
    bracketKeys = openBrackets + closeBrackets

    cursor = self.textCursor()

    #  brackets
    if event.key() in bracketKeys and pyzo.config.settings.autoClose_Brackets:

        # Dont autobracket inside comments and strings
        if isinstance(self._get_token_at_cursor(cursor),
                    (CommentToken, StringToken, MultilineStringToken, UnterminatedStringToken)):
            super().keyPressEvent(event)
            return

        if event.key() in openBrackets:
            idx = openBrackets.index(event.key())
            next_character = self.__getNextCharacter()
            if cursor.selectedText():
                # Surround selection with brackets
                new_text = chr(openBrackets[idx]) + cursor.selectedText() + chr(closeBrackets[idx])
                cursor.setKeepPositionOnInsert(True)
                cursor.insertText(new_text)
                cursor.setKeepPositionOnInsert(False)
                self.setTextCursor(cursor)
            elif next_character.strip():  # str.strip() conveniently removes all kinds of whitespace
                # Only autoclose if the char on the right is whitespace
                cursor.insertText(chr(event.key()))  # == super().keyPressEvent(event)
            else:
                # Auto-close bracket
                insert_txt = "{}{}".format(chr(openBrackets[idx]), chr(closeBrackets[idx]))
                cursor.insertText(insert_txt)
                self._moveCursorLeft(1)

        elif event.key() in closeBrackets:
            idx = closeBrackets.index(event.key())
            next_character = self.__getNextCharacter()
            if cursor.selectedText():
                # Replace
                cursor.insertText(chr(event.key()))
            elif next_character and ord(next_character) == event.key():
                # Skip
                self._moveCursorRight(1)
            else:
                # Normal
                cursor.insertText(chr(event.key()))  # == super().keyPressEvent(event)

    # quotes
    elif event.key() in quotesKeys and pyzo.config.settings.autoClose_Quotes:
        quote_character = chr(event.key())
        next_character = self.__getNextCharacter()

        # Dont autoquote inside comments and multiline strings
        # Only allow "doing our thing" when we're at the end of a normal string
        token = self._get_token_at_cursor(cursor)
        if isinstance(token, (CommentToken, MultilineStringToken)):
            super().keyPressEvent(event)
            return
        elif isinstance(token, StringToken) and quote_character != next_character:
            super().keyPressEvent(event)
            return

        if cursor.selectedText() in ('"', "'"):
            # Skip over char if its one char and a quote
            self._moveCursorRight(1)
        elif cursor.selectedText():
            # Surround selection with quotes, maybe even multi-line
            new_text = quote_character + cursor.selectedText() + quote_character
            if '\u2029' in new_text and 'python' in self.parser().name().lower():
                new_text = quote_character * 2 + new_text + quote_character * 2
            cursor.setKeepPositionOnInsert(True)
            cursor.insertText(new_text)
            cursor.setKeepPositionOnInsert(False)
            self.setTextCursor(cursor)
        elif next_character and next_character == quote_character:
            # Skip
            self._moveCursorRight(1)
        else:
            # Only autoquote if we're next to whitespace, operator, quote
            notok_token_types = IdentifierToken,
            tokenL = self._get_token_at_cursor(cursor, -1)
            tokenR = self._get_token_at_cursor(cursor, -0)
            if (isinstance(tokenL, notok_token_types) or isinstance(tokenR, notok_token_types)):
                super().keyPressEvent(event)
                return
            # Auto-close
            cursor.insertText("{}{}".format(quote_character, quote_character))
            self._moveCursorLeft(1)
            # # Maybe handle tripple quotes (add 2 more if we now have 3 on the left)
            # Disabled: this feature too easily gets in the way
            # if 'python' in self.parser().name().lower():
            #     cursor = self.textCursor()
            #     cursor.movePosition(cursor.PreviousCharacter, cursor.KeepAnchor, 3)
            #     if cursor.selectedText() == quote_character * 3:
            #         edit_cursor = self.textCursor()
            #         edit_cursor.insertText(quote_character * 2)
            #         self._moveCursorLeft(2)

    else:
        super().keyPressEvent(event)
</t>
<t tx="ekr.20190812072048.420">def __init__(self, *args):
    TabToolButton.__init__(self, *args)

    # Variable to keep icon
    self._icon = None
    self._cross = self.getCrossPixmap1()

    # For mouse tracking inside icon
    self.setMouseTracking(True)
    self._overCross = False
</t>
<t tx="ekr.20190812072048.421">def _isOverCross(self, pos):
    x1, x2 = self.CROSS_OFFSET[0], self.CROSS_OFFSET[0]+5+1
    y1, y2 = self.CROSS_OFFSET[1], self.CROSS_OFFSET[1]+5+1
    if pos.x()&gt;=x1 and pos.x()&lt;=x2 and pos.y()&gt;=y1 and pos.y()&lt;=y2:
        return True
    else:
        return False
</t>
<t tx="ekr.20190812072048.422">def mousePressEvent(self, event):
    if self._isOverCross(event.pos()):
        # Accept event so that the tabbar will NOT change to that tab
        event.accept()
    else:
        event.ignore()
</t>
<t tx="ekr.20190812072048.423">def mouseReleaseEvent(self, event):
    
    # if leo_g: leo_g.pr('TabToolButtonWithCloseButton.mouseReleaseEvent:', event)
    if self._isOverCross(event.pos()):
        event.accept()
        # Get tabs
        tabs = self.parent().parent()
        # Get index from position
        pos = self.mapTo(tabs, event.pos())
        index = tabs.tabBar().tabAt(pos)
        # Close it
        tabs.tabCloseRequested.emit(index)
    else:
        if leo_g: leo_g.trace('IGNORE')
        event.ignore()
</t>
<t tx="ekr.20190812072048.424">def mouseMoveEvent(self, event):
    QtWidgets.QToolButton.mouseMoveEvent(self, event)
    new_overCross = self._isOverCross(event.pos())
    if new_overCross != self._overCross:
        self._overCross = new_overCross
        if new_overCross:
            self._cross = self.getCrossPixmap2()
        else:
            self._cross = self.getCrossPixmap1()
        self.setIcon()
</t>
<t tx="ekr.20190812072048.425">def leaveEvent(self, event):
    if self._overCross:
        self._overCross =  False
        self._cross = self.getCrossPixmap1()
        self.setIcon()
</t>
<t tx="ekr.20190812072048.426">def setIcon(self, icon=None):

    # Store icon if given, otherwise use buffered version
    if icon is not None:
        self._icon = icon

    # Compose icon by superimposing the menuarrow pixmap
    artist = IconArtist(self.SIZE)
    if self._icon:
        if self.CROSS_OFFSET[0] &gt; 8:
            artist.addLayer(self._icon, 0,0)
        else:
            artist.addLayer(self._icon, 6,0)
    artist.addLayer(self._cross, *self.CROSS_OFFSET)
    icon = artist.finish()

    # Set icon
    QtWidgets.QToolButton.setIcon(self, icon)
</t>
<t tx="ekr.20190812072048.427">def _createMenuArrowPixmap(self, strength):
    artist = IconArtist()
    artist.addMenuArrow(strength)
    return artist.finish().pixmap(16,16)
</t>
<t tx="ekr.20190812072048.428">def _createCrossPixmap(self, alpha):
    artist = IconArtist((5,5))
    #
    artist.setPenColor((0,0,0,alpha))
    #
    artist.addPoint(0,0); artist.addPoint(1,1)
    artist.addPoint(2,2); artist.addPoint(3,3)
    artist.addPoint(4,4)
    artist.addPoint(0,4); artist.addPoint(1,3)
    artist.addPoint(3,1); artist.addPoint(4,0)
    #
    artist.setPenColor((0,0,0,int(0.5*alpha)))
    #
    artist.addPoint(1,0); artist.addPoint(0,1)
    artist.addPoint(2,1); artist.addPoint(1,2)
    artist.addPoint(3,2); artist.addPoint(2,3)
    artist.addPoint(4,3); artist.addPoint(3,4)
    #
    artist.addPoint(0,3); artist.addPoint(1,4)
    artist.addPoint(3,0); artist.addPoint(4,1)
    #
    return artist.finish().pixmap(5,5)
</t>
<t tx="ekr.20190812072048.429">def getCrossPixmap1(self):
    if hasattr(self, '_cross1'):
        pm = self._cross1
    else:
        pm = self._createCrossPixmap(50)
    return pm
</t>
<t tx="ekr.20190812072048.43">def __getNextCharacter(self):
    cursor = self.textCursor()
    cursor.movePosition(cursor.NoMove, cursor.MoveAnchor)  # rid selection
    cursor.movePosition(cursor.NextCharacter, cursor.KeepAnchor)
    next_char = cursor.selectedText()
    return next_char
</t>
<t tx="ekr.20190812072048.430">def getCrossPixmap2(self):
    if hasattr(self, '_cross2'):
        pm = self._cross2
    else:
        pm = self._createCrossPixmap(240)
    # Set
    return pm
</t>
<t tx="ekr.20190812072048.431">class EditorTabToolButton(TabToolButtonWithCloseButton):
    """ Button for the tabs of the editors. This is just a
    tight wrapper for the icon.
    """

    @others
</t>
<t tx="ekr.20190812072048.432">def updateIcon(self, isDirty, isMain, isPinned, nBlocks=10001):

    # Init drawing
    artist = IconArtist()

    # Create base
    if isDirty:
        artist.addLayer('page_white_dirty')
        artist.setPenColor('#f00')
    else:
        artist.addLayer('page_white')
        artist.setPenColor('#444')

    # Paint lines
    if not nBlocks:
        nLines = 0
    elif nBlocks &lt;= 10: nLines = 1
    elif nBlocks &lt;= 100: nLines = 2
    elif nBlocks &lt;= 1000: nLines = 3
    elif nBlocks &lt;= 10000: nLines = 4
    else: nLines = 5
    #
    fraction = float(nBlocks) / 10**nLines
    fraction = min(fraction, 1.0)
    #
    for i in range(nLines):
        y = 4 + 2 * i
        n = 5
        if y&gt;6: n = 8
        #if i == nLines-1:
        #    n = int(fraction * n)
        artist.addLine(4,y,4+n,y)

    # Overlays
    if isMain:
        artist.addLayer('overlay_star')
    if isPinned:
        artist.addLayer('overlay_thumbnail')
    if isDirty:
        artist.addLayer('overlay_disk')

    # Apply
    self.setIcon(artist.finish())
</t>
<t tx="ekr.20190812072048.433">class ShellIconMaker:
    """ Object that can make an icon for the shells
    """

    POSITION = (6,7) # absolute position of center of wheel.

    # Relative position for the wheel at two levels. Center is at (3,,3)
    POSITIONS1 = [(2,2), (3,2), (4,2), (4,3), (4,4), (3,4), (2,4), (2,3)]
    POSITIONS2 = [  (2,1), (3,1), (4,1), (5,2), (5,3), (5,4),
                    (4,5), (3,5), (2,5), (1,4), (1,3), (1,2) ]

    # Maps to make transitions between levels more natural
    MAP1to2 = [1,2, 4,5, 7,8, 10,11]
    MAP2to1 = [1,2,3,  3,4,5, 5,6,7, 7,0,1]

    MAX_ITERS_IN_LEVEL_1 = 2

    @others
</t>
<t tx="ekr.20190812072048.434">def __init__(self, objectWithIcon):

    self._objectWithIcon = objectWithIcon
    
    # if leo_g: leo_g.pr('ShellIconMaker.__init__', objectWithIcon)

    # Motion properties
    self._index = 0
    self._level = 0
    self._count = 0  #  to count number of iters in level 1

    # Prepare blob pixmap
    self._blob = self._createBlobPixmap()
    self._legs = self._createLegsPixmap()

    # Create timer
    self._timer = QtCore.QTimer(None)
    self._timer.setInterval(150)
    self._timer.setSingleShot(False)
    self._timer.timeout.connect(self.onTimer)
</t>
<t tx="ekr.20190812072048.435">def setIcon(self, icon):
    self._objectWithIcon.setIcon(icon)
</t>
<t tx="ekr.20190812072048.436">def _createBlobPixmap(self):

    artist = IconArtist()
    artist.setPenColor((0,150,0,255))
    artist.addPoint(1,1)
    artist.setPenColor((0,150,0, 200))
    artist.addPoint(1,0); artist.addPoint(1,2)
    artist.addPoint(0,1); artist.addPoint(2,1)
    artist.setPenColor((0,150,0, 100))
    artist.addPoint(0,0); artist.addPoint(2,0)
    artist.addPoint(0,2); artist.addPoint(2,2)
    return artist.finish().pixmap(16,16)
</t>
<t tx="ekr.20190812072048.437">def _createLegsPixmap(self):
    artist = IconArtist()
    x,y = self.POSITION
    artist.setPenColor((0,50,0,150))
    artist.addPoint(x+1,y-1); artist.addPoint(x+1,y-2); artist.addPoint(x+0,y-2)
    artist.addPoint(x+3,y+1); artist.addPoint(x+4,y+1); artist.addPoint(x+4,y+2)
    artist.addPoint(x+2,y+3); artist.addPoint(x+2,y+4)
    artist.addPoint(x+0,y+3); artist.addPoint(x+0,y+4)
    artist.addPoint(x-1,y+2); artist.addPoint(x-2,y+2)
    artist.addPoint(x-1,y+0); artist.addPoint(x-2,y+0)
    return artist.finish().pixmap(16,16)
</t>
<t tx="ekr.20190812072048.438">def updateIcon(self, status='Ready'):
    """ updateIcon(status)
    Public method to set what state the icon must show.
    """

    # Normalize and store
    if isinstance(status, str):
        status = status.lower()
    self._status = status

    # Handle
    if status == 'busy':
        self._index = 0
        if self._level == 2:
            self._index = self.MAP2to1[self._index]
        self._level = 1

    elif status == 'very busy':
        self._index = 0
        if self._level == 1:
            self._index = self.MAP1to2[self._index]
        self._level = 2

    else:
        self._level = 0

    # At least one timer iteration
    self._timer.start()
</t>
<t tx="ekr.20190812072048.439">def _nextIndex(self):
    self._index += 1
    if self._level == 1 and self._index &gt;= 8:
        self._index = 0
    elif self._level == 2 and self._index &gt;= 12:
        self._index = 0
</t>
<t tx="ekr.20190812072048.44">def _moveCursorLeft(self, n):
    """
    Move cursor left between eg. brackets
    """
    cursor2 = self.textCursor()
    cursor2.movePosition(cursor2.Left, cursor2.MoveAnchor, n)
    self.setTextCursor(cursor2)
</t>
<t tx="ekr.20190812072048.440">def _index1(self):
    return self._index
</t>
<t tx="ekr.20190812072048.441">def _index2(self):
    n = [0, 8, 12][self._level]
    index = self._index + n/2
    if index &gt;= n:
        index -= n
    return int(index)
</t>
<t tx="ekr.20190812072048.442">def onTimer(self):
    """ onTimer()
    Invoked on each timer iteration. Will call the static drawing
    methods if in level 0. Otherwise will invoke drawInMotion().
    This method also checks if we should change levels and calculates
    how this is best achieved.
    """
    if self._level == 0:
        # Turn of timer
        self._timer.stop()
        # Draw
        if self._status in ['ready', 'more']:
            self.drawReady()
        elif self._status == 'debug':
            self.drawDebug()
        elif self._status == 'dead':
            self.drawDead()
        else:
            self.drawDead()

    elif self._level == 1:
        # Draw
        self.drawInMotion()
        # Next, this is always intermediate
        self._nextIndex()
        self._count += 1

    elif self._level == 2:
        # Draw
        self.drawInMotion()
        # Next
        self._nextIndex()
</t>
<t tx="ekr.20190812072048.443">def drawReady(self):
    """ drawReady()
    Draw static icon for when in ready mode.
    """
    artist = IconArtist("application")
    artist.addLayer(self._blob, *self.POSITION)
    self.setIcon(artist.finish())
</t>
<t tx="ekr.20190812072048.444">def drawDebug(self):
    """ drawDebug()
    Draw static icon for when in debug mode.
    """
    artist = IconArtist("application")
    artist.addLayer(self._blob, *self.POSITION)
    artist.addLayer(self._legs)
    self.setIcon(artist.finish())
</t>
<t tx="ekr.20190812072048.445">def drawDead(self):
    """ drawDead()
    Draw static empty icon for when the kernel is dead.
    """
    artist = IconArtist("application")
    self.setIcon(artist.finish())
</t>
<t tx="ekr.20190812072048.446">def drawInMotion(self):
    """ drawInMotion()
    Draw one frame of the icon in motion. Position of the blobs
    is determined from the index and the list of locations.
    """

    # Init drawing
    artist = IconArtist("application")

    # Define params
    dx, dy = self.POSITION[0]-3, self.POSITION[1]-3
    blob = self._blob
    #
    if self._level == 1:
        positions = self.POSITIONS1
    elif self._level == 2:
        positions = self.POSITIONS2

    # Draw
    pos1 = positions[self._index1()]
    pos2 = positions[self._index2()]
    artist.addLayer(blob, pos1[0]+dx, pos1[1]+dy)
    artist.addLayer(blob, pos2[0]+dx, pos2[1]+dy)

    # Done
    self.setIcon(artist.finish())
</t>
<t tx="ekr.20190812072048.447">@path pyzo/core/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.448"># -*- coding: utf-8 -*-
""" Module kernelBroker

This module implements the interface between Pyzo and the kernel.
"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo/core/kernelbroker.py')
except Exception:
    leo_g = None

import os, sys, time
import subprocess
import signal
import threading
import ctypes

import yoton
import pyzo # local Pyzo (can be on a different box than where the user is)
from pyzo.util import zon as ssdf  # zon is ssdf-light

# To allow interpreters relative to (frozen) Pyzo app
EXE_DIR = os.path.abspath(os.path.dirname(sys.executable))
if EXE_DIR.endswith('.app/Contents/MacOS'):
    EXE_DIR = os.path.dirname(EXE_DIR.rsplit('.app')[0])

# Important: the yoton event loop should run somehow!
</t>
<t tx="ekr.20190812072048.449">class KernelInfo(ssdf.Struct):
    """ KernelInfo

    Describes all information for a kernel. This class can be used at
    the IDE as well as the kernelbroker.

    This information goes a long way from the pyzo config file to the
    kernel. The list pyzo.config.shellConfigs2 contains the configs
    for all kernels. These objects are edited in-place by the
    shell config.

    The shell keeps a reference of the shell config used to start the
    kernel. On each restart all information is resend. In this way,
    if a user changes a setting in the shell config, it is updated
    when the shell restarts.

    The broker also keeps a copy of the shell config. In this way,
    the shell might send no config information (or only partially
    update the config information) on a restart. This is not so
    relevant now, but it can be when we are running multiple people
    on a single kernel, and there is only one user who has the
    original config.

    """
    @others
</t>
<t tx="ekr.20190812072048.45">def _moveCursorRight(self, n):
    """
    Move cursor out of eg. brackets
    """
    cursor2 = self.textCursor()
    cursor2.movePosition(cursor2.Right, cursor2.MoveAnchor, n)
    self.setTextCursor(cursor2)
</t>
<t tx="ekr.20190812072048.450">def __init__(self, info=None):
    super().__init__()
    # ----- Fixed parameters that define a shell -----

    # scriptFile is used to define the mode. If given, we run in
    # script-mode. Otherwise we run in interactive mode.

    # The name of this shell config. Can be used to name the kernel
    self.name = 'Python'

    # The executable. This can be '/usr/bin/python3.1' or
    # 'c:/program files/python2.6/python.exe', etc.
    self.exe = ''

    # The GUI toolkit to embed the event loop of.
    # Instantiate with a value that is settable
    self.gui = 'Auto'

    # The Python path. Paths should be separated by newlines.
    # '$PYTHONPATH' is replaced by environment variable by broker
    self.pythonPath = ''

    # The path of the current project, the kernel will prepend this
    # to the sys.path. The broker could prepend to PYTHONPATH, but
    # in this way it is more explicit (kernel can tell the user that
    # the project path was prepended).
    self.projectPath = ''

    # The full filename of the script to run.
    # If given, the kernel should run in script-mode.
    # The kernel will check whether this file exists, and will
    # revert to interactive mode if it doesn't.
    self.scriptFile = ''

    # Interactive-mode only:

    # The initial directory. Only used for interactive-mode; in
    # script-mode the initial directory is the dir of the script.
    self.startDir = ''

    # The Startup script (only used for interactive-mode).
    # - Empty string means run nothing,
    # - Single line means file name
    # - multiple lines means source code.
    # - '$PYTHONSTARTUP' uses the code in that file. Broker replaces this.
    self.startupScript = ''

    # Additional command line arguments, set by the kernel
    self.argv = ''

    # Additional environment variables
    self.environ = ''

    # Load info from ssdf struct. Make sure they are all strings
    if info:
        # Get struct
        if isinstance(info, dict):
            s = info
        elif isinstance(info, str):
            s = ssdf.loads(info)
        else:
            raise ValueError('Kernel info should be a string or ssdf struct, not %s' % str(type(info)))
        # Inject values
        for key in s:
            val = s[key]
            if not val:
                val = ''
            self[key] = val
</t>
<t tx="ekr.20190812072048.451">def tostring(self):
    return ssdf.saves(self)
</t>
<t tx="ekr.20190812072048.452">def getCommandFromKernelInfo(info, port):
    info = KernelInfo(info)

    # Apply default exe
    exe = info.exe or 'python'
    if exe.startswith('.'):
        exe = os.path.abspath(os.path.join(EXE_DIR, exe))

    # Correct path when it contains spaces
    if exe.count(' ') and exe[0] != '"':
        exe = '"{}"'.format(exe)

    # Get start script
    startScript = os.path.join( pyzo.pyzoDir, 'pyzokernel', 'start.py')
    startScript = '"{}"'.format(startScript)

    # Build command
    command = exe + ' ' + startScript + ' ' + str(port)

    # Done
    return command
</t>
<t tx="ekr.20190812072048.453">def getEnvFromKernelInfo(info):
    info = KernelInfo(info)

    pythonPath = info.pythonPath

    # Set default pythonPath (replace only first occurrence of $PYTHONPATH
    ENV_PP = os.environ.get('PYTHONPATH','')
    pythonPath = pythonPath.replace('$PYTHONPATH', '\n'+ENV_PP+'\n', 1)
    pythonPath = pythonPath.replace('$PYTHONPATH', '')
    # Split paths, allow newlines and os.pathsep
    for splitChar in '\n\r' + os.pathsep:
        pythonPath = pythonPath.replace(splitChar, '\n')
    pythonPaths = [p.strip() for p in pythonPath.split('\n') if p]
    # Recombine using the OS's path separator
    pythonPath = os.pathsep.join(pythonPaths)
    # Add entry to Pythopath, so that we can import yoton
    # Note: an empty entry might cause trouble if the start-directory is
    # somehow overriden (see issue 128).
    pythonPath = pyzo.pyzoDir + os.pathsep + pythonPath

    # Prepare environment, remove references to tk libraries,
    # since they're wrong when frozen. Python will insert the
    # correct ones if required.
    env = os.environ.copy()
    #
    env.pop('TK_LIBRARY','')
    env.pop('TCL_LIBRARY','')
    env['PYTHONPATH'] = pythonPath
    # Jython does not use PYTHONPATH but JYTHONPATH
    env['JYTHONPATH'] = pyzo.pyzoDir + os.pathsep + os.environ.get('JYTHONPATH', '')
    env['TERM'] = 'dumb'  # we have a "dumb" terminal (see #422)

    # Add environment variables specified in shell config
    for line in info.environ.splitlines():
        line = line.strip()
        if '=' in line:
            key, val = line.split('=', 1)
            if key:
                key, val = key.strip(), val.strip()
                env[key] = os.path.expandvars(val)

    # Done
    return env
</t>
<t tx="ekr.20190812072048.454">class KernelBroker:
    """ KernelBroker(info)

    This class functions as a broker between a kernel process and zero or
    more IDE's (clients).

    This class has a single context assosiated with it, that lives as long
    as this object. It is used to connect to a kernel process and to
    0 or more IDE's (clients). The kernel process can be "restarted", meaning
    that it is terminated and a new process started.

    The broker is cleaned up if there is no kernel process AND no connections.

    """

    @others
</t>
<t tx="ekr.20190812072048.455">def __init__(self, manager, info, name=''):
    self._manager = manager

    # Store info that defines the kernel
    self._originalInfo = KernelInfo(info)

    # Make a copy for the current version. This copy is re-created on
    # each restart
    self._info = ssdf.copy(self._originalInfo)

    # Store name (or should the name be defined in the info struct)
    self._name = name

    # Create context for the connection to the kernel and IDE's
    # This context is persistent (it stays as long as this KernelBroker
    # instance is alive).
    self._context = yoton.Context()
    self._kernelCon = None
    self._ctrl_broker = None

    # Create yoton-based timer
    self._timer = yoton.Timer(0.2, oneshot=False)
    self._timer.bind(self.mainLoopIter)

    # Kernel process and connection (these are replaced on restarting)
    self._reset()

    # For restarting after terminating
    self._pending_restart = None

## Startup and teardown
</t>
<t tx="ekr.20190812072048.456">def _create_channels(self):
    ct = self._context

    # Close any existing channels first
    self._context.close_channels()

    # Create stream channels.
    # Stdout is for the C-level stdout/stderr streams.
    self._strm_broker = yoton.PubChannel(ct, 'strm-broker')
    self._strm_raw = yoton.PubChannel(ct, 'strm-raw')
    self._strm_prompt = yoton.PubChannel(ct, 'strm-prompt')

    # Create control channel so that the IDE can control restarting etc.
    self._ctrl_broker = yoton.SubChannel(ct, 'ctrl-broker')

    # Status channel to pass startup parameters to the kernel
    self._stat_startup = yoton.StateChannel(ct, 'stat-startup', yoton.OBJECT)

    # We use the stat-interpreter to set the status to dead when kernel dies
    self._stat_interpreter = yoton.StateChannel(ct, 'stat-interpreter')

    # Create introspect channel so we can interrupt and terminate
    self._reqp_introspect = yoton.ReqChannel(ct, 'reqp-introspect')
</t>
<t tx="ekr.20190812072048.457">def _reset(self, destroy=False):
    """ _reset(destroy=False)

    Reset state. if destroy, does a full clean up, closing the context
    and removing itself from the KernelManager's list.

    """

    # Close connection (it might be in a wait state if the process
    # failed to start)
    if self._kernelCon is not None:
        self._kernelCon.close()

    # Set process and kernel connection to None
    self._process = None
    self._kernelCon = None
    self._terminator = None
    self._streamReader = None

    if destroy:

        # Stop timer
        self._timer.unbind(self.mainLoopIter)
        self._timer.stop()
        self._timer = None

        # Clean up this kernelbroker instance
        L = self._manager._kernels
        while self in L:
            L.remove(self)

        # Remove references
        #
        if self._context is not None:
            self._context.close()
        self._context = None
        #
        self._strm_broker = None
        self._strm_raw = None
        self._stat_startup = None
        self._stat_interpreter = None
        self._strm_prompt = None
        #
        self._ctrl_broker = None
        self._reqp_introspect = None
</t>
<t tx="ekr.20190812072048.458">def startKernelIfConnected(self, timeout=10.0):
    """ startKernelIfConnected(timout=10.0)

    Start the kernel as soon as there is a connection.

    """
    self._process = time.time() + timeout
    self._timer.start()
</t>
<t tx="ekr.20190812072048.459">def startKernel(self):
    """ startKernel()

    Launch the kernel in a subprocess, and connect to it via the
    context and two Pypes.

    """

    # Create channels
    self._create_channels()

    # Create info dict
    info = {}
    for key in self._info:
        info[key] = self._info[key]

    # Send info stuff so that the kernel has access to the information
    self._stat_startup.send(info)

    # Get directory to start process in
    cwd = pyzo.pyzoDir

    # Host connection for the kernel to connect
    # (tries several port numbers, staring from 'PYZO')
    self._kernelCon = self._context.bind('localhost:PYZO',
                                            max_tries=256, name='kernel')

    # Get command to execute, and environment to use
    command = getCommandFromKernelInfo(self._info, self._kernelCon.port1)
    env = getEnvFromKernelInfo(self._info)

    # Wrap command in call to 'cmd'?
    if sys.platform.startswith('win'):
        # as the author from Pype writes:
        #if we don't run via a command shell, then either sometimes we
        #don't get wx GUIs, or sometimes we can't kill the subprocesses.
        # And I also see problems with Tk.
        # But we only use it if we are sure that cmd is available.
        # See pyzo issue #240
        try:
            subprocess.check_output('cmd /c "cd"', shell=True)
        except (IOError, subprocess.SubprocessError):
            pass  # Do not use cmd
        else:
            command = 'cmd /c "{}"'.format(command)

    # Start process
    self._process = subprocess.Popen(   command, shell=True,
                                        env=env, cwd=cwd,
                                        stdin=subprocess.PIPE,  # Fixes issue 165
                                        stdout=subprocess.PIPE,
                                        stderr=subprocess.STDOUT
                                    )

    # Set timeout for connection, i.e. after how much time of
    # unresponsive ness is the kernel found to be running extension code
    # Better set this before connecting
    self._kernelCon.timeout = 0.5

    # Bind to events
    self._kernelCon.closed.bind(self._onKernelConnectionClose)
    self._kernelCon.timedout.bind(self._onKernelTimedOut)

    # Create reader for stream
    self._streamReader = StreamReader(self._process,
                                self._strm_raw, self._strm_broker)

    # Start streamreader and timer
    self._streamReader.start()
    self._timer.start()

    # Reset some variables
    self._pending_restart = None
</t>
<t tx="ekr.20190812072048.46">@path pyzo/codeeditor/extensions/
@nopyflakes
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.460">def hostConnectionForIDE(self, address='localhost'):
    """ hostConnectionForIDE()

    Host a connection for an IDE to connect to. Returns the port to which
    the ide can connect.

    """
    c = self._context.bind(address+':PYZO+256', max_tries=32)
    return c.port1

## Callbacks
</t>
<t tx="ekr.20190812072048.461">def _onKernelTimedOut(self, c, timedout):
    """ _onKernelTimedOut(c, timeout)

    The kernel timed out (i.e. did not send heartbeat messages for
    a while. It is probably running extension code.

    """
    if timedout:
        self._stat_interpreter.send('Very busy')
    else:
        self._stat_interpreter.send('Busy')
</t>
<t tx="ekr.20190812072048.462">def _onKernelConnectionClose(self, c, why):
    """ _onKernelConnectionClose(c, why)

    Connection with kernel lost. Tell clients why.

    """

    # If we receive this event while the current kernel connection
    # is not the one that generated the event, ignore it.
    if self._kernelCon is not c:
        return

    # The only reasonable way that the connection
    # can be lost without the kernel closing, is if the yoton context
    # crashed or was stopped somehow. In both cases, we lost control,
    # and should put it down!
    if not self._terminator:
        self.terminate('because connecton was lost', 'KILL', 0.5)
</t>
<t tx="ekr.20190812072048.463">def _onKernelDied(self, returncode=0):
    """ _onKernelDied()

    Kernel process died. Clean up!

    """

    # If the kernel did not start yet, probably the command is invalid
    if self._kernelCon and self._kernelCon.is_waiting:
        msg = 'The process failed to start (invalid command?).'
    elif not self.isTerminating():
        msg = 'Kernel process exited.'
    elif not self._terminator._prev_action:
        # We did not actually take any terminating action
        # This happens, because if the kernel is killed from outside,
        # _onKernelConnectionClose() triggers a terminate sequence
        # (but with a delay).
        # Note the "The" to be able to distinguish this case
        msg = 'The kernel process exited.'
    else:
        msg = self._terminator.getMessage('Kernel process')

    if self._context.connection_count:
        # Notify
        returncodeMsg = '\n%s (%s)\n\n' % (msg, str(returncode))
        self._strm_broker.send(returncodeMsg)
        # Empty prompt and signal dead
        self._strm_prompt.send('\b')
        self._stat_interpreter.send('Dead')
        self._context.flush()

    # Cleanup (get rid of kernel process references)
    self._reset()

    # Handle any pending action
    if self._pending_restart:
        self.startKernel()

## Main loop and termination
</t>
<t tx="ekr.20190812072048.464">def terminate(self, reason='by user', action='TERM', timeout=0.0):
    """ terminate(reason='by user', action='TERM', timeout=0.0)

    Initiate termination procedure for the current kernel.

    """

    # The terminatation procedure is started by creating
    # a KernelTerminator instance. This instance's iteration method
    # iscalled from _mailLoopIter().
    self._terminator = KernelTerminator(self, reason, action, timeout)
</t>
<t tx="ekr.20190812072048.465">def isTerminating(self):
    """ isTerminating()

    Get whether the termination procedure has been initiated. This
    simply checks whether there is a self._terminator instance.

    """
    return bool(self._terminator)
</t>
<t tx="ekr.20190812072048.466">def mainLoopIter(self):
    """ mainLoopIter()

    Periodically called. Kind of the main loop iteration for this kernel.

    """

    # Get some important status info
    hasProcess = self._process is not None
    hasKernelConnection = bool(self._kernelCon and self._kernelCon.is_connected)
    hasClients = False
    if self._context:
        hasClients = self._context.connection_count &gt; int(hasKernelConnection)

    # Should we clean the whole thing up?
    if not (hasProcess or hasClients):
        self._reset(True) # Also unregisters this timer callback
        return

    # Waiting to get started; waiting for client to connect
    if isinstance(self._process, float):
        if self._context.connection_count:
            self.startKernel()
        elif self._process &gt; time.time():
            self._process = None
        return

    # If we have a process ...
    if self._process:
        # Test if process is dead
        process_returncode = self._process.poll()
        if process_returncode is not None:
            self._onKernelDied(process_returncode)
            return
        # Are we in the process of terminating?
        elif self.isTerminating():
            self._terminator.next()
    elif self.isTerminating():
        # We cannot have a terminator if we have no process
        self._terminator = None

    # handle control messages
    if self._ctrl_broker:
        for msg in self._ctrl_broker.recv_all():
            if msg == 'INT':
                self._commandInterrupt()
            elif msg == 'TERM':
                self._commandTerminate()
            elif msg.startswith('RESTART'):
                self._commandRestart(msg)
            else:
                pass # Message is not for us
</t>
<t tx="ekr.20190812072048.467">def _commandInterrupt(self):
    if self._process is None:
        self._strm_broker.send('Cannot interrupt: process is dead.\n')
    # Kernel receives and acts
    elif sys.platform.startswith('win'):
        self._reqp_introspect.interrupt()
    else:
        # Use POSIX to interrupt, which is more reliable
        # (the introspect thread might not get a chance)
        # but also does not work if running extension code
        pid = self._kernelCon.pid2
        os.kill(pid, signal.SIGINT)
</t>
<t tx="ekr.20190812072048.468">def _commandTerminate(self):
    # Start termination procedure
    # Kernel will receive term and act (if it can).
    # If it wont, we will act in a second or so.
    if self._process is None:
        self._strm_broker.send('Cannot terminate: process is dead.\n')
    elif self.isTerminating():
        # The user gave kill command while the kill process
        # is running. We could do an immediate kill now,
        # or we let the terminate process run its course.
        pass
    else:
        self.terminate('by user')
</t>
<t tx="ekr.20190812072048.469">def _commandRestart(self, msg):
    # Almost the same as terminate, but now we have a pending action
    self._pending_restart = True

    # Recreate the info struct
    self._info = ssdf.copy(self._originalInfo)
    # Update the info struct
    new_info = ssdf.loads(msg.split('RESTART',1)[1])
    for key in new_info:
        self._info[key] = new_info[key]

    # Restart now, wait, or initiate termination procedure?
    if self._process is None:
        self.startKernel()
    elif self.isTerminating():
        pass # Already terminating
    else:
        self.terminate('for restart')
</t>
<t tx="ekr.20190812072048.47"># -*- coding: utf-8 -*-
from ..qt import QtCore, QtGui, QtWidgets  # noqa
Qt = QtCore.Qt
</t>
<t tx="ekr.20190812072048.470">class KernelTerminator:
    """ KernelTerminator(broker, reason='user terminated', action='TERM', timeout=0.0)

    Simple class to help terminating the kernel. It has a next() method
    that should be periodically called. It keeps track whether the timeout
    has passed and will undertake increaslingly ruder actions to terminate
    the kernel.

    """
    @others
</t>
<t tx="ekr.20190812072048.471">def __init__(self, broker, reason='by user', action='TERM', timeout=0.0):

    # Init/store
    self._broker = broker
    self._reason = reason
    self._next_action = ''

    # Go
    self._do(action, timeout)
</t>
<t tx="ekr.20190812072048.472">def _do(self, action, timeout):
    self._prev_action = self._next_action
    self._next_action = action
    self._timeout = time.time() + timeout
    if not timeout:
        self.next()
</t>
<t tx="ekr.20190812072048.473">def next(self):

    # Get action
    action = self._next_action

    if time.time() &lt; self._timeout:
        # Time did not pass yet
        pass

    elif action == 'TERM':
        self._broker._reqp_introspect.terminate()
        self._do('INT', 0.5)

    elif action == 'INT':
        # Count
        if not hasattr(self, '_count'):
            self._count = 0
        self._count +=1
        # Handle
        if self._count &lt; 5:
            self._broker._reqp_introspect.interrupt()
            self._do('INT', 0.1)
        else:
            self._do('KILL', 0)

    elif action == 'KILL':
        # Get pid and signal
        pid = self._broker._kernelCon.pid2
        sigkill = signal.SIGTERM
        if hasattr(signal,'SIGKILL'):
            sigkill = signal.SIGKILL
        # Kill
        if hasattr(os,'kill'):
            os.kill(pid, sigkill)
        elif sys.platform.startswith('win'):
            kernel32 = ctypes.windll.kernel32
            handle = kernel32.OpenProcess(1, 0, pid)
            kernel32.TerminateProcess(handle, 0)
            #os.system("TASKKILL /PID " + str(pid) + " /F")
        # Set what we did
        self._do('NOTHING', 9999999999999999)
</t>
<t tx="ekr.20190812072048.474">def getMessage(self, what):
    # Get nice string of that
    D = {   '':     'exited',
            'TERM': 'terminated',
            'INT':  'terminated (after interrupting)',
            'KILL': 'killed'}
    actionMsg = D.get(self._prev_action, 'stopped for unknown reason')

    # Compile stop-string
    return '{} {} {}.'.format( what, actionMsg, self._reason)
</t>
<t tx="ekr.20190812072048.475">class StreamReader(threading.Thread):
    """ StreamReader(process, channel)

    Reads stdout of process and send to a yoton channel.
    This needs to be done in a separate thread because reading from
    a PYPE blocks.

    """
    @others
</t>
<t tx="ekr.20190812072048.476">def __init__(self, process, strm_raw, strm_broker):
    threading.Thread.__init__(self)

    self._process = process
    self._strm_raw = strm_raw
    self._strm_broker = strm_broker
    self.deamon = True
    self._exit = False
</t>
<t tx="ekr.20190812072048.477">def stop(self, timeout=1.0):
    self._exit = True
    self.join(timeout)
</t>
<t tx="ekr.20190812072048.478">def run(self):
    while not self._exit:
        time.sleep(0.001)
        # Read any stdout/stderr messages and route them via yoton.
        msg = self._process.stdout.readline() # &lt;-- Blocks here
        if not isinstance(msg, str):
            msg = msg.decode('utf-8', 'ignore')
        try:
            self._strm_raw.send(msg)
        except IOError:
            pass # Channel is closed
        # Process dead?
        if not msg:# or self._process.poll() is not None:
            break
    #self._strm_broker.send('streamreader exit\n')
</t>
<t tx="ekr.20190812072048.479">class Kernelmanager:
    """ Kernelmanager

    This class manages a set of kernels. These kernels run on the
    same machine as this broker. IDE's can ask which kernels are available
    and can connect to them via this broker.

    The Pyzo process runs an instance of this class that connects at
    localhost. At a later stage, we may make it possible to create
    a kernel-server at a remote machine.

    """

    @others
</t>
<t tx="ekr.20190812072048.48">class Calltip(object): # tag:CodeEditor
    _styleElements = [('Editor.calltip', 'The style of the calltip. ',
                        'fore:#555, back:#ff9, border:1')]

    @others
</t>
<t tx="ekr.20190812072048.480">def __init__(self, public=False):

    # Set whether other machines in this network may connect to our kernels
    self._public = public

    # Init list of kernels
    self._kernels = []
</t>
<t tx="ekr.20190812072048.481">def createKernel(self, info, name=None):
    """ create_kernel(info, name=None)

    Create a new kernel. Returns the port number to connect to the
    broker's context.

    """

    # Set name if not given
    if not name:
        i = len(self._kernels) + 1
        name = 'kernel %i' % i

    # Create kernel
    kernel = KernelBroker(self, info, name)
    self._kernels.append(kernel)

    # Host a connection for the ide
    port = kernel.hostConnectionForIDE()

    # Tell broker to start as soon as the IDE connects with the broker
    kernel.startKernelIfConnected()

    # Done
    return port
</t>
<t tx="ekr.20190812072048.482">def getKernelList(self):

    # Get info of each kernel as an ssdf struct
    infos = []
    for kernel in self._kernels:
        info = kernel._info
        info = ssdf.loads(info.tostring())
        info.name = kernel._name
        infos.append(info)

    # Done
    return infos
</t>
<t tx="ekr.20190812072048.483">def terminateAll(self):
    """ terminateAll()

    Terminates all kernels. Required when shutting down Pyzo.
    When this function returns, all kernels will be terminated.

    """
    for kernel in [kernel for kernel in self._kernels]:

        # Try closing the process gently: by closing stdin
        terminator = KernelTerminator(kernel, 'for closing down')

        # Terminate
        while (kernel._kernelCon and kernel._kernelCon.is_connected and
                kernel._process and (kernel._process.poll() is None) ):
            time.sleep(0.02)
            terminator.next()

        # Clean up
        kernel._reset(True)
</t>
<t tx="ekr.20190812072048.484">@path pyzo/core/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.485"># -*- coding: utf-8 -*-
""" Module main

This module contains the main frame. Implements the main window.
Also adds some variables to the pyzo namespace, such as the callLater
function which is also defined here.

"""

try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo.core.main.py (MainWindow)')
except Exception:
    leo_g = None

import os, sys, time
import base64
from queue import Queue, Empty

import pyzo
from pyzo.core.icons import IconArtist
from pyzo.core import commandline
from pyzo.util import qt
from pyzo.util.qt import QtCore, QtGui, QtWidgets
from pyzo.core.splash import SplashWidget
from pyzo.util import paths
from pyzo.util import zon as ssdf  # zon is ssdf-light
from pyzo import translate

</t>
<t tx="ekr.20190812072048.486">class MainWindow(QtWidgets.QMainWindow):

    @others
</t>
<t tx="ekr.20190812072048.487">def __init__(self, parent=None, locale=None):
    
    # if leo_g: leo_g.pr('\nBEGIN MainWindow.__init__')

    QtWidgets.QMainWindow.__init__(self, parent)
    
    # self.setObjectName('MainWindow') # EKR:change.

    self._closeflag = 0  # Used during closing/restarting

    # Init window title and application icon
    # Set title to something nice. On Ubuntu 12.10 this text is what
    # is being shown at the fancy title bar (since it's not properly
    # updated)
    self.setMainTitle()
    loadAppIcons()
    self.setWindowIcon(pyzo.icon)

    # Restore window geometry before drawing for the first time,
    # such that the window is in the right place
    self.resize(800, 600) # default size
    self.restoreGeometry()

    # Show splash screen (we need to set our color too)
    w = SplashWidget(self, distro='no distro')
    self.setCentralWidget(w)
    if 0: # EKR:change.
        self.setStyleSheet("QMainWindow { background-color: #268bd2;}")

    # Show empty window and disable updates for a while
    self.show()
    self.paintNow()
    self.setUpdatesEnabled(False)

    # Determine timeout for showing splash screen
    splash_timeout = time.time() + 1.0

    # Set locale of main widget, so that qt strings are translated
    # in the right way
    if locale:
        self.setLocale(locale)

    # Store myself
    pyzo.main = self

    # Init dockwidget settings
    self.setTabPosition(QtCore.Qt.AllDockWidgetAreas,QtWidgets.QTabWidget.South)
    self.setDockOptions(
            QtWidgets.QMainWindow.AllowNestedDocks |
            QtWidgets.QMainWindow.AllowTabbedDocks
            #|  QtWidgets.QMainWindow.AnimatedDocks
        )

    # Set window atrributes
    self.setAttribute(QtCore.Qt.WA_AlwaysShowToolTips, True)

    # Load icons and fonts
    loadIcons()
    loadFonts()

    # Set qt style and test success
    self.setQtStyle(None) # None means init!

    # Hold the splash screen if needed
    while time.time() &lt; splash_timeout:
        QtWidgets.qApp.flush()
        QtWidgets.qApp.processEvents()
        time.sleep(0.05)

    # Populate the window (imports more code)
    self._populate()

    # Revert to normal background, and enable updates
    self.setStyleSheet('')
    self.setUpdatesEnabled(True)

    # Restore window state, force updating, and restore again
    self.restoreState()
    self.paintNow()
    self.restoreState()

    # Present user with wizard if he/she is new.
    if False:  # pyzo.config.state.newUser:
        from pyzo.util.pyzowizard import PyzoWizard
        w = PyzoWizard(self)
        w.show() # Use show() instead of exec_() so the user can interact with pyzo

    # Create new shell config if there is None
    if not pyzo.config.shellConfigs2:
        from pyzo.core.kernelbroker import KernelInfo
        pyzo.config.shellConfigs2.append( KernelInfo() )

    # EKR:change Set background.
    if True:
        bg = getattr(pyzo.config.settings, 'dark_background', '#657b83')
            # Default: solarized base00
        try:
            self.setStyleSheet("background: %s" % bg) 
        except Exception:
            print('oops: MainWindow.__init__')

    # Focus on editor
    e = pyzo.editors.getCurrentEditor()
    if e is not None:
        e.setFocus()

    # Handle any actions
    commandline.handle_cmd_args()
    
    # if leo_g: leo_g.pr('END MainWindow.__init__')

# To force drawing ourselves
</t>
<t tx="ekr.20190812072048.488">def paintEvent(self, event):
    QtWidgets.QMainWindow.paintEvent(self, event)
    self._ispainted = True
</t>
<t tx="ekr.20190812072048.489">def paintNow(self):
    """ Enforce a repaint and keep calling processEvents until
    we are repainted.
    """
    self._ispainted = False
    self.update()
    while not self._ispainted:
        QtWidgets.qApp.flush()
        QtWidgets.qApp.processEvents()
        time.sleep(0.01)
</t>
<t tx="ekr.20190812072048.49">class __CalltipLabel(QtWidgets.QLabel):
    @others
</t>
<t tx="ekr.20190812072048.490">def _populate(self):

    # if leo_g: leo_g.pr('MainWindow._populate')

    # Delayed imports
    from pyzo.core.editorTabs import EditorTabs
    from pyzo.core.shellStack import ShellStackWidget
    from pyzo.core import codeparser
    from pyzo.core.history import CommandHistory
    from pyzo.tools import ToolManager

    # Instantiate tool manager
    pyzo.toolManager = ToolManager()

    # Check to install conda now ...
    #from pyzo.util.bootstrapconda import check_for_conda_env
    #check_for_conda_env()

    # Instantiate and start source-code parser
    if pyzo.parser is None:
        pyzo.parser = codeparser.Parser()
        pyzo.parser.start()

    # Create editor stack and make the central widget
    pyzo.editors = EditorTabs(self)
    self.setCentralWidget(pyzo.editors)
        # EKR: QMainWindow.setCentralWidget

    # Create floater for shell
    self._shellDock = dock = QtWidgets.QDockWidget(self)
    if pyzo.config.settings.allowFloatingShell:
        dock.setFeatures(dock.DockWidgetMovable | dock.DockWidgetFloatable)
    else:
        dock.setFeatures(dock.DockWidgetMovable)
    dock.setObjectName('shells')
    dock.setWindowTitle('Shells')
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)

    # Create shell stack
    pyzo.shells = ShellStackWidget(self)
    dock.setWidget(pyzo.shells)

    # Initialize command history
    pyzo.command_history = CommandHistory('command_history.py')

    # Create the default shell when returning to the event queue
    callLater(pyzo.shells.addShell)

    # Create statusbar
    if pyzo.config.view.showStatusbar:
        pyzo.status = self.statusBar()
    else:
        pyzo.status = None
        self.setStatusBar(None)

    # Create menu
    from pyzo.core import menu
    pyzo.keyMapper = menu.KeyMapper()
    menu.buildMenus(self.menuBar())

    # Add the context menu to the editor
    pyzo.editors.addContextMenu()
    pyzo.shells.addContextMenu()

    # Load tools
    if pyzo.config.state.newUser and not pyzo.config.state.loadedTools:
        pyzo.toolManager.loadTool('pyzosourcestructure')
        pyzo.toolManager.loadTool('pyzofilebrowser', 'pyzosourcestructure')
    elif pyzo.config.state.loadedTools:
        for toolId in pyzo.config.state.loadedTools:
            pyzo.toolManager.loadTool(toolId)
</t>
<t tx="ekr.20190812072048.491">def setMainTitle(self, path=None):
    """ Set the title of the main window, by giving a file path.
    """
    if not path:
        # Plain title
        title = "Interactive Editor for Python"
    else:
        # Title with a filename
        name = os.path.basename(path)
        if os.path.isfile(path):
            pass
        elif name == path:
            path = translate("main", 'unsaved')
        else:
            pass  # We hope the given path is informative
        # Set title
        tmp = { 'fileName':name, 'filename':name, 'name':name,
                'fullPath':path, 'fullpath':path, 'path':path }
        title = pyzo.config.advanced.titleText.format(**tmp)

    # Set
    self.setWindowTitle(title)
</t>
<t tx="ekr.20190812072048.492">def saveWindowState(self):
    """ Save:
        * which tools are loaded
        * geometry of the top level windows
        * layout of dockwidgets and toolbars
    """

    # Save tool list
    tools = pyzo.toolManager.getLoadedTools()
    pyzo.config.state.loadedTools = tools

    # Store window geometry
    geometry = self.saveGeometry()
    try:
        geometry = bytes(geometry) # PyQt4
    except:
        geometry = bytes().join(geometry) # PySide
    geometry = base64.encodebytes(geometry).decode('ascii')
    pyzo.config.state.windowGeometry = geometry

    # Store window state
    state = self.saveState()
        # EKR: a QByteArray.
    try:
        state = bytes(state) # PyQt4
    except:
        state = bytes().join(state) # PySide
    state = base64.encodebytes(state).decode('ascii')
    pyzo.config.state.windowState = state
</t>
<t tx="ekr.20190812072048.493">def restoreGeometry(self, value=None):
    # Restore window position and whether it is maximized

    if value is not None:
        return super().restoreGeometry(value)

    # No value give, try to get it from the config
    if pyzo.config.state.windowGeometry:
        try:
            geometry = pyzo.config.state.windowGeometry
            geometry = base64.decodebytes(geometry.encode('ascii'))
            self.restoreGeometry(geometry)
        except Exception as err:
            print('Could not restore window geomerty: ' + str(err))
</t>
<t tx="ekr.20190812072048.494">def restoreState(self, value=None):
    # Restore layout of dock widgets and toolbars

    if value is not None:
        return super().restoreState(value)

    # No value give, try to get it from the config
    if pyzo.config.state.windowState:
        try:
            state = pyzo.config.state.windowState
            state = base64.decodebytes(state.encode('ascii'))
            self.restoreState(state)
        except Exception as err:
            print('Could not restore window state: ' + str(err))
</t>
<t tx="ekr.20190812072048.495">def setQtStyle(self, stylename=None):
    """ Set the style and the palette, based on the given style name.
    If stylename is None or not given will do some initialization.
    If bool(stylename) evaluates to False will use the default style
    for this system. Returns the QStyle instance.
    """

    if stylename is None:
        # Initialize

        # Get native pallette (used below)
        QtWidgets.qApp.nativePalette = QtWidgets.qApp.palette()

        # Obtain default style name
        pyzo.defaultQtStyleName = str(QtWidgets.qApp.style().objectName())

        # Other than gtk+ and mac, Fusion/Cleanlooks looks best (in my opinion)
        if 'gtk' in pyzo.defaultQtStyleName.lower():
            pass # Use default style
        elif 'macintosh' in pyzo.defaultQtStyleName.lower():
            pass # Use default style
        elif qt.QT_VERSION &gt; '5':
            pyzo.defaultQtStyleName = 'Fusion'
        else:
            pyzo.defaultQtStyleName = 'Cleanlooks'

        # Set style if there is no style yet
        if not pyzo.config.view.qtstyle:
            pyzo.config.view.qtstyle = pyzo.defaultQtStyleName

    # Init
    if not stylename:
        stylename = pyzo.config.view.qtstyle

    # Check if this style exist, set to default otherwise
    styleNames = [name.lower() for name in QtWidgets.QStyleFactory.keys()]
    if stylename.lower() not in styleNames:
        stylename = pyzo.defaultQtStyleName

    # Try changing the style
    qstyle = QtWidgets.qApp.setStyle(stylename)

    # Set palette
    if qstyle:
        QtWidgets.qApp.setPalette(QtWidgets.qApp.nativePalette)

    # Done
    # if leo_g: leo_g.trace(stylename)
    return qstyle
</t>
<t tx="ekr.20190812072048.496">def closeEvent(self, event):
    """ Override close event handler. """
    
    # Replaced by the close_handler function.
    
    leo_g.pr('ORIGINAL MainWindow.closeEvent')

    # Are we restaring?
    restarting = time.time() - self._closeflag &lt; 1.0

    # Save settings
    pyzo.saveConfig()
    pyzo.command_history.save()

    # Stop command server
    commandline.stop_our_server()

    # Proceed with closing...
    result = pyzo.editors.closeAll()
    if not result:
        self._closeflag = False
        event.ignore()
        return
    else:
        self._closeflag = True
        #event.accept()  # Had to comment on Windows+py3.3 to prevent error

    # Proceed with closing shells
    pyzo.localKernelManager.terminateAll()
    for shell in pyzo.shells:
        shell._context.close()

    # Close tools
    for toolname in pyzo.toolManager.getLoadedTools():
        tool = pyzo.toolManager.getTool(toolname)
        tool.close()

    # Stop all threads (this should really only be daemon threads)
    import threading
    for thread in threading.enumerate():
        if hasattr(thread, 'stop'):
            try:
                thread.stop(0.1)
            except Exception:
                pass

#         # Wait for threads to die ...
#         # This should not be necessary, but I used it in the hope that it
#         # would prevent the segfault on Python3.3. It didn't.
#         timeout = time.time() + 0.5
#         while threading.activeCount() &gt; 1 and time.time() &lt; timeout:
#             time.sleep(0.1)
#         print('Number of threads alive:', threading.activeCount())

    # Proceed as normal
    QtWidgets.QMainWindow.closeEvent(self, event)

    # Harder exit to prevent segfault. Not really a solution,
    # but it does the job until Pyside gets fixed.
    if sys.version_info &gt;= (3,3,0) and not restarting:
        if hasattr(os, '_exit'):
            os._exit(0)
</t>
<t tx="ekr.20190812072048.497">def restart(self):
    """ Restart Pyzo. """

    self._closeflag = time.time()

    # Close
    self.close()

    if self._closeflag:
        # Get args
        args = [arg for arg in sys.argv]

        if not paths.is_frozen():
            # Prepend the executable name (required on Linux)
            lastBit = os.path.basename(sys.executable)
            args.insert(0, lastBit)

        # Replace the process!
        os.execv(sys.executable, args)
</t>
<t tx="ekr.20190812072048.498">def createPopupMenu(self):

    # Init menu
    menu = QtWidgets.QMenu()

    # Insert two items
    for item in ['Editors', 'Shells']:
        action = menu.addAction(item)
        action.setCheckable(True)
        action.setChecked(True)
        action.setEnabled(False)

    # Insert tools
    for tool in pyzo.toolManager.loadToolInfo():
        action = menu.addAction(tool.name)
        action.setCheckable(True)
        action.setChecked(bool(tool.instance))
        action.menuLauncher = tool.menuLauncher

    # Show menu and process result
    a = menu.popup(QtGui.QCursor.pos())
    if a:
        a.menuLauncher(not a.menuLauncher(None))
</t>
<t tx="ekr.20190812072048.499">def loadAppIcons():
    """ loadAppIcons()
    Load the application iconsr.
    """
    # Get directory containing the icons
    appiconDir =  os.path.join(pyzo.pyzoDir, 'resources', 'appicons')

    # Determine template for filename of the application icon-files.
    fnameT = 'pyzologo{}.png'

    # Construct application icon. Include a range of resolutions. Note that
    # Qt somehow does not use the highest possible res on Linux/Gnome(?), even
    # the logo of qt-designer when alt-tabbing looks a bit ugly.
    pyzo.icon = QtGui.QIcon()
    for sze in [16, 32, 48, 64, 128, 256]:
        fname = os.path.join(appiconDir, fnameT.format(sze))
        if os.path.isfile(fname):
            pyzo.icon.addFile(fname, QtCore.QSize(sze, sze))

    # Set as application icon. This one is used as the default for all
    # windows of the application.
    QtWidgets.qApp.setWindowIcon(pyzo.icon)

    # Construct another icon to show when the current shell is busy
    artist = IconArtist(pyzo.icon) # extracts the 16x16 version
    artist.setPenColor('#0B0')
    for x in range(11, 16):
        d = x-11 # runs from 0 to 4
        artist.addLine(x,6+d,x,15-d)
    pm = artist.finish().pixmap(16,16)
    #
    pyzo.iconRunning = QtGui.QIcon(pyzo.icon)
    pyzo.iconRunning.addPixmap(pm) # Change only 16x16 icon
</t>
<t tx="ekr.20190812072048.5">def autocompleteActive(self):
    """ Returns whether an autocompletion list is currently shown.
    """
    return self.__autocompleteStart is not None
</t>
<t tx="ekr.20190812072048.50">def __init__(self):
    QtWidgets.QLabel.__init__(self)

    # Start hidden
    self.hide()
    # Accept rich text
    self.setTextFormat(QtCore.Qt.RichText)
    # Show as tooltip
    self.setIndent(2)
    self.setWindowFlags(QtCore.Qt.ToolTip)
</t>
<t tx="ekr.20190812072048.500">def loadIcons():
    """ loadIcons()
    Load all icons in the icon dir.
    """
    # Get directory containing the icons
    iconDir = os.path.join(pyzo.pyzoDir, 'resources', 'icons')

    # Construct other icons
    dummyIcon = IconArtist().finish()
    # if leo_g: leo_g.trace('loadIcons: dummyIcon: %r' % dummyIcon)
    pyzo.icons = ssdf.new()
    for fname in os.listdir(iconDir):
        if fname.endswith('.png'):
            try:
                # Short and full name
                name = fname.split('.')[0]
                name = name.replace('pyzo_', '')  # discart prefix
                ffname = os.path.join(iconDir,fname)
                # Create icon
                icon = QtGui.QIcon()
                icon.addFile(ffname, QtCore.QSize(16,16))
                # Store
                pyzo.icons[name] = icon
            except Exception as err:
                pyzo.icons[name] = dummyIcon
                print('Could not load icon %s: %s' % (fname, str(err)))
</t>
<t tx="ekr.20190812072048.501">def loadFonts():
    """ loadFonts()
    Load all fonts that come with Pyzo.
    """
    import pyzo.codeeditor  # we need pyzo and codeeditor namespace here

    # Get directory containing the icons
    fontDir = os.path.join(pyzo.pyzoDir, 'resources', 'fonts')

    # Get database object
    db = QtGui.QFontDatabase()

    # Set default font
    pyzo.codeeditor.Manager.setDefaultFontFamily('DejaVu Sans Mono')

    # Load fonts that are in the fonts directory
    if os.path.isdir(fontDir):
        for fname in os.listdir(fontDir):
            if 'oblique' in fname.lower():  # issue #461
                continue
            if os.path.splitext(fname)[1].lower() in ['.otf', '.ttf']:
                try:
                    db.addApplicationFont( os.path.join(fontDir, fname) )
                except Exception as err:
                    print('Could not load font %s: %s' % (fname, str(err)))
</t>
<t tx="ekr.20190812072048.502">class _CallbackEventHandler(QtCore.QObject):
    """ Helper class to provide the callLater function.
    """

    @others
</t>
<t tx="ekr.20190812072048.503">def __init__(self):
    QtCore.QObject.__init__(self)
    self.queue = Queue()
</t>
<t tx="ekr.20190812072048.504">def customEvent(self, event):
    while True:
        try:
            callback, args = self.queue.get_nowait()
        except Empty:
            break
        try:
            callback(*args)
        except Exception as why:
            print('callback failed: {}:\n{}'.format(callback, why))
</t>
<t tx="ekr.20190812072048.505">def postEventWithCallback(self, callback, *args):
    self.queue.put((callback, args))
    QtWidgets.qApp.postEvent(self, QtCore.QEvent(QtCore.QEvent.User))
</t>
<t tx="ekr.20190812072048.506">def callLater(callback, *args):
    """ callLater(callback, *args)
    Post a callback to be called in the main thread.
    """
    _callbackEventHandler.postEventWithCallback(callback, *args)

# Create callback event handler instance and insert function in pyzo namespace
_callbackEventHandler = _CallbackEventHandler()
pyzo.callLater = callLater

_SCREENSHOT_CODE = """
import random

numerator = 4

def get_number():
    # todo: something appears to be broken here
    val = random.choice(range(10))
    return numerator / val

class Groceries(list):
    \"\"\" Overloaded list class.
    \"\"\"
    def append_defaults(self):
        spam = 'yum'
        pie = 3.14159
        self.extend([spam, pie])

class GroceriesPlus(Groceries):
    \"\"\" Groceries with surprises!
    \"\"\"
    def append_random(self):
        value = get_number()
        self.append(value)

# Create some groceries

g = GroceriesPlus()
g.append_defaults()
g.append_random()

"""
</t>
<t tx="ekr.20190812072048.507">def screenshotExample(width=1244, height=700):
    e = pyzo.editors.newFile()
    e.editor.setPlainText(_SCREENSHOT_CODE)
    pyzo.main.resize(width, height)
</t>
<t tx="ekr.20190812072048.508">def screenshot(countdown=5):
    QtCore.QTimer.singleShot(countdown*1000, _screenshot)
</t>
<t tx="ekr.20190812072048.509">def _screenshot():
    # Grab
    print('SNAP!')
    pix = QtGui.QPixmap.grabWindow(pyzo.main.winId())
    #pix = QtGui.QPixmap.grabWidget(pyzo.main)
    # Get name
    i = 1
    while i &gt; 0:
        name = 'pyzo_screen_%s_%02i.png' % (sys.platform, i)
        fname = os.path.join(os.path.expanduser('~'), name)
        if os.path.isfile(fname):
            i += 1
        else:
            i = -1
    # Save screenshot and a thumb
    pix.save(fname)
    thumb = pix.scaledToWidth(500, QtCore.Qt.SmoothTransformation)
    thumb.save(fname.replace('screen', 'thumb'))
    print('Screenshot and thumb saved in', os.path.expanduser('~'))

pyzo.screenshot = screenshot
pyzo.screenshotExample = screenshotExample
</t>
<t tx="ekr.20190812072048.51">def enterEvent(self, event):
    # Act a bit like a tooltip
    self.hide()
</t>
<t tx="ekr.20190812072048.510">@path pyzo/core/
# -*- coding: utf-8 -*-

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.511">try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('IMPORT pyzo.core')
except Exception:
    leo_g = None

""" Module menu

Implements a menu that can be edited very easily. Every menu item is
represented by a class. Also implements a dialog to change keyboard
shortcuts.

"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo/core/menu.py')
except Exception:
    leo_g = None
import os, sys, re
import webbrowser
from urllib.request import urlopen
import json

from pyzo.util.qt import QtCore, QtGui, QtWidgets

import pyzo
from pyzo.core.compactTabWidget import CompactTabWidget
if 0: # EKR:change: Is this necessary???
    from pyzo.core.pyzoLogging import print  # noqa
    assert print
from pyzo.core.assistant import PyzoAssistant
from pyzo import translate
</t>
<t tx="ekr.20190812072048.512">def buildMenus(menuBar):
    """
    Build all the menus.
    EKR: Called from MainWindow._populate.
    """
    menus = [   FileMenu(menuBar, translate("menu", "File")),
                EditMenu(menuBar, translate("menu", "Edit")),
                ViewMenu(menuBar, translate("menu", "View")),
                SettingsMenu(menuBar, translate("menu", "Settings")),
                ShellMenu(menuBar, translate("menu", "Shell")),
                RunMenu(menuBar, translate("menu", "Run")),
                ToolsMenu(menuBar, translate("menu", "Tools")),
                HelpMenu(menuBar, translate("menu", "Help")),
            ]
    menuBar._menumap = {}
    menuBar._menus = menus
    for menu in menuBar._menus:
        menuBar.addMenu(menu)
        menuName = menu.__class__.__name__.lower().split('menu')[0]
        menuBar._menumap[menuName] = menu

    # Enable tooltips
    def onHover(action):
        # This ugly bit of code makes sure that the tooltip is refreshed
        # (thus raised above the submenu). This happens only once and after
        # ths submenu has become visible.
        if action.menu():
            if not hasattr(menuBar, '_lastAction'):
                menuBar._lastAction = None
                menuBar._haveRaisedTooltip = False
            if action is menuBar._lastAction:
                if ((not menuBar._haveRaisedTooltip) and
                            action.menu().isVisible()):
                    QtWidgets.QToolTip.hideText()
                    menuBar._haveRaisedTooltip = True
            else:
                menuBar._lastAction = action
                menuBar._haveRaisedTooltip = False
        # Set tooltip
        tt = action.statusTip()
        if hasattr(action, '_shortcutsText'):
            tt = tt + ' ({})'.format(action._shortcutsText) # Add shortcuts text in it
        QtWidgets.QToolTip.showText(QtGui.QCursor.pos(), tt)
    menuBar.hovered.connect(onHover)

# todo: syntax styles now uses a new system. Make dialog for it!
# todo: put many settings in an advanced settings dialog:
# - autocomp use keywords
# - autocomp case sensitive
# - autocomp select chars
# - Default parser / indentation (width and tabsOrSpaces) / line endings
# - Shell wrapping to 80 columns?
# - number of lines in shell
# - more stuff from pyzo.config.advanced?
</t>
<t tx="ekr.20190812072048.513">def getShortcut(fullName):
    """ Given the full name or an action, get the shortcut
    from the pyzo.config.shortcuts2 dict. A tuple is returned
    representing the two shortcuts. """
    if isinstance(fullName, QtWidgets.QAction):
        fullName = fullName.menuPath # the menuPath property is set in Menu._addAction
    shortcut = '', ''
    if fullName in pyzo.config.shortcuts2:
        shortcut = pyzo.config.shortcuts2[fullName]
        if shortcut.count(','):
            shortcut = tuple(shortcut.split(','))
        else:
            shortcut = shortcut, ''
    return shortcut
</t>
<t tx="ekr.20190812072048.514">def translateShortcutToOSNames(shortcut):
    """
    Translate Qt names to OS names (e.g. Ctrl -&gt; cmd symbol for Mac,
    Meta -&gt; Windows for windows
    """

    if sys.platform == 'darwin':
        replace = (('Ctrl+','\u2318'),('Shift+','\u21E7'),
                    ('Alt+','\u2325'),('Meta+','^'))
    else:
        replace = ()

    for old, new in replace:
        shortcut = shortcut.replace(old, new)

    return shortcut
</t>
<t tx="ekr.20190812072048.515">class KeyMapper(QtCore.QObject):
    """
    This class is accessable via pyzo.keyMapper
    pyzo.keyMapper.keyMappingChanged is emitted when keybindings are changed
    """

    keyMappingChanged = QtCore.Signal()

    @others
</t>
<t tx="ekr.20190812072048.516">def setShortcut(self, action):
    """
    When an action is created or when keymappings are changed, this method
    is called to set the shortcut of an action based on its menuPath
    (which is the key in pyzo.config.shortcuts2, e.g. shell__clear_screen)
    """
    if action.menuPath in pyzo.config.shortcuts2:
        # Set shortcut so Qt can do its magic
        shortcuts = pyzo.config.shortcuts2[action.menuPath]
        action.setShortcuts(shortcuts.split(','))
        pyzo.main.addAction(action)  # issue #470, http://stackoverflow.com/questions/23916623
        # Also store shortcut text (used in display of tooltip
        shortcuts = shortcuts.replace(',',', ').replace('  ', ' ')
        action._shortcutsText = shortcuts.rstrip(', ')
</t>
<t tx="ekr.20190812072048.517">def unwrapText(text):
    """ Unwrap text to display in message boxes. This just removes all
    newlines. If you want to insert newlines, use \\r."""

    # Removes newlines
    text = text.replace('\n', '')

    # Remove double/triple/etc spaces
    text = text.lstrip()
    for i in range(10):
        text = text.replace('  ', ' ')

    # Convert \\r newlines
    text = text.replace('\r', '\n')

    # Remove spaces after newlines
    text = text.replace('\n ', '\n')

    return text
</t>
<t tx="ekr.20190812072048.518">class Menu(QtWidgets.QMenu):
    """ Menu(parent=None, name=None)

    Base class for all menus. Has methods to add actions of all sorts.

    The add* methods all have the name and icon as first two arguments.
    This is not so consistent with the Qt API for addAction, but it allows
    for cleaner code to add items; the first item can be quite long because
    it is a translation. In the current API, the second and subsequent
    arguments usually fit nicely on the second line.

    """
    @others
</t>
<t tx="ekr.20190812072048.519">def __init__(self, parent=None, name=None):
    QtWidgets.QMenu.__init__(self, parent)

    # Make sure that the menu has a title
    if name:
        self.setTitle(name)
    else:
        raise ValueError

    # Set tooltip too?
    if hasattr(name, 'tt'):
        self.setStatusTip(name.tt)

    # Action groups within the menu keep track of the selected value
    self._groups = {}

    # menuPath is used to bind shortcuts, it is ,e.g. shell__clear_screen
    if hasattr(parent,'menuPath'):
        self.menuPath = parent.menuPath + '__'
    else:
        self.menuPath = '' #This is a top-level menu

    # Get key for this menu
    key = name
    if hasattr(name, 'key'):
        key = name.key
    self.menuPath += self._createMenuPathName(key)

    # Build the menu. Happens only once
    self.build()
</t>
<t tx="ekr.20190812072048.52">def __init__(self, *args, **kwds):
    super(Calltip, self).__init__(*args, **kwds)
    # Create label for call tips
    self.__calltipLabel = self.__CalltipLabel()
    # Be notified of style updates
    self.styleChanged.connect(self.__afterSetStyle)

    # Prevents calltips from being shown immediately after pressing
    # the escape key.
    self.__noshow = False
</t>
<t tx="ekr.20190812072048.520">def _createMenuPathName(self, name):
    """
    Convert a menu title into a menuPath component name
    e.g. Interrupt current shell -&gt; interrupt_current_shell
    """
    # hide anything between brackets
    name = re.sub('\(.*\)', '', name)
    # replace invalid chars
    name = name.replace(' ', '_')
    if name and name[0] in '0123456789_':
        name = "_" + name
    name = re.sub('[^a-zA-z_0-9]','',name)
    return name.lower()
</t>
<t tx="ekr.20190812072048.521">def _addAction(self, text, icon, selected=None):
    """ Convenience function that makes the right call to addAction().
    """
    

    # Add the action
    if icon is None:
        a = self.addAction(text)
    else:
        a = self.addAction(icon, text)
        
    ### if leo_g and text == 'New':
        # leo_g.pr('\nMenu._addAction: action: %015x icon: %015x text: %s \n' % (id(a), id(icon), text))

    # Checkable?
    if selected is not None:
        a.setCheckable(True)
        a.setChecked(selected)

     # Set tooltip if we can find it
    if hasattr(text, 'tt'):
        a.setStatusTip(text.tt)

    # Find the key (untranslated name) for this menu item
    key = a.text()
    if hasattr(text, 'key'):
        key = text.key
    a.menuPath = self.menuPath + '__' + self._createMenuPathName(key)

    # Register the action so its keymap is kept up to date
    pyzo.keyMapper.keyMappingChanged.connect(lambda: pyzo.keyMapper.setShortcut(a))
    pyzo.keyMapper.setShortcut(a)

    return a
</t>
<t tx="ekr.20190812072048.522">def build(self):
    """
    Add all actions to the menu. To be overridden.
    """
    pass
</t>
<t tx="ekr.20190812072048.523">def addMenu(self, menu, icon=None):
    """
    Add a (sub)menu to this menu.
    """

    # Add menu in the conventional way
    a = QtWidgets.QMenu.addMenu(self, menu)
    a.menuPath = menu.menuPath

    # Set icon
    if icon is not None:
        a.setIcon(icon)

    return menu
</t>
<t tx="ekr.20190812072048.524">def addItem(self, text, icon=None, callback=None, value=None):
    """
    Add an item to the menu. If callback is given and not None,
    connect triggered signal to the callback. If value is None or not
    given, callback is called without parameteres, otherwise it is called
    with value as parameter
    """

    # Add action
    a = self._addAction(text, icon)

    # Connect the menu item to its callback
    if callback:
        if value is not None:
            a.triggered.connect(lambda b=None, v=value: callback(v))
        else:
            a.triggered.connect(lambda b=None: callback())

    return a
</t>
<t tx="ekr.20190812072048.525">def addGroupItem(self, text, icon=None, callback=None, value=None, group=None):
    """
    Add a 'select-one' option to the menu. Items with equal group value form
    a group. If callback is specified and not None, the callback is called
    for the new active item, with the value for that item as parameter
    whenever the selection is changed
    """

    # Init action
    a = self._addAction(text, icon)
    a.setCheckable(True)

    # Connect the menu item to its callback (toggled is a signal only
    # emitted by checkable actions, and can also be called programmatically,
    # e.g. in QActionGroup)
    if callback:
        def doCallback(b, v):
            if b:
                callback(v)
        a.toggled.connect(lambda b=None, v=value: doCallback(a.isChecked(), v))

    # Add the menu item to a action group
    if group is None:
        group = 'default'
    if group not in self._groups:
        #self._groups contains tuples (actiongroup, dict-of-actions)
        self._groups[group] = (QtWidgets.QActionGroup(self), {})

    actionGroup,actions = self._groups[group]
    actionGroup.addAction(a)
    actions[value]=a

    return a
</t>
<t tx="ekr.20190812072048.526">def addCheckItem(self, text, icon=None, callback=None, value=None, selected=False):
    """
    Add a true/false item to the menu. If callback is specified and not
    None, the callback is called when the item is changed. If value is not
    specified or None, callback is called with the new state as parameter.
    Otherwise, it is called with the new state and value as parameters
    """

    # Add action
    a = self._addAction(text, icon, selected)

    # Connect the menu item to its callback
    if callback:
        if value is not None:
            a.triggered.connect(lambda b=None, v=value: callback(a.isChecked(),v))
        else:
            a.triggered.connect(lambda b=None: callback(a.isChecked()))

    return a
</t>
<t tx="ekr.20190812072048.527">def setCheckedOption(self, group, value):
    """
    Set the selected value of a group. This will also activate the
    callback function of the item that gets selected.
    if group is None the default group is used.
    """
    if group is None:
        group = 'default'
    actionGroup, actions = self._groups[group]
    if value in actions:
        actions[value].setChecked(True)
</t>
<t tx="ekr.20190812072048.528">class GeneralOptionsMenu(Menu):
    """ GeneralOptionsMenu(parent, name, callback, options=None)

    Menu to present the user with a list from which to select one item.
    We need this a lot.

    """

    @others
</t>
<t tx="ekr.20190812072048.529">def __init__(self, parent=None, name=None, callback=None, options=None):
    Menu.__init__(self, parent, name)
    self._options_callback = callback
    if options:
        self.setOptions(options)
</t>
<t tx="ekr.20190812072048.53">def __afterSetStyle(self):
    format = self.getStyleElementFormat('editor.calltip')
    ss = "QLabel { color:%s; background:%s; border:%ipx solid %s; }" % (
                format['fore'], format['back'],
                int(format['border']), format['fore'] )
    self.__calltipLabel.setStyleSheet(ss)
</t>
<t tx="ekr.20190812072048.530">def build(self):
    pass # We build when the options are given
</t>
<t tx="ekr.20190812072048.531">def setOptions(self, options, values=None):
    """
    Set the list of options, clearing any existing options. The options
    are added ad group items and registered to the callback given
    at initialization.
    """
    # Init
    self.clear()
    cb = self._options_callback
    # Get values
    if values is None:
        values = options
    for option, value in zip(options, values):
        self.addGroupItem(option, None, cb, value)
</t>
<t tx="ekr.20190812072048.532">class IndentationMenu(Menu):
    """
    Menu for the user to control the type of indentation for a document:
    tabs vs spaces and the amount of spaces.
    Part of the File menu.
    """

    @others
</t>
<t tx="ekr.20190812072048.533">def build(self):
    self._items = [
        self.addGroupItem(translate("menu", "Use tabs"),
            None, self._setStyle, False, group="style"),
        self.addGroupItem(translate("menu", "Use spaces"),
            None, self._setStyle, True, group="style")
        ]
    self.addSeparator()
    spaces = translate("menu", "spaces", "plural of spacebar character")
    self._items += [
        self.addGroupItem("%d %s" % (i, spaces), None, self._setWidth, i, group="width")
        for i in range(2,9)
        ]
</t>
<t tx="ekr.20190812072048.534">def _setWidth(self, width):
    editor = pyzo.editors.getCurrentEditor()
    if editor is not None:
        editor.setIndentWidth(width)
</t>
<t tx="ekr.20190812072048.535">def _setStyle(self, style):
    editor = pyzo.editors.getCurrentEditor()
    if editor is not None:
        editor.setIndentUsingSpaces(style)
</t>
<t tx="ekr.20190812072048.536">class FileMenu(Menu):
    @others
</t>
<t tx="ekr.20190812072048.537">def build(self):
    icons = pyzo.icons

    self._items = []

    # Create indent menu
    t = translate("menu", "Indentation ::: The indentation used of the current file.")
    self._indentMenu = IndentationMenu(self, t)

    # Create parser menu
    from pyzo import codeeditor
    t = translate("menu", "Syntax parser ::: The syntax parser of the current file.")
    self._parserMenu = GeneralOptionsMenu(self, t, self._setParser)
    self._parserMenu.setOptions(["Plain"] + codeeditor.Manager.getParserNames())

    # Create line ending menu
    t = translate("menu", "Line endings ::: The line ending character of the current file.")
    self._lineEndingMenu = GeneralOptionsMenu(self, t, self._setLineEndings)
    self._lineEndingMenu.setOptions(['LF', 'CR', 'CRLF'])

    # Create encoding menu
    t = translate("menu", "Encoding ::: The character encoding of the current file.")
    self._encodingMenu = GeneralOptionsMenu(self, t, self._setEncoding)

    # Bind to signal
    pyzo.editors.currentChanged.connect(self.onEditorsCurrentChanged)

    # Build menu file management stuff
    self.addItem(translate('menu', 'New ::: Create a new (or temporary) file.'),
        icons.page_add, pyzo.editors.newFile)
    self.addItem(translate("menu", "Open... ::: Open an existing file from disk."),
        icons.folder_page, pyzo.editors.openFile)
    #
    self._items += [
        self.addItem(translate("menu", "Save ::: Save the current file to disk."),
            icons.disk, pyzo.editors.saveFile),
        self.addItem(translate("menu", "Save as... ::: Save the current file under another name."),
            icons.disk_as, pyzo.editors.saveFileAs),
        self.addItem(translate("menu", "Save all ::: Save all open files."),
            icons.disk_multiple, pyzo.editors.saveAllFiles),
        self.addItem(translate("menu", "Close ::: Close the current file."),
            icons.page_delete, pyzo.editors.closeFile),
        self.addItem(translate("menu", "Close all ::: Close all files."),
            icons.page_delete_all, pyzo.editors.closeAllFiles),
        self.addItem(translate("menu", "Export to PDF ::: Export current file to PDF (e.g. for printing)."),
            None, self._print),
        ]

    # Build file properties stuff
    self.addSeparator()
    self._items += [
                self.addMenu(self._indentMenu, icons.page_white_gear),
                self.addMenu(self._parserMenu, icons.page_white_gear),
                self.addMenu(self._lineEndingMenu, icons.page_white_gear),
                self.addMenu(self._encodingMenu, icons.page_white_gear),
                ]

    # Closing of app
    self.addSeparator()
    self.addItem(translate("menu", "Restart Pyzo ::: Restart the application."),
        icons.arrow_rotate_clockwise, pyzo.main.restart)
    self.addItem(translate("menu","Quit Pyzo ::: Close the application."),
        icons.cancel, pyzo.main.close)

    # Start disabled
    self.setEnabled(False)
</t>
<t tx="ekr.20190812072048.538">def setEnabled(self, enabled):
    """ Enable or disable all items. If disabling, also uncheck all items """
    for child in self._items:
        child.setEnabled(enabled)
</t>
<t tx="ekr.20190812072048.539">def onEditorsCurrentChanged(self):
    editor = pyzo.editors.getCurrentEditor()
    if editor is None:
        self.setEnabled(False) #Disable / uncheck all editor-related options
    else:
        self.setEnabled(True)
        # Update indentation
        self._indentMenu.setCheckedOption("style", editor.indentUsingSpaces())
        self._indentMenu.setCheckedOption("width", editor.indentWidth())
        # Update parser
        parserName = 'Plain'
        if editor.parser():
            parserName = editor.parser().name() or 'Plain'
        self._parserMenu.setCheckedOption(None, parserName )
        # Update line ending
        self._lineEndingMenu.setCheckedOption(None, editor.lineEndingsHumanReadable)
        # Update encoding
        self._updateEncoding(editor)
</t>
<t tx="ekr.20190812072048.54">def calltipShow(self, offset=0, richText='', highlightFunctionName=False):
    """ calltipShow(offset=0, richText='', highlightFunctionName=False)

    Shows the given calltip.

    Parameters
    ----------
    offset : int
        The character offset to show the tooltip.
    richText : str
        The text to show (may contain basic html for markup).
    highlightFunctionName : bool
        If True the text before the first opening brace is made bold.
        default False.

    """

    # Do not show the calltip if it was deliberately hidden by the
    # user.
    if self.__noshow:
        return

    # Process calltip text?
    if highlightFunctionName:
        i = richText.find('(')
        if i&gt;0:
            richText = '&lt;b&gt;{}&lt;/b&gt;{}'.format(richText[:i], richText[i:])

    # Get a cursor to establish the position to show the calltip
    startcursor = self.textCursor()
    startcursor.movePosition(startcursor.Left, n=offset)

    # Get position in pixel coordinates
    rect = self.cursorRect(startcursor)
    pos = rect.topLeft()
    pos.setY( pos.y() - rect.height() - 1 ) # Move one above line
    pos.setX( pos.x() - 3) # Correct for border and indent
    pos = self.viewport().mapToGlobal(pos)

    # Set text and update font
    self.__calltipLabel.setText(richText)
    self.__calltipLabel.setFont(self.font())

    # Use a qt tooltip to show the calltip
    if richText:
        self.__calltipLabel.move(pos)
        self.__calltipLabel.show()
    else:
        self.__calltipLabel.hide()
</t>
<t tx="ekr.20190812072048.540">def _setParser(self, value):
    editor = pyzo.editors.getCurrentEditor()
    if value.lower() == 'plain':
        value = None
    if editor is not None:
        editor.setParser(value)
</t>
<t tx="ekr.20190812072048.541">def _setLineEndings(self, value):
    editor = pyzo.editors.getCurrentEditor()
    editor.lineEndings = value
</t>
<t tx="ekr.20190812072048.542">def _updateEncoding(self, editor):
    # Dict with encoding aliases (official to aliases)
    D  = {  'cp1250':  ('windows-1252', ),
            'cp1251':  ('windows-1251', ),
            'latin_1': ('iso-8859-1', 'iso8859-1', 'cp819', 'latin', 'latin1', 'L1')}
    # Dict with aliases mapping to "official value"
    Da = {}
    for key in D:
        for key2 in D[key]:
            Da[key2] = key

    # Encodings to list
    encodings = [   'utf-8','ascii', 'latin_1',
                    'cp1250', 'cp1251']

    # Get current encoding (add if not present)
    editorEncoding = editor.encoding
    if editorEncoding in Da:
        editorEncoding = Da[editorEncoding]
    if editorEncoding not in encodings:
        encodings.append(editorEncoding)

    # Handle aliases
    encodingNames, encodingValues = [], []
    for encoding in encodings:
        encodingValues.append(encoding)
        if encoding in D:
            name = '%s (%s)' % (encoding, ', '.join(D[encoding]))
            encodingNames.append(name)
        else:
            encodingNames.append(encoding)

    # Update
    self._encodingMenu.setOptions(encodingNames, encodingValues)
    self._encodingMenu.setCheckedOption(None, editorEncoding)
</t>
<t tx="ekr.20190812072048.543">def _setEncoding(self, value):
    editor = pyzo.editors.getCurrentEditor()
    if editor is not None:
        editor.encoding = value
</t>
<t tx="ekr.20190812072048.544">def _print(self):
    editor = pyzo.editors.getCurrentEditor()
    if editor is not None:

        from pyzo.util.qt import QtPrintSupport
        printer = QtPrintSupport.QPrinter(QtPrintSupport.QPrinter.HighResolution)
        if True:
            filename = QtWidgets.QFileDialog.getSaveFileName(None,
                    'Export PDF', os.path.expanduser("~"), "*.pdf *.ps")
            if isinstance(filename, tuple): # PySide
                filename = filename[0]
            if not filename:
                return
            printer.setOutputFileName(filename)
        else:
            d = QtWidgets.QPrintDialog(printer)
            d.setWindowTitle('Print code')
            d.setOption(d.PrintSelection, editor.textCursor().hasSelection())
            d.setOption(d.PrintToFile, True)
            ok = d.exec_()
            if ok != d.Accepted:
                return
        # Print with line numbers
        lines = editor.toPlainText().splitlines()
        nzeros = len(str(len(lines)))
        lines.insert(0, '# ' + editor.filename)
        for i in range(1, len(lines)):
            lines[i] = str(i).rjust(nzeros, '0') + '| ' + lines[i]
        cursor0 = editor.textCursor()
        cursor = editor.textCursor()
        cursor.movePosition(cursor.Start)
        cursor.movePosition(cursor.End, cursor.KeepAnchor)
        cursor.insertText('\n'.join(lines))
        try:
            editor.print_(printer)
        finally:
            editor.undo()
            editor.setTextCursor(cursor0)
# todo: move to matching brace
</t>
<t tx="ekr.20190812072048.545">class EditMenu(Menu):
    @others
</t>
<t tx="ekr.20190812072048.546">def build(self):
    icons = pyzo.icons

    self.addItem(translate("menu", "Undo ::: Undo the latest editing action."),
        icons.arrow_undo, self._editItemCallback, "undo")
    self.addItem(translate("menu", "Redo ::: Redo the last undone editong action."),
        icons.arrow_redo, self._editItemCallback, "redo")
    self.addSeparator()
    self.addItem(translate("menu", "Cut ::: Cut the selected text."),
        icons.cut, self._editItemCallback, "cut")
    self.addItem(translate("menu", "Copy ::: Copy the selected text to the clipboard."),
        icons.page_white_copy, self._editItemCallback, "copy")
    self.addItem(translate("menu", "Paste ::: Paste the text that is now on the clipboard."),
        icons.paste_plain, self._editItemCallback, "paste")
    self.addItem(translate("menu", "Paste and select ::: Paste the text that is now on the clipboard and keep it selected in order to change its indentation."),  # noqa
        icons.paste_plain, self._editItemCallback, "pasteAndSelect")
    self.addItem(translate("menu", "Select all ::: Select all text."),
        icons.sum, self._editItemCallback, "selectAll")
    self.addSeparator()
    self.addItem(translate("menu", "Indent ::: Indent the selected line."),
        icons.text_indent, self._editItemCallback, "indentSelection")
    self.addItem(translate("menu", "Dedent ::: Unindent the selected line."),
        icons.text_indent_remove, self._editItemCallback, "dedentSelection")
    self.addItem(translate("menu", "Comment ::: Comment the selected line."),
        icons.comment_add, self._editItemCallback, "commentCode")
    self.addItem(translate("menu", "Uncomment ::: Uncomment the selected line."),
        icons.comment_delete, self._editItemCallback, "uncommentCode")
    self.addItem(translate("menu", "Justify comment/docstring::: Reshape the selected text so it is aligned to around 70 characters."),
        icons.text_align_justify, self._editItemCallback, "justifyText")
    self.addItem(translate("menu", "Go to line ::: Go to a specific line number."),
        None, self._editItemCallback, "gotoLinePopup")
    self.addItem(translate("menu", "Duplicate line ::: Duplicate the selected line(s)."),
        None, self._editItemCallback, "duplicateLines")
    self.addItem(translate("menu", "Delete line ::: Delete the selected line(s)."),
        None, self._editItemCallback, "deleteLines")
    self.addSeparator()
    self.addItem(translate("menu", "Toggle breakpoint ::: Toggle breakpoint on the current line."),
        None, self._editItemCallback, "toggleBreakpoint")
    self.addSeparator()
    self.addItem(translate("menu", "Toggle Case ::: Change selected text to lower or upper case"),
        None, self._editItemCallback, "toggleCase")
    self.addSeparator()
    self.addItem(translate("menu", "Find or replace ::: Show find/replace widget. Initialize with selected text."),
        icons.find, pyzo.editors._findReplace.startFind)
    self.addItem(translate("menu", "Find selection ::: Find the next occurrence of the selected text."),
        None, pyzo.editors._findReplace.findSelection)
    self.addItem(translate("menu", "Find selection backward ::: Find the previous occurrence of the selected text."),
        None, pyzo.editors._findReplace.findSelectionBw)
    self.addItem(translate("menu", "Find next ::: Find the next occurrence of the search string."),
        None, pyzo.editors._findReplace.findNext)
    self.addItem(translate("menu", "Find previous ::: Find the previous occurrence of the search string."),
        None, pyzo.editors._findReplace.findPrevious)
</t>
<t tx="ekr.20190812072048.547">def _editItemCallback(self, action):
    widget = QtWidgets.qApp.focusWidget()
    #If the widget has a 'name' attribute, call it
    if hasattr(widget, action):
        getattr(widget, action)()
</t>
<t tx="ekr.20190812072048.548">class ZoomMenu(Menu):
    """
    Small menu for the zooming. Part of the view menu.
    """
    @others
</t>
<t tx="ekr.20190812072048.549">def build(self):
    self.addItem(translate("menu", 'Zoom in'), None, self._setZoom, +1)
    self.addItem(translate("menu", 'Zoom out'), None, self._setZoom, -1)
    self.addItem(translate("menu", 'Zoom reset'), None, self._setZoom, 0)
</t>
<t tx="ekr.20190812072048.55">def calltipCancel(self):
    """ calltipCancel()

    Hides the calltip.

    """
    self.__calltipLabel.hide()
</t>
<t tx="ekr.20190812072048.550">def _setZoom(self, value):
    if not value:
        pyzo.config.view.zoom = 0
    else:
        pyzo.config.view.zoom += value
    # Apply
    for editor in pyzo.editors:
        pyzo.config.view.zoom = editor.setZoom(pyzo.config.view.zoom)
    for shell in pyzo.shells:
        pyzo.config.view.zoom = shell.setZoom(pyzo.config.view.zoom)
    logger = pyzo.toolManager.getTool('pyzologger')
    if logger:
        logger.setZoom(pyzo.config.view.zoom)
</t>
<t tx="ekr.20190812072048.551">class FontMenu(Menu):
    @others
</t>
<t tx="ekr.20190812072048.552">def __init__(self, parent=None, name="Font", *args, **kwds):
    Menu.__init__(self, parent, name, *args, **kwds)
    self.aboutToShow.connect(self._updateFonts)
</t>
<t tx="ekr.20190812072048.553">def _updateFonts(self):
    self.clear()
    # Build list with known available monospace fonts
    names = pyzo.codeeditor.Manager.fontNames()
    defaultName =  'DejaVu Sans Mono'
    for name in sorted(names):
        default_suffix = ' (%s)' % translate('menu', 'default')
        txt = name + default_suffix if name == defaultName else name
        self.addGroupItem(txt, None, self._selectFont, value=name)
    # Select the current one
    self.setCheckedOption(None, pyzo.config.view.fontname)
</t>
<t tx="ekr.20190812072048.554">def _selectFont(self, name):
    pyzo.config.view.fontname = name
    # Apply
    for editor in pyzo.editors:
        editor.setFont(pyzo.config.view.fontname)
    for shell in pyzo.shells:
        shell.setFont(pyzo.config.view.fontname)
    logger = pyzo.toolManager.getTool('pyzologger')
    if logger:
        logger.setFont(pyzo.config.view.fontname)
# todo: brace matching
# todo: code folding?
# todo: maybe move qt theme to settings
</t>
<t tx="ekr.20190812072048.555">class ViewMenu(Menu):
    @others
</t>
<t tx="ekr.20190812072048.556">def build(self):
    icons = pyzo.icons

    # Create edge column menu
    t = translate("menu", "Location of long line indicator ::: The location of the long-line-indicator.")
    self._edgeColumMenu = GeneralOptionsMenu(self, t, self._setEdgeColumn)
    values = [0] + [i for i in range(60,130,10)]
    names = [translate("menu","None")] + [str(i) for i in values[1:]]
    self._edgeColumMenu.setOptions(names, values)
    self._edgeColumMenu.setCheckedOption(None, pyzo.config.view.edgeColumn)

    # Create qt theme menu
    t = translate("menu", "Qt theme ::: The styling of the user interface widgets.")
    self._qtThemeMenu = GeneralOptionsMenu(self, t, self._setQtTheme)
    styleNames = list(QtWidgets.QStyleFactory.keys())
    styleNames.sort()
    titles = [name for name in styleNames]
    styleNames = [name.lower() for name in styleNames]
    for i in range(len(titles)):
        if titles[i].lower() == pyzo.defaultQtStyleName.lower():
            titles[i] += " (%s)" % translate('menu', 'default')
    self._qtThemeMenu.setOptions(titles, styleNames)
    self._qtThemeMenu.setCheckedOption(None, pyzo.config.view.qtstyle.lower())

    # Build menu
    self.addItem(translate("menu", "Select shell ::: Focus the cursor on the current shell."),
        icons.application_shell, self._selectShell)
    self.addItem(translate("menu", "Select editor ::: Focus the cursor on the current editor."),
        icons.application_edit, self._selectEditor)
    self.addItem(translate("menu", "Select previous file ::: Select the previously selected file."),
        icons.application_double, pyzo.editors._tabs.selectPreviousItem)
    self.addSeparator()
    self.addEditorItem(translate("menu", "Show whitespace ::: Show spaces and tabs."),
        None, "showWhitespace")
    self.addEditorItem(translate("menu", "Show line endings ::: Show the end of each line."),
        None, "showLineEndings")
    self.addEditorItem(translate("menu", "Show indentation guides ::: Show vertical lines to indicate indentation."),
        None, "showIndentationGuides")
    self.addSeparator()
    self.addEditorItem(translate("menu", "Wrap long lines ::: Wrap lines that do not fit on the screen (i.e. no horizontal scrolling)."),
        None, "wrap")
    self.addEditorItem(translate("menu", "Highlight current line ::: Highlight the line where the cursor is."),
        None, "highlightCurrentLine")
    self.addEditorItem(translate("menu", "Highlight brackets ::: Highlight matched and unmatched brackets."),
        None, "highlightMatchingBracket")
    self.addSeparator()
    self.addItem(translate("menu", "Previous cell ::: Go back to the previous cell."),
        None, self._previousCell )
    self.addItem(translate("menu", "Next cell ::: Advance to the next cell."),
        None, self._nextCell )
    self.addItem(translate("menu", "Previous object ::: Go back to the previous top-level structure."),
        None, self._previousTopLevelObject )
    self.addItem(translate("menu", "Next object ::: Advance to the next top-level structure."),
        None, self._nextTopLevelObject )
    self.addSeparator()
    self.addMenu(self._edgeColumMenu, icons.text_padding_right)
    self.addMenu(FontMenu(self, translate("menu", "Font")), icons.style)
    self.addMenu(ZoomMenu(self, translate("menu", "Zooming")), icons.magnifier)
    self.addMenu(self._qtThemeMenu, icons.application_view_tile)
</t>
<t tx="ekr.20190812072048.557">def addEditorItem(self, name, icon, param):
    """
    Create a boolean item that reperesents a property of the editors,
    whose value is stored in pyzo.config.view.param
    """
    if hasattr(pyzo.config.view, param):
        default = getattr(pyzo.config.view, param)
    else:
        default = True

    self.addCheckItem(name, icon, self._configEditor, param, default)
</t>
<t tx="ekr.20190812072048.558">def _configEditor(self, state, param):
    """
    Callback for addEditorItem items
    """
    # Store this parameter in the config
    setattr(pyzo.config.view, param, state)
    # Apply to all editors, translate e.g. showWhitespace to setShowWhitespace
    setter = 'set' + param[0].upper() + param[1:]
    for editor in pyzo.editors:
        getattr(editor,setter)(state)
</t>
<t tx="ekr.20190812072048.559">def _selectShell(self):
    shell = pyzo.shells.getCurrentShell()
    if shell:
        shell.setFocus()
</t>
<t tx="ekr.20190812072048.56">def calltipActive(self):
    """ calltipActive()

    Get whether the calltip is currently active.

    """
    return self.__calltipLabel.isVisible()
</t>
<t tx="ekr.20190812072048.560">def _selectEditor(self):
    editor = pyzo.editors.getCurrentEditor()
    if editor:
        editor.setFocus()
</t>
<t tx="ekr.20190812072048.561">def _setEdgeColumn(self, value):
    pyzo.config.view.edgeColumn = value
    for editor in pyzo.editors:
        editor.setLongLineIndicatorPosition(value)
</t>
<t tx="ekr.20190812072048.562">def _setQtTheme(self, value):
    pyzo.config.view.qtstyle = value
    pyzo.main.setQtStyle(value)
</t>
<t tx="ekr.20190812072048.563">def _previousCell(self):
    """
    Rewind the curser to the previous cell (starting with '##').
    """
    self._previousTopLevelObject(type='cell')
</t>
<t tx="ekr.20190812072048.564">def _nextCell(self):
    """
    Advance the curser to the next cell (starting with '##').
    """
    self._nextTopLevelObject(type='cell')
</t>
<t tx="ekr.20190812072048.565">def _previousTopLevelObject(self, type=None):
    # Get parser result
    result = pyzo.parser._getResult()
    if not result:
        return

    # Get editor
    editor = pyzo.editors.getCurrentEditor()
    if not editor:
        return

    # Get current line number
    ln = editor.textCursor().blockNumber()
    ln += 1  # is ln as in line number area

    runCursor = editor.textCursor() #The part that should be run
    runCursor.movePosition(runCursor.StartOfBlock)

    # Find the object which starts above current curser
    # position if there is any and move there
    for object in reversed(result.rootItem.children):
        # If type given, only consider objects of that type
        if type and type!=object.type:
            continue
        if ln and object.linenr &lt; ln:
            startLineNr = object.linenr

            # Rewind cursor until the start of this object
            while True:
                if not runCursor.block().previous().isValid():
                    return
                runCursor.movePosition(runCursor.PreviousBlock)
                if runCursor.blockNumber() == startLineNr-1:
                    break

            cursor = editor.textCursor()
            cursor.setPosition(runCursor.position())
            editor.setTextCursor(cursor)
            return
</t>
<t tx="ekr.20190812072048.566">def _nextTopLevelObject(self, type=None):
    # Get parser result
    result = pyzo.parser._getResult()
    if not result:
        return

    # Get editor
    editor = pyzo.editors.getCurrentEditor()
    if not editor:
        return

    # Get current line number
    ln = editor.textCursor().blockNumber()
    ln += 1  # is ln as in line number area

    runCursor = editor.textCursor() #The part that should be run
    runCursor.movePosition(runCursor.StartOfBlock)

    # Find the object which starts below current curser
    # position if there is any and move there
    for object in result.rootItem.children:
        # If type given, only consider objects of that type
        if type and type!=object.type:
            continue
        if ln and object.linenr &gt; ln:
            startLineNr = object.linenr
            endLineNr = object.linenr2

            # Advance cursor until the start of this object
            while True:
                if not runCursor.block().next().isValid():
                    return
                runCursor.movePosition(runCursor.NextBlock)
                if runCursor.blockNumber() == startLineNr-1:
                    break

            realCursorPosition = runCursor.position()

            # Advance cursor until the end of this object (to know
            # how far it extends and make sure it is most visible)
            while True:
                if not runCursor.block().next().isValid():
                    break
                runCursor.movePosition(runCursor.NextBlock)
                if runCursor.blockNumber() == endLineNr-1:
                    break

            cursor = editor.textCursor()
            cursor.setPosition(runCursor.position())
            editor.setTextCursor(cursor)
            cursor.setPosition(realCursorPosition)
            editor.setTextCursor(cursor)
            return
</t>
<t tx="ekr.20190812072048.567">class ShellMenu(Menu):

    @others
</t>
<t tx="ekr.20190812072048.568">def __init__(self, parent=None, name="Shell"):
    self._shellCreateActions = []
    self._shellActions = []
    Menu.__init__(self, parent, name)
    pyzo.shells.currentShellChanged.connect(self.onCurrentShellChanged)
    self.aboutToShow.connect(self._updateShells)
</t>
<t tx="ekr.20190812072048.569">def onCurrentShellChanged(self):
    """ Enable/disable shell actions based on wether a shell is available """
    for shellAction in self._shellActions:
        shellAction.setEnabled(bool(pyzo.shells.getCurrentShell()))
</t>
<t tx="ekr.20190812072048.57">def focusOutEvent(self, event):
    super(Calltip, self).focusOutEvent(event)
    self.__calltipLabel.hide()
</t>
<t tx="ekr.20190812072048.570">def buildShellActions(self):
    """ Create the menu items which are also avaliable in the
    ShellTabContextMenu

    Returns a list of all items added"""
    icons = pyzo.icons
    return [
        self.addItem(translate("menu", 'Clear screen ::: Clear the screen.'),
            icons.application_eraser, self._shellAction, "clearScreen"),
        self.addItem(translate("menu", 'Interrupt ::: Interrupt the current running code (does not work for extension code).'),
            icons.application_lightning, self._shellAction, "interrupt"),
        self.addItem(translate("menu", 'Restart ::: Terminate and restart the interpreter.'),
            icons.application_refresh, self._shellAction, "restart"),
        self.addItem(translate("menu", 'Terminate ::: Terminate the interpreter, leaving the shell open.'),
            icons.application_delete, self._shellAction, "terminate"),
        self.addItem(translate("menu", 'Close ::: Terminate the interpreter and close the shell.'),
            icons.cancel, self._shellAction, "closeShell"),
        ]
</t>
<t tx="ekr.20190812072048.571">def buildShellDebugActions(self):
    """ Create the menu items for debug shell actions.
    Returns a list of all items added"""
    icons = pyzo.icons

    return [
        self.addItem(translate("menu", 'Debug next: proceed until next line'),
            icons.debug_next, self._debugAction, "NEXT"),
        self.addItem(translate("menu", 'Debug step into: proceed one step'),
            icons.debug_step, self._debugAction, "STEP"),
        self.addItem(translate("menu", 'Debug return: proceed until returns'),
            icons.debug_return, self._debugAction, "RETURN"),
        self.addItem(translate("menu", 'Debug continue: proceed to next breakpoint'),
            icons.debug_continue, self._debugAction, "CONTINUE"),
        self.addItem(translate("menu", 'Stop debugging'),
            icons.debug_quit, self._debugAction, "STOP"),
        ]
</t>
<t tx="ekr.20190812072048.572">def getShell(self):
    """ Returns the shell on which to apply the menu actions. Default is
    the current shell, this is overridden in the shell/shell tab context
    menus"""
    return pyzo.shells.getCurrentShell()
</t>
<t tx="ekr.20190812072048.573">def build(self):
    """ Create the items for the shells menu """

    # Normal shell actions
    self._shellActions = self.buildShellActions()

    self.addSeparator()

    # Debug stuff
    self._debug_clear_text = translate('menu', 'Clear all {} breakpoints')
    self._debug_clear = self.addItem('', pyzo.icons.bug_delete, self._clearBreakPoints)
    self._debug_pm = self.addItem(
        translate('menu', 'Postmortem: debug from last traceback'),
        pyzo.icons.bug_delete, self._debugAction, "START")
    self._shellDebugActions = self.buildShellDebugActions()
    #
    self.aboutToShow.connect(self._updateDebugButtons)

    self.addSeparator()

    # Shell config
    self.addItem(translate("menu", 'Edit shell configurations... ::: Add new shell configs and edit interpreter properties.'),
        pyzo.icons.application_wrench, self._editConfig2)
    self.addItem(translate("menu", 'Create new Python environment... ::: Install miniconda.'),
        pyzo.icons.application_cascade, self._newPythonEnv)

    self.addSeparator()

    # Add shell configs
    self._updateShells()
</t>
<t tx="ekr.20190812072048.574">def _updateShells(self):
    """ Remove, then add the items for the creation of each shell """
    for action in self._shellCreateActions:
        self.removeAction(action)

    self._shellCreateActions = []
    for i, config in enumerate(pyzo.config.shellConfigs2):
        name = translate('menu', 'Create shell %s: (%s)') % (i+1, config.name)
        action = self.addItem(name,
            pyzo.icons.application_add, pyzo.shells.addShell, config)
        self._shellCreateActions.append(action)
</t>
<t tx="ekr.20190812072048.575">def _updateDebugButtons(self):
    # Count breakpoints
    bpcount = 0
    for e in pyzo.editors:
        bpcount += len(e.breakPoints())
    self._debug_clear.setText(self._debug_clear_text.format(bpcount))
    # Determine state of PM and clear button
    debugmode = pyzo.shells._debugmode
    self._debug_pm.setEnabled(debugmode==0)
    self._debug_clear.setEnabled(debugmode==0)
    # The _shellDebugActions are enabled/disabled by the shellStack
</t>
<t tx="ekr.20190812072048.576">def _shellAction(self, action):
    """ Call the method specified by 'action' on the current shell.
    """
    shell = self.getShell()
    if shell:
        # Call the specified action
        getattr(shell,action)()
</t>
<t tx="ekr.20190812072048.577">def _debugAction(self, action):
    shell = self.getShell()
    if shell:
        # Call the specified action
        command = action.upper()
        shell.executeCommand('DB %s\n' % command)
</t>
<t tx="ekr.20190812072048.578">def _clearBreakPoints(self, action=None):
    for e in pyzo.editors:
        e.clearBreakPoints()
</t>
<t tx="ekr.20190812072048.579">def _editConfig2(self):
    """ Edit, add and remove configurations for the shells. """
    from pyzo.core.shellInfoDialog import ShellInfoDialog
    d = ShellInfoDialog()
    d.exec_()
</t>
<t tx="ekr.20190812072048.58">def keyPressEvent(self,event):
    # If the user presses Escape and the calltip is active, hide it
    if event.key() == Qt.Key_Escape and event.modifiers() == Qt.NoModifier \
            and self.calltipActive():
        self.calltipCancel()
        self.__noshow = True
        return

    if event.key() in [Qt.Key_ParenLeft, Qt.Key_ParenRight]:
        self.__noshow = False

    # Proceed processing the keystrike
    super(Calltip, self).keyPressEvent(event)
</t>
<t tx="ekr.20190812072048.580">def _newPythonEnv(self):
    from pyzo.util.bootstrapconda import Installer
    d = Installer(pyzo.main)
    d.exec_()
</t>
<t tx="ekr.20190812072048.581">class ShellButtonMenu(ShellMenu):

    @others
</t>
<t tx="ekr.20190812072048.582">def build(self):
    self._shellActions = []

    self.addItem(translate("menu", 'Edit shell configurations... ::: Add new shell configs and edit interpreter properties.'),
        pyzo.icons.application_wrench, self._editConfig2)

    submenu = Menu(self, translate("menu", 'New shell ... ::: Create new shell to run code in.'))
    self._newShellMenu = self.addMenu(submenu, pyzo.icons.application_add)

    self.addSeparator()
</t>
<t tx="ekr.20190812072048.583">def _updateShells(self):
    """ Remove, then add the items for the creation of each shell """
    for action in self._shellCreateActions:
        self._newShellMenu.removeAction(action)

    self._shellCreateActions = []
    for i, config in enumerate(pyzo.config.shellConfigs2):
        name = translate('menu', 'Create shell %s: (%s)') % (i+1, config.name)
        action = self._newShellMenu.addItem(name,
            pyzo.icons.application_add, pyzo.shells.addShell, config)
        self._shellCreateActions.append(action)
</t>
<t tx="ekr.20190812072048.584">class ShellContextMenu(ShellMenu):
    """ This is the context menu for the shell """
    @others
</t>
<t tx="ekr.20190812072048.585">def __init__(self, shell, parent=None):
    ShellMenu.__init__(self, parent or shell, name='Shellcontextmenu')
    self._shell = shell
</t>
<t tx="ekr.20190812072048.586">def build(self):
    """ Build menu """
    self.buildShellActions()
    icons = pyzo.icons

    # This is a subset of the edit menu. Copied manually.
    self.addSeparator()
    self.addItem(translate("menu", "Cut ::: Cut the selected text."),
        icons.cut, self._editItemCallback, "cut")
    self.addItem(translate("menu", "Copy ::: Copy the selected text to the clipboard."),
        icons.page_white_copy, self._editItemCallback, "copy")
    self.addItem(translate("menu", "Paste ::: Paste the text that is now on the clipboard."),
        icons.paste_plain, self._editItemCallback, "paste")
    self.addItem(translate("menu", "Select all ::: Select all text."),
        icons.sum, self._editItemCallback, "selectAll")

    self.addSeparator()
    self.addItem(translate("menu", "Open current directory in file browser"),
        None, self._editItemCallback, "opendir")
    self.addItem(translate("menu", "Change current directory to the file browser's path"),
        None, self._editItemCallback, "changedir")
    self.addItem(translate("menu", "Change current directory to editor file path"),
        None, self._editItemCallback, "changedirtoeditor")
</t>
<t tx="ekr.20190812072048.587">def getShell(self):
    """ Shell actions of this menu operate on the shell specified in the constructor """
    return self._shell
</t>
<t tx="ekr.20190812072048.588">def _editItemCallback(self, action):
    #If the widget has a 'name' attribute, call it
    if action == 'opendir':
        curdir = self._shell.get_kernel_cd()
        fileBrowser = pyzo.toolManager.getTool('pyzofilebrowser')
        if curdir and fileBrowser:
            fileBrowser.setPath(curdir)
    elif action == 'changedir':
        fileBrowser = pyzo.toolManager.getTool('pyzofilebrowser')
        if fileBrowser:
            self._shell.executeCommand('cd ' + fileBrowser.path() + '\n')
    elif action == 'changedirtoeditor':
        msg = ''
        editor = pyzo.editors.getCurrentEditor()
        if editor is None:
            msg += translate("menu", "No editor selected.")
        # Show error dialog
        if msg:
            m = QtWidgets.QMessageBox(self)
            m.setWindowTitle(translate("menu dialog", "Could not change dir"))
            m.setText(translate("menu", "Could not  change dir" + ":\n\n" + msg))
            m.setIcon(m.Warning)
            m.exec_()
        else:
            self._shell.executeCommand('cd ' + os.path.dirname(editor.filename) + '\n')

    else:
        getattr(self._shell, action)()
</t>
<t tx="ekr.20190812072048.589">def _updateShells(self):
    pass
</t>
<t tx="ekr.20190812072048.59">@path pyzo/codeeditor/extensions/
# Extra line, so perfect import will work.
@nopyflakes
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.590">class ShellTabContextMenu(ShellContextMenu):
    """ The context menu for the shell tab is similar to the shell context menu,
    but only has the shell actions defined in ShellMenu.buildShellActions()"""
    @others
</t>
<t tx="ekr.20190812072048.591">def build(self):
    """ Build menu """
    self.buildShellActions()
</t>
<t tx="ekr.20190812072048.592">def _updateShells(self):
    pass
</t>
<t tx="ekr.20190812072048.593">class EditorContextMenu(Menu):
    """ This is the context menu for the editor """
    @others
</t>
<t tx="ekr.20190812072048.594">def __init__(self, editor, name='EditorContextMenu' ):
    self._editor = editor
    Menu.__init__(self, editor, name)
</t>
<t tx="ekr.20190812072048.595">def build(self):
    """ Build menu """
    icons = pyzo.icons

    # This is a subset of the edit menu. Copied manually.
    self.addItem(translate("menu", "Cut ::: Cut the selected text."),
        icons.cut, self._editItemCallback, "cut")
    self.addItem(translate("menu", "Copy ::: Copy the selected text to the clipboard."),
        icons.page_white_copy, self._editItemCallback, "copy")
    self.addItem(translate("menu", "Paste ::: Paste the text that is now on the clipboard."),
        icons.paste_plain, self._editItemCallback, "paste")
    self.addItem(translate("menu", "Select all ::: Select all text."),
        icons.sum, self._editItemCallback, "selectAll")
    self.addSeparator()
    self.addItem(translate("menu", "Indent ::: Indent the selected line."),
        icons.text_indent, self._editItemCallback, "indentSelection")
    self.addItem(translate("menu", "Dedent ::: Unindent the selected line."),
        icons.text_indent_remove, self._editItemCallback, "dedentSelection")
    self.addItem(translate("menu", "Comment ::: Comment the selected line."),
        icons.comment_add, self._editItemCallback, "commentCode")
    self.addItem(translate("menu", "Uncomment ::: Uncomment the selected line."),
        icons.comment_delete, self._editItemCallback, "uncommentCode")
    self.addItem(translate("menu", "Justify comment/docstring::: Reshape the selected text so it is aligned to around 70 characters."),
        icons.text_align_justify, self._editItemCallback, "justifyText")
    self.addSeparator()
    self.addItem(translate("menu", "Goto Definition ::: Go to definition of word under cursor."),
        icons.debug_return, self._editItemCallback, "gotoDef")
    self.addItem(translate("menu", "Open directory in file browser"),
        None, self._editItemCallback, "opendir")
    self.addSeparator()
    self.addItem(translate("menu", "Find or replace ::: Show find/replace widget. Initialize with selected text."),
        icons.find, pyzo.editors._findReplace.startFind)
    self.addItem(translate("menu", "Find selection ::: Find the next occurrence of the selected text."),
        None, pyzo.editors._findReplace.findSelection)
    self.addItem(translate("menu", "Find selection backward ::: Find the previous occurrence of the selected text."),
        None, pyzo.editors._findReplace.findSelectionBw)

    # This is a subset of the run menu. Copied manually.
    self.addSeparator()
    self.addItem(translate("menu", 'Run selection ::: Run the current editor\'s selected lines, selected words on the current line, or current line if there is no selection.'),   # noqa
        icons.run_lines, self._runSelected)
</t>
<t tx="ekr.20190812072048.596">def _editItemCallback(self, action):
    #If the widget has a 'name' attribute, call it
    if action == 'opendir':
        fileBrowser = pyzo.toolManager.getTool('pyzofilebrowser')
        if fileBrowser:
            fileBrowser.setPath(os.path.dirname(self._editor.filename))
    else:
        getattr(self._editor, action)()
</t>
<t tx="ekr.20190812072048.597">def _runSelected(self):
    runMenu = pyzo.main.menuBar()._menumap['run']
    runMenu._runSelected()
</t>
<t tx="ekr.20190812072048.598">class EditorTabContextMenu(Menu):
    @others
</t>
<t tx="ekr.20190812072048.599">def __init__(self, *args, **kwds):
    Menu.__init__(self, *args, **kwds)
    self._index = -1
</t>
<t tx="ekr.20190812072048.6">def __positionAutocompleter(self):
    """Move the autocompleter list to a proper position"""
    #Find the start of the autocompletion and move the completer popup there
    cur=QtGui.QTextCursor(self.__autocompleteStart) #Copy __autocompleteStart

    # Set size
    geometry = self.__completer.popup().geometry()
    geometry.setWidth(self.__popupSize[0])
    geometry.setHeight(self.__popupSize[1])
    self.__completer.popup().setGeometry(geometry)

    # Initial choice for position of the completer
    position = self.cursorRect(cur).bottomLeft() + self.viewport().pos()

    # Check if the completer is going to go off the screen
    desktop_geometry = QtWidgets.qApp.desktop().geometry()
    global_position = self.mapToGlobal(position)
    if global_position.y() + geometry.height() &gt; desktop_geometry.height():
        # Move the completer to above the current line
        position = self.cursorRect(cur).topLeft() + self.viewport().pos()
        global_position = self.mapToGlobal(position)
        global_position -= QtCore.QPoint(0, geometry.height())

    self.__completer.popup().move(global_position)
</t>
<t tx="ekr.20190812072048.600">def setIndex(self, index):
    self._index = index
</t>
<t tx="ekr.20190812072048.601">def build(self):
    """ Build menu """
    icons = pyzo.icons

    # Copied (and edited) manually from the File memu
    self.addItem(translate("menu", "Save ::: Save the current file to disk."),
        icons.disk, self._fileAction, "saveFile")
    self.addItem(translate("menu", "Save as... ::: Save the current file under another name."),
        icons.disk_as, self._fileAction, "saveFileAs")
    self.addItem(translate("menu", "Close ::: Close the current file."),
        icons.page_delete, self._fileAction, "closeFile")
    self.addItem(translate("menu", "Close others::: Close all files but this one."),
        None, self._fileAction, "close_others")
    self.addItem(translate("menu", "Close all ::: Close all files."),
        icons.page_delete_all, self._fileAction, "close_all")
    self.addItem(translate("menu", "Rename ::: Rename this file."),
        None, self._fileAction, "rename")

    self.addSeparator()
    self.addItem(translate("menu", "Copy path ::: Copy the full path of this file."),
        None, self._fileAction, "copypath")
    self.addItem(translate("menu", "Open directory in file browser"),
        None, self._fileAction, "opendir")

    self.addSeparator()
    # todo: remove feature to pin files?
    self.addItem(translate("menu", "Pin/Unpin ::: Pinned files get closed less easily."),
        None, self._fileAction, "pin")
    self.addItem(translate("menu", "Set/Unset as MAIN file ::: The main file can be run while another file is selected."),
        icons.star, self._fileAction, "main")

    self.addSeparator()
    self.addItem(translate("menu", "Run file ::: Run the code in this file."),
        icons.run_file, self._fileAction, "run")
    self.addItem(translate("menu", "Run file as script ::: Run this file as a script (restarts the interpreter)."),
        icons.run_file_script, self._fileAction, "run_script")
</t>
<t tx="ekr.20190812072048.602">def _fileAction(self, action):
    """ Call the method specified by 'action' on the selected shell """

    item = pyzo.editors._tabs.getItemAt(self._index)

    if action in ["saveFile", "saveFileAs", "closeFile"]:
        getattr(pyzo.editors, action)(item.editor)
    elif action == "close_others" or action == "close_all":
        if action == "close_all":
            item = None #The item not to be closed is not there
        items = pyzo.editors._tabs.items()
        for i in reversed(range(pyzo.editors._tabs.count())):
            if items[i] is item or items[i].pinned:
                continue
            pyzo.editors._tabs.tabCloseRequested.emit(i)

    elif action == "rename":
        filename = item.filename
        pyzo.editors.saveFileAs(item.editor)
        if item.filename != filename:
            try:
                os.remove(filename)
            except Exception:
                pass
    elif action == 'copypath':
        filename = item.filename
        QtWidgets.qApp.clipboard().setText(filename)
    elif action == 'opendir':
        fileBrowser = pyzo.toolManager.getTool('pyzofilebrowser')
        if fileBrowser:
            fileBrowser.setPath(os.path.dirname(item.filename))
    elif action == "pin":
        item._pinned = not item._pinned
    elif action == "main":
        if pyzo.editors._tabs._mainFile == item.id:
            pyzo.editors._tabs._mainFile = None
        else:
            pyzo.editors._tabs._mainFile = item.id
    elif action == "run":
        menu = pyzo.main.menuBar().findChild(RunMenu)
        if menu:
            menu._runFile((False, False), item.editor)
    elif action == "run_script":
        menu = pyzo.main.menuBar().findChild(RunMenu)
        if menu:
            menu._runFile((True, False), item.editor)

    pyzo.editors._tabs.updateItems()
</t>
<t tx="ekr.20190812072048.603">class RunMenu(Menu):
    @others
</t>
<t tx="ekr.20190812072048.604">def build(self):
    icons = pyzo.icons

    self.addItem(translate("menu", 'Run file as script ::: Restart and run the current file as a script.'),  # noqa
        icons.run_file_script, self._runFile, (True, False))
    self.addItem(translate("menu", 'Run main file as script ::: Restart and run the main file as a script.'),  # noqa
        icons.run_mainfile_script, self._runFile, (True, True))

    self.addSeparator()

    self.addItem(translate("menu", 'Execute selection ::: Execute the current editor\'s selected lines, selected words on the current line, or current line if there is no selection.'),  # noqa
        icons.run_lines, self._runSelected)
    self.addItem(translate("menu", 'Execute cell ::: Execute the current editors\'s cell in the current shell.'),  # noqa
        icons.run_cell, self._runCell)

    #In the _runFile calls, the parameter specifies (asScript, mainFile)
    self.addItem(translate("menu", 'Execute file ::: Execute the current file in the current shell.'),
        icons.run_file, self._runFile,(False, False))
    self.addItem(translate("menu", 'Execute main file ::: Execute the main file in the current shell.'),
        icons.run_mainfile, self._runFile,(False, True))

    self.addSeparator()

    self.addItem(translate("menu", 'Execute selection and advance'),
        icons.run_lines, self._runSelectedAdvance)
    self.addItem(translate("menu", 'Execute cell and advance ::: Execute the current editors\'s cell and advance to the next cell.'),
        icons.run_cell, self._runCellAdvance)

    self.addSeparator()

    self.addCheckItem(translate("menu", 'Change directory when executing file ::: like Run File As Script does'),
                      None, self._cdonfileexec, None, pyzo.config.settings.changeDirOnFileExec)
    self.addItem(translate("menu", 'Help on running code ::: Open the pyzo wizard at the page about running code.'),
        icons.information, self._showHelp)
</t>
<t tx="ekr.20190812072048.605">def _cdonfileexec(self, value):
    pyzo.config.settings.changeDirOnFileExec = bool(value)
</t>
<t tx="ekr.20190812072048.606">def _showHelp(self):
    """ Show more information about ways to run code. """
    from pyzo.util.pyzowizard import PyzoWizard
    w = PyzoWizard(self)
    w.show('RuncodeWizardPage1') # Start wizard at page about running code
</t>
<t tx="ekr.20190812072048.607">def _getShellAndEditor(self, what, mainEditor=False):
    """ Get the shell and editor. Shows a warning dialog when one of
    these is not available.
    """
    # Init empty error message
    msg = ''
    # Get shell
    shell = pyzo.shells.getCurrentShell()
    if shell is None:
        msg += translate("menu", "No shell to run code in.").rstrip() + ' '
        #shell = pyzo.shells.addShell()  # issue #335, does not work, somehow
    # Get editor
    if mainEditor:
        editor = pyzo.editors.getMainEditor()
        if editor is None:
            msg += translate("menu", "There is no main file selected.")
    else:
        editor = pyzo.editors.getCurrentEditor()
        if editor is None:
            msg += translate("menu", "No editor selected.")
    # Show error dialog
    if msg:
        m = QtWidgets.QMessageBox(self)
        m.setWindowTitle(translate("menu dialog", "Could not run"))
        m.setText(translate("menu", "Could not run " + what + ":\n\n" + msg))
        m.setIcon(m.Warning)
        m.exec_()
    # Return
    return shell, editor
</t>
<t tx="ekr.20190812072048.608">def _advance(self, runCursor):
    # Get editor and shell
    shell, editor = self._getShellAndEditor('selection')
    if not shell or not editor:
        return

    cursor = editor.textCursor()
    cursor.setPosition(runCursor.position())
    cursor.movePosition(cursor.NextBlock)
    editor.setTextCursor(cursor)
</t>
<t tx="ekr.20190812072048.609">def _runSelectedAdvance(self):
    self._runSelected(advance=True)
</t>
<t tx="ekr.20190812072048.61"></t>
<t tx="ekr.20190812072048.610">def _runSelected(self, advance=False):
    """ Run the selected whole lines in the current shell.
    """
    # Get editor and shell
    shell, editor = self._getShellAndEditor('selection')
    if not shell or not editor:
        return

    # Get position to sample between (only sample whole lines)
    screenCursor = editor.textCursor() #Current selection in the editor
    runCursor = editor.textCursor() #The part that should be run

    runCursor.setPosition(screenCursor.selectionStart())
    runCursor.movePosition(runCursor.StartOfBlock) #This also moves the anchor
    lineNumber1 = runCursor.blockNumber()

    runCursor.setPosition(screenCursor.selectionEnd(),runCursor.KeepAnchor)
    if not (screenCursor.hasSelection() and runCursor.atBlockStart()):
        #If the end of the selection is at the beginning of a block, don't extend it
        runCursor.movePosition(runCursor.EndOfBlock,runCursor.KeepAnchor)
    lineNumber2 = runCursor.blockNumber()

    # Does this look like a statement?
    isStatement = lineNumber1 == lineNumber2 and screenCursor.hasSelection()

    if isStatement:
        # Get source code of statement
        code = screenCursor.selectedText().replace('\u2029', '\n').strip()
        # add code to history
        pyzo.command_history.append(code)
        # Execute statement
        shell.executeCommand(code+'\n')
    else:
        # Get source code
        code = runCursor.selectedText().replace('\u2029', '\n')
        # Notify user of what we execute
        self._showWhatToExecute(editor, runCursor)
        # Get filename and run code
        fname = editor.id() # editor._name or editor._filename
        shell.executeCode(code, fname, lineNumber1)

    if advance:
        self._advance(runCursor)
</t>
<t tx="ekr.20190812072048.611">def _runCellAdvance(self):
    self._runCell(advance=True)
</t>
<t tx="ekr.20190812072048.612">def _runCell(self, advance=False):
    """ Run the code between two cell separaters ('##').
    """
    #TODO: ignore ## in multi-line strings
    # Maybe using source-structure information?

    # Get editor and shell
    shell, editor = self._getShellAndEditor('cell')
    if not shell or not editor:
        return

    cellName = ''

    # Get current cell
    # Move up until the start of document
    # or right after a line starting with '##'
    runCursor = editor.textCursor() #The part that should be run
    runCursor.movePosition(runCursor.StartOfBlock)
    while True:
        line = runCursor.block().text().lstrip()
        if line.startswith('##') or line.startswith('#%%') or line.startswith('# %%'):
            # ## line, move to the line following this one
            if not runCursor.block().next().isValid():
                #The user tried to execute the last line of a file which
                #started with ##. Do nothing
                return
            runCursor.movePosition(runCursor.NextBlock)
            cellName = line.lstrip('#% ').strip()
            break
        if not runCursor.block().previous().isValid():
            break #Start of document
        runCursor.movePosition(runCursor.PreviousBlock)

    # This is the line number of the start
    lineNumber = runCursor.blockNumber()
    if len(cellName) &gt; 20:
        cellName = cellName[:17]+'...'

    # Move down until a line before one starting with'##'
    # or to end of document
    while True:
        line = runCursor.block().text().lstrip()
        if line.startswith('##') or line.startswith('#%%') or line.startswith('# %%'):
            #This line starts with ##, move to the end of the previous one
            runCursor.movePosition(runCursor.Left,runCursor.KeepAnchor)
            break
        if not runCursor.block().next().isValid():
            #Last block of the document, move to the end of the line
            runCursor.movePosition(runCursor.EndOfBlock,runCursor.KeepAnchor)
            break
        runCursor.movePosition(runCursor.NextBlock,runCursor.KeepAnchor)

    # Get source code
    code = runCursor.selectedText().replace('\u2029', '\n')
    # Notify user of what we execute
    self._showWhatToExecute(editor, runCursor)
    # Get filename and run code
    fname = editor.id() # editor._name or editor._filename
    shell.executeCode(code, fname, lineNumber, cellName)

    if advance:
        self._advance(runCursor)
</t>
<t tx="ekr.20190812072048.613">def _showWhatToExecute(self, editor, runCursor=None):
    # Get runCursor for whole document if not given
    if runCursor is None:
        runCursor = editor.textCursor()
        runCursor.movePosition(runCursor.Start)
        runCursor.movePosition(runCursor.End, runCursor.KeepAnchor)

    editor.showRunCursor(runCursor)
</t>
<t tx="ekr.20190812072048.614">def _getCodeOfFile(self, editor):
    # Obtain source code
    text = editor.toPlainText()
    # Show what we execute
    self._showWhatToExecute(editor)
    # Get filename and return
    fname = editor.id() # editor._name or editor._filename
    return fname, text
</t>
<t tx="ekr.20190812072048.615">def _runFile(self, runMode, givenEditor=None):
    """ Run a file
     runMode is a tuple (asScript, mainFile)
     """
    asScript, mainFile = runMode

    # Get editor and shell
    description = 'main file' if mainFile else 'file'
    if asScript:
        description += translate('menu', ' (as script)')

    shell, editor = self._getShellAndEditor(description, mainFile)
    if givenEditor:
        editor = givenEditor
    if not shell or not editor:
        return

    if asScript:
        # Go
        self._runScript(editor, shell)
    else:
        # Obtain source code and fname
        fname, text = self._getCodeOfFile(editor)
        shell.executeCode(text, fname, changeDir=pyzo.config.settings.changeDirOnFileExec)
</t>
<t tx="ekr.20190812072048.616">def _runScript(self, editor, shell):
    # Obtain fname and try running
    err = ""
    if editor._filename:
        saveOk = pyzo.editors.saveFile(editor) # Always try to save
        if saveOk or not editor.document().isModified():
            self._showWhatToExecute(editor)
            if shell._startup_info.get('ipython', '') == 'yes':
                # If we have a ipython shell we use %run -i instead
                # This works better when python autoreload is used
                d = os.path.normpath(os.path.normcase(os.path.dirname(editor._filename)))
                shell._ctrl_command.send('%%cd "%s"\n' % d)
                shell._ctrl_command.send('%%run -i "%s"\n' % editor._filename)
            else:
                shell.restart(editor._filename)
        else:
            err = translate("menu", "Could not save the file.")
    else:
        err = translate("menu", "Can only run scripts that are in the file system.")
    # If not success, notify
    if err:
        m = QtWidgets.QMessageBox(self)
        m.setWindowTitle(translate("menu dialog", "Could not run script."))
        m.setText(err)
        m.setIcon(m.Warning)
        m.exec_()
</t>
<t tx="ekr.20190812072048.617">class ToolsMenu(Menu):

    @others
</t>
<t tx="ekr.20190812072048.618">def __init__(self, *args, **kwds):
    self._toolActions = []
    Menu.__init__(self, *args, **kwds)
</t>
<t tx="ekr.20190812072048.619">def build(self):
    self.addItem(translate("menu", 'Reload tools ::: For people who develop tools.'),
        pyzo.icons.plugin_refresh, pyzo.toolManager.reloadTools)
    self.addSeparator()

    self.onToolInstanceChange() # Build initial menu
    pyzo.toolManager.toolInstanceChange.connect(self.onToolInstanceChange)
</t>
<t tx="ekr.20190812072048.62">@path pyzo/codeeditor/parsers/
# -*- coding: utf-8 -*-

# Import tokens in module namespace
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.620">def onToolInstanceChange(self):
    # Remove all exisiting tools from the menu
    for toolAction in self._toolActions:
        self.removeAction(toolAction)

    # Add all tools, with checkmarks for those that are active
    self._toolActions = []
    for tool in pyzo.toolManager.getToolInfo():
        action = self.addCheckItem(tool.name, pyzo.icons.plugin,
            tool.menuLauncher, selected=bool(tool.instance))
        self._toolActions.append(action)
</t>
<t tx="ekr.20190812072048.621">class HelpMenu(Menu):

    @others
</t>
<t tx="ekr.20190812072048.622">def build(self):
    icons = pyzo.icons

    self.addUrlItem(translate("menu", "Pyzo website ::: Open the Pyzo website in your browser."),
        icons.help, "http://pyzo.org")
    self.addUrlItem(translate("menu", "Pyzo guide ::: Open the Pyzo guide in your browser."),
        icons.help, "http://guide.pyzo.org")
    self.addItem(translate("menu", "Pyzo wizard ::: Get started quickly."),
        icons.wand, self._showPyzoWizard)

    self.addSeparator()

    self.addUrlItem(translate("menu", "Ask a question ::: Need help?"),
        icons.comments, "http://community.pyzo.org")
    self.addUrlItem(translate("menu", "Report an issue ::: Did you found a bug in Pyzo, or do you have a feature request?"),
        icons.error_add, "http://issues.pyzo.org")
    self.addItem(translate("menu", "Local documentation ::: Documentation on Python and the Scipy Stack."),
        icons.help, self._showPyzoDocs)
    self.addSeparator()
    #self.addItem(translate("menu", "View code license ::: Legal stuff."),
    #    icons.script, lambda: pyzo.editors.loadFile(os.path.join(pyzo.pyzoDir,"license.txt")))

    self.addItem(translate("menu", "Check for updates ::: Are you using the latest version?"),
       icons.application_go, self._checkUpdates)

    self.addItem(translate("menu", "About Pyzo ::: More information about Pyzo."),
        icons.information, self._aboutPyzo)
</t>
<t tx="ekr.20190812072048.623">def addUrlItem(self, name, icon, url):
    self.addItem(name, icon, lambda: webbrowser.open(url))
</t>
<t tx="ekr.20190812072048.624">def _showPyzoWizard(self):
    from pyzo.util.pyzowizard import PyzoWizard
    w = PyzoWizard(self)
    w.show() # Use show() instead of exec_() so the user can interact with pyzo
</t>
<t tx="ekr.20190812072048.625">def _checkUpdates(self):
    """ Check whether a newer version of pyzo is available. """
    # Get versions available
    url = 'https://api.github.com/repos/pyzo/pyzo/releases'
    releases = json.loads(urlopen(url).read())
    versions = []
    for release in releases:
        tag = release.get('tag_name', '')
        if tag.startswith('v'):
            version = tuple(int(i) for i in tag[1:].split('.'))
            versions.append(version)
    versions.sort()
    latest_version = '.'.join(str(i) for i in versions[-1]) if versions else '?'
    # Define message
    text = "Your version of Pyzo is: {}\n"
    text += "Latest available version is: {}\n\n"
    text = text.format(pyzo.__version__, latest_version)
    text += "Do you want to open the download page?\n"
    # Show message box
    m = QtWidgets.QMessageBox(self)
    m.setWindowTitle(translate("menu dialog", "Check for the latest version."))
    m.setStandardButtons(m.Yes | m.Cancel)
    m.setDefaultButton(m.Cancel)
    m.setText(text)
    m.setIcon(m.Information)
    result = m.exec_()
    # Goto webpage if user chose to
    if result == m.Yes:
        webbrowser.open("http://pyzo.org/start.html")
</t>
<t tx="ekr.20190812072048.626">def _aboutPyzo(self):
    from pyzo.core.about import AboutDialog
    m = AboutDialog(self)
    m.exec_()
</t>
<t tx="ekr.20190812072048.627">def _showPyzoDocs(self):
    # Show widget with docs:
    self._assistant = PyzoAssistant()
    self._assistant.show()
</t>
<t tx="ekr.20190812072048.628">class AutocompMenu(Menu):
    """
    Menu for the user to control autocompletion.
    """

    @others
</t>
<t tx="ekr.20190812072048.629">def build(self):

    # Part for selecting mode
    modes = [translate('menu', 'No autocompletion'),
             translate('menu', 'Automatic popup'),
             translate('menu', 'Only show popup when pressing Tab')]
    for value, mode in enumerate(modes):
        self.addGroupItem(mode, None, self._setMode, value, group='mode')
    self.setCheckedOption('mode', pyzo.config.settings.autoComplete)

    self.addSeparator()

    # Part for accept key
    accept_keys = [translate('menu', 'Tab'),
                  translate('menu', 'Enter'),
                  translate('menu', 'Tab, Enter'),
                  translate('menu', 'Tab, (, ['),
                  translate('menu', 'Tab, Enter, (, [')]
    prefix = translate("menu", "Accept autocompletion with:")
    for keys in accept_keys:
        self.addGroupItem(prefix + ' ' + keys, None, self._setAcceptKeys, keys, group="acceptkeys")
    self.setCheckedOption('acceptkeys', pyzo.config.settings.autoComplete_acceptKeys)

    self.addSeparator()

    # Booleans
    self.addCheckItem(translate("menu", 'Autocomplete keywords ::: The autocompletion list includes keywords.'),
                      None, self._setCompleteKeywords, None, pyzo.config.settings.autoComplete_keywords)

    self.addSeparator()

    # auto closing options
    self.addCheckItem(translate("menu", 'Auto close quotes ::: Auto close single and double quotes.'),
                      None, self._setQuotes, None, pyzo.config.settings.autoClose_Quotes)

    self.addCheckItem(translate("menu", 'Auto close brackets ::: Auto close ( { [ ] } ).'),
                      None, self._setBrackets, None, pyzo.config.settings.autoClose_Brackets)
</t>
<t tx="ekr.20190812072048.63">from .python_parser import PythonParser, pythonKeywords

# Set keywords
cythonExtraKeywords = set([
    'cdef', 'cpdef', 'ctypedef', 'cimport',
    'float', 'double', 'int', 'long',
])
</t>
<t tx="ekr.20190812072048.630">def _setAcceptKeys(self, autocompkeys):
    # Skip if setting is not changes
    if pyzo.config.settings.autoComplete_acceptKeys == autocompkeys:
        return
    # Save new setting
    pyzo.config.settings.autoComplete_acceptKeys = autocompkeys
    # Apply
    for e in pyzo.editors:
        e.setAutoCompletionAcceptKeysFromStr(autocompkeys)
    for s in pyzo.shells:
        s.setAutoCompletionAcceptKeysFromStr(autocompkeys)
</t>
<t tx="ekr.20190812072048.631">def _setMode(self, autocompmode):
    pyzo.config.settings.autoComplete = int(autocompmode)
</t>
<t tx="ekr.20190812072048.632">def _setCompleteKeywords(self, value):
    pyzo.config.settings.autoComplete_keywords = bool(value)
</t>
<t tx="ekr.20190812072048.633">def _setQuotes(self, value):
    # Set automatic insertion of single and double quotes
    pyzo.config.settings.autoClose_Quotes = bool(value)
</t>
<t tx="ekr.20190812072048.634">def _setBrackets(self, value):
    # Set automatic insertion of parenthesis, braces and brackets
    pyzo.config.settings.autoClose_Brackets = bool(value)
</t>
<t tx="ekr.20190812072048.635">class SettingsMenu(Menu):
    @others
</t>
<t tx="ekr.20190812072048.636">def build(self):
    icons = pyzo.icons

    # Create language menu
    from pyzo.util._locale import LANGUAGES, LANGUAGE_SYNONYMS
    # Update language setting if necessary
    cur = pyzo.config.settings.language
    pyzo.config.settings.language = LANGUAGE_SYNONYMS.get(cur, cur)

    # Create language menu
    t = translate("menu", "Select language ::: The language used by Pyzo.")
    self._languageMenu = GeneralOptionsMenu(self, t, self._selectLanguage)
    values = [key for key in sorted(LANGUAGES)]
    self._languageMenu.setOptions(values, values)
    self._languageMenu.setCheckedOption(None, pyzo.config.settings.language)

    self.addBoolSetting(translate("menu", 'Automatically indent ::: Indent when pressing enter after a colon.'),
        'autoIndent', lambda state, key: [e.setAutoIndent(state) for e in pyzo.editors])
    self.addBoolSetting(translate("menu", 'Enable calltips ::: Show calltips with function signatures.'),
        'autoCallTip')

    self.addMenu(AutocompMenu(self, translate("menu", 'Autocompletion')))

    self.addSeparator()
    self.addItem(translate("menu", 'Edit key mappings... ::: Edit the shortcuts for menu items.'),
        icons.keyboard, lambda: KeymappingDialog().exec_())
    self.addItem(translate("menu", 'Edit syntax styles... ::: Change the coloring of your code.'),
        icons.style, self._editStyles)
    self.addMenu(self._languageMenu, icons.flag_green)
    self.addItem(translate("menu", 'Advanced settings... ::: Configure Pyzo even further.'),
        icons.cog, self._advancedSettings)
</t>
<t tx="ekr.20190812072048.637">def _editStyles(self):
    """ Edit the style file. """
    text = """
    Chosing or editing the syntax style is currently not available.
    We selected a style which we like a lot. It's based on the
    solarized theme (http://ethanschoonover.com/solarized) isn't it pretty?
    \r\r
    In case you really want to change the style, you can change the
    source code at:\r
    {}
    """.format(os.path.join(pyzo.pyzoDir, 'codeeditor', 'base.py'))
    m = QtWidgets.QMessageBox(self)
    m.setWindowTitle(translate("menu dialog", "Edit syntax styling"))
    m.setText(unwrapText(text))
    m.setIcon(m.Information)
    m.setStandardButtons(m.Ok | m.Cancel)
    m.setDefaultButton(m.Ok)
    m.exec_()
</t>
<t tx="ekr.20190812072048.638">def _advancedSettings(self):
    """ How to edit the advanced settings. """
    text = translate("menu", """
    More settings are available via the logger-tool:
    \r\r
    - Advanced settings are stored in the struct "pyzo.config.advanced".
      Type "print(pyzo.config.advanced)" to view all advanced settings.\r
    - Call "pyzo.resetConfig()" to reset all settings.\r
    - Call "pyzo.resetConfig(True)" to reset all settings and state.\r
    \r\r
    Note that most settings require a restart for the change to
    take effect.
    """)
    m = QtWidgets.QMessageBox(self)
    m.setWindowTitle(translate("menu dialog", "Advanced settings"))
    m.setText(unwrapText(text))
    m.setIcon(m.Information)
    m.exec_()
</t>
<t tx="ekr.20190812072048.639">def addBoolSetting(self, name, key, callback = None):
    def _callback(state, key):
        setattr(pyzo.config.settings, key, state)
        if callback is not None:
            callback(state, key)

    self.addCheckItem(name, None, _callback, key,
        getattr(pyzo.config.settings,key)) #Default value
</t>
<t tx="ekr.20190812072048.64">class CythonParser(PythonParser):
    """ Parser for Cython/Pyrex.
    """
    _extensions = ['pyi', '.pyx' , '.pxd']

    _keywords = pythonKeywords | cythonExtraKeywords

    @others
</t>
<t tx="ekr.20190812072048.640">def _selectLanguage(self, languageName):
    # Skip if the same
    if pyzo.config.settings.language == languageName:
        return
    # Save new language
    pyzo.config.settings.language = languageName
    # Notify user
    text = translate('menu dialog', """
    The language has been changed.
    Pyzo needs to restart for the change to take effect.
    """)
    m = QtWidgets.QMessageBox(self)
    m.setWindowTitle(translate("menu dialog", "Language changed"))
    m.setText(unwrapText(text))
    m.setIcon(m.Information)
    m.exec_()
## Classes to enable editing the key mappings
</t>
<t tx="ekr.20190812072048.641">class KeyMapModel(QtCore.QAbstractItemModel):
    """ The model to view the structure of the menu and the shortcuts
    currently mapped. """

    @others
k = QtCore.Qt
keymap = {k.Key_Enter:'Enter', k.Key_Return:'Return', k.Key_Escape:'Escape',
    k.Key_Tab:'Tab', k.Key_Backspace:'Backspace', k.Key_Pause:'Pause',
    k.Key_Backtab: 'Tab', #Backtab is actually shift+tab
    k.Key_F1:'F1', k.Key_F2:'F2', k.Key_F3:'F3', k.Key_F4:'F4', k.Key_F5:'F5',
    k.Key_F6:'F6', k.Key_F7:'F7', k.Key_F8:'F8', k.Key_F9:'F9',
    k.Key_F10:'F10', k.Key_F11:'F11', k.Key_F12:'F12', k.Key_Space:'Space',
    k.Key_Delete:'Delete', k.Key_Insert:'Insert', k.Key_Home:'Home',
    k.Key_End:'End', k.Key_PageUp:'PageUp', k.Key_PageDown:'PageDown',
    k.Key_Left:'Left', k.Key_Up:'Up', k.Key_Right:'Right', k.Key_Down:'Down' }
</t>
<t tx="ekr.20190812072048.642">def __init__(self, *args):
    QtCore.QAbstractItemModel.__init__(self, *args)
    self._root = None
</t>
<t tx="ekr.20190812072048.643">def setRootMenu(self, menu):
    """ Call this after starting. """
    self._root = menu
</t>
<t tx="ekr.20190812072048.644">def data(self, index, role):
    if not index.isValid() or role not in [0, 8]:
        return None

    # get menu or action item
    item = index.internalPointer()

    # get text and shortcuts
    key1, key2 = '', ''
    if isinstance(item, QtWidgets.QMenu):
        value = item.title()
    else:
        value = item.text()
        if not value:
            value = '-'*10
        elif index.column()&gt;0:
            key1, key2 = ' ', ' '
            shortcuts = getShortcut(item)
            if shortcuts[0]:
                key1 = shortcuts[0]
            if shortcuts[1]:
                key2 = shortcuts[1]
    # translate to text for the user
    key1 = translateShortcutToOSNames(key1)
    key2 = translateShortcutToOSNames(key2)

    # obtain value
    value = [value,key1,key2, ''][index.column()]

    # return
    if role == 0:
        # display role
        return value
    elif role == 8:
        # 8: BackgroundRole
        if not value:
            return None
        elif index.column() == 1:
            return QtGui.QBrush(QtGui.QColor(200,220,240))
        elif index.column() == 2:
            return QtGui.QBrush(QtGui.QColor(210,230,250))
        else:
            return None
    else:
        return None
</t>
<t tx="ekr.20190812072048.645">def rowCount(self, parent):
    if parent.isValid():
        menu = parent.internalPointer()
        return len(menu.actions())
    else:
        return len(self._root.actions())
</t>
<t tx="ekr.20190812072048.646">def columnCount(self, parent):
    return 4
</t>
<t tx="ekr.20190812072048.647">def headerData(self, section, orientation, role):
    if role == 0:# and orientation==1:
        tmp = ['Menu action','Shortcut 1','Shortcut 2', '']
        return tmp[section]
</t>
<t tx="ekr.20190812072048.648">def parent(self, index):
    if not index.isValid():
        return QtCore.QModelIndex()
    item = index.internalPointer()
    pitem = item.parent()
    if pitem is self._root:
        return QtCore.QModelIndex()
    else:
        L = pitem.parent().actions()
        row = 0
        if pitem in L:
            row = L.index(pitem)
        return self.createIndex(row, 0, pitem)
</t>
<t tx="ekr.20190812072048.649">def hasChildren(self, index):
    # no items have parents (except the root item)

    if index.row()&lt;0:
        return True
    else:
        return isinstance(index.internalPointer(), QtWidgets.QMenu)
</t>
<t tx="ekr.20190812072048.65">def _identifierState(self, identifier=None):
    """ Given an identifier returs the identifier state:
    3 means the current identifier can be a function.
    4 means the current identifier can be a class.
    0 otherwise.

    This method enables storing the state during the line,
    and helps the Cython parser to reuse the Python parser's code.

    This implementation keeps a counter. If the counter is 0, the
    state is zero.
    """
    if identifier is None:
        # Explicit get and reset
        state = 0
        try:
            if self._idsCounter&gt;0:
                state = self._idsState
        except Exception:
            pass
        self._idsState = 0
        self._idsCounter = 0
        return state
    elif identifier in ['def', 'cdef', 'cpdef']:
        # Set function state
        self._idsState = 3
        self._idsCounter = 2
        return 3
    elif identifier == 'class':
        # Set class state
        self._idsState = 4
        self._idsCounter = 1
        return 4
    elif self._idsCounter&gt;0:
        self._idsCounter -= 1
        return self._idsState
    else:
        # This one can be func or class, next one can't
        return 0
</t>
<t tx="ekr.20190812072048.650">def index(self, row, column, parent):
    # if not self.hasIndex(row, column, parent):
    #     return QtCore.QModelIndex()
    # establish parent
    if not parent.isValid():
        parentMenu = self._root
    else:
        parentMenu = parent.internalPointer()
    # produce index and make menu if the action represents a menu
    childAction = parentMenu.actions()[row]
    if childAction.menu():
        childAction = childAction.menu()
    return self.createIndex(row, column, childAction)
    # This is the trick. The internal pointer is the way to establish
    # correspondence between ModelIndex and underlying data.

# Key to string mappings
</t>
<t tx="ekr.20190812072048.651">class KeyMapLineEdit(QtWidgets.QLineEdit):
    """ A modified version of a lineEdit object that catches the key event
    and displays "Ctrl" when control was pressed, and similarly for alt and
    shift, function keys and other keys.
    """

    textUpdate = QtCore.Signal()

    @others
</t>
<t tx="ekr.20190812072048.652">def __init__(self, *args, **kwargs):
    QtWidgets.QLineEdit.__init__(self, *args, **kwargs)
    self.clear()

    # keep a list of native keys, so that we can capture for example
    # "shift+]". If we would use text(), we can only capture "shift+}"
    # which is not a valid shortcut.
    self._nativeKeys = {}

# Override setText, text and clear, so as to be able to set shortcuts like
# Ctrl+A, while the actually displayed value is an OS shortcut (e.g. on Mac
# Cmd-symbol + A)
</t>
<t tx="ekr.20190812072048.653">def setText(self, text):
    QtWidgets.QLineEdit.setText(self, translateShortcutToOSNames(text))
    self._shortcut = text
</t>
<t tx="ekr.20190812072048.654">def text(self):
    return self._shortcut
</t>
<t tx="ekr.20190812072048.655">def clear(self):
    QtWidgets.QLineEdit.setText(self, '&lt;enter key combination here&gt;')
    self._shortcut = ''
</t>
<t tx="ekr.20190812072048.656">def focusInEvent(self, event):
    #self.clear()
    QtWidgets.QLineEdit.focusInEvent(self, event)
</t>
<t tx="ekr.20190812072048.657">def event(self,event):
    # Override event handler to enable catching the Tab key
    # If the event is a KeyPress or KeyRelease, handle it with
    # self.keyPressEvent or keyReleaseEvent
    if event.type()==event.KeyPress:
        self.keyPressEvent(event)
        return True #Mark as handled
    if event.type()==event.KeyRelease:
        self.keyReleaseEvent(event)
        return True #Mark as handled
    #Default: handle events as usual
    return QtWidgets.QLineEdit.event(self,event)
</t>
<t tx="ekr.20190812072048.658">def keyPressEvent(self, event):
    # get key codes
    key = event.key()
    nativekey = event.nativeVirtualKey()

    # try to get text
    if nativekey &lt; 128 and sys.platform != 'darwin':
        text = chr(nativekey).upper()
    elif key&lt;128:
        text = chr(key).upper()
    else:
        text = ''

    # do we know this specic key or this native key?
    if key in keymap:
        text = keymap[key]
    elif nativekey in self._nativeKeys:
        text = self._nativeKeys[nativekey]

    # apply!
    if text:
        storeNativeKey, text0 = True, text
        if QtWidgets.qApp.keyboardModifiers() &amp; k.AltModifier:
            text  = 'Alt+' + text
        if QtWidgets.qApp.keyboardModifiers() &amp; k.ShiftModifier:
            text  = 'Shift+' + text
            storeNativeKey = False
        if QtWidgets.qApp.keyboardModifiers() &amp; k.ControlModifier:
            text  = 'Ctrl+' + text
        if QtWidgets.qApp.keyboardModifiers() &amp; k.MetaModifier:
            text  = 'Meta+' + text
        self.setText(text)
        if storeNativeKey and nativekey:
            # store native key if shift was not pressed.
            self._nativeKeys[nativekey] = text0

    # notify listeners
    self.textUpdate.emit()
</t>
<t tx="ekr.20190812072048.659">class KeyMapEditDialog(QtWidgets.QDialog):
    """ The prompt that is shown when double clicking
    a keymap in the tree.
    It notifies the user when the entered shortcut is already used
    elsewhere and applies the shortcut (removing it elsewhere if
    required) when the apply button is pressed.
    """

    @others
</t>
<t tx="ekr.20190812072048.66">@path pyzo/codeeditor/parsers/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.660">def __init__(self, *args):
    QtWidgets.QDialog.__init__(self, *args)

    # set title
    self.setWindowTitle(translate("menu dialog", 'Edit shortcut mapping'))

    # set size
    size = 400,140
    offset = 5
    size2 = size[0], size[1]+offset
    self.resize(*size2)
    self.setMaximumSize(*size2)
    self.setMinimumSize(*size2)

    self._label = QtWidgets.QLabel("", self)
    self._label.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)
    self._label.resize(size[0]-20, 100)
    self._label.move(10,2)

    self._line = KeyMapLineEdit('', self)
    self._line.resize(size[0]-80, 20)
    self._line.move(10,90)

    self._clear = QtWidgets.QPushButton("Clear", self)
    self._clear.resize(50, 20)
    self._clear.move(size[0]-60,90)

    self._apply = QtWidgets.QPushButton("Apply", self)
    self._apply.resize(50, 20)
    self._apply.move(size[0]-120,120)

    self._cancel = QtWidgets.QPushButton("Cancel", self)
    self._cancel.resize(50, 20)
    self._cancel.move(size[0]-60,120)

    # callbacks
    self._line.textUpdate.connect(self.onEdit)
    self._clear.clicked.connect(self.onClear)
    self._apply.clicked.connect(self.onAccept)
    self._cancel.clicked.connect(self.close)

    # stuff to fill in later
    self._fullname = ''
    self._intro = ''
    self._isprimary = True
</t>
<t tx="ekr.20190812072048.661">def setFullName(self, fullname, isprimary):
    """ To be called right after initialization to let the user
    know what he's updating, and show the current shortcut for that
    in the line edit. """

    # store
    self._isprimary = isprimary
    self._fullname = fullname
    # create intro to show, and store + show it
    tmp = fullname.replace('__',' -&gt; ').replace('_', ' ')
    primSec = ['secondary', 'primary'][int(isprimary)]
    self._intro = "Set the {} shortcut for:\n{}".format(primSec,tmp)
    self._label.setText(self._intro)
    # set initial value
    if fullname in pyzo.config.shortcuts2:
        current = pyzo.config.shortcuts2[fullname]
        if ',' not in current:
            current += ','
        current = current.split(',')
        self._line.setText( current[0] if isprimary else current[1] )
</t>
<t tx="ekr.20190812072048.662">def onClear(self):
    self._line.clear()
    self._line.setFocus()
</t>
<t tx="ekr.20190812072048.663">def onEdit(self):
    """ Test if already in use. """

    # init
    shortcut = self._line.text()
    if not shortcut:
        self._label.setText(self._intro)
        return

    for key in pyzo.config.shortcuts2:
        # get shortcut and test whether it corresponds with what's pressed
        shortcuts = getShortcut(key)
        primSec = ''
        if shortcuts[0].lower() == shortcut.lower():
            primSec = 'primary'
        elif shortcuts[1].lower() == shortcut.lower():
            primSec = 'secondary'
        # if a correspondence, let the user know
        if primSec and key != self._fullname:
            tmp = "Warning: shortcut already in use for:\n"
            tmp += key.replace('__',' -&gt; ').replace('_', ' ')
            self._label.setText(self._intro + '\n\n' + tmp + '\n')
            break
    else:
        self._label.setText(self._intro)
</t>
<t tx="ekr.20190812072048.664">def onAccept(self):
    shortcut = self._line.text()

    # remove shortcut if present elsewhere
    keys = [key for key in pyzo.config.shortcuts2] # copy
    for key in keys:
        # get shortcut, test whether it corresponds with what's pressed
        shortcuts = getShortcut(key)
        tmp = list(shortcuts)
        needUpdate = False
        if shortcuts[0].lower() == shortcut.lower():
            tmp[0] = ''
            needUpdate = True
        if shortcuts[1].lower() == shortcut.lower():
            tmp[1] = ''
            needUpdate = True
        if needUpdate:
            tmp = ','.join(tmp)
            tmp = tmp.replace(' ','')
            if len(tmp)==1:
                del pyzo.config.shortcuts2[key]
            else:
                pyzo.config.shortcuts2[key] = tmp

    # insert shortcut
    if self._fullname:
        # get current and make list of size two
        if self._fullname in pyzo.config.shortcuts2:
            current = list(getShortcut(self._fullname))
        else:
            current = ['', '']
        # update the list
        current[int(not self._isprimary)] = shortcut
        pyzo.config.shortcuts2[self._fullname] = ','.join(current)

    # close
    self.close()
</t>
<t tx="ekr.20190812072048.665">class KeymappingDialog(QtWidgets.QDialog):
    """ The main keymap dialog, it has tabs corresponding with the
    different menus and each tab has a tree representing the structure
    of these menus. The current shortcuts are displayed.
    On double clicking on an item, the shortcut can be edited. """

    @others
</t>
<t tx="ekr.20190812072048.666">def __init__(self, *args):
    QtWidgets.QDialog.__init__(self, *args)

    # set title
    self.setWindowTitle(translate("menu dialog", 'Shortcut mappings'))

    # set size
    size = 600,400
    offset = 0
    size2 = size[0], size[1]+offset
    self.resize(*size2)
    self.setMaximumSize(*size2)
    self.setMinimumSize(*   size2)

    self.tab = CompactTabWidget(self, padding=(4,4,6,6))
    self.tab.resize(*size)
    self.tab.move(0,offset)
    self.tab.setMovable(False)

    # fill tab
    self._models = []
    self._trees = []
    for menu in pyzo.main.menuBar()._menus:
        # create treeview and model
        model = KeyMapModel()
        model.setRootMenu(menu)
        tree = QtWidgets.QTreeView(self.tab)
        tree.setModel(model)
        # configure treeview
        tree.clicked.connect(self.onClickSelect)
        tree.doubleClicked.connect(self.onDoubleClick)
        tree.setColumnWidth(0,150)
        # append to lists
        self._models.append(model)
        self._trees.append(tree)
        self.tab.addTab(tree, menu.title())

    self.tab.currentChanged.connect(self.onTabSelect)
</t>
<t tx="ekr.20190812072048.667">def closeEvent(self, event):
    # update key setting
    pyzo.keyMapper.keyMappingChanged.emit()

    event.accept()
</t>
<t tx="ekr.20190812072048.668">def onTabSelect(self):
    pass
</t>
<t tx="ekr.20190812072048.669">def onClickSelect(self, index):
    # should we show a prompt?
    if index.column():
        self.popupItem(index.internalPointer(), index.column())
</t>
<t tx="ekr.20190812072048.67"># -*- coding: utf-8 -*-
import re
from . import Parser, BlockState, text_type
from .tokens import ALPHANUM

from .tokens import (Token, CommentToken, StringToken,
    UnterminatedStringToken, IdentifierToken, NonIdentifierToken, KeywordToken,
    NumberToken)

# todo: compiler directives (or how do you call these things starting with #)
</t>
<t tx="ekr.20190812072048.670">def onDoubleClick(self, index):
    if not index.column():
        self.popupItem(index.internalPointer())
</t>
<t tx="ekr.20190812072048.671">def popupItem(self, item, shortCutId=1):
    """ Popup the dialog to change the shortcut. """
    if isinstance(item, QtWidgets.QAction) and item.text():
        # create prompt dialog
        dlg = KeyMapEditDialog(self)
        dlg.setFullName( item.menuPath, shortCutId==1 )
        # show it
        dlg.exec_()
</t>
<t tx="ekr.20190812072048.68">class MultilineCommentToken(CommentToken):
    """ Characters representing a multi-line comment. """
    defaultStyle = 'fore:#007F00'
</t>
<t tx="ekr.20190812072048.69">class CharToken(Token):
    """ Single-quoted char """
    defaultStyle = 'fore:#7F007F'

# This regexp is used to find special stuff, such as comments, numbers and
# strings.
tokenProg = re.compile(
    '([' + ALPHANUM + '_]+)|' +	# Identifiers/numbers (group 1) or
    '(\/\/)|' +                   # Single line comment (group 2)
    '(\/\*)|' +                   # Comment (group 3) or
    '(\'\\\\?.\')|' +  # char (group 4)
    '(\")'                 # string (group 5)
    )

#For a string, get the RegExp
#program that matches the end. (^|[^\\]) means: start of the line
#or something that is not \ (since \ is supposed to escape the following
#quote) (\\\\)* means: any number of two slashes \\ since each slash will
#escape the next one
stringEndProg = re.compile(r'(^|[^\\])(\\\\)*"')
commentEndProg = re.compile(r'\*/')
</t>
<t tx="ekr.20190812072048.7">def __updateAutocompleterPrefix(self):
    """
    Find the autocompletion prefix (the part of the word that has been
    entered) and send it to the completer. Update the selected completion
    (out of several possiblilties) which is best suited
    """
    if not self.autocompleteActive():
        self.__completer.popup().hide() #TODO: why is this required?
        return False

    #Select the text from autocompleteStart until the current cursor
    cursor=self.textCursor()
    cursor.setPosition(self.__autocompleteStart.position(),cursor.KeepAnchor)

    prefix=cursor.selectedText()
    self.__completer.setCompletionPrefix(prefix)
    model = self.__completer.completionModel()
    if model.rowCount():
        # Create a list of all possible completions, and select the one
        # which is best suited. Use the one which is highest in the
        # __recentCompletions list, but prefer completions with matching
        # case if they exists

        # Create a list of (row, value) tuples of all possible completions
        completions = [
            (row, model.data(model.index(row,0),self.__completer.completionRole()))
            for row in range(model.rowCount())
            ]

        # Define a function to get the position in the __recentCompletions
        def completionIndex(data):
            try:
                return self.__recentCompletions.index(data)
            except ValueError:
                return -1

        # Sort twice; the last sort has priority over the first

        # Sort on most recent completions
        completions.sort(key = lambda c: completionIndex(c[1]), reverse = True)
        # Sort on matching case (prefer matching case)
        completions.sort(key = lambda c: c[1].startswith(prefix), reverse = True)

        # apply the best match
        bestMatchRow = completions[0][0]
        self.__completer.popup().setCurrentIndex(model.index(bestMatchRow,0))

        return True

    else:
        #No match, just hide
        self.autocompleteCancel()
        return False
</t>
<t tx="ekr.20190812072048.70">class CParser(Parser):
    """ A C parser.
    """
    _extensions = ['.c', '.h', '.cpp', 'cxx', 'hxx']
    _keywords = ['int', 'const', 'char', 'void', 'short', 'long', 'case']

    @others
if __name__=='__main__':
    parser = CParser()
    for token in parser.parseLine('void test(int i=2) /* test '):
        print ("%s %s" % (token.name, token))
</t>
<t tx="ekr.20190812072048.71">def parseLine(self, line, previousState=0):
    """ parseLine(line, previousState=0)

    Parses a line of C code, yielding tokens.

    """
    line = text_type(line)

    pos = 0 # Position following the previous match

    # identifierState and previousstate values:
    # 0: nothing special
    # 1: string
    # 2: multiline comment /* */

    # First determine whether we should look for the end of a string,
    # or if we should process a token.
    if previousState == 1:
        token = StringToken(line, 0, 0)
        tokens = self._findEndOfString(line, token)
        # Process tokens
        for token in tokens:
            yield token
            if isinstance(token, BlockState):
                return
        pos = token.end
    elif previousState == 2:
        token = MultilineCommentToken(line, 0, 0)
        tokens = self._findEndOfComment(line, token)
        # Process tokens
        for token in tokens:
            yield token
            if isinstance(token, BlockState):
                return
        pos = token.end

    # Enter the main loop that iterates over the tokens and skips strings
    while True:

        # Get next tokens
        tokens = self._findNextToken(line, pos)
        if not tokens:
            return
        elif isinstance(tokens[-1], StringToken):
            moreTokens = self._findEndOfString(line, tokens[-1])
            tokens = tokens[:-1] + moreTokens
        elif isinstance(tokens[-1], MultilineCommentToken):
            moreTokens = self._findEndOfComment(line, tokens[-1])
            tokens = tokens[:-1] + moreTokens

        # Process tokens
        for token in tokens:
            yield token
            if isinstance(token, BlockState):
                return
        pos = token.end
</t>
<t tx="ekr.20190812072048.72">def _findEndOfComment(self, line, token):
    """ Find the matching comment end in the rest of the line
    """

    # Do not use the start parameter of search, since ^ does not work then

    endMatch = commentEndProg.search(line, token.end)

    if endMatch:
        # The comment does end on this line
        token.end = endMatch.end()
        return [token]
    else:
        # The comment does not end on this line
        token.end = len(line)
        return [token, BlockState(2)]
</t>
<t tx="ekr.20190812072048.73">def _findEndOfString(self, line, token):
    """ Find the matching string end in the rest of the line
    """

    # todo: distinguish between single and double quote strings

    # Find the matching end in the rest of the line
    # Do not use the start parameter of search, since ^ does not work then
    endMatch = stringEndProg.search(line[token.end:])

    if endMatch:
        # The string does end on this line
        token.end = token.end + endMatch.end()
        return [token]
    else:
        # The string does not end on this line
        if line.strip().endswith("\\"): #Multi line string
            token = StringToken(line, token.start, len(line))
            return [token, BlockState(1)]
        else:
            return [UnterminatedStringToken(line, token.start, len(line))]
</t>
<t tx="ekr.20190812072048.74">def _findNextToken(self, line, pos):
    """ _findNextToken(line, pos):

    Returns a token or None if no new tokens can be found.

    """

    # Init tokens, if positing too large, stop now
    if pos &gt; len(line):
        return None
    tokens = []

    # Find the start of the next string or comment
    match = tokenProg.search(line, pos)

    # Process the Non-Identifier between pos and match.start()
    # or end of line
    nonIdentifierEnd = match.start() if match else len(line)

    # Return the Non-Identifier token if non-null
    token = NonIdentifierToken(line,pos,nonIdentifierEnd)
    if token:
        tokens.append(token)

    # If no match, we are done processing the line
    if not match:
        return tokens

    # The rest is to establish what identifier we are dealing with

    # Identifier ("a word or number") Find out whether it is a key word
    if match.group(1) is not None:
        identifier = match.group(1)
        tokenArgs = line, match.start(), match.end()

        if identifier in self._keywords:
            tokens.append( KeywordToken(*tokenArgs) )
        elif identifier[0] in '0123456789':
            # identifierState = 0
            tokens.append( NumberToken(*tokenArgs) )
        else:
            tokens.append( IdentifierToken(*tokenArgs) )

    # Single line comment
    elif match.group(2) is not None:
        tokens.append( CommentToken(line,match.start(),len(line)) )
    elif match.group(3) is not None:
        tokens.append( MultilineCommentToken(line,match.start(),match.end()) )
    elif match.group(4) is not None: # Char
        tokens.append( CharToken(line,match.start(),match.end()) )
    else:
        # We have matched a string-start
        tokens.append( StringToken(line,match.start(),match.end()) )

    # Done
    return tokens
</t>
<t tx="ekr.20190812072048.75">@path pyzo/codeeditor/parsers/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.76"># -*- coding: utf-8 -*-
import re
from . import Parser, BlockState, text_type
from .tokens import ALPHANUM
from ..misc import ustr

# Import tokens in module namespace
from .tokens import (CommentToken, StringToken,
    UnterminatedStringToken, IdentifierToken, NonIdentifierToken,
    KeywordToken, BuiltinsToken, InstanceToken, NumberToken, FunctionNameToken, ClassNameToken,
    TodoCommentToken, OpenParenToken, CloseParenToken)

# Keywords sets

# Source: import keyword; keyword.kwlist (Python 2.6.6)
python2Keywords = set(['and', 'as', 'assert', 'break', 'class', 'continue',
        'def', 'del', 'elif', 'else', 'except', 'exec', 'finally', 'for',
        'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'not', 'or',
        'pass', 'print', 'raise', 'return', 'try', 'while', 'with', 'yield'])

# Source: import keyword; keyword.kwlist (Python 3.1.2)
python3Keywords = set(['False', 'None', 'True', 'and', 'as', 'assert', 'break',
        'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally',
        'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda',
        'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while',
        'with', 'yield', 'async', 'await'])

# Merge the two sets to get a general Python keyword list
pythonKeywords = python2Keywords | python3Keywords

# Builtins sets

# Source: dir (__builtins__) (Python 2.7.12)
python2Builtins = set(['ArithmeticError', 'AssertionError', 'AttributeError',
        'BaseException', 'BufferError', 'BytesWarning', 'DeprecationWarning',
        'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',
        'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError',
        'ImportError', 'ImportWarning', 'IndentationError', 'IndexError',
        'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError',
        'NameError', 'None', 'NotImplemented', 'NotImplementedError',
        'OSError', 'OverflowError', 'PendingDeprecationWarning',
        'ReferenceError', 'RuntimeError', 'RuntimeWarning', 'StandardError',
        'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',
        'SystemExit', 'TabError', 'True', 'TypeError', 'UnboundLocalError',
        'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError',
        'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError',
        'Warning', 'ZeroDivisionError', '__debug__', '__doc__', '__import__',
        '__name__', '__package__', 'abs', 'all', 'any', 'apply', 'basestring',
        'bin', 'bool', 'buffer', 'bytearray', 'bytes', 'callable', 'chr',
        'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'copyright',
        'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval',
        'execfile', 'exit', 'file', 'filter', 'float', 'format', 'frozenset',
        'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input',
        'int', 'intern', 'isinstance', 'issubclass', 'iter', 'len', 'license',
        'list', 'locals', 'long', 'map', 'max', 'memoryview', 'min', 'next',
        'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit',
        'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round',
        'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum',
        'super', 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange',
        'zip'])

# Source: import builtins; dir(builtins) (Python 3.5.2)
# Note: Removed 'False', 'None', 'True'. They are keyword in Python 3
python3Builtins = set(['ArithmeticError', 'AssertionError', 'AttributeError',
        'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError',
        'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError',
        'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError',
        'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError',
        'Exception', 'FileExistsError', 'FileNotFoundError',
        'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError',
        'ImportError', 'ImportWarning', 'IndentationError', 'IndexError',
        'InterruptedError', 'IsADirectoryError', 'KeyError',
        'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError',
        'NotADirectoryError', 'NotImplemented', 'NotImplementedError',
        'OSError', 'OverflowError', 'PendingDeprecationWarning',
        'PermissionError', 'ProcessLookupError', 'RecursionError',
        'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',
        'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning',
        'SystemError', 'SystemExit', 'TabError', 'TimeoutError',
        'TypeError', 'UnboundLocalError', 'UnicodeDecodeError',
        'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError',
        'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning',
        'ZeroDivisionError', '__build_class__', '__debug__', '__doc__',
        '__import__', '__loader__', '__name__', '__package__', '__spec__',
        'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes',
        'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright',
        'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval',
        'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr',
        'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int',
        'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals',
        'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open',
        'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed',
        'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str',
        'sum', 'super', 'tuple', 'type', 'vars', 'zip'])

# Merge the two sets to get a general Python builtins list
pythonBuiltins = python2Builtins | python3Builtins

# Instance sets
python2Instance = set(['self'])

python3Instance = set(['self'])

pythonInstance = python2Instance | python3Instance
</t>
<t tx="ekr.20190812072048.77">class MultilineStringToken(StringToken):
    """ Characters representing a multi-line string. """
    defaultStyle = 'fore:#7F0000'
</t>
<t tx="ekr.20190812072048.78">class CellCommentToken(CommentToken):
    """ Characters representing a cell separator comment: "##". """
    defaultStyle = 'bold:yes, underline:yes'

# This regexp is used to find special stuff, such as comments, numbers and
# strings.
tokenProg = re.compile(
    '#|' +						# Comment or
    '([' + ALPHANUM + '_]+)|' +	# Identifiers/numbers (group 1) or
    '(' +  						# Begin of string group (group 2)
    '([bB]|[uU])?' +			# Possibly bytes or unicode (py2.x)
    '[rR]?' +					# Possibly a raw string
    '("""|\'\'\'|"|\')' +		# String start (triple qoutes first, group 4)
    ')|' +						# End of string group
    '(\(|\[|\{)|' +             # Opening parenthesis (gr 5)
    '(\)|\]|\})'                # Closing parenthesis (gr 6)
    )

# For a given type of string ( ', " , ''' , """ ),get  the RegExp
# program that matches the end. (^|[^\\]) means: start of the line
# or something that is not \ (since \ is supposed to escape the following
# quote) (\\\\)* means: any number of two slashes \\ since each slash will
# escape the next one
endProgs = {
    "'": re.compile(r"(^|[^\\])(\\\\)*'"),
    '"': re.compile(r'(^|[^\\])(\\\\)*"'),
    "'''": re.compile(r"(^|[^\\])(\\\\)*'''"),
    '"""': re.compile(r'(^|[^\\])(\\\\)*"""')
    }
</t>
<t tx="ekr.20190812072048.79">class PythonParser(Parser):
    """ Parser for Python in general (2.x or 3.x).
    """
    _extensions = ['.py' , '.pyw']
    _shebangKeywords = ["python", "python3", "python2"]
    # The list of keywords is overridden by the Python2/3 specific parsers
    _keywords = pythonKeywords
    # The list of builtins and instances is overridden by the Python2/3 specific parsers
    _builtins = pythonBuiltins
    _instance = pythonInstance

    @others
</t>
<t tx="ekr.20190812072048.8">def potentiallyAutoComplete(self, event):
    """ potentiallyAutoComplete(event)
    Given a keyEvent, check if we should perform an autocompletion.
    Returns 0 if no autocompletion was performed. Return 1 if
    autocompletion was performed, but the key event should be processed
    as normal. Return 2 if the autocompletion was performed, and the key
    should be consumed.
    """
    if self.autocompleteActive():
        if event.key() in self.__autocompletionAcceptKeys:
            if event.key() &lt;= 128:
                self.onAutoComplete()  # No arg: select last highlighted
                self.autocompleteCancel()
                event.ignore()
                return 1  # Let key have effect as normal
            elif event.modifiers() == Qt.NoModifier:
                # The key
                self.onAutoComplete()  # No arg: select last highlighted
                self.autocompleteCancel()
                return 2  # Key should be consumed
    return 0
</t>
<t tx="ekr.20190812072048.80">def _identifierState(self, identifier=None):
    """ Given an identifier returs the identifier state:
    3 means the current identifier can be a function.
    4 means the current identifier can be a class.
    0 otherwise.

    This method enables storing the state during the line,
    and helps the Cython parser to reuse the Python parser's code.
    """
    if identifier is None:
        # Explicit get/reset
        try:
            state = self._idsState
        except Exception:
            state = 0
        self._idsState = 0
        return state
    elif identifier == 'def':
        # Set function state
        self._idsState = 3
        return 3
    elif identifier == 'class':
        # Set class state
        self._idsState = 4
        return 4
    else:
        # This one can be func or class, next one can't
        state = self._idsState
        self._idsState = 0
        return state
</t>
<t tx="ekr.20190812072048.81">def parseLine(self, line, previousState=0):
    """ parseLine(line, previousState=0)

    Parse a line of Python code, yielding tokens.
    previousstate is the state of the previous block, and is used
    to handle line continuation and multiline strings.

    """
    line = text_type(line)

    # Init
    pos = 0 # Position following the previous match

    # identifierState and previousstate values:
    # 0: nothing special
    # 1: multiline comment single qoutes
    # 2: multiline comment double quotes
    # 3: a def keyword
    # 4: a class keyword

    #Handle line continuation after def or class
    #identifierState is 3 or 4 if the previous identifier was 3 or 4
    if previousState == 3 or previousState == 4:
        self._identifierState({3:'def',4:'class'}[previousState])
    else:
        self._identifierState(None)

    if previousState in [1,2]:
        token = MultilineStringToken(line, 0, 0)
        token._style = ['', "'''", '"""'][previousState]
        tokens = self._findEndOfString(line, token)
        # Process tokens
        for token in tokens:
            yield token
            if isinstance(token, BlockState):
                return
        pos = token.end

    # Enter the main loop that iterates over the tokens and skips strings
    while True:

        # Get next tokens
        tokens = self._findNextToken(line, pos)
        if not tokens:
            return
        elif isinstance(tokens[-1], StringToken):
            moreTokens = self._findEndOfString(line, tokens[-1])
            tokens = tokens[:-1] + moreTokens

        # Process tokens
        for token in tokens:
            yield token
            if isinstance(token, BlockState):
                return
        pos = token.end
</t>
<t tx="ekr.20190812072048.82">def _findEndOfString(self, line, token):
    """ _findEndOfString(line, token)

    Find the end of a string. Returns (token, endToken). The first
    is the given token or a replacement (UnterminatedStringToken).
    The latter is None, or the BlockState. If given, the line is
    finished.

    """

    # Set state
    self._identifierState(None)

    # Find the matching end in the rest of the line
    # Do not use the start parameter of search, since ^ does not work then
    style = token._style
    endMatch = endProgs[style].search(line[token.end:])

    if endMatch:
        # The string does end on this line
        tokenArgs = line, token.start, token.end + endMatch.end()
        if style in ['"""', "'''"]:
            token = MultilineStringToken(*tokenArgs)
        else:
            token.end = token.end + endMatch.end()
        return [token]
    else:
        # The string does not end on this line
        tokenArgs = line, token.start, token.end + len(line)
        if style == "'''":
            return [MultilineStringToken(*tokenArgs), BlockState(1)]
        elif style == '"""':
            return [MultilineStringToken(*tokenArgs), BlockState(2)]
        else:
            return [UnterminatedStringToken(*tokenArgs)]
</t>
<t tx="ekr.20190812072048.83">def _findNextToken(self, line, pos):
    """ _findNextToken(line, pos):

    Returns a token or None if no new tokens can be found.

    """

    # Init tokens, if pos too large, were done
    if pos &gt; len(line):
        return None
    tokens = []

    # Find the start of the next string or comment
    match = tokenProg.search(line, pos)

    # Process the Non-Identifier between pos and match.start()
    # or end of line
    nonIdentifierEnd = match.start() if match else len(line)

    # Return the Non-Identifier token if non-null
    # todo: here it goes wrong (allow returning more than one token?)
    token = NonIdentifierToken(line,pos,nonIdentifierEnd)
    strippedNonIdentifier = ustr(token).strip()
    if token:
        tokens.append(token)

    # Do checks for line continuation and identifierState
    # Is the last non-whitespace a line-continuation character?
    if strippedNonIdentifier.endswith('\\'):
        lineContinuation = True
        # If there are non-whitespace characters after def or class,
        # cancel the identifierState
        if strippedNonIdentifier != '\\':
            self._identifierState(None)
    else:
        lineContinuation = False
        # If there are non-whitespace characters after def or class,
        # cancel the identifierState
        if strippedNonIdentifier != '':
            self._identifierState(None)

    # If no match, we are done processing the line
    if not match:
        if lineContinuation:
            tokens.append( BlockState(self._identifierState()) )
        return tokens

    # The rest is to establish what identifier we are dealing with

    # Comment
    if match.group() == '#':
        matchStart = match.start()
        if not line[:matchStart].strip() and (
               line[matchStart:].startswith('##') or
               line[matchStart:].startswith('#%%') or
               line[matchStart:].startswith('# %%')):
            tokens.append( CellCommentToken(line,matchStart,len(line)) )
        elif self._isTodoItem(line[matchStart+1:]):
            tokens.append( TodoCommentToken(line,matchStart,len(line)) )
        else:
            tokens.append( CommentToken(line,matchStart,len(line)) )
        if lineContinuation:
            tokens.append( BlockState(self._identifierState()) )
        return tokens

    # If there are non-whitespace characters after def or class,
    # cancel the identifierState (this time, also if there is just a \
    # since apparently it was not on the end of a line)
    if strippedNonIdentifier != '':
        self._identifierState(None)

    # Identifier ("a word or number") Find out whether it is a key word
    if match.group(1) is not None:
        identifier = match.group(1)
        tokenArgs = line, match.start(), match.end()

        # Set identifier state
        identifierState = self._identifierState(identifier)

        if identifier in self._keywords:
            tokens.append( KeywordToken(*tokenArgs) )
        elif identifier in self._builtins and ('.' + identifier not in line and
                                               'def ' + identifier not in line):
            tokens.append(BuiltinsToken(*tokenArgs))
        elif identifier in self._instance:
            tokens.append(InstanceToken(*tokenArgs))
        elif identifier[0] in '0123456789':
            self._identifierState(None)
            tokens.append( NumberToken(*tokenArgs) )
        else:
            if (identifierState==3 and
                    line[match.end():].lstrip().startswith('(') ):
                tokens.append( FunctionNameToken(*tokenArgs) )
            elif identifierState==4:
                tokens.append( ClassNameToken(*tokenArgs) )
            else:
                tokens.append( IdentifierToken(*tokenArgs) )

    elif match.group(2) is not None :
        # We have matched a string-start
        # Find the string style ( ' or " or ''' or """)
        token = StringToken(line, match.start(), match.end())
        token._style = match.group(4) # The style is in match group 4
        tokens.append( token )
    elif match.group(5) is not None :
        token = OpenParenToken(line, match.start(), match.end())
        token._style = match.group(5)
        tokens.append(token)
    elif match.group(6) is not None :
        token = CloseParenToken(line, match.start(), match.end())
        token._style = match.group(6)
        tokens.append(token)
    # Done
    return tokens
</t>
<t tx="ekr.20190812072048.84">class Python2Parser(PythonParser):
    """ Parser for Python 2.x code.
    """
    # The application should choose whether to set the Py 2 specific parser
    _extensions = []
    _shebangKeywords = []
    _keywords = python2Keywords
    _builtins = python2Builtins
    _instance = python2Instance
</t>
<t tx="ekr.20190812072048.85">class Python3Parser(PythonParser):
    """ Parser for Python 3.x code.
    """
    # The application should choose whether to set the Py 3 specific parser
    _extensions = []
    _shebangKeywords = []
    _keywords = python3Keywords
    _builtins = python3Builtins
    _instance = python3Instance
</t>
<t tx="ekr.20190812072048.86">@path pyzo/codeeditor/parsers/
@nopyflakes
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.87"># -*- coding: utf-8 -*-
from . import Parser, BlockState, text_type

# Import tokens in module namespace
from .tokens import (CommentToken, StringToken,
    UnterminatedStringToken, IdentifierToken, NonIdentifierToken,
    FunctionNameToken, ClassNameToken, KeywordToken,
    NumberToken, OpenParenToken, CloseParenToken)
</t>
<t tx="ekr.20190812072048.88">class SExprParser(Parser):
    """ Parser for S-expressions.
    """

    _extensions = ['.lisp' , '.ss', '.sls', '.scm']

    _keywords = []  # can be overloaded

    @others
</t>
<t tx="ekr.20190812072048.89">def parseLine(self, line, comment_level=0):
    """ parseLine(line, comment_level=0)

    Parse a line of code, yielding tokens.
    previousstate is the state of the previous block, and is used
    to handle line continuation and multiline strings.

    """
    line = text_type(line)

    if comment_level &lt; 0:
        comment_level = 0
    if comment_level &gt; 0:
        token = CommentToken(line, 0, 0)

    pos = 0
    while pos &lt; len(line):
        pos = self._skip_whitespace(line, pos)
        if pos &gt;= len(line):
            break

        # Parse block comments
        if line[pos] == '(' and pos &lt; len(line)-1 and line[pos+1] == ';':
            if comment_level == 0:
                token = CommentToken(line, pos, pos)
            comment_level += 1
            pos += 1
        elif line[pos] == ';' and pos &lt; len(line)-1 and line[pos+1] == ')':
            if comment_level == 1:
                token.end = pos + 2
                yield token
            comment_level = max(0, comment_level - 1)
            pos += 1

        elif comment_level &gt; 0:
            pos += 1

        else:
            # Outside of block comments ...

            if line[pos] == ';' and pos &lt; len(line)-1 and line[pos+1] == ';':
                yield CommentToken(line, pos, len(line))
                pos = len(line)
            elif line[pos] == '(':
                token = OpenParenToken(line, pos, pos+1)
                token._style = '('
                yield token
                pos += 1
            elif line[pos] == ')':
                token = CloseParenToken(line, pos, pos+1)
                token._style = ')'
                yield token
                pos += 1
            elif line[pos] == '"':
                i0 = pos
                esc = False
                for i in range(i0 + 1, len(line)):
                    if not esc and line[i] == '"':
                        pos = i + 1
                        yield StringToken(line, i0, pos)
                        break
                    esc = line[i] == '\\'
                else:
                    yield UnterminatedStringToken(line, i0, len(line))
                    pos = len(line)
            else:
                # word: number, keyword or normal identifier
                i0 = pos
                for i in range(i0, len(line)):
                    if line[i] in ' \t\r\n)':
                        yield self._get_token_for_word(line, i0, i)
                        pos = i
                        break
                else:
                    pos = len(line)
                    yield self._get_token_for_word(line, i0, len(line))

    if comment_level &gt; 0:
        token.end = len(line)
        yield token
    yield BlockState(comment_level)
</t>
<t tx="ekr.20190812072048.9">def keyPressEvent(self, event):
    key = event.key()
    modifiers = event.modifiers()
    if key == Qt.Key_Escape and modifiers == Qt.NoModifier and \
            self.autocompleteActive():
        self.autocompleteCancel()
        return #Consume the key

    if self.potentiallyAutoComplete(event) &gt; 1:
        return  #Consume

    #Allowed keys that do not close the autocompleteList:
    # alphanumeric and _ ans shift
    # Backspace (until start of autocomplete word)
    if self.autocompleteActive() and \
        not event.text().isalnum() and event.text() != '_' and \
        key != Qt.Key_Shift and not (
        (key==Qt.Key_Backspace) and self.textCursor().position()&gt;self.__autocompleteStart.position()):
        self.autocompleteCancel()

    # Apply the key that was pressed
    super(AutoCompletion, self).keyPressEvent(event)

    if self.autocompleteActive():
        #While we type, the start of the autocompletion may move due to line
        #wrapping, so reposition after every key stroke
        self.__positionAutocompleter()
        self.__updateAutocompleterPrefix()
</t>
<t tx="ekr.20190812072048.90">def _skip_whitespace(self, line, pos):
    while pos &lt; len(line):
        if line[pos] not in ' \t\r\n':
            break
        pos += 1
    return pos
</t>
<t tx="ekr.20190812072048.91">def _get_token_for_word(self, line, i0, i1):
    word = line[i0:i1]
    is_number =  False
    try:
        float(word)
        is_number = True
    except ValueError:
        pass

    if is_number or word.startswith('$'):
        return NumberToken(line, i0, i1)
    elif word in self._keywords:  # highlight extra
        return ClassNameToken(line, i0, i1)  # ClassNameToken or FunctionNameToken
    elif i0 &gt;0 and line[i0-1] == '(':  # First element in expression is "keyword"
        return KeywordToken(line, i0, i1)
    else:
        return IdentifierToken(line, i0, i1)
</t>
<t tx="ekr.20190812072048.92">class WatParser(SExprParser):
    """ Parser for textual WASM (WAT) code.
    """

    _extensions = ['.wat', '.wast']

    _keywords = ['module', 'type', 'import', 'func', 'table', 'memory',
                 'global', 'export', 'start', 'element', 'data']
</t>
<t tx="ekr.20190812072048.93">@path pyzo/codeeditor/parsers/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072048.94"># -*- coding: utf-8 -*-
""" Module tokens

Defines the base Token class and a few generic tokens.
Tokens are used by parsers to identify for groups of characters
what they represent. This is in turn used by the highlighter
to determine how these characters should be styled.

"""

# Many parsers need this
ALPHANUM = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'

from ..style import StyleFormat, StyleElementDescription
from ..misc import ustr

</t>
<t tx="ekr.20190812072048.95">class Token(object):
    """ Token(line, start, end)

    Base token class.

    A token is a group of characters representing "something".
    What is represented, is specified by the subclass.

    Each token class should have a docstring describing the meaning
    of the characters it is applied to.

    """
    defaultStyle = 'fore:#000, bold:no, underline:no, italic:no'
    isToken = True # For the BlockState object, which is also returned by the parsers, this is False
    @others
</t>
<t tx="ekr.20190812072048.96">def __init__(self, line='', start=0, end=0):
    self.line = ustr(line)
    self.start = start
    self.end = end
    self._name = self._getName()
</t>
<t tx="ekr.20190812072048.97">def __str__(self):  # on 2.x we use __unicode__
    return self.line[self.start:self.end]
</t>
<t tx="ekr.20190812072048.98">def __unicode__(self):  # for py 2.x
    return self.line[self.start:self.end]
</t>
<t tx="ekr.20190812072048.99">def __repr__(self):
    return repr('%s:%s' % (self.name, self))
</t>
<t tx="ekr.20190812072049.1">@path pyzo/core/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.10">def print(*args, **kwargs):
    # Obtain time string
    t = time.localtime()
    preamble = "{:02g}-{:02g}-{:04g} {:02g}:{:02g}:{:02g}: "
    preamble = preamble.format( t.tm_mday, t.tm_mon, t.tm_year,
                                t.tm_hour, t.tm_min, t.tm_sec)
    # Prepend to args and print
    args = [preamble] + list(args)
    original_print(*tuple(args),**kwargs)
</t>
<t tx="ekr.20190812072049.100">def onEditChanged(self):
    if self.DISABLE_SYSTEM_DEFAULT or not self._check.isChecked():
        self._value = self.getWidgetText()
</t>
<t tx="ekr.20190812072049.101">def onCheckChanged(self, state):
    if state:
        self._bufferedValue = self._value
        self.setTheText(self.SYSTEM_VALUE)
    else:
        self.setTheText(self._bufferedValue)
</t>
<t tx="ekr.20190812072049.102">def setTheText(self, value):

    if self.DISABLE_SYSTEM_DEFAULT:
        # Just set the value
        self._edit.setReadOnly(False)
        self.setWidgetText(value)

    elif value != self.SYSTEM_VALUE:
        # Value given, enable edit
        self._check.setChecked(False)
        self._edit.setReadOnly(False)
        # Set the text
        self.setWidgetText(value)

    else:
        # Use system default, disable edit widget
        self._check.setChecked(True)
        self._edit.setReadOnly(True)
        # Set text using system environment
        self.setWidgetText(None)

    # Store value
    self._value = value
</t>
<t tx="ekr.20190812072049.103">def getTheText(self):
    return self._value
</t>
<t tx="ekr.20190812072049.104">class ShellInfo_pythonPath(ShellinfoWithSystemDefault):

    SYSTEM_VALUE = '$PYTHONPATH'

    @others
</t>
<t tx="ekr.20190812072049.105">def __init__(self, parent):

    # Create sub-widget
    self._edit = QtWidgets.QTextEdit(parent)
    self._edit.zoomOut(1)
    self._edit.setMaximumHeight(80)
    self._edit.setMinimumWidth(200)
    self._edit.textChanged.connect(self.onEditChanged)

    # Instantiate
    ShellinfoWithSystemDefault.__init__(self, parent, self._edit)
</t>
<t tx="ekr.20190812072049.106">def getWidgetText(self):
    return self._edit.toPlainText()
</t>
<t tx="ekr.20190812072049.107">def setWidgetText(self, value=None):
    if value is None:
        pp = os.environ.get('PYTHONPATH','')
        pp = pp.replace(os.pathsep, '\n').strip()
        value = '$PYTHONPATH:\n%s\n' % pp
    self._edit.setText(value)

# class ShellInfo_startupScript(ShellinfoWithSystemDefault):
#
#     SYSTEM_VALUE = '$PYTHONSTARTUP'
#
#     def __init__(self, parent):
#
#         # Create sub-widget
#         self._edit = QtWidgets.QLineEdit(parent)
#         self._edit.textEdited.connect(self.onEditChanged)
#
#         # Instantiate
#         ShellinfoWithSystemDefault.__init__(self, parent, self._edit)
#
#
#     def getWidgetText(self):
#         return self._edit.text()
#
#
#     def setWidgetText(self, value=None):
#         if value is None:
#             pp = os.environ.get('PYTHONSTARTUP','').strip()
#             if pp:
#                 value = '$PYTHONSTARTUP: "%s"' % pp
#             else:
#                 value = '$PYTHONSTARTUP: None'
#
#         self._edit.setText(value)
</t>
<t tx="ekr.20190812072049.108">class ShellInfo_startupScript(QtWidgets.QVBoxLayout):

    DISABLE_SYSTEM_DEFAULT = sys.platform == 'darwin'
    SYSTEM_VALUE = '$PYTHONSTARTUP'
    RUN_AFTER_GUI_TEXT = '# AFTER_GUI - remove to run the code BEFORE integrating the GUI\n'

    @others
</t>
<t tx="ekr.20190812072049.109">def __init__(self, parent):
    # Do not pass parent, because is a sublayout
    QtWidgets.QVBoxLayout.__init__(self)

    # Create sub-widget
    self._edit1 = QtWidgets.QLineEdit(parent)
    self._edit1.textEdited.connect(self.onEditChanged)
    if sys.platform.startswith('win'):
        self._edit1.setPlaceholderText('C:\\path\\to\\script.py')
    else:
        self._edit1.setPlaceholderText('/path/to/script.py')
    #
    self._edit2 = QtWidgets.QTextEdit(parent)
    self._edit2.zoomOut(1)
    self._edit2.setMaximumHeight(80)
    self._edit2.setMinimumWidth(200)
    self._edit2.textChanged.connect(self.onEditChanged)

    # Layout
    self.setSpacing(1)
    self.addWidget(self._edit1)
    self.addWidget(self._edit2)

    # Create radio widget for system default
    t = translate('shell', 'Use system default')
    self._radio_system = QtWidgets.QRadioButton(t, parent)
    self._radio_system.toggled.connect(self.onCheckChanged)
    self.addWidget(self._radio_system)
    if self.DISABLE_SYSTEM_DEFAULT:
        self._radio_system.hide()

    # Create radio widget for file
    t = translate('shell', 'File to run at startup')
    self._radio_file = QtWidgets.QRadioButton(t, parent)
    self._radio_file.toggled.connect(self.onCheckChanged)
    self.addWidget(self._radio_file)

    # Create radio widget for code
    t = translate('shell', 'Code to run at startup')
    self._radio_code = QtWidgets.QRadioButton(t, parent)
    self._radio_code.toggled.connect(self.onCheckChanged)
    self.addWidget(self._radio_code)

    # The actual value of this shell config attribute
    self._value = ''

    # A buffered version, so that clicking the text box does not
    # remove the value at once
    self._valueFile = ''
    self._valueCode = '\n'
</t>
<t tx="ekr.20190812072049.11">def splitConsole(stdoutFun=None, stderrFun=None):
    """
    splitConsole(stdoutFun=None, stderrFun=None)

    Splits the stdout and stderr streams. On each call
    to their write methods, in addition to the original
    write method being called, will call the given
    functions.
    Returns the history of the console (combined stdout
    and stderr).
    Used by the logger shell.
    """
    # if leo_g: leo_g.pr('pyzo/__init__.py: splitConsole()')

    # Split stdout and stderr
    sys.stdout = OutputStreamSplitter(sys.stdout)
    sys.stderr = OutputStreamSplitter(sys.stderr)

    # Make them share their history
    sys.stderr._history = sys.stdout._history

    # Set defer functions
    if stdoutFun:
        sys.stdout._deferFunction = stdoutFun
    if stderrFun:
        sys.stderr._deferFunction = stderrFun

    # Return history
    return ''.join(sys.stdout._history)
</t>
<t tx="ekr.20190812072049.110">def onEditChanged(self):
    if self._radio_file.isChecked():
        self._value = self._valueFile = self._edit1.text().strip()
    elif self._radio_code.isChecked():
        # ensure newline!
        self._value = self._valueCode = self._edit2.toPlainText().strip() + '\n'
</t>
<t tx="ekr.20190812072049.111">def onCheckChanged(self, state):
    if self._radio_system.isChecked():
        self.setWidgetText(self.SYSTEM_VALUE)
    elif self._radio_file.isChecked():
        self.setWidgetText(self._valueFile)
    elif self._radio_code.isChecked():
        self.setWidgetText(self._valueCode)
</t>
<t tx="ekr.20190812072049.112">def setTheText(self, value):
    self.setWidgetText(value, True)
    self._value = value
</t>
<t tx="ekr.20190812072049.113">def setWidgetText(self, value, init=False):
    self._value = value

    if value == self.SYSTEM_VALUE and not self.DISABLE_SYSTEM_DEFAULT:
        # System default
        if init:
            self._radio_system.setChecked(True)
        pp = os.environ.get('PYTHONSTARTUP','').strip()
        if pp:
            value = '$PYTHONSTARTUP: "%s"' % pp
        else:
            value = '$PYTHONSTARTUP: None'
        #
        self._edit1.setReadOnly(True)
        self._edit1.show()
        self._edit2.hide()
        self._edit1.setText(value)

    elif not '\n' in value:
        # File
        if init:
            self._radio_file.setChecked(True)
        self._edit1.setReadOnly(False)
        self._edit1.show()
        self._edit2.hide()
        self._edit1.setText(value)

    else:
        # Code
        if init:
            self._radio_code.setChecked(True)
        self._edit1.hide()
        self._edit2.show()
        if not value.strip():
            value = self.RUN_AFTER_GUI_TEXT
        self._edit2.setText(value)
</t>
<t tx="ekr.20190812072049.114">def getTheText(self):
    return self._value
</t>
<t tx="ekr.20190812072049.115">class ShellInfo_startDir(ShellInfoLineEdit):
    @others
</t>
<t tx="ekr.20190812072049.116">def __init__(self, parent):
    ShellInfoLineEdit.__init__(self, parent)
    if sys.platform.startswith('win'):
        self.setPlaceholderText('C:\\path\\to\\your\\python\\modules')
    else:
        self.setPlaceholderText('/path/to/your/python/modules')
</t>
<t tx="ekr.20190812072049.117">class ShellInfo_argv(ShellInfoLineEdit):
    @others
</t>
<t tx="ekr.20190812072049.118">def __init__(self, parent):
    ShellInfoLineEdit.__init__(self, parent)
    self.setPlaceholderText('arg1 arg2 "arg with spaces"')
</t>
<t tx="ekr.20190812072049.119">class ShellInfo_environ(QtWidgets.QTextEdit):
    EXAMPLE = 'EXAMPLE_VAR1=value1\nPYZO_PROCESS_EVENTS_WHILE_DEBUGGING=1'

    @others
</t>
<t tx="ekr.20190812072049.12">class OutputStreamSplitter:
    """ This class is used to replace stdout and stderr output
    streams. It defers the stream to the original and to
    a function that can be registered.
    Used by the logger shell.
    """

    @others

# Split now, with no defering
splitConsole()

# EKR: *importing* this module starts logging.
</t>
<t tx="ekr.20190812072049.120">def __init__(self, parent):
    QtWidgets.QTextEdit.__init__(self, parent)
    self.zoomOut(1)
    self.setText(self.EXAMPLE)
</t>
<t tx="ekr.20190812072049.121">def _cleanText(self, txt):
    return '\n'.join([line.strip() for line in txt.splitlines()])
</t>
<t tx="ekr.20190812072049.122">def setTheText(self, value):
    value = self._cleanText(value)
    if value:
        self.setText(value)
    else:
        self.setText(self.EXAMPLE)
</t>
<t tx="ekr.20190812072049.123">def getTheText(self):
    value = self.toPlainText()
    value = self._cleanText(value)
    if value == self.EXAMPLE:
        return ''
    else:
        return value
</t>
<t tx="ekr.20190812072049.124">## The dialog class and container with tabs
class ShellInfoTab(QtWidgets.QScrollArea):

    INFO_KEYS = [   translate('shell', 'name ::: The name of this configuration.'),
                    translate('shell', 'exe ::: The Python executable.'),
                    translate('shell', 'ipython ::: Use IPython shell if available.'),
                    translate('shell', 'gui ::: The GUI toolkit to integrate (for interactive plotting, etc.).'),
                    translate('shell', 'pythonPath ::: A list of directories to search for modules and packages. Write each path on a new line, or separate with the default seperator for this OS.'),  # noqa
                    translate('shell', 'startupScript ::: The script to run at startup (not in script mode).'),
                    translate('shell', 'startDir ::: The start directory (not in script mode).'),
                    translate('shell', 'argv ::: The command line arguments (sys.argv).'),
                    translate('shell', 'environ ::: Extra environment variables (os.environ).'),
                ]

    @others
</t>
<t tx="ekr.20190812072049.125">def __init__(self, parent):
    QtWidgets.QScrollArea.__init__(self, parent)

    # Init the scroll area
    self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
    self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)
    self.setWidgetResizable(True)
    self.setFrameShape(QtWidgets.QFrame.NoFrame)

    # Create widget and a layout
    self._content = QtWidgets.QWidget(parent)
    self._formLayout = QtWidgets.QFormLayout(self._content)

    # Collect classes of widgets to instantiate
    classes = []
    for t in self.INFO_KEYS:
        className = 'ShellInfo_' + t.key
        cls = globals()[className]
        classes.append((t, cls))

    # Instantiate all classes
    self._shellInfoWidgets = {}
    for t, cls in classes:
        # Instantiate and store
        instance = cls(self._content)
        self._shellInfoWidgets[t.key] = instance
        # Create label
        label = QtWidgets.QLabel(t, self._content)
        label.setToolTip(t.tt)
        # Add to layout
        self._formLayout.addRow(label, instance)

    # Add delete button

    t = translate('shell', 'Delete ::: Delete this shell configuration')
    label = QtWidgets.QLabel('', self._content)
    instance = QtWidgets.QPushButton(pyzo.icons.cancel, t, self._content)
    instance.setToolTip(t.tt)
    instance.setAutoDefault(False)
    instance.clicked.connect(self.parent().parent().onTabClose)
    deleteLayout = QtWidgets.QHBoxLayout()
    deleteLayout.addWidget(instance, 0)
    deleteLayout.addStretch(1)
    # Add to layout
    self._formLayout.addRow(label, deleteLayout)

    # Apply layout
    self._formLayout.setSpacing(15)
    self._content.setLayout(self._formLayout)
    self.setWidget(self._content)
</t>
<t tx="ekr.20190812072049.126">def setTabTitle(self, name):
    tabWidget = self.parent().parent()
    tabWidget.setTabText(tabWidget.indexOf(self), name)
</t>
<t tx="ekr.20190812072049.127">def setInfo(self, info=None):
    """  Set the shell info struct, and use it to update the widgets.
    Not via init, because this function also sets the tab name.
    """

    # If info not given, use default as specified by the KernelInfo struct
    if info is None:
        info = KernelInfo()
        # Name
        n = self.parent().parent().count()
        if n &gt; 1:
            info.name = "Shell config %i" % n

    # Store info
    self._info = info

    # Set widget values according to info
    try:
        for key in info:
            widget = self._shellInfoWidgets.get(key, None)
            if widget is not None:
                widget.setTheText(info[key])

    except Exception as why:
        print("Error setting info in shell config:", why)
        print(info)
</t>
<t tx="ekr.20190812072049.128">def getInfo(self):

    info = self._info

    # Set struct values according to widgets
    try:
        for key, widget in self._shellInfoWidgets.items():
            info[key] = widget.getTheText()

    except Exception as why:
        print("Error getting info in shell config:", why)
        print(info)

    # Return the original (but modified) ssdf Dict object
    return info
</t>
<t tx="ekr.20190812072049.129">class ShellInfoDialog(QtWidgets.QDialog):
    """ Dialog to edit the shell configurations. """

    @others
</t>
<t tx="ekr.20190812072049.13">def __init__(self, fileObject):

    # Init, copy properties if it was already a splitter
    if isinstance(fileObject, OutputStreamSplitter):
        self._original = fileObject._original
        self._history = fileObject._history
        self._deferFunction = fileObject._deferFunction
    else:
        self._original = fileObject
        self._history = []
        self._deferFunction = self.dummyDeferFunction

    # Replace original with a dummy if None
    if self._original is None:
        self._original = DummyStd()
</t>
<t tx="ekr.20190812072049.130">def __init__(self, *args):
    QtWidgets.QDialog.__init__(self, *args)
    self.setModal(True)

    # Set title
    self.setWindowTitle(pyzo.translate('shell', 'Shell configurations'))
    # Create tab widget
    self._tabs = QtWidgets.QTabWidget(self)
    #self._tabs = CompactTabWidget(self, padding=(4,4,5,5))
    #self._tabs.setDocumentMode(False)
    self._tabs.setMovable(True)

    # Get known interpreters (sorted them by version)
    # Do this here so we only need to do it once ...
    from pyzo.util.interpreters import get_interpreters
    self.interpreters = list(reversed(get_interpreters('2.4')))

    # Introduce an entry if there's none
    if not pyzo.config.shellConfigs2:
        w = ShellInfoTab(self._tabs)
        self._tabs.addTab(w, '---')
        w.setInfo()

    # Fill tabs
    for item in pyzo.config.shellConfigs2:
        w = ShellInfoTab(self._tabs)
        self._tabs.addTab(w, '---')
        w.setInfo(item)

    # Enable making new tabs and closing tabs
    self._add = QtWidgets.QToolButton(self)
    self._tabs.setCornerWidget(self._add)
    self._add.clicked.connect(self.onAdd)
    self._add.setToolButtonStyle(QtCore.Qt.ToolButtonTextBesideIcon)
    self._add.setIcon(pyzo.icons.add)
    self._add.setText(translate('shell', 'Add config'))
    #
    #self._tabs.setTabsClosable(True)
    self._tabs.tabCloseRequested.connect(self.onTabClose)

    # Create buttons
    cancelBut = QtWidgets.QPushButton("Cancel", self)
    okBut = QtWidgets.QPushButton("Done", self)
    cancelBut.clicked.connect(self.close)
    okBut.clicked.connect(self.applyAndClose)
    # Layout for buttons
    buttonLayout = QtWidgets.QHBoxLayout()
    buttonLayout.addStretch(1)
    buttonLayout.addWidget(cancelBut)
    buttonLayout.addSpacing(10)
    buttonLayout.addWidget(okBut)

    # Layout the widgets
    mainLayout = QtWidgets.QVBoxLayout(self)
    mainLayout.addSpacing(8)
    mainLayout.addWidget(self._tabs,0)
    mainLayout.addLayout(buttonLayout,0)
    self.setLayout(mainLayout)

    # Prevent resizing
    self.show()
    self.setMinimumSize(500, 400)
    self.resize(640, 500)
    #self.setMaximumHeight(500)
</t>
<t tx="ekr.20190812072049.131">def onAdd(self):
    # Create widget and add to tabs
    w = ShellInfoTab(self._tabs)
    self._tabs.addTab(w, '---')
    w.setInfo()
    # Select
    self._tabs.setCurrentWidget(w)
    w.setFocus()
</t>
<t tx="ekr.20190812072049.132">def onTabClose(self):
    index = self._tabs.currentIndex()
    self._tabs.removeTab( index )
</t>
<t tx="ekr.20190812072049.133">def applyAndClose(self, event=None):
    self.apply()
    self.close()
</t>
<t tx="ekr.20190812072049.134">def apply(self):
    """ Apply changes for all tabs. """

    # Clear
    pyzo.config.shellConfigs2 = []

    # Set new versions. Note that although we recreate the list,
    # the list is filled with the orignal structs, so having a
    # reference to such a struct (as the shell has) will enable
    # you to keep track of any made changes.
    for i in range(self._tabs.count()):
        w = self._tabs.widget(i)
        pyzo.config.shellConfigs2.append( w.getInfo() )
</t>
<t tx="ekr.20190812072049.135">@path pyzo/core/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.136"># -*- coding: utf-8 -*-
""" Module shellStack

Implements the stack of shells. Also implements the nifty debug button
and a dialog to edit the shell configurations.

"""

try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo.core.shellStack.py')
except Exception:
    leo_g = None

import time
import webbrowser
from pyzo.util.qt import QtCore, QtGui, QtWidgets  # noqa
assert QtCore and QtGui and QtWidgets # EKR:change.

import pyzo
from pyzo import translate
from pyzo.core.shell import PythonShell
from pyzo.core.pyzoLogging import print  # noqa
assert print # EKR:change
from pyzo.core.menu import ShellTabContextMenu, ShellButtonMenu
from pyzo.core.icons import ShellIconMaker

</t>
<t tx="ekr.20190812072049.137">def shellTitle(shell, moreinfo=False):
    """ Given a shell instance, build the text title to represent it.
    """

    # Get name
    nameText = shell._info.name

    # Build version text
    if shell._version:
        versionText = 'v{}'.format(shell._version)
    else:
        versionText = 'v?'

    # Build gui text
    guiText = shell._startup_info.get('gui')
    guiText = guiText or ''
    if guiText.lower() in ['none', '']:
        guiText = 'without gui'
    else:
        guiText = 'with ' + guiText + ' gui'

    # Build state text
    stateText = shell._state or ''

    # Build text for elapsed time
    elapsed = time.time() - shell._start_time
    hh = elapsed//3600
    mm = (elapsed - hh*3600)//60
    ss = elapsed - hh*3600 - mm*60
    runtimeText = 'runtime: %i:%02i:%02i' % (hh, mm, ss)

    # Build text
    if not moreinfo:
        text = nameText
    else:
        text = "'%s' (%s %s) - %s, %s" % (nameText, versionText, guiText, stateText, runtimeText)

    # Done
    return text
</t>
<t tx="ekr.20190812072049.138">class ShellStackWidget(QtWidgets.QWidget):
    """ The shell stack widget provides a stack of shells.

    It wrapps a QStackedWidget that contains the shell objects. This
    stack is used as a reference to synchronize the shell selection with.
    We keep track of what is the current selected shell and apply updates
    if necessary. Therefore, changing the current shell in the stack
    should be enough to invoke a full update.

    """

    # When the current shell changes.
    currentShellChanged = QtCore.Signal()

    # When the current shells state (or debug state) changes,
    # or when a new prompt is received.
    # Also fired when the current shell changes.
    currentShellStateChanged = QtCore.Signal()

    @others
</t>
<t tx="ekr.20190812072049.139">def __init__(self, parent):
    QtWidgets.QWidget.__init__(self, parent)
    
    # if leo_g: leo_g.pr('\nShellStackWidget.__init__', leo_g.callers())

    # create toolbar
    self._toolbar = QtWidgets.QToolBar(self)
    self._toolbar.setMaximumHeight(26)
    self._toolbar.setIconSize(QtCore.QSize(16,16))

    # create stack
    self._stack = QtWidgets.QStackedWidget(self)

    # Populate toolbar
    self._shellButton = ShellControl(self._toolbar, self._stack)
    self._debugmode = 0
    self._dbs = DebugStack(self._toolbar)
    #
    self._toolbar.addWidget(self._shellButton)
    self._toolbar.addSeparator()
    # self._toolbar.addWidget(self._dbc) -&gt; delayed, see addContextMenu()

    self._interpreterhelp = InterpreterHelper(self)

    # widget layout
    layout = QtWidgets.QVBoxLayout()
    layout.setSpacing(0)
    layout.setContentsMargins(0, 0, 0, 0)
    layout.addWidget(self._toolbar)
    layout.addWidget(self._stack, 0)
    layout.addWidget(self._interpreterhelp, 0)
    self.setLayout(layout)

    # make callbacks
    self._stack.currentChanged.connect(self.onCurrentChanged)

    self.showInterpreterHelper()
</t>
<t tx="ekr.20190812072049.14">def dummyDeferFunction(self, text):
    pass
</t>
<t tx="ekr.20190812072049.140">def __iter__(self):
    i = 0
    while i &lt; self._stack.count():
        w = self._stack.widget(i)
        i += 1
        yield w
</t>
<t tx="ekr.20190812072049.141">def showInterpreterHelper(self, show=True):
    self._interpreterhelp.setVisible(show)
    self._toolbar.setVisible(not show)
    self._stack.setVisible(not show)
    if show:
        self._interpreterhelp.detect()
</t>
<t tx="ekr.20190812072049.142">def addShell(self, shellInfo=None):
    """Add a shell to the widget. """
    # g = leo_g
    # g.pr('ShellStackWidget.addShell', repr(pyzo.main))
    #
    # Create shell and add to stack
    shell = PythonShell(self, shellInfo)
    self._stack.addWidget(shell)
    #
    # Bind to signals
    shell.stateChanged.connect(self.onShellStateChange)
    shell.debugStateChanged.connect(self.onShellDebugStateChange)
    #
    # Select it and focus on it (invokes onCurrentChanged)
    self._stack.setCurrentWidget(shell)
    shell.setFocus()
    return shell
</t>
<t tx="ekr.20190812072049.143">def removeShell(self, shell):
    """ removeShell()
    Remove an existing shell from the widget
    """
    self._stack.removeWidget(shell)
</t>
<t tx="ekr.20190812072049.144">def onCurrentChanged(self, index):
    """ When another shell is selected, update some things.
    """

    # Get current
    shell = self.getCurrentShell()
    # Call functions
    self.onShellStateChange(shell)
    self.onShellDebugStateChange(shell)
    # Emit Signal
    self.currentShellChanged.emit()
</t>
<t tx="ekr.20190812072049.145">def onShellStateChange(self, shell):
    """ Called when the shell state changes, and is called
    by onCurrentChanged. Sets the mainwindow's icon if busy.
    """
    
    # leo_g.pr('ShellStackWidget.onShellStateChange', repr(pyzo.main))

    # Keep shell button and its menu up-to-date
    self._shellButton.updateShellMenu(shell)

    if shell is self.getCurrentShell(): # can be None
        # Update application icon
        if shell and shell._state in ['Busy']:
            pyzo.main.setWindowIcon(pyzo.iconRunning)
        else:
            pyzo.main.setWindowIcon(pyzo.icon)
        # Send signal
        self.currentShellStateChanged.emit()
</t>
<t tx="ekr.20190812072049.146">def onShellDebugStateChange(self, shell):
    """ Called when the shell debug state changes, and is called
    by onCurrentChanged. Sets the debug button.
    """

    if shell is self.getCurrentShell():

        # Update debug info
        if shell and shell._debugState:
            info = shell._debugState
            self._debugmode = info['debugmode']
            ### EKR:change: add guard.
            if self._debugActions:
                for action in self._debugActions:
                    action.setEnabled(self._debugmode==2)
                self._debugActions[-1].setEnabled(self._debugmode&gt;0)  # Stop
                self._dbs.setTrace(shell._debugState)
        else:
            for action in self._debugActions:
                action.setEnabled(False)
            self._debugmode = 0
            self._dbs.setTrace(None)
        # Send signal
        self.currentShellStateChanged.emit()
</t>
<t tx="ekr.20190812072049.147">def getCurrentShell(self):
    """ getCurrentShell()
    Get the currently active shell.
    """

    w = None
    if self._stack.count():
        w = self._stack.currentWidget()
    if not w:
        return None
    else:
        return w
</t>
<t tx="ekr.20190812072049.148">def getShells(self):
    """ Get all shell in stack as list """

    shells = []
    for i in range(self._stack.count()):
        shell = self.getShellAt(i)
        if shell is not None:
            shells.append(shell)

    return shells
</t>
<t tx="ekr.20190812072049.149">def getShellAt(self, i):
    return
    """ Get shell at current tab index """

    return self._stack.widget(i)
</t>
<t tx="ekr.20190812072049.15">def write(self, text):
    """ Write method. """
    self._original.write(text)
    self._history.append(text)
    try:
        self._deferFunction(text)
    except Exception:
        pass  # self._original.write('error writing to deferred stream')
    # Show in statusbar
    if pyzo.status and len(text)&gt;1:
        pyzo.status.showMessage(text, 5000)
</t>
<t tx="ekr.20190812072049.150">def addContextMenu(self):
    # A bit awkward... but the ShellMenu needs the ShellStack, so it
    # can only be initialized *after* the shellstack is created ...

    # Give shell tool button a menu
    self._shellButton.setMenu(ShellButtonMenu(self, 'Shell button menu'))
    self._shellButton.menu().aboutToShow.connect(self._shellButton._elapsedTimesTimer.start)

    # Also give it a context menu
    self._shellButton.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self._shellButton.customContextMenuRequested.connect(self.contextMenuTriggered)

    # Add actions
    for action in pyzo.main.menuBar()._menumap['shell']._shellActions:
        action = self._toolbar.addAction(action)

    self._toolbar.addSeparator()

    # Add debug actions
    self._debugActions = []
    for action in pyzo.main.menuBar()._menumap['shell']._shellDebugActions:
        self._debugActions.append(action)
        action = self._toolbar.addAction(action)

    # Delayed-add debug control buttons
    self._toolbar.addWidget(self._dbs)
</t>
<t tx="ekr.20190812072049.151">def contextMenuTriggered(self, p):
    """ Called when context menu is clicked """

    # Get index of shell belonging to the tab
    shell = self.getCurrentShell()

    if shell:
        p = self._shellButton.mapToGlobal(self._shellButton.rect().bottomLeft())
        ShellTabContextMenu(shell=shell, parent=self).popup(p)
</t>
<t tx="ekr.20190812072049.152">def onShellAction(self, action):
    shell = self.getCurrentShell()
    if shell:
        getattr(shell, action)()
</t>
<t tx="ekr.20190812072049.153">class ShellControl(QtWidgets.QToolButton):
    """ A button that can be used to select a shell and start a new shell.
    """

    @others
</t>
<t tx="ekr.20190812072049.154">def __init__(self, parent, shellStack):
    QtWidgets.QToolButton.__init__(self, parent)
    
    # print('\nShellControl.__init__: parent:', repr(parent), leo_g.callers())

    # Store reference of shell stack
    self._shellStack = shellStack

    # Keep reference of actions corresponding to shells
    self._shellActions = []

    # Set text and tooltip
    self.setText('Warming up ...')
    self.setToolTip(translate("shells", "Click to select shell."))
    self.setToolButtonStyle(QtCore.Qt.ToolButtonTextBesideIcon)
    self.setPopupMode(self.InstantPopup)

    # Set icon
    self._iconMaker = ShellIconMaker(self)
    self._iconMaker.updateIcon('busy') # Busy initializing

    # Create timer
    self._elapsedTimesTimer = QtCore.QTimer(self)
    self._elapsedTimesTimer.setInterval(200)
    self._elapsedTimesTimer.setSingleShot(False)
    self._elapsedTimesTimer.timeout.connect(self.onElapsedTimesTimer)
</t>
<t tx="ekr.20190812072049.155">def updateShellMenu(self, shellToUpdate=None):
    """ Update the shell menu. Ensure that there is a menu item
    for each shell. If shellToUpdate is given, updates the corresponding
    menu item.
    """
    menu = self.menu()
    if not menu: ### EKR:change.
        return

    # Get shells now active
    currentShell = self._shellStack.currentWidget()
    shells = [self._shellStack.widget(i) for i in range(self._shellStack.count())]

    # Synchronize actions. Remove invalid actions
    for action in self._shellActions:
        # Check match with shells
        if action._shell in shells:
            shells.remove(action._shell)
        else:
            menu.removeAction(action)
        # Update checked state
        if action._shell is currentShell and currentShell:
            action.setChecked(True)
        else:
            action.setChecked(False)
        # Update text if necessary
        if action._shell is shellToUpdate:
            action.setText(shellTitle(shellToUpdate, True))

    # Any items left in shells need a menu item
    # Dont give them an icon, or the icon is used as checkbox thingy
    for shell in shells:
        text = shellTitle(shell)
        action = menu.addItem(text, None, self._shellStack.setCurrentWidget, shell)
            # EKR: This crashes if we aren't using menus.
        action._shell = shell
        action.setCheckable(True)
        self._shellActions.append(action)

    # Is the shell being updated the current?
    if currentShell is shellToUpdate and currentShell is not None:
        self._iconMaker.updateIcon(currentShell._state)
        self.setText(shellTitle(currentShell))
    elif currentShell is None:
        self._iconMaker.updateIcon('')
        self.setText('No shell selected')
</t>
<t tx="ekr.20190812072049.156">def onElapsedTimesTimer(self):
    # Automatically turn timer off is menu is hidden
    if not self.menu().isVisible():
        self._elapsedTimesTimer.stop()
        return

    # Update text for each shell action
    for action in self._shellActions:
        action.setText(shellTitle(action._shell, True))

# todo: remove this?
# class DebugControl(QtWidgets.QToolButton):
#     """ A button to control debugging.
#     """
#
#     def __init__(self, parent):
#         QtWidgets.QToolButton.__init__(self, parent)
#
#         # Flag
#         self._debugmode = False
#
#         # Set text
#         self.setText(translate('debug', 'Debug'))
#         self.setIcon(pyzo.icons.bug)
#         self.setToolButtonStyle(QtCore.Qt.ToolButtonTextBesideIcon)
#         #self.setPopupMode(self.InstantPopup)
#
#         # Bind to triggers
#         self.triggered.connect(self.onTriggered)
#         self.pressed.connect(self.onPressed)
#         self.buildMenu()
#
#
#     def buildMenu(self):
#
#         # Count breakpoints
#         bpcount = 0
#         for e in pyzo.editors:
#             bpcount += len(e.breakPoints())
#
#         # Prepare a text
#         clearallbps = translate('debug', 'Clear all {} breakpoints')
#         clearallbps = clearallbps.format(bpcount)
#
#         # Set menu
#         menu = QtWidgets.QMenu(self)
#         self.setMenu(menu)
#
#         for cmd, enabled, icon, text in [
#                 ('CLEAR', self._debugmode==0, pyzo.icons.bug_delete, clearallbps),
#                 ('PM', self._debugmode==0, pyzo.icons.bug_error,
#                     translate('debug', 'Postmortem: debug from last traceback')),
#                 ('STOP', self._debugmode&gt;0, pyzo.icons.debug_quit,
#                     translate('debug', 'Stop debugging')),
# #                 ('NEXT', self._debugmode==2, pyzo.icons.debug_next,
# #                     translate('debug', 'Next: proceed until next line')),
# #                 ('STEP', self._debugmode==2, pyzo.icons.debug_step,
# #                     translate('debug', 'Step: proceed one step')),
# #                 ('RETURN', self._debugmode==2, pyzo.icons.debug_return,
# #                     translate('debug', 'Return: proceed until returns')),
# #                 ('CONTINUE', self._debugmode==2, pyzo.icons.debug_continue,
# #                     translate('debug', 'Continue: proceed to next breakpoint')),
#                 ]:
#             if cmd is None:
#                 menu.addSeparator()
#             else:
#                 if icon is not None:
#                     a = menu.addAction(icon, text)
#                 else:
#                     a = menu.addAction(text)
#                 if hasattr(text, 'tt'):
#                     a.setToolTip(text.tt)
#                 a.cmd = cmd
#                 a.setEnabled(enabled)
#
#
#     def onPressed(self, show=True):
#         self.buildMenu()
#         self.showMenu()
#
#
#     def onTriggered(self, action):
#         if action.cmd == 'PM':
#             # Initiate postmortem debugging
#             shell = pyzo.shells.getCurrentShell()
#             if shell:
#                 shell.executeCommand('DB START\n')
#
#         elif action.cmd == 'CLEAR':
#             # Clear all breakpoints
#             for e in pyzo.editors:
#                 e.clearBreakPoints()
#
#         else:
#             command = action.cmd.upper()
#             shell = pyzo.shells.getCurrentShell()
#             if shell:
#                 shell.executeCommand('DB %s\n' % command)
#
#
#     def setTrace(self, info):
#         """ Determine whether we are in debug mode.
#         """
#         if info is None:
#             self._debugmode = 0
#         else:
#             self._debugmode = info['debugmode']
</t>
<t tx="ekr.20190812072049.157">class DebugStack(QtWidgets.QToolButton):
    """ A button that shows the stack trace.
    """

    @others
</t>
<t tx="ekr.20190812072049.158">def __init__(self, parent):
    QtWidgets.QToolButton.__init__(self, parent)

    # Set text and tooltip
    self._baseText = translate('debug', 'Stack')
    self.setText('%s:' % self._baseText)
    self.setIcon(pyzo.icons.text_align_justify)
    self.setToolButtonStyle(QtCore.Qt.ToolButtonTextBesideIcon)
    self.setPopupMode(self.InstantPopup)

    # Bind to triggers
    self.triggered.connect(self.onTriggered)
</t>
<t tx="ekr.20190812072049.159">def onTriggered(self, action):

    # Get shell
    shell = pyzo.shells.getCurrentShell()
    if not shell:
        return

    # Change stack index
    if not action._isCurrent:
        shell.executeCommand('DB FRAME {}\n'.format(action._index))
    # Open file and select line
    if True:
        line = action.text().split(': ',1)[1]
        self.debugFocus(line)
</t>
<t tx="ekr.20190812072049.16">def flush(self):
    return self._original.flush()
</t>
<t tx="ekr.20190812072049.160">def setTrace(self, info):
    """ Set the stack trace. This method is called from
    the shell that receives the trace via its status channel
    directly from the interpreter.
    If trace is None, removes the trace
    """

    # Get info
    if info:
        index, frames, debugmode = info['index'], info['frames'], info['debugmode']
    else:
        index, frames = -1, []

    if (not frames) or (debugmode==0):

        # Remove trace
        self.setMenu(None)
        self.setText('')  #(self._baseText)
        self.setEnabled(False)
        pyzo.editors.setDebugLineIndicators(None)

    else:
        # Get the current frame
        theAction = None

        # Create menu and add __main__
        menu = QtWidgets.QMenu(self)
        self.setMenu(menu)

        # Fill trace
        for i in range(len(frames)):
            thisIndex = i + 1
            # Set text for action
            text = '{}: File "{}", line {}, in {}'
            text = text.format(thisIndex, *frames[i])
            action = menu.addAction(text)
            action._index = thisIndex
            action._isCurrent = False
            if thisIndex == index:
                action._isCurrent = True
                theAction = action
                self.debugFocus(text.split(': ',1)[1])  # Load editor

        # Get debug indicators
        debugIndicators = []
        for i in range(len(frames)):
            thisIndex = i + 1
            filename, linenr, func = frames[i]
            debugIndicators.append((filename, linenr))
            if thisIndex == index:
                break
        # Set debug indicators
        pyzo.editors.setDebugLineIndicators(*debugIndicators)

        # Highlight current item and set the button text
        if theAction:
            menu.setDefaultAction(theAction)
            #self.setText(theAction.text().ljust(20))
            i = theAction._index
            text = "{} ({}/{}):  ".format(self._baseText, i, len(frames))
            self.setText(text)

        self.setEnabled(True)
</t>
<t tx="ekr.20190812072049.161">def debugFocus(self, lineFromDebugState):
    """ debugFocus(lineFromDebugState)
    Open the file and show the linenr of the given lineFromDebugState.
    """
    # Get filenr and item
    try:
        tmp = lineFromDebugState.split(', in ')[0].split(', line ')
        filename = tmp[0][len('File '):].strip('"')
        linenr = int(tmp[1].strip())
    except Exception:
        return 'Could not focus!'
    # Cannot open &lt;console&gt;
    if filename == '&lt;console&gt;':
        return 'Stack frame is &lt;console&gt;.'
    elif filename.startswith('&lt;ipython-input-'):
        return 'Stack frame is IPython input.'
    elif filename.startswith('&lt;'):
        return 'Stack frame is special name'
    # Go there!
    result = pyzo.editors.loadFile(filename)
    if not result:
        return 'Could not open file where the error occured.'
    else:
        editor = result._editor
        # Goto line and select it
        editor.gotoLine(linenr)
        cursor = editor.textCursor()
        cursor.movePosition(cursor.StartOfBlock)
        cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
        editor.setTextCursor(cursor)
</t>
<t tx="ekr.20190812072049.162">class InterpreterHelper(QtWidgets.QWidget):
    """ This sits in place of a shell to help the user download miniconda.
    """

    @others
</t>
<t tx="ekr.20190812072049.163">def __init__(self, parent):
    super().__init__(parent)

    self._label = QtWidgets.QLabel('hello world')
    self._label.setTextFormat(QtCore.Qt.RichText)
    self._label.setWordWrap(True)
    # self._label.setOpenExternalLinks(True)
    self._label.linkActivated.connect(self.handle_link)
    font = self._label.font()
    font.setPointSize(font.pointSize()+2)
    self._label.setFont(font)

    layout = QtWidgets.QVBoxLayout()
    self.setLayout(layout)
    layout.addWidget(self._label, 1)
</t>
<t tx="ekr.20190812072049.164">def refresh(self):
    self._label.setText('Detecting interpreters ...')
    QtWidgets.qApp.flush()
    QtWidgets.qApp.processEvents()
    self.detect()
</t>
<t tx="ekr.20190812072049.165">def detect(self):

    # if leo_g: leo_g.pr('shellStack.py: InterpreterHelper.detect')

    python_link = '&lt;a href="https://www.python.org/"&gt;Python&lt;/a&gt;'
    conda_link = '&lt;a href="https://miniconda.pyzo.org"&gt;Miniconda&lt;/a&gt;'
    self._the_exe = None
    configs = pyzo.config.shellConfigs2

    # Hide now?
    if configs and configs[0].exe:
        self._label.setText('Happy coding!')
        QtCore.QTimer.singleShot(1200, self.hide_this)
        return

    # Try to find an interpreter
    from pyzo.util.interpreters import get_interpreters
    interpreters = list(reversed(get_interpreters('2.4')))
    conda_interpreters = [i for i in interpreters if i.is_conda]
    conda_interpreters.sort(key=lambda x:len(x.path.replace('pyzo', 'pyzo'*10)))

    # Always sleep for a bit, so show that we've refreshed
    time.sleep(0.05)

    if conda_interpreters and conda_interpreters[0].version &gt; '3':
        self._the_exe = conda_interpreters[0].path
        text = """Pyzo detected a conda environment in:
                  &lt;br /&gt;%s&lt;br /&gt;&lt;br /&gt;
                  You can &lt;a href='usefound'&gt;use&amp;nbsp;this&amp;nbsp;environment&lt;/a&gt;
                  (recommended), or manually specify an interpreter
                  by setting the exe in the &lt;a href='config'&gt;shell&amp;nbsp;config&lt;/a&gt;.
                  &lt;br /&gt;&lt;br /&gt;Click one of the links above, or &lt;a href='refresh'&gt;refresh&lt;/a&gt;.
               """ % (self._the_exe, )
    elif interpreters and interpreters[0].version &gt; '3':
        self._the_exe = interpreters[0].path
        text = """Pyzo detected a Python interpreter in:
                  &lt;br /&gt;%s&lt;br /&gt;&lt;br /&gt;
                  You can &lt;a href='usefound'&gt;use&amp;nbsp;this&amp;nbsp;environment&lt;/a&gt;
                  (recommended), or manually specify an interpreter
                  by setting the exe in the &lt;a href='config'&gt;shell&amp;nbsp;config&lt;/a&gt;.
                  &lt;br /&gt;&lt;br /&gt;Click one of the links above, or &lt;a href='refresh'&gt;refresh&lt;/a&gt;.
               """ % (self._the_exe, )
    elif interpreters:
        text = """Pyzo detected a Python interpreter,
                  but it is Python 2. We strongly recommend using Python 3 instead.
                  &lt;br /&gt;&lt;br /&gt;
                  If you installed %s or %s in a non-default location,
                  or if you want to manually specify an interpreter,
                  set the exe in the &lt;a href='config'&gt;shell&amp;nbsp;config&lt;/a&gt;.
                  &lt;br /&gt;&lt;br /&gt;Click one of the links above, or &lt;a href='refresh'&gt;refresh&lt;/a&gt;.
               """ % (python_link, conda_link)
    else:
        text = """Pyzo did not detect any Python interpreters.
                  We recomment installing %s or %s
                  (and click &lt;a href='refresh'&gt;refresh&lt;/a&gt; when done).
                  &lt;br /&gt;&lt;br /&gt;
                  If you installed Python or Miniconda in a non-default location,
                  or if you want to manually specify the interpreter,
                  set the exe in the &lt;a href='config'&gt;shell&amp;nbsp;config&lt;/a&gt;.
               """ % (python_link, conda_link)

    link_style = 'font-weight: bold; color:#369; text-decoration:underline;'
    self._label.setText(text.replace('&lt;a ', '&lt;a style="%s" ' % link_style))
</t>
<t tx="ekr.20190812072049.166">def handle_link(self, url):
    if url == 'refresh':
        self.refresh()
    elif url == 'config':
        self.editShellConfig()
    elif url == 'usefound':
        self.useFound()
    elif url.startswith(('http://', 'https://')):
        webbrowser.open(url)
    else:
        raise ValueError('Unknown link in conda helper: %s' % url)
</t>
<t tx="ekr.20190812072049.167">def editShellConfig(self):
    from pyzo.core.shellInfoDialog import ShellInfoDialog
    d = ShellInfoDialog()
    d.exec_()
    self.refresh()
    self.restart_shell()
</t>
<t tx="ekr.20190812072049.168">def useFound(self):
    # Set newfound interpreter
    if self._the_exe:
        configs = pyzo.config.shellConfigs2
        if not configs:
            from pyzo.core.kernelbroker import KernelInfo
            pyzo.config.shellConfigs2.append( KernelInfo() )
        configs[0].exe = self._the_exe
        self.restart_shell()
    self.refresh()
</t>
<t tx="ekr.20190812072049.169">def hide_this(self):
    shells = self.parent()
    shells.showInterpreterHelper(False)
</t>
<t tx="ekr.20190812072049.17">@property
def closed(self):
    return self._original.closed
</t>
<t tx="ekr.20190812072049.170">def restart_shell(self):
    shells = self.parent()
    shell = shells.getCurrentShell()
    if shell is not None:
        shell.closeShell()
    shells.addShell(pyzo.config.shellConfigs2[0])
</t>
<t tx="ekr.20190812072049.171">@path pyzo/core/
@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072049.172"># -*- coding: utf-8 -*-
""" Module splash

Defines splash window shown during startup.

"""

try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo.core.splash.py')
except Exception:
    leo_g = None

import os

import pyzo
from pyzo.util.qt import QtCore, QtGui, QtWidgets  # noqa
from pyzo import translate

STYLESHEET = """
QWidget {
    background-color: #268bd2;
}
QFrame {
    background-image: url("%s");
    background-repeat: no-repeat;
    background-position: center;
}
QLabel {
    color: #222;
    background: #46abf2;
    border-radius:20px;
}
"""

splash_text = """
&lt;p&gt;{text_title}&lt;/p&gt;
&lt;p&gt;{text_version} {version}&lt;/p&gt;
&lt;p&gt;{text_os} &lt;a href='http://pyzo.org/'&gt;http://pyzo.org&lt;/a&gt;&lt;/p&gt;
"""
</t>
<t tx="ekr.20190812072049.173">class LogoWidget(QtWidgets.QFrame):
    @others
</t>
<t tx="ekr.20190812072049.174">def __init__(self, parent):
    QtWidgets.QFrame.__init__(self, parent)
    self.setMinimumSize(256, 256)
    self.setMaximumSize(256, 256)
</t>
<t tx="ekr.20190812072049.175">class LabelWidget(QtWidgets.QWidget):
    @others
</t>
<t tx="ekr.20190812072049.176">def __init__(self, parent, distro=None):
    QtWidgets.QWidget.__init__(self, parent)
    self.setMinimumSize(360, 256)  # Ensure title fits nicely

    # Create label widget and costumize
    self._label = QtWidgets.QLabel(self)
    self._label.setTextFormat(QtCore.Qt.RichText)
    self._label.setOpenExternalLinks(True)
    self._label.setWordWrap(True)
    self._label.setMargin(20)

    # Set font size (absolute value)
    font = self._label.font()
    font.setPointSize(11)  #(font.pointSize()+1)
    self._label.setFont(font)

    # Build
    text_title = translate('splash', 'This is &lt;b&gt;Pyzo&lt;/b&gt;&lt;br /&gt;the Python IDE for scientific computing')
    text_version = translate('splash', 'Version')
    text_os = translate('splash', 'Pyzo is open source software and freely available for everyone.')
    text = splash_text.format(version=pyzo.__version__,
                              text_title=text_title, text_version=text_version, text_os=text_os)

    # Set text
    self._label.setText(text)

    layout = QtWidgets.QVBoxLayout(self)
    self.setLayout(layout)
    layout.addStretch(1)
    layout.addWidget(self._label, 0)
    layout.addStretch(1)
</t>
<t tx="ekr.20190812072049.177">class SplashWidget(QtWidgets.QWidget):
    """ A splash widget.
    """
    @others
if __name__ == '__main__':
    w = SplashWidget(None, distro='some arbitrary distro')
    w.resize(800,600)
    w.show()
</t>
<t tx="ekr.20190812072049.178">def __init__(self, parent, **kwargs):
    QtWidgets.QWidget.__init__(self, parent)
    
    # if leo_g: leo_g.pr('SplashWidget.__init__')

    self._left = LogoWidget(self)
    self._right = LabelWidget(self, **kwargs)

    # Layout
    layout = QtWidgets.QHBoxLayout(self)
    self.setLayout(layout)
    #layout.setContentsMargins(0,0,0,0)
    layout.setSpacing(25)
    layout.addStretch(1)
    layout.addWidget(self._left, 0)
    layout.addWidget(self._right, 0)
    layout.addStretch(1)

    # Change background of main window to create a splash-screen-efefct
    iconImage = 'pyzologo256.png'
    iconImage = os.path.join(pyzo.pyzoDir, 'resources','appicons', iconImage)
    iconImage = iconImage.replace(os.path.sep, '/') # Fix for Windows
    self.setStyleSheet(STYLESHEET % iconImage)
</t>
<t tx="ekr.20190812072049.179">@path pyzo/core/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.18">def close(self):
    return self._original.close()
</t>
<t tx="ekr.20190812072049.180"># -*- coding: utf-8 -*-
""" Package core - the core of Pyzo.
"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('IMPORT pyzo.core')
except Exception:
    leo_g = None
</t>
<t tx="ekr.20190812072049.182"></t>
<t tx="ekr.20190812072049.183">@path pyzo/pyzokernel/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.184"># -*- coding: utf-8 -*-
import os
import sys
import time
import bdb
import traceback
</t>
<t tx="ekr.20190812072049.185">class Debugger(bdb.Bdb):
    """ Debugger for the pyzo kernel, based on bdb.
    """

    @others
</t>
<t tx="ekr.20190812072049.186">def __init__(self):
    self._wait_for_mainpyfile = False  # from pdb, do we need this?
    bdb.Bdb.__init__(self)
    self._debugmode = 0  # 0: no debug,  1: postmortem,  2: full debug
    self._files_with_offset = []
</t>
<t tx="ekr.20190812072049.187">def clear_all_breaks(self):
    bdb.Bdb.clear_all_breaks(self)
    self._files_with_offset = []
</t>
<t tx="ekr.20190812072049.188">def trace_dispatch(self, frame, event, arg):
    # Overload to deal with offset in filenames
    # (cells or lines being executed)
    ori_filename = frame.f_code.co_filename

    if '+' in ori_filename and ori_filename not in self._files_with_offset:
        clean_filename, offset = ori_filename.rsplit('+', 1)
        try:
            offset = int(offset)
        except Exception:
            offset = None
        if offset is not None:
            # This is a cell or selected lines being executed
            self._files_with_offset.append(ori_filename)
            if clean_filename.startswith('&lt;'):
                self.fncache[ori_filename] = ori_filename
            for i in self.breaks.get(clean_filename, []):
                self.set_break(ori_filename, i-offset)

    return bdb.Bdb.trace_dispatch(self, frame, event, arg)
</t>
<t tx="ekr.20190812072049.189">def interaction(self, frame, traceback=None, pm=False):
    """ Enter an interaction-loop for debugging. No GUI events are
    processed here. We leave this event loop at some point, after
    which the conrol flow will proceed.

    This is called to enter debug-mode at a breakpoint, or to enter
    post-mortem debugging.
    """
    interpreter = sys._pyzoInterpreter

    # Collect frames
    frames = []
    while frame:
        if frame is self.botframe: break
        co_filename = frame.f_code.co_filename
        if 'pyzokernel' in co_filename: break  # pyzo kernel
        if 'interactiveshell.py' in co_filename: break  # IPython kernel
        frames.insert(0, frame)
        frame = frame.f_back

    # Tell interpreter our stack
    if frames:
        interpreter._dbFrames = frames
        interpreter._dbFrameIndex = len(interpreter._dbFrames)
        frame = interpreter._dbFrames[interpreter._dbFrameIndex-1]
        interpreter._dbFrameName = frame.f_code.co_name
        interpreter.locals = frame.f_locals
        interpreter.globals = frame.f_globals

    # Let the IDE know (
    # "self._debugmode = 1 if pm else 2" does not work not on py2.4)
    if pm:
        self._debugmode = 1
    else:
        self._debugmode = 2
    self.writestatus()

    # Enter interact loop. We may hang in here for a while ...
    self._interacting = True
    while self._interacting:
        time.sleep(0.05)
        interpreter.process_commands()
        pe = os.getenv('PYZO_PROCESS_EVENTS_WHILE_DEBUGGING', '').lower()
        if pe in ('1', 'true', 'yes'):
            interpreter.guiApp.process_events()

    # Reset
    self._debugmode = 0
    interpreter.locals = interpreter._main_locals
    interpreter.globals = None
    interpreter._dbFrames = []
    self.writestatus()
</t>
<t tx="ekr.20190812072049.19">def encoding(self):
    return self._original.encoding()

</t>
<t tx="ekr.20190812072049.190">def stopinteraction(self):
    """ Stop the interaction loop.
    """
    self._interacting = False
</t>
<t tx="ekr.20190812072049.191">def set_on(self):
    """ To turn debugging on right before executing code.
    """
    # Reset and set bottom frame
    self.reset()
    self.botframe = sys._getframe().f_back
    # Don't stop except at breakpoints or when finished
    # We do: self._set_stopinfo(self.botframe, None, -1) from set_continue
    # But write it all out because py2.4 does not have _set_stopinfo
    self.stopframe = self.botframe
    self.returnframe = None
    self.quitting = False
    self.stoplineno = -1
    # Set tracing or not
    if self.breaks:
        sys.settrace(self.trace_dispatch)
    else:
        sys.settrace(None)
</t>
<t tx="ekr.20190812072049.192">def message(self, msg):
    """ Alias for interpreter.write(), but appends a newline.
    Writes to stderr.
    """
    sys._pyzoInterpreter.write(msg+'\n')
</t>
<t tx="ekr.20190812072049.193">def error(self, msg):
    """ method used in some code that we copied from pdb.
    """
    raise self.message('*** '+msg)
</t>
<t tx="ekr.20190812072049.194">def writestatus(self):
    """ Write the debug status so the IDE can take action.
    """

    interpreter = sys._pyzoInterpreter

    # Collect frames info
    frames = []
    for f in interpreter._dbFrames:
        # Get fname and lineno, and correct if required
        fname, lineno = f.f_code.co_filename, f.f_lineno
        fname, lineno = interpreter.correctfilenameandlineno(fname, lineno)
        if not fname.startswith('&lt;'):
            fname2 = os.path.abspath(fname)
            if os.path.isfile(fname2):
                fname = fname2
        frames.append((fname, lineno, f.f_code.co_name))
        # Build string
        #text = 'File "%s", line %i, in %s' % (
        #                        fname, lineno, f.f_code.co_name)
        #frames.append(text)

    # Send info object
    state = {   'index': interpreter._dbFrameIndex,
                'frames': frames,
                'debugmode': self._debugmode}
    interpreter.context._stat_debug.send(state)

## Stuff that we need to overload

# Overload set_break to also allow non-existing filenames like "&lt;tmp 1"
</t>
<t tx="ekr.20190812072049.195">def set_break(self, filename, lineno, temporary=False, cond=None,
              funcname=None):
    filename = self.canonic(filename)
    list = self.breaks.setdefault(filename, [])
    if lineno not in list:
        list.append(lineno)
    bdb.Breakpoint(filename, lineno, temporary, cond, funcname)

# Prevent stopping in bdb code or pyzokernel code
</t>
<t tx="ekr.20190812072049.196">def stop_here(self, frame):
    result = bdb.Bdb.stop_here(self, frame)
    if result:
        return (    ('bdb.py' not in frame.f_code.co_filename) and
                    ('pyzokernel' not in frame.f_code.co_filename) )
</t>
<t tx="ekr.20190812072049.197">def do_clear(self, arg):
    """"""
    # Clear breakpoints, we need to overload from Bdb,
    # but do not expose this command to the user.
    """cl(ear) filename:lineno\ncl(ear) [bpnumber [bpnumber...]]
    With a space separated list of breakpoint numbers, clear
    those breakpoints.  Without argument, clear all breaks (but
    first ask confirmation).  With a filename:lineno argument,
    clear all breaks at that line in that file.
    """
    if not arg:
        bplist = [bp for bp in bdb.Breakpoint.bpbynumber if bp]
        self.clear_all_breaks()
        for bp in bplist:
            self.message('Deleted %s' % bp)
        return
    if ':' in arg:
        # Make sure it works for "clear C:\foo\bar.py:12"
        i = arg.rfind(':')
        filename = arg[:i]
        arg = arg[i+1:]
        try:
            lineno = int(arg)
        except ValueError:
            err = "Invalid line number (%s)" % arg
        else:
            bplist = self.get_breaks(filename, lineno)
            err = self.clear_break(filename, lineno)
        if err:
            self.error(err)
        else:
            for bp in bplist:
                self.message('Deleted %s' % bp)
        return
    numberlist = arg.split()
    for i in numberlist:
        try:
            bp = self.get_bpbynumber(i)
        except ValueError:
            self.error("Cannot get breakpoint by number.")
        else:
            self.clear_bpbynumber(i)
            self.message('Deleted %s' % bp)
</t>
<t tx="ekr.20190812072049.198">def user_call(self, frame, argument_list):
    """This method is called when there is the remote possibility
    that we ever need to stop in this function."""
    if self._wait_for_mainpyfile:
        return
    if self.stop_here(frame):
        self.message('--Call--')
        self.interaction(frame, None)
</t>
<t tx="ekr.20190812072049.199">def user_line(self, frame):
    """This function is called when we stop or break at this line."""
    if self._wait_for_mainpyfile:
        if (self.mainpyfile != self.canonic(frame.f_code.co_filename) or frame.f_lineno &lt;= 0):
            return
        self._wait_for_mainpyfile = False
    if True: #self.bp_commands(frame):  from pdb
        self.interaction(frame, None)
</t>
<t tx="ekr.20190812072049.2"># -*- coding: utf-8 -*-
""" Module logging

Functionality for logging in pyzo.
"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo/core/pyzoLogging.py')
except Exception:
    leo_g = None
import sys, time
import pyzo

pyzo.status = None

# todo: enable logging to a file?
# Define prompts
try:
    sys.ps1
except AttributeError:
    sys.ps1 = "&gt;&gt;&gt; "
try:
    sys.ps2
except AttributeError:
    sys.ps2 = "... "
</t>
<t tx="ekr.20190812072049.20">@path pyzo/core/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.200">def user_return(self, frame, return_value):
    """This function is called when a return trap is set here."""
    if self._wait_for_mainpyfile:
        return
    frame.f_locals['__return__'] = return_value
    self.message('--Return--')
    self.interaction(frame, None)
</t>
<t tx="ekr.20190812072049.201">def user_exception(self, frame, exc_info):
    """This function is called if an exception occurs,
    but only if we are to stop at or just below this level."""
    if self._wait_for_mainpyfile:
        return
    exc_type, exc_value, exc_traceback = exc_info
    frame.f_locals['__exception__'] = exc_type, exc_value
    self.message(traceback.format_exception_only(exc_type,
                                                 exc_value)[-1].strip())
    self.interaction(frame, exc_traceback)

## Commands
</t>
<t tx="ekr.20190812072049.202">def do_help(self, arg):
    """ Get help on debug commands.
    """
    # Collect docstrings
    docs = {}
    for name in dir(self):
        if name.startswith('do_'):
            doc = getattr(self, name).__doc__
            if doc:
                docs[name[3:]] = doc.strip()

    if not arg:
        print('All debug commands:')
        # Show docs in  order
        for name in [   'start', 'stop', 'frame', 'up', 'down',
                        'next', 'step','return', 'continue',
                        'where', 'events']:
            doc = docs.pop(name)
            name= name.rjust(10)
            print(' %s - %s' % (name, doc))
        # Show rest
        for name in docs:
            doc = docs[name]
            name= name.rjust(10)
            print(' %s - %s' % (name, doc))

    else:
        # Show specific doc
        name = arg.lower()
        doc = docs.get(name, None)
        if doc is not None:
            print('%s - %s' % (name, doc))
        else:
            print('Unknown debug command: %s' % name)
</t>
<t tx="ekr.20190812072049.203">def do_start(self, arg):
    """ Start postmortem debugging from the last uncaught exception.
    """

    # Get traceback
    try:
        tb = sys.last_traceback
    except AttributeError:
        tb = None

    # Get top frame
    frame = None
    while tb:
        frame = tb.tb_frame
        tb = tb.tb_next

    # Interact, or not
    if self._debugmode:
        self.message("Already in debug mode.")
    elif frame:
        self.interaction(frame, None, pm=True)
    else:
        self.message("No debug information available.")
</t>
<t tx="ekr.20190812072049.204">def do_frame(self, arg):
    """ Go to the i'th frame in the stack.
    """
    interpreter = sys._pyzoInterpreter

    if not self._debugmode:
        self.message("Not in debug mode.")
    else:
        # Set frame index
        interpreter._dbFrameIndex = int(arg)
        if interpreter._dbFrameIndex &lt; 1:
            interpreter._dbFrameIndex = 1
        elif interpreter._dbFrameIndex &gt; len(interpreter._dbFrames):
            interpreter._dbFrameIndex = len(interpreter._dbFrames)
        # Set name and locals
        frame = interpreter._dbFrames[interpreter._dbFrameIndex-1]
        interpreter._dbFrameName = frame.f_code.co_name
        interpreter.locals = frame.f_locals
        interpreter.globals = frame.f_globals
        self.writestatus()
</t>
<t tx="ekr.20190812072049.205">def do_up(self, arg):
    """ Go one frame up the stack.
    """
    interpreter = sys._pyzoInterpreter

    if not self._debugmode:
        self.message("Not in debug mode.")
    else:
        # Decrease frame index
        interpreter._dbFrameIndex -= 1
        if interpreter._dbFrameIndex &lt; 1:
            interpreter._dbFrameIndex = 1
        # Set name and locals
        frame = interpreter._dbFrames[interpreter._dbFrameIndex-1]
        interpreter._dbFrameName = frame.f_code.co_name
        interpreter.locals = frame.f_locals
        interpreter.globals = frame.f_globals
        self.writestatus()
</t>
<t tx="ekr.20190812072049.206">def do_down(self, arg):
    """ Go one frame down the stack.
    """
    interpreter = sys._pyzoInterpreter

    if not self._debugmode:
        self.message("Not in debug mode.")
    else:
        # Increase frame index
        interpreter._dbFrameIndex += 1
        if interpreter._dbFrameIndex &gt; len(interpreter._dbFrames):
            interpreter._dbFrameIndex = len(interpreter._dbFrames)
        # Set name and locals
        frame = interpreter._dbFrames[interpreter._dbFrameIndex-1]
        interpreter._dbFrameName = frame.f_code.co_name
        interpreter.locals = frame.f_locals
        interpreter.globals = frame.f_globals
        self.writestatus()
</t>
<t tx="ekr.20190812072049.207">def do_stop(self, arg):
    """ Stop debugging, terminate process execution.
    """
    # Can be done both in postmortem and normal debugging
    if not self._debugmode:
        self.message("Not in debug mode.")
    else:
        self.set_quit()
        self.stopinteraction()
</t>
<t tx="ekr.20190812072049.208">def do_where(self, arg):
    """ Print the stack trace and indicate the current frame.
    """
    interpreter = sys._pyzoInterpreter

    if not self._debugmode:
        self.message("Not in debug mode.")
    else:
        lines = []
        for i in range(len(interpreter._dbFrames)):
            frameIndex = i+1
            f = interpreter._dbFrames[i]
            # Get fname and lineno, and correct if required
            fname, lineno = f.f_code.co_filename, f.f_lineno
            fname, lineno = interpreter.correctfilenameandlineno(fname,
                                                                    lineno)
            # Build string
            text = 'File "%s", line %i, in %s' % (
                                    fname, lineno, f.f_code.co_name)
            if frameIndex == interpreter._dbFrameIndex:
                lines.append('-&gt; %i: %s'%(frameIndex, text))
            else:
                lines.append('   %i: %s'%(frameIndex, text))
        lines.append('')
        sys.stdout.write('\n'.join(lines))
</t>
<t tx="ekr.20190812072049.209">def do_continue(self, arg):
    """ Continue the program execution.
    """
    if self._debugmode == 0:
        self.message("Not in debug mode.")
    elif self._debugmode == 1:
        self.message("Cannot use 'continue' in postmortem debug mode.")
    else:
        self.set_continue()
        self.stopinteraction()
</t>
<t tx="ekr.20190812072049.21"># -*- coding: utf-8 -*-
""" Module shell

Defines the shell to be used in pyzo.
This is done in a few inheritance steps:
  - BaseShell inherits BaseTextCtrl and adds the typical shell behaviour.
  - PythonShell makes it specific to Python.
This module also implements ways to communicate with the shell and to run
code in it.

"""

try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo/core/shell.py')
except Exception:
    leo_g = None
import sys, time
import re

import yoton

import pyzo
from pyzo.util import zon as ssdf  # zon is ssdf-light
from pyzo.util.qt import QtCore, QtGui, QtWidgets
Qt = QtCore.Qt

from pyzo.codeeditor.highlighter import Highlighter
from pyzo.codeeditor import parsers

from pyzo.core.baseTextCtrl import BaseTextCtrl
from pyzo.core.pyzoLogging import print
from pyzo.core.kernelbroker import KernelInfo, Kernelmanager
from pyzo.core.menu import ShellContextMenu

# Interval for polling messages. Timer for each kernel. I found
# that this one does not affect performance much
POLL_TIMER_INTERVAL = 30 # 30 ms 33Hz

# Maximum number of lines in the shell
MAXBLOCKCOUNT = pyzo.config.advanced.shellMaxLines

# todo: we could make command shells to, with autocompletion and coloring...
</t>
<t tx="ekr.20190812072049.210">def do_step(self, arg):
    """ Execute the current line, stop ASAP (step into).
    """
    if self._debugmode == 0:
        self.message("Not in debug mode.")
    elif self._debugmode == 1:
        self.message("Cannot use 'step' in postmortem debug mode.")
    else:
        self.set_step()
        self.stopinteraction()
</t>
<t tx="ekr.20190812072049.211">def do_next(self, arg):
    """ Continue execution until the next line (step over).
    """
    interpreter = sys._pyzoInterpreter

    if self._debugmode == 0:
        self.message("Not in debug mode.")
    elif self._debugmode == 1:
        self.message("Cannot use 'next' in postmortem debug mode.")
    else:
        frame = interpreter._dbFrames[-1]
        self.set_next(frame)
        self.stopinteraction()
</t>
<t tx="ekr.20190812072049.212">def do_return(self, arg):
    """ Continue execution until the current function returns (step out).
    """
    interpreter = sys._pyzoInterpreter

    if self._debugmode == 0:
        self.message("Not in debug mode.")
    elif self._debugmode == 1:
        self.message("Cannot use 'return' in postmortem debug mode.")
    else:
        frame = interpreter._dbFrames[-1]
        self.set_return(frame)
        self.stopinteraction()
</t>
<t tx="ekr.20190812072049.213">def do_events(self, arg):
    """ Process GUI events for the integrated GUI toolkit.
    """
    interpreter = sys._pyzoInterpreter
    interpreter.guiApp.process_events()
</t>
<t tx="ekr.20190812072049.214">@path pyzo/pyzokernel/
@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072049.215"># -*- coding: utf-8 -*-
"""
Module to integrate GUI event loops in the Pyzo interpreter.

This specifies classes that all have the same interface. Each class
wraps one GUI toolkit.

Support for PyQt4, WxPython, FLTK, GTK, TK.

"""

import sys
import time

from pyzokernel import printDirect

# Warning message.
mainloopWarning = """
Note: The GUI event loop is already running in the pyzo kernel. Be aware
that the function to enter the main loop does not block.
""".strip()+"\n"

# Qt has its own message
mainloopWarning_qt = """
Note on using QApplication.exec_():
The GUI event loop is already running in the pyzo kernel, and exec_()
does not block. In most cases your app should run fine without the need
for modifications. For clarity, this is what the pyzo kernel does:
- Prevent deletion of objects in the local scope of functions leading to exec_()
- Prevent system exit right after the exec_() call
""".lstrip()

# Print the main loop warning at most once
_printed_warning = False
</t>
<t tx="ekr.20190812072049.216">def print_mainloop_warning(msg=None):
    global _printed_warning
    if not _printed_warning:
        _printed_warning = True
        msg = msg or mainloopWarning
        printDirect(msg)
</t>
<t tx="ekr.20190812072049.217">class App_base:
    """ Defines the interface.
    """

    @others
</t>
<t tx="ekr.20190812072049.218">def process_events(self):
    pass
</t>
<t tx="ekr.20190812072049.219">def _keyboard_interrupt(self, signum=None, frame=None):
    interpreter = sys._pyzoInterpreter
    interpreter.write("\nKeyboardInterrupt\n")
    interpreter._resetbuffer()
    if interpreter.more:
        interpreter.more = 0
        interpreter.newPrompt = True
</t>
<t tx="ekr.20190812072049.22">class YotonEmbedder(QtCore.QObject):
    """ Embed the Yoton event loop.
    """

    @others
yotonEmbedder = YotonEmbedder()

# Short constants for cursor movement
A_KEEP = QtGui.QTextCursor.KeepAnchor
A_MOVE = QtGui.QTextCursor.MoveAnchor

# Instantiate a local kernel broker upon loading this module
pyzo.localKernelManager = Kernelmanager(public=False)
</t>
<t tx="ekr.20190812072049.220">def run(self, repl_callback, sleeptime=0.01):
    """ Very simple mainloop. Subclasses can overload this to use
    the native event loop. Attempt to process GUI events at least
    every sleeptime seconds.
    """

    if hasattr(time, 'perf_counter'):
        perf_counter= time.perf_counter
    else:
        perf_counter = time.time

    _sleeptime = sleeptime

    # The toplevel while-loop is just to catch Keyboard interrupts
    # and then proceed. The inner while-loop is the actual event loop.
    while True:
        try:

            while True:
                time.sleep(_sleeptime)
                repl_callback()
                self.process_events()

        except KeyboardInterrupt:
            self._keyboard_interrupt()
        except TypeError:
            # For some reason, when wx is integrated, keyboard interrupts
            # result in a TypeError.
            # I tried to find the source, but did not find it. If anyone
            # has an idea, please e-mail me!
            if '_wx' in self.__class__.__name__.lower():
                self._keyboard_interrupt()
</t>
<t tx="ekr.20190812072049.221">def quit(self):
    raise SystemExit()
</t>
<t tx="ekr.20190812072049.222">class App_asyncio(App_base):
    """ Based on asyncio (standard Python) event loop.

    We do not run the event loop and a timer to keep the REPL active, because
    asyncio does allow creating new loops while one is running. So we stick to
    a simple and non-intrusive mechanism to regularly process events from
    whatever event loop is current at any given moment.

    """

    @others
</t>
<t tx="ekr.20190812072049.223">def __init__(self):
    import asyncio
    self.app = asyncio.get_event_loop()
    self.app._in_event_loop = 'Pyzo'
    self._warned_about_process_events = False
    self._blocking = False

    # Hijack

    # Prevent entering forever, not giving control back to repl
    self.app._original_run_forever = self.app.run_forever
    self.app.run_forever = self.stub_run_forever
    # The run_until_complete() calls run_forever and then checks that future completed
    self.app._original_run_until_complete = self.app.run_until_complete
    self.app.run_until_complete = self.stub_run_until_complete
    # Prevent the loop from being destroyed
    self.app._original_close = self.app.close
    self.app.close = self.stub_close
    # Stop is fine, since we don't "run" the loop, but just keep it active
</t>
<t tx="ekr.20190812072049.224">def stub_run_until_complete(self, *args):
    self._blocking = True
    return self.app._original_run_until_complete(*args)
</t>
<t tx="ekr.20190812072049.225">def stub_run_forever(self):
    if self._blocking:
        self._blocking = False
        self.app._original_run_forever()
</t>
<t tx="ekr.20190812072049.226">def stub_close(self):
    pass
</t>
<t tx="ekr.20190812072049.227">def process_events(self):
    loop = self.app
    if loop.is_closed():
        pass  # not much we can do
    elif loop.is_running():
        if not self._warned_about_process_events:
            print('Warning: cannot process events synchronously in asyncio')
            self._warned_about_process_events = True
    else:
        # First calling stop and then run_forever() process all pending events.
        # We do this multiple times to work around the limited frequence that this
        # method gets called, but we need to use a private attribute for that :/
        for i in range(20):
            loop.stop()
            loop._original_run_forever()
            if len(getattr(loop, '_ready', ())) == 0:
                break
</t>
<t tx="ekr.20190812072049.228">def quit(self):
    loop = self.app
    try:
        if not loop.is_closed():
            loop.close()
    finally:
        raise SystemExit()
</t>
<t tx="ekr.20190812072049.229">class App_tk(App_base):
    """ Tries to import tkinter and returns a withdrawn tkinter root
    window.  If tkinter is already imported or not available, this
    returns None.
    Modifies tkinter's mainloop with a dummy so when a module calls
    mainloop, it does not block.
    """
    @others
</t>
<t tx="ekr.20190812072049.23">def __init__(self):
    QtCore.QObject.__init__(self)
    yoton.app.embed_event_loop(self.postYotonEvent)
</t>
<t tx="ekr.20190812072049.230">def __init__(self):

    # Try importing
    import sys
    if sys.version[0] == '3':
        import tkinter
    else:
        import Tkinter as tkinter

    # Replace mainloop. Note that a root object obtained with
    # tkinter.Tk() has a mainloop method, which will simply call
    # tkinter.mainloop().
    def dummy_mainloop(*args,**kwargs):
        print_mainloop_warning()
    tkinter.Misc.mainloop = dummy_mainloop
    tkinter.mainloop = dummy_mainloop

    # Create tk "main window" that has a Tcl interpreter.
    # Withdraw so it's not shown. This object can be used to
    # process events for any other windows.
    r = tkinter.Tk()
    r.withdraw()

    # Store the app instance to process events
    self.app = r

    # Notify that we integrated the event loop
    self.app._in_event_loop = 'Pyzo'
    tkinter._in_event_loop = 'Pyzo'
</t>
<t tx="ekr.20190812072049.231">def process_events(self):
    self.app.update()
</t>
<t tx="ekr.20190812072049.232">class App_fltk(App_base):
    """ Hijack fltk 1.
    This one is easy. Just call fl.wait(0.0) now and then.
    Note that both tk and fltk try to bind to PyOS_InputHook. Fltk
    will warn about not being able to and Tk does not, so we should
    just hijack (import) fltk first. The hook that they try to fetch
    is not required in pyzo, because the pyzo interpreter will keep
    all GUI backends updated when idle.
    """
    @others
</t>
<t tx="ekr.20190812072049.233">def __init__(self):
    # Try importing
    import fltk as fl
    import types

    # Replace mainloop with a dummy
    def dummyrun(*args,**kwargs):
        print_mainloop_warning()
    fl.Fl.run = types.MethodType(dummyrun, fl.Fl)

    # Store the app instance to process events
    self.app =  fl.Fl

    # Notify that we integrated the event loop
    self.app._in_event_loop = 'Pyzo'
    fl._in_event_loop = 'Pyzo'
</t>
<t tx="ekr.20190812072049.234">def process_events(self):
    self.app.wait(0)
</t>
<t tx="ekr.20190812072049.235">class App_fltk2(App_base):
    """ Hijack fltk 2.
    """
    @others
</t>
<t tx="ekr.20190812072049.236">def __init__(self):
    # Try importing
    import fltk2 as fl

    # Replace mainloop with a dummy
    def dummyrun(*args,**kwargs):
        print_mainloop_warning()
    fl.run = dummyrun

    # Return the app instance to process events
    self.app = fl

    # Notify that we integrated the event loop
    self.app._in_event_loop = 'Pyzo'
</t>
<t tx="ekr.20190812072049.237">def process_events(self):
    # is this right?
    self.app.wait(0)
</t>
<t tx="ekr.20190812072049.238">class App_tornado(App_base):
    """ Hijack Tornado event loop.

    Tornado does have a function to process events, but it does not
    work when the event loop is already running. Therefore we don't
    enter the real Tornado event loop, but just poll it regularly.
    """

    @others
</t>
<t tx="ekr.20190812072049.239">def __init__(self):
    # Try importing
    import tornado.ioloop

    # Get the "app" instance
    self.app = tornado.ioloop.IOLoop.instance()

    # Replace mainloop with a dummy
    def dummy_start():
        print_mainloop_warning()
        sys._pyzoInterpreter.ignore_sys_exit = True
        self.app.add_callback(reset_sys_exit)
    def dummy_stop():
        pass
    def reset_sys_exit():
        sys._pyzoInterpreter.ignore_sys_exit = False
    def run_sync(func, timeout=None):
        self.app.start = self.app._original_start
        try:
            self.app._original_run_sync(func, timeout)
        finally:
            self.app.start = self.app._dummy_start
    #
    self.app._original_start = self.app.start
    self.app._dummy_start = dummy_start
    self.app.start = self.app._dummy_start
    #
    self.app._original_stop = self.app.stop
    self.app._dummy_stop = dummy_stop
    self.app.stop = self.app._dummy_stop
    #
    self.app._original_run_sync = self.app.run_sync
    self.app.run_sync = run_sync

    # Notify that we integrated the event loop
    self.app._in_event_loop = 'Pyzo'

    self._warned_about_process_events = False
</t>
<t tx="ekr.20190812072049.24">def postYotonEvent(self):
    try:
        QtWidgets.qApp.postEvent(self, QtCore.QEvent(QtCore.QEvent.User))
    except Exception:
        pass # If pyzo is shutting down, the app may be None
</t>
<t tx="ekr.20190812072049.240">def process_events(self):
    if not self._warned_about_process_events:
        print('Warning: cannot process events synchronously in Tornado')
        self._warned_about_process_events = True
    #self.app.run_sync(lambda x=None: None)
</t>
<t tx="ekr.20190812072049.241">def run(self, repl_callback, sleeptime=None):
    from tornado.ioloop import PeriodicCallback
    # Create timer
    self._timer = PeriodicCallback(repl_callback, 0.05*1000)
    self._timer.start()
    # Enter mainloop
    self.app._original_start()
    while True:
        try:
            self.app._original_start()
        except KeyboardInterrupt:
            self._keyboard_interrupt()
            self.app._original_stop()
            continue
        break
</t>
<t tx="ekr.20190812072049.242">def quit(self):
    self.app._original_stop()
    # raise SystemExit()
</t>
<t tx="ekr.20190812072049.243">class App_qt(App_base):
    """ Common functionality for pyqt and pyside
    """

    @others
</t>
<t tx="ekr.20190812072049.244">def __init__(self):
    import types

    # Try importing qt
    QtGui, QtCore = self.importCoreAndGui()
    self._QtGui, self._QtCore = QtGui, QtCore

    # Store the real application class
    if not hasattr(QtGui, 'real_QApplication'):
        QtGui.real_QApplication = QtGui.QApplication

    class QApplication_hijacked(QtGui.QApplication):
        """ QApplication_hijacked(*args, **kwargs)

        Hijacked QApplication class. This class has a __new__()
        method that always returns the global application
        instance, i.e. QtGui.qApp.

        The QtGui.qApp instance is an instance of the original
        QtGui.QApplication, but with its __init__() and exec_()
        methods replaced.

        You can subclass this class; the global application instance
        will be given the methods and attributes so it will behave
        like the subclass.
        """
        def __new__(cls, *args, **kwargs):

            # Get the singleton application instance
            theApp = QApplication_hijacked.instance()

            # Instantiate an original QApplication instance if we need to
            if theApp is None:
                theApp = QtGui.real_QApplication(*args, **kwargs)
                QtGui.qApp = theApp

            # Add attributes of cls to the instance to make it
            # behave as if it were an instance of that class
            for key in dir(cls):
                # Skip all magic methods except __init__
                if key.startswith('__') and key != '__init__':
                    continue
                # Skip attributes that we already have
                val = getattr(cls, key)
                if hasattr(theApp.__class__, key):
                    if hash(val) == hash(getattr(theApp.__class__, key)):
                        continue
                # Make method?
                if hasattr(val, '__call__'):
                    if hasattr(val, 'im_func'):
                        val = val.im_func # Python 2.x
                    val = types.MethodType(val, theApp.__class__)
                # Set attribute on app instance (not the class!)
                try:
                    setattr(theApp, key, val)
                except Exception:
                    pass # tough luck

            # Call init function (in case the user overloaded it)
            theApp.__init__(*args, **kwargs)

            # Return global app object (modified to the users needs)
            return theApp

        def __init__(self, *args, **kwargs):
            pass

        def exec_(self, *args, **kwargs):
            """ This function does nothing, except printing a
            warning message. The point is that a Qt App can crash
            quite hard if an object goes out of scope, and the error
            is not obvious.
            """
            print_mainloop_warning(mainloopWarning_qt)

            # Store local namespaces (scopes) of any functions that
            # precede this call. It might have a widget or application
            # object that should not be deleted ...
            import inspect, __main__
            for caller in inspect.stack()[1:]:
                frame, name = caller[0], caller[3]
                if name.startswith('&lt;'):  # most probably "&lt;module&gt;"
                    break
                else:
                    __main__.__dict__[name+'_locals'] = frame.f_locals

            # Tell interpreter to ignore any system exits
            sys._pyzoInterpreter.ignore_sys_exit = True

            # But re-enable it as soon as *this event* is processed
            def reEnableSysExit():
                sys._pyzoInterpreter.ignore_sys_exit = False
            self._reEnableSysExitTimer = timer = QtCore.QTimer()
            timer.singleShot(0, reEnableSysExit)

        def quit(self, *args, **kwargs):
            """ Do not quit if Qt app quits. """
            pass

    # Instantiate application object
    self.app = QApplication_hijacked([''])

    # Keep it alive even if all windows are closed
    self.app.setQuitOnLastWindowClosed(False)

    # Replace app class
    QtGui.QApplication = QApplication_hijacked

    # Notify that we integrated the event loop
    self.app._in_event_loop = 'Pyzo'
    QtGui._in_event_loop = 'Pyzo'

    # Use sys.excepthook to catch keyboard interrupts that occur
    # in event handlers. We also want to call the curren hook
    self._original_excepthook = sys.excepthook
    sys.excepthook = self._excepthook
</t>
<t tx="ekr.20190812072049.245">def _excepthook(self, type, value, traceback):
    if issubclass(type, KeyboardInterrupt):
        self._keyboard_interrupt()
    elif self._original_excepthook is not None:
        return self._original_excepthook(type, value, traceback)
</t>
<t tx="ekr.20190812072049.246">def process_events(self):
    self.app.flush()
    self.app.processEvents()
</t>
<t tx="ekr.20190812072049.247">def run(self, repl_callback, sleeptime=None):
    # Create timer
    timer = self._timer = self._QtCore.QTimer()
    timer.setSingleShot(False)
    timer.setInterval(0.05*1000)  # ms
    timer.timeout.connect(repl_callback)
    timer.start()

    # Enter Qt mainloop
    #self._QtGui.real_QApplication.exec_(self.app)
    self._QtGui.real_QApplication.exec_()
</t>
<t tx="ekr.20190812072049.248">def quit(self):
    # A nicer way to quit
    self._QtGui.real_QApplication.quit()
</t>
<t tx="ekr.20190812072049.249">class App_pyqt5(App_qt):
    """ Hijack the PyQt5 mainloop.
    """

    @others
</t>
<t tx="ekr.20190812072049.25">def customEvent(self, event):
    """ This is what gets called by Qt.
    """
    yoton.process_events(False)
</t>
<t tx="ekr.20190812072049.250">def importCoreAndGui(self):
    # Try importing qt
    import PyQt5  # noqa
    from PyQt5 import QtGui, QtCore, QtWidgets  # noqa
    return QtWidgets, QtCore  # QApp sits on QtWidgets
</t>
<t tx="ekr.20190812072049.251">class App_pyqt4(App_qt):
    """ Hijack the PyQt4 mainloop.
    """

    @others
</t>
<t tx="ekr.20190812072049.252">def importCoreAndGui(self):
    # Try importing qt
    import PyQt4  # noqa
    from PyQt4 import QtGui, QtCore
    return QtGui, QtCore
</t>
<t tx="ekr.20190812072049.253">class App_pyside2(App_qt):
    """ Hijack the PySide2 mainloop.
    """

    @others
</t>
<t tx="ekr.20190812072049.254">def importCoreAndGui(self):
    # Try importing qt
    import PySide2  # noqa
    from PySide2 import QtGui, QtCore, QtWidgets  # noqa
    return QtWidgets, QtCore  # QApp sits on QtWidgets
</t>
<t tx="ekr.20190812072049.255">class App_pyside(App_qt):
    """ Hijack the PySide mainloop.
    """

    @others
</t>
<t tx="ekr.20190812072049.256">def importCoreAndGui(self):
    # Try importing qt
    import PySide  # noqa
    from PySide import QtGui, QtCore
    return QtGui, QtCore
</t>
<t tx="ekr.20190812072049.257">class App_wx(App_base):
    """ Hijack the wxWidgets mainloop.
    """

    @others
</t>
<t tx="ekr.20190812072049.258">def __init__(self):

    # Try importing
    try:
        import wx
    except ImportError:
        # For very old versions of WX
        import wxPython as wx

    # Create dummy mainloop to replace original mainloop
    def dummy_mainloop(*args, **kw):
        print_mainloop_warning()

    # Depending on version, replace mainloop
    ver = wx.__version__
    orig_mainloop = None
    if ver[:3] &gt;= '2.5':
        if hasattr(wx, '_core_'): core = getattr(wx, '_core_')
        elif hasattr(wx, '_core'): core = getattr(wx, '_core')
        else: raise ImportError
        orig_mainloop = core.PyApp_MainLoop
        core.PyApp_MainLoop = dummy_mainloop
    elif ver[:3] == '2.4':
        orig_mainloop = wx.wxc.wxPyApp_MainLoop
        wx.wxc.wxPyApp_MainLoop = dummy_mainloop
    else:
        # Unable to find either wxPython version 2.4 or &gt;= 2.5."
        raise ImportError

    self._orig_mainloop = orig_mainloop
    # Store package wx
    self.wx = wx

    # Get and store the app instance to process events
    app = wx.GetApp()
    if app is None:
        app = wx.App(False)
    self.app = app

    # Notify that we integrated the event loop
    self.app._in_event_loop = 'Pyzo'
    wx._in_event_loop = 'Pyzo'
</t>
<t tx="ekr.20190812072049.259">def process_events(self):
    wx = self.wx

    # This bit is really needed
    old = wx.EventLoop.GetActive()
    eventLoop = wx.EventLoop()
    wx.EventLoop.SetActive(eventLoop)
    while eventLoop.Pending():
        eventLoop.Dispatch()

    # Process and reset
    self.app.ProcessIdle() # otherwise frames do not close
    wx.EventLoop.SetActive(old)
</t>
<t tx="ekr.20190812072049.26">def finishKernelInfo(info, scriptFile=None):
    """ finishKernelInfo(info, scriptFile=None)

    Get a copy of the kernel info struct, with the scriptFile
    and the projectPath set.

    """

    # Make a copy, we do not want to change the original
    info = ssdf.copy(info)

    # Set scriptFile (if '', the kernel will run in interactive mode)
    if scriptFile:
        info.scriptFile = scriptFile
    else:
        info.scriptFile = ''

    #If the file browser is active, and has the check box
    #'add path to Python path' set, set the PROJECTPATH variable
    fileBrowser = pyzo.toolManager.getTool('pyzofilebrowser')
    projectManager = pyzo.toolManager.getTool('pyzoprojectmanager')
    info.projectPath = ''
    if fileBrowser:
        info.projectPath = fileBrowser.getAddToPythonPath()
    if projectManager and not info.projectPath:
        # Only process project manager tool if file browser did not set a path.
        info.projectPath = projectManager.getAddToPythonPath()

    return info
</t>
<t tx="ekr.20190812072049.260">class App_gtk(App_base):
    """ Modifies pyGTK's mainloop with a dummy so user code does not
    block IPython.  processing events is done using the module'
    main_iteration function.
    """
    @others
</t>
<t tx="ekr.20190812072049.261">def __init__(self):
    # Try importing gtk
    import gtk

    # Replace mainloop with a dummy
    def dummy_mainloop(*args, **kwargs):
        print_mainloop_warning()
    gtk.mainloop = dummy_mainloop
    gtk.main = dummy_mainloop

    # Replace main_quit with a dummy too
    def dummy_quit(*args, **kwargs):
        pass
    gtk.main_quit = dummy_quit
    gtk.mainquit = dummy_quit

    # Make sure main_iteration exists even on older versions
    if not hasattr(gtk, 'main_iteration'):
        gtk.main_iteration = gtk.mainiteration

    # Store 'app object'
    self.app = gtk

    # Notify that we integrated the event loop
    self.app._in_event_loop = 'Pyzo'
</t>
<t tx="ekr.20190812072049.262">def process_events(self):
    gtk = self.app
    while gtk.events_pending():
        gtk.main_iteration(False)
</t>
<t tx="ekr.20190812072049.263">@path pyzo/pyzokernel/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.264">#!/usr/bin/env python
# coding: utf-8
"""
Support for creating GUI apps and starting event loops.

IPython's GUI integration allows interative plotting and GUI usage in IPython
session. IPython has two different types of GUI integration:

1. The terminal based IPython supports GUI event loops through Python's
   PyOS_InputHook. PyOS_InputHook is a hook that Python calls periodically
   whenever raw_input is waiting for a user to type code. We implement GUI
   support in the terminal by setting PyOS_InputHook to a function that
   iterates the event loop for a short while. It is important to note that
   in this situation, the real GUI event loop is NOT run in the normal
   manner, so you can't use the normal means to detect that it is running.
2. In the two process IPython kernel/frontend, the GUI event loop is run in
   the kernel. In this case, the event loop is run in the normal manner by
   calling the function or method of the GUI toolkit that starts the event
   loop.

In addition to starting the GUI event loops in one of these two ways, IPython
will *always* create an appropriate GUI application object when GUi
integration is enabled.

If you want your GUI apps to run in IPython you need to do two things:

1. Test to see if there is already an existing main application object. If
   there is, you should use it. If there is not an existing application object
   you should create one.
2. Test to see if the GUI event loop is running. If it is, you should not
   start it. If the event loop is not running you may start it.

This module contains functions for each toolkit that perform these things
in a consistent manner. Because of how PyOS_InputHook runs the event loop
you cannot detect if the event loop is running using the traditional calls
(such as ``wx.GetApp.IsMainLoopRunning()`` in wxPython). If PyOS_InputHook is
set These methods will return a false negative. That is, they will say the
event loop is not running, when is actually is. To work around this limitation
we proposed the following informal protocol:

* Whenever someone starts the event loop, they *must* set the ``_in_event_loop``
  attribute of the main application object to ``True``. This should be done
  regardless of how the event loop is actually run.
* Whenever someone stops the event loop, they *must* set the ``_in_event_loop``
  attribute of the main application object to ``False``.
* If you want to see if the event loop is running, you *must* use ``hasattr``
  to see if ``_in_event_loop`` attribute has been set. If it is set, you
  *must* use its value. If it has not been set, you can query the toolkit
  in the normal manner.
* If you want GUI support and no one else has created an application or
  started the event loop you *must* do this. We don't want projects to
  attempt to defer these things to someone else if they themselves need it.

The functions below implement this logic for each GUI toolkit. If you need
to create custom application subclasses, you will likely have to modify this
code for your own purposes. This code can be copied into your own project
so you don't have to depend on IPython.

"""

#-----------------------------------------------------------------------------
#  Copyright (C) 2008-2010  The IPython Development Team
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#-----------------------------------------------------------------------------
</t>
<t tx="ekr.20190812072049.265">def get_app_wx(*args, **kwargs):
    """Create a new wx app or return an exiting one."""
    import wx
    app = wx.GetApp()
    if app is None:
        if 'redirect' not in kwargs:
            kwargs['redirect'] = False
        # app = wx.PySimpleApp(*args, **kwargs) Deprecated!
        app = wx.App(*args, **kwargs)
    return app
</t>
<t tx="ekr.20190812072049.266">def is_event_loop_running_wx(app=None):
    """Is the wx event loop running."""
    if app is None:
        app = get_app_wx()
    if hasattr(app, '_in_event_loop'):
        return app._in_event_loop
    else:
        return app.IsMainLoopRunning()
</t>
<t tx="ekr.20190812072049.267">def start_event_loop_wx(app=None):
    """Start the wx event loop in a consistent manner."""
    if app is None:
        app = get_app_wx()
    if not is_event_loop_running_wx(app):
        app._in_event_loop = True
        app.MainLoop()
        app._in_event_loop = False
    else:
        app._in_event_loop = True

#-----------------------------------------------------------------------------
# qt4
#-----------------------------------------------------------------------------
</t>
<t tx="ekr.20190812072049.268">def get_app_qt4(*args, **kwargs):
    """Create a new qt4 app or return an existing one."""
    from PyQt4 import QtWidgets
    app = QtWidgets.QApplication.instance()
    if app is None:
        if not args:
            args = ([''],)
        app = QtWidgets.QApplication(*args, **kwargs)
    return app
</t>
<t tx="ekr.20190812072049.269">def is_event_loop_running_qt4(app=None):
    """Is the qt4 event loop running."""
    if app is None:
        app = get_app_qt4([''])
    if hasattr(app, '_in_event_loop'):
        return app._in_event_loop
    else:
        # Does qt4 provide a other way to detect this?
        return False
</t>
<t tx="ekr.20190812072049.27">class ShellHighlighter(Highlighter):
    """ This highlighter implements highlighting for a shell;
    only the input lines are highlighted with this highlighter.
    """

    @others
</t>
<t tx="ekr.20190812072049.270">def start_event_loop_qt4(app=None):
    """Start the qt4 event loop in a consistent manner."""
    if app is None:
        app = get_app_qt4([''])
    if not is_event_loop_running_qt4(app):
        app._in_event_loop = True
        app.exec_()
        app._in_event_loop = False
    else:
        app._in_event_loop = True

#-----------------------------------------------------------------------------
# Tk
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# gtk
#-----------------------------------------------------------------------------
</t>
<t tx="ekr.20190812072049.271">@path pyzo/pyzokernel/
# -*- coding: utf-8 -*-

@others
@language python
@tabwidth -4
@nopyflakes
</t>
<t tx="ekr.20190812072049.272">try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo.pyzokernel.interpreter.py')
except Exception:
    leo_g = None

""" Module pyzokernel.interpreter

Implements the Pyzo interpreter.

Notes on IPython
----------------
We integrate IPython via the IPython.core.interactiveshell.InteractiveShell.
  * The namespace is set to __main__
  * We call its run_cell method to execute code
  * Debugging/breakpoints are "enabled using the pre_run_code_hook
  * Debugging occurs in our own debugger
  * GUI integration is all handled by pyzo
  * We need special prompts for IPython input

"""

import os
import sys
import time
import logging
import platform
import struct
import shlex
from codeop import CommandCompiler
import traceback
import keyword
import inspect # noqa - Must be in this namespace
import bdb
from distutils.version import LooseVersion as LV

import yoton
from pyzokernel import guiintegration, printDirect
from pyzokernel.magic import Magician
from pyzokernel.debug import Debugger

# Init last traceback information
sys.last_type = None
sys.last_value = None
sys.last_traceback = None

# Set Python version and get some names
PYTHON_VERSION = sys.version_info[0]
if PYTHON_VERSION &lt; 3:
    ustr = unicode  # noqa
    bstr = str
    input = raw_input  # noqa
else:
    ustr = str
    bstr = bytes
</t>
<t tx="ekr.20190812072049.273">class PS1:
    """ Dynamic prompt for PS1. Show IPython prompt if available, and
    show current stack frame when debugging.
    """
    @others
</t>
<t tx="ekr.20190812072049.274">def __init__(self, pyzo):
    self._pyzo = pyzo
</t>
<t tx="ekr.20190812072049.275">def __str__(self):
    if self._pyzo._dbFrames:
        # When debugging, show where we are, do not use IPython prompt
        preamble = '('+self._pyzo._dbFrameName+')'
        return '\n\x1b[0;32m%s&gt;&gt;&gt;\x1b[0m ' % preamble
    elif self._pyzo._ipython:
        # IPython prompt
        return '\n\x1b[0;32mIn [\x1b[1;32m%i\x1b[0;32m]:\x1b[0m ' % (
                                        self._pyzo._ipython.execution_count)
        #return 'In [%i]: ' % (self._ipython.execution_count)
    else:
        # Normal Python prompt
        return '\n\x1b[0;32m&gt;&gt;&gt;\x1b[0m '
</t>
<t tx="ekr.20190812072049.276">class PS2:
    """ Dynamic prompt for PS2.
    """
    @others
</t>
<t tx="ekr.20190812072049.277">def __init__(self, pyzo):
    self._pyzo = pyzo
</t>
<t tx="ekr.20190812072049.278">def __str__(self):
    if self._pyzo._dbFrames:
        # When debugging, show where we are, do not use IPython prompt
        preamble = '('+self._pyzo._dbFrameName+')'
        return '\x1b[0;32m%s...\x1b[0m ' % preamble
    elif self._pyzo._ipython:
        # Dots ala IPython
        nspaces = len(str(self._pyzo._ipython.execution_count)) + 2
        return '\x1b[0;32m%s...:\x1b[0m ' % (nspaces*' ')
    else:
        # Just dots
        return '\x1b[0;32m...\x1b[0m '
</t>
<t tx="ekr.20190812072049.279">class PyzoInterpreter:
    """ PyzoInterpreter

    The pyzo interpreter is the part that makes the pyzo kernel interactive.
    It executes code, integrates the GUI toolkit, parses magic commands, etc.
    The pyzo interpreter has been designed to emulate the standard interactive
    Python console as much as possible, but with a lot of extra goodies.

    There is one instance of this class, stored at sys._pyzoInterpreter and
    at the __pyzo__ variable in the global namespace.

    The global instance has a couple of interesting attributes:
      * context: the yoton Context instance at the kernel (has all channels)
      * introspector: the introspector instance (a subclassed yoton.RepChannel)
      * magician: the object that handles the magic commands
      * guiApp: a wrapper for the integrated GUI application
      * sleeptime: the amount of time (in seconds) to sleep at each iteration

    """

    # Simular working as code.InteractiveConsole. Some code was copied, but
    # the following things are changed:
    # - prompts are printed in the err stream, like the default interpreter does
    # - uses an asynchronous read using the yoton interface
    # - support for hijacking GUI toolkits
    # - can run large pieces of code
    # - support post mortem debugging
    # - support for magic commands

    @others
</t>
<t tx="ekr.20190812072049.28">def highlightBlock(self, line):

    # Make sure this is a Unicode Python string
    line = str(line)

    # Get previous state
    previousState = self.previousBlockState()

    # Get parser
    parser = None
    if hasattr(self._codeEditor, 'parser'):
        parser = self._codeEditor.parser()

    # Get function to get format
    nameToFormat = self._codeEditor.getStyleElementFormat

    # Last line?
    cursor1 = self._codeEditor._cursor1
    cursor2 = self._codeEditor._cursor2
    commandCursor = self._codeEditor._lastCommandCursor
    curBlock = self.currentBlock()
    #
    atLastPrompt, atCurrentPrompt = False, False
    if curBlock.position() == 0:
        pass
    elif curBlock.position() == commandCursor.block().position():
        atLastPrompt = True
    elif curBlock.position() &gt;= cursor1.block().position():
        atCurrentPrompt = True

    if not atLastPrompt and not atCurrentPrompt:
        # Do not highlight anything but current and last prompts
        return

    if parser:
        if atCurrentPrompt:
            pos1, pos2 = cursor1.positionInBlock(), cursor2.positionInBlock()
        else:
            pos1, pos2 = 0, commandCursor.positionInBlock()

        # Check if we should *not* format this line.
        # This is the case for special "executing" text
        # A bit of a hack though ... is there a better way to signal this?
        specialinput = (not atCurrentPrompt) and line[pos2:].startswith('(executing ')

        self.setCurrentBlockState(0)
        if specialinput:
            pass # Let the kernel decide formatting
        else:
            for token in parser.parseLine(line, previousState):
                # Handle block state
                if isinstance(token, parsers.BlockState):
                    self.setCurrentBlockState(token.state)
                else:
                    # Get format
                    try:
                        format = nameToFormat(token.name).textCharFormat
                    except KeyError:
                        #print(repr(nameToFormat(token.name)))
                        continue
                    # Set format
                    #format.setFontWeight(75)
                    if token.start &gt;= pos2:
                        self.setFormat(token.start,token.end-token.start,format)

        # Set prompt to bold
        if atCurrentPrompt:
            format = QtGui.QTextCharFormat()
            format.setFontWeight(75)
            self.setFormat(pos1, pos2-pos1, format)

    #Get the indentation setting of the editors
    indentUsingSpaces = self._codeEditor.indentUsingSpaces()

    # Get user data
    bd = self.getCurrentBlockUserData()

    leadingWhitespace=line[:len(line)-len(line.lstrip())]
    if '\t' in leadingWhitespace and ' ' in leadingWhitespace:
        #Mixed whitespace
        bd.indentation = 0
        format=QtGui.QTextCharFormat()
        format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        format.setUnderlineColor(QtCore.Qt.red)
        format.setToolTip('Mixed tabs and spaces')
        self.setFormat(0,len(leadingWhitespace),format)
    elif ('\t' in leadingWhitespace and indentUsingSpaces) or \
        (' ' in leadingWhitespace and not indentUsingSpaces):
        #Whitespace differs from document setting
        bd.indentation = 0
        format=QtGui.QTextCharFormat()
        format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
        format.setUnderlineColor(QtCore.Qt.blue)
        format.setToolTip('Whitespace differs from document setting')
        self.setFormat(0,len(leadingWhitespace),format)
    else:
        # Store info for indentation guides
        # amount of tabs or spaces
        bd.indentation = len(leadingWhitespace)
</t>
<t tx="ekr.20190812072049.280">def __init__(self, locals, filename="&lt;console&gt;"):

    # Init variables for locals and globals (globals only for debugging)
    self.locals = locals
    self.globals = None

    # Store filename
    self._filename = filename

    # Store ref of locals that is our main
    self._main_locals = locals

    # Flag to ignore sys exit, to allow running some scripts
    # interactively, even if they call sys.exit.
    self.ignore_sys_exit = False

    # Information for debugging. If self._dbFrames, we're in debug mode
    # _dbFrameIndex starts from 1
    self._dbFrames = []
    self._dbFrameIndex = 0
    self._dbFrameName = ''

    # Init datase to store source code that we execute
    self._codeCollection = ExecutedSourceCollection()

    # Init buffer to deal with multi-line command in the shell
    self._buffer = []

    # Init sleep time. 0.001 result in 0% CPU usage at my laptop (Windows),
    # but 8% CPU usage at my older laptop (on Linux).
    self.sleeptime = 0.01 # 100 Hz

    # Create compiler
    if sys.platform.startswith('java'):
        import compiler
        self._compile = compiler.compile  # or 'exec' does not work
    else:
        self._compile = CommandCompiler()

    # Instantiate magician and tracer
    self.magician = Magician()
    self.debugger = Debugger()

    # To keep track of whether to send a new prompt, and whether more
    # code is expected.
    self.more = 0
    self.newPrompt = True

    # Code and script to run on first iteration
    self._codeToRunOnStartup = None
    self._scriptToRunOnStartup = None

    # Remove "THIS" directory from the PYTHONPATH
    # to prevent unwanted imports. Same for pyzokernel dir
    thisPath = os.getcwd()
    for p in [thisPath, os.path.join(thisPath,'pyzokernel')]:
        while p in sys.path:
            sys.path.remove(p)
</t>
<t tx="ekr.20190812072049.281">def run(self):
    """ Run (start the mainloop)

    Here we enter the main loop, which is provided by the guiApp.
    This event loop calls process_commands on a regular basis.

    We may also enter the debug intereaction loop, either from a
    request for post-mortem debugging, or *during* execution by
    means of a breakpoint. When in this debug-loop, the guiApp event
    loop lays still, but the debug-loop does call process-commands
    for user interaction.

    When the user wants to quit, SystemExit is raised (one way or
    another). This is detected in process_commands and the exception
    instance is stored in self._exitException. Then the debug-loop
    is stopped if necessary, and the guiApp is told to stop its event
    loop.

    And that brings us back here, where we exit using in order of
    preference: self._exitException, the exception with which the
    event loop was exited (if any), or a new exception.

    """

    # Prepare
    self._prepare()
    self._exitException = None

    # Enter main
    try:
        self.guiApp.run(self.process_commands, self.sleeptime)
    except SystemExit:
        # Set self._exitException if it is not set yet
        type, value, tb = sys.exc_info()
        del tb
        if self._exitException is None:
            self._exitException = value

    # Exit
    if self._exitException is None:
        self._exitException = SystemExit()
    raise self._exitException
</t>
<t tx="ekr.20190812072049.282">def _prepare(self):
    """ Prepare for running the main loop.
    Here we do some initialization like obtaining the startup info,
    creating the GUI application wrapper, etc.
    """

    # Reset debug status
    self.debugger.writestatus()

    # Get startup info (get a copy, or setting the new version wont trigger!)
    while self.context._stat_startup.recv() is None:
        time.sleep(0.02)
    self.startup_info = startup_info = self.context._stat_startup.recv().copy()

    # Set startup info (with additional info)
    if sys.platform.startswith('java'):
        import __builtin__ as builtins  # Jython
    else:
        builtins = __builtins__
    if not isinstance(builtins, dict):
        builtins = builtins.__dict__
    startup_info['builtins'] = [builtin for builtin in builtins.keys()]
    startup_info['version'] = tuple(sys.version_info)
    startup_info['keywords'] = keyword.kwlist
    # Update startup info, we update again at the end of this method
    self.context._stat_startup.send(startup_info.copy())

    # Prepare the Python environment
    self._prepare_environment(startup_info)

    # Run startup code (before loading GUI toolkit or IPython
    self._run_startup_code(startup_info)

    # Write Python banner (to stdout)
    thename = 'Python'
    if sys.version_info[0] == 2:
        thename = 'Legacy Python'
    if '__pypy__' in sys.builtin_module_names:
        thename = 'Pypy'
    if sys.platform.startswith('java'):
        thename = 'Jython'
        # Jython cannot do struct.calcsize("P")
        import java.lang
        real_plat = java.lang.System.getProperty("os.name").lower()
        plat = '%s/%s' % (sys.platform, real_plat)
    elif sys.platform.startswith('win'):
        NBITS = 8 * struct.calcsize("P")
        plat = 'Windows (%i bits)' % NBITS
    else:
        NBITS = 8 * struct.calcsize("P")
        plat = '%s (%i bits)' % (sys.platform, NBITS)
    printDirect("%s %s on %s.\n" %
                (thename, sys.version.split('[')[0].rstrip(), plat))

    # Integrate GUI
    guiName, guiError = self._integrate_gui(startup_info)

    # Write pyzo part of banner (including what GUI loop is integrated)
    if True:
        pyzoBanner = 'This is the Pyzo interpreter'
    if guiError:
        pyzoBanner += '. ' + guiError + '\n'
    elif guiName:
        pyzoBanner += ' with integrated event loop for '
        pyzoBanner += guiName + '.\n'
    else:
        pyzoBanner += '.\n'
    printDirect(pyzoBanner)

    # Try loading IPython
    if startup_info.get('ipython', '').lower() in ('', 'no', 'false'):
        self._ipython = None
    else:
        try:
            self._load_ipyhon()
        except Exception:
            type, value, tb = sys.exc_info()
            del tb
            printDirect('IPython could not be loaded: %s\n' % str(value))
            self._ipython = None
            startup_info['ipython'] = 'no'

    # Set prompts
    sys.ps1 = PS1(self)
    sys.ps2 = PS2(self)

    # Notify about project path
    projectPath = startup_info['projectPath']
    if projectPath:
        printDirect('Prepending the project path %r to sys.path\n' %
            projectPath)

    # Write tips message.
    if self._ipython:
        import IPython
        printDirect("\nUsing IPython %s -- An enhanced Interactive Python.\n"
                    %  IPython.__version__)
        printDirect(
            "?         -&gt; Introduction and overview of IPython's features.\n"
            "%quickref -&gt; Quick reference.\n"
            "help      -&gt; Python's own help system.\n"
            "object?   -&gt; Details about 'object', "
            "use 'object??' for extra details.\n")
    else:
        printDirect("Type 'help' for help, " +
                    "type '?' for a list of *magic* commands.\n")

    # Notify the running of the script
    if self._scriptToRunOnStartup:
        printDirect('\x1b[0;33mRunning script: "'+self._scriptToRunOnStartup+'"\x1b[0m\n')

    # Prevent app nap on OSX 9.2 and up
    # The _nope module is taken from MINRK's appnope package
    if sys.platform == "darwin" and LV(platform.mac_ver()[0]) &gt;= LV("10.9"):
        from pyzokernel import _nope
        _nope.nope()

    # Setup post-mortem debugging via appropriately logged exceptions
    class PMHandler(logging.Handler):
        def emit(self, record):
            if record.exc_info:
                sys.last_type, sys.last_value, sys.last_traceback = record.exc_info
            return record
    #
    root_logger = logging.getLogger()
    if not root_logger.handlers:
        root_logger.addHandler(logging.StreamHandler())
    root_logger.addHandler(PMHandler())

    # Update startup info
    self.context._stat_startup.send(startup_info)
</t>
<t tx="ekr.20190812072049.283">def _prepare_environment(self, startup_info):
    """ Prepare the Python environment. There are two possibilities:
    either we run a script or we run interactively.
    """
    
    # Get whether we should (and can) run as script
    scriptFilename = startup_info['scriptFile']
    if scriptFilename:
        if not os.path.isfile(scriptFilename):
            printDirect('Invalid script file: "'+scriptFilename+'"\n')
            scriptFilename = None

    # Get project path
    projectPath = startup_info['projectPath']

    if scriptFilename.endswith('.ipynb'):
        # Run Jupyter notebook
        import notebook.notebookapp
        sys.argv = ['jupyter_notebook', scriptFilename]
        sys.exit(notebook.notebookapp.main())

    elif scriptFilename:
        # RUN AS SCRIPT
        # Set __file__  (note that __name__ is already '__main__')
        self.locals['__file__'] = scriptFilename
        # Set command line arguments
        sys.argv[:] = []
        sys.argv.append(scriptFilename)
        sys.argv.extend(shlex.split(startup_info.get('argv', '')))
        # Insert script directory to path
        theDir = os.path.abspath( os.path.dirname(scriptFilename) )
        if theDir not in sys.path:
            sys.path.insert(0, theDir)
        if projectPath is not None:
            sys.path.insert(0,projectPath)
        # Go to script dir
        os.chdir( os.path.dirname(scriptFilename) )
        # Run script later
        self._scriptToRunOnStartup = scriptFilename
    else:
        # RUN INTERACTIVELY
        # No __file__ (note that __name__ is already '__main__')
        self.locals.pop('__file__','')
        # Remove all command line arguments, set first to empty string
        sys.argv[:] = []
        sys.argv.append('')
        sys.argv.extend(shlex.split(startup_info.get('argv', '')))
        # Insert current directory to path
        sys.path.insert(0, '')
        if projectPath:
            sys.path.insert(0,projectPath)
        # Go to start dir
        startDir = startup_info['startDir']
        if startDir and os.path.isdir(startDir):
            os.chdir(startDir)
        else:
            os.chdir(os.path.expanduser('~')) # home dir
</t>
<t tx="ekr.20190812072049.284">def _run_startup_code(self, startup_info):
    """ Execute the startup code or script.
    """

    # Run startup script (if set)
    script = startup_info['startupScript']
    # Should we use the default startupScript?
    if script == '$PYTHONSTARTUP':
        script = os.environ.get('PYTHONSTARTUP','')

    if '\n' in script:
        # Run code later or now
        firstline = script.split('\n')[0].replace(' ', '')
        if firstline.startswith('#AFTER_GUI'):
            self._codeToRunOnStartup = script
        else:
            self.context._stat_interpreter.send('Busy')
            msg = {'source': script, 'fname': '&lt;startup&gt;', 'lineno': 0}
            self.runlargecode(msg, True)
    elif script and os.path.isfile(script):
        # Run script
        self.context._stat_interpreter.send('Busy')
        self.runfile(script)
    else:
        # Nothing to run
        pass
</t>
<t tx="ekr.20190812072049.285">def _integrate_gui(self, startup_info):
    """ Integrate event loop of GUI toolkit (or use pure Python
    event loop).
    """

    self.guiApp = guiintegration.App_base()
    self.guiName = guiName = startup_info['gui'].upper()
    guiError = ''

    try:
        if guiName in ['', 'NONE']:
            guiName = ''
        elif guiName == 'AUTO':
            for tryName, tryApp in [('PYQT5', guiintegration.App_pyqt5),
                                    ('PYQT4', guiintegration.App_pyqt4),
                                    ('PYSIDE2', guiintegration.App_pyside2),
                                    ('PYSIDE', guiintegration.App_pyside),
                                    #('WX', guiintegration.App_wx),
                                    ('ASYNCIO', guiintegration.App_asyncio),
                                    ('TK', guiintegration.App_tk),
                                    ]:
                try:
                    self.guiApp = tryApp()
                except Exception:
                    continue
                guiName = tryName
                break
            else:
                guiName = ''
        elif guiName == 'ASYNCIO':
            self.guiApp = guiintegration.App_asyncio()
        elif guiName == 'TK':
            self.guiApp = guiintegration.App_tk()
        elif guiName == 'WX':
            self.guiApp = guiintegration.App_wx()
        elif guiName == 'TORNADO':
            self.guiApp = guiintegration.App_tornado()
        elif guiName == 'PYSIDE':
            self.guiApp = guiintegration.App_pyside()
        elif guiName == 'PYSIDE2':
            self.guiApp = guiintegration.App_pyside2()
        elif guiName in ['PYQT5', 'QT5']:
            self.guiApp = guiintegration.App_pyqt5()
        elif guiName in ['PYQT4', 'QT4']:
            self.guiApp = guiintegration.App_pyqt4()
        elif guiName == 'FLTK':
            self.guiApp = guiintegration.App_fltk()
        elif guiName == 'GTK':
            self.guiApp = guiintegration.App_gtk()
        else:
            guiError = 'Unkown gui: %s' % guiName
            guiName = ''
    except Exception: # Catch any error
        # Get exception info (we do it using sys.exc_info() because
        # we cannot catch the exception in a version independent way.
        type, value, tb = sys.exc_info()
        del tb
        guiError = 'Failed to integrate event loop for %s: %s' % (
            guiName, str(value))

    return guiName, guiError
</t>
<t tx="ekr.20190812072049.286">def _load_ipyhon(self):
    """ Try loading IPython shell. The result is set in self._ipython
    (can be None if IPython not available).
    """

    # Init
    self._ipython = None
    import __main__

    # Try importing IPython
    try:
        import IPython
    except ImportError:
        return

    # Version ok?
    if IPython.version_info &lt; (1,):
        return

    # Create an IPython shell
    from IPython.core.interactiveshell import InteractiveShell
    self._ipython = InteractiveShell(user_module=__main__)

    # Set some hooks / event callbacks
    # Run hook (pre_run_code_hook is depreacted in 2.0)
    pre_run_cell_hook  = self.ipython_pre_run_cell_hook
    if IPython.version_info &lt; (2,):
        self._ipython.set_hook('pre_run_code_hook', pre_run_cell_hook)
    else:
        self._ipython.events.register('pre_run_cell', pre_run_cell_hook)
    # Other hooks
    self._ipython.set_hook('editor', self.ipython_editor_hook)
    self._ipython.set_custom_exc((bdb.BdbQuit,), self.dbstop_handler)

    # Some patching
    self._ipython.ask_exit = self.ipython_ask_exit

    # Make output be shown on Windows
    if sys.platform.startswith('win'):
        # IPython wraps std streams just like we do below, but
        # pyreadline adds *another* wrapper, which is where it
        # goes wrong. Here we set it back to bypass pyreadline.
        from IPython.utils import io
        io.stdin = io.IOStream(sys.stdin)
        io.stdout = io.IOStream(sys.stdout)
        io.stderr = io.IOStream(sys.stderr)

        # Ipython uses msvcrt e.g. for pausing between pages
        # but this does not work in pyzo
        import msvcrt
        msvcrt.getwch = msvcrt.getch = input  # input is deffed above
</t>
<t tx="ekr.20190812072049.287">def process_commands(self):
    """ Do one iteration of processing commands (the REPL).
    """
    try:

        self._process_commands()

    except SystemExit:
        # It may be that we should ignore sys exit now...
        if self.ignore_sys_exit:
            self.ignore_sys_exit = False  # Never allow more than once
            return
        # Get and store the exception so we can raise it later
        type, value, tb = sys.exc_info()
        del tb
        self._exitException = value
        # Stop debugger if it is running
        self.debugger.stopinteraction()
        # Exit from interpreter. Exit in the appropriate way
        self.guiApp.quit()  # Is sys.exit() by default
</t>
<t tx="ekr.20190812072049.288">def _process_commands(self):

    # Run startup code/script inside the loop (only the first time)
    # so that keyboard interrupt will work
    if self._codeToRunOnStartup:
        self.context._stat_interpreter.send('Busy')
        self._codeToRunOnStartup, tmp = None, self._codeToRunOnStartup
        self.pushline(tmp)
    if self._scriptToRunOnStartup:
        self.context._stat_interpreter.send('Busy')
        self._scriptToRunOnStartup, tmp = None, self._scriptToRunOnStartup
        self.runfile(tmp)

    # Flush real stdout / stderr
    sys.__stdout__.flush()
    sys.__stderr__.flush()

    # Set status and prompt?
    # Prompt is allowed to be an object with __str__ method
    if self.newPrompt:
        self.newPrompt = False
        ps = [sys.ps1, sys.ps2][bool(self.more)]
        self.context._strm_prompt.send(str(ps))

    if True:
        # Determine state. The message is really only send
        # when the state is different. Note that the kernelbroker
        # can also set the state ("Very busy", "Busy", "Dead")
        if self._dbFrames:
            self.context._stat_interpreter.send('Debug')
        elif self.more:
            self.context._stat_interpreter.send('More')
        else:
            self.context._stat_interpreter.send('Ready')
        self.context._stat_cd.send(os.getcwd())

    # Are we still connected?
    if sys.stdin.closed or not self.context.connection_count:
        # Exit from main loop.
        # This will raise SystemExit and will shut us down in the
        # most appropriate way
        sys.exit()

    # Get channel to take a message from
    ch = yoton.select_sub_channel(self.context._ctrl_command, self.context._ctrl_code)

    if ch is None:
        pass # No messages waiting

    elif ch is self.context._ctrl_command:
        # Read command
        line1 = self.context._ctrl_command.recv(False) # Command
        if line1:
            # Notify what we're doing
            self.context._strm_echo.send(line1)
            self.context._stat_interpreter.send('Busy')
            self.newPrompt = True
            # Convert command
            # (only a few magics are supported if IPython is active)
            line2 = self.magician.convert_command(line1.rstrip('\n'))
            # Execute actual code
            if line2 is not None:
                for line3 in line2.split('\n'):  # not splitlines!
                    self.more = self.pushline(line3)
            else:
                self.more = False
                self._resetbuffer()

    elif ch is self.context._ctrl_code:
        # Read larger block of code (dict)
        msg = self.context._ctrl_code.recv(False)
        if msg:
            # Notify what we're doing
            # (runlargecode() sends on stdin-echo)
            self.context._stat_interpreter.send('Busy')
            self.newPrompt = True
            # Execute code
            self.runlargecode(msg)
            # Reset more stuff
            self._resetbuffer()
            self.more = False

    else:
        # This should not happen, but if it does, just flush!
        ch.recv(False)

## Running code in various ways
# In all cases there is a call for compilecode and a call to execcode
</t>
<t tx="ekr.20190812072049.289">def _resetbuffer(self):
    """Reset the input buffer."""
    self._buffer = []
</t>
<t tx="ekr.20190812072049.29">class BaseShell(BaseTextCtrl):
    """ The BaseShell implements functionality to make a generic shell.
    """

    @others
</t>
<t tx="ekr.20190812072049.290">def pushline(self, line):
    """Push a line to the interpreter.

    The line should not have a trailing newline; it may have
    internal newlines.  The line is appended to a buffer and the
    interpreter's _runlines() method is called with the
    concatenated contents of the buffer as source.  If this
    indicates that the command was executed or invalid, the buffer
    is reset; otherwise, the command is incomplete, and the buffer
    is left as it was after the line was appended.  The return
    value is 1 if more input is required, 0 if the line was dealt
    with in some way (this is the same as _runlines()).

    """
    # Get buffer, join to get source
    buffer = self._buffer
    buffer.append(line)
    source = "\n".join(buffer)
    # Clear buffer and run source
    self._resetbuffer()
    more = self._runlines(source, self._filename)
    # Create buffer if needed
    if more:
        self._buffer = buffer
    return more
</t>
<t tx="ekr.20190812072049.291">def _runlines(self, source, filename="&lt;input&gt;", symbol="single"):
    """Compile and run some source in the interpreter.

    Arguments are as for compile_command().

    One several things can happen:

    1) The input is incorrect; compile_command() raised an
    exception (SyntaxError or OverflowError).  A syntax traceback
    will be printed by calling the showsyntaxerror() method.

    2) The input is incomplete, and more input is required;
    compile_command() returned None.  Nothing happens.

    3) The input is complete; compile_command() returned a code
    object.  The code is executed by calling self.execcode() (which
    also handles run-time exceptions, except for SystemExit).

    The return value is True in case 2, False in the other cases (unless
    an exception is raised).  The return value can be used to
    decide whether to use sys.ps1 or sys.ps2 to prompt the next
    line.

    """

    use_ipython = self._ipython and not self._dbFrames

    # Try compiling.
    # The IPython kernel does not handle incomple lines, so we check
    # that ourselves ...
    error = None
    try:
        code = self.compilecode(source, filename, symbol)
    except (OverflowError, SyntaxError, ValueError):
        error = sys.exc_info()[1]
        code = False

    if use_ipython:
        if code is None:
            # Case 2
            #self._ipython.run_cell('', True)
            return True
        else:
            # Case 1 and 3 handled by IPython
            self._ipython.run_cell(source, True, False)
            return False

    else:
        if code is None:
            # Case 2
            return True
        elif not code:
            # Case 1, a bit awkward way to show the error, but we need
            # to call showsyntaxerror in an exception handler.
            try:
                raise error
            except Exception:
                self.showsyntaxerror(filename)
            return False
        else:
            # Case 3
            self.execcode(code)
            return False
</t>
<t tx="ekr.20190812072049.292">def runlargecode(self, msg, silent=False):
    """ To execute larger pieces of code. """

    # Get information
    source, fname, lineno = msg['source'], msg['fname'], msg['lineno']
    cellName = msg.get('cellName', '')
    source += '\n'

    # Change directory?
    if msg.get('changeDir', False) and os.path.isfile(fname):
        d = os.path.normpath(os.path.normcase(os.path.dirname(fname)))
        if d != os.getcwd():
            os.chdir(d)

    # Construct notification message
    lineno1 = lineno + 1
    lineno2 = lineno + source.count('\n')
    fname_show = fname
    if not fname.startswith('&lt;'):
        fname_show = os.path.split(fname)[1]
    if cellName == fname:
        runtext = '(executing file "%s")\n' % fname_show
    elif cellName:
        runtext = '(executing cell "%s" (line %i of "%s"))\n' % (cellName, lineno1, fname_show)
    elif lineno1 == lineno2:
        runtext = '(executing line %i of "%s")\n' % (lineno1, fname_show)
    else:
        runtext = '(executing lines %i to %i of "%s")\n' % (
                                            lineno1, lineno2, fname_show)
    # Notify IDE
    if not silent:
        self.context._strm_echo.send('\x1b[0;33m%s\x1b[0m' % runtext)
        # Increase counter
        if self._ipython:
            self._ipython.execution_count += 1

    # Put the line number in the filename (if necessary)
    # Note that we could store the line offset in the _codeCollection,
    # but then we cannot retrieve it for syntax errors.
    if lineno:
        fname = "%s+%i" % (fname, lineno)

    # Try compiling the source
    code = None
    try:
        # Compile
        code = self.compilecode(source, fname, "exec")

    except (OverflowError, SyntaxError, ValueError):
        self.showsyntaxerror(fname)
        return

    if code:
        # Store the source using the (id of the) code object as a key
        self._codeCollection.store_source(code, source)
        # Execute the code
        self.execcode(code)
    else:
        # Incomplete code
        self.write('Could not run code because it is incomplete.\n')
</t>
<t tx="ekr.20190812072049.293">def runfile(self, fname):
    """  To execute the startup script. """

    # Get text (make sure it ends with a newline)
    try:
        bb = open(fname, 'rb').read()
        encoding = 'UTF-8'
        firstline = bb.split('\n'.encode(), 1)[0].decode('ascii', 'ignore')
        if firstline.startswith('#') and 'coding' in firstline:
            encoding = firstline.split('coding', 1)[-1].strip(' \t\r\n:=-*')
        source = bb.decode(encoding)
    except Exception:
        printDirect('Could not read script (decoding using %s): %r\n' % (encoding, fname))
        return
    try:
        source = source.replace('\r\n', '\n').replace('\r','\n')
        if source[-1] != '\n':
            source += '\n'
    except Exception:
        printDirect('Could not execute script: "' + fname + '"\n')
        return

    # Try compiling the source
    code = None
    try:
        # Compile
        code = self.compilecode(source, fname, "exec")
    except (OverflowError, SyntaxError, ValueError):
        time.sleep(0.2) # Give stdout time to be send
        self.showsyntaxerror(fname)
        return

    if code:
        # Store the source using the (id of the) code object as a key
        self._codeCollection.store_source(code, source)
        # Execute the code
        self.execcode(code)
    else:
        # Incomplete code
        self.write('Could not run code because it is incomplete.\n')
</t>
<t tx="ekr.20190812072049.294">def compilecode(self, source, filename, mode, *args, **kwargs):
    """ Compile source code.
    Will mangle coding definitions on first two lines.

    * This method should be called with Unicode sources.
    * Source newlines should consist only of LF characters.
    """

    # This method solves pyzo issue 22

    # Split in first two lines and the rest
    parts = source.split('\n', 2)

    # Replace any coding definitions
    ci = 'coding is'
    contained_coding = False
    for i in range(len(parts)-1):
        tmp = parts[i]
        if tmp and tmp[0] == '#' and 'coding' in tmp:
            contained_coding = True
            parts[i] = tmp.replace('coding=', ci).replace('coding:', ci)

    # Combine parts again (if necessary)
    if contained_coding:
        source = '\n'.join(parts)

    # Convert filename to UTF-8 if Python version &lt; 3
    if PYTHON_VERSION &lt; 3:
        filename = filename.encode('utf-8')

    # Compile
    return self._compile(source, filename, mode, *args, **kwargs)
</t>
<t tx="ekr.20190812072049.295">def execcode(self, code):
    """Execute a code object.

    When an exception occurs, self.showtraceback() is called to
    display a traceback.  All exceptions are caught except
    SystemExit, which is reraised.

    A note about KeyboardInterrupt: this exception may occur
    elsewhere in this code, and may not always be caught.  The
    caller should be prepared to deal with it.

    The globals variable is used when in debug mode.
    """

    try:
        if self._dbFrames:
            self.apply_breakpoints()
            exec(code, self.globals, self.locals)
        else:
            # Turn debugger on at this point. If there are no breakpoints,
            # the tracing is disabled for better performance.
            self.apply_breakpoints()
            self.debugger.set_on()
            exec(code, self.locals)
    except bdb.BdbQuit:
        self.dbstop_handler()
    except Exception:
        time.sleep(0.2) # Give stdout some time to send data
        self.showtraceback()
    except KeyboardInterrupt: # is a BaseException, not an Exception
        time.sleep(0.2)
        self.showtraceback()
</t>
<t tx="ekr.20190812072049.296">def apply_breakpoints(self):
    """ Breakpoints are updated at each time a command is given,
    including commands like "db continue".
    """
    try:
        breaks = self.context._stat_breakpoints.recv()
        if self.debugger.breaks:
            self.debugger.clear_all_breaks()
        if breaks:  # Can be None
            for fname in breaks:
                for linenr in breaks[fname]:
                    self.debugger.set_break(fname, linenr)
    except Exception:
        type, value, tb = sys.exc_info(); del tb
        print('Error while setting breakpoints: %s' % str(value))

## Handlers and hooks
</t>
<t tx="ekr.20190812072049.297">def ipython_pre_run_cell_hook(self, ipython=None):
    """ Hook that IPython calls right before executing code.
    """
    self.apply_breakpoints()
    self.debugger.set_on()
</t>
<t tx="ekr.20190812072049.298">def ipython_editor_hook(self, ipython, filename, linenum=None, wait=True):
    # Correct line number for cell offset
    filename, linenum = self.correctfilenameandlineno(filename, linenum or 0)
    # Get action string
    if linenum:
        action = 'open %i %s' % (linenum, os.path.abspath(filename))
    else:
        action = 'open %s' % os.path.abspath(filename)
    # Send
    self.context._strm_action.send(action)
</t>
<t tx="ekr.20190812072049.299">def ipython_ask_exit(self):
    # Ask the user
    a = input("Do you really want to exit ([y]/n)? ")
    a = a or 'y'
    # Close stdin if necessary
    if a.lower() == 'y':
        sys.stdin._channel.close()
</t>
<t tx="ekr.20190812072049.3">class DummyStd:
    """ For when std is not available. """
    @others
original_print = print
</t>
<t tx="ekr.20190812072049.30">def __init__(self, parent, **kwds):
    super().__init__(parent, wrap=True, showLineNumbers=False,
        showBreakPoints=False, highlightCurrentLine=False, parser='python',
        **kwds)

    # Use a special highlighter that only highlights the input.
    self._setHighlighter(ShellHighlighter)

    # No undo in shells
    self.setUndoRedoEnabled(False)

    # variables we need
    self._more = False

    # We use two cursors to keep track of where the prompt is
    # cursor1 is in front, and cursor2 is at the end of the prompt.
    # They can be in the same position.
    # Further, we store a cursor that selects the last given command,
    # so it can be styled.
    self._cursor1 = self.textCursor()
    self._cursor2 = self.textCursor()
    self._lastCommandCursor = self.textCursor()
    self._lastline_had_cr = False

    # When inserting/removing text at the edit line (thus also while typing)
    # keep cursor2 at its place. Only when text is written before
    # the prompt (i.e. in write), this flag is temporarily set to False.
    # Same for cursor1, because sometimes (when there is no prompt) it
    # is at the same position.
    self._cursor1.setKeepPositionOnInsert(True)
    self._cursor2.setKeepPositionOnInsert(True)

    # Similarly, we use the _lastCommandCursor cursor really for pointing.
    self._lastCommandCursor.setKeepPositionOnInsert(True)

    # Variables to keep track of the command history usage
    self._historyNeedle = None # None means none, "" means look in all
    self._historyStep = 0

    # Set minimum width so 80 lines do fit in smallest font size
    self.setMinimumWidth(200)

    # Hard wrapping. QTextEdit allows hard wrapping at a specific column.
    # Unfortunately, QPlainTextEdit does not.
    self.setWordWrapMode(QtGui.QTextOption.WrapAnywhere)

    # Limit number of lines
    self.setMaximumBlockCount(MAXBLOCKCOUNT)

    # Keep track of position, so we can disable editing if the cursor
    # is before the prompt
    self.cursorPositionChanged.connect(self.onCursorPositionChanged)

    self.setFocusPolicy(Qt.TabFocus) # See remark at mousePressEvent

## Cursor stuff
</t>
<t tx="ekr.20190812072049.300">def dbstop_handler(self, *args, **kwargs):
    print("Program execution stopped from debugger.")


## Writing and error handling
</t>
<t tx="ekr.20190812072049.301">def write(self, text):
    """ Write errors. """
    sys.stderr.write( text )
</t>
<t tx="ekr.20190812072049.302">def showsyntaxerror(self, filename=None):
    """Display the syntax error that just occurred.
    This doesn't display a stack trace because there isn't one.
    If a filename is given, it is stuffed in the exception instead
    of what was there before (because Python's parser always uses
    "&lt;string&gt;" when reading from a string).

    Pyzo version: support to display the right line number,
    see doc of showtraceback for details.
    """

    # Get info (do not store)
    type, value, tb = sys.exc_info()
    del tb

    # Work hard to stuff the correct filename in the exception
    if filename and type is SyntaxError:
        try:
            # unpack information
            msg, (dummy_filename, lineno, offset, line) = value
            # correct line-number
            fname, lineno = self.correctfilenameandlineno(filename, lineno)
        except:
            # Not the format we expect; leave it alone
            pass
        else:
            # Stuff in the right filename
            value = SyntaxError(msg, (fname, lineno, offset, line))
            sys.last_value = value

    # Show syntax error
    strList = traceback.format_exception_only(type, value)
    for s in strList:
        self.write(s)
</t>
<t tx="ekr.20190812072049.303">def showtraceback(self, useLastTraceback=False):
    """Display the exception that just occurred.
    We remove the first stack item because it is our own code.
    The output is written by self.write(), below.

    In the pyzo version, before executing a block of code,
    the filename is modified by appending " [x]". Where x is
    the index in a list that we keep, of tuples
    (sourcecode, filename, lineno).

    Here, showing the traceback, we check if we see such [x],
    and if so, we extract the line of code where it went wrong,
    and correct the lineno, so it will point at the right line
    in the editor if part of a file was executed. When the file
    was modified since the part in question was executed, the
    fileno might deviate, but the line of code shown shall
    always be correct...
    """
    # Traceback info:
    # tb_next -&gt; go down the trace
    # tb_frame -&gt; get the stack frame
    # tb_lineno -&gt; where it went wrong
    #
    # Frame info:
    # f_back -&gt; go up (towards caller)
    # f_code -&gt; code object
    # f_locals -&gt; we can execute code here when PM debugging
    # f_globals
    # f_trace -&gt; (can be None) function for debugging? (
    #
    # The traceback module is used to obtain prints from the
    # traceback.

    try:
        if useLastTraceback:
            # Get traceback info from buffered
            type = sys.last_type
            value = sys.last_value
            tb = sys.last_traceback
        else:
            # Get exception information and remove first, since that's us
            type, value, tb = sys.exc_info()
            tb = tb.tb_next

            # Store for debugging, but only store if not in debug mode
            if not self._dbFrames:
                sys.last_type = type
                sys.last_value = value
                sys.last_traceback = tb

        # Get traceback to correct all the line numbers
        # tblist = list  of (filename, line-number, function-name, text)
        tblist = traceback.extract_tb(tb)

        # Get frames
        frames = []
        while tb:
            frames.append(tb.tb_frame)
            tb = tb.tb_next

        # Walk through the list
        for i in range(len(tblist)):
            tbInfo = tblist[i]
            # Get filename and line number, init example
            fname, lineno = self.correctfilenameandlineno(tbInfo[0], tbInfo[1])
            if not isinstance(fname, ustr):
                fname = fname.decode('utf-8')
            example = tbInfo[3]
            # Reset info
            tblist[i] = (fname, lineno, tbInfo[2], example)

        # Format list
        strList = traceback.format_list(tblist)
        if strList:
            strList.insert(0, "Traceback (most recent call last):\n")
        strList.extend( traceback.format_exception_only(type, value) )

        # Write traceback
        for s in strList:
            self.write(s)

        # Clean up (we cannot combine except and finally in Python &lt;2.5
        tb = None
        frames = None

    except Exception:
        type, value, tb = sys.exc_info()
        tb = None
        frames = None
        t = 'An error occured, but then another one when trying to write the traceback: '
        t += str(value) + '\n'
        self.write(t)
</t>
<t tx="ekr.20190812072049.304">def correctfilenameandlineno(self, fname, lineno):
    """ Given a filename and lineno, this function returns
    a modified (if necessary) version of the two.
    As example:
    "foo.py+7", 22  -&gt; "foo.py", 29
    """
    j = fname.rfind('+')
    if j&gt;0:
        try:
            lineno += int(fname[j+1:])
            fname = fname[:j]
        except ValueError:
            pass
    return fname, lineno
</t>
<t tx="ekr.20190812072049.305">class ExecutedSourceCollection:
    """ Stores the source of executed pieces of code, so that the right
    traceback can be reproduced when an error occurs. The filename
    (including the +lineno suffix) is used as a key. We monkey-patch
    the linecache module so that we first try our cache to look up the
    lines. In that way we also allow third party modules (e.g. IPython)
    to get the lines for executed cells.
    """

    @others
</t>
<t tx="ekr.20190812072049.306">def __init__(self):
    self._cache = {}
    self._patch()
</t>
<t tx="ekr.20190812072049.307">def store_source(self, codeObject, source):
    self._cache[codeObject.co_filename] = source
</t>
<t tx="ekr.20190812072049.308">def _patch(self):
    def getlines(filename, module_globals=None):
        # Try getting the source from our own cache,
        # otherwise fallback to linecache's own cache
        src = self._cache.get(filename, '')
        if src:
            return [line+'\n' for line in src.splitlines()]
        else:
            import linecache
            if module_globals is None:
                return linecache._getlines(filename)  # only valid sig in 2.4
            else:
                return linecache._getlines(filename, module_globals)

    # Monkey patch
    import linecache
    linecache._getlines = linecache.getlines
    linecache.getlines =getlines

    # I hoped this would remove the +lineno for IPython tracebacks,
    # but it doesn't
#         def extract_tb(tb, limit=None):
#             print('aasdasd')
#             import traceback
#             list1 = traceback._extract_tb(tb, limit)
#             list2 = []
#             for (filename, lineno, name, line) in list1:
#                 filename, lineno = sys._pyzoInterpreter.correctfilenameandlineno(filename, lineno)
#                 list2.append((filename, lineno, name, line))
#             return list2
#
#         import traceback
#         traceback._extract_tb = traceback.extract_tb
#         traceback.extract_tb = extract_tb
</t>
<t tx="ekr.20190812072049.309">@path pyzo/pyzokernel/
@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072049.31">def onCursorPositionChanged(self):
    #If the end of the selection (or just the cursor if there is no selection)
    #is before the beginning of the line. make the document read-only
    cursor = self.textCursor()
    promptpos = self._cursor2.position()
    if cursor.position() &lt; promptpos or cursor.anchor() &lt; promptpos:
        self.setReadOnly(True)
    else:
        self.setReadOnly(False)
</t>
<t tx="ekr.20190812072049.310"># -*- coding: utf-8 -*-
import sys
import yoton
import inspect  # noqa - used in eval()

try:
    import thread # Python 2
except ImportError:
    import _thread as thread # Python 3
</t>
<t tx="ekr.20190812072049.311">class PyzoIntrospector(yoton.RepChannel):
    """ This is a RepChannel object that runs a thread to respond to
    requests from the IDE.
    """

    @others
</t>
<t tx="ekr.20190812072049.312">def _getNameSpace(self, name=''):
    """ _getNameSpace(name='')

    Get the namespace to apply introspection in.
    If name is given, will find that name. For example sys.stdin.

    """

    # Get namespace
    NS1 = sys._pyzoInterpreter.locals
    NS2 = sys._pyzoInterpreter.globals
    if not NS2:
        NS = NS1
    else:
        NS = NS2.copy()
        NS.update(NS1)

    # Look up a name?
    if not name:
        return NS
    else:
        try:
            # Get object
            ob = eval(name, None, NS)

            # Get namespace for this object
            if isinstance(ob, dict):
                NS = ob
            elif isinstance(ob, (list, tuple)):
                NS = {}
                count = -1
                for el in ob:
                    count += 1
                    NS['[%i]'%count] = el
            else:
                keys = dir(ob)
                NS = {}
                for key in keys:
                    try:
                        NS[key] = getattr(ob, key)
                    except Exception:
                        NS[key] = '&lt;unknown&gt;'

            # Done
            return NS

        except Exception:
            return {}
</t>
<t tx="ekr.20190812072049.313">def _getSignature(self, objectName):
    """ _getSignature(objectName)

    Get the signature of builtin, function or method.
    Returns a tuple (signature_string, kind), where kind is a string
    of one of the above. When none of the above, both elements in
    the tuple are an empty string.

    """

    # if a class, get init
    # not if an instance! -&gt; try __call__ instead
    # what about self?

    # Get valid object names
    parts = objectName.rsplit('.')
    objectNames = ['.'.join(parts[-i:]) for i in range(1,len(parts)+1)]

    # find out what kind of function, or if a function at all!
    NS = self._getNameSpace()
    fun1 = eval("inspect.isbuiltin(%s)"%(objectName), None, NS)
    fun2 = eval("inspect.isfunction(%s)"%(objectName), None, NS)
    fun3 = eval("inspect.ismethod(%s)"%(objectName), None, NS)
    fun4 = False
    fun5 = False
    if not (fun1 or fun2 or fun3):
        # Maybe it's a class with an init?
        if eval("hasattr(%s,'__init__')"%(objectName), None, NS):
            objectName += ".__init__"
            fun4 = eval("inspect.ismethod(%s)"%(objectName), None, NS)
        #  Or a callable object?
        elif eval("hasattr(%s,'__call__')"%(objectName), None, NS):
            objectName += ".__call__"
            fun5 = eval("inspect.ismethod(%s)"%(objectName), None, NS)

    sigs = ""
    if True:
        # the first line in the docstring is usually the signature
        tmp = eval("%s.__doc__"%(objectNames[-1]), {}, NS )
        sigs = ''
        if tmp:
            sigs = tmp.splitlines()[0].strip()
        # Test if doc has signature
        hasSig = False
        for name in objectNames: # list.append -&gt; L.apend(objec) -- blabla
            name +="("
            if name in sigs:
                hasSig = True
        # If not a valid signature, do not bother ...
        if (not hasSig) or (sigs.count("(") != sigs.count(")")):
            sigs = ""

    if fun1 or fun2 or fun3 or fun4 or fun5:

        if fun1:
            kind = 'builtin'
        elif fun2:
            kind = 'function'
        elif fun3:
            kind = 'method'
        elif fun4:
            kind = 'class'
        elif fun5:
            kind = 'callable'

        if not sigs:
            # Use intospection

            # collect
            try:
                tmp = eval("inspect.getargspec(%s)"%(objectName), None, NS)
            except Exception:  # the above fails on 2.4 (+?) for builtins
                tmp = None
                kind = ''

            if tmp is not None:
                args, varargs, varkw, defaults = tmp

                # prepare defaults
                if defaults is None:
                    defaults = ()
                defaults = list(defaults)
                defaults.reverse()
                # make list (back to forth)
                args2 = []
                for i in range(len(args)-fun4):
                    arg = args.pop()
                    if i &lt; len(defaults):
                        args2.insert(0, "%s=%s" % (arg, defaults[i]) )
                    else:
                        args2.insert(0, arg )
                # append varargs and kwargs
                if varargs:
                    args2.append( "*"+varargs )
                if varkw:
                    args2.append( "**"+varkw )

                # append the lot to our  string
                funname = objectName.split('.')[-1]
                sigs = "%s(%s)" % ( funname, ", ".join(args2) )

    elif sigs:
        kind = "function"
    else:
        sigs = ""
        kind = ""

    return sigs, kind

# todo: variant that also says whether it's a property/function/class/other
</t>
<t tx="ekr.20190812072049.314">def dir(self, objectName):
    """ dir(objectName)

    Get list of attributes for the given name.

    """
    #sys.__stdout__.write('handling '+objectName+'\n')
    #sys.__stdout__.flush()

    # Get namespace
    NS = self._getNameSpace()

    # Init names
    names = set()

    # Obtain all attributes of the class
    try:
        command = "dir(%s.__class__)" % (objectName)
        d = eval(command, {}, NS)
    except Exception:
        pass
    else:
        names.update(d)

    # Obtain instance attributes
    try:
        command = "%s.__dict__.keys()" % (objectName)
        d = eval(command, {}, NS)
    except Exception:
        pass
    else:
        names.update(d)

    # That should be enough, but in case __dir__ is overloaded,
    # query that as well
    try:
        command = "dir(%s)" % (objectName)
        d = eval(command, {}, NS)
    except Exception:
        pass
    else:
        names.update(d)

    # Respond
    return list(names)
</t>
<t tx="ekr.20190812072049.315">def dir2(self, objectName):
    """ dir2(objectName)

    Get variable names in currently active namespace plus extra information.
    Returns a list with strings, which each contain a (comma separated)
    list of elements: name, type, kind, repr.

    """
    try:
        name = ''
        names = ['','']
        def storeInfo(name, val):
            # Determine type
            typeName = type(val).__name__
            # Determine kind
            kind = typeName
            if typeName != 'type':
                if hasattr(val, '__array__') and hasattr(val, 'dtype'):
                    kind = 'array'
                elif isinstance(val, list):
                    kind = 'list'
                elif isinstance(val, tuple):
                    kind = 'tuple'
            # Determine representation
            if kind == 'array':
                tmp = 'x'.join([str(s) for s in val.shape])
                if tmp:
                    repres = '&lt;array %s %s&gt;' % (tmp, val.dtype.name)
                elif val.size:
                    tmp = str(float(val))
                    if 'int' in val.dtype.name:
                        tmp = str(int(val))
                    repres = '&lt;array scalar %s (%s)&gt;' % (val.dtype.name, tmp)
                else:
                    repres = '&lt;array empty %s&gt;' % (val.dtype.name)
            elif kind == 'list':
                repres = '&lt;list with %i elements&gt;' % len(val)
            elif kind == 'tuple':
                repres = '&lt;tuple with %i elements&gt;' % len(val)
            else:
                repres = repr(val)
                if len(repres) &gt; 80:
                    repres = repres[:77] + '...'
            # Store
            tmp = ','.join([name, typeName, kind, repres])
            names.append(tmp)

        # Get locals
        NS = self._getNameSpace(objectName)
        for name in NS.keys():  # name can be a key in a dict, i.e. not str
            if hasattr(name, 'startswith') and name.startswith('__'):
                continue
            try:
                storeInfo(str(name), NS[name])
            except Exception:
                pass

        return names

    except Exception:
        return []
</t>
<t tx="ekr.20190812072049.316">def signature(self, objectName):
    """ signature(objectName)

    Get signature.

    """
    try:
        text, kind = self._getSignature(objectName)
        return text
    except Exception:
        return None
</t>
<t tx="ekr.20190812072049.317">def doc(self, objectName):
    """ doc(objectName)

    Get documentation for an object.

    """

    # Get namespace
    NS = self._getNameSpace()

    try:

        # collect docstring
        h_text = ''
        # Try using the class (for properties)
        try:
            className = eval("%s.__class__.__name__"%(objectName), {}, NS)
            if '.' in objectName:
                tmp = objectName.rsplit('.',1)
                tmp[1] += '.'
            else:
                tmp = [objectName, '']
            if className not in ['type', 'module', 'builtin_function_or_method', 'function']:
                cmd = "%s.__class__.%s__doc__"
                h_text = eval(cmd % (tmp[0],tmp[1]), {}, NS)
        except Exception:
            pass

        # Normal doc
        if not h_text:
            h_text = eval("%s.__doc__"%(objectName), {}, NS )

        # collect more data
        h_repr = eval("repr(%s)"%(objectName), {}, NS )
        try:
            h_class = eval("%s.__class__.__name__"%(objectName), {}, NS )
        except Exception:
            h_class = "unknown"

        # docstring can be None, but should be empty then
        if not h_text:
            h_text = ""

        # get and correct signature
        h_fun, kind = self._getSignature(objectName)
        if kind == 'builtin' or not h_fun:
            h_fun = ""  # signature already in docstring or not available

        # cut repr if too long
        if len(h_repr) &gt; 200:
            h_repr = h_repr[:200] + "..."
        # replace newlines so we can separates the different parts
        h_repr = h_repr.replace('\n', '\r')

        # build final text
        text = '\n'.join([objectName, h_class, h_fun, h_repr, h_text])

    except Exception:
        type, value, tb = sys.exc_info()
        del tb
        text = '\n'.join([objectName, '', '', '', 'No help available. ', str(value)])

    # Done
    return text
</t>
<t tx="ekr.20190812072049.318">def eval(self, command):
    """ eval(command)

    Evaluate a command and return result.

    """

    # Get namespace
    NS = self._getNameSpace()

    try:
        # here globals is None, so we can look into sys, time, etc...
        return eval(command, None, NS)
    except Exception:
        return 'Error evaluating: ' + command
</t>
<t tx="ekr.20190812072049.319">def interrupt(self, command=None):
    """ interrupt()

    Interrupt the main thread. This does not work if the main thread
    is running extension code.

    A bit of a hack to do this in the introspector, but it's the
    easeast way and prevents having to launch another thread just
    to wait for an interrupt/terminare command.

    Note that on POSIX we can send an OS INT signal, which is faster
    and maybe more effective in some situations.

    """
    thread.interrupt_main()
</t>
<t tx="ekr.20190812072049.32">def ensureCursorAtEditLine(self):
    """
    If the text cursor is before the beginning of the edit line,
    move it to the end of the edit line
    """
    cursor = self.textCursor()
    promptpos = self._cursor2.position()
    if cursor.position() &lt; promptpos or cursor.anchor() &lt; promptpos:
        cursor.movePosition(cursor.End, A_MOVE) # Move to end of document
        self.setTextCursor(cursor)
        self.onCursorPositionChanged()
</t>
<t tx="ekr.20190812072049.320">def terminate(self, command=None):
    """ terminate()

    Ask the kernel to terminate by closing the stdin.

    """
    sys.stdin._channel.close()
</t>
<t tx="ekr.20190812072049.321">@path pyzo/pyzokernel/
@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072049.322"># -*- coding: utf-8 -*-
"""
Magic commands for the Pyzo kernel.
No need to use printDirect here, magic commands are just like normal Python
commands, in the sense that they print something etc.
"""

import sys
import os
import re
import time
import inspect
import tokenize, token, keyword
try:
    import io
except ImportError:  # Not on Python 2.4
    pass

# Set Python version and get some names
PYTHON_VERSION = sys.version_info[0]
if PYTHON_VERSION &lt; 3:
    input = raw_input  # noqa

MESSAGE = """List of *magic* commands:
    ?               - show this message
    ?X or X?        - show docstring of X
    ??X or X??      - help(X)
    cd              - show current directory
    cd X            - change directory
    ls              - list current directory
    who             - list variables in current workspace
    whos            - list variables plus their class and representation
    timeit X        - times execution of command X
    open X          - open file X or the Python module that defines object X
    run X           - run file X
    install         - install a new package
    update          - update an installed package
    remove          - remove (i.e. uninstall) an installed package
    uninstall       - alias for remove
    conda           - manage packages using conda
    pip             - manage packages using pip
    db X            - debug commands
    cls             - clear screen
    notebook        - launch the Jupyter notebook
"""

TIMEIT_MESSAGE = """Time execution duration. Usage:
    timeit fun  # where fun is a callable
    timeit 'expression'
    timeit expression
    timeit 20 fun/expression  # tests 20 passes
"""
</t>
<t tx="ekr.20190812072049.323">def _should_not_interpret_as_magic(line):
    interpreter = sys._pyzoInterpreter

    # Check that line is not some valid python input
    try:
        # gets a list of 5-tuples, of which [0] is the type of token and [1] is the token string
        ltok = list(tokenize.tokenize(io.BytesIO(line.encode('utf-8')).readline))
    except tokenize.TokenError:  # typically this means an unmatched parenthesis
                                 # (which should not happen because these are detected before)
        return True

    # ignore garbage and indentation at the beginning
    pos = 0
    while pos &lt; len(ltok) and ltok[pos][0] in [59, token.INDENT, tokenize.ENCODING]:
        # 59 is BACKQUOTE but there is no token.BACKQUOTE...
        pos = pos + 1
    # when line is only garbage or does not begin with a name
    if pos &gt;= len(ltok) or ltok[pos][0] != token.NAME:
        return True
    command = ltok[pos][1]
    if keyword.iskeyword(command):
        return True
    pos = pos + 1
    # command is alone on the line
    if pos &gt;= len(ltok) or ltok[pos][0] in [token.ENDMARKER, tokenize.COMMENT]:
        if command in interpreter.locals:
            return True
        if interpreter.globals and command in interpreter.globals:
            return True
    else: # command is not alone ; next token should not be an operator (this includes parentheses)
        if ltok[pos][0] == token.OP and not line.endswith('?'):
            return True

    return False
</t>
<t tx="ekr.20190812072049.324">class Magician:

    @others
</t>
<t tx="ekr.20190812072049.325">def _eval(self, command):

    # Get namespace
    NS1 = sys._pyzoInterpreter.locals
    NS2 = sys._pyzoInterpreter.globals
    if not NS2:
        NS = NS1
    else:
        NS = NS2.copy()
        NS.update(NS1)

    # Evaluate in namespace
    return eval(command, {}, NS)
</t>
<t tx="ekr.20190812072049.326">def convert_command(self, line):
    """ convert_command(line)

    Convert a given command from a magic command to Python code.
    Returns the converted command if it was a magic command, or
    the original otherwise.

    """
    # Get converted command, catch and report errors
    try:
        res = self._convert_command(line)
    except Exception:
        # Try informing about line number
        type, value, tb = sys.exc_info()
        msg = 'Error in handling magic function:\n'
        msg += '  %s\n' % str(value)
        if tb.tb_next: tb = tb.tb_next.tb_next
        while tb:
            msg += '  line %i in %s\n' % (tb.tb_lineno, tb.tb_frame.f_code.co_filename)
            tb = tb.tb_next
        # Clear
        del tb
        # Write
        print(msg)
        return None

    # Process
    if res is None:
        return line
    else:
        return res
</t>
<t tx="ekr.20190812072049.327">def _convert_command(self, line):

    # Get interpreter
    interpreter = sys._pyzoInterpreter
    command = line.rstrip()

    have_hard_chars = 'cd ', '?'
    if PYTHON_VERSION &gt;= 3 and not command.lower().startswith(have_hard_chars):
        try:
            if _should_not_interpret_as_magic(line):
                return
        except Exception:
            pass  # dont break interpreter if above func has a bug ...

    else:
        # Old, not as good check for outdated Python version
        # Check if it is a variable
        if ' ' not in command:
            if command in interpreter.locals:
                return
            if interpreter.globals and command in interpreter.globals:
                return

    # Clean and make case insensitive
    command = line.upper().rstrip()

    # Commands to always support (also with IPython)

    if not command:
        return

    elif command.startswith('DB'):
        return self.debug(line, command)

    elif command.startswith('NOTEBOOK'):
        return self.notebook(line, command)

    elif command.startswith('INSTALL'):
        return self.install(line, command)

    elif command.startswith('UPDATE') or command.startswith('UPGRADE'):
        line = line.replace('upgrade', 'update')
        command = command.replace('UPGRADE', 'UPDATE')
        return self.update(line, command)

    elif command.startswith('REMOVE') or command.startswith('UNINSTALL'):
        line = line.replace('uninstall', 'remove')
        return self.remove(line, command)

    elif command.startswith('CONDA'):
        return self.conda(line, command)

    elif command.startswith('PIP'):
        return self.pip(line, command)

    elif command == 'CLS':
        return self.cls(line, command)

    elif command.startswith('OPEN '):
        return self.open(line, command)

    elif interpreter._ipython:
        # Patch IPython magic

        # EDIT do not run code after editing
        if command.startswith('EDIT ') and not ' -X ' in command:
            return 'edit -x ' + line[5:]

        # In all cases stop processing magic commands
        return

    # Commands that we only support in the absense of IPtython

    elif command == '?':
        return 'print(%s)' % repr(MESSAGE)

    elif command.startswith("??"):
        return 'help(%s)' % line[2:].rstrip()
    elif command.endswith("??"):
        return 'help(%s)' % line.rstrip()[:-2]

    elif command.startswith("?"):
        return 'print(%s.__doc__)' % line[1:].rstrip()

    elif command.endswith("?"):
        return 'print(%s.__doc__)' % line.rstrip()[:-1]

    elif command.startswith('CD'):
        return self.cd(line, command)

    elif command.startswith('LS'):
        return self.ls(line, command)

    elif command.startswith('TIMEIT'):
        return self.timeit(line, command)

    elif command == 'WHO':
        return self.who(line, command)

    elif command == 'WHOS':
        return self.whos(line, command)

    elif command.startswith('RUN '):
        return self.run(line, command)
</t>
<t tx="ekr.20190812072049.328">def debug(self, line, command):
    if command == 'DB':
        line = 'db help'
    elif not command.startswith('DB '):
        return

    # Get interpreter
    interpreter = sys._pyzoInterpreter
    # Get command and arg
    line += ' '
    _, cmd, arg = line.split(' ', 2)
    cmd = cmd.lower()
    # Get func
    func = getattr(interpreter.debugger, 'do_'+cmd, None)
    # Call or show warning
    if func is not None:
        func(arg.strip())
    else:
        interpreter.write("Unknown debug command: %s.\n" % cmd)
    # Done (no code to execute)
    return ''
</t>
<t tx="ekr.20190812072049.329">def cd(self, line, command):
    if command == 'CD' or command.startswith("CD ") and '=' not in command:
        path = line[3:].strip()
        if path:
            try:
                os.chdir(path)
            except Exception:
                print('Could not change to directory "%s".' % path)
                return ''
            newPath = os.getcwd()
        else:
            newPath = os.getcwd()
        # Done
        print(repr(newPath))
        return ''
</t>
<t tx="ekr.20190812072049.33">def mousePressEvent(self, event):
    """
    - Disable right MB and middle MB (which pastes by default).
    - Focus policy
        If a user clicks this shell, while it has no focus, we do
        not want the cursor position to change (since generally the
        user clicks the shell to give it the focus). We do this by
        setting the focus-policy to Qt::TabFocus, and we give the
        widget its focus manually from the mousePressedEvent event
        handler

    """

    if not self.hasFocus():
        self.setFocus()
        return

    if event.button() != QtCore.Qt.MidButton:
        super().mousePressEvent(event)
</t>
<t tx="ekr.20190812072049.330">def ls(self, line, command):
    if command == 'LS' or command.startswith("LS ") and '=' not in command:
        path = line[3:].strip()
        if not path:
            path = os.getcwd()
        L = [p for p in os.listdir(path) if not p.startswith('.')]
        text = '\n'.join(sorted(L))
        # Done
        print(text)
        return ''
</t>
<t tx="ekr.20190812072049.331">def timeit(self, line, command):
    if command == "TIMEIT":
        return 'print(%s)' % repr(TIMEIT_MESSAGE)
    elif command.startswith("TIMEIT "):
        expression = line[7:]
        # Get number of iterations
        N = 1
        tmp = expression.split(' ',1)
        if len(tmp)==2:
            try:
                N = int(tmp[0])
                expression = tmp[1]
            except Exception:
                N = 1
        if expression[0] not in '\'\"':
            isidentifier = lambda x: bool(re.match(r'[a-z_]\w*$', x, re.I))
            if not isidentifier(expression):
                expression = "'%s'" % expression
        # Compile expression
        line2 = 'import timeit; t=timeit.Timer(%s);' % expression
        line2 += 'print(str( t.timeit(%i)/%i ) ' % (N, N)
        line2 += '+" seconds on average for %i iterations." )' % N
        #
        return line2
</t>
<t tx="ekr.20190812072049.332">def who(self, line, command):
    L = self._eval('dir()\n')
    L = [k for k in L if not k.startswith('__')]
    if L:
        print(', '.join(L))
    else:
        print("There are no variables defined in this scope.")
    return ''
</t>
<t tx="ekr.20190812072049.333">def _justify(self, line, width, offset):
    realWidth = width - offset
    if len(line) &gt; realWidth:
        line = line[:realWidth-3] + '...'
    return line.ljust(width)
</t>
<t tx="ekr.20190812072049.334">def whos(self, line, command):
    # Get list of variables
    L = self._eval('dir()\n')
    L = [k for k in L if not k.startswith('__')]
    # Anny variables?
    if not L:
        print("There are no variables defined in this scope.")
        return ''
    else:
        text = "VARIABLE: ".ljust(20,' ') + "TYPE: ".ljust(20,' ')
        text += "REPRESENTATION: ".ljust(20,' ') + '\n'
    # Create list item for each variablee
    for name in L:
        ob = self._eval(name)
        cls = ''
        if hasattr(ob, '__class__'):
            cls = ob.__class__.__name__
        rep = repr(ob)
        text += self._justify(name,20,2) + self._justify(cls,20,2)
        text += self._justify(rep,40,2) + '\n'
    # Done
    print(text)
    return ''
</t>
<t tx="ekr.20190812072049.335">def cls(self, line, command):
    sys._pyzoInterpreter.context._strm_action.send('cls')
    return ''
</t>
<t tx="ekr.20190812072049.336">def open(self, line, command):

    # Get what to open
    name = line.split(' ',1)[1].strip()
    fname = ''
    linenr = None

    # Is it a file name?
    tmp = os.path.join(os.getcwd(), name)
    #
    if name[0] in '"\'' and name[-1] in '"\'': # Explicitly given
        fname = name[1:-1]
    elif os.path.isfile(tmp):
        fname = tmp
    elif os.path.isfile(name):
        fname = name

    else:
        # Then it maybe is an object

        # Get the object
        try:
            ob = self._eval(name)
        except NameError:
            print('There is no object known as "%s"' % name)
            return ''

        # Try get filename
        for iter in range(3):
            # Try successive steps
            if iter == 0:
                ob = ob
            elif iter == 1 and not isinstance(ob, type):
                ob = ob.__class__
            elif iter == 2 and hasattr(ob, '__module__'):
                ob = sys.modules[ob.__module__]
            # Try get fname
            fname = ''
            try:
                fname = inspect.getsourcefile(ob)
            except Exception:
                pass
            # Returned fname may simply be x.replace('.pyc', '.py')
            if os.path.isfile(fname):
                break

        # Try get line number
        if fname:
            try:
                lines, linenr = inspect.getsourcelines(ob)
            except Exception:
                pass

    # Almost done
    # IPython's edit now support this via our hook in interpreter.py
    if not fname:
        print('Could not determine file name for object "%s".' % name)
    elif linenr is not None:
        action = 'open %i %s' % (linenr, os.path.abspath(fname))
        sys._pyzoInterpreter.context._strm_action.send(action)
    else:
        action = 'open %s' % os.path.abspath(fname)
        sys._pyzoInterpreter.context._strm_action.send(action)
    #
    return ''
</t>
<t tx="ekr.20190812072049.337">def run(self, line, command):

    # Get what to open
    name = line.split(' ',1)[1].strip()
    fname = ''

    # Enable dealing with qoutes
    if name[0] in '"\'' and name[-1] in '"\'':
        name = name[1:-1]

    # Is it a file name?
    tmp = os.path.join(os.getcwd(), name)
    #
    if os.path.isfile(tmp):
        fname = tmp
    elif os.path.isfile(name):
        fname = name

    # Go run!
    if not fname:
        print('Could not find file to run "%s".' % name)
    else:
        sys._pyzoInterpreter.runfile(fname)
    #
    return ''
</t>
<t tx="ekr.20190812072049.338">def _hasconda(self):
    try:
        from conda import __version__
    except ImportError:
        return False
    return True
</t>
<t tx="ekr.20190812072049.339">def install(self, line, command):
    if not command.startswith('INSTALL '):
        return

    hasconda = self._hasconda()

    if hasconda:
        text = "Trying installation with conda. If this does not work, try:\n"
        text += "   pip " + line + "\n"
    else:
        text = "Trying installation with pip\n"

    print("\x1b[34m\x1b[1m" + text + "\x1b[0m")
    time.sleep(0.2)

    if hasconda:
        self.conda('conda ' + line, 'CONDA')
    else:
        self.pip('pip ' + line, 'PIP')
    return ''
</t>
<t tx="ekr.20190812072049.34">def contextMenuEvent(self, event):
    """ Do not show context menu. """
    pass
</t>
<t tx="ekr.20190812072049.340">def update(self, line, command):
    if not command.startswith('UPDATE '):
        return

    hasconda = self._hasconda()

    if hasconda:
        text = "Trying update with conda. If this does not work, try:\n"
        text += "   pip " + line.replace('update', 'install') + " --upgrade\n"
    else:
        text = "Trying pip install --upgrade\n"

    print("\x1b[34m\x1b[1m" + text + "\x1b[0m")
    time.sleep(0.2)

    if hasconda:
        self.conda('conda ' + line, 'CONDA')
    else:
        self.pip('pip ' + line.replace('update', 'install') + " --upgrade", 'PIP')
    return ''
</t>
<t tx="ekr.20190812072049.341">def remove(self, line, command):
    if not command.startswith(('REMOVE ', 'UNINSTALL')):
        return

    hasconda = self._hasconda()

    if hasconda:
        text = "Trying remove/uninstall with conda. If this does not work, try:\n"
        text += "   pip " + line.replace('remove', 'uninstall') + "\n"
    else:
        text = "Trying remove/uninstall with pip\n"

    if hasconda:
        self.conda('conda ' + line, 'CONDA')
    else:
        self.pip('pip ' + line.replace('remove', 'uninstall'), 'PIP')
    return ''
</t>
<t tx="ekr.20190812072049.342">def conda(self, line, command):

    if not (command == 'CONDA' or command.startswith('CONDA ')):
        return

    # Get command args
    args = line.split(' ')
    args = [w for w in args if w]
    args.pop(0) # remove 'conda'

    # Stop if user does "conda = ..."
    if args and '=' in args[0]:
        return

    # Add channels when using install, this gets added last, so
    # that user-specified channels take preference
    channel_list = []
    if args and args[0] == 'install':
        channel_list = ['-c', 'conda-forge', '-c', 'pyzo']

    def write_no_dots(x):
        if x.strip() == '.':  # note, no "x if y else z" in Python 2.4
            return 0
        return stderr_write(x)

    # Go!
    # Weird double-try, to make work on Python 2.4
    oldargs = sys.argv
    stderr_write = sys.stderr.write
    try:
        try:
            # older version of conda would spew dots to stderr during downloading
            sys.stderr.write = write_no_dots
            import conda  # noqa
            from conda.cli import main
            sys.argv = ['conda'] + list(args) + channel_list
            main()
        except SystemExit:  # as err:
            type, err, tb = sys.exc_info(); del tb
            err = str(err)
            if len(err) &gt; 4:  # Only print if looks like a message
                print(err)
        except Exception:  # as err:
            type, err, tb = sys.exc_info(); del tb
            print('Error in conda command:')
            print(err)
    finally:
        sys.argv = oldargs
        sys.stderr.write = stderr_write

    return ''
</t>
<t tx="ekr.20190812072049.343">def _check_imported_modules(self):
    KNOWN_PURE_PYHON = ('conda', 'yaml', 'IPython', 'requests',
                        'readline', 'pyreadline')
    if not sys.platform.startswith('win'):
        return  # Only a problem on Windows
    # Check what modules are currently imported
    loaded_modules = set()
    for name, mod in sys.modules.items():
        if 'site-packages' in getattr(mod, '__file__', ''):
            name = name.split('.')[0]
            if name.startswith('_') or name in KNOWN_PURE_PYHON:
                continue
            loaded_modules.add(name)
    # Add PySide PyQt4 from IEP if prefix is the same
    if os.getenv('IEP_PREFIX', '') == sys.prefix:
        loaded_modules.add(os.getenv('IEP_QTLIB', 'qt'))
    # Warn if we have any such modules
    loaded_modules = [m.lower() for m in loaded_modules if m]
    if loaded_modules:
        print('WARNING! The following modules are currently loaded:\n')
        print('  ' + ', '.join(sorted(loaded_modules)))
        print('\nUpdating or removing them may fail if they are not '
              'pure Python.\nIf none of the listed packages is updated or '
              'removed, it is safe\nto proceed (use "f" if necessary).\n')
        print('-'*80)
        time.sleep(2.0)  # Give user time to realize there is a warning
</t>
<t tx="ekr.20190812072049.344">def pip(self, line, command):

    if not (command == 'PIP' or command.startswith('PIP ')):
        return

    # Get command args
    args = line.split(' ')
    args = [w for w in args if w]
    args.pop(0) # remove 'pip'

    # Stop if user does "pip = ..."
    if args and '=' in args[0]:
        return

    # Tweak the args
    if args and args[0] == 'uninstall':
        args.insert(1, '--yes')

    # Go!
    try:
        from pyzokernel.pipper import pip_command
        pip_command(*args)
    except SystemExit:  # as err:
        type, err, tb = sys.exc_info(); del tb
        err = str(err)
        if len(err) &gt; 4:  # Only print if looks like a message
            print(err)
    except Exception:# as err:
        type, err, tb = sys.exc_info(); del tb
        print('Error in pip command:')
        print(err)

    return ''
# todo: I think we can deprecate this
</t>
<t tx="ekr.20190812072049.345">def notebook(self, line, command):

    if not (command == 'NOTEBOOK' or command.startswith('NOTEBOOK ')):
        return

    # Get command args
    args = line.split(' ')
    args = [w.replace('%20', ' ') for w in args if w]
    args.pop(0) # remove 'notebook'

    # Stop if user does "conda = ..."
    if args and '=' in args[0]:
        return

    # Go!
    # Weird double-try, to make work on Python 2.4
    oldargs = sys.argv
    try:
        try:
            import notebook.notebookapp
            sys.argv = ['jupyter_notebook'] + list(args)
            notebook.notebookapp.main()
        except SystemExit:  # as err:
            type, err, tb = sys.exc_info(); del tb
            err = str(err)
            if len(err) &gt; 4:  # Only print if looks like a message
                print(err)
        except Exception:  # as err:
            type, err, tb = sys.exc_info(); del tb
            print('Error in notebook command:')
            print(err)
    finally:
        sys.argv = oldargs

    return ''
</t>
<t tx="ekr.20190812072049.346">@path pyzo/pyzokernel/
# -*- coding: utf-8 -*-
# Copyright (C) 2013, Almar Klein

# From pyzo/pyzokernel

@others
if __name__ == '__main__':
    pip_command('install', 'networkx')

@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.347">import sys
import time
import subprocess
</t>
<t tx="ekr.20190812072049.348">def subprocess_with_callback(callback, cmd, **kwargs):
    """ Execute command in subprocess, stdout is passed to the
    callback function. Returns the returncode of the process.
    If callback is None, simply prints any stdout.
    """

    # Set callback to void if None
    if callback is None:
        callback = lambda x:None

    # Execute command
    try:
        p = subprocess.Popen(cmd,
                    stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                    **kwargs)
    except OSError:
        type, err, tb = sys.exc_info(); del tb
        callback(str(err)+'\n')
        return -1

    pending = []
    while p.poll() is None:
        time.sleep(0.001)
        # Read text and process
        c = p.stdout.read(1).decode('utf-8', 'ignore')
        pending.append(c)
        if c in '.\n':
            callback(''.join(pending))
            pending = []

    # Process remaining text
    pending.append( p.stdout.read().decode('utf-8') )
    callback( ''.join(pending) )

    # Done
    return p.returncode
</t>
<t tx="ekr.20190812072049.349">def print_(p):
    sys.stdout.write(p)
    sys.stdout.flush()
</t>
<t tx="ekr.20190812072049.35">def mouseDoubleClickEvent(self, event):
    BaseTextCtrl.mouseDoubleClickEvent(self, event)
    self._handleClickOnFilename(event.pos())
</t>
<t tx="ekr.20190812072049.350">def pip_command_exe(exe, *args):
    """ Do a pip command in the interpreter with the given exe.
    """

    # Get pip command
    cmd = [exe, '-m', 'pip'] + list(args)

    # Execute it
    subprocess_with_callback(print_, cmd)
</t>
<t tx="ekr.20190812072049.351">def pip_command(*args):
    """ Do a pip command, e.g. "install networkx".
    Installs in the current interpreter.
    """
    pip_command_exe(sys.executable, *args)
</t>
<t tx="ekr.20190812072049.352">@path pyzo/pyzokernel/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.353"># -*- coding: utf-8 -*-
""" pyzokernel/start.py

Starting script for remote processes in pyzo.
This script connects to the pyzo ide using the yoton interface
and imports remote2 to start the interpreter and introspection thread.

Channels
--------
There are four groups of channels. The ctrl channels are streams from
the ide to the kernel and/or broker. The strm channels are streams to
the ide. The stat channels are status channels. The reqp channels are
req/rep channels. All channels are TEXT except for a few OBJECT channels.

ctrl-command: to give simple commands to the interpreter (ala stdin)
ctrl-code (OBJECT): to let the interpreter execute blocks of code
ctrl-broker: to control the broker (restarting etc)

strm-out: the stdout of the interpreter
strm-err: the stderr of the interpreter
strm-raw: the C-level stdout and stderr of the interpreter (captured by broker)
strm-echo: the interpreters echos commands here
strm-prompt: to send the prompts explicitly
strm-broker: for the broker to send messages to the ide
strm-action: for the kernel to push actions to the ide

stat-interpreter): status of the interpreter (ready, busy, very busy, more, etc)
stat-debug (OBJECT): debug status
stat-startup (OBJECT): Used to pass startup parameters to the kernel

reqp-introspect (OBJECT): To query information from the kernel (and for interruping)

"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo/pyzokernel/start.py')
except Exception:
    leo_g = None

# This file is executed with the active directory one up from this file.
import os
import sys
import time
import yoton
import __main__ # we will run code in the __main__.__dict__ namespace
## Make connection object and get channels

# Create a yoton context. All channels are stored at the context.
ct = yoton.Context()

# Create control channels
ct._ctrl_command = yoton.SubChannel(ct, 'ctrl-command')
ct._ctrl_code = yoton.SubChannel(ct, 'ctrl-code', yoton.OBJECT)

# Create stream channels
ct._strm_out = yoton.PubChannel(ct, 'strm-out')
ct._strm_err = yoton.PubChannel(ct, 'strm-err')
ct._strm_echo = yoton.PubChannel(ct, 'strm-echo')
ct._strm_prompt = yoton.PubChannel(ct, 'strm-prompt')
ct._strm_action = yoton.PubChannel(ct, 'strm-action', yoton.OBJECT)

# Create status channels
ct._stat_interpreter = yoton.StateChannel(ct, 'stat-interpreter')
ct._stat_cd = yoton.StateChannel(ct, 'stat-cd')
ct._stat_debug = yoton.StateChannel(ct, 'stat-debug', yoton.OBJECT)
ct._stat_startup = yoton.StateChannel(ct, 'stat-startup', yoton.OBJECT)
ct._stat_breakpoints = yoton.StateChannel(ct, 'stat-breakpoints', yoton.OBJECT)

# Connect (port number given as command line argument)
# Important to do this *before* replacing the stdout etc, because if an
# error occurs here, it will be printed in the shell.
port = int(sys.argv[1])
ct.connect('localhost:'+str(port), timeout=1.0)

# Create file objects for stdin, stdout, stderr
sys.stdin = yoton.FileWrapper( ct._ctrl_command, echo=ct._strm_echo, isatty=True)
sys.stdout = yoton.FileWrapper( ct._strm_out, 256, isatty=True)
sys.stderr = yoton.FileWrapper( ct._strm_err, 256, isatty=True)

# Set fileno on both
sys.stdout.fileno = sys.__stdout__.fileno
sys.stderr.fileno = sys.__stderr__.fileno
# if leo_g: leo_g.pr('start.py: port %s, sys.argv: %r' % (port, sys.argv))
## Set Excepthook
</t>
<t tx="ekr.20190812072049.354">def pyzo_excepthook(type, value, tb):
    import sys
    def writeErr(err):
        sys.__stderr__.write(str(err)+'\n')
        sys.__stderr__.flush()
    writeErr("Uncaught exception in interpreter:")
    writeErr(value)
    if not isinstance(value, (OverflowError, SyntaxError, ValueError)):
        while tb:
            writeErr("-&gt; line %i of %s." % (
                        tb.tb_frame.f_lineno, tb.tb_frame.f_code.co_filename) )
            tb = tb.tb_next
    import time
    time.sleep(0.3) # Give some time for the message to be send

# Uncomment to detect error in the interpreter itself.
# But better not use it by default. For instance errors in qt events
# are also catched by this function. I think that is because it would
# allow you to show such exceptions in an error dialog.
#sys.excepthook = pyzo_excepthook

## Init interpreter and introspector request channel

# Delay import, so we can detect syntax errors using the except hook
from pyzokernel.interpreter import PyzoInterpreter
from pyzokernel.introspection import PyzoIntrospector

# Create interpreter instance and give dict in which to run all code
__pyzo__ = PyzoInterpreter( __main__.__dict__, '&lt;console&gt;')
sys._pyzoInterpreter = __pyzo__

# Store context
__pyzo__.context = ct

# Create introspection req channel (store at interpreter instance)
__pyzo__.introspector = PyzoIntrospector(ct, 'reqp-introspect')

## Clean up

# Delete local variables
del yoton, PyzoInterpreter, PyzoIntrospector, pyzo_excepthook
del ct, port
del os, sys, time

# Delete stuff we do not want
for name in [   '__file__',  # __main__ does not have a corresponding file
                '__loader__'  # prevent lines from this file to be shown in tb
            ]:
    globals().pop(name, None)
del name

## Start and stop

# Start introspector and enter the interpreter
__pyzo__.introspector.set_mode('thread')

try:
    __pyzo__.run()

finally:
    # Restore original streams, so that SystemExit behaves as intended
    import sys
    try:
        sys.stdout, sys.stderr = sys.__stdout__, sys.__stderr__
    except Exception:
        pass
    # Flush pending messages (raises exception if times out)
    try:
        __pyzo__.context.flush(0.1)
    except Exception:
        pass
    # Nicely exit by closing context (closes channels and connections). If we do
    # not do this on Python 3.2 (at least Windows) the exit delays 10s. (issue 79)
    try:
        __pyzo__.introspector.set_mode(0)
        __pyzo__.context.close()
    except Exception:
        pass
</t>
<t tx="ekr.20190812072049.355">@path pyzo/pyzokernel/
#-----------------------------------------------------------------------------
#  Copyright (C) 2013 Min RK
#
#  Distributed under the terms of the 2-clause BSD License.
#-----------------------------------------------------------------------------
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.356">from contextlib import contextmanager

import ctypes
import ctypes.util

objc = ctypes.cdll.LoadLibrary(ctypes.util.find_library('objc'))

void_p = ctypes.c_void_p
ull = ctypes.c_uint64

objc.objc_getClass.restype = void_p
objc.sel_registerName.restype = void_p
objc.objc_msgSend.restype = void_p
objc.objc_msgSend.argtypes = [void_p, void_p]

msg = objc.objc_msgSend
</t>
<t tx="ekr.20190812072049.357">def _utf8(s):
    """ensure utf8 bytes"""
    if not isinstance(s, bytes):
        s = s.encode('utf8')
    return s
</t>
<t tx="ekr.20190812072049.358">def n(name):
    """create a selector name (for methods)"""
    return objc.sel_registerName(_utf8(name))
</t>
<t tx="ekr.20190812072049.359">def C(classname):
    """get an ObjC Class by name"""
    return objc.objc_getClass(_utf8(classname))

# constants from Foundation

NSActivityIdleDisplaySleepDisabled             = (1 &lt;&lt; 40)
NSActivityIdleSystemSleepDisabled              = (1 &lt;&lt; 20)
NSActivitySuddenTerminationDisabled            = (1 &lt;&lt; 14)
NSActivityAutomaticTerminationDisabled         = (1 &lt;&lt; 15)
NSActivityUserInitiated                        = (0x00FFFFFF | NSActivityIdleSystemSleepDisabled)
NSActivityUserInitiatedAllowingIdleSystemSleep = (NSActivityUserInitiated &amp; ~NSActivityIdleSystemSleepDisabled)
NSActivityBackground                           = 0x000000FF
NSActivityLatencyCritical                      = 0xFF00000000
</t>
<t tx="ekr.20190812072049.36">def _handleClickOnFilename(self, mousepos):
    """ Check whether the text that is clicked is a filename
    and open the file in the editor. If a line number can also be
    detected, open the file at that line number.
    """

    # Get cursor and its current pos
    cursor = self.cursorForPosition(mousepos)
    ocursor = QtGui.QTextCursor(cursor)  # Make a copy to use below
    pos = cursor.positionInBlock()

    # Get line of text for the cursor
    cursor.movePosition(cursor.EndOfBlock, cursor.MoveAnchor)
    cursor.movePosition(cursor.StartOfBlock, cursor.KeepAnchor)
    line = cursor.selectedText()
    if len(line) &gt; 1024:
        return  # safety

    # Get the thing that is clicked, assuming it is delimited with quotes
    line = line.replace('\'', '"')
    before = line[:pos].split('"')[-1]
    after = line[pos:].split('"')[0]
    piece = before + after

    # Check if it looks like a filename, quit if it does not
    if len(piece) &lt; 4:
        return
    elif not ('/' in piece or '\\' in piece):
        return
    #
    if sys.platform.startswith('win'):
        if piece[1] != ':':
            return
    else:
        if not piece.startswith('/'):
            return
    #
    filename = piece

    # Split in parts for getting line number
    line = line[pos+len(after):]
    line = line.replace(',', ' ')
    parts = [p for p in line.split(' ') if p]
    # Iterate over parts
    linenr = None
    for i, part in enumerate(parts):
        if part in ('line', 'linenr', 'lineno'):
            try:
                linenr = int(parts[i+1])
            except IndexError:
                pass  # no more parts
            except ValueError:
                pass  # not an integer
            else:
                break

    # Try again IPython style
    # IPython shows a few lines with the active line indicated by an arrow
    if linenr is None:
        for i in range(4):
            cursor.movePosition(cursor.NextBlock, cursor.MoveAnchor)
            cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
            line = cursor.selectedText()
            if len(line) &gt; 1024:
                continue  # safety
            if not line.startswith('-'):
                continue
            parts = line.split(' ', 2)
            if parts[0] in ('-&gt;', '--&gt;', '---&gt;', '----&gt;', '-----&gt;'):
                try:
                    linenr = int(parts[1].strip())
                except IndexError:
                    pass  # too few parts
                except ValueError:
                    pass  # not an integer
                else:
                    break

    # Select word here (in shell)
    cursor = ocursor
    cursor.movePosition(cursor.Left, cursor.MoveAnchor, len(before))
    cursor.movePosition(cursor.Right, cursor.KeepAnchor, len(piece))
    self.setTextCursor(cursor)

    # For syntax errors we have the offset thingy in the file name
    if '.py+' in filename[-9:]:
        filename, _, offset = filename.rpartition('+')
        if linenr is not None:
            try:
                linenr += int(offset)
            except ValueError:
                pass

    # Try opening the file (at the line number if we have one)
    result = pyzo.editors.loadFile(filename)
    if result and linenr is not None:
            editor = result._editor
            editor.gotoLine(linenr)
            cursor = editor.textCursor()
            cursor.movePosition(cursor.StartOfBlock)
            cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
            editor.setTextCursor(cursor)

##Indentation: override code editor behaviour
</t>
<t tx="ekr.20190812072049.360">def beginActivityWithOptions(options, reason=""):
    """Wrapper for:

    [ [ NSProcessInfo processInfo]
        beginActivityWithOptions: (uint64)options
                          reason: (str)reason
    ]
    """
    NSProcessInfo = C('NSProcessInfo')
    NSString = C('NSString')

    reason = msg(NSString, n("stringWithUTF8String:"), _utf8(reason))
    info = msg(NSProcessInfo, n('processInfo'))
    activity = msg(info,
        n('beginActivityWithOptions:reason:'),
        ull(options),
        void_p(reason)
    )
    return activity
</t>
<t tx="ekr.20190812072049.361">def endActivity(activity):
    """end a process activity assertion"""
    NSProcessInfo = C('NSProcessInfo')
    info = msg(NSProcessInfo, n('processInfo'))
    msg(info, n("endActivity:"), void_p(activity))

_theactivity = None
</t>
<t tx="ekr.20190812072049.362">def nope():
    """disable App Nap by setting NSActivityUserInitiatedAllowingIdleSystemSleep"""
    global _theactivity
    _theactivity = beginActivityWithOptions(
        NSActivityUserInitiatedAllowingIdleSystemSleep,
        "Because Reasons"
    )
</t>
<t tx="ekr.20190812072049.363">def nap():
    """end the caffeinated state started by `nope`"""
    global _theactivity
    if _theactivity is not None:
        endActivity(_theactivity)
        _theactivity = None
</t>
<t tx="ekr.20190812072049.364">def napping_allowed():
    """is napping allowed?"""
    return _theactivity is None
</t>
<t tx="ekr.20190812072049.365">@contextmanager
def nope_scope(
        options=NSActivityUserInitiatedAllowingIdleSystemSleep,
        reason="Because Reasons"
    ):
    """context manager for beginActivityWithOptions.

    Within this context, App Nap will be disabled.
    """
    activity = beginActivityWithOptions(options, reason)
    try:
        yield
    finally:
        endActivity(activity)

__all__ = [
    "NSActivityIdleDisplaySleepDisabled",
    "NSActivityIdleSystemSleepDisabled",
    "NSActivitySuddenTerminationDisabled",
    "NSActivityAutomaticTerminationDisabled",
    "NSActivityUserInitiated",
    "NSActivityUserInitiatedAllowingIdleSystemSleep",
    "NSActivityBackground",
    "NSActivityLatencyCritical",
    "beginActivityWithOptions",
    "endActivity",
    "nope",
    "nap",
    "napping_allowed",
    "nope_scope",
]
</t>
<t tx="ekr.20190812072049.366">@path pyzo/pyzokernel/
@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072049.367"># -*- coding: utf-8 -*-
"""
The pyzokernel package contains the code for the Pyzo kernel process.
This kernel is designed to be relatively lightweight; i.e. most of
the work is done by the IDE.

See pyzokernel/start.py for more information.
"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('IMPORT pyzo.pyzokernel')
except Exception:
    leo_g = None

import sys
</t>
<t tx="ekr.20190812072049.368">def printDirect(msg):
    """ Small function that writes directly to the strm_out channel.
    This means that regardless if stdout was hijacked, the message ends
    up at the Pyzo shell. This keeps any hijacked stdout clean, and gets
    the message where you want it. In most cases this is just cosmetics:
    the Python banner is one example.
    """
    import sys
    sys._pyzoInterpreter.context._strm_out.send(msg)
</t>
<t tx="ekr.20190812072049.37">def indentSelection(self):
    pass
</t>
<t tx="ekr.20190812072049.370"></t>
<t tx="ekr.20190812072049.371">@path pyzo/resources/
## Introduction
@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072049.372">"""
Welcome to the tutorial for Pyzo! This tutorial should get you
familiarized with Pyzo in just a few minutes. If you feel this tutorial
contains errors or lacks some information, please let us know via
pyzo@googlegroups.com.

Pyzo is a cross-platform Python IDE focused on interactivity and
introspection, which makes it very suitable for scientific computing.
Its practical design is aimed at simplicity and efficiency.

Pyzo consists of two main components, the editor and the shell, and
uses a set of pluggable tools to help the programmer in various ways.

"""

## The editor
"""
The editor (this window) is where your code is located; it is the central
component of Pyzo.

In the editor, each open file is represented as a tab. By right-clicking on
a tab, files can be run, saved, closed, etc.

The right mouse button also enables one to make a file the MAIN FILE of
a project. This file can be recognized by its star symbol and its blue filename,
and it enables running the file more easily (as we will see later in this
tutorial).

For larger projects, the Project manager tool can be used to manage your files
(also described later in this tutorial)
"""

## The shells
"""
The other main component is the window that holds the shells. When Pyzo
starts, a default shell is created. You can add more shells that run
simultaneously, and which may be of different Python versions.

It is good to know that the shells run in a sub-process, such that
when it is busy, Pyzo itself stays responsive, which allows you to
keep coding and even run code in another shell.

Another notable feature is that Pyzo can integrate the event loop of
five different GUI toolkits, thus enabling interactive plotting with
e.g., Visvis or Matplotlib.

Via "Shell &gt; Edit shell configurations", you can edit and add shell
configurations. This allows you to for example select the initial
directory, or use a custom PYTHONPATH.

"""

## The tools
"""
Via the "Tools" menu, one can select which tools to use. The tools can
be positioned in any way you want, and can also be un-docked.

Try the "Source Structure" tool to see the outline of this tutorial!

Note that the tools system is designed such that it's quite easy to
create your own tools. Look at the online wiki for more information,
or use one of the existing tools as an example. Also, Pyzo does not
need to restart to see new tools, or to update existing tools.

"""

## Running code
"""
Pyzo supports several ways to run source code in the editor. (see
also the "Run" menu).

  * Run selected lines. If a line is partially selected, the whole
    line is executed. If there is no selection, Pyzo will run the
    current line.

  * Run cell. A cell is everything between two commands starting
    with '##', such as the headings in this tutorial. Try running
    the code at the bottom of this cell!

  * Run file. This runs all the code in the current file.

  * Run project main file. Runs the code in the current project's
    main file.

Additionally, you can run the current file or the current project's
main file as a script. This will first restart the shell to provide
a clean environment. The shell is also initialized differently:

Things done on shell startup in INTERACTIVE MODE:
  * sys.argv = ['']
  * sys.path is prepended with an empty string (current working directory)
  * The working dir is set to the "Initial directory" of the shell config.
  * The PYTHONSTARTUP script is run.

Things done on shell startup in SCRIPT MODE:
  * __file__ = &lt;script_filename&gt;
  * sys.argv = [ &lt;script_filename&gt; ]
  * sys.path is prepended with the directory containing the script.
  * The working dir is set to the directory containing the script.

Depending on the settings of the Project mananger, the current project
directory may also be inserted in sys.path.
"""

a = 3
b = 4
print('The answer is ' + str(a+b))

## The menu
"""
Almost all functionality of Pyzo can be accessed via the menu. For more
advanced/specific stuff, you can use the logger tool (see also
Settings &gt; Advanced settings)

All actions in the menu can be accessed via a shortcut. Change the
shortcuts using the shortcut editor: Settings &gt; Edit key mappings.

"""

## Introspection
"""
Pyzo has strong introspection capabilities. Pyzo knows about the objects
in the shell, and parses (not runs) the source code in order to detect
the structure of your code. This enables powerful instospection such
as autocompletion, calltips, interactive help and source structure.

"""

## Debugging
"""
Pyzo supports post-mortem debugging, which means that after something
went wrong, you can inspect the stack trace to find the error.

The easiest way to start debugging is to press the "Debug" button
at the upper right corner of the shells.

Once in debug mode, the button becomes expandable, allowing you to
see the stack trace and go to any frame you like. (Starting debug mode
brings you to the bottom frame.) Changing a frame will make all objects
in that frame available in the shell. If possible, Pyzo will also show
the source file belonging to that frame, and select the line where the
error occurred.

Debugging can also be controlled via magic commands, enter "?" in the
shell for more information.

Below follows an example that you can run to test the debugging.

"""

import random
someModuleVariable = True
</t>
<t tx="ekr.20190812072049.373">def getNumber():
    return random.choice(range(10))
</t>
<t tx="ekr.20190812072049.374">def foo():
    spam = 'yum'
    eggs = 7
    value = bar()
</t>
<t tx="ekr.20190812072049.375">def bar():
    total = 0
    for i1 in range(100):
        i2 = getNumber()
        total += i1/i2
    return total

foo()

## The Project manager
"""
For working on projects, the Project manager tool can help you to keep
an overview of all your files. To open up the Project manager tool,
select it from the menu (Tools &gt; Project manager).

To add, remove, or edit your projects, click the button with the
wrench icon. In the dialog, select 'New project' to add a project and
select the directory where your project is located. When the project
is added, you can change the Project description (name).

You can select wether the project path is added to the Python
sys.path. This feature allows you to import project modules from the
shell, or from scripts which are not in the project root directory.
Note that this feature requires a restart of the shell to take effect
(Shell &gt; Restart)

The Project manager allows you to switch between your projects easily
using the selection box at the top. The tree view shows the files and
directories in your project. Files can be hidden using the filter that
is specified at the bottom of the Project manager, e.g. !*.pyc to hide
all files that have the extension pyc.
"""
</t>
<t tx="ekr.20190812072049.38">def dedentSelection(self):
    pass

## Key handlers
</t>
<t tx="ekr.20190812072049.381"></t>
<t tx="ekr.20190812072049.382">@path pyzo/tools/
@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072049.383"># -*- coding: utf-8 -*-
"""
This file provides the pyzo history viewer. It contains two main components: the
History class, which is a Qt model, and the PyzoHistoryViewer, which is a Qt view
"""
import pyzo
from pyzo.util.qt import QtCore, QtGui, QtWidgets  # noqa
from pyzo import translate
from pyzo.core.menu import Menu

tool_name = translate('pyzoHistoryViewer', 'History viewer')
tool_summary = "Shows the last used commands."

</t>
<t tx="ekr.20190812072049.384">class PyzoHistoryViewer(QtWidgets.QWidget):
    """
    The history viewer has several ways of using the data stored in the history:
     - double click a single item to execute in the current shell
     - drag and drop one or multiple selected lines into the editor or any
       other widget or application accepting plain text
     - copy selected items using the copy item in the pyzo edit menu
     - copy selected items using the context menu
     - execute selected items in the current shell using the context menu
    """
    @others
if __name__ == '__main__':
    import pyzo.core.main
    m = pyzo.core.main.MainWindow()
    view = PyzoHistoryViewer()
    view.show()
</t>
<t tx="ekr.20190812072049.385">def __init__(self, parent = None):
    super().__init__(parent)

    # Widgets
    self._search = QtWidgets.QLineEdit(self)
    self._list = QtWidgets.QListWidget(self)

    # Set monospace
    font = self._list.font()
    font.setFamily(pyzo.config.view.fontname)
    self._list.setFont(font)

    # Layout
    layout = QtWidgets.QVBoxLayout(self)
    self.setLayout(layout)
    layout.addWidget(self._search, 0)
    layout.addWidget(self._list, 1)

    # Customize line edit
    self._search.setPlaceholderText(translate('menu', 'Search'))
    self._search.textChanged.connect(self._on_search)

    # Drag/drop
    self._list.setSelectionMode(self._list.ExtendedSelection)
    self._list.setDragEnabled(True)
    self._list.doubleClicked.connect(self._onDoubleClicked)

    # Context menu
    self._menu = Menu(self, translate("menu", "History"))
    self._menu.addItem(translate("menu", "Copy ::: Copy selected lines"),
        pyzo.icons.page_white_copy, self.copy, "copy")
    self._menu.addItem(translate("menu", "Run ::: Run selected lines in current shell"),
        pyzo.icons.run_lines, self.runSelection, "run")
    self._menu.addItem(translate("menu", "Remove ::: Remove selected history items(s)"),
        pyzo.icons.delete, self.removeSelection, "remove")

    self._list.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self._list.customContextMenuRequested.connect(self._onCustomContextMenuRequested)

    # Populate
    for command in pyzo.command_history.get_commands():
        self._list.addItem(command)

    # Scroll to end of list on start up
    self._list.setCurrentRow(self._list.count()-1)
    item = self._list.currentItem()
    self._list.scrollToItem(item)

    # Keep up to date ...
    pyzo.command_history.command_added.connect(self._on_command_added)
    pyzo.command_history.command_removed.connect(self._on_command_removed)
    pyzo.command_history.commands_reset.connect(self._on_commands_reset)
</t>
<t tx="ekr.20190812072049.386">def _on_search(self):
    needle = self._search.text()
    for i in range(self._list.count()):
        item = self._list.item(i)
        item.setHidden(bool(needle and needle not in item.text()))
## Keep track of history
</t>
<t tx="ekr.20190812072049.387">def _on_command_added(self, command):
    item = QtWidgets.QListWidgetItem(command, self._list)
    self._list.addItem(item)
    needle = self._search.text()
    item.setHidden(bool(needle and needle not in command))
    self._list.scrollToItem(item)
</t>
<t tx="ekr.20190812072049.388">def _on_command_removed(self, index):
    self._list.takeItem(index)
</t>
<t tx="ekr.20190812072049.389">def _on_commands_reset(self):
    self._list.clear()
    for command in pyzo.command_history.get_commands():
        self._list.addItem(command)
## User actions
</t>
<t tx="ekr.20190812072049.39">def keyPressEvent(self,event):

    if event.key() in [Qt.Key_Return, Qt.Key_Enter]:

        # First check if autocompletion triggered
        if self.potentiallyAutoComplete(event):
            return
        else:
            # Enter: execute line
            # Remove calltip and autocomp if shown
            self.autocompleteCancel()
            self.calltipCancel()

            # reset history needle
            self._historyNeedle = None

            # process
            self.processLine()
            return

    if event.key() == Qt.Key_Escape:
        # Escape clears command
        if not ( self.autocompleteActive() or self.calltipActive() ):
            self.clearCommand()

    if event.key() == Qt.Key_Home:
        # Home goes to the prompt.
        cursor = self.textCursor()
        if event.modifiers() &amp; Qt.ShiftModifier:
            cursor.setPosition(self._cursor2.position(), A_KEEP)
        else:
            cursor.setPosition(self._cursor2.position(), A_MOVE)
        #
        self.setTextCursor(cursor)
        self.autocompleteCancel()
        return

    if event.key() == Qt.Key_Insert:
        # Don't toggle between insert mode and overwrite mode.
        return True

    #Ensure to not backspace / go left beyond the prompt
    if event.key() in [Qt.Key_Backspace, Qt.Key_Left]:
        self._historyNeedle = None
        if self.textCursor().position() == self._cursor2.position():
            if event.key() == Qt.Key_Backspace:
                self.textCursor().removeSelectedText()
            return  #Ignore the key, don't go beyond the prompt

    if event.key() in [Qt.Key_Up, Qt.Key_Down] and not \
            self.autocompleteActive():

        # needle
        if self._historyNeedle is None:
            # get partly-written-command
            #
            # Select text
            cursor = self.textCursor()
            cursor.setPosition(self._cursor2.position(), A_MOVE)
            cursor.movePosition(cursor.End, A_KEEP)
            # Update needle text
            self._historyNeedle = cursor.selectedText()
            self._historyStep = 0

        #Browse through history
        if event.key() == Qt.Key_Up:
            self._historyStep +=1
        else: # Key_Down
            self._historyStep -=1
            if self._historyStep &lt; 1:
                self._historyStep = 1

        # find the command
        c = pyzo.command_history.find_starting_with(self._historyNeedle, self._historyStep)
        if c is None:
            # found nothing-&gt; reset
            self._historyStep = 0
            c = self._historyNeedle

        # Replace text
        cursor = self.textCursor()
        cursor.setPosition(self._cursor2.position(), A_MOVE)
        cursor.movePosition(cursor.End, A_KEEP)
        cursor.insertText(c)

        self.ensureCursorAtEditLine()
        return

    else:
        # Reset needle
        self._historyNeedle = None

    #if a 'normal' key is pressed, ensure the cursor is at the edit line
    if event.text():
        self.ensureCursorAtEditLine()

    #Default behaviour: BaseTextCtrl
    BaseTextCtrl.keyPressEvent(self,event)

## Cut / Copy / Paste / Drag &amp; Drop
</t>
<t tx="ekr.20190812072049.390">def _onCustomContextMenuRequested(self, pos):
    self._menu.popup(self._list.viewport().mapToGlobal(pos))
</t>
<t tx="ekr.20190812072049.391">def copy(self, event=None):
    text = '\n'.join(i.text() for i in self._list.selectedItems())
    QtWidgets.qApp.clipboard().setText(text)
</t>
<t tx="ekr.20190812072049.392">def removeSelection(self, event=None):
    indices = [i.row() for i in self._list.selectedIndexes()]
    for i in reversed(sorted(indices)):
        pyzo.command_history.pop(i)
</t>
<t tx="ekr.20190812072049.393">def runSelection(self, event=None):
    commands = [i.text() for i in self._list.selectedItems()]
    shell = pyzo.shells.getCurrentShell()
    if shell is not None:
        for command in reversed(commands):
            pyzo.command_history.append(command)
        shell.executeCommand('\n'.join(commands) + '\n')
        if len(commands) &gt; 1 and commands[-1].startswith(' '):
            shell.executeCommand('\n')  # finalize multi-command
</t>
<t tx="ekr.20190812072049.394">def _onDoubleClicked(self, index):
    text = '\n'.join(i.text() for i in self._list.selectedItems())
    shell = pyzo.shells.getCurrentShell()
    if shell is not None:
        shell.executeCommand(text + '\n')
        # Do not update history? Was this intended?
</t>
<t tx="ekr.20190812072049.395">@path pyzo/tools/
@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072049.396"># -*- coding: utf-8 -*-
import sys, re

from pyzo.util.qt import QtCore, QtGui, QtWidgets  # noqa
import pyzo

tool_name = pyzo.translate("pyzoInteractiveHelp","Interactive help")
tool_summary = "Shows help on an object when using up/down in autocomplete."

#
htmlWrap = """&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
"http://www.w3.org/TR/REC-html40/strict.dtd"&gt;
&lt;html&gt;
&lt;head&gt;
&lt;style type="text/css"&gt;
&lt;/style&gt;
&lt;/head&gt;
&lt;body style=" font-family:'Sans Serif'; font-size:{}pt; font-weight:400; font-style:normal;"&gt;
{}
&lt;/body&gt;
&lt;/html&gt;
"""

# Define title text (font-size percentage does not seem to work sadly.)
</t>
<t tx="ekr.20190812072049.397">def get_title_text(objectName, h_class='', h_repr=''):
    title_text = "&lt;p style='background-color:#def;'&gt;"
    title_text += "&lt;b&gt;Object:&lt;/b&gt; {}".format(objectName)
    if h_class:
        title_text += ", &lt;b&gt;class:&lt;/b&gt; {}".format(h_class)
    if h_repr:
        if len(h_repr) &gt; 40:
            h_repr = h_repr[:37] + '...'
        title_text += ", &lt;b&gt;repr:&lt;/b&gt; {}".format(h_repr)

    # Finish
    title_text += '&lt;/p&gt;\n'
    return title_text

initText =  """
Help information is queried from the current shell
when moving up/down in the autocompletion list
and when double clicking on a name.
"""
</t>
<t tx="ekr.20190812072049.398">class PyzoInteractiveHelp(QtWidgets.QWidget):

    @others
</t>
<t tx="ekr.20190812072049.399">def __init__(self, parent):
    QtWidgets.QWidget.__init__(self, parent)

    # Create text field, checkbox, and button
    self._text = QtWidgets.QLineEdit(self)
    self._printBut = QtWidgets.QPushButton("Print", self)

    # Create options button
    self._options = QtWidgets.QToolButton(self)
    self._options.setIcon(pyzo.icons.wrench)
    self._options.setIconSize(QtCore.QSize(16,16))
    self._options.setPopupMode(self._options.InstantPopup)
    self._options.setToolButtonStyle(QtCore.Qt.ToolButtonTextBesideIcon)

    # Create options menu
    self._options._menu = QtWidgets.QMenu()
    self._options.setMenu(self._options._menu)

    # Create browser
    self._browser = QtWidgets.QTextBrowser(self)
    self._browser_text = initText

    # Create two sizers
    self._sizer1 = QtWidgets.QVBoxLayout(self)
    self._sizer2 = QtWidgets.QHBoxLayout()

    # Put the elements together
    self._sizer2.addWidget(self._text, 4)
    self._sizer2.addWidget(self._printBut, 0)
    self._sizer2.addWidget(self._options, 2)
    #
    self._sizer1.addLayout(self._sizer2, 0)
    self._sizer1.addWidget(self._browser, 1)
    #
    self._sizer1.setSpacing(2)
    self._sizer1.setContentsMargins(4,4,4,4)
    self.setLayout(self._sizer1)

    # Set config
    toolId =  self.__class__.__name__.lower()
    self._config = config = pyzo.config.tools[toolId]
    #
    if not hasattr(config, 'smartNewlines'):
        config.smartNewlines = True
    if not hasattr(config, 'fontSize'):
        if sys.platform == 'darwin':
            config.fontSize = 12
        else:
            config.fontSize = 10

    # Create callbacks
    self._text.returnPressed.connect(self.queryDoc)
    self._printBut.clicked.connect(self.printDoc)
    #
    self._options.pressed.connect(self.onOptionsPress)
    self._options._menu.triggered.connect(self.onOptionMenuTiggered)

    # Start
    self.setText()  # Set default text
    self.onOptionsPress() # Fill menu
</t>
<t tx="ekr.20190812072049.4">def __init__(self):
    self._closed = False
</t>
<t tx="ekr.20190812072049.40">def cut(self):
    """ Reimplement cut to only copy if part of the selected text
    is not at the prompt. """

    if self.isReadOnly():
        return self.copy()
    else:
        return BaseTextCtrl.cut(self)

#def copy(self): # no overload needed
</t>
<t tx="ekr.20190812072049.400">def onOptionsPress(self):
    """ Create the menu for the button, Do each time to make sure
    the checks are right. """

    # Get menu
    menu = self._options._menu
    menu.clear()

    # Add smart format option
    action = menu.addAction('Smart format')
    action.setCheckable(True)
    action.setChecked(bool(self._config.smartNewlines))

    # Add delimiter
    menu.addSeparator()

    # Add font size options
    currentSize = self._config.fontSize
    for i in range(8,15):
        action = menu.addAction('font-size: %ipx' % i)
        action.setCheckable(True)
        action.setChecked(i==currentSize)
</t>
<t tx="ekr.20190812072049.401">def onOptionMenuTiggered(self, action):
    """  The user decides what to show in the structure. """

    # Get text
    text = action.text().lower()

    if 'smart' in text:
        # Swap value
        current = bool(self._config.smartNewlines)
        self._config.smartNewlines = not current
        # Update
        self.queryDoc()

    elif 'size' in text:
        # Get font size
        size = int( text.split(':',1)[1][:-2] )
        # Update
        self._config.fontSize = size
        # Update
        self.setText()
</t>
<t tx="ekr.20190812072049.402">def setText(self, text=None):

    # (Re)store text
    if text is None:
        text = self._browser_text
    else:
        self._browser_text = text

    # Set text with html header
    size = self._config.fontSize
    self._browser.setHtml(htmlWrap.format(size,text))
</t>
<t tx="ekr.20190812072049.403">def setObjectName(self, name):
    """ Set the object name programatically
    and query documentation for it. """
    self._text.setText(name)
    self.queryDoc()
</t>
<t tx="ekr.20190812072049.404">def printDoc(self):
    """ Print the doc for the text in the line edit. """
    # Get name
    name = self._text.text()
    # Tell shell to print doc
    shell = pyzo.shells.getCurrentShell()
    if shell and name:
        shell.processLine('print({}.__doc__)'.format(name))
</t>
<t tx="ekr.20190812072049.405">def queryDoc(self):
    """ Query the doc for the text in the line edit. """
    # Get name
    name = self._text.text()
    # Get shell and ask for the documentation
    shell = pyzo.shells.getCurrentShell()
    if shell and name:
        future = shell._request.doc(name)
        future.add_done_callback(self.queryDoc_response)
    elif not name:
        self.setText(initText)
</t>
<t tx="ekr.20190812072049.406">def queryDoc_response(self, future):
    """ Process the response from the shell. """

    # Process future
    if future.cancelled():
        #print('Introspect cancelled') # No living kernel
        return
    elif future.exception():
        print('Introspect-queryDoc-exception: ', future.exception())
        return
    else:
        response = future.result()
        if not response:
            return

    try:
        # Get parts
        parts = response.split('\n')
        objectName, h_class, h_fun, h_repr = tuple(parts[:4])
        h_text = '\n'.join(parts[4:])

        # Obtain newlines that we hid for repr
        h_repr.replace('/r', '/n')

        # Make all newlines \n in h_text and strip
        h_text = h_text.replace('\r\n', '\n').replace('\r', '\n')
        h_text = h_text.lstrip()

        # Init text
        text = ''

        # These signs will fool the html
        h_repr = h_repr.replace("&lt;","&amp;lt;")
        h_repr = h_repr.replace("&gt;","&amp;gt;")
        h_text = h_text.replace("&lt;","&amp;lt;")
        h_text = h_text.replace("&gt;","&amp;gt;")

        if self._config.smartNewlines:

            # Make sure the signature is separated from the rest using at
            # least two newlines
            header = ''
            if True:
                # Get short version of objectName
                name = objectName.split('.')[-1]
                # Is the signature in the docstring?
                docs = h_text.replace('\n','|')
                tmp = re.search('[a-zA-z_\.]*?'+name+'\(.*?\)', docs)
                if tmp and tmp.span(0)[0]&lt;5:
                    header = tmp.group(0)
                    h_text = h_text[len(header):].lstrip(':').lstrip()
                    header = header.replace('|','')
                    #h_text = header + '\n\n' + h_text
                elif h_text.startswith(objectName) or h_text.startswith(name):
                    header, sep, docs = h_text.partition('\n')
                    #h_text = header + '\n\n' + docs
                    h_text = docs

            # Parse the text as rest/numpy like docstring
            h_text = self.smartFormat(h_text)
            if header:
                h_text = "&lt;p style='color:#005;'&gt;&lt;b&gt;%s&lt;/b&gt;&lt;/p&gt;\n%s" % (
                                                        header, h_text)
                #h_text = "&lt;b&gt;%s&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;\n%s" % (header, h_text)
        else:
            # Make newlines html
            h_text = h_text.replace("\n","&lt;br /&gt;")

        # Compile rich text
        text += get_title_text(objectName, h_class, h_repr)
        text += '{}&lt;br /&gt;'.format(h_text)

    except Exception as why:
        try:
            text += get_title_text(objectName, h_class, h_repr)
            text += h_text
        except Exception:
            text = response

    # Done
    # size = self._config.fontSize
    self.setText(text)
</t>
<t tx="ekr.20190812072049.407">def smartFormat(self, text):

    # Get lines
    lines = text.splitlines()

    # Test minimal indentation
    minIndent = 9999
    for line in lines[1:]:
        line_ = line.lstrip()
        indent = len(line) - len(line_)
        if line_:
            minIndent = min(minIndent, indent)

    # Remove minimal indentation
    lines2 = [lines[0]]
    for line in lines[1:]:
        lines2.append( line[minIndent:] )

    # Prepare
    prevLine_ = ''
    prevIndent = 0
    prevWasHeader = False
    inExample = False
    forceNewline = False

    # Format line by line
    lines3 = []
    for line in lines2:

        # Get indentation
        line_ = line.lstrip()
        indent = len(line) - len(line_)
        #indentPart = line[:indent-minIndent]
        indentPart = line[:indent]

        if not line_:
            lines3.append("&lt;br /&gt;")
            forceNewline = True
            continue

        # Indent in html
        line = "&amp;nbsp;" * len(indentPart) + line

        # Determine if we should introduce a newline
        isHeader = False
        if ("---" in line or "===" in line) and indent == prevIndent:
            # Header
            lines3[-1] = '&lt;b&gt;' + lines3[-1] + '&lt;/b&gt;'
            line = ''#'&lt;br /&gt; ' + line
            isHeader = True
            inExample = False
            # Special case, examples
            if prevLine_.lower().startswith('example'):
                inExample = True
            else:
                inExample = False
        elif ' : ' in line:
            tmp = line.split(' : ',1)
            line = '&lt;br /&gt;&lt;u&gt;' + tmp[0] + '&lt;/u&gt; : ' + tmp[1]
        elif line_.startswith('* '):
            line = '&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;#8226;' + line_[2:]
        elif prevWasHeader or inExample or forceNewline:
            line = '&lt;br /&gt;' + line
        else:
            if prevLine_:
                line = " " + line_
            else:
                line = line_

        # Force next line to be on a new line if using a colon
        if ' : ' in line:
            forceNewline = True
        else:
            forceNewline = False

        # Prepare for next line
        prevLine_ = line_
        prevIndent = indent
        prevWasHeader = isHeader

        # Done with line
        lines3.append(line)

    # Done formatting
    return ''.join(lines3)
</t>
<t tx="ekr.20190812072049.408">@path pyzo/tools/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.409"># -*- coding: utf-8 -*-
import sys, os, code

import pyzo
from pyzo.core.shell import BaseShell
from pyzo.core.pyzoLogging import splitConsole

tool_name = pyzo.translate("pyzoLogger","Logger")
tool_summary = "Logs messages, warnings and errors within Pyzo."
</t>
<t tx="ekr.20190812072049.41">def paste(self):
    """ Reimplement paste to paste at the end of the edit line when
    the position is at the prompt. """
    self.ensureCursorAtEditLine()
    # Paste normally
    return BaseTextCtrl.paste(self)
</t>
<t tx="ekr.20190812072049.410">class PyzoLogger(BaseShell):
    """ Shell that logs all messages produced by pyzo. It also
    allows to look inside pyzo, which can be handy for debugging
    and developing.
    """

    @others
</t>
<t tx="ekr.20190812072049.411">def __init__(self, parent):
    BaseShell.__init__(self, parent)

    # Set style to Python, or autocompletion does not work
    self.setParser('python')

    # Change background color to make the logger look different from shell
    # Use color as if all lines are highlighted
    f1 = self.getStyleElementFormat('Editor.text')
    f2 = self.getStyleElementFormat('Editor.Highlight current line')
    newStyle = 'back:%s, fore:%s' % (f2.back.name(), f1.fore.name())
    self.setStyle(editor_text=newStyle)

    # Create namespace for logger interpreter
    locals = {'pyzo':pyzo, 'sys':sys, 'os':os}
    # Include linguist tools
    for name in ['linguist', 'lrelease', 'lupdate', 'lhelp']:
        locals[name] = getattr(pyzo.util._locale, name)

    # Create interpreter to run code
    self._interpreter = code.InteractiveConsole(locals, "&lt;logger&gt;")

    # Show welcome text
    moreBanner = "This is the Pyzo logger shell."
    self.write("Python %s on %s - %s\n\n" %
                   (sys.version[:5], sys.platform, moreBanner))
    self.write(str(sys.ps1), 2)

    # Split console
    history = splitConsole(self.write, self.writeErr)
    self.write(history)
</t>
<t tx="ekr.20190812072049.412">def executeCommand(self, command):
    """ Execute the command here! """
    # Use writeErr rather than sys.stdout.write. This prevents
    # the prompts to be logged by the history. Because if they
    # are, the text does not look good due to missing newlines
    # when loading the history.

    # "Echo" stdin
    self.write(command, 1)
    more = self._interpreter.push(command.rstrip('\n'))
    if more:
        self.write(str(sys.ps2), 2)
    else:
        self.write(str(sys.ps1), 2)
</t>
<t tx="ekr.20190812072049.413">def writeErr(self, msg):
    """ This is what the logger uses to write errors.
    """
    self.write(msg, 0, '#C00')

# Note that I did not (yet) implement calltips
</t>
<t tx="ekr.20190812072049.414">def processAutoComp(self, aco):
    """ Processes an autocomp request using an AutoCompObject instance.
    """

    # Try using buffer first
    if aco.tryUsingBuffer():
        return

    # Include buildins?
    if not aco.name:
        command = "__builtins__.keys()"
        try:
            names = eval(command, {}, self._interpreter.locals)
            aco.addNames(names)
        except Exception:
            pass

    # Query list of names
    command = "dir({})".format(aco.name)
    try:
        names = eval(command, {}, self._interpreter.locals)
        aco.addNames(names)
    except Exception:
        pass

    # Done
    aco.finish()
</t>
<t tx="ekr.20190812072049.415">@path pyzo/tools/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.416"># -*- coding: utf-8 -*-
import pyzo
from pyzo.util.qt import QtCore, QtGui, QtWidgets
from pyzo import translate

tool_name = translate('pyzoSourceStructure', 'Source structure')
tool_summary = "Shows the structure of your source code."
</t>
<t tx="ekr.20190812072049.417">class Navigation:
    @others
</t>
<t tx="ekr.20190812072049.418">def __init__(self):
    self.back = []
    self.forward = []
</t>
<t tx="ekr.20190812072049.419">class PyzoSourceStructure(QtWidgets.QWidget):
    @others
</t>
<t tx="ekr.20190812072049.42">def dragEnterEvent(self, event):
    """
    We only support copying of the text
    """
    if event.mimeData().hasText():
        event.setDropAction(QtCore.Qt.CopyAction)
        event.accept()
</t>
<t tx="ekr.20190812072049.420">def __init__(self, parent):
    QtWidgets.QWidget.__init__(self, parent)

    # Make sure there is a configuration entry for this tool
    # The pyzo tool manager makes sure that there is an entry in
    # config.tools before the tool is instantiated.
    toolId = self.__class__.__name__.lower()
    self._config = pyzo.config.tools[toolId]
    if not hasattr(self._config, 'showTypes'):
        self._config.showTypes = ['class', 'def', 'cell', 'todo']
    if not hasattr(self._config, 'level'):
        self._config.level = 2

    # Keep track of clicks so we can "go back"
    self._nav = {}  # editor-id -&gt; Navigation object

    # Create buttons for navigation
    self._navbut_back = QtWidgets.QToolButton(self)
    self._navbut_back.setIcon(pyzo.icons.arrow_left)
    self._navbut_back.setIconSize(QtCore.QSize(16,16))
    self._navbut_back.setStyleSheet("QToolButton { border: none; padding: 0px; }")
    self._navbut_back.clicked.connect(self.onNavBack)
    #
    self._navbut_forward = QtWidgets.QToolButton(self)
    self._navbut_forward.setIcon(pyzo.icons.arrow_right)
    self._navbut_forward.setIconSize(QtCore.QSize(16,16))
    self._navbut_forward.setStyleSheet("QToolButton { border: none; padding: 0px; }")
    self._navbut_forward.clicked.connect(self.onNavForward)

    # # Create icon for slider
    # self._sliderIcon = QtWidgets.QToolButton(self)
    # self._sliderIcon.setIcon(pyzo.icons.text_align_right)
    # self._sliderIcon.setIconSize(QtCore.QSize(16,16))
    # self._sliderIcon.setStyleSheet("QToolButton { border: none; padding: 0px; }")

    # Create slider
    self._slider = QtWidgets.QSlider(QtCore.Qt.Horizontal, self)
    self._slider.setTickPosition(QtWidgets.QSlider.TicksBelow)
    self._slider.setSingleStep(1)
    self._slider.setPageStep(1)
    self._slider.setRange(1,5)
    self._slider.setValue(self._config.level)
    self._slider.valueChanged.connect(self.updateStructure)

    # Create options button
    #self._options = QtWidgets.QPushButton(self)
    #self._options.setText('Options'))
    #self._options.setToolTip("What elements to show.")
    self._options = QtWidgets.QToolButton(self)
    self._options.setIcon(pyzo.icons.filter)
    self._options.setIconSize(QtCore.QSize(16,16))
    self._options.setPopupMode(self._options.InstantPopup)
    self._options.setToolButtonStyle(QtCore.Qt.ToolButtonTextBesideIcon)

    # Create options menu
    self._options._menu = QtWidgets.QMenu()
    self._options.setMenu(self._options._menu)

    # Create tree widget
    self._tree = QtWidgets.QTreeWidget(self)
    self._tree.setHeaderHidden(True)
    self._tree.itemCollapsed.connect(self.updateStructure) # keep expanded
    self._tree.itemClicked.connect(self.onItemClick)

    # Create two sizers
    self._sizer1 = QtWidgets.QVBoxLayout(self)
    self._sizer2 = QtWidgets.QHBoxLayout()
    self._sizer1.setSpacing(2)
    self._sizer1.setContentsMargins(4,4,4,4)

    # Set layout
    self._sizer1.addLayout(self._sizer2, 0)
    self._sizer1.addWidget(self._tree, 1)
    # self._sizer2.addWidget(self._sliderIcon, 0)
    self._sizer2.addWidget(self._navbut_back, 0)
    self._sizer2.addWidget(self._navbut_forward, 0)
    self._sizer2.addStretch(1)
    self._sizer2.addWidget(self._slider, 6)
    self._sizer2.addStretch(1)
    self._sizer2.addWidget(self._options, 0)
    #
    self.setLayout(self._sizer1)

    # Init current-file name
    self._currentEditorId = 0

    # Bind to events
    pyzo.editors.currentChanged.connect(self.onEditorsCurrentChanged)
    pyzo.editors.parserDone.connect(self.updateStructure)

    self._options.pressed.connect(self.onOptionsPress)
    self._options._menu.triggered.connect(self.onOptionMenuTiggered)

    # Start
    # When the tool is loaded, the editorStack is already done loading
    # all previous files and selected the appropriate file.
    self.onOptionsPress() # Create menu now
    self.onEditorsCurrentChanged()
</t>
<t tx="ekr.20190812072049.421">def onOptionsPress(self):
    """ Create the menu for the button, Do each time to make sure
    the checks are right. """

    # Get menu
    menu = self._options._menu
    menu.clear()

    for type in ['class', 'def', 'cell', 'todo', 'import', 'attribute']:
        checked = type in self._config.showTypes
        action = menu.addAction('Show %s'%type)
        action.setCheckable(True)
        action.setChecked(checked)
</t>
<t tx="ekr.20190812072049.422">def onOptionMenuTiggered(self, action):
    """  The user decides what to show in the structure. """

    # What to show
    type = action.text().split(' ',1)[1]

    # Swap
    if type in self._config.showTypes:
        while type in self._config.showTypes:
            self._config.showTypes.remove(type)
    else:
        self._config.showTypes.append(type)

    # Update
    self.updateStructure()
</t>
<t tx="ekr.20190812072049.423">def onEditorsCurrentChanged(self):
    """ Notify that the file is being parsed and make
    sure that not the structure of a previously selected
    file is shown. """

    # Get editor and clear list
    editor = pyzo.editors.getCurrentEditor()
    self._tree.clear()

    if editor is None:
        # Set editor id
        self._currentEditorId = 0

    if editor is not None:
        # Set editor id
        self._currentEditorId = id(editor)

        # Notify
        text = translate('pyzoSourceStructure', 'Parsing ') + editor._name + ' ...'
        QtWidgets.QTreeWidgetItem(self._tree, [text])

        # Try getting the  structure right now
        self.updateStructure()
</t>
<t tx="ekr.20190812072049.424">def _getCurrentNav(self):
    if not self._currentEditorId:
        return None
    if self._currentEditorId not in self._nav:
        self._nav[self._currentEditorId] = Navigation()
    return self._nav[self._currentEditorId]
</t>
<t tx="ekr.20190812072049.425">def onNavBack(self):
    nav = self._getCurrentNav()
    if not nav or not nav.back:
        return
    linenr = nav.back.pop(-1)
    old_linenr = self._navigate_to_line(linenr)
    if old_linenr is not None:
        nav.forward.append(old_linenr)
</t>
<t tx="ekr.20190812072049.426">def onNavForward(self):
    nav = self._getCurrentNav()
    if not nav or not nav.forward:
        return
    linenr = nav.forward.pop(-1)
    old_linenr = self._navigate_to_line(linenr)
    if old_linenr is not None:
        nav.back.append(old_linenr)
</t>
<t tx="ekr.20190812072049.427">def onItemClick(self, item):
    """ Go to the right line in the editor and give focus. """

    # If item is attribute, get parent
    if not item.linenr:
        item = item.parent()

    old_linenr = self._navigate_to_line(item.linenr)

    if old_linenr is not None:
        nav = self._getCurrentNav()
        if nav and (not nav.back or nav.back[-1] != old_linenr):
            nav.back.append(old_linenr)
            nav.forward = []
</t>
<t tx="ekr.20190812072049.428">def _navigate_to_line(self, linenr):

    # Get editor
    editor = pyzo.editors.getCurrentEditor()
    if not editor:
        return None
    # Keep current line nr
    old_linenr = editor.textCursor().blockNumber() + 1
    # Move to line
    editor.gotoLine(linenr)
    # Give focus
    pyzo.callLater(editor.setFocus)
    return old_linenr
</t>
<t tx="ekr.20190812072049.429">def updateStructure(self):
    """ Updates the tree.
    """

    # Get editor
    editor = pyzo.editors.getCurrentEditor()
    if not editor:
        return

    # Something to show
    result = pyzo.parser._getResult()
    if result is None:
        return

    # Do the ids match?
    id0, id1, id2 = self._currentEditorId, id(editor), result.editorId
    if id0 != id1 or id0 != id2:
        return

    # Get current line number and the structure
    ln = editor.textCursor().blockNumber()
    ln += 1  # is ln as in line number area

    # Define colours
    colours = {'cell':'#b58900', 'class':'#cb4b16', 'def':'#073642',
               'attribute':'#657b83', 'import':'#268bd2', 'todo':'#d33682',
               'nameismain':'#859900'}
    #colours = {'cell':'#007F00', 'class':'#0000FF', 'def':'#007F7F',
    #            'attribute':'#444444', 'import':'#8800BB', 'todo':'#FF3333',
    #            'nameismain':'#007F00'}

    # Define what to show
    showTypes = self._config.showTypes

    # Define to what level to show (now is also a good time to save)
    showLevel = int( self._slider.value() )
    self._config.level = showLevel
    showLevel = showLevel if showLevel &lt; 5 else 99

    # Define function to set items
    selectedItem = [None]
    def SetItems(parentItem, fictiveObjects, level):
        level += 1
        for object in fictiveObjects:
            type = object.type
            if type not in showTypes and type != 'nameismain':
                continue
            # Construct text
            if type == 'import':
                text = " %s (%s)" % (object.name, object.text)
            elif type=='todo':
                text = object.name
            elif type=='nameismain':
                text = object.text
            elif type=='class':
                text = object.name
            elif type=='def':
                text = object.name + '()'
            elif type=='attribute':
                text = '- ' + object.name
            elif type in ('cell', '##', '#%%', '# %%'):
                type = 'cell'
                text = '## ' + object.name + ' ' * 120
            else:
                text = "%s %s" % (type, object.name)
            # Create item
            thisItem = QtWidgets.QTreeWidgetItem(parentItem, [text])
            color = QtGui.QColor(colours[object.type])
            thisItem.setForeground(0, QtGui.QBrush(color))
            font = thisItem.font(0)
            font.setBold(True)
            if type == 'cell':
                font.setUnderline(True)
            thisItem.setFont(0, font)
            thisItem.linenr = object.linenr
            # Is this the current item?
            if ln and object.linenr &lt;= ln and object.linenr2 &gt; ln:
                selectedItem[0] = thisItem
            # Any children that we should display?
            if object.children:
                SetItems(thisItem, object.children, level)
            # Set visibility
            thisItem.setExpanded( bool(level &lt; showLevel) )

    # Go
    self._tree.setUpdatesEnabled(False)
    self._tree.clear()
    SetItems(self._tree, result.rootItem.children, 0)
    self._tree.setUpdatesEnabled(True)

    # Handle selected item
    selectedItem = selectedItem[0]
    if selectedItem:
        selectedItem.setBackground(0, QtGui.QBrush(QtGui.QColor('#CCC')))
        self._tree.scrollToItem(selectedItem) # ensure visible
</t>
<t tx="ekr.20190812072049.43">def dragMoveEvent(self, event):
    self.dragEnterEvent(event)
</t>
<t tx="ekr.20190812072049.430">@path pyzo/tools/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.431"># -*- coding: utf-8 -*-
import urllib.request, urllib.parse

from pyzo.util.qt import QtCore, QtWidgets
imported_qtwebkit = True
try:
    from pyzo.util.qt import QtWebKit
except ImportError:
    imported_qtwebkit = False

import pyzo
tool_name = pyzo.translate("pyzoWebBrowser","Web browser")
tool_summary = "A very simple web browser."
default_bookmarks = [
   'docs.python.org',
    'scipy.org',
    'doc.qt.nokia.com/4.5/',
    'pyzo.org',
]
</t>
<t tx="ekr.20190812072049.432">class WebView(QtWidgets.QTextBrowser):
    """ Inherit the webview class to implement zooming using
    the mouse wheel.
    """

    loadStarted = QtCore.Signal()
    loadFinished = QtCore.Signal(bool)

    @others
</t>
<t tx="ekr.20190812072049.433">def __init__(self, parent):
    QtWidgets.QTextBrowser.__init__(self, parent)

    # Current url
    self._url = ''
    self._history = []
    self._history2 = []

    # Connect
    self.anchorClicked.connect(self.load)
</t>
<t tx="ekr.20190812072049.434">def wheelEvent(self, event):
    # Zooming does not work for this widget
    if QtCore.Qt.ControlModifier &amp; QtWidgets.qApp.keyboardModifiers():
        self.parent().wheelEvent(event)
    else:
        QtWidgets.QTextBrowser.wheelEvent(self, event)
</t>
<t tx="ekr.20190812072049.435">def url(self):
    return self._url
</t>
<t tx="ekr.20190812072049.436">def _getUrlParts(self):
    r = urllib.parse.urlparse(self._url)
    base = r.scheme + '://' + r.netloc
    return base, r.path, r.fragment

#
#     def loadCss(self, urls=[]):
#         urls.append('http://docs.python.org/_static/default.css')
#         urls.append('http://docs.python.org/_static/pygments.css')
#         text = ''
#         for url in urls:
#             tmp = urllib.request.urlopen(url).read().decode('utf-8')
#             text += '\n' + tmp
#         self.document().setDefaultStyleSheet(text)
</t>
<t tx="ekr.20190812072049.437">def back(self):

    # Get url and update forward history
    url = self._history.pop()
    self._history2.append(self._url)

    # Go there
    url = self._load(url)
</t>
<t tx="ekr.20190812072049.438">def forward(self):

    if not self._history2:
        return

    # Get url and update forward history
    url = self._history2.pop()
    self._history.append(self._url)

    # Go there
    url = self._load(url)
</t>
<t tx="ekr.20190812072049.439">def load(self, url):

    # Clear forward history
    self._history2 =  []

    # Store current url in history
    while self._url in self._history:
        self._history.remove(self._url)
    self._history.append(self._url)

    # Load
    url = self._load(url)
</t>
<t tx="ekr.20190812072049.44">def dropEvent(self, event):
    """
    The shell supports only a single line but the text may contain multiple
    lines. We insert at the editLine only the first non-empty line of the text
    """
    if event.mimeData().hasText():
        text = event.mimeData().text()
        insertText = ''
        for line in text.splitlines():
            if line.strip():
                insertText = line
                break

        # Move the cursor to the position indicated by the drop location, but
        # ensure it is at the edit line
        self.setTextCursor(self.cursorForPosition(event.pos()))
        self.ensureCursorAtEditLine()

        # Now insert the text
        cursor = self.textCursor()
        cursor.insertText(insertText)
        self.setFocus()

## Basic commands to control the shell
</t>
<t tx="ekr.20190812072049.440">def _load(self, url):
    """ _load(url)
    Convert url and load page, returns new url.
    """
    # Make url a string
    if isinstance(url, QtCore.QUrl):
        url = str(url.toString())

    # Compose relative url to absolute
    if url.startswith('#'):
        base, path, frag = self._getUrlParts()
        url = base + path + url
    elif not '//' in url:
        base, path, frag = self._getUrlParts()
        url = base + '/' + url.lstrip('/')

    # Try loading
    self.loadStarted.emit()
    self._url = url
    try:
        #print('URL:', url)
        text = urllib.request.urlopen(url).read().decode('utf-8')
        self.setHtml(text)
        self.loadFinished.emit(True)
    except Exception as err:
        self.setHtml(str(err))
        self.loadFinished.emit(False)

    # Set
    return url
</t>
<t tx="ekr.20190812072049.441">class PyzoWebBrowser(QtWidgets.QFrame):
    """ The main window, containing buttons, address bar and
    browser widget.
    """

    @others
</t>
<t tx="ekr.20190812072049.442">def __init__(self, parent):
    QtWidgets.QFrame.__init__(self, parent)

    # Init config
    toolId =  self.__class__.__name__.lower()
        
    self._config = pyzo.config.tools[toolId]
    if not hasattr(self._config, 'zoomFactor'):
        self._config.zoomFactor = 1.0
    if not hasattr(self._config, 'bookMarks'):
        self._config.bookMarks = []
    for item in default_bookmarks:
        if item not in self._config.bookMarks:
            self._config.bookMarks.append(item)

    # Get style object (for icons)
    style = QtWidgets.QApplication.style()

    # Create some buttons
    self._back = QtWidgets.QToolButton(self)
    self._back.setIcon(style.standardIcon(style.SP_ArrowBack))
    self._back.setIconSize(QtCore.QSize(16,16))
    #
    self._forward = QtWidgets.QToolButton(self)
    self._forward.setIcon(style.standardIcon(style.SP_ArrowForward))
    self._forward.setIconSize(QtCore.QSize(16,16))

    # Create address bar
    #self._address = QtWidgets.QLineEdit(self)
    self._address = QtWidgets.QComboBox(self)
    self._address.setEditable(True)
    self._address.setInsertPolicy(self._address.NoInsert)
    #
    for a in self._config.bookMarks:
        self._address.addItem(a)
    self._address.setEditText('')

    # Create web view
    if imported_qtwebkit:
        self._view = QtWebKit.QWebView(self)
    else:
        self._view = WebView(self)
    #
#         self._view.setZoomFactor(self._config.zoomFactor)
#         settings = self._view.settings()
#         settings.setAttribute(settings.JavascriptEnabled, True)
#         settings.setAttribute(settings.PluginsEnabled, True)

    # Layout
    self._sizer1 = QtWidgets.QVBoxLayout(self)
    self._sizer2 = QtWidgets.QHBoxLayout()
    #
    self._sizer2.addWidget(self._back, 0)
    self._sizer2.addWidget(self._forward, 0)
    self._sizer2.addWidget(self._address, 1)
    #
    self._sizer1.addLayout(self._sizer2, 0)
    self._sizer1.addWidget(self._view, 1)
    #
    self._sizer1.setSpacing(2)
    self.setLayout(self._sizer1)

    # Bind signals
    self._back.clicked .connect(self.onBack)
    self._forward.clicked .connect(self.onForward)
    self._address.lineEdit().returnPressed.connect(self.go)
    self._address.activated.connect(self.go)
    self._view.loadFinished.connect(self.onLoadEnd)
    self._view.loadStarted.connect(self.onLoadStart)

    # Start
    self._view.show()
    self.go('http://docs.python.org')
</t>
<t tx="ekr.20190812072049.443">def parseAddress(self, address):
    if not address.startswith('http'):
        address = 'http://' + address
    return address#QtCore.QUrl(address, QtCore.QUrl.TolerantMode)
</t>
<t tx="ekr.20190812072049.444">def go(self, address=None):
    if not isinstance(address, str):
        address = self._address.currentText()
    self._view.load( self.parseAddress(address) )
</t>
<t tx="ekr.20190812072049.445">def onLoadStart(self):
    self._address.setEditText('&lt;loading&gt;')
</t>
<t tx="ekr.20190812072049.446">def onLoadEnd(self, ok):
    if ok:
        #url = self._view.url()
        #address = str(url.toString())
        if imported_qtwebkit:
            address = self._view.url().toString()
        else:
            address = self._view.url()
    else:
        address = '&lt;could not load page&gt;'
    self._address.setEditText(str(address))
</t>
<t tx="ekr.20190812072049.447">def onBack(self):
    self._view.back()
</t>
<t tx="ekr.20190812072049.448">def onForward(self):
    self._view.forward()
</t>
<t tx="ekr.20190812072049.449">def wheelEvent(self, event):
    if QtCore.Qt.ControlModifier &amp; QtWidgets.qApp.keyboardModifiers():
        # Get amount of scrolling
        degrees = event.delta() / 8.0
        steps = degrees / 15.0
        # Set factor
        factor = self._view.zoomFactor() + steps/10.0
        if factor &lt; 0.25:
            factor = 0.25
        if factor &gt; 4.0:
            factor = 4.0
        # Store and apply
        self._config.zoomFactor = factor
#             self._view.setZoomFactor(factor)
    else:
        QtWidgets.QFrame.wheelEvent(self, event)
</t>
<t tx="ekr.20190812072049.45">def clearScreen(self):
    """ Clear all the previous output from the screen. """
    # Select from beginning of prompt to start of document
    self._cursor1.clearSelection()
    self._cursor1.movePosition(self._cursor1.Start, A_KEEP) # Keep anchor
    self._cursor1.removeSelectedText()
    # Wrap up
    self.ensureCursorAtEditLine()
    self.ensureCursorVisible()
</t>
<t tx="ekr.20190812072049.450">@path pyzo/tools/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.451"># -*- coding: utf-8 -*-
import pyzo
from pyzo.util.qt import QtCore, QtGui, QtWidgets

tool_name = pyzo.translate("pyzoWorkspace","Workspace")
tool_summary = "Lists the variables in the current shell's namespace."
</t>
<t tx="ekr.20190812072049.452">def splitName(name):
    """ splitName(name)
    Split an object name in parts, taking dots and indexing into account.
    """
    name = name.replace('[', '.[')
    parts = name.split('.')
    return [p for p in parts if p]
</t>
<t tx="ekr.20190812072049.453">def joinName(parts):
    """ joinName(parts)
    Join the parts of an object name, taking dots and indexing into account.
    """
    name = '.'.join(parts)
    return name.replace('.[', '[')
</t>
<t tx="ekr.20190812072049.454">class WorkspaceProxy(QtCore.QObject):
    """ WorkspaceProxy

    A proxy class to handle the asynchonous behaviour of getting information
    from the shell. The workspace tool asks for a certain name, and this
    class notifies when new data is available using a qt signal.

    """

    haveNewData = QtCore.Signal()

    @others
</t>
<t tx="ekr.20190812072049.455">def __init__(self):
    QtCore.QObject.__init__(self)

    # Variables
    self._variables = []

    # Element to get more info of
    self._name = ''

    # Bind to events
    pyzo.shells.currentShellChanged.connect(self.onCurrentShellChanged)
    pyzo.shells.currentShellStateChanged.connect(self.onCurrentShellStateChanged)

    # Initialize
    self.onCurrentShellStateChanged()
</t>
<t tx="ekr.20190812072049.456">def addNamePart(self, part):
    """ addNamePart(part)
    Add a part to the name.
    """
    parts = splitName(self._name)
    parts.append(part)
    self.setName(joinName(parts))
</t>
<t tx="ekr.20190812072049.457">def setName(self, name):
    """ setName(name)
    Set the name that we want to know more of.
    """
    self._name = name

    shell = pyzo.shells.getCurrentShell()
    if shell:
        future = shell._request.dir2(self._name)
        future.add_done_callback(self.processResponse)
</t>
<t tx="ekr.20190812072049.458">def goUp(self):
    """ goUp()
    Cut the last part off the name.
    """
    parts = splitName(self._name)
    if parts:
        parts.pop()
    self.setName(joinName(parts))
</t>
<t tx="ekr.20190812072049.459">def onCurrentShellChanged(self):
    """ onCurrentShellChanged()
    When no shell is selected now, update this. In all other cases,
    the onCurrentShellStateChange will be fired too.
    """
    shell = pyzo.shells.getCurrentShell()
    if not shell:
        self._variables = []
        self.haveNewData.emit()
</t>
<t tx="ekr.20190812072049.46">def deleteLines(self):
    """ Called from the menu option "delete lines", just execute self.clearCommand() """
    self.clearCommand()
</t>
<t tx="ekr.20190812072049.460">def onCurrentShellStateChanged(self):
    """ onCurrentShellStateChanged()
    Do a request for information!
    """
    shell = pyzo.shells.getCurrentShell()
    if not shell:
        # Should never happen I think, but just to be sure
        self._variables = []
    elif shell._state.lower() != 'busy':
        future = shell._request.dir2(self._name)
        future.add_done_callback(self.processResponse)
</t>
<t tx="ekr.20190812072049.461">def processResponse(self, future):
    """ processResponse(response)
    We got a response, update our list and notify the tree.
    """

    response = []

    # Process future
    if future.cancelled():
        pass #print('Introspect cancelled') # No living kernel
    elif future.exception():
        print('Introspect-queryDoc-exception: ', future.exception())
    else:
        response = future.result()

    self._variables = response
    self.haveNewData.emit()
</t>
<t tx="ekr.20190812072049.462">class WorkspaceItem(QtWidgets.QTreeWidgetItem):

    @others
</t>
<t tx="ekr.20190812072049.463">def __lt__(self, otherItem):
    column = self.treeWidget().sortColumn()
    try:
        return float( self.text(column).strip('[]') ) &gt; float( otherItem.text(column).strip('[]') )
    except ValueError:
        return self.text(column) &gt; otherItem.text(column)
</t>
<t tx="ekr.20190812072049.464">class WorkspaceTree(QtWidgets.QTreeWidget):
    """ WorkspaceTree

    The tree that displays the items in the current namespace.
    I first thought about implementing this using the mode/view
    framework, but it is so much work and I can't seem to fully
    understand how it works :(

    The QTreeWidget is so very simple and enables sorting very
    easily, so I'll stick with that ...

    """

    @others
</t>
<t tx="ekr.20190812072049.465">def __init__(self, parent):
    QtWidgets.QTreeWidget.__init__(self, parent)

    self._config = parent._config

    # Set header stuff
    self.setHeaderHidden(False)
    self.setColumnCount(3)
    self.setHeaderLabels(['Name', 'Type', 'Repr'])
    #self.setColumnWidth(0, 100)
    self.setSortingEnabled(True)

    # Nice rows
    self.setAlternatingRowColors(True)
    self.setRootIsDecorated(False)

    # Create proxy
    self._proxy = WorkspaceProxy()
    self._proxy.haveNewData.connect(self.fillWorkspace)

    # For menu
    self.setContextMenuPolicy(QtCore.Qt.DefaultContextMenu)
    self._menu = QtWidgets.QMenu()
    self._menu.triggered.connect(self.contextMenuTriggered)

    # Bind to events
    self.itemActivated.connect(self.onItemExpand)
</t>
<t tx="ekr.20190812072049.466">def contextMenuEvent(self, event):
    """ contextMenuEvent(event)
    Show the context menu.
    """

    QtWidgets.QTreeView.contextMenuEvent(self, event)

    # Get if an item is selected
    item = self.currentItem()
    if not item:
        return

    # Create menu
    self._menu.clear()
    for a in ['Show namespace', 'Show help', 'Delete']:
        action = self._menu.addAction(a)
        parts = splitName(self._proxy._name)
        parts.append(item.text(0))
        action._objectName = joinName(parts)
        action._item = item

    # Show
    self._menu.popup(QtGui.QCursor.pos()+QtCore.QPoint(3,3))
</t>
<t tx="ekr.20190812072049.467">def contextMenuTriggered(self, action):
    """ contextMenuTriggered(action)
    Process a request from the context menu.
    """

    # Get text
    req = action.text().lower()

    if 'namespace' in req:
        # Go deeper
        self.onItemExpand(action._item)

    elif 'help' in req:
        # Show help in help tool (if loaded)
        hw = pyzo.toolManager.getTool('pyzointeractivehelp')
        if hw:
            hw.setObjectName(action._objectName)

    elif 'delete' in req:
        # Delete the variable
        shell = pyzo.shells.getCurrentShell()
        if shell:
            shell.processLine('del ' + action._objectName)
</t>
<t tx="ekr.20190812072049.468">def onItemExpand(self, item):
    """ onItemExpand(item)
    Inspect the attributes of that item.
    """
    self._proxy.addNamePart(item.text(0))
</t>
<t tx="ekr.20190812072049.469">def fillWorkspace(self):
    """ fillWorkspace()
    Update the workspace tree.
    """

    # Clear first
    self.clear()

    # Set name
    line = self.parent()._line
    line.setText(self._proxy._name)

    # Add elements
    for des in self._proxy._variables:

        # Get parts
        parts = des.split(',',3)
        if len(parts) &lt; 4:
            continue

        name = parts[0]

        # Pop the 'kind' element
        kind = parts.pop(2)

        # &lt;kludge 2&gt;
        # the typeTranslation dictionary contains "synonyms" for types that will be hidden
        # Currently only "method"-&gt;"function" is used
        # the try:... is there to have a minimal translation dictionary.
        try:
            kind = self._config.typeTranslation[kind]
        except KeyError:
            pass
        # &lt;/kludge 2&gt;
        if kind in self._config.hideTypes:
            continue
        if name.startswith('_') and 'private' in self._config.hideTypes:
            continue

        # Create item
        item = WorkspaceItem(parts, 0)
        self.addTopLevelItem(item)

        # Set tooltip
        tt = '%s: %s' % (parts[0], parts[-1])
        item.setToolTip(0,tt)
        item.setToolTip(1,tt)
        item.setToolTip(2,tt)
</t>
<t tx="ekr.20190812072049.47">def clearCommand(self):
    """ Clear the current command, move the cursor right behind
    the prompt, and ensure it's visible.
    """
    # Select from prompt end to length and delete selected text.
    cursor = self.textCursor()
    cursor.setPosition(self._cursor2.position(), A_MOVE)
    cursor.movePosition(cursor.End, A_KEEP)
    cursor.removeSelectedText()
    # Wrap up
    self.ensureCursorAtEditLine()
    self.ensureCursorVisible()
</t>
<t tx="ekr.20190812072049.470">class PyzoWorkspace(QtWidgets.QWidget):
    """ PyzoWorkspace

    The main widget for this tool.

    """

    @others
</t>
<t tx="ekr.20190812072049.471">def __init__(self, parent):
    QtWidgets.QWidget.__init__(self, parent)

    # Make sure there is a configuration entry for this tool
    # The pyzo tool manager makes sure that there is an entry in
    # config.tools before the tool is instantiated.
    toolId = self.__class__.__name__.lower()
    self._config = pyzo.config.tools[toolId]
    if not hasattr(self._config, 'hideTypes'):
        self._config.hideTypes = []
    # &lt;kludge 2&gt;
    # configuring the typeTranslation dictionary
    if not hasattr(self._config, 'typeTranslation'):
        # to prevent the exception to be raised, one could init to :
        # {"method": "function", "function": "function", "type": "type", "private": "private", "module": "module"}
        self._config.typeTranslation = {}
    # Defaults
    self._config.typeTranslation['method'] = 'function'
    self._config.typeTranslation['builtin_function_or_method'] = 'function'
    # &lt;kludge 2&gt;

    # Create tool button
    self._up = QtWidgets.QToolButton(self)
    style = QtWidgets.qApp.style()
    self._up.setIcon( style.standardIcon(style.SP_ArrowLeft) )
    self._up.setIconSize(QtCore.QSize(16,16))

    # Create "path" line edit
    self._line = QtWidgets.QLineEdit(self)
    self._line.setReadOnly(True)
    self._line.setStyleSheet("QLineEdit { background:#ddd; }")
    self._line.setFocusPolicy(QtCore.Qt.NoFocus)

    # Create options menu
    self._options = QtWidgets.QToolButton(self)
    self._options.setIcon(pyzo.icons.filter)
    self._options.setIconSize(QtCore.QSize(16,16))
    self._options.setPopupMode(self._options.InstantPopup)
    self._options.setToolButtonStyle(QtCore.Qt.ToolButtonTextBesideIcon)
    #
    self._options._menu = QtWidgets.QMenu()
    self._options.setMenu(self._options._menu)
    self.onOptionsPress()  # create menu now

    # Create tree
    self._tree = WorkspaceTree(self)

    # Set layout
    layout = QtWidgets.QHBoxLayout()
    layout.addWidget(self._up, 0)
    layout.addWidget(self._line, 1)
    layout.addWidget(self._options, 0)
    #
    mainLayout = QtWidgets.QVBoxLayout(self)
    mainLayout.addLayout(layout, 0)
    mainLayout.addWidget(self._tree, 1)
    mainLayout.setSpacing(2)
    mainLayout.setContentsMargins(4,4,4,4)
    self.setLayout(mainLayout)

    # Bind events
    self._up.pressed.connect(self._tree._proxy.goUp)
    self._options.pressed.connect(self.onOptionsPress)
    self._options._menu.triggered.connect(self.onOptionMenuTiggered)
</t>
<t tx="ekr.20190812072049.472">def onOptionsPress(self):
    """ Create the menu for the button, Do each time to make sure
    the checks are right. """

    # Get menu
    menu = self._options._menu
    menu.clear()

    for type in ['type', 'function', 'module', 'private']:
        checked = type in self._config.hideTypes
        action = menu.addAction('Hide %s'%type)
        action.setCheckable(True)
        action.setChecked(checked)
</t>
<t tx="ekr.20190812072049.473">def onOptionMenuTiggered(self, action):
    """  The user decides what to hide in the workspace. """

    # What to show
    type = action.text().split(' ',1)[1]

    # Swap
    if type in self._config.hideTypes:
        while type in self._config.hideTypes:
            self._config.hideTypes.remove(type)
    else:
        self._config.hideTypes.append(type)

    # Update
    self._tree.fillWorkspace()
</t>
<t tx="ekr.20190812072049.474">@path pyzo/tools/
&lt;&lt; tools/__init__ docstring &gt;&gt;

try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('IMPORT pyzo.tools')
except Exception:
    leo_g = None

import os, sys, imp

import pyzo
from pyzo.util.qt import QtCore, QtWidgets  # noqa: QtGui
from pyzo.util import zon as ssdf
from pyzo import translate
assert translate

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.476">class ToolDockWidget(QtWidgets.QDockWidget):
    """ A dock widget that holds a tool.
    It sets all settings, initializes the tool widget, and notifies the
    tool manager on closing.
    """

    @others
</t>
<t tx="ekr.20190812072049.477">def __init__(self, parent, toolManager):
    QtWidgets.QDockWidget.__init__(self, parent)

    # Store stuff
    self._toolManager = toolManager

    # Allow docking anywhere, othwerise restoring state wont work properly

    # Set other settings
    self.setFeatures(   QtWidgets.QDockWidget.DockWidgetMovable |
                        QtWidgets.QDockWidget.DockWidgetClosable |
                        QtWidgets.QDockWidget.DockWidgetFloatable
                        #QtWidgets.QDockWidget.DockWidgetVerticalTitleBar
                        )
</t>
<t tx="ekr.20190812072049.478">def setTool(self, toolId, toolName, toolClass):
    """ Set the tool information. Call this right after
    initialization. """

    # Store id and set object name to enable saving/restoring state
    self._toolId = toolId
    self.setObjectName(toolId)

    # Set name
    self.setWindowTitle(toolName)

    # Create tool widget
    self.reload(toolClass)
</t>
<t tx="ekr.20190812072049.479">def closeEvent(self, event):
    if self._toolManager:
        self._toolManager.onToolClose(self._toolId)
        self._toolManager = None
    # Close and delete widget
    old = self.widget()
    if old:
        old.close()
        old.deleteLater()
    # Close and delete dock widget
    self.close()
    self.deleteLater()
    # We handled the event
    event.accept()
</t>
<t tx="ekr.20190812072049.48">def _handleBackspaces_split(self, text):

    # while NOT a backspace at first position, or none found
    i = 9999999999999
    while i&gt;0:
        i = text.rfind('\b',0,i)
        if i&gt;0 and text[i-1]!='\b':
            text = text[0:i-1] + text[i+1:]

    # Strip the backspaces at the start
    text2 = text.lstrip('\b')
    n = len(text) - len(text2)

    # Done
    return n, text2
</t>
<t tx="ekr.20190812072049.480">def reload(self, toolClass):
    """ Reload the widget with a new widget class. """
    old = self.widget()
    new = toolClass(pyzo.main)
    self.setWidget(new)
    if old:
        old.close()
        old.deleteLater()
</t>
<t tx="ekr.20190812072049.481">class ToolDescription:
    """ Provides a description of a tool and has a reference to
    the tool dock instance if it is loaded.
    """

    @others
</t>
<t tx="ekr.20190812072049.482">def __init__(self, modulePath, name='', description=''):
    # Set names
    self.modulePath = modulePath
    self.moduleName = os.path.splitext(os.path.basename(modulePath))[0]
    self.id = self.moduleName.lower()
    if name:
        self.name = name
    else:
        self.name = self.id

    # Set description
    self.description = description
    # Init instance to None, will be set when loaded
    self.instance = None
</t>
<t tx="ekr.20190812072049.483">def menuLauncher(self, value):
    """ Function that is called by the menu when this tool is selected.
    """
    if value is None:
        return bool(self.instance)
        #return self.id in pyzo.toolManager._activeTools
    elif value:
        pyzo.toolManager.loadTool(self.id)
    else:
        self.widget = None
        pyzo.toolManager.closeTool(self.id)
</t>
<t tx="ekr.20190812072049.484">class ToolManager(QtCore.QObject):
    """ Manages the tools. """

    # This signal indicates a change in the loaded tools
    toolInstanceChange = QtCore.Signal()

    @others
</t>
<t tx="ekr.20190812072049.485">def __init__(self, parent = None):
    QtCore.QObject.__init__(self, parent)

    # list of ToolDescription instances
    self._toolInfo = None
    self._activeTools = {}
</t>
<t tx="ekr.20190812072049.486">def loadToolInfo(self):
    """ (re)load the tool information.
    """
    # Get paths to load files from
    toolDir1 = os.path.join(pyzo.pyzoDir, 'tools')
    toolDir2 = os.path.join(pyzo.appDataDir, 'tools')

    # Create list of tool files
    toolfiles = []
    for toolDir in [toolDir1, toolDir2]:
        tmp = [os.path.join(toolDir, f) for f in os.listdir(toolDir)]
        toolfiles.extend(tmp)

    # Note: we do not use the code below anymore, since even the frozen
    # app makes use of the .py files.
#         # Get list of files, also when we're in a zip file.
#         i = tooldir.find('.zip')
#         if i&gt;0:
#             # Get list of files from zipfile
#             tooldir = tooldir[:i+4]
#             import zipfile
#             z = zipfile.ZipFile(tooldir)
#             toolfiles = [os.path.split(i)[1] for i in z.namelist()
#                         if i.startswith('visvis') and i.count('functions')]
#         else:
#             # Get list of files from file system
#             toolfiles = os.listdir(tooldir)

    # Iterate over tool modules
    newlist = []
    for file in toolfiles:
        modulePath = file

        # Check
        if os.path.isdir(file):
            file = os.path.join(file, '__init__.py')  # A package perhaps
            if not os.path.isfile(file):
                continue
        elif file.endswith('__.py') or not file.endswith('.py'):
            continue
        elif file.endswith('pyzoFileBrowser.py'):
            # Skip old file browser (the file can be there from a previous install)
            continue

        #
        toolName = ""
        toolSummary = ""
        # read file to find name or summary
        linecount = 0
        for line in open(file, encoding='utf-8'):
            linecount += 1
            if linecount &gt; 50:
                break
            if line.startswith("tool_name"):
                i = line.find("=")
                if i&lt;0: continue
                line = line.rstrip("\n").rstrip("\r")
                line = line[i+1:].strip(" ")
                toolName = eval(line)  # applies translation
            elif line.startswith("tool_summary"):
                i = line.find("=")
                if i&lt;0: continue
                line = line.rstrip("\n").rstrip("\r")
                line = line[i+1:].strip(" ")
                toolSummary = line.strip("'").strip('"')
            else:
                pass

        # Add stuff
        tmp = ToolDescription(modulePath, toolName, toolSummary)
        newlist.append(tmp)

    # Store and return
    self._toolInfo = sorted( newlist, key=lambda x:x.id )
    self.updateToolInstances()
    return self._toolInfo
</t>
<t tx="ekr.20190812072049.487">def updateToolInstances(self):
    """ Make tool instances up to date, so that it can be seen what
    tools are now active. """
    for toolDes in self.getToolInfo():
        if toolDes.id in self._activeTools:
            toolDes.instance = self._activeTools[toolDes.id]
        else:
            toolDes.instance = None

    # Emit update signal
    self.toolInstanceChange.emit()
</t>
<t tx="ekr.20190812072049.488">def getToolInfo(self):
    """ Like loadToolInfo(), but use buffered instance if available.
    """
    if self._toolInfo is None:
        self.loadToolInfo()
    return self._toolInfo
</t>
<t tx="ekr.20190812072049.489">def getToolClass(self, toolId):
    """ Get the class of the tool.
    It will import (and reload) the module and get the class.
    Some checks are performed, like whether the class inherits
    from QWidget.
    Returns the class or None if failed...
    """

    # Make sure we have the info
    if self._toolInfo is None:
        self.loadToolInfo()

    # Get module name and path
    for toolDes in self._toolInfo:
        if toolDes.id == toolId:
            moduleName = toolDes.moduleName
            modulePath = toolDes.modulePath
            break
    else:
        print("WARNING: could not find module for tool", repr(toolId))
        return None

    # Remove from sys.modules, to force the module to reload
    for key in [key for key in sys.modules]:
        if key and key.startswith('pyzo.tools.'+moduleName):
            del sys.modules[key]

    # Load module
    try:
        m_file, m_fname, m_des = imp.find_module(moduleName, [os.path.dirname(modulePath)])
        mod = imp.load_module('pyzo.tools.'+moduleName, m_file, m_fname, m_des)
    except Exception as why:
        print("Invalid tool " + toolId +":", why)
        return None

    # Is the expected class present?
    className = ""
    for member in dir(mod):
        if member.lower() == toolId:
            className = member
            break
    else:
        print("Invalid tool, Classname must match module name '%s'!" % toolId)
        return None

    # Does it inherit from QWidget?
    plug = mod.__dict__[className]
    if not (isinstance(plug,type) and issubclass(plug,QtWidgets.QWidget)):
        print("Invalid tool, tool class must inherit from QWidget!")
        return None

    # Succes!
    return plug
</t>
<t tx="ekr.20190812072049.49">def _handleBackspacesOnList(self, texts):
    """ _handleBackspacesOnList(texts)

    Handle backspaces on a list of messages. When printing
    progress, many messages will simply replace each-other, which
    means we can process them much more effectively than when they're
    combined in a list.

    """
    # Init number of backspaces at the start
    N = 0

    for i in range(len(texts)):

        # Remove backspaces in text and how many are left
        n, text = self._handleBackspaces_split(texts[i])
        texts[i] = text

        # Use remaining backspaces to remove backspaces in earlier texts
        while n and i &gt; 0:
            i -= 1
            text = texts[i]
            if len(text) &gt; n:
                texts[i] = text[:-n]
                n = 0
            else:
                texts[i] = ''
                n -= len(text)
        N += n

    # Insert tabs for start
    if N:
        texts[0] = '\b'*N + texts[0]

    # Return with empy elements popped
    return [t for t in texts if t]
</t>
<t tx="ekr.20190812072049.490">def loadTool(self, toolId, splitWith=None):
    """ Load a tool by creating a dock widget containing the tool widget.
    """
    # leo_g.trace('toolId', toolId)

    # A tool id should always be lower case
    toolId = toolId.lower()

    # Close old one
    if toolId in self._activeTools:
        old = self._activeTools[toolId].widget()
        self._activeTools[toolId].setWidget(QtWidgets.QWidget(pyzo.main))
        if old:
            old.close()
            old.deleteLater()

    # Get tool class (returns None on failure)
    toolClass = self.getToolClass(toolId)
    if toolClass is None:
        return

    # Already loaded? reload!
    if toolId in self._activeTools:
        self._activeTools[toolId].reload(toolClass)
        return

    # Obtain name from buffered list of names
    for toolDes in self._toolInfo:
        if toolDes.id == toolId:
            name = toolDes.name
            break
    else:
        name = toolId

    # Make sure there is a config entry for this tool
    if not hasattr(pyzo.config.tools, toolId):
        pyzo.config.tools[toolId] = ssdf.new()

    # Create dock widget and add in the main window
    dock = ToolDockWidget(pyzo.main, self)
    dock.setTool(toolId, name, toolClass)

    if splitWith and splitWith in self._activeTools:
        otherDock = self._activeTools[splitWith]
        pyzo.main.splitDockWidget(otherDock, dock, QtCore.Qt.Horizontal)
            # QMainWindow.splitDocWidget.
    else:
        pyzo.main.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
            # QMainWindow.addDocWidget.

    # Add to list
    self._activeTools[toolId] = dock
    self.updateToolInstances()
</t>
<t tx="ekr.20190812072049.491">def reloadTools(self):
    """ Reload all tools. """
    for id in self.getLoadedTools():
        self.loadTool(id)
</t>
<t tx="ekr.20190812072049.492">def closeTool(self, toolId):
    """ Close the tool with specified id.
    """
    if toolId in self._activeTools:
        dock = self._activeTools[toolId]
        dock.close()
</t>
<t tx="ekr.20190812072049.493">def getTool(self, toolId):
    """ Get the tool widget instance, or None
    if not available. """
    if toolId in self._activeTools:
        return self._activeTools[toolId].widget()
    else:
        return None
</t>
<t tx="ekr.20190812072049.494">def onToolClose(self, toolId):
    # Remove from dict
    self._activeTools.pop(toolId, None)
    # Set instance to None
    self.updateToolInstances()
</t>
<t tx="ekr.20190812072049.495">def getLoadedTools(self):
    """ Get a list with id's of loaded tools. """
    tmp = []
    for toolDes in self.getToolInfo():
        if toolDes.id in self._activeTools:
            tmp.append(toolDes.id)
    return tmp
</t>
<t tx="ekr.20190812072049.497"></t>
<t tx="ekr.20190812072049.498">@path pyzo/tools/pyzoFileBrowser/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.499">import sys
import os.path as op

import pyzo
from pyzo import translate
from pyzo.util import zon as ssdf

from . import QtCore, QtGui, QtWidgets
from . import proxies
from .tree import Tree
from .utils import cleanpath, isdir
</t>
<t tx="ekr.20190812072049.5">def write(self, text):
    pass
</t>
<t tx="ekr.20190812072049.50">def _handleBackspaces(self, text):
    """ Apply backspaces in the string itself and if there are
    backspaces left at the start of the text, remove the appropriate
    amount of characters from the text.

    Returns the new text.
    """
    # take care of backspaces
    if '\b' in text:
        # Remove backspaces and get how many were at the beginning
        nb, text = self._handleBackspaces_split(text)
        if nb:
            # Select what we remove and delete that
            self._cursor1.clearSelection()
            self._cursor1.movePosition(self._cursor1.Left, A_KEEP, nb)
            self._cursor1.removeSelectedText()

    # Return result
    return text
</t>
<t tx="ekr.20190812072049.500">class Browser(QtWidgets.QWidget):
    """ A browser consists of an address bar, and tree view, and other
    widets to help browse the file system. The browser object is responsible
    for tying the different browser-components together.

    It is also provides the API for dealing with starred dirs.
    """

    @others
</t>
<t tx="ekr.20190812072049.501">def __init__(self, parent, config, path=None):
    QtWidgets.QWidget.__init__(self, parent)

    # Store config
    self.config = config

    # Create star button
    self._projects = Projects(self)

    # Create path input/display lineEdit
    self._pathEdit = PathInput(self)

    # Create file system proxy
    self._fsProxy = proxies.NativeFSProxy()
    self.destroyed.connect(self._fsProxy.stop)

    # Create tree widget
    self._tree = Tree(self)
    self._tree.setPath(cleanpath(self.config.path))

    # Create name filter
    self._nameFilter = NameFilter(self)
    #self._nameFilter.lineEdit().setToolTip('File filter pattern')
    self._nameFilter.setToolTip(translate('filebrowser', 'Filename filter'))
    self._nameFilter.setPlaceholderText(self._nameFilter.toolTip())

    # Create search filter
    self._searchFilter = SearchFilter(self)
    self._searchFilter.setToolTip(translate('filebrowser', 'Search in files'))
    self._searchFilter.setPlaceholderText(self._searchFilter.toolTip())

    # Signals to sync path.
    # Widgets that can change the path transmit signal to _tree
    self._pathEdit.dirUp.connect(self._tree.setFocus)
    self._pathEdit.dirUp.connect(self._tree.setPathUp)
    self._pathEdit.dirChanged.connect(self._tree.setPath)
    self._projects.dirChanged.connect(self._tree.setPath)
    #
    self._nameFilter.filterChanged.connect(self._tree.onChanged) # == update
    self._searchFilter.filterChanged.connect(self._tree.onChanged)
    # The tree transmits signals to widgets that need to know the path
    self._tree.dirChanged.connect(self._pathEdit.setPath)
    self._tree.dirChanged.connect(self._projects.setPath)

    self._layout()

    # Set and sync path ...
    if path is not None:
        self._tree.SetPath(path)
    self._tree.dirChanged.emit(self._tree.path())
</t>
<t tx="ekr.20190812072049.502">def getImportWizard(self):
    # Lazy loading
    try:
        return self._importWizard
    except AttributeError:

        from .importwizard import ImportWizard
        self._importWizard = ImportWizard()

        return self._importWizard
</t>
<t tx="ekr.20190812072049.503">def _layout(self):
    layout = QtWidgets.QVBoxLayout(self)
    layout.setContentsMargins(0,0,0,0)
    #layout.setSpacing(6)
    self.setLayout(layout)
    #
    layout.addWidget(self._projects)
    layout.addWidget(self._pathEdit)
    layout.addWidget(self._tree)
    #
    subLayout = QtWidgets.QHBoxLayout()
    subLayout.setSpacing(2)
    subLayout.addWidget(self._nameFilter, 5)
    subLayout.addWidget(self._searchFilter, 5)
    layout.addLayout(subLayout)
</t>
<t tx="ekr.20190812072049.504">def closeEvent(self, event):
    #print('Closing browser, stopping file system proxy')
    super().closeEvent(event)
    self._fsProxy.stop()
</t>
<t tx="ekr.20190812072049.505">def nameFilter(self):
    #return self._nameFilter.lineEdit().text()
    return self._nameFilter.text()
</t>
<t tx="ekr.20190812072049.506">def searchFilter(self):
    return {'pattern': self._searchFilter.text(),
            'matchCase': self.config.searchMatchCase,
            'regExp': self.config.searchRegExp,
            'subDirs': self.config.searchSubDirs,
            }
</t>
<t tx="ekr.20190812072049.507">@property
def expandedDirs(self):
    """ The list of the expanded directories.
    """
    return self.parent().config.expandedDirs
</t>
<t tx="ekr.20190812072049.508">@property
def starredDirs(self):
    """ A list of the starred directories.
    """
    return [d.path for d in self.parent().config.starredDirs]
</t>
<t tx="ekr.20190812072049.509">def dictForStarredDir(self, path):
    """ Return the dict of the starred dir corresponding to
    the given path, or None if no starred dir was found.
    """
    if not path:
        return None
    for d in self.parent().config.starredDirs:
        if op.normcase(d['path']) == op.normcase(path):
            return d
    else:
        return None
</t>
<t tx="ekr.20190812072049.51">def _handleCarriageReturnOnList(self, texts):
    """ Discard messages that end with CR and that are not followed
    with LF. Also discard messages followed by a line that starts
    with CR. Assumes that each message is one line.
    """
    for i in range(len(texts)-1):
        if ((texts[i].endswith('\r') and not
             texts[i+1].startswith('\n'))
            or
            (texts[i+1].startswith('\r') and not
             texts[i+1][1:].startswith('\n'))):
            texts[i] = ''

    return [t for t in texts if t]
</t>
<t tx="ekr.20190812072049.510">def addStarredDir(self, path):
    """ Add the given path to the starred directories.
    """
    # Create new dict
    newProject = ssdf.new()
    newProject.path = op.normcase(path) # Normalize case!
    newProject.name = op.basename(path)
    newProject.addToPythonpath = False
    # Add it to the config
    self.parent().config.starredDirs.append(newProject)
    # Update list
    self._projects.updateProjectList()
</t>
<t tx="ekr.20190812072049.511">def removeStarredDir(self, path):
    """ Remove the given path from the starred directories.
    The path must exactlty match.
    """
    # Remove
    starredDirs = self.parent().config.starredDirs
    pathn = op.normcase(path)
    for d in starredDirs:
        if op.normcase(pathn) == op.normcase(d.path):
            starredDirs.remove(d)
    # Update list
    self._projects.updateProjectList()
</t>
<t tx="ekr.20190812072049.512">def test(self, sort=False):
    items = []
    for i in range(self._tree.topLevelItemCount()):
        item = self._tree.topLevelItem(i)
        items.append(item)
        #self._tree.removeItemWidget(item, 0)
    self._tree.clear()

    #items.sort(key=lambda x: x._path)
    items = [item for item in reversed(items)]

    for item in items:
        self._tree.addTopLevelItem(item)
</t>
<t tx="ekr.20190812072049.513">def currentProject(self):
    """ Return the ssdf dict for the current project, or None.
    """
    return self._projects.currentDict()
</t>
<t tx="ekr.20190812072049.514">class LineEditWithToolButtons(QtWidgets.QLineEdit):
    """ Line edit to which tool buttons (with icons) can be attached.
    """

    @others
</t>
<t tx="ekr.20190812072049.515">def __init__(self, parent):
    QtWidgets.QLineEdit.__init__(self, parent)
    self._leftButtons = []
    self._rightButtons = []
</t>
<t tx="ekr.20190812072049.516">def addButtonLeft(self, icon, willHaveMenu=False):
    return self._addButton(icon, willHaveMenu, self._leftButtons)
</t>
<t tx="ekr.20190812072049.517">def addButtonRight(self, icon, willHaveMenu=False):
    return self._addButton(icon, willHaveMenu, self._rightButtons)
</t>
<t tx="ekr.20190812072049.518">def _addButton(self, icon, willHaveMenu, L):
    # Create button
    button = QtWidgets.QToolButton(self)
    L.append(button)
    # Customize appearance
    button.setIcon(icon)
    button.setIconSize(QtCore.QSize(16,16))
    button.setStyleSheet("QToolButton { border: none; padding: 0px; }")
    #button.setStyleSheet("QToolButton { border: none; padding: 0px; background-color:red;}");
    # Set behavior
    button.setCursor(QtCore.Qt.ArrowCursor)
    button.setPopupMode(button.InstantPopup)
    # Customize alignment
    if willHaveMenu:
        button.setToolButtonStyle(QtCore.Qt.ToolButtonTextBesideIcon)
        if sys.platform.startswith('win'):
            button.setText(' ')
    # Update self
    self._updateGeometry()
    return button
</t>
<t tx="ekr.20190812072049.519">def setButtonVisible(self, button, visible):
    for but in self._leftButtons:
        if but is button:
            but.setVisible(visible)
    for but in self._rightButtons:
        if but is button:
            but.setVisible(visible)
    self._updateGeometry()
</t>
<t tx="ekr.20190812072049.52">def _handleCarriageReturn(self, text):
    """ Removes the last line if it ended with CR, or if the current new
    message starts with CR.
    Returns the text.
    """
    if 'logger' in self.__class__.__name__.lower():
        return text
    # Remove last line if it ended with CR
    cursor = self._cursor1
    if ((self._lastline_had_cr and not text.startswith('\n')) or
            (text.startswith('\r') and not text[1:].startswith('\n'))):
        cursor.movePosition(cursor.PreviousBlock, cursor.KeepAnchor, 1)
        cursor.removeSelectedText()
    # Is this new line ending in CR?
    self._lastline_had_cr = text.endswith('\r')
    return text
</t>
<t tx="ekr.20190812072049.520">def resizeEvent(self, event):
    QtWidgets.QLineEdit.resizeEvent(self, event)
    self._updateGeometry(True)
</t>
<t tx="ekr.20190812072049.521">def showEvent(self, event):
    QtWidgets.QLineEdit.showEvent(self, event)
    self._updateGeometry()
</t>
<t tx="ekr.20190812072049.522">def _updateGeometry(self, light=False):
    if not self.isVisible():
        return

    # Init
    rect = self.rect()

    # Determine padding and height
    paddingLeft, paddingRight, height = 1, 1, 0
    #
    for but in self._leftButtons:
        if but.isVisible():
            sz = but.sizeHint()
            height = max(height, sz.height())
            but.move(   1+paddingLeft,
                        (rect.bottom() + 1 - sz.height())/2 )
            paddingLeft += sz.width() + 1
    #
    for but in self._rightButtons:
        if but.isVisible():
            sz = but.sizeHint()
            paddingRight += sz.width() + 1
            height = max(height, sz.height())
            but.move(   rect.right()-1-paddingRight,
                        (rect.bottom() + 1 - sz.height())/2 )

    # Set padding
    ss = "QLineEdit { padding-left: %ipx; padding-right: %ipx} "
    self.setStyleSheet( ss % (paddingLeft, paddingRight) )

    # Set minimum size
    if not light:
        fw = QtWidgets.qApp.style().pixelMetric(QtWidgets.QStyle.PM_DefaultFrameWidth)
        msz = self.minimumSizeHint()
        w = max(msz.width(), paddingLeft + paddingRight + 10)
        h = max(msz.height(), height + fw*2 + 2)
        self.setMinimumSize(w,h)
</t>
<t tx="ekr.20190812072049.523">class PathInput(LineEditWithToolButtons):
    """ Line edit for selecting a path.
    """

    dirChanged = QtCore.Signal(str)  # Emitted when the user changes the path (and is valid)
    dirUp = QtCore.Signal()  # Emitted when user presses the up button

    @others
</t>
<t tx="ekr.20190812072049.524">def __init__(self, parent):
    LineEditWithToolButtons.__init__(self, parent)

    # Create up button
    self._upBut = self.addButtonLeft(pyzo.icons.folder_parent)
    self._upBut.clicked.connect(self.dirUp)

    # To receive focus events
    self.setFocusPolicy(QtCore.Qt.StrongFocus)

    # Set completion mode
    self.setCompleter(QtWidgets.QCompleter())
    c = self.completer()
    c.setCompletionMode(c.InlineCompletion)

    # Set dir model to completer
    dirModel = QtWidgets.QDirModel(c)
    dirModel.setFilter(QtCore.QDir.Dirs | QtCore.QDir.NoDotAndDotDot)
    c.setModel(dirModel)

    # Connect signals
    #c.activated.connect(self.onActivated)
    self.textEdited.connect(self.onTextEdited)
    #self.textChanged.connect(self.onTextEdited)
    #self.cursorPositionChanged.connect(self.onTextEdited)
</t>
<t tx="ekr.20190812072049.525">def setPath(self, path):
    """ Set the path to display. Does nothing if this widget has focus.
    """
    if not self.hasFocus():
        self.setText(path)
        self.checkValid() # Reset style if it was invalid first
</t>
<t tx="ekr.20190812072049.526">def checkValid(self):
    # todo: This kind of violates the abstraction of the file system
    # ok for now, but we should find a different approach someday
    # Check
    text = self.text()
    dir = cleanpath(text)
    isvalid = text and isdir(dir) and op.isabs(dir)
    # Apply styling
    ss = self.styleSheet().replace('font-style:italic; ', '')
    if not isvalid:
        ss = ss.replace('QLineEdit {', 'QLineEdit {font-style:italic; ')
    self.setStyleSheet(ss)
    # Return
    return isvalid
</t>
<t tx="ekr.20190812072049.527">def event(self, event):
    # Capture key events to explicitly apply the completion and
    # invoke checking whether the current text is a valid directory.
    # Test if QtGui is not None (can happen when reloading tools)
    if QtGui and isinstance(event, QtGui.QKeyEvent):
        qt = QtCore.Qt
        if event.key() in [qt.Key_Tab, qt.Key_Enter, qt.Key_Return]:
            self.setText(self.text()) # Apply completion
            self.onTextEdited() # Check if this is a valid dir
            return True
    return super().event(event)
</t>
<t tx="ekr.20190812072049.528">def onTextEdited(self, dummy=None):
    text = self.text()
    if self.checkValid():
        self.dirChanged.emit(cleanpath(text))
</t>
<t tx="ekr.20190812072049.529">def focusOutEvent(self, event=None):
    """ focusOutEvent(event)
    On focusing out, make sure that the set path is correct.
    """
    if event is not None:
        QtWidgets.QLineEdit.focusOutEvent(self, event)

    path = self.parent()._tree.path()
    self.setPath(path)
</t>
<t tx="ekr.20190812072049.53">def _splitLinesForPrinting(self, text):
    """ Given a text, split the text in lines. Lines that are extremely
    long are split in pieces of 80 characters to increase performance for
    wrapping. This is kind of a failsafe for when the user accidentally
    prints a bitmap or huge list. See issue 98.
    """
    for line in text.splitlines(True):
        if len(line) &gt; 1024: # about 12 lines of 80 chars
            parts = [line[i:i+80] for i in range(0, len(line), 80)]
            yield '\n'.join(parts)
        else:
            yield line
</t>
<t tx="ekr.20190812072049.530">class Projects(QtWidgets.QWidget):

    dirChanged = QtCore.Signal(str) # Emitted when the user changes the project

    @others
</t>
<t tx="ekr.20190812072049.531">def __init__(self, parent):
    QtWidgets.QWidget.__init__(self, parent)

    # Init variables
    self._path = ''

    # Create combo button
    self._combo = QtWidgets.QComboBox(self)
    self._combo.setEditable(False)
    self.updateProjectList()

    # Create star button
    self._but = QtWidgets.QToolButton(self)
    self._but.setIcon( pyzo.icons.star3 )
    self._but.setStyleSheet("QToolButton { padding: 0px; }")
    self._but.setIconSize(QtCore.QSize(18,18))
    self._but.setToolButtonStyle(QtCore.Qt.ToolButtonTextBesideIcon)
    self._but.setPopupMode(self._but.InstantPopup)
    #
    self._menu = QtWidgets.QMenu(self._but)
    self._menu.triggered.connect(self.onMenuTriggered)
    self.buildMenu()

    # Make equal height
    h = max(self._combo.sizeHint().height(), self._but.sizeHint().height())
    self._combo.setMinimumHeight(h);  self._but.setMinimumHeight(h)

    # Connect signals
    self._but.pressed.connect(self.onButtonPressed)
    self._combo.activated .connect(self.onProjectSelect)

    # Layout
    layout = QtWidgets.QHBoxLayout(self)
    self.setLayout(layout)
    layout.addWidget(self._but)
    layout.addWidget(self._combo)
    layout.setSpacing(2)
    layout.setContentsMargins(0,0,0,0)
</t>
<t tx="ekr.20190812072049.532">def currentDict(self):
    """ Return the current project-dict, or None.
    """
    path = self._combo.itemData(self._combo.currentIndex())
    return self.parent().dictForStarredDir(path)
</t>
<t tx="ekr.20190812072049.533">def setPath(self, path):
    self._path = path
    # Find project index
    projectIndex, L = 0, 0
    pathn = op.normcase(path) + op.sep
    for i in range(self._combo.count()):
        projectPath = self._combo.itemData(i) + op.sep
        if pathn.startswith(projectPath) and len(projectPath) &gt; L:
            projectIndex, L = i, len(projectPath)
    # Select project or not ...
    self._combo.setCurrentIndex(projectIndex)
    if projectIndex:
        self._but.setIcon( pyzo.icons.star2 )
        self._but.setMenu(self._menu)
    else:
        self._but.setIcon( pyzo.icons.star3 )
        self._but.setMenu(None)
</t>
<t tx="ekr.20190812072049.534">def updateProjectList(self):
    # Get sorted version of starredDirs
    starredDirs = self.parent().starredDirs
    starredDirs.sort(key=lambda p:self.parent().dictForStarredDir(p).name.lower())
    # Refill the combo box
    self._combo.clear()
    if starredDirs:
        self._combo.addItem(translate('filebrowser', 'Projects:'), '') # No-project item
        for p in starredDirs:
            name = self.parent().dictForStarredDir(p).name
            self._combo.addItem(name, p)
    else:
        self._combo.addItem(
            translate('filebrowser', 'Click star to bookmark current dir'), '')
</t>
<t tx="ekr.20190812072049.535">def buildMenu(self):
    menu = self._menu
    menu.clear()

    # Add action to remove bookmark
    action = menu.addAction(translate('filebrowser', 'Remove project'))
    action._id = 'remove'
    action.setCheckable(False)

    # Add action to change name
    action = menu.addAction(translate('filebrowser', 'Change project name'))
    action._id = 'name'
    action.setCheckable(False)

    menu.addSeparator()

    # Add check action for adding to Pythonpath
    action = menu.addAction(translate('filebrowser', 'Add path to Python path'))
    action._id = 'pythonpath'
    action.setCheckable(True)
    d = self.currentDict()
    if d:
        checked = bool( d and d['addToPythonpath'] )
        action.setChecked(checked)

    # Add action to cd to the project directory
    action = menu.addAction(translate('filebrowser', 'Go to this directory in the current shell'))
    action._id = 'cd'
    action.setCheckable(False)
</t>
<t tx="ekr.20190812072049.536">def onMenuTriggered(self, action):
    d = self.currentDict()
    if not d:
        return

    if action._id == 'remove':
        # Remove this project
        self.parent().removeStarredDir(d.path)

    elif action._id == 'name':
        # Open dialog to ask for name
        name = QtWidgets.QInputDialog.getText(self.parent(),
                            translate('filebrowser', 'Project name'),
                            translate('filebrowser', 'New project name:'),
                            text=d['name'],
                        )
        if isinstance(name, tuple):
            name = name[0] if name[1] else ''
        if name:
            d['name'] = name
        self.updateProjectList()

    elif action._id == 'pythonpath':
        # Flip add-to-pythonpath flag
        d['addToPythonpath'] = not d['addToPythonpath']

    elif action._id == 'cd':
        # cd to the directory
        shell = pyzo.shells.getCurrentShell()
        if shell:
            shell.executeCommand('cd '+d.path+'\n')
</t>
<t tx="ekr.20190812072049.537">def onButtonPressed(self):
    if self._but.menu():
        # The directory is starred and has a menu. The user just
        # used the menu (or not). Update so it is up-to-date next time.
        self.buildMenu()
    else:
        # Not starred right now, create new project!
        self.parent().addStarredDir(self._path)
    # Update
    self.setPath(self._path)
</t>
<t tx="ekr.20190812072049.538">def onProjectSelect(self, index):
    path = self._combo.itemData(index)
    if path:
        # Go to dir
        self.dirChanged.emit(path)
    else:
        # Dummy item, reset
        self.setPath(self._path)
</t>
<t tx="ekr.20190812072049.539">class NameFilter(LineEditWithToolButtons):
    """ Combobox to filter by name.
    """

    filterChanged = QtCore.Signal()

    @others
</t>
<t tx="ekr.20190812072049.54">def write(self, text, prompt=0, color=None):
    """ write(text, prompt=0, color=None)

    Write to the shell. Fauto-ind

    If prompt is 0 (default) the text is printed before the prompt. If
    prompt is 1, the text is printed after the prompt, the new prompt
    becomes null. If prompt is 2, the given text becomes the new prompt.

    The color of the text can also be specified (as a hex-string).

    """

    # From The Qt docs: Note that a cursor always moves when text is
    # inserted before the current position of the cursor, and it always
    # keeps its position when text is inserted after the current position
    # of the cursor.

    # Make sure there's text and make sure its a string
    if not text:
        return
    if isinstance(text, bytes):
        text = text.decode('utf-8')

    # Prepare format
    format = QtGui.QTextCharFormat()
    if color:
        format.setForeground(QtGui.QColor(color))

    #pos1, pos2 = self._cursor1.position(), self._cursor2.position()

    # Just in case, clear any selection of the cursors
    self._cursor1.clearSelection()
    self._cursor2.clearSelection()

    if prompt == 0:
        # Insert text behind prompt (normal streams)
        self._cursor1.setKeepPositionOnInsert(False)
        self._cursor2.setKeepPositionOnInsert(False)
        text = self._handleCarriageReturn(text)
        text = self._handleBackspaces(text)
        self._insertText(self._cursor1, text, format)
    elif prompt == 1:
        # Insert command text after prompt, prompt becomes null (input)
        self._lastCommandCursor.setPosition(self._cursor2.position())
        self._cursor1.setKeepPositionOnInsert(False)
        self._cursor2.setKeepPositionOnInsert(False)
        self._insertText(self._cursor2, text, format)
        self._cursor1.setPosition(self._cursor2.position(), A_MOVE)
    elif prompt == 2 and text == '\b':
        # Remove prompt (used when closing the kernel)
        self._cursor1.setPosition(self._cursor2.position(), A_KEEP)
        self._cursor1.removeSelectedText()
        self._cursor2.setPosition(self._cursor1.position(), A_MOVE)
    elif prompt == 2:
        # Insert text after prompt, inserted text becomes new prompt
        self._cursor1.setPosition(self._cursor2.position(), A_MOVE)
        self._cursor1.setKeepPositionOnInsert(True)
        self._cursor2.setKeepPositionOnInsert(False)
        self._insertText(self._cursor1, text, format)

    # Reset cursor states for the user to type his/her commands
    self._cursor1.setKeepPositionOnInsert(True)
    self._cursor2.setKeepPositionOnInsert(True)

    # Make sure that cursor is visible (only when cursor is at edit line)
    if not self.isReadOnly():
        self.ensureCursorVisible()

    # Scroll along with the text if lines are popped from the top
    elif self.blockCount() == MAXBLOCKCOUNT:
        n = text.count('\n')
        sb = self.verticalScrollBar()
        sb.setValue(sb.value()-n)
</t>
<t tx="ekr.20190812072049.540">def __init__(self, parent):
    LineEditWithToolButtons.__init__(self, parent)

    # Create tool button, and attach the menu
    self._menuBut = self.addButtonRight(pyzo.icons['filter'], True)
    self._menu = QtWidgets.QMenu(self._menuBut)
    self._menu.triggered.connect(self.onMenuTriggered)
    self._menuBut.setMenu(self._menu)
    #
    # Add common patterns
    for pattern in ['*', '!hidden', '!*.pyc !hidden',
                    '*.py *.pyw', '*.py *.pyw *.pyx *.pxd',
                    '*.h *.c *.cpp']:
        self._menu.addAction(pattern)

    # Emit signal when value is changed
    self._lastValue = ''
    self.returnPressed.connect(self.checkFilterValue)
    self.editingFinished.connect(self.checkFilterValue)

    # Ensure the namefilter is in the config and initialize
    config = self.parent().config
    if 'nameFilter' not in config:
        config.nameFilter = '!*.pyc'
    self.setText(config.nameFilter)
</t>
<t tx="ekr.20190812072049.541">def setText(self, value, test=False):
    """ To initialize the name filter.
    """
    QtWidgets.QLineEdit.setText(self, value)
    if test:
        self.checkFilterValue()
    self._lastValue = value
</t>
<t tx="ekr.20190812072049.542">def checkFilterValue(self):
    value = self.text()
    if value != self._lastValue:
        self.parent().config.nameFilter = value
        self._lastValue = value
        self.filterChanged.emit()
</t>
<t tx="ekr.20190812072049.543">def onMenuTriggered(self, action):
    self.setText(action.text(), True)
</t>
<t tx="ekr.20190812072049.544">class SearchFilter(LineEditWithToolButtons):
    """ Line edit to do a search in the files.
    """

    filterChanged = QtCore.Signal()

    @others
</t>
<t tx="ekr.20190812072049.545">def __init__(self, parent):
    LineEditWithToolButtons.__init__(self, parent)

    # Create tool button, and attach the menu
    self._menuBut = self.addButtonRight(pyzo.icons['magnifier'], True)
    self._menu = QtWidgets.QMenu(self._menuBut)
    self._menu.triggered.connect(self.onMenuTriggered)
    self._menuBut.setMenu(self._menu)
    self.buildMenu()

    # Create cancel button
    self._cancelBut = self.addButtonRight(pyzo.icons['cancel'])
    self._cancelBut.setVisible(False)

    # Keep track of last value of search (initialized empty)
    self._lastValue = ''

    # Connect signals
    self._cancelBut.pressed.connect(self.onCancelPressed)
    self.textChanged.connect(self.updateCancelButton)
    self.editingFinished.connect(self.checkFilterValue)
    self.returnPressed.connect(self.forceFilterChanged)
</t>
<t tx="ekr.20190812072049.546">def onCancelPressed(self):
    """ Clear text or build menu.
    """
    if self.text():
        QtWidgets.QLineEdit.clear(self)
        self.checkFilterValue()
    else:
        self.buildMenu()
</t>
<t tx="ekr.20190812072049.547">def checkFilterValue(self):
    value = self.text()
    if value != self._lastValue:
        self._lastValue = value
        self.filterChanged.emit()
</t>
<t tx="ekr.20190812072049.548">def forceFilterChanged(self):
    self._lastValue = self.text()
    self.filterChanged.emit()
</t>
<t tx="ekr.20190812072049.549">def updateCancelButton(self, text):
    visible = bool(self.text())
    self.setButtonVisible(self._cancelBut, visible)
</t>
<t tx="ekr.20190812072049.55">def _insertText(self, cursor, text, format):
    """ Insert text at the given cursor, and with the given format.
    This function processes ANSI escape code for formatting and
    colorization: http://en.wikipedia.org/wiki/ANSI_escape_code
    """

    # If necessary, make a new cursor that moves along. We insert
    # the text in pieces, so we need to move along with the text!
    if cursor.keepPositionOnInsert():
        cursor = QtGui.QTextCursor(cursor)
        cursor.setKeepPositionOnInsert(False)

    # Init. We use the solarised color theme
    pattern = r'\x1b\[(.*?)m'
    #CLRS = ['#000', '#F00', '#0F0', '#FF0', '#00F', '#F0F', '#0FF', '#FFF']
    CLRS = ['#657b83', '#dc322f', '#859900', '#b58900', '#268bd2',
            '#d33682', '#2aa198', '#eee8d5']
    i0 = 0

    for match in re.finditer(pattern, text):

        # Insert pending text with the current format
        # Also update indices
        i1, i2 = match.span()
        cursor.insertText(text[i0:i1], format)
        i0 = i2

        # The formay that we are now going to parse should apply to
        # the text that follow it ...

        # Get parameters
        try:
            params = [int(i) for i in match.group(1).split(';')]
        except ValueError:
            params = []
        if not params:
            params = [0]

        # Process
        for param in params:
            if param == 0:
                format = QtGui.QTextCharFormat()
            elif param == 1:
                format.setFontWeight(75)  # Bold
            elif param == 2:
                format.setFontWeight(25)  # Faint
            elif param == 3:
                format.setFontItalic(True)  # Italic
            elif param == 4:
                format.setFontUnderline(True)  # Underline
            #
            elif param == 22:
                format.setFontWeight(50)  # Not bold or faint
            elif param == 23:
                format.setFontItalic(False)  # Not italic
            elif param == 24:
                format.setFontUnderline(False)  # Not underline
            #
            elif 30 &lt;= param &lt;= 37:  # Set foreground color
                clr = CLRS[param-30]
                format.setForeground(QtGui.QColor(clr))
            elif 40 &lt;= param &lt;= 47:
                pass # Cannot set background text in QPlainTextEdit
            #
            else:
                pass  # Not supported

    else:
        # At the end, process the remaining text
        text = text[i0:]

        # Process very long text more efficiently.
        # Insert per line (very long lines are split in smaller ones)
        if len(text) &gt; 1024:
            for line in self._splitLinesForPrinting(text):
                cursor.insertText(line, format)
        else:
            cursor.insertText(text, format)

## Executing stuff
</t>
<t tx="ekr.20190812072049.550">def buildMenu(self):
    config = self.parent().config
    menu = self._menu
    menu.clear()

    map = [ ('searchMatchCase', False, translate("filebrowser", "Match case")),
            ('searchRegExp', False, translate("filebrowser", "RegExp")),
            ('searchSubDirs', True, translate("filebrowser", "Search in subdirs"))
          ]

    # Fill menu
    for option, default, description in map:
        if option is None:
            menu.addSeparator()
        else:
            # Make sure the option exists
            if option not in config:
                config[option] = default
            # Make action in menu
            action = menu.addAction(description)
            action._option = option
            action.setCheckable(True)
            action.setChecked( bool(config[option]) )
</t>
<t tx="ekr.20190812072049.551">def onMenuTriggered(self, action):
    config = self.parent().config
    option = action._option
    # Swap this option
    if option in config:
        config[option] = not config[option]
    else:
        config[option] = True
    # Update
    self.filterChanged.emit()
</t>
<t tx="ekr.20190812072049.552">@path pyzo/tools/pyzoFileBrowser/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072049.553">"""

The import wizard helps the user importing CSV-like data from a file into a
numpy array. The wizard containst three pages:

SelectFilePage:
    - The user selects a file and previews its contents (or, the beginning of it)

SetParametersPage:
    - The user selects delimiters, etc. and selects which columns to import
    - A preview of the data in tabualar form is shown, with colors indicating
      how the file is parsed: yellow for header rows, green for the comments
      column and red for values that could not be parsed

ResultPage:
    - The wizard shows the generated code that is to be used to import the file
      according to the settings
    - The user chooses to execute the code in the current shell or paste the
      code into the editor

"""

import unicodedata
import os.path as op

import pyzo.codeeditor
from . import QtCore, QtGui, QtWidgets
from pyzo import translate

# All keywords in Python 2 and 3. Obtained using: import keyword; keyword.kwlist
# Merged from Py2 and 3
keywords = ['False', 'None', 'True', 'and', 'as', 'assert', 'break',
    'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'exec',
    'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is',
    'lambda', 'nonlocal', 'not', 'or', 'pass', 'print', 'raise', 'return',
    'try', 'while', 'with', 'yield']
</t>
<t tx="ekr.20190812072049.554">class CodeView(
    pyzo.codeeditor.IndentationGuides,
    pyzo.codeeditor.CodeFolding,
    pyzo.codeeditor.Indentation,
    pyzo.codeeditor.HomeKey,
    pyzo.codeeditor.EndKey,
    pyzo.codeeditor.NumpadPeriodKey,

    pyzo.codeeditor.AutoIndent,
    pyzo.codeeditor.PythonAutoIndent,

    pyzo.codeeditor.SyntaxHighlighting,

    pyzo.codeeditor.CodeEditorBase):  #CodeEditorBase must be the last one in the list
    """
    Code viewer, stripped down version of the CodeEditor
    """
    pass
</t>
<t tx="ekr.20190812072049.555">class SelectFilePage(QtWidgets.QWizardPage):
    """
    First page of the wizard, select file and preview contents
    """
    @others
</t>
<t tx="ekr.20190812072049.556">def __init__(self):
    QtWidgets.QWizardPage.__init__(self)

    self.setTitle(translate('importwizard', 'Select file'))

    self.txtFilename = QtWidgets.QLineEdit()
    self.btnBrowse = QtWidgets.QPushButton(translate('importwizard', 'Browse...'))
    self.preview = QtWidgets.QPlainTextEdit()
    self.preview.setReadOnly(True)

    vlayout = QtWidgets.QVBoxLayout()
    hlayout = QtWidgets.QHBoxLayout()

    hlayout.addWidget(self.txtFilename)
    hlayout.addWidget(self.btnBrowse)
    vlayout.addLayout(hlayout)
    vlayout.addWidget(QtWidgets.QLabel(translate('importwizard', 'Preview:')))
    vlayout.addWidget(self.preview)

    self.setLayout(vlayout)

    self.registerField('fname', self.txtFilename)

    self.btnBrowse.clicked.connect(self.onBrowseClicked)
    self.txtFilename.editingFinished.connect(self.updatePreview)
    self._isComplete = False
</t>
<t tx="ekr.20190812072049.557">def onBrowseClicked(self):
    # Difference between PyQt4 and PySide: PySide returns filename, filter
    # while PyQt4 returns only the filename
    filename = QtWidgets.QFileDialog.getOpenFileName(filter = 'Text files (*.txt *.csv);;All files (*.*)')
    if isinstance(filename, tuple):
        filename = filename[0]

    filename = str(filename).replace('/', op.sep) # Show native file separator

    self.txtFilename.setText(filename)
    self.updatePreview()
</t>
<t tx="ekr.20190812072049.558">def updatePreview(self):
    filename = self.txtFilename.text()
    if not filename:
        data = ''
        self._isComplete = False
        self.wizard().setPreviewData(None)
    else:
        try:
            with open(filename,'rb') as file:
                maxsize = 5000
                data = file.read(maxsize)
                more = bool(file.read(1)) # See if there is more data available

            data = data.decode('ascii', 'replace')

            self.wizard().setPreviewData(data)

            if more:
                data += '...'

            self._isComplete = True  # Allow to proceed to the next page
        except Exception as e:
            data = str(e)
            self._isComplete = False
            self.wizard().setPreviewData(None)

    self.preview.setPlainText(data)
    self.completeChanged.emit()
</t>
<t tx="ekr.20190812072049.559">def isComplete(self):
    return self._isComplete
</t>
<t tx="ekr.20190812072049.56">def processLine(self, line=None, execute=True):
    """ processLine(self, line=None, execute=True)

    Process the given line or the current line at the prompt if not given.
    Called when the user presses enter.

    If execute is False will not execute the command. This way
    a message can be written while other ways are used to process
    the command.
    """

    # Can we do this?
    if self.isReadOnly() and not line:
        return

    if line:
        # remove trailing newline(s)
        command = line.rstrip('\n')
    else:
        # Select command
        cursor = self.textCursor()
        cursor.setPosition(self._cursor2.position(), A_MOVE)
        cursor.movePosition(cursor.End, A_KEEP)

        # Sample the text from the prompt and remove it
        command = cursor.selectedText().replace('\u2029', '\n') .rstrip('\n')
        cursor.removeSelectedText()

        # Auto-indent. Note: this is rather Python-specific
        command_s = command.lstrip()
        indent = ' ' * (len(command) - len(command_s))
        if command.strip().endswith(':'):
            indent += '    '
        elif not command_s:
            indent = ''
        if indent:
            cursor.insertText(indent)

        if command:
            # Remember the command in this global history
            pyzo.command_history.append(command)

    if execute:
        command = command.replace('\r\n', '\n')
        self.executeCommand(command+'\n')
</t>
<t tx="ekr.20190812072049.560">class SetParametersPage(QtWidgets.QWizardPage):
    @others
</t>
<t tx="ekr.20190812072049.561">def __init__(self):
    QtWidgets.QWizardPage.__init__(self)

    self.setTitle("Select parameters")

    self._columnNames = None

    def genComboBox(choices):
        cbx = QtWidgets.QComboBox()
        for choice in choices:
            cbx.addItem(choice)
        cbx.setEditable(True)
        return cbx

    self.cbxDelimiter = genComboBox(",;")
    self.cbxComments = genComboBox("#%'")
    self.sbSkipHeader = QtWidgets.QSpinBox()

    self.preview = QtWidgets.QTableWidget()
    self.preview.setSelectionModel(QtCore.QItemSelectionModel(self.preview.model())) # Work-around for reference tracking bug in PySide
    self.preview.setSelectionBehavior(self.preview.SelectColumns)
    self.preview.setSelectionMode(self.preview.MultiSelection)

    # Layout

    formlayout = QtWidgets.QFormLayout()
    formlayout.addRow('Delimiter', self.cbxDelimiter)
    formlayout.addRow('Comments', self.cbxComments)
    formlayout.addRow('Header rows to skip', self.sbSkipHeader)

    layout = QtWidgets.QVBoxLayout()
    layout.addLayout(formlayout)
    layout.addWidget(QtWidgets.QLabel(
        translate('importwizard', 'Select columns to import:')))
    layout.addWidget(self.preview)

    self.setLayout(layout)

    # Wizard fields
    self.registerField('delimiter', self.cbxDelimiter, "currentText")
    self.registerField('comments', self.cbxComments, "currentText")
    self.registerField('skip_header', self.sbSkipHeader)

    # Signals
    self.cbxComments.editTextChanged.connect(self.updatePreview)
    self.cbxDelimiter.editTextChanged.connect(self.updatePreview)
    self.sbSkipHeader.valueChanged.connect(self.updatePreview)
    self.preview.verticalHeader().sectionClicked.connect(self.onRowHeaderClicked)
</t>
<t tx="ekr.20190812072049.562">def columnNames(self):
    if self._columnNames is None:
        return list(['d' + str(i + 1) for i in range(self.preview.columnCount()-1)])

    return list(self._columnNames)
</t>
<t tx="ekr.20190812072049.563">def updateHorizontalHeaderLabels(self):
    self.preview.setHorizontalHeaderLabels(self.columnNames() + ['Comments'])
</t>
<t tx="ekr.20190812072049.564">def onRowHeaderClicked(self, row):
    names = self.parseColumnNames(row)
    self._columnNames = names
    self.updateHorizontalHeaderLabels()
</t>
<t tx="ekr.20190812072049.565">def parseColumnNames(self, row):
    """
    Use the data in the given row to create column names. First, try the
    data in the data columns. If these are all empty, use the comments
    column, split by the given delimiter.

    Names are fixed up to be valid Python 2 / Python 3 identifiers
    (chars a-z A-Z _ 0-9 , no Python 2 or 3 keywords, not starting with 0-9)

    returns: list of names, exactly as many as there are data columns
    """
    names = []
    columnCount = self.preview.columnCount()-1
    for col in range(columnCount):
        cell = self.preview.item(row, col)
        if cell is None:
            names.append('')
        else:
            names.append(cell.text().strip())

    # If no values found, try the comments:
    if not any(names):
        cell = self.preview.item(row, columnCount)
        if cell is not None:
            comment = cell.text()[1:].strip() # Remove comment char and whitespace
            delimiter = self.cbxDelimiter.currentText()
            names = list(name.strip() for name in comment.split(delimiter))

            # Ensure names is exactly columnCount long
            names += [''] * columnCount
            names = names[:columnCount]

    # Fixup names
    def fixname(name, col):
        # Remove accents
        name = ''.join(c for c in unicodedata.normalize('NFD', name)
                                    if unicodedata.category(c) != 'Mn')
        # Replace invalid chars with _
        name = ''.join(c if (c.lower()&gt;='a' and c.lower()&lt;='z') or (c&gt;='0' and c&lt;='9') else '_' for c in name)

        if not name:
            return 'd' + str(col)

        if name[0]&gt;='0' and name&lt;='9':
            name = 'd' + name

        if name in keywords:
            name = name + '_'

        return name

    names = list(fixname(name, i + 1) for i, name in enumerate(names))

    return names
</t>
<t tx="ekr.20190812072049.566">def selectedColumns(self):
    """
    Returns a tuple of the columns that are selected, or None if no columns
    are selected
    """
    selected = []
    for selrange in self.preview.selectionModel().selection():
        selected += range(selrange.left(), selrange.right() + 1)

    selected.sort()

    if not selected:
        return None
    else:
        return tuple(selected)
</t>
<t tx="ekr.20190812072049.567">def initializePage(self):
    self.updatePreview()
</t>
<t tx="ekr.20190812072049.568">def updatePreview(self):
    # Get settings from the currently specified values in the wizard
    comments = self.cbxComments.currentText()
    delimiter = self.cbxDelimiter.currentText()
    skipheader = self.sbSkipHeader.value()
    if not comments or not delimiter:
        return

    # Store current selection, will be restored at the end
    selectedColumns = self.selectedColumns()

    # Clear the complete table
    self.preview.clear()
    self.preview.setColumnCount(0)
    self.preview.setRowCount(0)

    # Iterate through the source file line by line
    # Process like genfromtxt, with names = False
    # However, we do keep the header lines and comments; we show them in
    # distinct colors so that the user can see how the data is selected

    source = iter(self.wizard().previewData().splitlines())

    def split_line(line):
        """Chop off comments, strip, and split at delimiter."""
        line, sep, commentstr = line.partition(comments)
        line = line.strip(' \r\n')
        if line:
            return line.split(delimiter), sep + commentstr
        else:
            return [], sep + commentstr

    # Insert comments column
    self.preview.insertColumn(0)

    ncols = 0           # Number of columns, excluding comments column
    headerrows = 0      # Number of header rows, including empty header rows

    inheader = True

    for lineno, line in enumerate(source):
        fields, commentstr = split_line(line)

        # Process header like genfromtxt, with names = False
        if lineno&gt;=skipheader and fields:
            inheader = False

        if inheader:
            headerrows = lineno + 1 # +1 since lineno = 0 is the first line

        self.preview.insertRow(lineno)

        # Add columns to fit all fields
        while len(fields)&gt;ncols:
            self.preview.insertColumn(ncols)
            ncols += 1

        # Add fields to the table
        for col, field in enumerate(fields):
            cell = QtWidgets.QTableWidgetItem(field)
            if not inheader:
                try:
                    float(field)
                except ValueError:
                    cell.setBackground(QtGui.QBrush(QtGui.QColor("pink")))

            self.preview.setItem(lineno,col, cell)

        # Add the comment
        cell = QtWidgets.QTableWidgetItem(commentstr)
        cell.setBackground(QtGui.QBrush(QtGui.QColor("lightgreen")))

        self.preview.setItem(lineno,ncols, cell)

    # Colorize the header cells. This is done as the last step, since
    # meanwhile new columns (and thus new cells) may have been added
    for row in range(headerrows):
        for col in range(ncols):
            cell = self.preview.item(row, col)
            if not cell:
                cell = QtWidgets.QTableWidgetItem('')
                self.preview.setItem(row, col, cell)

            cell.setBackground(QtGui.QBrush(QtGui.QColor("khaki")))

    # Try to restore selection
    if selectedColumns is not None:
        for column in selectedColumns:
            self.preview.selectColumn(column)

    # Restore column names
    self.updateHorizontalHeaderLabels()
</t>
<t tx="ekr.20190812072049.569">class ResultPage(QtWidgets.QWizardPage):
    """
    The resultpage lets the user select wether to import the data as a single
    2D-array, or as one variable (1D-array) per column

    Then, the code to do the import is generated (Py2 and Py3 compatible). This
    code can be executed in the current shell, or copied into the current editor

    """
    @others
</t>
<t tx="ekr.20190812072049.57">def executeCommand(self, command):
    """ Execute the given command.
    Should be overridden.
    """
    # this is a stupid simulation version
    self.write("you executed: "+command+'\n')
    self.write("&gt;&gt;&gt; ", prompt=2)
</t>
<t tx="ekr.20190812072049.570">def __init__(self):
    QtWidgets.QWizardPage.__init__(self)
    self.setTitle("Execute import")
    self.setButtonText(QtWidgets.QWizard.FinishButton,
        translate('importwizard', 'Close'))

    self.rbAsArray = QtWidgets.QRadioButton(translate('importwizard', 'Import data as single array'))
    self.rbPerColumn = QtWidgets.QRadioButton(translate('importwizard', 'Import data into one variable per column'))
    self.rbAsArray.setChecked(True)

    self.chkInvalidRaise = QtWidgets.QCheckBox(translate('importwizard', 'Raise error upon invalid data'))
    self.chkInvalidRaise.setChecked(True)

    self.codeView = CodeView()
    self.codeView.setParser('python')
    self.codeView.setZoom(pyzo.config.view.zoom)
    self.codeView.setFont(pyzo.config.view.fontname)

    self.btnExecute = QtWidgets.QPushButton('Execute in current shell')
    self.btnInsert = QtWidgets.QPushButton('Paste into current file')

    layout = QtWidgets.QVBoxLayout()
    layout.addWidget(self.rbAsArray)
    layout.addWidget(self.rbPerColumn)
    layout.addWidget(self.chkInvalidRaise)

    layout.addWidget(QtWidgets.QLabel('Resulting import code:'))
    layout.addWidget(self.codeView)
    layout.addWidget(self.btnExecute)
    layout.addWidget(self.btnInsert)
    self.setLayout(layout)

    self.registerField('invalid_raise', self.chkInvalidRaise)

    self.btnExecute.clicked.connect(self.onBtnExecuteClicked)
    self.btnInsert.clicked.connect(self.onBtnInsertClicked)
    self.rbAsArray.clicked.connect(self.updateCode)
    self.rbPerColumn.clicked.connect(self.updateCode)
    self.chkInvalidRaise.stateChanged.connect(lambda state: self.updateCode())
</t>
<t tx="ekr.20190812072049.571">def initializePage(self):
    self.updateCode()
</t>
<t tx="ekr.20190812072049.572">def updateCode(self):
    perColumn = self.rbPerColumn.isChecked()

    if perColumn:
        columnNames = self.wizard().field('columnnames')
        usecols = self.wizard().field('usecols')

        if usecols is not None: # User selected a subset of all columns
            # Pick corrsponding column names
            columnNames = [columnNames[i] for i in usecols]

        variables = ', '.join(columnNames)
    else:
        variables = 'data'

    code = "import numpy\n"

    code += variables + " = numpy.genfromtxt(\n"
    for param, default in (
        ('fname', None),
        ('skip_header', 0),
        ('comments', '#'),
        ('delimiter', None),
        ('usecols', None),
        ('invalid_raise', True),
        ):
            value = self.wizard().field(param)
            if value != default:
                code += "\t%s = %r,\n" % (param, value)
    if perColumn:
        code += '\tunpack = True,\n'
    code += '\t)\n'

    self.codeView.setPlainText(code)
</t>
<t tx="ekr.20190812072049.573">def getCode(self):
    return self.codeView.toPlainText()
</t>
<t tx="ekr.20190812072049.574">def onBtnExecuteClicked(self):
    shell = pyzo.shells.getCurrentShell()
    if shell is None:
        QtWidgets.QMessageBox.information(self,
            translate('importwizard', 'Import data wizard'),
            translate('importwizard', 'No current shell active'))
        return

    shell.executeCode(self.getCode(), 'importwizard')
</t>
<t tx="ekr.20190812072049.575">def onBtnInsertClicked(self):
    editor = pyzo.editors.getCurrentEditor()
    if editor is None:
        QtWidgets.QMessageBox.information(self,
            translate('importwizard', 'Import data wizard'),
            translate('importwizard', 'No current file open'))
        return

    code = self.getCode()

    # Format tabs/spaces according to editor setting
    if editor.indentUsingSpaces():
        code = code.replace('\t', ' ' * editor.indentWidth())

    # insert code at start of line
    cursor = editor.textCursor()
    cursor.movePosition(cursor.StartOfBlock)
    cursor.insertText(code)
</t>
<t tx="ekr.20190812072049.576">class ImportWizard(QtWidgets.QWizard):
    @others
if __name__=='__main__':
    iw = ImportWizard()
    iw.open('test.txt')
</t>
<t tx="ekr.20190812072049.577">def __init__(self):
    QtWidgets.QWizard.__init__(self)
    self.setMinimumSize(500,400)
    self.resize(700,500)

    self.setPreviewData(None)

    self.selectFilePage = SelectFilePage()
    self.setParametersPage = SetParametersPage()
    self.resultPage = ResultPage()

    self.addPage(self.selectFilePage)
    self.addPage(self.setParametersPage)
    self.addPage(self.resultPage)

    self.setWindowTitle(translate('importwizard', 'Import data'))

    self.currentIdChanged.connect(self.onCurrentIdChanged)
</t>
<t tx="ekr.20190812072049.578">def onCurrentIdChanged(self, id):
    # Hide the 'cancel' button on the last page
    if self.nextId() == -1:
        self.button(QtWidgets.QWizard.CancelButton).hide()
    else:
        self.button(QtWidgets.QWizard.CancelButton).show()
</t>
<t tx="ekr.20190812072049.579">def open(self, filename):
    if self.isVisible():
        QtWidgets.QMessageBox.information(self,
            translate('importwizard', 'Import data wizard'),
            translate('importwizard', 'The import data wizard is already open'))
        return

    self.restart()
    self.selectFilePage.txtFilename.setText(filename)
    self.selectFilePage.updatePreview()
    self.show()
</t>
<t tx="ekr.20190812072049.58">class PythonShell(BaseShell):
    """ The PythonShell class implements the python part of the shell
    by connecting to a remote process that runs a Python interpreter.
    """

    # Emits when the status string has changed or when receiving a new prompt
    stateChanged = QtCore.Signal(BaseShell)

    # Emits when the debug status is changed
    debugStateChanged = QtCore.Signal(BaseShell)

    @others
if __name__ == '__main__':
    b = BaseShell(None)
    b.show()
</t>
<t tx="ekr.20190812072049.580">def field(self, name):
    # Allow access to all data via field, some properties are not avaialble
    # as actual controls and therefore we have to handle them ourselves
    if name == 'usecols':
        return self.setParametersPage.selectedColumns()
    elif name == 'columnnames':
        return self.setParametersPage.columnNames()
    else:
        return QtWidgets.QWizard.field(self, name)
</t>
<t tx="ekr.20190812072049.581">def setPreviewData(self, data):
    self._previewData = data
</t>
<t tx="ekr.20190812072049.582">def previewData(self):
    if self._previewData is None:
        raise RuntimeError('Preview data not loaded')

    return self._previewData
</t>
<t tx="ekr.20190812072049.59">def __init__(self, parent, info):
    BaseShell.__init__(self, parent)

    # Get standard info if not given.
    if info is None and pyzo.config.shellConfigs2:
        info = pyzo.config.shellConfigs2[0]
    if not info:
        info = KernelInfo(None)

    # Store info so we can reuse it on a restart
    self._info = info

    # For the editor to keep track of attempted imports
    self._importAttempts = []

    # To keep track of the response for introspection
    self._currentCTO = None
    self._currentACO = None

    # Write buffer to store messages in for writing
    self._write_buffer = None

    # Create timer to keep polling any results
    # todo: Maybe use yoton events to process messages as they arrive.
    # I tried this briefly, but it seemd to be less efficient because
    # messages are not so much bach-processed anymore. We should decide
    # on either method.
    self._timer = QtCore.QTimer(self)
    self._timer.setInterval(POLL_TIMER_INTERVAL)  # ms
    self._timer.setSingleShot(False)
    self._timer.timeout.connect(self.poll)
    self._timer.start()

    # Add context menu
    self._menu = ShellContextMenu(shell=self, parent=self)
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(lambda p: self._menu.popup(self.mapToGlobal(p+QtCore.QPoint(0,3))))

    # Keep track of breakpoints
    pyzo.editors.breakPointsChanged.connect(self.sendBreakPoints)

    # Start!
    self.resetVariables()
    self.connectToKernel(info)
</t>
<t tx="ekr.20190812072049.6">def encoding(self):
    return 'utf-8'
</t>
<t tx="ekr.20190812072049.60">def resetVariables(self):
    """ Resets some variables. """

    # Reset read state
    self.setReadOnly(False)

    # Variables to store state, python version, builtins and keywords
    self._state = ''
    self._debugState = {}
    self._version = ""
    self._builtins = []
    self._keywords = []
    self._startup_info = {}
    self._start_time = 0

    # (re)set import attempts
    self._importAttempts[:] = []

    # Update
    self.stateChanged.emit(self)
</t>
<t tx="ekr.20190812072049.61">def connectToKernel(self, info):
    """ connectToKernel()

    Create kernel and connect to it.

    """

    # Create yoton context
    self._context = ct = yoton.Context()

    # Create stream channels
    self._strm_out = yoton.SubChannel(ct, 'strm-out')
    self._strm_err = yoton.SubChannel(ct, 'strm-err')
    self._strm_raw = yoton.SubChannel(ct, 'strm-raw')
    self._strm_echo = yoton.SubChannel(ct, 'strm-echo')
    self._strm_prompt = yoton.SubChannel(ct, 'strm-prompt')
    self._strm_broker = yoton.SubChannel(ct, 'strm-broker')
    self._strm_action = yoton.SubChannel(ct, 'strm-action', yoton.OBJECT)

    # Set channels to sync mode. This means that if the pyzo cannot process
    # the messages fast enough, the sending side is blocked for a short
    # while. We don't want our users to miss any messages.
    for c in [self._strm_out, self._strm_err]:
        c.set_sync_mode(True)

    # Create control channels
    self._ctrl_command = yoton.PubChannel(ct, 'ctrl-command')
    self._ctrl_code = yoton.PubChannel(ct, 'ctrl-code', yoton.OBJECT)
    self._ctrl_broker = yoton.PubChannel(ct, 'ctrl-broker')

    # Create status channels
    self._stat_interpreter = yoton.StateChannel(ct, 'stat-interpreter')
    self._stat_cd = yoton.StateChannel(ct, 'stat-cd')
    self._stat_debug = yoton.StateChannel(ct, 'stat-debug', yoton.OBJECT)
    self._stat_startup = yoton.StateChannel(ct, 'stat-startup', yoton.OBJECT)
    self._stat_breakpoints = yoton.StateChannel(ct, 'stat-breakpoints', yoton.OBJECT)

    self._stat_startup.received.bind(self._onReceivedStartupInfo)

    # Create introspection request channel
    self._request = yoton.ReqChannel(ct, 'reqp-introspect')

    # Connect! The broker will only start the kernel AFTER
    # we connect, so we do not miss out on anything.
    slot = pyzo.localKernelManager.createKernel(finishKernelInfo(info))
    self._brokerConnection = ct.connect('localhost:%i'%slot)
    self._brokerConnection.closed.bind(self._onConnectionClose)

    # Force updating of breakpoints
    pyzo.editors.updateBreakPoints()

    # todo: see polling vs events
#         # Detect incoming messages
#         for c in [self._strm_out, self._strm_err, self._strm_raw,
#                 self._strm_echo, self._strm_prompt, self._strm_broker,
#                 self._strm_action,
#                 self._stat_interpreter, self._stat_debug]:
#             c.received.bind(self.poll)
</t>
<t tx="ekr.20190812072049.62">def get_kernel_cd(self):
    """ Get current working dir of kernel.
    """
    return self._stat_cd.recv()
</t>
<t tx="ekr.20190812072049.63">def _onReceivedStartupInfo(self, channel):
    startup_info = channel.recv()

    # Store the whole dict
    self._startup_info = startup_info

    # Store when we received this
    self._start_time = time.time()

    # Set version
    version = startup_info.get('version', None)
    if isinstance(version, tuple):
        version = [str(v) for v in version]
        self._version = '.'.join(version[:2])

    # Set keywords
    L = startup_info.get('keywords', None)
    if isinstance(L, list):
        self._keywords = L

    # Set builtins
    L = startup_info.get('builtins', None)
    if isinstance(L, list):
        self._builtins = L

    # Notify
    self.stateChanged.emit(self)

## Introspection processing methods
</t>
<t tx="ekr.20190812072049.64">def processCallTip(self, cto):
    """ Processes a calltip request using a CallTipObject instance.
    """

    # Try using buffer first (not if we're not the requester)
    if self is cto.textCtrl:
        if cto.tryUsingBuffer():
            return

    # Clear buffer to prevent doing a second request
    # and store cto to see whether the response is still wanted.
    cto.setBuffer('')
    self._currentCTO = cto

    # Post request
    future = self._request.signature(cto.name)
    future.add_done_callback(self._processCallTip_response)
    future.cto = cto
</t>
<t tx="ekr.20190812072049.65">def _processCallTip_response(self, future):
    """ Process response of shell to show signature.
    """

    # Process future
    if future.cancelled():
        #print('Introspect cancelled')  # No kernel
        return
    elif future.exception():
        print('Introspect-exception: ', future.exception())
        return
    else:
        response = future.result()
        cto = future.cto

    # First see if this is still the right editor (can also be a shell)
    editor1 = pyzo.editors.getCurrentEditor()
    editor2 = pyzo.shells.getCurrentShell()
    if cto.textCtrl not in [editor1, editor2]:
        # The editor or shell starting the autocomp is no longer active
        cto.textCtrl.autocompleteCancel()
        return

    # Invalid response
    if response is None:
        cto.textCtrl.autocompleteCancel()
        return

    # If still required, show tip, otherwise only store result
    if cto is self._currentCTO:
        cto.finish(response)
    else:
        cto.setBuffer(response)
</t>
<t tx="ekr.20190812072049.66">def processAutoComp(self, aco):
    """ Processes an autocomp request using an AutoCompObject instance.
    """

    # Try using buffer first (not if we're not the requester)
    if self is aco.textCtrl:
        if aco.tryUsingBuffer():
            return

    # Include builtins and keywords?
    if not aco.name:
        aco.addNames(self._builtins)
        if pyzo.config.settings.autoComplete_keywords:
            aco.addNames(self._keywords)

    # Set buffer to prevent doing a second request
    # and store aco to see whether the response is still wanted.
    aco.setBuffer()
    self._currentACO = aco

    # Post request
    future = self._request.dir(aco.name)
    future.add_done_callback(self._processAutoComp_response)
    future.aco = aco
</t>
<t tx="ekr.20190812072049.67">def _processAutoComp_response(self, future):
    """ Process the response of the shell for the auto completion.
    """

    # Process future
    if future.cancelled():
        #print('Introspect cancelled') # No living kernel
        return
    elif future.exception():
        print('Introspect-exception: ', future.exception())
        return
    else:
        response = future.result()
        aco = future.aco

    # First see if this is still the right editor (can also be a shell)
    editor1 = pyzo.editors.getCurrentEditor()
    editor2 = pyzo.shells.getCurrentShell()
    if aco.textCtrl not in [editor1, editor2]:
        # The editor or shell starting the autocomp is no longer active
        aco.textCtrl.autocompleteCancel()
        return

    # Add result to the list
    foundNames = []
    if response is not None:
        foundNames = response
    aco.addNames(foundNames)

    # Process list
    if aco.name and not foundNames:
        # No names found for the requested name. This means
        # it does not exist, let's try to import it
        importNames, importLines = pyzo.parser.getFictiveImports(editor1)
        baseName = aco.nameInImportNames(importNames)
        if baseName:
            line = importLines[baseName].strip()
            if line not in self._importAttempts:
                # Do import
                self.processLine(line + ' # auto-import')
                self._importAttempts.append(line)
                # Wait a barely noticable time to increase the chances
                # That the import is complete when we repost the request.
                time.sleep(0.2)
                # To be sure, decrease the experiration date on the buffer
                aco.setBuffer(timeout=1)
                # Repost request
                future = self._request.signature(aco.name)
                future.add_done_callback(self._processAutoComp_response)
                future.aco = aco
    else:
        # If still required, show list, otherwise only store result
        if self._currentACO is aco:
            aco.finish()
        else:
            aco.setBuffer()

## Methods for executing code
</t>
<t tx="ekr.20190812072049.68">def executeCommand(self, text):
    """ executeCommand(text)
    Execute one-line command in the remote Python session.
    """

    # Ensure edit line is selected (to reset scrolling to end)
    self.ensureCursorAtEditLine()

    self._ctrl_command.send(text)
</t>
<t tx="ekr.20190812072049.69">def executeCode(self, text, fname, lineno=None, cellName=None, changeDir=False):
    """ executeCode(text, fname, lineno, cellName=None)
    Execute (run) a large piece of code in the remote shell.
    text: the source code to execute
    filename: the file from which the source comes
    lineno: the first lineno of the text in the file, where 0 would be
    the first line of the file...

    The text (source code) is first pre-processed:
    - convert all line-endings to \n
    - remove all empty lines at the end
    - remove commented lines at the end
    - convert tabs to spaces
    - dedent so minimal indentation is zero
    """

    # Convert tabs to spaces
    text = text.replace("\t"," "*4)

    # Make sure there is always *some* text
    if not text:
        text = ' '

    if lineno is None:
        lineno = 0
        cellName = fname  # run all

    # Examine the text line by line...
    # - check for empty/commented lined at the end
    # - calculate minimal indentation
    lines = text.splitlines()
    lastLineOfCode = 0
    minIndent = 99
    for linenr in range(len(lines)):
        # Get line
        line = lines[linenr]
        # Check if empty (can be commented, but nothing more)
        tmp = line.split("#",1)[0]  # get part before first #
        if tmp.count(" ") == len(tmp):
            continue  # empty line, proceed
        else:
            lastLineOfCode = linenr
        # Calculate indentation
        tmp = line.lstrip(" ")
        indent = len(line) - len(tmp)
        if indent &lt; minIndent:
            minIndent = indent

    # Copy all proper lines to a new list,
    # remove minimal indentation, but only if we then would only remove
    # spaces (in the case of commented lines)
    lines2 = []
    for linenr in range(lastLineOfCode+1):
        line = lines[linenr]
        # Remove indentation,
        if line[:minIndent].count(" ") == minIndent:
            line = line[minIndent:]
        else:
            line = line.lstrip(" ")
        lines2.append( line )

    # Ensure edit line is selected (to reset scrolling to end)
    self.ensureCursorAtEditLine()

    # Send message
    text = "\n".join(lines2)
    msg = {'source':text, 'fname':fname, 'lineno':lineno, 'cellName': cellName, 'changeDir': int(changeDir)}
    self._ctrl_code.send(msg)
</t>
<t tx="ekr.20190812072049.7">@property
def closed(self):
    return self._closed
</t>
<t tx="ekr.20190812072049.70">def sendBreakPoints(self, breaks):
    """ Send all breakpoints.
    """
    # breaks is a dict of filenames to integers
    self._stat_breakpoints.send(breaks)

## The polling methods and terminating methods
</t>
<t tx="ekr.20190812072049.71">def poll(self, channel=None):
    """ poll()
    To keep the shell up-to-date.
    Call this periodically.
    """

    if self._write_buffer:
        # There is still data in the buffer
        sub, M = self._write_buffer
    else:
        # Check what subchannel has the latest message pending
        sub = yoton.select_sub_channel(self._strm_out, self._strm_err,
                            self._strm_echo, self._strm_raw,
                            self._strm_broker, self._strm_prompt )
        # Read messages from it
        if sub:
            M = sub.recv_selected()
            #M = [sub.recv()] # Slow version (for testing)
            # Optimization: handle backspaces on stack of messages
            if sub is self._strm_out:
                M = self._handleCarriageReturnOnList(M)
                M = self._handleBackspacesOnList(M)
        # New prompt?
        if sub is self._strm_prompt:
            self.stateChanged.emit(self)

    # Write all pending messages that are later than any other message
    if sub:
        # Select messages to process
        N = 256
        M, buffer = M[:N], M[N:]
        # Buffer the rest
        if buffer:
            self._write_buffer = sub, buffer
        else:
            self._write_buffer = None
        # Get how to deal with prompt
        prompt = 0
        if sub is self._strm_echo:
            prompt = 1
        elif sub is self._strm_prompt:
            prompt = 2
        # Get color
        color = None
        if sub is self._strm_broker:
            color = '#000'
        elif sub is self._strm_raw:
            color = '#888888' # Halfway
        elif sub is self._strm_err:
            color = '#F00'
        # Write
        self.write(''.join(M), prompt, color)

    # Do any actions?
    action = self._strm_action.recv(False)
    if action:
        if action == 'cls':
            self.clearScreen()
        elif action.startswith('open '):
            parts = action.split(' ')
            parts.pop(0)
            try:
                linenr = int(parts[0])
                parts.pop(0)
            except ValueError:
                linenr = None
            fname = ' '.join(parts)
            editor = pyzo.editors.loadFile(fname)
            if editor and linenr:
                editor._editor.gotoLine(linenr)
        else:
            print('Unkown action: %s' % action)

    # ----- status

    # Do not update status when the kernel is not really up and running
    # self._version is set when the startup info is received
    if not self._version:
        return

    # Update status
    state = self._stat_interpreter.recv()
    if state != self._state:
        self._state = state
        self.stateChanged.emit(self)

    # Update debug status
    state = self._stat_debug.recv()
    if state != self._debugState:
        self._debugState = state
        self.debugStateChanged.emit(self)
</t>
<t tx="ekr.20190812072049.72">def interrupt(self):
    """ interrupt()
    Send a Keyboard interrupt signal to the main thread of the
    remote process.
    """
    # Ensure edit line is selected (to reset scrolling to end)
    self.ensureCursorAtEditLine()

    self._ctrl_broker.send('INT')
</t>
<t tx="ekr.20190812072049.73">def restart(self, scriptFile=None):
    """ restart(scriptFile=None)
    Terminate the shell, after which it is restarted.
    Args can be a filename, to execute as a script as soon as the
    shell is back up.
    """

    # Ensure edit line is selected (to reset scrolling to end)
    self.ensureCursorAtEditLine()

    # Get info
    info = finishKernelInfo(self._info, scriptFile)

    # Create message and send
    msg = 'RESTART\n' + ssdf.saves(info)
    self._ctrl_broker.send(msg)

    # Reset
    self.resetVariables()
</t>
<t tx="ekr.20190812072049.74">def terminate(self):
    """ terminate()
    Terminates the python process. It will first try gently, but
    if that does not work, the process shall be killed.
    To be notified of the termination, connect to the "terminated"
    signal of the shell.
    """
    # Ensure edit line is selected (to reset scrolling to end)
    self.ensureCursorAtEditLine()

    self._ctrl_broker.send('TERM')
</t>
<t tx="ekr.20190812072049.75">def closeShell(self): # do not call it close(); that is a reserved method.
    """ closeShell()

    Very simple. This closes the shell. If possible, we will first
    tell the broker to terminate the kernel.

    The broker will be cleaned up if there are no clients connected
    and if there is no active kernel. In a multi-user environment,
    we should thus be able to close the shell without killing the
    kernel. But in a closed 1-to-1 environment we really want to
    prevent loose brokers and kernels dangling around.

    In both cases however, it is the responsibility of the broker to
    terminate the kernel, and the shell will simply assume that this
    will work :)

    """

    # If we can, try to tell the broker to terminate the kernel
    if self._context and self._context.connection_count:
        self.terminate()
        self._context.flush() # Important, make sure the message is send!
        self._context.close()

    # Adios
    pyzo.shells.removeShell(self)
</t>
<t tx="ekr.20190812072049.76">def _onConnectionClose(self, c, why):
    """ To be called after disconnecting.
    In general, the broker will not close the connection, so it can
    be considered an error-state if this function is called.
    """

    # Stop context
    if self._context:
        self._context.close()

    # New (empty prompt)
    self._cursor1.movePosition(self._cursor1.End, A_MOVE)
    self._cursor2.movePosition(self._cursor2.End, A_MOVE)

    self.write('\n\n')
    self.write('Lost connection with broker:\n')
    self.write(why)
    self.write('\n\n')

    # Set style to indicate dead-ness
    self.setReadOnly(True)

    # Goto end such that the closing message is visible
    cursor = self.textCursor()
    cursor.movePosition(cursor.End, A_MOVE)
    self.setTextCursor(cursor)
    self.ensureCursorVisible()
</t>
<t tx="ekr.20190812072049.77">@path pyzo/core/
# -*- coding: utf-8 -*-

@others
@language python
@tabwidth -4
@nopyflakes
</t>
<t tx="ekr.20190812072049.78">try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo.core.shellInfoDialog.py')
except Exception:
    leo_g = None
""" Module shellInfoDialog

Implements shell configuration dialog.

"""

import os, sys
from pyzo.util.qt import QtCore, QtGui, QtWidgets  # noqa

import pyzo
from pyzo.core.pyzoLogging import print
from pyzo.core.kernelbroker import KernelInfo
from pyzo import translate

## Implement widgets that have a common interface
</t>
<t tx="ekr.20190812072049.79">class ShellInfoLineEdit(QtWidgets.QLineEdit):

    @others
</t>
<t tx="ekr.20190812072049.8">def close(self):
    self._closed = False
</t>
<t tx="ekr.20190812072049.80">def setTheText(self, value):
    self.setText(value)
</t>
<t tx="ekr.20190812072049.81">def getTheText(self):
    return self.text()
</t>
<t tx="ekr.20190812072049.82">class ShellInfo_name(ShellInfoLineEdit):

    @others
</t>
<t tx="ekr.20190812072049.83">def __init__(self, *args, **kwargs):
    ShellInfoLineEdit.__init__(self, *args, **kwargs)
    self.editingFinished.connect(self.onValueChanged)
    t = translate('shell', 'name ::: The name of this configuration.')
    self.setPlaceholderText(t.tt)
</t>
<t tx="ekr.20190812072049.84">def setTheText(self, value):
    ShellInfoLineEdit.setTheText(self, value)
    self.onValueChanged()
</t>
<t tx="ekr.20190812072049.85">def onValueChanged(self):
    self.parent().parent().parent().setTabTitle(self.getTheText())
</t>
<t tx="ekr.20190812072049.86">class ShellInfo_exe(QtWidgets.QComboBox):

    @others
</t>
<t tx="ekr.20190812072049.87">def __init__(self, *args):
    QtWidgets.QComboBox.__init__(self, *args)
</t>
<t tx="ekr.20190812072049.88">def _interpreterName(self, p):
    if p.is_conda:
        return '%s  [v%s, conda]' % (p.path, p.version)
    else:
        return '%s  [v%s]' % (p.path, p.version)
</t>
<t tx="ekr.20190812072049.89">def setTheText(self, value):

    # Init
    self.clear()
    self.setEditable(True)
    self.setInsertPolicy(self.InsertAtTop)

    # Get known interpreters from shellDialog (which are sorted by version)
    shellDialog = self
    while not isinstance(shellDialog, ShellInfoDialog):
        shellDialog = shellDialog.parent()
    interpreters = shellDialog.interpreters
    exes = [p.path for p in interpreters]

    # Hande current value
    if value in exes:
        value = self._interpreterName( interpreters[exes.index(value)] )
    else:
        self.addItem(value)

    # Add all found interpreters
    for p in interpreters:
        self.addItem(self._interpreterName(p))

    # Set current text
    self.setEditText(value)
</t>
<t tx="ekr.20190812072049.9">def flush(self):
    pass
</t>
<t tx="ekr.20190812072049.90">def getTheText(self):
    #return self.currentText().split('(')[0].rstrip()
    value = self.currentText()
    if value.endswith(']') and '[' in value:
        value = value.rsplit('[', 1)[0]
    return value.strip()
</t>
<t tx="ekr.20190812072049.91">class ShellInfo_ipython(QtWidgets.QCheckBox):

    @others
</t>
<t tx="ekr.20190812072049.92">def __init__(self, parent):
    QtWidgets.QCheckBox.__init__(self, parent)
    t = translate('shell', 'ipython ::: Use IPython shell if available.')
    self.setText(t.tt)
    self.setChecked(False)
</t>
<t tx="ekr.20190812072049.93">def setTheText(self, value):
    if value.lower() in ['', 'no', 'false']:  # Also for empty string; default is False
        self.setChecked(False)
    else:
        self.setChecked(True)
</t>
<t tx="ekr.20190812072049.94">def getTheText(self):
    if self.isChecked():
        return 'yes'
    else:
        return 'no'
</t>
<t tx="ekr.20190812072049.95">class ShellInfo_gui(QtWidgets.QComboBox):

    # For (backward) compatibility
    COMPAT = {'QT4':'PYQT4'}

    # GUI names
    GUIS = [    ('None', 'no GUI support'),
                ('Auto', 'Use what is available (recommended)'),
                ('Asyncio', 'Python\'s builtin event loop'),
                ('PyQt5', 'GPL/commercial licensed wrapper to Qt'),
                ('PyQt4', 'GPL/commercial licensed wrapper to Qt'),
                ('PySide', 'LGPL licensed wrapper to Qt'),
                ('PySide2', 'LGPL licensed wrapper to Qt5'),
                ('Tornado', 'Tornado asynchronous networking library'),
                ('Tk', 'Tk widget toolkit'),
                ('WX', 'wxPython'),
                ('FLTK', 'The fast light toolkit'),
                ('GTK', 'GIMP Toolkit'),
            ]

    # GUI descriptions

    @others
</t>
<t tx="ekr.20190812072049.96">def setTheText(self, value):

    # Process value
    value = value.upper()
    value = self.COMPAT.get(value, value)

    # Set options
    ii = 0
    self.clear()
    for i in range(len(self.GUIS)):
        gui, des = self.GUIS[i]
        if value == gui.upper():
            ii = i
        self.addItem('%s  -  %s' % (gui, des))

    # Set current text
    self.setCurrentIndex(ii)
</t>
<t tx="ekr.20190812072049.97">def getTheText(self):
    text = self.currentText().lower()
    return text.partition('-')[0].strip()
</t>
<t tx="ekr.20190812072049.98">class ShellinfoWithSystemDefault(QtWidgets.QVBoxLayout):

    DISABLE_SYSTEM_DEFAULT = sys.platform == 'darwin'
    SYSTEM_VALUE = ''

    @others
</t>
<t tx="ekr.20190812072049.99">def __init__(self, parent, widget):
    # Do not pass parent, because is a sublayout
    QtWidgets.QVBoxLayout.__init__(self)

    # Layout
    self.setSpacing(1)
    self.addWidget(widget)

    # Create checkbox widget
    if not self.DISABLE_SYSTEM_DEFAULT:
        t = translate('shell', 'Use system default')
        self._check = QtWidgets.QCheckBox(t, parent)
        self._check.stateChanged.connect(self.onCheckChanged)
        self.addWidget(self._check)

    # The actual value of this shell config attribute
    self._value = ''

    # A buffered version, so that clicking the text box does not
    # remove the value at once
    self._bufferedValue = ''
</t>
<t tx="ekr.20190812072050.1">@path pyzo/tools/pyzoFileBrowser/
# -*- coding: utf-8 -*-
# Copyright (C) 2013 Almar Klein
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.10">def __repr__(self):
    return '&lt;{} "{}"&gt;'.format(self.__class__.__name__, self._path)
</t>
<t tx="ekr.20190812072050.100">def onActivated(self):
    self.treeWidget().setPath(self.path())
</t>
<t tx="ekr.20190812072050.101">class DirItem(BrowserItem):
    """ Tree widget item for directories.
    """

    @others
</t>
<t tx="ekr.20190812072050.102">def __init__(self, parent, pathProxy, starred=False):
    self._starred = starred
    BrowserItem.__init__(self, parent, pathProxy)

    # Create dummy item so that the dir is expandable
    self._createDummyItem('Loading contents ...')
</t>
<t tx="ekr.20190812072050.103">def setFileIcon(self):
    # Use folder icon
    icon = iconprovider.icon(iconprovider.Folder)
    overlays = []
    if self._starred:
        overlays.append(pyzo.icons.bullet_yellow)
    icon = addIconOverlays(icon, *overlays, offset=(8,0), overlay_offset=(-4,0))
    self.setIcon(0, icon)
</t>
<t tx="ekr.20190812072050.104">def onActivated(self):
    self.treeWidget().setPath(self.path())
</t>
<t tx="ekr.20190812072050.105">def onExpanded(self):
    # Update list of expanded dirs
    expandedDirs = self.treeWidget().parent().expandedDirs
    p = op.normcase(self.path())  # Normalize case!
    if p not in expandedDirs:
        expandedDirs.append(p)
    # Keep track of changes in our contents
    self._proxy.track()
    self._proxy.push()
</t>
<t tx="ekr.20190812072050.106">def onCollapsed(self):
    # Update list of expanded dirs
    expandedDirs = self.treeWidget().parent().expandedDirs
    p = op.normcase(self.path())   # Normalize case!
    while p in expandedDirs:
        expandedDirs.remove(p)
    # Stop tracking changes in our contents
    self._proxy.cancel()
    # Clear contents and create a single placeholder item
    self.clear()
    self._createDummyItem('Loading contents ...')

# No need to implement onDeleted: the parent will get a changed event.
</t>
<t tx="ekr.20190812072050.107">def onChanged(self):
    """ Called when a change in the contents has occured, or when
    we just activated the proxy. Update our items!
    """
    if not self.isExpanded():
        return
    tree = self.treeWidget()
    tree.createItems(self)
</t>
<t tx="ekr.20190812072050.108">class FileItem(BrowserItem):
    """ Tree widget item for files.
    """

    @others
</t>
<t tx="ekr.20190812072050.109">def __init__(self, parent, pathProxy, mode='normal'):
    BrowserItem.__init__(self, parent, pathProxy)
    self._mode = mode
    self._timeSinceLastDocString = 0

    if self._mode=='normal' and self.path().lower().endswith('.py'):
        self._createDummyItem('Loading high level structure ...')
</t>
<t tx="ekr.20190812072050.11">def path(self):
    """ Get the path of this proxy.
    """
    return self._path
</t>
<t tx="ekr.20190812072050.110">def setFileIcon(self):
    # Create dummy file in pyzo user dir
    dummy_filename = op.join(cleanpath(pyzo.appDataDir), 'dummyFiles', 'dummy' + ext(self.path()))
    # Create file?
    if not op.isfile(dummy_filename):
        if not isdir(op.dirname(dummy_filename)):
            os.makedirs(op.dirname(dummy_filename))
        f = open(dummy_filename, 'wb')
        f.close()
    # Use that file
    if sys.platform.startswith('linux') and \
                                not QtCore.__file__.startswith('/usr/'):
        icon = iconprovider.icon(iconprovider.File)
    else:
        icon = iconprovider.icon(QtCore.QFileInfo(dummy_filename))
    icon = addIconOverlays(icon)
    self.setIcon(0, icon)
</t>
<t tx="ekr.20190812072050.111">def searchContents(self, needle, **kwargs):
    self.setHidden(True)
    self._proxy.setSearch(needle, **kwargs)
</t>
<t tx="ekr.20190812072050.112">def onActivated(self):
    # todo: someday we should be able to simply pass the proxy object to the editors
    # so that we can open files on any file system
    path = self.path()
    leo_g.trace(path)
    if ext(path) not in ['.pyc','.pyo','.png','.jpg','.ico']:
        if pyzo.editors: # EKR:change.
            # Load file
            pyzo.editors.loadFile(path)
            # Give focus
            pyzo.editors.getCurrentEditor().setFocus()
</t>
<t tx="ekr.20190812072050.113">def onExpanded(self):
    if self._mode == 'normal':
        # Create task to retrieve high level structure
        if self.path().lower().endswith('.py'):
            self._proxy.pushTask(tasks.DocstringTask())
            self._proxy.pushTask(tasks.PeekTask())
</t>
<t tx="ekr.20190812072050.114">def onCollapsed(self):
    if self._mode == 'normal':
        self.clear()
        if self.path().lower().endswith('.py'):
            self._createDummyItem('Loading high level structure ...')

#     def onClicked(self):
#         # Limit sending events to prevent flicker when double clicking
#         if time.time() - self._timeSinceLastDocString &lt; 0.5:
#             return
#         self._timeSinceLastDocString = time.time()
#         # Create task
#         if self.path().lower().endswith('.py'):
#             self._proxy.pushTask(tasks.DocstringTask())
</t>
<t tx="ekr.20190812072050.115">def onChanged(self):
    pass
</t>
<t tx="ekr.20190812072050.116">def onTaskFinished(self, task):

    if isinstance(task, tasks.DocstringTask):
        result = task.result()
        self.clear()  # Docstring task is done *before* peek task
        if result:
            DocstringItem(self, result)
#         if isinstance(task, tasks.DocstringTask):
#             result = task.result()
#             if result:
#                 #self.setToolTip(0, result)
#                 # Show tooltip *now* if mouse is still over this item
#                 tree = self.treeWidget()
#                 pos = tree.mapFromGlobal(QtGui.QCursor.pos())
#                 if tree.itemAt(pos) is self:
#                     QtWidgets.QToolTip.showText(QtGui.QCursor.pos(), result)
    elif isinstance(task, tasks.PeekTask):
        result = task.result()
        #self.clear()  # Cleared when docstring task result is received
        if result:
            for r in result:
                SubFileItem(self, *r)
        else:
            self._createDummyItem('No classes or functions found.')
    else:
        BrowserItem.onTaskFinished(self, task)
</t>
<t tx="ekr.20190812072050.117">class SubFileItem(QtWidgets.QTreeWidgetItem):
    """ Tree widget item for search items.
    """
    @others
</t>
<t tx="ekr.20190812072050.118">def __init__(self, parent, linenr, text, showlinenr=False):
    QtWidgets.QTreeWidgetItem.__init__(self, parent)
    self._linenr = linenr
    if showlinenr:
        self.setText(0, 'Line %i: %s' % (linenr, text))
    else:
        self.setText(0, text)
</t>
<t tx="ekr.20190812072050.119">def path(self):
    return self.parent().path()
</t>
<t tx="ekr.20190812072050.12">def track(self):
    """ Start tracking this proxy object in the idle time of the
    FSProxy thread.
    """
    self._fsProxy._track(self)
</t>
<t tx="ekr.20190812072050.120">def onActivated(self):
    path = self.path()
    if ext(path) not in ['.pyc','.pyo','.png','.jpg','.ico']:
        # Load and get editor
        fileItem = pyzo.editors.loadFile(path)
        editor = fileItem._editor
        # Goto line
        editor.gotoLine(self._linenr)
        # Give focus
        pyzo.editors.getCurrentEditor().setFocus()
</t>
<t tx="ekr.20190812072050.121">class DocstringItem(QtWidgets.QTreeWidgetItem):
    """ Tree widget item for docstring placeholder items.
    """

    @others
</t>
<t tx="ekr.20190812072050.122">def __init__(self, parent, docstring):
    QtWidgets.QTreeWidgetItem.__init__(self, parent)
    self._docstring = docstring
    # Get one-line version of docstring
    shortText = self._docstring.split('\n',1)[0].strip()
    if len(shortText) &lt; len(self._docstring):
        shortText += '...'
    # Set short version now
    self.setText(0, 'doc: '+shortText)
    # Long version is the tooltip
    self.setToolTip(0, docstring)
</t>
<t tx="ekr.20190812072050.123">def path(self):
    return self.parent().path()
</t>
<t tx="ekr.20190812072050.124">def onClicked(self):
    tree = self.treeWidget()
    pos = tree.mapFromGlobal(QtGui.QCursor.pos())
    if tree.itemAt(pos) is self:
        QtWidgets.QToolTip.showText(QtGui.QCursor.pos(), self._docstring)
</t>
<t tx="ekr.20190812072050.125">class ErrorItem(QtWidgets.QTreeWidgetItem):
    """ Tree widget item for errors and information.
    """
    @others
</t>
<t tx="ekr.20190812072050.126">def __init__(self, parent, info):
    QtWidgets.QTreeWidgetItem.__init__(self, parent)
    self.setText(0, info)
    self.setFlags(QtCore.Qt.NoItemFlags)
    font = self.font(0)
    font.setItalic(True)
    self.setFont(0, font)
</t>
<t tx="ekr.20190812072050.127">class SearchInfoItem(ErrorItem):
    """ Tree widget item that displays info on the search.
    """
    @others
</t>
<t tx="ekr.20190812072050.128">def __init__(self, parent):
    ErrorItem.__init__(self, parent, 'Searching ...')
    self._totalCount = 0
    self._checkCount = 0
    self._hitCount = 0
</t>
<t tx="ekr.20190812072050.129">def increaseTotal(self, c):
    self._totalCount += c
    self.updateCounts()
</t>
<t tx="ekr.20190812072050.13">def push(self):
    """ Process this proxy object asap; the object is put in the queue
    of the FSProxy, so it is updated as fast as possible.
    """
    self._cancelled = False
    self._fsProxy._push(self)
</t>
<t tx="ekr.20190812072050.130">def addFile(self, hit):
    self._checkCount += 1
    if hit:
        self._hitCount += 1
    # Update appearance
    self.updateCounts()
</t>
<t tx="ekr.20190812072050.131">def updateCounts(self):
    counts = self._checkCount, self._totalCount, self._hitCount
    self.setText(0, 'Searched {}/{} files: {} hits'.format(*counts))
</t>
<t tx="ekr.20190812072050.132">class TemporaryDirItem:
    """ Created when searching. This object posts a requests for its contents
    which are then processed, after which this object disbands itself.
    """
    __slots__ = ['_tree', '_proxy', '__weakref__']

    @others
</t>
<t tx="ekr.20190812072050.133">def __init__(self, tree, pathProxy):
    self._tree = tree
    self._proxy = pathProxy
    self._proxy.changed.connect(self.onChanged)
    # Process asap, but do not track
    self._proxy.push()
    # Store ourself
    tree._temporaryItems.add(self)
</t>
<t tx="ekr.20190812072050.134">def clear(self):
    pass  # tree.createItems() calls this ...
</t>
<t tx="ekr.20190812072050.135">def onChanged(self):
    # Disband
    self._tree._temporaryItems.discard(self)
    # Process contents
    self._tree.createItems(self)
</t>
<t tx="ekr.20190812072050.136">class TemporaryFileItem:
    """ Created when searching. This object posts a requests to search
    its contents which are then processed, after which this object
    disbands itself, passing the proxy object to a real FileItem if the
    search had results.
    """
    __slots__ = ['_tree', '_proxy', '__weakref__']

    @others
</t>
<t tx="ekr.20190812072050.137">def __init__(self, tree, pathProxy):
    self._tree = tree
    self._proxy = pathProxy
    self._proxy.taskFinished.connect(self.onSearchResult)
    # Store ourself
    tree._temporaryItems.add(self)
</t>
<t tx="ekr.20190812072050.138">def search(self, searchFilter):
    self._proxy.pushTask(tasks.SearchTask(**searchFilter))
</t>
<t tx="ekr.20190812072050.139">def onSearchResult(self, task):
    # Disband now
    self._tree._temporaryItems.discard(self)

    # Get result. May raise an error
    result = task.result()
    # Process contents
    if result:
        item = FileItem(self._tree, self._proxy, 'search')  # Search mode
        for r in result:
            SubFileItem(item, *r, showlinenr=True)
    # Update counter
    searchInfoItem = self._tree.topLevelItem(0)
    if isinstance(searchInfoItem, SearchInfoItem):
        searchInfoItem.addFile(bool(result))
</t>
<t tx="ekr.20190812072050.14">def cancel(self):
    """ Stop tracking this proxy object. Cancel processing if this
    object was in the queue.
    """
    self._fsProxy._unTrack(self)
    self._cancelled = True
</t>
<t tx="ekr.20190812072050.140">class Tree(QtWidgets.QTreeWidget):
    """ Representation of the tree view.
    Instances of this class are responsible for keeping the contents
    up-to-date. The Item classes above are dumb objects.
    """

    dirChanged = QtCore.Signal(str) # Emitted when user goes into a subdir

    @others
</t>
<t tx="ekr.20190812072050.141">def __init__(self, parent):
    QtWidgets.QTreeWidget.__init__(self, parent)

    # Initialize
    self.setMinimumWidth(150)
    self.setMinimumHeight(150)
    #
    self.setColumnCount(1)
    self.setHeaderHidden(True)
    self.setIconSize(QtCore.QSize(24,16))

    # Connecy signals
    self.itemExpanded.connect(self.onItemExpanded)
    self.itemCollapsed.connect(self.onItemCollapsed)
    self.itemClicked.connect(self.onItemClicked)
    self.itemActivated.connect(self.onItemActivated)

    # Variables for restoring the view after updating
    self._selectedPath = '' # To restore a selection after updating
    self._selectedScrolling = 0

    # Set of temporary items
    self._temporaryItems = set()

    # Define context menu
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.contextMenuTriggered)

    # Initialize proxy (this is where the path is stored)
    self._proxy = None
</t>
<t tx="ekr.20190812072050.142">def path(self):
    """ Get the current path shown by the treeview.
    """
    return self._proxy.path()
</t>
<t tx="ekr.20190812072050.143">def setPath(self, path):
    """ Set the current path shown by the treeview.
    """
    # Close old proxy
    if self._proxy is not None:
        self._proxy.cancel()
        self._proxy.changed.disconnect(self.onChanged)
        self._proxy.deleted.disconnect(self.onDeleted)
        self._proxy.errored.disconnect(self.onErrored)
        self.destroyed.disconnect(self._proxy.cancel)
    # Create new proxy
    if True:
        self._proxy = self.parent()._fsProxy.dir(path)
        self._proxy.changed.connect(self.onChanged)
        self._proxy.deleted.connect(self.onDeleted)
        self._proxy.errored.connect(self.onErrored)
        self.destroyed.connect(self._proxy.cancel)
    # Activate the proxy, we'll get a call at onChanged() asap.
    if path.lower() == MOUNTS.lower():
        self.clear()
        createMounts(self.parent(), self)
    else:
        self._proxy.track()
        self._proxy.push()
    # Store dir in config
    self.parent().config.path = path
    # Signal that the dir has changed
    # Note that our contents may not be visible yet.
    self.dirChanged.emit(self.path())
</t>
<t tx="ekr.20190812072050.144">def setPathUp(self):
    """ Go one directory up.
    """
    newPath = op.dirname(self.path())

    if op.normcase(newPath) == op.normcase(self.path()):
        self.setPath(cleanpath(MOUNTS))
    else:
        self.setPath(newPath)
</t>
<t tx="ekr.20190812072050.145">def clear(self):
    """ Overload the clear method to remove the items in a nice
    way, alowing the pathProxy instance to be closed correctly.
    """
    # Clear temporary (invisible) items
    for item in self._temporaryItems:
        item._proxy.cancel()
    self._temporaryItems.clear()
    # Clear visible items
    for i in reversed(range(self.topLevelItemCount())):
        item = self.topLevelItem(i)
        if hasattr(item, 'clear'):
            item.clear()
        if hasattr(item, 'onDestroyed'):
            item.onDestroyed()
    QtWidgets.QTreeWidget.clear(self)
</t>
<t tx="ekr.20190812072050.146">def mouseDoubleClickEvent(self, event):
    """ Bypass expanding an item when double-cliking it.
    Only activate the item.
    """
    item = self.itemAt(event.x(), event.y())
    if item is not None:
        self.onItemActivated(item)
</t>
<t tx="ekr.20190812072050.147">def onChanged(self):
    """ Called when our contents change or when we just changed directories.
    """
    self.createItems(self)
</t>
<t tx="ekr.20190812072050.148">def createItems(self, parent):
    """ High level method to create the items of the tree or a DirItem.
    This method will handle the restoring of state etc.
    The actual filtering of entries and creation of tree widget items
    is done in the createItemsFun() function.
    """
    # Store state and clear
    self._storeSelectionState()
    parent.clear()
    # Create sub items
    count = createItemsFun(self.parent(), parent)
    if not count and isinstance(parent, QtWidgets.QTreeWidgetItem):
        ErrorItem(parent, 'Empty directory')
    # Restore state
    self._restoreSelectionState()
</t>
<t tx="ekr.20190812072050.149">def onErrored(self, err='...'):
    self.clear()
    ErrorItem(self, 'Error: ' + err)
</t>
<t tx="ekr.20190812072050.15">def pushTask(self, task):
    """ pushTask(task)
    Give a task to the proxy to be executed in the FSProxy
    thread. The taskFinished signal will be emitted with the given
    task when it is done.
    """
    shouldPush = False
    with self._lock:
        if not self._pendingTasks:
            shouldPush = True
        self._pendingTasks.append(task)
    if shouldPush:
        self.push()
</t>
<t tx="ekr.20190812072050.150">def onDeleted(self):
    self.setPathUp()
</t>
<t tx="ekr.20190812072050.151">def onItemExpanded(self, item):
    if hasattr(item, 'onExpanded'):
        item.onExpanded()
</t>
<t tx="ekr.20190812072050.152">def onItemCollapsed(self, item):
    if hasattr(item, 'onCollapsed'):
        item.onCollapsed()
</t>
<t tx="ekr.20190812072050.153">def onItemClicked(self, item):
    if hasattr(item, 'onClicked'):
        item.onClicked()
</t>
<t tx="ekr.20190812072050.154">def onItemActivated(self, item):
    """ When an item is "activated", make that the new directory,
    or open that file.
    """
    if hasattr(item, 'onActivated'):
        item.onActivated()
</t>
<t tx="ekr.20190812072050.155">def _storeSelectionState(self):
    # Store selection
    items = self.selectedItems()
    self._selectedPath = items[0].path() if items else ''
    # Store scrolling
    self._selectedScrolling = self.verticalScrollBar().value()
</t>
<t tx="ekr.20190812072050.156">def _restoreSelectionState(self):
    # First select the first item
    # (otherwise the scrolling wont work for some reason)
    if self.topLevelItemCount():
        self.setCurrentItem(self.topLevelItem(0))
    # Restore selection
    if self._selectedPath:
        items = self.findItems(op.basename(self._selectedPath), QtCore.Qt.MatchExactly, 0)
        items = [item for item in items if op.normcase(item.path()) == op.normcase(self._selectedPath)]
        if items:
            self.setCurrentItem(items[0])
    # Restore scrolling
    self.verticalScrollBar().setValue(self._selectedScrolling)
    self.verticalScrollBar().setValue(self._selectedScrolling)
</t>
<t tx="ekr.20190812072050.157">def contextMenuTriggered(self, p):
    """ Called when context menu is clicked """
    # Get item that was clicked on
    item = self.itemAt(p)
    if item is None:
        item = self

    # Create and show menu
    if isinstance(item, (Tree, FileItem, DirItem)):
        menu = PopupMenu(self, item)
        menu.popup(self.mapToGlobal(p+QtCore.QPoint(3,3)))
</t>
<t tx="ekr.20190812072050.158">class PopupMenu(pyzo.core.menu.Menu):
    @others
</t>
<t tx="ekr.20190812072050.159">def __init__(self, parent, item):
    self._item = item
    pyzo.core.menu.Menu.__init__(self, parent, " ")
</t>
<t tx="ekr.20190812072050.16">def _processTasks(self):
    # Get pending tasks
    with self._lock:
        pendingTasks = self._pendingTasks
        self._pendingTasks = []
    # Process pending tasks
    finishedTasks = []
    for task in pendingTasks:
        task._run(self)
        finishedTasks.append(task)
    # Emit signal if there are finished tasks
    for task in finishedTasks:
        self.taskFinished.emit(task)
</t>
<t tx="ekr.20190812072050.160">def build(self):

    isplat = sys.platform.startswith

    # The star object
    if isinstance(self._item, DirItem):
        if self._item._starred:
            self.addItem(translate("filebrowser", "Unstar this directory"), None, self._star)
        else:
            self.addItem(translate("filebrowser", "Star this directory"), None, self._star)
        self.addSeparator()

    # The pyzo related functions
    if isinstance(self._item, FileItem):
        self.addItem(translate("filebrowser", "Open"), None, self._item.onActivated)
        if self._item.path().endswith('.py'):
            self.addItem(translate("filebrowser", "Run as script"),
                None, self._runAsScript)
        elif self._item.path().endswith('.ipynb'):
            self.addItem(translate("filebrowser", "Run Jupyter notebook"),
                None, self._runNotebook)
        else:
            self.addItem(translate("filebrowser", "Import data..."),
                None, self._importData)
        self.addSeparator()

    # Create items for open and copy path
    if isinstance(self._item, (FileItem, DirItem)):
        if isplat('win') or isplat('darwin') or isplat('linux'):
            self.addItem(translate("filebrowser", "Open outside Pyzo"),
                None, self._openOutsidePyzo)
        if isplat('darwin'):
            self.addItem(translate("filebrowser", "Reveal in Finder"),
                None, self._showInFinder)
        if True:
            self.addItem(translate("filebrowser", "Copy path"),
                None, self._copyPath)
        self.addSeparator()

    # Create items for file management
    if isinstance(self._item, FileItem):
        self.addItem(translate("filebrowser", "Rename"), None, self.onRename)
        self.addItem(translate("filebrowser", "Delete"), None, self.onDelete)
        #self.addItem(translate("filebrowser", "Duplicate"), None, self.onDuplicate)
    if isinstance(self._item, (Tree, DirItem)):
        self.addItem(translate("filebrowser", "Create new file"), None, self.onCreateFile)
        self.addItem(translate("filebrowser", "Create new directory"), None, self.onCreateDir)
    if isinstance(self._item, DirItem):
        self.addSeparator()
        self.addItem(translate("filebrowser", "Rename"), None, self.onRename)
        self.addItem(translate("filebrowser", "Delete"), None, self.onDelete)
</t>
<t tx="ekr.20190812072050.161">def _star(self):
    # Prepare
    browser = self.parent().parent()
    path = self._item.path()
    if self._item._starred:
        browser.removeStarredDir(path)
    else:
        browser.addStarredDir(path)
    # Refresh
    self.parent().setPath(self.parent().path())
</t>
<t tx="ekr.20190812072050.162">def _openOutsidePyzo(self):
    path = self._item.path()
    if sys.platform.startswith('darwin'):
        subprocess.call(('open', path))
    elif sys.platform.startswith('win'):
        if ' ' in path:  # http://stackoverflow.com/a/72796/2271927
            subprocess.call(('start', '', path), shell=True)
        else:
            subprocess.call(('start', path), shell=True)
    elif sys.platform.startswith('linux'):
        # xdg-open is available on all Freedesktop.org compliant distros
        # http://superuser.com/questions/38984/linux-equivalent-command-for-open-command-on-mac-windows
        subprocess.call(('xdg-open', path))
</t>
<t tx="ekr.20190812072050.163">def _showInFinder(self):
    subprocess.call(('open', '-R', self._item.path()))
</t>
<t tx="ekr.20190812072050.164">def _copyPath(self):
    QtWidgets.qApp.clipboard().setText(self._item.path())
</t>
<t tx="ekr.20190812072050.165">def _runAsScript(self):
    filename = self._item.path()
    shell = pyzo.shells.getCurrentShell()
    if shell is not None:
        shell.restart(filename)
    else:
        msg = "No shell to run code in. "
        m = QtWidgets.QMessageBox(self)
        m.setWindowTitle(translate("menu dialog", "Could not run"))
        m.setText("Could not run " + filename + ":\n\n" + msg)
        m.setIcon(m.Warning)
        m.exec_()
</t>
<t tx="ekr.20190812072050.166">def _runNotebook(self):
    filename = self._item.path()
    shell = pyzo.shells.getCurrentShell()
    if shell is not None:
        shell.restart(filename)
    else:
        msg = "No shell to run notebook in. "
        m = QtWidgets.QMessageBox(self)
        m.setWindowTitle(translate("menu dialog", "Could not run notebook"))
        m.setText("Could not run " + filename + ":\n\n" + msg)
        m.setIcon(m.Warning)
        m.exec_()
</t>
<t tx="ekr.20190812072050.167">def _importData(self):
    browser = self.parent().parent()
    wizard = browser.getImportWizard()
    wizard.open(self._item.path())
</t>
<t tx="ekr.20190812072050.168">def onDuplicate(self):
    return self._duplicateOrRename(False)
</t>
<t tx="ekr.20190812072050.169">def onRename(self):
    return self._duplicateOrRename(True)
</t>
<t tx="ekr.20190812072050.17">class DirProxy(PathProxy):
    """ Proxy object for a directory. Obtain an instance of this class
    using filesystemProx.dir()
    """

    @others
</t>
<t tx="ekr.20190812072050.170">def onCreateFile(self):
    self._createDirOrFile(True)
</t>
<t tx="ekr.20190812072050.171">def onCreateDir(self):
    self._createDirOrFile(False)
</t>
<t tx="ekr.20190812072050.172">def _createDirOrFile(self, file=True):

    # Get title and label
    if file:
        title = translate("filebrowser", "Create new file")
        label = translate("filebrowser", "Give the new name for the file")
    else:
        title = translate("filebrowser", "Create new directory")
        label = translate("filebrowser", "Give the name for the new directory")

    # Ask for new filename
    s = QtWidgets.QInputDialog.getText(self.parent(), title,
                label + ':\n%s' % self._item.path(),
                QtWidgets.QLineEdit.Normal,
                'new name'
            )
    if isinstance(s, tuple):
        s = s[0] if s[1] else ''

    # Push rename task
    if s:
        newpath = op.join(self._item.path(), s)
        task = tasks.CreateTask(newpath=newpath, file=file)
        self._item._proxy.pushTask(task)
</t>
<t tx="ekr.20190812072050.173">def _duplicateOrRename(self, rename):

    # Get dirname and filename
    dirname, filename = op.split(self._item.path())

    # Get title and label
    if rename:
        title = translate("filebrowser", "Rename")
        label = translate("filebrowser", "Give the new name for the file")
    else:
        title = translate("filebrowser", "Duplicate")
        label = translate("filebrowser", "Give the name for the new file")
        filename = 'Copy of ' + filename

    # Ask for new filename
    s = QtWidgets.QInputDialog.getText(self.parent(), title,
                label + ':\n%s' % self._item.path(),
                QtWidgets.QLineEdit.Normal,
                filename
            )
    if isinstance(s, tuple):
        s = s[0] if s[1] else ''

    # Push rename task
    if s:
        newpath = op.join(dirname, s)
        task = tasks.RenameTask(newpath=newpath, removeold=rename)
        self._item._proxy.pushTask(task)
</t>
<t tx="ekr.20190812072050.174">def onDelete(self):
    # Ask for new filename
    b = QtWidgets.QMessageBox.question(self.parent(),
                translate("filebrowser", "Delete"),
                translate("filebrowser", "Are you sure that you want to delete") +
                ':\n%s' % self._item.path(),
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel,
            )
    # Push delete task
    if b == QtWidgets.QMessageBox.Yes:
        self._item._proxy.pushTask(tasks.RemoveTask())
</t>
<t tx="ekr.20190812072050.175">@path pyzo/tools/pyzoFileBrowser/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.176">import os
import ctypes
import sys
import string
import os.path as op
</t>
<t tx="ekr.20190812072050.177">def cleanpath(p):
    return op.normpath(op.expanduser(op.expandvars(p)))
</t>
<t tx="ekr.20190812072050.178">def isdir(p):
    # Add os.sep, because trailing spaces seem to be ignored on Windows
    return op.isdir(p + op.sep)
</t>
<t tx="ekr.20190812072050.179">def ext(p):
    return os.path.splitext(p)[1]
# todo: also include available remote file systems
</t>
<t tx="ekr.20190812072050.18">def __init__(self, *args):
    PathProxy.__init__(self, *args)
    self._dirs = set()
    self._files = set()
</t>
<t tx="ekr.20190812072050.180">def getMounts():
    if sys.platform.startswith('win'):
        return getDrivesWin()
    elif sys.platform.startswith('darwin'):
        return '/'
    elif sys.platform.startswith('linux'):
        return ['/'] + [op.join('/media', e) for e in os.listdir('/media')]
    else:
        return '/'
</t>
<t tx="ekr.20190812072050.181">def getDrivesWin():
    drives = []
    bitmask = ctypes.windll.kernel32.GetLogicalDrives()
    for letter in string.ascii_uppercase:
        if bitmask &amp; 1:
            drives.append(letter)
        bitmask &gt;&gt;= 1
    return [drive+':\\' for drive in drives]
</t>
<t tx="ekr.20190812072050.182">def hasHiddenAttribute(path):
    """ Test (on Windows) whether a file should be hidden.
    """
    if not sys.platform.startswith('win'):
        return False
    try:
        attrs = ctypes.windll.kernel32.GetFileAttributesW(path)
        assert attrs != -1
        return bool(attrs &amp; 2)
    except (AttributeError, AssertionError):
        return False
</t>
<t tx="ekr.20190812072050.183">@path pyzo/tools/pyzoFileBrowser/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.184"># -*- coding: utf-8 -*-
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('IMPORT pyzo.tools.pyzoFileBrowser')
except Exception:
    leo_g = None

from pyzo import translate
tool_name = translate("pyzoFileBrowser","File Browser")
tool_summary = "Browse the files in your projects."
""" File browser tool

A powerfull tool for managing your projects in a lightweight manner.
It has a few file management utilities as well.

Config
======

The config consists of three fields:

  * list expandedDirs, with each element a directory
  * list starredDirs, with each element a dict with fields:
      * str path, the directory that is starred
      * str name, the name of the project (op.basename(path) by default)
      * bool addToPythonpath
  * searchMatchCase, searchRegExp, searchSubDirs
  * nameFilter

"""

# todo: List!
"""
  * see easily which files are opened (so it can be used as a secondary tab bar)
  * make visible the "current file" (if applicable)
  * single click on an file that is open selects it in the editor?
  * context menu items to run scripts
  * Support for multiple browsers.

"""
import os.path as op

import pyzo
assert pyzo
from pyzo.util import zon as ssdf
from pyzo.util.qt import QtCore, QtGui, QtWidgets  # noqa
assert QtCore and QtGui and QtWidgets

from .browser import Browser
from .utils import cleanpath, isdir

</t>
<t tx="ekr.20190812072050.185">class PyzoFileBrowser(QtWidgets.QWidget):
    """ The main tool widget. An instance of this class contains one or
    more Browser instances. If there are more, they can be selected
    using a tab bar.
    """

    @others
</t>
<t tx="ekr.20190812072050.186">def __init__(self, parent):
    QtWidgets.QWidget.__init__(self, parent)

    # Get config
    # EKR:change-tool
    self.config = ssdf.new()
    ### Probably don't need or want this:
        # toolId =  self.__class__.__name__.lower() + '2'  # This is v2 of the file browser
        # if toolId not in pyzo.config.tools:
            # pyzo.config.tools[toolId] = ssdf.new()
        # self.config = pyzo.config.tools[toolId]

    # Ensure three main attributes in config
    for name in ['expandedDirs', 'starredDirs']:
        if name not in self.config:
            self.config[name] = []

    # Ensure path in config
    # if leo_g: leo_g.pr('PyzoFileBrowser.__init__', self.config.__class__)
    if 'path' not in self.config or not isdir(self.config.path):
        self.config.path = op.expanduser('~')

    # Check expandedDirs and starredDirs.
    # Make path objects and remove invalid dirs. Also normalize case,
    # should not be necessary, but maybe the config was manually edited.
    expandedDirs, starredDirs = [], []
    for d in self.config.starredDirs:
        if 'path' in d and 'name' in d and 'addToPythonpath' in d:
            if isdir(d.path):
                d.path = op.normcase(cleanpath(d.path))
                starredDirs.append(d)
    for p in set([str(p) for p in self.config.expandedDirs]):
        if isdir(p):
            p = op.normcase(cleanpath(p))
            # Add if it is a subdir of a starred dir
            for d in starredDirs:
                if p.startswith(d.path):
                    expandedDirs.append(p)
                    break
    self.config.expandedDirs, self.config.starredDirs = expandedDirs, starredDirs

    # Create browser(s).
    self._browsers = []
    for i in [0]:
        self._browsers.append( Browser(self, self.config) )

    # Layout
    layout = QtWidgets.QVBoxLayout(self)
    self.setLayout(layout)
    layout.addWidget(self._browsers[0])
    layout.setSpacing(0)
    layout.setContentsMargins(4,4,4,4)
</t>
<t tx="ekr.20190812072050.187">def path(self):
    """ Get the current path shown by the file browser.
    """
    browser = self._browsers[0]
    return browser._tree.path()
</t>
<t tx="ekr.20190812072050.188">def setPath(self, path):
    """ Set the shown path.
    """
    browser = self._browsers[0]
    browser._tree.setPath(path)
</t>
<t tx="ekr.20190812072050.189">def getAddToPythonPath(self):
    """
    Returns the path to be added to the Python path when starting a shell
    If a project is selected, which has the addToPath checkbox selected,
    returns the path of the project. Otherwise, returns None
    """
    # Select browser
    browser = self._browsers[0]
    # Select active project
    d = browser.currentProject()
    if d and d.addToPythonpath:
        return d.path
    return None
</t>
<t tx="ekr.20190812072050.19">def dirs(self):
    with self._lock:
        return set(self._dirs)
</t>
<t tx="ekr.20190812072050.190">def getDefaultSavePath(self):
    """
    Returns the path to be used as default when saving a new file in pyzo.
    Or None if the no path could be determined
    """
    # Select current browser
    browser = self._browsers[0]
    # Select its path
    path = browser._tree.path()
    # Return
    if op.isabs(path) and isdir(path):
        return path
</t>
<t tx="ekr.20190812072050.191">def closeEvent(self, event):
    # Close all browsers so they can clean up the file system proxies
    for browser in self._browsers:
        browser.close()
    return QtWidgets.QWidget.closeEvent(self, event)
</t>
<t tx="ekr.20190812072050.193"></t>
<t tx="ekr.20190812072050.194">@path pyzo/util/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.195">"""
Tools to install miniconda from pyzo and register that env in pyzo's
shell config.
"""

import os
import sys
import stat
import time
import struct
import shutil
import threading
import subprocess
import urllib.request

import pyzo
from pyzo.util.qt import QtCore, QtWidgets
from pyzo import translate

base_url = 'http://repo.continuum.io/miniconda/'
links = {'win32': 'Miniconda3-latest-Windows-x86.exe',
         'win64': 'Miniconda3-latest-Windows-x86_64.exe',
         'osx64': 'Miniconda3-latest-MacOSX-x86_64.sh',
         'linux32': 'Miniconda3-latest-Linux-x86.sh',
         'linux64': 'Miniconda3-latest-Linux-x86_64.sh',
         'arm': 'Miniconda3-latest-Linux-armv7l.sh',  # raspberry pi
         }

# Get where we want to put miniconda installer
miniconda_path = os.path.join(pyzo.appDataDir, 'miniconda')
miniconda_path += '.exe' if sys.platform.startswith('win') else '.sh'

# Get default dir where we want the env
#default_conda_dir = os.path.join(pyzo.appDataDir, 'conda_root')
default_conda_dir = 'C:\\miniconda3' if sys.platform.startswith('win') else os.path.expanduser('~/miniconda3')
</t>
<t tx="ekr.20190812072050.196">def check_for_conda_env(parent=None):
    """ Check if it is reasonable to ask to install a conda env. If
    users says yes, do it. If user says no, don't, and remember.
    """

    # Interested previously?
    if getattr(pyzo.config.state, 'did_not_want_conda_env', False):
        print('User has previously indicated to have no interest in a conda env')
        return

    # Needed?
    if pyzo.config.shellConfigs2:
        exe = pyzo.config.shellConfigs2[0]['exe']
        r = ''
        try:
            r = subprocess.check_output([exe, '-m', 'conda', 'info'], shell=sys.platform.startswith('win'))
            r = r.decode()
        except Exception:
            pass  # no Python or no conda
        if r and 'is foreign system : False' in r:
            print('First shell config looks like a conda env.')
            return

    # Ask if interested now?
    d = AskToInstallConda(parent)
    d.exec_()
    if not d.result():
        pyzo.config.state.did_not_want_conda_env = True  # Mark for next time
        return

    # Launch installer
    d = Installer(parent)
    d.exec_()
</t>
<t tx="ekr.20190812072050.197">class AskToInstallConda(QtWidgets.QDialog):
    @others
</t>
<t tx="ekr.20190812072050.198">def __init__(self, parent=None):
    QtWidgets.QDialog.__init__(self, parent)
    self.setWindowTitle('Install a conda env?')
    self.setModal(True)

    text = 'Pyzo is only an editor. To execute code, you need a Python environment.\n\n'
    text += 'Do you want Pyzo to install a Python environment (miniconda)?\n'
    text += 'If not, you must arrange for a Python interpreter yourself'
    if not sys.platform.startswith('win'):
        text += ' or use the system Python'
    text += '.'
    text += '\n(You can always launch the installer from the shell menu.)'

    self._label = QtWidgets.QLabel(text, self)
    self._no = QtWidgets.QPushButton("No thanks (dont ask again)")
    self._yes = QtWidgets.QPushButton("Yes, please install Python!")

    self._no.clicked.connect(self.reject)
    self._yes.clicked.connect(self.accept)

    vbox = QtWidgets.QVBoxLayout(self)
    hbox = QtWidgets.QHBoxLayout()
    self.setLayout(vbox)
    vbox.addWidget(self._label, 1)
    vbox.addLayout(hbox, 0)
    hbox.addWidget(self._no, 2)
    hbox.addWidget(self._yes, 2)

    self._yes.setDefault(1)
</t>
<t tx="ekr.20190812072050.199">class Installer(QtWidgets.QDialog):

    lineFromStdOut = QtCore.Signal(str)

    @others
</t>
<t tx="ekr.20190812072050.2">"""
This module defines file system proxies to be used for the file browser.
For now, there is only one: the native file system. But in time,
we may add proxies for ftp, S3, remote computing, etc.

This may seem like an awkward way to use the file system, but (with
small modifications) this approach can probably be used also for
opening/saving files to any file system that we implement here. This
will make Pyzo truly powerful for use in remote computing.

"""
import time
import threading
from queue import Queue, Empty
import os.path as op

from . import QtCore
from .utils import isdir
</t>
<t tx="ekr.20190812072050.20">def files(self):
    with self._lock:
        return set(self._files)
</t>
<t tx="ekr.20190812072050.200">def __init__(self, parent=None):
    QtWidgets.QDialog.__init__(self, parent)
    self.setWindowTitle('Install miniconda')
    self.setModal(True)
    self.resize(500, 500)

    text = translate('bootstrapconda', 'This will download and install miniconda on your computer.')

    self._label = QtWidgets.QLabel(text, self)

    self._scipystack = QtWidgets.QCheckBox(translate('bootstrapconda', 'Also install scientific packages'), self)
    self._scipystack.setChecked(True)
    self._path = QtWidgets.QLineEdit(default_conda_dir, self)
    self._progress = QtWidgets.QProgressBar(self)
    self._outputLine = QtWidgets.QLabel(self)
    self._output = QtWidgets.QPlainTextEdit(self)
    self._output.setReadOnly(True)
    self._button = QtWidgets.QPushButton('Install', self)

    self._outputLine.setSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Fixed)

    vbox = QtWidgets.QVBoxLayout(self)
    self.setLayout(vbox)
    vbox.addWidget(self._label, 0)
    vbox.addWidget(self._path, 0)
    vbox.addWidget(self._scipystack, 0)
    vbox.addWidget(self._progress, 0)
    vbox.addWidget(self._outputLine, 0)
    vbox.addWidget(self._output, 1)
    vbox.addWidget(self._button, 0)

    self._button.clicked.connect(self.go)

    self.addOutput(translate('bootstrapconda', 'Waiting to start installation.\n'))
    self._progress.setVisible(False)

    self.lineFromStdOut.connect(self.setStatus)
</t>
<t tx="ekr.20190812072050.201">def setStatus(self, line):
    self._outputLine.setText(line)
</t>
<t tx="ekr.20190812072050.202">def addOutput(self, text):
    #self._output.setPlainText(self._output.toPlainText() + '\n' + text)
    cursor = self._output.textCursor()
    cursor.movePosition(cursor.End, cursor.MoveAnchor)
    cursor.insertText(text)
    cursor.movePosition(cursor.End, cursor.MoveAnchor)
    self._output.setTextCursor(cursor)
    self._output.ensureCursorVisible()
</t>
<t tx="ekr.20190812072050.203">def addStatus(self, line):
    self.addOutput('\n' + line)
    self.setStatus(line)
</t>
<t tx="ekr.20190812072050.204">def go(self):

    # Check if we can install
    try:
        self._conda_dir = self._path.text()
        if not os.path.isabs(self._conda_dir):
            raise ValueError('Given installation path must be absolute.')
        if os.path.exists(self._conda_dir):
            raise ValueError('The given installation path already exists.')
    except Exception as err:
        self.addOutput('\nCould not install:\n' + str(err))
        return

    ok = False

    try:

        # Disable user input, get ready for installation
        self._progress.setVisible(True)
        self._button.clicked.disconnect()
        self._button.setEnabled(False)
        self._scipystack.setEnabled(False)
        self._path.setEnabled(False)

        if not os.path.exists(self._conda_dir):
            self.addStatus('Downloading installer ... ')
            self._progress.setMaximum(100)
            self.download()
            self.addStatus('Done downloading installer.')
            self.make_done()

            self.addStatus('Installing (this can take a minute) ... ')
            self._progress.setMaximum(0)
            ret = self.install()
            self.addStatus(('Failed' if ret else 'Done') + ' installing.')
            self.make_done()

        self.post_install()

        if self._scipystack.isChecked():
            self.addStatus('Installing scientific packages ... ')
            self._progress.setMaximum(0)
            ret = self.install_scipy()
            self.addStatus('Done installing scientific packages')
            self.make_done()

        self.addStatus('Verifying ... ')
        self._progress.setMaximum(100)
        ret = self.verify()
        if ret:
            self.addOutput('Error\n' + ret)
            self.addStatus('Verification Failed!')
        else:
            self.addOutput('Done verifying')
            self.addStatus('Ready to go!')
            self.make_done()
            ok = True

    except Exception as err:
        self.addStatus('Installation failed ...')
        self.addOutput('\n\nException!\n' + str(err))

    if not ok:
        self.addOutput('\n\nWe recommend installing miniconda or anaconda, ')
        self.addOutput('and making Pyzo aware if it via the shell configuration.')
    else:
        self.addOutput('\n\nYou can install additional packages by running "conda install" in the shell.')

    # Wrap up, allow user to exit
    self._progress.hide()
    self._button.setEnabled(True)
    self._button.setText('Close')
    self._button.clicked.connect(self.close)
</t>
<t tx="ekr.20190812072050.205">def make_done(self):
    self._progress.setMaximum(100)
    self._progress.setValue(100)
    etime = time.time() + 0.2
    while time.time() &lt; etime:
        time.sleep(0.01)
        QtWidgets.qApp.processEvents()
</t>
<t tx="ekr.20190812072050.206">def download(self):

    # Installer already downloaded?
    if os.path.isfile(miniconda_path):
        self.addOutput('Already downloaded.')
        return  # os.remove(miniconda_path)

    # Get url key
    key = ''
    if sys.platform.startswith('win'):
        key = 'win'
    elif sys.platform.startswith('darwin'):
        key = 'osx'
    elif sys.platform.startswith('linux'):
        key = 'linux'
    key += '64' if is_64bit() else '32'

    # Get url
    if key not in links:
        raise RuntimeError('Cannot download miniconda for this platform.')
    url = base_url + links[key]

    _fetch_file(url, miniconda_path, self._progress)
</t>
<t tx="ekr.20190812072050.207">def install(self):
    dest = self._conda_dir

    # Clear dir
    assert not os.path.isdir(dest), 'Miniconda dir already exists'
    assert ' ' not in dest, 'miniconda dest path must not contain spaces'

    if sys.platform.startswith('win'):
        return self._run_process([miniconda_path, '/S', '/D=%s' % dest])
    else:
        os.chmod(miniconda_path, os.stat(miniconda_path).st_mode | stat.S_IEXEC)
        return self._run_process([miniconda_path, '-b', '-p', dest])
</t>
<t tx="ekr.20190812072050.208">def post_install(self):

    exe = py_exe(self._conda_dir)

    # Add Pyzo channel
    cmd = [exe, '-m', 'conda', 'config', '--system', '--add', 'channels', 'pyzo']
    subprocess.check_call(cmd, shell=sys.platform.startswith('win'))
    self.addStatus('Added Pyzo channel to conda env')

    # Add to pyzo shell config
    if pyzo.config.shellConfigs2 and pyzo.config.shellConfigs2[0]['exe'] == exe:
        pass
    else:
        s = pyzo.ssdf.new()
        s.name = 'Py3-conda'
        s.exe = exe
        s.gui='PyQt4'
        pyzo.config.shellConfigs2.insert(0, s)
        pyzo.saveConfig()
        self.addStatus('Prepended new env to Pyzo shell configs.')
</t>
<t tx="ekr.20190812072050.209">def install_scipy(self):

    packages = ['numpy', 'scipy', 'pandas', 'matplotlib', 'sympy',
                #'scikit-image', 'scikit-learn',
                'pyopengl', # 'visvis', 'imageio',
                'tornado', 'pyqt', #'ipython', 'jupyter',
                #'requests', 'pygments','pytest',
                ]
    exe = py_exe(self._conda_dir)
    cmd = [exe, '-m', 'conda', 'install', '--yes'] + packages
    return self._run_process(cmd)
</t>
<t tx="ekr.20190812072050.21">def _process(self, forceUpdate=False):
    # Get info
    dirs = self._fsProxy.listDirs(self._path)
    files = self._fsProxy.listFiles(self._path)
    # Is it deleted?
    if dirs is None or files is None:
        self.deleted.emit()
        return
    # All seems ok. Update if necessary
    dirs, files = set(dirs), set(files)
    if (dirs != self._dirs) or (files != self._files):
        with self._lock:
            self._dirs, self._files = dirs, files
        self.changed.emit()
    elif forceUpdate:
        self.changed.emit()
</t>
<t tx="ekr.20190812072050.210">def _run_process(self, cmd):
    """ Run command in a separate process, catch stdout, show lines
    in the output label. On fail, show all output in output text.
    """
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=sys.platform.startswith('win'))
    catcher = StreamCatcher(p.stdout, self.lineFromStdOut)

    while p.poll() is None:
        time.sleep(0.01)
        QtWidgets.qApp.processEvents()

    catcher.join()
    if p.poll():
        self.addOutput(catcher.output())
    return p.poll()
</t>
<t tx="ekr.20190812072050.211">def verify(self):

    self._progress.setValue(1)
    if not os.path.isdir(self._conda_dir):
        return 'Conda dir not created.'

    self._progress.setValue(11)
    exe = py_exe(self._conda_dir)
    if not os.path.isfile(exe):
        return 'Conda dir does not have Python exe'

    self._progress.setValue(21)
    try:
        ver = subprocess.check_output([exe, '-c', 'import sys; print(sys.version)'])
    except Exception as err:
        return 'Error getting Python version: ' + str(err)

    self._progress.setValue(31)
    if ver.decode() &lt; '3.4':
        return 'Expected Python version 3.4 or higher'

    self._progress.setValue(41)
    try:
        ver = subprocess.check_output([exe, '-c', 'import conda; print(conda.__version__)'])
    except Exception as err:
        return 'Error calling Python exe: ' + str(err)

    self._progress.setValue(51)
    if ver.decode() &lt; '3.16':
        return 'Expected Conda version 3.16 or higher'

    # Smooth toward 100%
    for i in range(self._progress.value(), 100, 5):
        time.sleep(0.05)
        self._progress.setValue(i)
        QtWidgets.qApp.processEvents()
</t>
<t tx="ekr.20190812072050.212">def is_64bit():
    """ Get whether the OS is 64 bit. On WIndows yields what it *really*
    is, not what the process is.
    """
    if False:#sys.platform.startswith('win'):  ARG, causes problems with subprocess
        if 'PROCESSOR_ARCHITEW6432' in os.environ:
            return True
        return os.environ['PROCESSOR_ARCHITECTURE'].endswith('64')
    else:
        return struct.calcsize('P') == 8
</t>
<t tx="ekr.20190812072050.213">def py_exe(dir):
    if sys.platform.startswith('win'):
        return os.path.join(dir, 'python.exe')
    else:
        return os.path.join(dir, 'bin', 'python')
</t>
<t tx="ekr.20190812072050.214">def _chunk_read(response, local_file, chunk_size=1024, initial_size=0, progress=None):
    """Download a file chunk by chunk and show advancement
    """
    # Adapted from NISL:
    # https://github.com/nisl/tutorial/blob/master/nisl/datasets.py

    bytes_so_far = initial_size
    # Returns only amount left to download when resuming, not the size of the
    # entire file
    total_size = int(response.headers['Content-Length'].strip())
    total_size += initial_size

    if progress:
        progress.setMaximum(total_size)

    while True:
        QtWidgets.qApp.processEvents()
        chunk = response.read(chunk_size)
        bytes_so_far += len(chunk)
        if not chunk:
            sys.stderr.write('\n')
            break
        #_chunk_write(chunk, local_file, progress)
        progress.setValue(bytes_so_far)
        local_file.write(chunk)
</t>
<t tx="ekr.20190812072050.215">def _fetch_file(url, file_name, progress=None):
    """Load requested file, downloading it if needed or requested
    """
    # Adapted from NISL:
    # https://github.com/nisl/tutorial/blob/master/nisl/datasets.py

    temp_file_name = file_name + ".part"
    local_file = None
    initial_size = 0
    try:
        # Checking file size and displaying it alongside the download url
        response = urllib.request.urlopen(url, timeout=5.)
        # file_size = int(response.headers['Content-Length'].strip())
        # Downloading data (can be extended to resume if need be)
        local_file = open(temp_file_name, "wb")
        _chunk_read(response, local_file, initial_size=initial_size, progress=progress)
        # temp file must be closed prior to the move
        if not local_file.closed:
            local_file.close()
        shutil.move(temp_file_name, file_name)
    except Exception as e:
        raise RuntimeError('Error while fetching file %s.\n'
                           'Dataset fetching aborted (%s)' % (url, e))
    finally:
        if local_file is not None:
            if not local_file.closed:
                local_file.close()
</t>
<t tx="ekr.20190812072050.216">class StreamCatcher(threading.Thread):

    @others
if __name__ == '__main__':

    check_for_conda_env()
</t>
<t tx="ekr.20190812072050.217">def __init__(self, file, signal):
    self._file = file
    self._signal = signal
    self._lines = []
    self._line = ''
    threading.Thread.__init__(self)
    self.setDaemon(True)  # do not let this thread hold up Python shutdown
    self.start()
</t>
<t tx="ekr.20190812072050.218">def run(self):
    while True:
        time.sleep(0.0001)
        try:
            part = self._file.read(20)
        except ValueError:  # pragma: no cover
            break
        if not part:
            break
        part = part.decode('utf-8', 'ignore')
        #print(part, end='')

        self._line += part.replace('\r', '\n')
        lines = [line for line in self._line.split('\n') if line]
        self._lines.extend(lines[:-1])
        self._line = lines[-1]

        if self._lines:
            self._signal.emit(self._lines[-1])

    self._lines.append(self._line)
    self._signal.emit(self._lines[-1])
</t>
<t tx="ekr.20190812072050.219">def output(self):
    return '\n'.join(self._lines)
</t>
<t tx="ekr.20190812072050.22">class FileProxy(PathProxy):
    """ Proxy object for a file. Obtain an instance of this class
    using filesystemProx.dir()
    """

    @others
</t>
<t tx="ekr.20190812072050.220">@path pyzo/util/
# -*- coding: utf-8 -*-
# Copyright (c) 2016, Almar Klein, Rob Reilink
#
# This file is distributed under the terms of the (new) BSD License.

@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072050.221">""" Module paths

Get paths to useful directories in a cross platform manner. The functions
in this module are designed to be stand-alone, so that they can easily
be copied and used in code that does not want pyzo as a dependency.

This code was first part of pyzolib, and later moved to pyzo.

"""

# Notes:
# * site.getusersitepackages() returns a dir in roaming userspace on Windows
#   so better avoid that.
# * site.getuserbase() returns appdata_dir('Python', True)
# * See docstring: that's why the functions tend to not re-use each-other

import sys

ISWIN = sys.platform.startswith('win')
ISMAC = sys.platform.startswith('darwin')
ISLINUX = sys.platform.startswith('linux')

PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3

# From pyzolib/paths.py (https://bitbucket.org/pyzo/pyzolib/src/tip/paths.py)
import sys
</t>
<t tx="ekr.20190812072050.222">def is_frozen():
    """ is_frozen()
    Return whether this app is a frozen application (using e.g. cx_freeze).
    """
    return bool( getattr(sys, 'frozen', None) )

# From pyzolib/paths.py (https://bitbucket.org/pyzo/pyzolib/src/tip/paths.py)
import os, sys, tempfile
</t>
<t tx="ekr.20190812072050.223">def temp_dir(appname=None, nospaces=False):
    """ temp_dir(appname=None, nospaces=False)
    Get path to a temporary directory with write access.
    If appname is given, a subdir is appended (and created if necessary).
    If nospaces, will ensure that the path has no spaces.
    """

    # Do it the Python way
    path = tempfile.gettempdir()

    # Try harder if we have to
    if nospaces and ' ' in path:
        if sys.platform.startswith('win'):
            for path in ['c:\\TEMP', 'c:\\TMP']:
                if os.path.isdir(path):
                    break
            if not os.path.isdir(path):
                os.mkdir(path)
        else:
            for path in ['/tmp', '/var/tmp']: # http://www.tuxfiles.org/linuxhelp/linuxdir.html
                if os.path.isdir(path):
                    break
            else:
                raise RuntimeError('Could not locate temporary directory.')

    # Get path specific for this app
    if appname:
        path = os.path.join(path, appname)
        if not os.path.isdir(path):
            os.mkdir(path)

    # Done
    return path

# From pyzolib/paths.py (https://bitbucket.org/pyzo/pyzolib/src/tip/paths.py)
import os
</t>
<t tx="ekr.20190812072050.224">def user_dir():
    """ user_dir()
    Get the path to the user directory. (e.g. "/home/jack", "c:/Users/jack")
    """
    return os.path.expanduser('~')

# From pyzolib/paths.py (https://bitbucket.org/pyzo/pyzolib/src/tip/paths.py)
import os, sys
</t>
<t tx="ekr.20190812072050.225">def appdata_dir(appname=None, roaming=False, macAsLinux=False):
    """ appdata_dir(appname=None, roaming=False,  macAsLinux=False)
    Get the path to the application directory, where applications are allowed
    to write user specific files (e.g. configurations). For non-user specific
    data, consider using common_appdata_dir().
    If appname is given, a subdir is appended (and created if necessary).
    If roaming is True, will prefer a roaming directory (Windows Vista/7).
    If macAsLinux is True, will return the Linux-like location on Mac.
    """

    # Define default user directory
    userDir = os.path.expanduser('~')

    # Get system app data dir
    path = None
    if sys.platform.startswith('win'):
        path1, path2 = os.getenv('LOCALAPPDATA'), os.getenv('APPDATA')
        path = (path2 or path1) if roaming else (path1 or path2)
    elif sys.platform.startswith('darwin') and not macAsLinux:
        path = os.path.join(userDir, 'Library', 'Application Support')
    # On Linux and as fallback
    if not (path and os.path.isdir(path)):
        path = userDir

    # Maybe we should store things local to the executable (in case of a
    # portable distro or a frozen application that wants to be portable)
    prefix = sys.prefix
    if getattr(sys, 'frozen', None): # See application_dir() function
        prefix = os.path.abspath(os.path.dirname(sys.executable))
    for reldir in ('settings', '../settings'):
        localpath = os.path.abspath(os.path.join(prefix, reldir))
        if os.path.isdir(localpath):
            try:
                open(os.path.join(localpath, 'test.write'), 'wb').close()
                os.remove(os.path.join(localpath, 'test.write'))
            except IOError:
                pass # We cannot write in this directory
            else:
                path = localpath
                break

    # Get path specific for this app
    if appname:
        if path == userDir:
            appname = '.' + appname.lstrip('.') # Make it a hidden directory
        path = os.path.join(path, appname)
        if not os.path.isdir(path):
            os.mkdir(path)

    # Done
    return path

# From pyzolib/paths.py (https://bitbucket.org/pyzo/pyzolib/src/tip/paths.py)
import os, sys
</t>
<t tx="ekr.20190812072050.226">def common_appdata_dir(appname=None):
    """ common_appdata_dir(appname=None)
    Get the path to the common application directory. Applications are
    allowed to write files here. For user specific data, consider using
    appdata_dir().
    If appname is given, a subdir is appended (and created if necessary).
    """

    # Try to get path
    path = None
    if sys.platform.startswith('win'):
        path = os.getenv('ALLUSERSPROFILE', os.getenv('PROGRAMDATA'))
    elif sys.platform.startswith('darwin'):
        path = '/Library/Application Support'
    else:
        # Not sure what to use. Apps are only allowed to write to the home
        # dir and tmp dir, right?
        pass

    # If no success, use appdata_dir() instead
    if not (path and os.path.isdir(path)):
        path = appdata_dir()

    # Get path specific for this app
    if appname:
        path = os.path.join(path, appname)
        if not os.path.isdir(path):
            os.mkdir(path)

    # Done
    return path

#  Other approaches that we considered, but which did not work for links,
#  or are less reliable for other reasons are:
#      * sys.executable: does not work for links
#      * sys.prefix: dito
#      * sys.exec_prefix: dito
#      * os.__file__: does not work when frozen
#      * __file__: only accessable from main module namespace, does not work when frozen

# todo: get this included in Python sys or os module!

# From pyzolib/paths.py (https://bitbucket.org/pyzo/pyzolib/src/tip/paths.py)
import os, sys
</t>
<t tx="ekr.20190812072050.227">def application_dir():
    """ application_dir()
    Get the directory in which the current application is located.
    The "application" can be a Python script or a frozen application.
    This function raises a RuntimeError if in interpreter mode.
    """
    if getattr(sys, 'frozen', False):
        # When frozen, use sys.executable
        thepath = os.path.dirname(sys.executable)
    else:
        # Test if the current process can be considered an "application"
        if not sys.path or not sys.path[0]:
            raise RuntimeError('Cannot determine app path because sys.path[0] is empty!')
        thepath = sys.path[0]
    # Return absolute version, or symlinks may not work
    return os.path.abspath(thepath)

## Pyzo specific
#
# A Pyzo distribution maintains a file in the appdata dir that lists
# the directory where it is intalled. Pyzo can in principle be installed
# multiple times. In that case the file contains multiple entries.
# This file is checked each time the pyzo executable is run. Therefore
# a user can move the Pyzo directory and simply run the Pyzo executable
# to update the registration.
</t>
<t tx="ekr.20190812072050.228">def pyzo_dirs(newdir=None, makelast=False):
    """ pyzo_dirs(newdir=None,  makelast=False)
    Compatibility function. Like pyzo_dirs2, but returns a list of
    directories and does not allow setting the version.
    """
    return [p[0] for p in pyzo_dirs2(newdir, makelast=makelast)]

# From pyzolib/paths.py (https://bitbucket.org/pyzo/pyzolib/src/tip/paths.py)
import os, sys
</t>
<t tx="ekr.20190812072050.229">def pyzo_dirs2(path=None, version='0', **kwargs):
    """ pyzo_dirs2(dir=None, version='0', makelast=False)
    Get the locations of installed Pyzo directories. Returns a list of
    tuples: (dirname, version). In future versions more information may
    be added to the file, so please take larger tuples into account.
    If path is a dir containing a python exe, it is added it to the
    list. If the keyword arg 'makelast' is given and True, will ensure
    that the given path is the last in the list (i.e. the default).
    """
    defaultPyzo = '', '0'  # To fill in values for shorter items
    newPyzo = (str(path), str(version)) if path else None
    # Get application dir
    userDir = os.path.expanduser('~')
    path = None
    if sys.platform.startswith('win'):
        path = os.getenv('LOCALAPPDATA', os.getenv('APPDATA'))
    elif sys.platform.startswith('darwin'):
        path = os.path.join(userDir, 'Library', 'Application Support')
    # Get application dir for Pyzo
    if path and os.path.isdir(path):
        path = os.path.join(path, 'pyzo')
    else:
        path = os.path.join(userDir, '.pyzo')  # On Linux and as fallback
    if not os.path.isdir(path):
        os.mkdir(path)
    # Open file and parse
    fname = os.path.join(path, 'pyzodirs')
    pyzos, npyzos = [], 0
    if os.path.isfile(fname):
        lines = open(fname, 'rb').read().decode('utf-8').split('\n')
        pyzos = [tuple(d.split(':::')) for d in [d.strip() for d in lines] if d]
        npyzos = len(pyzos)
    # Add dir if necessary
    if newPyzo and os.path.isdir(newPyzo[0]):
        if kwargs.get('makelast', False) or newPyzo not in pyzos:
            npyzos = 0  # force save
            pyzos = [p for p in pyzos if p[0] != newPyzo[0]]  # rm based on dir
            pyzos.append(newPyzo)
    # Check validity of all pyzos, write back if necessary, and return
    pythonname = 'python' + '.exe' * sys.platform.startswith('win')
    pyzos = [p for p in pyzos if os.path.isfile(os.path.join(p[0], pythonname))]
    if len(pyzos) != npyzos:
        lines = [':::'.join(p) for p in pyzos]
        open(fname, 'wb').write( ('\n'.join(lines)).encode('utf-8') )
    return [p+defaultPyzo[len(p):] for p in pyzos]

## Windows specific

# Maybe for directory of programs, pictures etc.
</t>
<t tx="ekr.20190812072050.23">def __init__(self, *args):
    PathProxy.__init__(self, *args)
    self._modified = 0
</t>
<t tx="ekr.20190812072050.230">@path pyzo/util/
@others
if __name__ == '__main__':
    w = PyzoWizard(None)
    w.show()

@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.231"># -*- coding: utf-8 -*-
""" pyzowizard module

Implements a wizard to help new users get familiar with pyzo.

"""

import os
import re

import pyzo
from pyzo.util.qt import QtCore, QtGui, QtWidgets
from pyzo import translate

from pyzo.util._locale import LANGUAGES, LANGUAGE_SYNONYMS, setLanguage
</t>
<t tx="ekr.20190812072050.232">def retranslate(t):
    """ To allow retranslating after selecting the language.
    """
    if hasattr(t, 'original'):
        return translate('wizard', t.original)
    else:
        return t
</t>
<t tx="ekr.20190812072050.233">class PyzoWizard(QtWidgets.QWizard):

    @others
</t>
<t tx="ekr.20190812072050.234">def __init__(self, parent):
    QtWidgets.QWizard.__init__(self, parent)

    # Set some appearance stuff
    self.setMinimumSize(600, 500)
    self.setWindowTitle(translate('wizard', 'Getting started with Pyzo'))
    self.setWizardStyle(self.ModernStyle)
    self.setButtonText(self.CancelButton, 'Stop')

    # Set logo
    pm = QtGui.QPixmap()
    pm.load(os.path.join(pyzo.pyzoDir, 'resources', 'appicons', 'pyzologo48.png'))
    self.setPixmap(self.LogoPixmap, pm)

    # Define pages
    klasses = [ IntroWizardPage,
                TwocomponentsWizardPage, EditorWizardPage,
                ShellWizardPage1, ShellWizardPage2,
                RuncodeWizardPage1, RuncodeWizardPage2,
                ToolsWizardPage1, ToolsWizardPage2,
                FinalPage]

    # Create pages
    self._n = len(klasses)
    for i, klass in enumerate(klasses):
        self.addPage(klass(self, i))
</t>
<t tx="ekr.20190812072050.235">def show(self, startPage=None):
    """ Show the wizard. If startPage is given, open the Wizard at
    that page. startPage can be an integer or a string that matches
    the classname of a page.
    """
    QtWidgets.QWizard.show(self)

    # Check startpage
    if isinstance(startPage, int):
        pass
    elif isinstance(startPage, str):
        for i in range(self._n):
            page = self.page(i)
            if page.__class__.__name__.lower() == startPage.lower():
                startPage = i
                break
        else:
            print('Pyzo wizard: Could not find start page: %r' % startPage)
            startPage = None
    elif startPage is not None:
        print('Pyzo wizard: invalid start page: %r' % startPage)
        startPage = None

    # Go to start page
    if startPage is not None:
        for i in range(startPage):
            self.next()
</t>
<t tx="ekr.20190812072050.236">class BasePyzoWizardPage(QtWidgets.QWizardPage):

    _prefix = translate('wizard', 'Step')

    _title = 'dummy title'
    _descriptions = []
    _image_filename = ''

    @others
</t>
<t tx="ekr.20190812072050.237">def __init__(self, parent, i):
    QtWidgets.QWizardPage.__init__(self, parent)
    self._i = i

    # Create label for description
    self._text_label = QtWidgets.QLabel(self)
    self._text_label.setTextFormat(QtCore.Qt.RichText)
    self._text_label.setWordWrap(True)

    # Create label for image
    self._comicLabel = QtWidgets.QLabel(self)
    pm = QtGui.QPixmap()
    if 'logo' in self._image_filename:
        pm.load(os.path.join(pyzo.pyzoDir, 'resources', 'appicons', self._image_filename))
    elif self._image_filename:
        pm.load(os.path.join(pyzo.pyzoDir, 'resources', 'images', self._image_filename))
    self._comicLabel.setPixmap(pm)
    self._comicLabel.setAlignment(QtCore.Qt.AlignHCenter | QtCore.Qt.AlignVCenter)

    # Layout
    theLayout = QtWidgets.QVBoxLayout(self)
    self.setLayout(theLayout)
    #
    theLayout.addWidget(self._text_label)
    theLayout.addStretch()
    theLayout.addWidget(self._comicLabel)
    theLayout.addStretch()
</t>
<t tx="ekr.20190812072050.238">def initializePage(self):

    # Get prefix
    i = self._i
    n = self.wizard()._n - 2 # Dont count the first and last page
    prefix = ''
    if i and i &lt;= n:
        prefix = retranslate(self._prefix) + ' %i/%i: ' % (i, n)

    # Set title
    self.setTitle(prefix + retranslate(self._title))

    # Parse description
    # Two description units are separated with BR tags
    # Emphasis on words is set to italic tags.
    lines = []
    descriptions = [retranslate(d).strip() for d in self._descriptions]
    for description in descriptions:
        for line in description.splitlines():
            line = line.strip()
            line = re.sub(r'\*(.+?)\*', r'&lt;b&gt;\1&lt;/b&gt;', line)
            lines.append(line)
        lines.append('&lt;br /&gt;&lt;br /&gt;')
    lines = lines[:-1]

    # Set description
    self._text_label.setText('\n'.join(lines))
</t>
<t tx="ekr.20190812072050.239">class IntroWizardPage(BasePyzoWizardPage):

    _title = translate('wizard', 'Welcome to the Interactive Editor for Python!')
    _image_filename = 'pyzologo128.png'
    _descriptions = [
        translate('wizard', """This wizard helps you get familiarized with the workings of Pyzo."""),

        translate('wizard', """Pyzo is a cross-platform Python IDE
        focused on *interactivity* and *introspection*, which makes it
        very suitable for scientific computing. Its practical design
        is aimed at *simplicity* and *efficiency*."""),
        ]

    @others
</t>
<t tx="ekr.20190812072050.24">def modified(self):
    with self._lock:
        return self._modified
</t>
<t tx="ekr.20190812072050.240">def __init__(self, parent, i):
    BasePyzoWizardPage.__init__(self, parent, i)

    # Create label and checkbox
    t1 = translate('wizard', "This wizard can be opened using 'Help &gt; Pyzo wizard'")
    # t2 = translate('wizard', "Show this wizard on startup")
    self._label_info = QtWidgets.QLabel(t1, self)
    #self._check_show = QtWidgets.QCheckBox(t2, self)
    #self._check_show.stateChanged.connect(self._setNewUser)

    # Create language switcher
    self._langLabel = QtWidgets.QLabel(translate('wizard', "Select language"), self)
    #
    self._langBox = QtWidgets.QComboBox(self)
    self._langBox.setEditable(False)
    # Fill
    index, theIndex = -1, -1
    cur = pyzo.config.settings.language
    for lang in sorted(LANGUAGES):
        index += 1
        self._langBox.addItem(lang)
        if lang == LANGUAGE_SYNONYMS.get(cur, cur):
            theIndex = index
    # Set current index
    if theIndex &gt;= 0:
        self._langBox.setCurrentIndex(theIndex)
    # Bind signal
    self._langBox.activated.connect(self.onLanguageChange)

    # Init check state
    #if pyzo.config.state.newUser:
    #    self._check_show.setCheckState(QtCore.Qt.Checked)

    # Create sublayout
    layout = QtWidgets.QHBoxLayout()
    layout.addWidget(self._langLabel, 0)
    layout.addWidget(self._langBox, 0)
    layout.addStretch(2)
    self.layout().addLayout(layout)

    # Add to layout
    self.layout().addSpacing(10)
    self.layout().addWidget(self._label_info)
    #self.layout().addWidget(self._check_show)
</t>
<t tx="ekr.20190812072050.241">def _setNewUser(self, newUser):
    newUser = bool(newUser)
    self._label_info.setHidden(newUser)
    pyzo.config.state.newUser = newUser
</t>
<t tx="ekr.20190812072050.242">def onLanguageChange(self):
    languageName = self._langBox.currentText()
    if pyzo.config.settings.language == languageName:
        return
    # Save new language
    pyzo.config.settings.language = languageName
    setLanguage(pyzo.config.settings.language)
    # Notify user
    text = translate('wizard', """
    The language has been changed for this wizard.
    Pyzo needs to restart for the change to take effect application-wide.
    """)
    m = QtWidgets.QMessageBox(self)
    m.setWindowTitle(translate("wizard", "Language changed"))
    m.setText(text)
    m.setIcon(m.Information)
    m.exec_()

    # Get props of current wizard
    geo = self.wizard().geometry()
    parent = self.wizard().parent()
    # Close ourself!
    self.wizard().close()
    # Start new one
    w = PyzoWizard(parent)
    w.setGeometry(geo)
    w.show()
</t>
<t tx="ekr.20190812072050.243">class TwocomponentsWizardPage(BasePyzoWizardPage):

    _title = translate('wizard', 'Pyzo consists of two main components')
    _image_filename = 'pyzo_two_components.png'
    _descriptions = [
        translate('wizard',
        "You can execute commands directly in the *shell*,"),
        translate('wizard',
        "or you can write code in the *editor* and execute that."),
        ]
</t>
<t tx="ekr.20190812072050.244">class EditorWizardPage(BasePyzoWizardPage):

    _title = translate('wizard', 'The editor is where you write your code')
    _image_filename = 'pyzo_editor.png'
    _descriptions = [
        translate('wizard',
        """In the *editor*, each open file is represented as a tab. By
        right-clicking on a tab, files can be run, saved, closed, etc."""),
        translate('wizard',
        """The right mouse button also enables one to make a file the
        *main file* of a project. This file can be recognized by its star
        symbol, and it enables running the file more easily."""),
        ]
</t>
<t tx="ekr.20190812072050.245">class ShellWizardPage1(BasePyzoWizardPage):

    _title = translate('wizard', 'The shell is where your code gets executed')
    _image_filename = 'pyzo_shell1.png'
    _descriptions = [
        translate('wizard',
        """When Pyzo starts, a default *shell* is created. You can add more
        shells that run simultaneously, and which may be of different
        Python versions."""),
        translate('wizard',
        """Shells run in a sub-process, such that when it is busy, Pyzo
        itself stays responsive, allowing you to keep coding and even
        run code in another shell."""),
        ]
</t>
<t tx="ekr.20190812072050.246">class ShellWizardPage2(BasePyzoWizardPage):

    _title = translate('wizard', 'Configuring shells')
    _image_filename = 'pyzo_shell2.png'
    _descriptions = [
        translate('wizard',
        """Pyzo can integrate the event loop of five different *GUI toolkits*,
        thus enabling interactive plotting with e.g. Visvis or Matplotlib."""),
        translate('wizard',
        """Via 'Shell &gt; Edit shell configurations', you can edit and add
        *shell configurations*. This allows you to for example select the
        initial directory, or use a custom Pythonpath."""),
        ]
</t>
<t tx="ekr.20190812072050.247">class RuncodeWizardPage1(BasePyzoWizardPage):

    _title = translate('wizard', 'Running code')
    _image_filename = 'pyzo_run1.png'
    _descriptions = [
        translate('wizard',
        "Pyzo supports several ways to run source code in the editor. (see the 'Run' menu)."),
        translate('wizard',
        """*Run selection:* if there is no selected text, the current line
        is executed; if the selection is on a single line, the selection
        is evaluated; if the selection spans multiple lines, Pyzo will
        run the the (complete) selected lines."""),
        translate('wizard',
        "*Run cell:* a cell is everything between two lines starting with '##'."),
        translate('wizard',
        "*Run file:* run all the code in the current file."),
        translate('wizard',
        "*Run project main file:* run the code in the current project's main file."),
        ]
</t>
<t tx="ekr.20190812072050.248">class RuncodeWizardPage2(BasePyzoWizardPage):

    _title = translate('wizard', 'Interactive mode vs running as script')
    _image_filename = ''
    _descriptions = [
        translate('wizard',
        """You can run the current file or the main file normally, or as a script.
        When run as script, the shell is restared to provide a clean
        environment. The shell is also initialized differently so that it
        closely resembles a normal script execution."""),
        translate('wizard',
        """In interactive mode, sys.path[0] is an empty string (i.e. the current dir),
        and sys.argv is set to ['']."""),
        translate('wizard',
        """In script mode, __file__ and sys.argv[0] are set to the scripts filename,
        sys.path[0] and the working dir are set to the directory containing the script."""),
        ]
</t>
<t tx="ekr.20190812072050.249">class ToolsWizardPage1(BasePyzoWizardPage):

    _title = translate('wizard', 'Tools for your convenience')
    _image_filename = 'pyzo_tools1.png'
    _descriptions = [
        translate('wizard',
        """Via the *Tools menu*, one can select which tools to use. The tools can
        be positioned in any way you want, and can also be un-docked."""),
        translate('wizard',
        """Note that the tools system is designed such that it's easy to
        create your own tools. Look at the online wiki for more information,
        or use one of the existing tools as an example."""),
        ]
</t>
<t tx="ekr.20190812072050.25">def _process(self, forceUpdate=False):
    # Get info
    modified = self._fsProxy.modified(self._path)
    # Is it deleted?
    if modified is None:
        self.deleted.emit()
        return
    # All seems ok. Update if necessary
    if modified != self._modified:
        with self._lock:
            self._modified = modified
        self.changed.emit()
    elif forceUpdate:
        self.changed.emit()
</t>
<t tx="ekr.20190812072050.250">class ToolsWizardPage2(BasePyzoWizardPage):

    _title = translate('wizard', 'Recommended tools')
    _image_filename = 'pyzo_tools2.png'
    _descriptions = [
        translate('wizard',
        """We especially recommend the following tools:"""),
        translate('wizard',
        """The *Source structure tool* gives an outline of the source code."""),
        translate('wizard',
        """The *File browser tool* helps keep an overview of all files
        in a directory. To manage your projects, click the star icon."""),
        ]
</t>
<t tx="ekr.20190812072050.251">class FinalPage(BasePyzoWizardPage):

    _title = translate('wizard', 'Get coding!')
    _image_filename = 'pyzologo128.png'
    _descriptions = [
        translate('wizard',
        """This concludes the Pyzo wizard. Now, get coding and have fun!"""),
        ]

# def smooth_images():
#     """ This was used to create the images from their raw versions.
#     """
#
#     import os
#     import visvis as vv
#     import scipy as sp
#     import scipy.ndimage
#     for fname in os.listdir('images'):
#         im = vv.imread(os.path.join('images', fname))
#         for i in range(im.shape[2]):
#             im[:,:,i] = sp.ndimage.gaussian_filter(im[:,:,i], 0.7)
#         #fname = fname.replace('.png', '.jpg')
#         print(fname)
#         vv.imwrite(fname, im[::2,::2,:])
</t>
<t tx="ekr.20190812072050.252">@path pyzo/util/
# -*- coding: utf-8 -*-
# Copyright (C) 2016, Almar Klein
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.253">"""
Reading and saving Zoof Object Notation files. ZON is like JSON, but a
more Pythonic format. It's just about 500 lines of code.

This format is a spin-off from the SSDF format, it is fully compatible,
except that ZON does not support numpy arrays.
"""
import re
import sys
import time

# From six.py
# if sys.version_info[0] &gt;= 3:
string_types = str,
integer_types = int,
# else:
    # string_types = basestring,  # noqa
    # integer_types = (int, long)  # noqa
float_types = float,

## Dict class

try:  # pragma: no cover
    from collections import OrderedDict as _dict
except ImportError:
    _dict = dict
</t>
<t tx="ekr.20190812072050.254">def isidentifier(s):
    # http://stackoverflow.com/questions/2544972/
    if not isinstance(s, str):
        return False
    return re.match(r'^\w+$', s, re.UNICODE) and re.match(r'^[0-9]', s) is None
</t>
<t tx="ekr.20190812072050.255">class Dict(_dict):
    """ A dict in which the items can be get/set as attributes.
    """

    __reserved_names__ = dir(_dict())  # Also from OrderedDict
    __pure_names__ = dir(dict())
    __slots__ = []

    @others
Struct = Dict
Struct.__is_ssdf_struct__ = True

## Public functions
# SSDF compatibility
</t>
<t tx="ekr.20190812072050.256">def __repr__(self):
    identifier_items = []
    nonidentifier_items = []
    for key, val in self.items():
        if isidentifier(key):
            identifier_items.append('%s=%r' % (key, val))
        else:
            nonidentifier_items.append('(%r, %r)' % (key, val))
    if nonidentifier_items:
        return 'Dict([%s], %s)' % (', '.join(nonidentifier_items),
                                   ', '.join(identifier_items))
    else:
        return 'Dict(%s)' % (', '.join(identifier_items))
</t>
<t tx="ekr.20190812072050.257">def __getattribute__(self, key):
    try:
        return object.__getattribute__(self, key)
    except AttributeError:
        if key in self:
            return self[key]
        else:
            raise
</t>
<t tx="ekr.20190812072050.258">def __setattr__(self, key, val):
    if key in Dict.__reserved_names__:
        # Either let OrderedDict do its work, or disallow
        if key not in Dict.__pure_names__:
            return _dict.__setattr__(self, key, val)
        else:
            raise AttributeError('Reserved name, this key can only ' +
                                 'be set via ``d[%r] = X``' % key)
    else:
        # if isinstance(val, dict): val = Dict(val) -&gt; no, makes a copy!
        self[key] = val
</t>
<t tx="ekr.20190812072050.259">def __dir__(self):
    names = [k for k in self.keys() if isidentifier(k)]
    return Dict.__reserved_names__ + names


</t>
<t tx="ekr.20190812072050.26">def read(self):
    pass # ?
</t>
<t tx="ekr.20190812072050.260">def isstruct(ob):  # SSDF compatibility
    """ isstruct(ob)

    Returns whether the given object is an SSDF struct.
    """
    if hasattr(ob, '__is_ssdf_struct__'):
        return bool(ob.__is_ssdf_struct__)
    else:
        return False
</t>
<t tx="ekr.20190812072050.261">def new():
    """ new()

    Create a new Dict object. The same as "Dict()".
    """
    return Dict()
</t>
<t tx="ekr.20190812072050.262">def clear(d):  # SSDF compatibility
    """ clear(d)

    Clear all elements of the given Dict object.
    """
    d.clear()
</t>
<t tx="ekr.20190812072050.263">def copy(object):
    """ copy(objec)

    Return a deep copy the given object. The object and its children
    should be dict-compatible data types. Note that dicts are converted
    to Dict and tuples to lists.
    """
    if isstruct(object) or isinstance(object, dict):
        newObject = Dict()
        for key in object:
            val = object[key]
            newObject[key] = copy(val)
        return newObject
    elif isinstance(object, (tuple, list)):
        return [copy(ob) for ob in object]
    else:
        return object  # immutable
</t>
<t tx="ekr.20190812072050.264">def count(object, cache=None):
    """ count(object):

    Count the number of elements in the given object. An element is
    defined as one of the 6 datatypes supported by ZON (dict,
    tuple/list, string, int, float, None).
    """
    cache = cache or []
    if isstruct(object) or isinstance(object, (dict, list)):
        if id(object) in cache:
            raise RuntimeError('recursion!')
        cache.append(id(object))
    n = 1
    if isstruct(object) or isinstance(object, dict):
        for key in object:
            val = object[key]
            n += count(val, cache)
    elif isinstance(object, (tuple, list)):
        for val in object:
            n += count(val, cache)
    return n
</t>
<t tx="ekr.20190812072050.265">def loads(text):
    """ loads(text)

    Load a Dict from the given Unicode) string in ZON syntax.
    """
    if not isinstance(text, string_types):
        raise ValueError('zon.loads() expects a string.')
    reader = ReaderWriter()
    return reader.read(text)
</t>
<t tx="ekr.20190812072050.266">def load(file):
    """ load(filename)

    Load a Dict from the given file or filename.
    """
    if isinstance(file, string_types):
        file = open(file, 'rb')
    text = file.read().decode('utf-8')
    return loads(text)
</t>
<t tx="ekr.20190812072050.267">def saves(d):
    """ saves(d)

    Serialize the given dict to a (Unicode) string.
    """
    if not (isstruct(d) or isinstance(d, dict)):
        raise ValueError('ssdf.saves() expects a dict.')
    writer = ReaderWriter()
    text = writer.save(d)
    return text
</t>
<t tx="ekr.20190812072050.268">def save(file, d):
    """ save(file, d)

    Serialize the given dict to the given file or filename.
    """
    text = saves(d)
    if isinstance(file, string_types):
        file = open(file, 'wb')
    with file:
        file.write(text.encode('utf-8'))
## The core

</t>
<t tx="ekr.20190812072050.269">class ReaderWriter(object):

    @others
</t>
<t tx="ekr.20190812072050.27">def save(self):
    pass # ?
</t>
<t tx="ekr.20190812072050.270">def read(self, text):

    indent = 0
    root = Dict()
    container_stack = [(0, root)]
    new_container = None

    for i, line in enumerate(text.splitlines()):
        linenr = i + 1

        # Strip line
        line2 = line.lstrip()

        # Skip comments and empty lines
        if not line2 or line2[0] == '#':
            continue

        # Find the indentation
        prev_indent = indent
        indent = len(line) - len(line2)
        if indent == prev_indent:
            pass
        elif indent &lt; prev_indent:
            while container_stack[-1][0] &gt; indent:
                container_stack.pop(-1)
            if container_stack[-1][0] != indent:
                print('ZON: Ignoring wrong dedentation at %i' % linenr)
        elif indent &gt; prev_indent and new_container is not None:
            container_stack.append((indent, new_container))
            new_container = None
        else:
            print('ZON: Ignoring wrong indentation at %i' % linenr)
            indent = prev_indent

        # Split name and data using a regular expression
        m = re.search("^\w+? *?=", line2)
        if m:
            i = m.end(0)
            name = line2[:i-1].strip()
            data = line2[i:].lstrip()
        else:
            name = None
            data = line2

        # Get value
        value = self.to_object(data, linenr)

        # Store the value
        _indent, current_container = container_stack[-1]
        if isinstance(current_container, dict):
            if name:
                current_container[name] = value
            else:
                print('ZON: unnamed item in dict on line %i' % linenr)
        elif isinstance(current_container, list):
            if name:
                print('ZON: named item in list on line %i' % linenr)
            else:
                current_container.append(value)
        else:
            raise RuntimeError('Invalid container %r' % current_container)

        # Prepare for next round
        if isinstance(value, (dict, list)):
            new_container = value

    return root
</t>
<t tx="ekr.20190812072050.271">def save(self, d):

    pyver = '%i.%i.%i' % sys.version_info[:3]
    ct = time.asctime()
    lines = []
    lines.append('# -*- coding: utf-8 -*-')
    lines.append('# This Zoof Object Notation (ZON) file was')
    lines.append('# created from Python %s on %s.\n' % (pyver, ct))
    lines.append('')
    lines.extend(self.from_dict(d, -2)[1:])

    return '\r\n'.join(lines)
    # todo: pop toplevel dict
</t>
<t tx="ekr.20190812072050.272">def from_object(self, name, value, indent):

    # Get object's data
    if value is None:
        data = 'Null'
    elif isinstance(value, integer_types):
        data = self.from_int(value)
    elif isinstance(value, float_types):
        data = self.from_float(value)
    elif isinstance(value, bool):
        data = self.from_int(int(value))
    elif isinstance(value, string_types):
        data = self.from_unicode(value)
    elif isinstance(value, dict):
        data = self.from_dict(value, indent)
    elif isinstance(value, (list, tuple)):
        data = self.from_list(value, indent)
    else:
        # We do not know
        data = 'Null'
        tmp = repr(value)
        if len(tmp) &gt; 64:
            tmp = tmp[:64] + '...'
        if name is not None:
            print("ZON: %s is unknown object: %s" %  (name, tmp))
        else:
            print("ZON: unknown object: %s" % tmp)

    # Finish line (or first line)
    if isinstance(data, string_types):
        data = [data]
    if name:
        data[0] = '%s%s = %s' % (' ' * indent, name, data[0])
    else:
        data[0] = '%s%s' % (' ' * indent, data[0])

    return data
</t>
<t tx="ekr.20190812072050.273">def to_object(self, data, linenr):

    data = data.lstrip()

    # Determine what type of object we're dealing with by reading
    # like a human.
    if not data:
        print('ZON: no value specified at line %i.' % linenr)
    elif data[0] in '-.0123456789':
        return self.to_int_or_float(data, linenr)
    elif data[0] == "'":
        return self.to_unicode(data, linenr)
    elif data.startswith('dict:'):
        return self.to_dict(data, linenr)
    elif data.startswith('list:') or data[0] == '[':
        return self.to_list(data, linenr)
    elif data.startswith('Null') or data.startswith('None'):
        return None
    else:
        print("ZON: invalid type on line %i." % linenr)
        return None
</t>
<t tx="ekr.20190812072050.274">def to_int_or_float(self, data, linenr):
    line = data.partition('#')[0]
    try:
        return int(line)
    except ValueError:
        try:
            return float(line)
        except ValueError:
            print("ZON: could not parse number on line %i." % linenr)
            return None
</t>
<t tx="ekr.20190812072050.275">def from_int(self, value):
    return repr(int(value)).rstrip('L')
</t>
<t tx="ekr.20190812072050.276">def from_float(self, value):
    # Use general specifier with a very high precision.
    # Any spurious zeros are automatically removed. The precision
    # should be sufficient such that any numbers saved and loaded
    # back will have the exact same value again.
    # see e.g. http://bugs.python.org/issue1580
    return repr(float(value))  # '%0.17g' % value
</t>
<t tx="ekr.20190812072050.277">def from_unicode(self, value):
    value = value.replace('\\', '\\\\')
    value = value.replace('\n','\\n')
    value = value.replace('\r','\\r')
    value = value.replace('\x0b', '\\x0b').replace('\x0c', '\\x0c')
    value = value.replace("'", "\\'")
    return "'" + value + "'"
</t>
<t tx="ekr.20190812072050.278">def to_unicode(self, data, linenr):
    # Encode double slashes
    line = data.replace('\\\\','0x07') # temp

    # Find string using a regular expression
    m = re.search("'.*?[^\\\\]'|''", line)
    if not m:
        print("ZON: string not ended correctly on line %i." % linenr)
        return None # return not-a-string
    else:
        line = m.group(0)[1:-1]

    # Decode stuff
    line = line.replace('\\n','\n')
    line = line.replace('\\r','\r')
    line = line.replace('\\x0b', '\x0b').replace('\\x0c', '\x0c')
    line = line.replace("\\'","'")
    line = line.replace('0x07','\\')
    return line
</t>
<t tx="ekr.20190812072050.279">def from_dict(self, value, indent):
    lines = ["dict:"]
    # Process children
    for key, val in value.items():
        # Skip all the builtin stuff
        if key.startswith("__"):
            continue
        # Skip methods, or anything else we can call
        if hasattr(val, '__call__'):
            continue  # Note: py3.x does not have function callable
        # Add!
        lines.extend(self.from_object(key, val, indent+2))
    return lines
</t>
<t tx="ekr.20190812072050.28">## Proxy classes for the file system
class BaseFSProxy(threading.Thread):
    """ Abstract base class for file system proxies.

    The file system proxy defines an interface that subclasses can implement
    to "become" a usable file system proxy.

    This class implements the polling of information for the DirProxy
    and FileProxy objects, and keeping them up-to-date. For this purpose
    it keeps a set of PathProxy instances that are polled when idle.
    There is also a queue for items that need processing asap. This is
    where objects are put in when they are activated.

    This class has methods to use the file system (list files and
    directories, etc.). These can be used directly, but may be slow.
    Therefor it is recommended to use the FileProxy and DirProxy objects
    instead.

    """

    # Define how often the registered dirs and files are checked
    IDLE_TIMEOUT = 1.0

    # For testing to induce extra delay. Should normally be close to zero,
    # but not exactly zero!
    IDLE_DELAY = 0.01
    QUEUE_DELAY = 0.01  # 0.5

    @others
import os
</t>
<t tx="ekr.20190812072050.280">def to_dict(self, data, linenr):
    return Dict()
</t>
<t tx="ekr.20190812072050.281">def from_list(self, value, indent):
    # Collect subdata and check whether this is a "small list"
    isSmallList = True
    allowedTypes = integer_types + float_types + string_types
    subItems = []
    for element in value:
        if not isinstance(element, allowedTypes):
            isSmallList = False
        subdata = self.from_object(None, element, 0)  # No indent
        subItems.extend(subdata)
    isSmallList = isSmallList and len(subItems) &lt; 256

    # Return data
    if isSmallList:
        return '[%s]' % (', '.join(subItems))
    else:
        data = ["list:"]
        ind = ' ' * (indent + 2)
        for item in subItems:
            data.append(ind + item)
        return data
</t>
<t tx="ekr.20190812072050.282">def to_list(self, data, linenr):
    value = []
    if data[0] == 'l': # list:
        return list()
    else:
        i0 = 1
        pieces = []
        inString = False
        escapeThis = False
        line = data
        for i in range(1,len(line)):
            if inString:
                # Detect how to get out
                if escapeThis:
                    escapeThis = False
                    continue
                elif line[i] == "\\":
                    escapeThis = True
                elif line[i] == "'":
                    inString = False
            else:
                # Detect going in a string, break, or end
                if line[i] == "'":
                    inString = True
                elif line[i] == ",":
                    pieces.append(line[i0:i])
                    i0 = i+1
                elif line[i] == "]":
                    piece = line[i0:i]
                    if piece.strip(): # Do not add if empty
                        pieces.append(piece)
                    break
        else:
            print("ZON: short list not closed right on line %i." % linenr)

        # Cut in pieces and process each piece
        value = []
        for piece in pieces:
            v = self.to_object(piece, linenr)
            value.append(v)
        return value
</t>
<t tx="ekr.20190812072050.283">@path pyzo/util/
@others
if __name__ == '__main__':
    # Print names of translator files

    print('Language data files:')
    for key in LANGUAGES:
        s = '{}: {}'.format(key, getLocale(key).name()+'.tr')
        print(s)
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.284"># -*- coding: utf-8 -*-
""" pyzo.util._locale
Module for locale stuff like language and translations.
"""

import os, sys, time

import pyzo
from pyzo.util.qt import QtCore, QtWidgets

QLocale = QtCore.QLocale

# Define supported languages. The key defines the name as shown to the
# user. The value is passed to create a Locale object. From the local
# object we obtain the name for the .tr file.
# Chinese:
LANGUAGES = {
    'English (US)': QLocale.C,
    # == (QLocale.English, QLocale.UnitedStates),
    #'English (UK)': (QLocale.English, QLocale.UnitedKingdom),
    'Dutch': QLocale.Dutch,
    'Spanish': QLocale.Spanish,
    'Catalan': QLocale.Catalan,
    'French': QLocale.French,
    'German': QLocale.German,
    'Russian': QLocale.Russian,  # not updated for 3.4
    'Portuguese': QLocale.Portuguese,
    'Portuguese (BR)': (QLocale.Portuguese, QLocale.Brazil),
    'Simplified Chinese': QLocale.Chinese,
    'Traditional Chinese': (QLocale.Chinese, QLocale.Taiwan),  # https://bugreports.qt.io/browse/QTBUG-1573
    # Languages for which the is a .tr file, but no translations available yet:
    # 'Slovak': QLocale.Slovak,
    }

LANGUAGE_SYNONYMS = {   None: 'English (US)',
                        '': 'English (US)',
                        'English': 'English (US)'}
</t>
<t tx="ekr.20190812072050.285">def getLocale(languageName):
    """ getLocale(languageName)
    Get the QLocale object for the given language (as a string).
    """

    # Apply synonyms
    languageName = LANGUAGE_SYNONYMS.get(languageName, languageName)

    # Select language in qt terms
    qtLanguage = LANGUAGES.get(languageName, None)
    if qtLanguage is None:
        raise ValueError('Unknown language')

    # Return locale
    if isinstance(qtLanguage, tuple):
        return QLocale(*qtLanguage)
    else:
        return QLocale(qtLanguage)
</t>
<t tx="ekr.20190812072050.286">def setLanguage(languageName):
    """ setLanguage(languageName)
    Set the language for the app. Loads qt and pyzo translations.
    Returns the QLocale instance to pass to the main widget.
    """

    # Get locale
    locale = getLocale(languageName)

    # Get paths were language files are
    qtTransPath = str(QtCore.QLibraryInfo.location(
                    QtCore.QLibraryInfo.TranslationsPath))
    pyzoTransPath = os.path.join(pyzo.pyzoDir, 'resources', 'translations')

    # Get possible names for language files
    # (because Qt's .tr files may not have the language component.)
    localeName1 = locale.name()
    localeName2 = localeName1.split('_')[0]

    # Uninstall translators
    if not hasattr(QtCore, '_translators'):
        QtCore._translators = []
    for trans in QtCore._translators:
        QtWidgets.QApplication.removeTranslator(trans)

    # The default language
    if localeName1 == 'C':
        return locale

    # Set Qt translations
    # Note that the translator instances must be stored
    # Note that the load() method is very forgiving with the file name
    for what, where in [('qt', qtTransPath),('pyzo', pyzoTransPath)]:
        trans = QtCore.QTranslator()
        # Try loading both names
        for localeName in [localeName1, localeName2]:
            success = trans.load(what + '_' + localeName + '.tr', where)
            if success:
                QtWidgets.QApplication.installTranslator(trans)
                QtCore._translators.append(trans)
                print('loading %s %s: ok' % (what, languageName))
                break
        else:
            print('loading %s %s: failed' % (what, languageName))

    # Done
    return locale
</t>
<t tx="ekr.20190812072050.287">class Translation(str):
    """ Derives from str class. The translate function returns an instance
    of this class and assigns extra atrributes:
      * original: the original text passed to the translation
      * tt: the tooltip text
      * key: the original text without tooltip (used by menus as a key)

    We adopt a simple system to include tooltip text in the same
    translation as the label text. By including ":::" in the text,
    the text after that identifier is considered the tooltip.
    The text returned by the translate function is always the
    string without tooltip, but the text object has an attribute
    "tt" that stores the tooltip text. In this way, if you do not
    use this feature or do not know about this feature, everything
    keeps working as expected.
    """
    pass
</t>
<t tx="ekr.20190812072050.288">def _splitMainAndTt(s):
        if ':::' in s:
            parts = s.split(':::', 1)
            return parts[0].rstrip(), parts[1].lstrip()
        else:
            return s, ''
</t>
<t tx="ekr.20190812072050.289">def translate(context, text, disambiguation=None):
    """ translate(context, text, disambiguation=None)
    The translate function used throughout pyzo.
    """
    # Get translation and split tooltip
    newtext = QtCore.QCoreApplication.translate(context, text, disambiguation)
    s, tt = _splitMainAndTt(newtext)
    # Create translation object (string with extra attributes)
    translation = Translation(s)
    translation.original = text
    translation.tt = tt
    translation.key = _splitMainAndTt(text)[0].strip()
    return translation

## Development tools
import subprocess

LHELP = """
Language help - info for translaters

For translating, you will need a set of working Qt language tools:
pyside-lupdate, linguist, lrelease. On Windows, these should come
with your PySide installation. On (Ubuntu) Linux, you can install
these with 'sudo apt-get install pyside-tools qt4-dev-tools'.

You also need to run pyzo from source as checked out from the repo
(e.g. by running pyzolauncher.py).

To create a new language:
  * the file 'pyzo/util/locale.py' should be edited to add the language
    to the LANGUAGES dict
  * run 'linguist(your_lang)', this will raise an erro, but it will show
    the name of the .tr file
  * the file 'pyzo/pyzo.pro' should be edited to include the new .tr file
  * run 'lupdate()' to create the .tr file
  * run 'linguist(your_lang)' again to initialize the .tr file.

To update a language:
  * run 'lupdate()'
  * run 'linguist(your_lang)'
  * make all the translations and save
  * run lrelease() and restart pyzo to see translations
  * repeat if necessary

"""
</t>
<t tx="ekr.20190812072050.29">def __init__(self):
    threading.Thread.__init__(self)
    self.setDaemon(True)
    #
    self._interrupt = False
    self._exit = False
    #
    self._lock = threading.RLock()
    self._q = Queue()
    self._pathProxies = set()
    #
    self.start()
</t>
<t tx="ekr.20190812072050.290">def lhelp():
    """ lhelp()
    Print help text on using the language tools.
    """
    print(LHELP)
</t>
<t tx="ekr.20190812072050.291">def linguist(languageName):
    """ linguist(languageName)
    Open linguist with the language file as specified by lang. The
    languageName can be one of the fields as visible in the language
    list in the menu. This function is intended for translators.
    """
    # Get locale
    locale = getLocale(languageName)

    # Get file to open
    fname = 'pyzo_{}.tr'.format(locale.name())
    filename = os.path.join(pyzo.pyzoDir, 'resources', 'translations', fname)
    if not os.path.isfile(filename):
        raise ValueError('Could not find {}'.format(filename))

    # Get Command for linguist
    pysideDir = os.path.abspath(os.path.dirname(pyzo.QtCore.__file__))
    ISWIN = sys.platform.startswith('win')
    exe_ = 'linguist' + '.exe' * ISWIN
    exe = os.path.join(pysideDir, exe_)
    if not os.path.isfile(exe):
        exe = exe_

    # Spawn process
    return subprocess.Popen([exe , filename])
</t>
<t tx="ekr.20190812072050.292">def lupdate():
    """ For developers. From pyzo.pro create the .tr files
    """
    # Get file to open
    fname = 'pyzo.pro'
    filename = os.path.realpath(os.path.join(pyzo.pyzoDir, '..', fname))
    if not os.path.isfile(filename):
        raise ValueError('Could not find {}. This function must run from the source repo.'.format(fname))

    # Get Command for python lupdate
    pysideDir = os.path.abspath(os.path.dirname(pyzo.QtCore.__file__))
    ISWIN = sys.platform.startswith('win')
    exe_ = 'pylupdate' + pyzo.QtCore.__version__[0] + '.exe' * ISWIN
    exe = os.path.join(pysideDir, exe_)
    if not os.path.isfile(exe):
        exe = exe_

    # Spawn process
    cmd = [exe, '-noobsolete', '-verbose', filename]
    p = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    while p.poll() is None:
        time.sleep(0.1)
    output =  p.stdout.read().decode('utf-8')
    if p.returncode:
        raise RuntimeError('lupdate failed (%i): %s' % (p.returncode, output))
    else:
        print(output)
</t>
<t tx="ekr.20190812072050.293">def lrelease():
    """ For developers. From pyzo.pro and the .tr files, create the .qm files.
    """
    # Get file to open
    fname = 'pyzo.pro'
    filename = os.path.realpath(os.path.join(pyzo.pyzoDir, '..', fname))
    if not os.path.isfile(filename):
        raise ValueError('Could not find {}. This function must run from the source repo.'.format(fname))

    # Get Command for lrelease
    pysideDir = os.path.abspath(os.path.dirname(pyzo.QtCore.__file__))
    ISWIN = sys.platform.startswith('win')
    exe_ = 'lrelease' + '.exe' * ISWIN
    exe = os.path.join(pysideDir, exe_)
    if not os.path.isfile(exe):
        exe = exe_

    # Spawn process
    cmd = [exe, filename]
    p = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    while p.poll() is None:
        time.sleep(0.1)
    output =  p.stdout.read().decode('utf-8')
    if p.returncode:
        raise RuntimeError('lrelease failed (%i): %s' % (p.returncode, output))
    else:
        print(output)
</t>
<t tx="ekr.20190812072050.294">@path pyzo/util/
# Extra line, so perfect import will work.
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.295">try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('IMPORT pyzo.util')
except Exception:
    leo_g = None
</t>
<t tx="ekr.20190812072050.297"></t>
<t tx="ekr.20190812072050.298">@path pyzo/util/interpreters/
# -*- coding: utf-8 -*-
# Copyright (c) 2016, Almar Klein
@others
if __name__ == '__main__':

    for v in get_interpreters_in_reg():
        print(v)
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.299">"""
This module implements functionality to obtain registered
Python interpreters and to register a Python interpreter in the Windows
registry.

"""

import sys
import os
try:
    import winreg
except ImportError:
    winreg = None

PYTHON_KEY = 'SOFTWARE\\Python\\PythonCore'
PYTHON_KEY_WOW64 = 'SOFTWARE\\Wow6432Node\\Python\\PythonCore'
INSTALL_KEY = "InstallPath"
PATH_KEY = "PythonPath"


</t>
<t tx="ekr.20190812072050.3">class Task:
    """ Task(**params)

    A task object. Accepts params as keyword arguments.
    When overloading, dont forget to set __slots__.

    Overload and implement the 'process' method to create a task.
    Then use pushTask on a pathProxy object. Use the 'result' method to
    obtain the result (or raise an error).
    """
    __slots__ = ['_params', '_result', '_error']

    @others
</t>
<t tx="ekr.20190812072050.30">def _track(self, pathProxy):
    # todo: use weak references
    with self._lock:
        self._pathProxies.add(pathProxy)
</t>
<t tx="ekr.20190812072050.300">class PythonInReg:
    """ Class to represent a specific version of the Python interpreter
    registered (or being registered in the registry).
    This is a helper class for the functions defined in this module; it
    should not be instantiated directly.
    """

    USER_ONE = 1
    USER_ALL = 2

    @others
</t>
<t tx="ekr.20190812072050.301">def __init__(self, user, version, wow64=False):
    self._user = user
    self._key = (wow64 and PYTHON_KEY_WOW64 or PYTHON_KEY) + '\\' + version
</t>
<t tx="ekr.20190812072050.302">def __repr__(self):
    userstr = [None, 'USER_ONE', 'USER_ALL'][self._user]
    installPath = self.installPath()
    reg = self._reg()
    if not reg:
        return '&lt;PythonInReg %s at %s (unregistered)&gt;' % (self.version(), userstr)
    elif installPath:
        return '&lt;PythonInReg %s at %s in "%s"&gt;' % (self.version(), userstr, installPath)
    else:
        return '&lt;PythonInReg %s at %s&gt;' % (self.version(), userstr)
</t>
<t tx="ekr.20190812072050.303">def _root(self):
    if self._user == PythonInReg.USER_ONE:
        return winreg.HKEY_CURRENT_USER
    else:
        return winreg.HKEY_LOCAL_MACHINE
</t>
<t tx="ekr.20190812072050.304">def _reg(self):
    # Get key for this version
    try:
        return winreg.OpenKey(self._root(), self._key, 0, winreg.KEY_READ)
    except Exception:
        return None
</t>
<t tx="ekr.20190812072050.305">def create(self):
    """ Create key. If already exists, does nothing.
    """

    # Get key for this version
    reg = self._reg()

    if reg:
        winreg.CloseKey(reg)
        #print('Unable to create Python version %s: already exists.' % self.version())

    else:
        # Try to create
        try:
            reg = winreg.CreateKey(self._root(), self._key)
            winreg.CloseKey(reg)
        except Exception:
            raise RuntimeError('Unable to create python version %s.' % self.version())
        print('Created %s.' % str(self))
</t>
<t tx="ekr.20190812072050.306">def delete(self):

    # Get key for this version
    reg = self._reg()
    if not reg:
        print('Unable to delete Python version %s: does not exist.')

    # Delete attributes
    try:
        winreg.DeleteKey(reg, INSTALL_KEY)
    except Exception:
        pass
    try:
        winreg.DeleteKey(reg, PATH_KEY)
    except Exception:
        pass

    # Delete main key for this version, or show warning
    try:
        winreg.DeleteKey(self._root(), self._key)
    except Exception:
        print('Could not delete %s.' % str(self))
        return
    print('Deleted %s.' % str(self))
</t>
<t tx="ekr.20190812072050.307">def setInstallPath(self, installPath):
    # Get key for this version
    reg = self._reg()
    if not reg:
        raise RuntimeError('Could not set installPath for version %s: version does not exist.' % self.version())

    # Set value or raise error
    try:
        winreg.SetValue(reg, INSTALL_KEY, winreg.REG_SZ, installPath)
        winreg.CloseKey(reg)
    except Exception:
        winreg.CloseKey(reg)
        raise RuntimeError('Could not set installPath for %s.' % str(self))
</t>
<t tx="ekr.20190812072050.308">def installPath(self):
    # Get key for this version
    reg = self._reg()
    if not reg:
        return None

    # Get value or return None
    try:
        installPath = winreg.QueryValue(reg, INSTALL_KEY)
        winreg.CloseKey(reg)
        return installPath
    except Exception:
        winreg.CloseKey(reg)
        return None
</t>
<t tx="ekr.20190812072050.309">def setPythonPath(self, pythonPath):
    # Get key for this version
    reg = self._reg()
    if not reg:
        raise RuntimeError('Could not set pythonPath for version %s: version does not exist.' % self.version())

    # Set value or raise error
    try:
        winreg.SetValue(reg, PATH_KEY, winreg.REG_SZ, pythonPath)
        winreg.CloseKey(reg)
    except Exception:
        winreg.CloseKey(reg)
        raise RuntimeError('Could not set pythonPath for %s.' % str(self))
</t>
<t tx="ekr.20190812072050.31">def _unTrack(self, pathProxy):
    with self._lock:
        self._pathProxies.discard(pathProxy)
</t>
<t tx="ekr.20190812072050.310">def pythonPath(self):
    # Get key for this version
    reg = self._reg()
    if not reg:
        return None

    # Get value or return None
    try:
        pythonPath = winreg.QueryValue(reg, PATH_KEY)
        winreg.CloseKey(reg)
        return pythonPath
    except Exception:
        winreg.CloseKey(reg)
        return None
</t>
<t tx="ekr.20190812072050.311">def version(self):
    """ Get the Python version.
    """
    return self._key[-3:]
</t>
<t tx="ekr.20190812072050.312">def get_interpreters_in_reg():
    """ get_interpreters_in_reg()
    Get a list of PythonInReg instances: one for each interpreter
    in the registry. This function checks both LOCAL_MACHINE and CURRENT_USER.
    """
    versions = []
    for user in [1, 2]:
        for wow64 in [False, True]:
            versions.extend( _get_interpreter_in_reg(user, wow64) )
    return versions
</t>
<t tx="ekr.20190812072050.313">def _get_interpreter_in_reg(user, wow64=False):

    # Get base key
    if user == PythonInReg.USER_ONE:
        HKEY = winreg.HKEY_CURRENT_USER
    else:
        HKEY = winreg.HKEY_LOCAL_MACHINE

    # Get Python key
    if wow64:
        PYKEY = PYTHON_KEY_WOW64
    else:
        PYKEY = PYTHON_KEY

    # Try to open Python key
    try:
        reg = winreg.OpenKey(HKEY, PYKEY, 0, winreg.KEY_READ)
    except Exception:
        return []

    # Get info about subkeys
    nsub, nval, modified = winreg.QueryInfoKey(reg)

    # Query all
    versions = []
    for i in range(nsub):
        # Get name and subkey
        version = winreg.EnumKey(reg, i)
        versions.append( PythonInReg(user, version, wow64) )

    # Done
    winreg.CloseKey(reg)
    return versions
</t>
<t tx="ekr.20190812072050.314">def register_interpreter(version=None, installPath=None, user=None, wow64=False):
    """ register_interpreter(version=None, installPath=None, user=None, wow64=False)
    Register a certain Python version. If version and installPath
    are not given, the current Python process is registered.
    if user is not given, tries LOCAL_MACHINE first but uses CURRENT_USER
    if that fails.
    """
    if version is None:
        version = sys.version[:3]
    if installPath is None:
        installPath = sys.prefix

    # Get existing versions
    existingVersions = get_interpreters_in_reg()

    # Determine what users to try
    if user is None:
        users = [2, 1]
    else:
        users = [user]

    success = False

    for user in users:

        # Create new PythonInReg instance
        v = PythonInReg(user, version, wow64)

        # Check if already exists
        ok = True
        for ev in existingVersions:
            if ev._key != v._key or ev._user != v._user:
                continue # Different key; no problem
            if (not ev.installPath()) or (not os.path.isdir(ev.installPath())):
                continue # Key the same, but existing entry is invalid
            if ev.installPath() == installPath:
                # Exactly the same, no action required, return now!
                return ev
            # Ok, there's a problem
            ok = False
            print('Warning: version %s is already installed in "%s".'
                                            % (version, ev.installPath()))
        if not ok:
            continue

        # Try to create the key
        try:
            v.create()
            v.setInstallPath(installPath)
            success = True
            break
        except RuntimeError:
            continue

    if success:
        return v
    else:
        raise RuntimeError('Could not register Python version %s at %s.'
                                    % (version, installPath))
</t>
<t tx="ekr.20190812072050.315">@path pyzo/util/interpreters/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.316">import os
import sys
import subprocess

from .inwinreg import register_interpreter

EXE_DIR = os.path.abspath(os.path.dirname(sys.executable))
if EXE_DIR.endswith('.app/Contents/MacOS'):
    EXE_DIR = os.path.dirname(EXE_DIR.rsplit('.app')[0])
</t>
<t tx="ekr.20190812072050.317">def make_abs(path):
    if path.startswith('.'):
        return os.path.abspath(os.path.join(EXE_DIR, path))
    return path
</t>
<t tx="ekr.20190812072050.318">class PythonInterpreter:
    """ Class to represent a Python interpreter. It has properties
    to get the path and version. Upon creation the version number is
    acquired by calling the interpreter in a subprocess. If this fails,
    the version becomes ''.

    """
    @others
</t>
<t tx="ekr.20190812072050.319">def __init__(self, path):
    if not isinstance(path, str):
        raise ValueError('Path for PythonInterpreter is not a string: %r' % path)
    if not os.path.isfile(make_abs(path)):
        raise ValueError('Path for PythonInterpreter is invalid: %r' % path)
    self._path = path if path.startswith('.') else os.path.normpath(os.path.abspath(path))
    self._normpath = os.path.normcase(self._path)
    self._problem = ''
    self._version = None
    # Set prefix
    self._prefix = os.path.dirname(self.path)
    if os.path.basename(self._prefix) == 'bin':
        self._prefix = os.path.dirname(self._prefix)
</t>
<t tx="ekr.20190812072050.32">def _push(self, pathProxy):
    # todo: use weak ref here too?
    self._q.put(pathProxy)
    self._interrupt = True
</t>
<t tx="ekr.20190812072050.320">def __repr__(self):
    cls_name = self.__class__.__name__
    return '&lt;%s version %s at %s&gt;' % (cls_name, self.version, self.path)
</t>
<t tx="ekr.20190812072050.321">def __hash__(self):
    return hash(self._normpath)
</t>
<t tx="ekr.20190812072050.322">def __eq__(self, other):
    return self._normpath == other._normpath
</t>
<t tx="ekr.20190812072050.323">@property
def path(self):
    """ The path to the executable of the Python interpreter.
    If relative (starting with a dot), it is relative to the current
    sys.executable.
    """
    return self._path
</t>
<t tx="ekr.20190812072050.324">@property
def prefix(self):
    """ The prefix of this executable.
    """
    return self._prefix
</t>
<t tx="ekr.20190812072050.325">@property
def is_conda(self):
    """ Whether this interpreter is part of a conda environment (either
    a root or an env).
    """
    return os.path.isdir(os.path.join(make_abs(self._prefix), 'conda-meta'))
</t>
<t tx="ekr.20190812072050.326">@property
def version(self):
    """ The version number as a string, usually 3 numbers.
    """
    if self._version is None:
        self._version = self._getversion()
    return self._version
</t>
<t tx="ekr.20190812072050.327">@property
def version_info(self):
    """ The version number as a tuple of integers. For comparing.
    """
    return versionStringToTuple(self.version)
</t>
<t tx="ekr.20190812072050.328">def register(self):
    """ Register this Python intepreter. On Windows this modifies
    the CURRENT_USER. On All other OS's this is a no-op.
    """
    if sys.platform.startswith('win'):
        path = os.path.split(make_abs(self.path))[0] # Remove "python.exe"
        register_interpreter(self.version[:3], path)
</t>
<t tx="ekr.20190812072050.329">def _getversion(self):
    path = make_abs(self._path)

    # Check if path is even a file
    if not os.path.isfile(path):
        self._problem = '%s is not a valid file.'
        return ''

    # Poll Python executable (--version does not work on 2.4)
    # shell=True prevents loads of command windows popping up on Windows,
    # but if used on Linux it would enter interpreter mode
    cmd = [path, '-V']
    try:
        v = subprocess.check_output(cmd, stderr=subprocess.STDOUT,
                                    shell=sys.platform.startswith('win'))
    except (OSError, IOError, subprocess.CalledProcessError) as e:
        self._problem = str(e)
        return ''

    # Extract the version, apply some defensive programming
    v = v.decode('ascii','ignore').strip().lower()
    if v.startswith('python'):
        v = v.split(' ')[1]
    v = v.split(' ')[0]

    # Try turning it into version_info
    try:
        versionStringToTuple(v)
    except ValueError:
        return ''

    # Done
    return v
</t>
<t tx="ekr.20190812072050.33">def stop(self, *, timeout=1.0):
    with self._lock:
        self._exit = True
        self._interrupt = True
        self._pathProxies.clear()
    self.join(timeout)
</t>
<t tx="ekr.20190812072050.330">def versionStringToTuple(version):
    # Truncate version number to first occurance of non-numeric character
    tversion = ''
    for c in version:
        if c in '0123456789.':  tversion += c
    # Split by dots, make each number an integer
    tversion = tversion.strip('.')
    return tuple( [int(a) for a in tversion.split('.') if a] )
</t>
<t tx="ekr.20190812072050.331">@path pyzo/util/interpreters/
# -*- coding: utf-8 -*-
# Copyright (c) 2016, Almar Klein
@others
if __name__ == '__main__':
    for pi in get_interpreters():
        print(pi)
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.332">"""
This module implements functionality to detect available Python
interpreters. This is done by looking at common locations, the Windows
registry, and conda's environment list.
"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('IMPORT pyzo.util.interpreters')
except Exception:
    leo_g = None

import sys
import os
from .pythoninterpreter import EXE_DIR, PythonInterpreter, versionStringToTuple
from .inwinreg import get_interpreters_in_reg
from .. import paths
</t>
<t tx="ekr.20190812072050.333">def get_interpreters(minimumVersion=None):
    """ get_interpreters(minimumVersion=None)
    Returns a list of PythonInterpreter instances.
    If minimumVersion is given, return only the interprers with at least that
    version, and also sort the result by version number.
    """

    # Get Python interpreters
    if sys.platform.startswith('win'):
        pythons = _get_interpreters_win()
    else:
        pythons = _get_interpreters_posix()
    pythons = set([PythonInterpreter(p) for p in pythons])

    # Get conda paths
    condas = set([PythonInterpreter(p) for p in _get_interpreters_conda()])

    # Get relative interpreters
    relative = set([PythonInterpreter(p) for p in _get_interpreters_relative()])

    # Get Pyzo paths
    pyzos = set([PythonInterpreter(p) for p in _get_interpreters_pyzo()])

    # Almost done
    interpreters = set.union(pythons, condas, relative, pyzos)
    minimumVersion = minimumVersion or '0'
    return _select_interpreters(interpreters, minimumVersion)
</t>
<t tx="ekr.20190812072050.334">def _select_interpreters(interpreters, minimumVersion):
    """ Given a list of PythonInterpreter instances, return a list with
    the interpreters selected that are valid and have their version equal
    or larger than the given minimimVersion. The returned list is sorted
    by version number.
    """
    if not isinstance(minimumVersion, str):
        raise ValueError('minimumVersion in get_interpreters must be a string.')
    # Remove invalid interpreters
    interpreters = [i for i in interpreters if i.version]
    # Remove the ones below the reference version
    if minimumVersion is not None:
        refTuple = versionStringToTuple(minimumVersion)
        interpreters = [i for i in interpreters if (i.version_info &gt;= refTuple)]
    # Return, sorted by version
    return sorted(interpreters, key=lambda x:x.version_info)
</t>
<t tx="ekr.20190812072050.335">def _get_interpreters_win():
    found = []

    # Query from registry
    for v in get_interpreters_in_reg():
        found.append(v.installPath() )

    # Check common locations
    for rootname in ['C:/', '~/',
                     'C:/program files/', 'C:/program files (x86)/', 'C:/ProgramData/',
                     '~/appdata/local/programs/python/',
                     '~/appdata/local/continuum/', '~/appdata/local/anaconda/',
                     ]:
        rootname = os.path.expanduser(rootname)
        if not os.path.isdir(rootname):
            continue
        for dname in os.listdir(rootname):
            if dname.lower().startswith(('python', 'pypy', 'miniconda', 'anaconda')):
                found.append(os.path.join(rootname, dname))

    # Normalize all paths, and remove trailing backslashes
    found = [os.path.normcase(os.path.abspath(v)).strip('\\') for v in found]

    # Append "python.exe" and check if that file exists
    found2 = []
    for dname in found:
        for fname in ('python.exe', 'pypy.exe'):
            exename = os.path.join(dname, fname)
            if os.path.isfile(exename):
                found2.append(exename)
                break

    # Returnas set (remove duplicates)
    return set(found2)
</t>
<t tx="ekr.20190812072050.336">def _get_interpreters_posix():
    found=[]

    # Look for system Python interpreters
    for searchpath in ['/usr/bin','/usr/local/bin','/opt/local/bin']:
        searchpath = os.path.expanduser(searchpath)

        # Get files
        try:
            files = os.listdir(searchpath)
        except Exception:
            continue

        # Search for python executables
        for fname in files:
            if fname.startswith(('python', 'pypy')) and not fname.count('config'):
                if len(fname) &lt; 16:
                    # Get filename and resolve symlink
                    filename = os.path.join(searchpath, fname)
                    filename = os.path.realpath(filename)
                    # Seen on OS X that was not a valid file
                    if os.path.isfile(filename):
                        found.append(filename)

    # Look for user-installed Python interpreters such as pypy and anaconda
    for rootname in ['~', '/usr/local']:
        rootname = os.path.expanduser(rootname)
        if not os.path.isdir(rootname):
            continue
        for dname in os.listdir(rootname):
            if dname.lower().startswith(('python', 'pypy', 'miniconda', 'anaconda')):
                for fname in ('bin/python', 'bin/pypy'):
                    exename = os.path.join(rootname, dname, fname)
                    if os.path.isfile(exename):
                        found.append(exename)

    # Remove pythonw, pythonm and the like
    found = set(found)
    for path in list(found):
        if path.endswith(('m', 'w')) and path[:-1] in found:
            found.discard(path)

    # Return as set (remove duplicates)
    return set(found)
</t>
<t tx="ekr.20190812072050.337">def _get_interpreters_pyzo():
    """ Get a list of known Pyzo interpreters.
    """
    pythonname = 'python' + '.exe' * sys.platform.startswith('win')
    exes = []
    for d in paths.pyzo_dirs():
        for fname in [  os.path.join(d, 'bin', pythonname + '3'),
                        os.path.join(d, pythonname), ]:
            if os.path.isfile(fname):
                exes.append(fname)
                break
    return exes
</t>
<t tx="ekr.20190812072050.338">def _get_interpreters_conda():
    """ Get known conda environments
    """
    if sys.platform.startswith('win'):
        pythonname = 'python' + '.exe'
    else:
        pythonname = 'bin/python'

    exes = []
    filename = os.path.expanduser('~/.conda/environments.txt')
    if os.path.isfile(filename):
        for line in open(filename, 'rt').readlines():
            line = line.strip()
            exe_filename = os.path.join(line, pythonname)
            if line and os.path.isfile(exe_filename):
                exes.append(exe_filename)
    return exes
</t>
<t tx="ekr.20190812072050.339">def _get_interpreters_relative():
    """ Get interpreters relative to our prefix and the parent directory.
    This allows Pyzo to be shipped inside a pre-installed conda env.
    """
    pythonname = 'python' + '.exe' * sys.platform.startswith('win')
    exes = []
    for d in ['.', '..']:
        for fname in [  os.path.join(d, 'bin', pythonname),
                        os.path.join(d, pythonname), ]:
            filename = os.path.abspath(os.path.join(EXE_DIR, fname))
            if os.path.isfile(filename):
                exes.append(fname)
                break
    return exes
</t>
<t tx="ekr.20190812072050.34">def dir(self, path):
    """ Convenience function to create a new DirProxy object.
    """
    return DirProxy(self, path)
</t>
<t tx="ekr.20190812072050.341"></t>
<t tx="ekr.20190812072050.342">@path pyzo/util/qt/
@nopyflakes
# -*- coding: utf-8 -*-
#
# Copyright  2014-2015 Colin Duquesnoy
# Copyright  2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)

@others
if PYQT5:
    from PyQt5.QtCore import *
    from PyQt5.QtCore import pyqtSignal as Signal
    from PyQt5.QtCore import pyqtSlot as Slot
    from PyQt5.QtCore import pyqtProperty as Property
    from PyQt5.QtCore import QT_VERSION_STR as __version__

    # Those are imported from `import *`
    del pyqtSignal, pyqtSlot, pyqtProperty, QT_VERSION_STR
elif PYSIDE2:
    from PySide2.QtCore import *
    try:  # may be limited to PySide-5.11a1 only
        from PySide2.QtGui import QStringListModel
    except:
        pass
elif PYQT4:
    from PyQt4.QtCore import *
    # Those are things we inherited from Spyder that fix crazy crashes under
    # some specific situations. (See #34)
    from PyQt4.QtCore import QCoreApplication
    from PyQt4.QtCore import Qt
    from PyQt4.QtCore import pyqtSignal as Signal
    from PyQt4.QtCore import pyqtSlot as Slot
    from PyQt4.QtCore import pyqtProperty as Property
    from PyQt4.QtGui import (QItemSelection, QItemSelectionModel,
                             QItemSelectionRange, QSortFilterProxyModel,
                             QStringListModel)
    from PyQt4.QtCore import QT_VERSION_STR as __version__
    from PyQt4.QtCore import qInstallMsgHandler as qInstallMessageHandler

    # QDesktopServices has has been split into (QDesktopServices and
    # QStandardPaths) in Qt5
    # This creates a dummy class that emulates QStandardPaths
    from PyQt4.QtGui import QDesktopServices as _QDesktopServices

    class QStandardPaths():
        StandardLocation = _QDesktopServices.StandardLocation
        displayName = _QDesktopServices.displayName
        DesktopLocation = _QDesktopServices.DesktopLocation
        DocumentsLocation = _QDesktopServices.DocumentsLocation
        FontsLocation = _QDesktopServices.FontsLocation
        ApplicationsLocation = _QDesktopServices.ApplicationsLocation
        MusicLocation = _QDesktopServices.MusicLocation
        MoviesLocation = _QDesktopServices.MoviesLocation
        PicturesLocation = _QDesktopServices.PicturesLocation
        TempLocation = _QDesktopServices.TempLocation
        HomeLocation = _QDesktopServices.HomeLocation
        DataLocation = _QDesktopServices.DataLocation
        CacheLocation = _QDesktopServices.CacheLocation
        writableLocation = _QDesktopServices.storageLocation

    # Those are imported from `import *`
    del pyqtSignal, pyqtSlot, pyqtProperty, QT_VERSION_STR, qInstallMsgHandler
elif PYSIDE:
    from PySide.QtCore import *
    from PySide.QtGui import (QItemSelection, QItemSelectionModel,
                              QItemSelectionRange, QSortFilterProxyModel,
                              QStringListModel)
    from PySide.QtCore import qInstallMsgHandler as qInstallMessageHandler
    del qInstallMsgHandler

    # QDesktopServices has has been split into (QDesktopServices and
    # QStandardPaths) in Qt5
    # This creates a dummy class that emulates QStandardPaths
    from PySide.QtGui import QDesktopServices as _QDesktopServices

    class QStandardPaths():
        StandardLocation = _QDesktopServices.StandardLocation
        displayName = _QDesktopServices.displayName
        DesktopLocation = _QDesktopServices.DesktopLocation
        DocumentsLocation = _QDesktopServices.DocumentsLocation
        FontsLocation = _QDesktopServices.FontsLocation
        ApplicationsLocation = _QDesktopServices.ApplicationsLocation
        MusicLocation = _QDesktopServices.MusicLocation
        MoviesLocation = _QDesktopServices.MoviesLocation
        PicturesLocation = _QDesktopServices.PicturesLocation
        TempLocation = _QDesktopServices.TempLocation
        HomeLocation = _QDesktopServices.HomeLocation
        DataLocation = _QDesktopServices.DataLocation
        CacheLocation = _QDesktopServices.CacheLocation
        writableLocation = _QDesktopServices.storageLocation

    import PySide.QtCore
    __version__ = PySide.QtCore.__version__
else:
    raise PythonQtError('No Qt bindings could be found')
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.343">"""
Provides QtCore classes and functions.
"""

from . import PYQT5, PYSIDE2, PYQT4, PYSIDE, PythonQtError
</t>
<t tx="ekr.20190812072050.344">@path pyzo/util/qt/
@nopyflakes
# -*- coding: utf-8 -*-
#
# Copyright  2014-2015 Colin Duquesnoy
# Copyright  2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)

@others
if PYQT5:
    from PyQt5.QtGui import *
elif PYSIDE2:
    from PySide2.QtGui import *
elif PYQT4:
    try:
        # Older versions of PyQt4 do not provide these
        from PyQt4.QtGui import (QGlyphRun, QMatrix2x2, QMatrix2x3,
                                 QMatrix2x4, QMatrix3x2, QMatrix3x3,
                                 QMatrix3x4, QMatrix4x2, QMatrix4x3,
                                 QMatrix4x4, QTouchEvent, QQuaternion,
                                 QRadialGradient, QRawFont, QStaticText,
                                 QVector2D, QVector3D, QVector4D,
                                 qFuzzyCompare)
    except ImportError:
        pass
    from PyQt4.Qt import QKeySequence, QTextCursor
    from PyQt4.QtGui import (QAbstractTextDocumentLayout, QActionEvent, QBitmap,
                             QBrush, QClipboard, QCloseEvent, QColor,
                             QConicalGradient, QContextMenuEvent, QCursor,
                             QDoubleValidator, QDrag,
                             QDragEnterEvent, QDragLeaveEvent, QDragMoveEvent,
                             QDropEvent, QFileOpenEvent, QFocusEvent, QFont,
                             QFontDatabase, QFontInfo, QFontMetrics,
                             QFontMetricsF, QGradient, QHelpEvent,
                             QHideEvent, QHoverEvent, QIcon, QIconDragEvent,
                             QIconEngine, QImage, QImageIOHandler, QImageReader,
                             QImageWriter, QInputEvent, QInputMethodEvent,
                             QKeyEvent, QLinearGradient,
                             QMouseEvent, QMoveEvent, QMovie,
                             QPaintDevice, QPaintEngine, QPaintEngineState,
                             QPaintEvent, QPainter, QPainterPath,
                             QPainterPathStroker, QPalette, QPen, QPicture,
                             QPictureIO, QPixmap, QPixmapCache, QPolygon,
                             QPolygonF, QRegExpValidator, QRegion, QResizeEvent,
                             QSessionManager, QShortcutEvent, QShowEvent,
                             QStandardItem, QStandardItemModel,
                             QStatusTipEvent, QSyntaxHighlighter, QTabletEvent,
                             QTextBlock, QTextBlockFormat, QTextBlockGroup,
                             QTextBlockUserData, QTextCharFormat,
                             QTextDocument, QTextDocumentFragment,
                             QTextDocumentWriter, QTextFormat, QTextFragment,
                             QTextFrame, QTextFrameFormat, QTextImageFormat,
                             QTextInlineObject, QTextItem, QTextLayout,
                             QTextLength, QTextLine, QTextList, QTextListFormat,
                             QTextObject, QTextObjectInterface, QTextOption,
                             QTextTable, QTextTableCell, QTextTableCellFormat,
                             QTextTableFormat, QTransform,
                             QValidator, QWhatsThisClickedEvent, QWheelEvent,
                             QWindowStateChangeEvent, qAlpha, qBlue,
                             qGray, qGreen, qIsGray, qRed, qRgb,
                             qRgba, QIntValidator)

    # QDesktopServices has has been split into (QDesktopServices and
    # QStandardPaths) in Qt5
    # It only exposes QDesktopServices that are still in pyqt5
    from PyQt4.QtGui import QDesktopServices as _QDesktopServices

    class QDesktopServices():
        openUrl = _QDesktopServices.openUrl
        setUrlHandler = _QDesktopServices.setUrlHandler
        unsetUrlHandler = _QDesktopServices.unsetUrlHandler

        def __getattr__(self, name):
            attr = getattr(_QDesktopServices, name)

            new_name = name
            if name == 'storageLocation':
                new_name = 'writableLocation'
            warnings.warn(("Warning QDesktopServices.{} is deprecated in Qt5"
                            "we recommend you use QDesktopServices.{} instead").format(name, new_name),
                           DeprecationWarning)
            return attr
    QDesktopServices = QDesktopServices()

elif PYSIDE:
    from PySide.QtGui import (QAbstractTextDocumentLayout, QActionEvent, QBitmap,
                              QBrush, QClipboard, QCloseEvent, QColor,
                              QConicalGradient, QContextMenuEvent, QCursor,
                              QDoubleValidator, QDrag,
                              QDragEnterEvent, QDragLeaveEvent, QDragMoveEvent,
                              QDropEvent, QFileOpenEvent, QFocusEvent, QFont,
                              QFontDatabase, QFontInfo, QFontMetrics,
                              QFontMetricsF, QGradient, QHelpEvent,
                              QHideEvent, QHoverEvent, QIcon, QIconDragEvent,
                              QIconEngine, QImage, QImageIOHandler, QImageReader,
                              QImageWriter, QInputEvent, QInputMethodEvent,
                              QKeyEvent, QKeySequence, QLinearGradient,
                              QMatrix2x2, QMatrix2x3, QMatrix2x4, QMatrix3x2,
                              QMatrix3x3, QMatrix3x4, QMatrix4x2, QMatrix4x3,
                              QMatrix4x4, QMouseEvent, QMoveEvent, QMovie,
                              QPaintDevice, QPaintEngine, QPaintEngineState,
                              QPaintEvent, QPainter, QPainterPath,
                              QPainterPathStroker, QPalette, QPen, QPicture,
                              QPictureIO, QPixmap, QPixmapCache, QPolygon,
                              QPolygonF, QQuaternion, QRadialGradient,
                              QRegExpValidator, QRegion, QResizeEvent,
                              QSessionManager, QShortcutEvent, QShowEvent,
                              QStandardItem, QStandardItemModel,
                              QStatusTipEvent, QSyntaxHighlighter, QTabletEvent,
                              QTextBlock, QTextBlockFormat, QTextBlockGroup,
                              QTextBlockUserData, QTextCharFormat, QTextCursor,
                              QTextDocument, QTextDocumentFragment,
                              QTextFormat, QTextFragment,
                              QTextFrame, QTextFrameFormat, QTextImageFormat,
                              QTextInlineObject, QTextItem, QTextLayout,
                              QTextLength, QTextLine, QTextList, QTextListFormat,
                              QTextObject, QTextObjectInterface, QTextOption,
                              QTextTable, QTextTableCell, QTextTableCellFormat,
                              QTextTableFormat, QTouchEvent, QTransform,
                              QValidator, QVector2D, QVector3D, QVector4D,
                              QWhatsThisClickedEvent, QWheelEvent,
                              QWindowStateChangeEvent, qAlpha, qBlue,
                              qGray, qGreen, qIsGray, qRed, qRgb, qRgba,
                              QIntValidator)
    # QDesktopServices has has been split into (QDesktopServices and
    # QStandardPaths) in Qt5
    # It only exposes QDesktopServices that are still in pyqt5
    from PySide.QtGui import QDesktopServices as _QDesktopServices

    class QDesktopServices():
        openUrl = _QDesktopServices.openUrl
        setUrlHandler = _QDesktopServices.setUrlHandler
        unsetUrlHandler = _QDesktopServices.unsetUrlHandler

        def __getattr__(self, name):
            attr = getattr(_QDesktopServices, name)

            new_name = name
            if name == 'storageLocation':
                new_name = 'writableLocation'
            warnings.warn(("Warning QDesktopServices.{} is deprecated in Qt5"
                            "we recommend you use QDesktopServices.{} instead").format(name, new_name),
                           DeprecationWarning)
            return attr
    QDesktopServices = QDesktopServices()
else:
    raise PythonQtError('No Qt bindings could be found')
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.345">"""
Provides QtGui classes and functions.
.. warning:: Only PyQt4/PySide QtGui classes compatible with PyQt5.QtGui are
    exposed here. Therefore, you need to treat/use this package as if it were
    the ``PyQt5.QtGui`` module.
"""
import warnings

from . import PYQT5, PYQT4, PYSIDE, PYSIDE2, PythonQtError
</t>
<t tx="ekr.20190812072050.346">@path pyzo/util/qt/
# -*- coding: utf-8 -*-
#
# Copyright  2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)

@others
if PYQT5:
    from PyQt5.QtHelp import *
elif PYSIDE2:
    from PySide2.QtHelp import *
elif PYQT4:
    from PyQt4.QtHelp import *
elif PYSIDE:
    from PySide.QtHelp import *
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072050.347">"""QtHelp Wrapper."""

import warnings

from . import PYQT5
from . import PYQT4
from . import PYSIDE
from . import PYSIDE2
</t>
<t tx="ekr.20190812072050.348">@path pyzo/util/qt/
# -*- coding: utf-8 -*-
#
# Copyright  2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)

@others
if PYQT5:
    from PyQt5.QtPrintSupport import *
elif PYSIDE2:
    from PySide2.QtPrintSupport import *
elif PYQT4:
    from PyQt4.QtGui import (QAbstractPrintDialog, QPageSetupDialog,
                             QPrintDialog, QPrintEngine, QPrintPreviewDialog,
                             QPrintPreviewWidget, QPrinter, QPrinterInfo)
elif PYSIDE:
    from PySide.QtGui import (QAbstractPrintDialog, QPageSetupDialog,
                              QPrintDialog, QPrintEngine, QPrintPreviewDialog,
                              QPrintPreviewWidget, QPrinter, QPrinterInfo)
else:
    raise PythonQtError('No Qt bindings could be found')
@language python
@tabwidth -4
@nopyflakes
</t>
<t tx="ekr.20190812072050.349">"""
Provides QtPrintSupport classes and functions.
"""

from . import PYQT5, PYQT4,PYSIDE2, PYSIDE, PythonQtError
</t>
<t tx="ekr.20190812072050.35">def file(self, path):
    """ Convenience function to create a new FileProxy object.
    """
    return FileProxy(self, path)
</t>
<t tx="ekr.20190812072050.350">@path pyzo/util/qt/
@nopyflakes
# -*- coding: utf-8 -*-
#
# Copyright  2014-2015 Colin Duquesnoy
# Copyright  2009- The Spyder Developmet Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
@others
if PYQT5:
    from PyQt5.QtWidgets import *
elif PYSIDE2:
    from PySide2.QtWidgets import *
elif PYQT4:
    from PyQt4.QtGui import *
    QStyleOptionViewItem = QStyleOptionViewItemV4
    del QStyleOptionViewItemV4

    # These objects belong to QtGui
    try:
        # Older versions of PyQt4 do not provide these
        del (QGlyphRun,
             QMatrix2x2, QMatrix2x3, QMatrix2x4, QMatrix3x2, QMatrix3x3,
             QMatrix3x4, QMatrix4x2, QMatrix4x3, QMatrix4x4,
             QQuaternion, QRadialGradient, QRawFont, QRegExpValidator,
             QStaticText, QTouchEvent, QVector2D, QVector3D, QVector4D,
             qFuzzyCompare)
    except NameError:
        pass
    del (QAbstractTextDocumentLayout, QActionEvent, QBitmap, QBrush, QClipboard,
         QCloseEvent, QColor, QConicalGradient, QContextMenuEvent, QCursor,
         QDesktopServices, QDoubleValidator, QDrag, QDragEnterEvent,
         QDragLeaveEvent, QDragMoveEvent, QDropEvent, QFileOpenEvent,
         QFocusEvent, QFont, QFontDatabase, QFontInfo, QFontMetrics,
         QFontMetricsF, QGradient, QHelpEvent, QHideEvent,
         QHoverEvent, QIcon, QIconDragEvent, QIconEngine, QImage,
         QImageIOHandler, QImageReader, QImageWriter, QInputEvent,
         QInputMethodEvent, QKeyEvent, QKeySequence, QLinearGradient,
         QMouseEvent, QMoveEvent, QMovie, QPaintDevice, QPaintEngine,
         QPaintEngineState, QPaintEvent, QPainter, QPainterPath,
         QPainterPathStroker, QPalette, QPen, QPicture, QPictureIO, QPixmap,
         QPixmapCache, QPolygon, QPolygonF,
         QRegion, QResizeEvent, QSessionManager, QShortcutEvent, QShowEvent,
         QStandardItem, QStandardItemModel, QStatusTipEvent,
         QSyntaxHighlighter, QTabletEvent, QTextBlock, QTextBlockFormat,
         QTextBlockGroup, QTextBlockUserData, QTextCharFormat, QTextCursor,
         QTextDocument, QTextDocumentFragment, QTextDocumentWriter,
         QTextFormat, QTextFragment, QTextFrame, QTextFrameFormat,
         QTextImageFormat, QTextInlineObject, QTextItem, QTextLayout,
         QTextLength, QTextLine, QTextList, QTextListFormat, QTextObject,
         QTextObjectInterface, QTextOption, QTextTable, QTextTableCell,
         QTextTableCellFormat, QTextTableFormat, QTransform,
         QValidator, QWhatsThisClickedEvent,
         QWheelEvent, QWindowStateChangeEvent, qAlpha, qBlue,
         qGray, qGreen, qIsGray, qRed, qRgb, qRgba, QIntValidator,
         QStringListModel)

    # These objects belong to QtPrintSupport
    del (QAbstractPrintDialog, QPageSetupDialog, QPrintDialog, QPrintEngine,
         QPrintPreviewDialog, QPrintPreviewWidget, QPrinter, QPrinterInfo)

    # These objects belong to QtCore
    del (QItemSelection, QItemSelectionModel, QItemSelectionRange,
         QSortFilterProxyModel)

    # Patch QComboBox to allow Python objects to be passed to userData
    patch_qcombobox(QComboBox)

    # QHeaderView: renamed methods
    introduce_renamed_methods_qheaderview(QHeaderView)

elif PYSIDE:
    from PySide.QtGui import *
    QStyleOptionViewItem = QStyleOptionViewItemV4
    del QStyleOptionViewItemV4

    # These objects belong to QtGui
    del (QAbstractTextDocumentLayout, QActionEvent, QBitmap, QBrush, QClipboard,
         QCloseEvent, QColor, QConicalGradient, QContextMenuEvent, QCursor,
         QDesktopServices, QDoubleValidator, QDrag, QDragEnterEvent,
         QDragLeaveEvent, QDragMoveEvent, QDropEvent, QFileOpenEvent,
         QFocusEvent, QFont, QFontDatabase, QFontInfo, QFontMetrics,
         QFontMetricsF, QGradient, QHelpEvent, QHideEvent,
         QHoverEvent, QIcon, QIconDragEvent, QIconEngine, QImage,
         QImageIOHandler, QImageReader, QImageWriter, QInputEvent,
         QInputMethodEvent, QKeyEvent, QKeySequence, QLinearGradient,
         QMatrix2x2, QMatrix2x3, QMatrix2x4, QMatrix3x2, QMatrix3x3,
         QMatrix3x4, QMatrix4x2, QMatrix4x3, QMatrix4x4, QMouseEvent,
         QMoveEvent, QMovie, QPaintDevice, QPaintEngine, QPaintEngineState,
         QPaintEvent, QPainter, QPainterPath, QPainterPathStroker, QPalette,
         QPen, QPicture, QPictureIO, QPixmap, QPixmapCache, QPolygon,
         QPolygonF, QQuaternion, QRadialGradient, QRegExpValidator,
         QRegion, QResizeEvent, QSessionManager, QShortcutEvent, QShowEvent,
         QStandardItem, QStandardItemModel, QStatusTipEvent,
         QSyntaxHighlighter, QTabletEvent, QTextBlock, QTextBlockFormat,
         QTextBlockGroup, QTextBlockUserData, QTextCharFormat, QTextCursor,
         QTextDocument, QTextDocumentFragment,
         QTextFormat, QTextFragment, QTextFrame, QTextFrameFormat,
         QTextImageFormat, QTextInlineObject, QTextItem, QTextLayout,
         QTextLength, QTextLine, QTextList, QTextListFormat, QTextObject,
         QTextObjectInterface, QTextOption, QTextTable, QTextTableCell,
         QTextTableCellFormat, QTextTableFormat, QTouchEvent, QTransform,
         QValidator, QVector2D, QVector3D, QVector4D, QWhatsThisClickedEvent,
         QWheelEvent, QWindowStateChangeEvent, qAlpha, qBlue, qGray, qGreen,
         qIsGray, qRed, qRgb, qRgba, QIntValidator, QStringListModel)

    # These objects belong to QtPrintSupport
    del (QAbstractPrintDialog, QPageSetupDialog, QPrintDialog, QPrintEngine,
         QPrintPreviewDialog, QPrintPreviewWidget, QPrinter, QPrinterInfo)

    # These objects belong to QtCore
    del (QItemSelection, QItemSelectionModel, QItemSelectionRange,
         QSortFilterProxyModel)

    # Patch QComboBox to allow Python objects to be passed to userData
    patch_qcombobox(QComboBox)

    # QHeaderView: renamed methods
    introduce_renamed_methods_qheaderview(QHeaderView)

else:
    raise PythonQtError('No Qt bindings could be found')
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.351">"""
Provides widget classes and functions.
.. warning:: Only PyQt4/PySide QtGui classes compatible with PyQt5.QtWidgets
    are exposed here. Therefore, you need to treat/use this package as if it
    were the ``PyQt5.QtWidgets`` module.
"""

from . import PYQT5, PYSIDE2, PYQT4, PYSIDE, PythonQtError
from ._patch.qcombobox import patch_qcombobox
from ._patch.qheaderview import introduce_renamed_methods_qheaderview

</t>
<t tx="ekr.20190812072050.352">@path pyzo/util/qt/
@nopyflakes
@others
if PYQT5:

    from PyQt5.uic import *

elif PYQT4:

    from PyQt4.uic import *

else:

    __all__ = ['loadUi']

    # In PySide, loadUi does not exist, so we define it using QUiLoader, and
    # then make sure we expose that function. This is adapted from qt-helpers
    # which was released under a 3-clause BSD license:
    # qt-helpers - a common front-end to various Qt modules
    #
    # Copyright (c) 2015, Chris Beaumont and Thomas Robitaille
    #
    # All rights reserved.
    #
    # Redistribution and use in source and binary forms, with or without
    # modification, are permitted provided that the following conditions are
    # met:
    #
    #  * Redistributions of source code must retain the above copyright
    #    notice, this list of conditions and the following disclaimer.
    #  * Redistributions in binary form must reproduce the above copyright
    #    notice, this list of conditions and the following disclaimer in the
    #    documentation and/or other materials provided with the
    #    distribution.
    #  * Neither the name of the Glue project nor the names of its contributors
    #    may be used to endorse or promote products derived from this software
    #    without specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    # IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
    # CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    # PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # Which itself was based on the solution at
    #
    # https://gist.github.com/cpbotha/1b42a20c8f3eb9bb7cb8
    #
    # which was released under the MIT license:
    #
    # Copyright (c) 2011 Sebastian Wiesner &lt;lunaryorn@gmail.com&gt;
    # Modifications by Charl Botha &lt;cpbotha@vxlabs.com&gt;
    #
    # Permission is hereby granted, free of charge, to any person obtaining a
    # copy of this software and associated documentation files (the "Software"),
    # to deal in the Software without restriction, including without limitation
    # the rights to use, copy, modify, merge, publish, distribute, sublicense,
    # and/or sell copies of the Software, and to permit persons to whom the
    # Software is furnished to do so, subject to the following conditions:
    #
    # The above copyright notice and this permission notice shall be included in
    # all copies or substantial portions of the Software.
    #
    # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    # THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    # DEALINGS IN THE SOFTWARE.

    if PYSIDE:
        from PySide.QtCore import QMetaObject
        from PySide.QtUiTools import QUiLoader
    elif PYSIDE2:
        from PySide2.QtCore import QMetaObject
        from PySide2.QtUiTools import QUiLoader

    class UiLoader(QUiLoader):
        """
        Subclass of :class:`~PySide.QtUiTools.QUiLoader` to create the user
        interface in a base instance.

        Unlike :class:`~PySide.QtUiTools.QUiLoader` itself this class does not
        create a new instance of the top-level widget, but creates the user
        interface in an existing instance of the top-level class if needed.

        This mimics the behaviour of :func:`PyQt4.uic.loadUi`.
        """

        def __init__(self, baseinstance, customWidgets=None):
            """
            Create a loader for the given ``baseinstance``.

            The user interface is created in ``baseinstance``, which must be an
            instance of the top-level class in the user interface to load, or a
            subclass thereof.

            ``customWidgets`` is a dictionary mapping from class name to class
            object for custom widgets. Usually, this should be done by calling
            registerCustomWidget on the QUiLoader, but with PySide 1.1.2 on
            Ubuntu 12.04 x86_64 this causes a segfault.

            ``parent`` is the parent object of this loader.
            """

            QUiLoader.__init__(self, baseinstance)

            self.baseinstance = baseinstance

            if customWidgets is None:
                self.customWidgets = {}
            else:
                self.customWidgets = customWidgets

        def createWidget(self, class_name, parent=None, name=''):
            """
            Function that is called for each widget defined in ui file,
            overridden here to populate baseinstance instead.
            """

            if parent is None and self.baseinstance:
                # supposed to create the top-level widget, return the base
                # instance instead
                return self.baseinstance

            else:

                # For some reason, Line is not in the list of available
                # widgets, but works fine, so we have to special case it here.
                if class_name in self.availableWidgets() or class_name == 'Line':
                    # create a new widget for child widgets
                    widget = QUiLoader.createWidget(self, class_name, parent, name)

                else:
                    # If not in the list of availableWidgets, must be a custom
                    # widget. This will raise KeyError if the user has not
                    # supplied the relevant class_name in the dictionary or if
                    # customWidgets is empty.
                    try:
                        widget = self.customWidgets[class_name](parent)
                    except KeyError:
                        raise Exception('No custom widget ' + class_name + ' '
                                        'found in customWidgets')

                if self.baseinstance:
                    # set an attribute for the new child widget on the base
                    # instance, just like PyQt4.uic.loadUi does.
                    setattr(self.baseinstance, name, widget)

                return widget

    def _get_custom_widgets(ui_file):
        """
        This function is used to parse a ui file and look for the &lt;customwidgets&gt;
        section, then automatically load all the custom widget classes.
        """

        import sys
        import importlib
        from xml.etree.ElementTree import ElementTree

        # Parse the UI file
        etree = ElementTree()
        ui = etree.parse(ui_file)

        # Get the customwidgets section
        custom_widgets = ui.find('customwidgets')

        if custom_widgets is None:
            return {}

        custom_widget_classes = {}

        for custom_widget in custom_widgets.getchildren():

            cw_class = custom_widget.find('class').text
            cw_header = custom_widget.find('header').text

            module = importlib.import_module(cw_header)

            custom_widget_classes[cw_class] = getattr(module, cw_class)

        return custom_widget_classes

    def loadUi(uifile, baseinstance=None, workingDirectory=None):
        """
        Dynamically load a user interface from the given ``uifile``.

        ``uifile`` is a string containing a file name of the UI file to load.

        If ``baseinstance`` is ``None``, the a new instance of the top-level
        widget will be created. Otherwise, the user interface is created within
        the given ``baseinstance``. In this case ``baseinstance`` must be an
        instance of the top-level widget class in the UI file to load, or a
        subclass thereof. In other words, if you've created a ``QMainWindow``
        interface in the designer, ``baseinstance`` must be a ``QMainWindow``
        or a subclass thereof, too. You cannot load a ``QMainWindow`` UI file
        with a plain :class:`~PySide.QtGui.QWidget` as ``baseinstance``.

        :method:`~PySide.QtCore.QMetaObject.connectSlotsByName()` is called on
        the created user interface, so you can implemented your slots according
        to its conventions in your widget class.

        Return ``baseinstance``, if ``baseinstance`` is not ``None``. Otherwise
        return the newly created instance of the user interface.
        """

        # We parse the UI file and import any required custom widgets
        customWidgets = _get_custom_widgets(uifile)

        loader = UiLoader(baseinstance, customWidgets)

        if workingDirectory is not None:
            loader.setWorkingDirectory(workingDirectory)

        widget = loader.load(uifile)
        QMetaObject.connectSlotsByName(widget)
        return widget
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.353">import os

from . import PYSIDE, PYSIDE2, PYQT4, PYQT5
from .QtWidgets import QComboBox
</t>
<t tx="ekr.20190812072050.354">@path pyzo/util/qt/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.355">version_info = (1, 5, 0, 'dev0')
__version__ = '.'.join(map(str, version_info))
</t>
<t tx="ekr.20190812072050.356">@path pyzo/util/qt/
@nopyflakes
# -*- coding: utf-8 -*-
#
# Copyright  2009- The Spyder Development Team
# Copyright  2014-2015 Colin Duquesnoy
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
@others
if 'PyQt5' in sys.modules:
    API = 'pyqt5'
elif 'PySide2' in sys.modules:
    API = 'pyside2'
elif 'PyQt4' in sys.modules:
    API = 'pyqt4'
elif 'PySide' in sys.modules:
    API = 'pyside'

if API in PYQT5_API:
    try:
        from PyQt5.QtCore import PYQT_VERSION_STR as PYQT_VERSION  # analysis:ignore
        from PyQt5.QtCore import QT_VERSION_STR as QT_VERSION  # analysis:ignore
        PYSIDE_VERSION = None
    except ImportError:
        API = os.environ['QT_API'] = 'pyside2'

if API in PYSIDE2_API:
    try:
        from PySide2 import __version__ as PYSIDE_VERSION  # analysis:ignore
        from PySide2.QtCore import __version__ as QT_VERSION  # analysis:ignore

        PYQT_VERSION = None
        PYQT5 = False
        PYSIDE2 = True
    except ImportError:
        API = os.environ['QT_API'] = 'pyqt'

if API in PYQT4_API:
    try:
        import sip
        try:
            sip.setapi('QString', 2)
            sip.setapi('QVariant', 2)
            sip.setapi('QDate', 2)
            sip.setapi('QDateTime', 2)
            sip.setapi('QTextStream', 2)
            sip.setapi('QTime', 2)
            sip.setapi('QUrl', 2)
        except AttributeError:
            # PyQt &lt; v4.6
            pass
        from PyQt4.Qt import PYQT_VERSION_STR as PYQT_VERSION  # analysis:ignore
        from PyQt4.Qt import QT_VERSION_STR as QT_VERSION  # analysis:ignore
        PYSIDE_VERSION = None
        PYQT5 = False
        PYQT4 = True
    except ImportError:
        API = os.environ['QT_API'] = 'pyside'
    else:
        is_old_pyqt = PYQT_VERSION.startswith(('4.4', '4.5', '4.6', '4.7'))
        is_pyqt46 = PYQT_VERSION.startswith('4.6')

if API in PYSIDE_API:
    try:
        from PySide import __version__ as PYSIDE_VERSION  # analysis:ignore
        from PySide.QtCore import __version__ as QT_VERSION  # analysis:ignore
        PYQT_VERSION = None
        PYQT5 = PYSIDE2 = False
        PYSIDE = True
    except ImportError:
        raise PythonQtError('No Qt bindings could be found')

# If a correct API name is passed to QT_API and it could not be found,
# switches to another and informs through the warning
# if API != initial_api:
#     warnings.warn('Selected binding "{}" could not be found, '
#                   'using "{}"'.format(initial_api, API), RuntimeWarning)

API_NAME = {'pyqt5': 'PyQt5', 'pyqt': 'PyQt4', 'pyqt4': 'PyQt4',
            'pyside': 'PySide', 'pyside2':'PySide2'}[API]

if PYQT4:
        import sip
        try:
            API_NAME += (" (API v{0})".format(sip.getapi('QString')))
        except AttributeError:
            pass
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.357">"""
**QtPy** is a shim over the various Python Qt bindings. It is used to write
Qt binding indenpendent libraries or applications.

If one of the APIs has already been imported, then it will be used.

Otherwise, the shim will automatically select the first available API (PyQt5,
PySide2, PyQt4 and finally PySide); in that case, you can force the use of one
specific bindings (e.g. if your application is using one specific bindings and
you need to use library that use QtPy) by setting up the ``QT_API`` environment
variable.

PyQt5
=====

For PyQt5, you don't have to set anything as it will be used automatically::

    &gt;&gt;&gt; from qtpy import QtGui, QtWidgets, QtCore
    &gt;&gt;&gt; print(QtWidgets.QWidget)

PySide2
======

Set the QT_API environment variable to 'pyside2' before importing other
packages::

    &gt;&gt;&gt; import os
    &gt;&gt;&gt; os.environ['QT_API'] = 'pyside2'
    &gt;&gt;&gt; from qtpy import QtGui, QtWidgets, QtCore
    &gt;&gt;&gt; print(QtWidgets.QWidget)

PyQt4
=====

Set the ``QT_API`` environment variable to 'pyqt' before importing any python
package::

    &gt;&gt;&gt; import os
    &gt;&gt;&gt; os.environ['QT_API'] = 'pyqt'
    &gt;&gt;&gt; from qtpy import QtGui, QtWidgets, QtCore
    &gt;&gt;&gt; print(QtWidgets.QWidget)

PySide
======

Set the QT_API environment variable to 'pyside' before importing other
packages::

    &gt;&gt;&gt; import os
    &gt;&gt;&gt; os.environ['QT_API'] = 'pyside'
    &gt;&gt;&gt; from qtpy import QtGui, QtWidgets, QtCore
    &gt;&gt;&gt; print(QtWidgets.QWidget)

"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('IMPORT pyzo.util.qt')
except Exception:
    leo_g = None
import os
import sys
import warnings
# Version of QtPy
from ._version import __version__
# Qt API environment variable name
QT_API = 'QT_API'

# Names of the expected PyQt5 api
PYQT5_API = ['pyqt5']

# Names of the expected PyQt4 api
PYQT4_API = [
    'pyqt',  # name used in IPython.qt
    'pyqt4'  # pyqode.qt original name
]

# Names of the expected PySide api
PYSIDE_API = ['pyside']

# Names of the expected PySide2 api
PYSIDE2_API = ['pyside2']

# Setting a default value for QT_API
os.environ.setdefault(QT_API, 'pyqt5')

API = os.environ[QT_API].lower()
initial_api = API
assert API in (PYQT5_API + PYQT4_API + PYSIDE_API + PYSIDE2_API)

is_old_pyqt = is_pyqt46 = False
PYQT5 = True
PYQT4 = PYSIDE = PYSIDE2 = False
</t>
<t tx="ekr.20190812072050.358">class PythonQtError(Exception):
    """Error raise if no bindings could be selected"""
    pass
</t>
<t tx="ekr.20190812072050.359">class PythonQtWarning(Warning):
    """Warning if some features are not implemented in a binding."""
    pass
</t>
<t tx="ekr.20190812072050.36">def run(self):

    try:
        try:
            self._run()
        except Exception as err:
            if Empty is None or self._lock is None:
                pass  # Shutting down ...
            else:
                print('Exception in proxy thread: ' + str(err))

    except Exception:
        pass  # Interpreter is shutting down
</t>
<t tx="ekr.20190812072050.361"></t>
<t tx="ekr.20190812072050.362">@path pyzo/util/qt/_patch/
@nopyflakes
# The code below, as well as the associated test were adapted from
# qt-helpers, which was released under a 3-Clause BSD license:
#
# Copyright (c) 2015, Chris Beaumont and Thomas Robitaille
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the
#    distribution.
#  * Neither the name of the Glue project nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.363">def patch_qcombobox(QComboBox):
    """
    In PySide, using Python objects as userData in QComboBox causes
    Segmentation faults under certain conditions. Even in cases where it
    doesn't, findData does not work correctly. Likewise, findData also does not
    work correctly with Python objects when using PyQt4. On the other hand,
    PyQt5 deals with this case correctly. We therefore patch QComboBox when
    using PyQt4 and PySide to avoid issues.
    """

    from ..QtGui import QIcon
    from ..QtCore import Qt, QObject

    class userDataWrapper():
        """
        This class is used to wrap any userData object. If we don't do this,
        then certain types of objects can cause segmentation faults or issues
        depending on whether/how __getitem__ is defined.
        """
        def __init__(self, data):
            self.data = data

    _addItem = QComboBox.addItem

    def addItem(self, *args, **kwargs):
        if len(args) == 3 or (not isinstance(args[0], QIcon)
                              and len(args) == 2):
            args, kwargs['userData'] = args[:-1], args[-1]
        if 'userData' in kwargs:
            kwargs['userData'] = userDataWrapper(kwargs['userData'])
        _addItem(self, *args, **kwargs)

    _insertItem = QComboBox.insertItem

    def insertItem(self, *args, **kwargs):
        if len(args) == 4 or (not isinstance(args[1], QIcon)
                              and len(args) == 3):
            args, kwargs['userData'] = args[:-1], args[-1]
        if 'userData' in kwargs:
            kwargs['userData'] = userDataWrapper(kwargs['userData'])
        _insertItem(self, *args, **kwargs)

    _setItemData = QComboBox.setItemData

    def setItemData(self, index, value, role=Qt.UserRole):
        value = userDataWrapper(value)
        _setItemData(self, index, value, role=role)

    _itemData = QComboBox.itemData

    def itemData(self, index, role=Qt.UserRole):
        userData = _itemData(self, index, role=role)
        if isinstance(userData, userDataWrapper):
            userData = userData.data
        return userData

    def findData(self, value):
        for i in range(self.count()):
            if self.itemData(i) == value:
                return i
        return -1

    QComboBox.addItem = addItem
    QComboBox.insertItem = insertItem
    QComboBox.setItemData = setItemData
    QComboBox.itemData = itemData
    QComboBox.findData = findData
</t>
<t tx="ekr.20190812072050.364">@path pyzo/util/qt/_patch/
# -*- coding: utf-8 -*-
#
# Copyright  The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.365">import warnings
</t>
<t tx="ekr.20190812072050.366">def introduce_renamed_methods_qheaderview(QHeaderView):

    _isClickable = QHeaderView.isClickable
    def sectionsClickable(self):
        """
        QHeaderView.sectionsClickable() -&gt; bool
        """
        return _isClickable(self)
    QHeaderView.sectionsClickable = sectionsClickable
    def isClickable(self):
        warnings.warn('isClickable is only available in Qt4. Use '
                        'sectionsClickable instead.', stacklevel=2)
        return _isClickable(self)
    QHeaderView.isClickable = isClickable

    _isMovable = QHeaderView.isMovable
    def sectionsMovable(self):
        """
        QHeaderView.sectionsMovable() -&gt; bool
        """
        return _isMovable(self)
    QHeaderView.sectionsMovable = sectionsMovable
    def isMovable(self):
        warnings.warn('isMovable is only available in Qt4. Use '
                        'sectionsMovable instead.', stacklevel=2)
        return _isMovable(self)
    QHeaderView.isMovable = isMovable

    _resizeMode = QHeaderView.resizeMode
    def sectionResizeMode(self, logicalIndex):
        """
        QHeaderView.sectionResizeMode(int) -&gt; QHeaderView.ResizeMode
        """
        return _resizeMode(self, logicalIndex)
    QHeaderView.sectionResizeMode = sectionResizeMode
    def resizeMode(self, logicalIndex):
        warnings.warn('resizeMode is only available in Qt4. Use '
                        'sectionResizeMode instead.', stacklevel=2)
        return _resizeMode(self, logicalIndex)
    QHeaderView.resizeMode = resizeMode

    _setClickable = QHeaderView.setClickable
    def setSectionsClickable(self, clickable):
        """
        QHeaderView.setSectionsClickable(bool)
        """
        return _setClickable(self, clickable)
    QHeaderView.setSectionsClickable = setSectionsClickable
    def setClickable(self, clickable):
        warnings.warn('setClickable is only available in Qt4. Use '
                        'setSectionsClickable instead.', stacklevel=2)
        return _setClickable(self, clickable)
    QHeaderView.setClickable = setClickable

    _setMovable = QHeaderView.setMovable
    def setSectionsMovable(self, movable):
        """
        QHeaderView.setSectionsMovable(bool)
        """
        return _setMovable(self, movable)
    QHeaderView.setSectionsMovable = setSectionsMovable
    def setMovable(self, movable):
        warnings.warn('setMovable is only available in Qt4. Use '
                        'setSectionsMovable instead.', stacklevel=2)
        return _setMovable(self, movable)
    QHeaderView.setMovable = setMovable

    _setResizeMode = QHeaderView.setResizeMode
    def setSectionResizeMode(self, *args):
        """
        QHeaderView.setSectionResizeMode(QHeaderView.ResizeMode)
        QHeaderView.setSectionResizeMode(int, QHeaderView.ResizeMode)
        """
        _setResizeMode(self, *args)
    QHeaderView.setSectionResizeMode = setSectionResizeMode
    def setResizeMode(self, *args):
        warnings.warn('setResizeMode is only available in Qt4. Use '
                        'setSectionResizeMode instead.', stacklevel=2)
        _setResizeMode(self, *args)
    QHeaderView.setResizeMode = setResizeMode
</t>
<t tx="ekr.20190812072050.367">@path pyzo/util/qt/_patch/
# Extra line, so perfect import will work.
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.369"></t>
<t tx="ekr.20190812072050.37">def _run(self):

    last_sleep = time.time()

    while True:

        # Check and reset
        self._interrupt = False
        if self._exit:
            return

        # Sleep
        now = time.time()
        if now - last_sleep &gt; 0.1:
            last_sleep = now
            time.sleep(0.05)

        try:
            # Process items from the queue
            item = self._q.get(True, self.IDLE_TIMEOUT)
            if item is not None and not item._cancelled:
                self._processItem(item, True)
        except Empty:
            # Queue empty, check items periodically
            self._idle()
</t>
<t tx="ekr.20190812072050.370">@path pyzo/yoton/
@others
if __name__ == '__main__':

    class Lala(RequestServer):
        def handle_request(self, req):
            print('REQ:',repr(req))
            return "The current time is %i" % time.time()

    s = Lala('localhost:test', 0, 1)
    s.start()
    if False:
        print(do_request('localhost:test', 'wait', 5))
        for i in range(10):
            print(do_request('localhost:test', 'hi'+str(i)))
    # do_request('localhost:test', 'wait'); do_request('localhost:test', 'hi');
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.371"># -*- coding: utf-8 -*-
""" yoton.clientserver.py

Yoton comes with a small framework to setup a request-reply pattern
using a client-server model (over a non-persistent connection),
similar to telnet. This allows one process to easily ask small pieces
of information from another process.

To create a server, create a class that inherits from
yoton.RequestServer and implement its handle_request() method.

A client process can simply use the yoton.do_request function.
Example: ``yoton.do_request('www.google.com:80', 'GET http/1.1\\r\\n')``

The client server model is implemented using one function and one class:
yoton.do_request and yoton.RequestServer.

Details
-------

The server implements a request/reply pattern by listening at a socket.
Similar to telnet, each request is handled using a connection
and the socket is closed after the response is send.

The request server can setup to run in the main thread, or can be started
using its own thread. In the latter case, one can easily create multiple
servers in a single process, that listen on different ports.

"""

import time
import socket
import threading

from yoton.misc import basestring, str
from yoton.misc import split_address, getErrorMsg
from yoton.core import send_all, recv_all
</t>
<t tx="ekr.20190812072050.372">class RequestServer(threading.Thread):
    """ RequestServer(address, async_val=False, verbose=0)

    Setup a simple server that handles requests similar to a telnet server,
    or asyncore. Starting the server using run() will run the server in
    the calling thread. Starting the server using start() will run the
    server in a separate thread.

    To create a server, subclass this class and re-implement the
    handle_request method. It accepts a request and should return a
    reply. This server assumes utf-8 encoded messages.

    Parameters
    ----------
    address : str
        Should be of the shape hostname:port.
    async_val : bool
        If True, handles each incoming connection in a separate thread.
        This might be advantageous if a the handle_request() method
        takes a long time to execute.
    verbose : bool
        If True, print a message each time a connection is accepted.

    Notes on hostname
    -----------------
    The hostname can be:
      * The IP address, or the string hostname of this computer.
      * 'localhost': the connections is only visible from this computer.
        Also some low level networking layers are bypassed, which results
        in a faster connection. The other context should also connect to
        'localhost'.
      * 'publichost': the connection is visible by other computers on the
        same network.

    """

    @others
</t>
<t tx="ekr.20190812072050.373">def __init__(self, address, async_val=False, verbose=0):
    threading.Thread.__init__(self)

    # Store whether to handle requests asynchronously
    self._async = async_val

    # Verbosity
    self._verbose = verbose

    # Determine host and port (assume tcp)
    protocol, host, port = split_address(address)

    # Create socket. Apply SO_REUSEADDR when binding, so that a
    # improperly closed socket on the same port will not prevent
    # us connecting.
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    # Bind (can raise error is port is not available)
    s.bind((host,port))

    # Store socket instance
    self._bsd_socket = s

    # To stop serving
    self._stop_me = False

    # Make deamon
    self.setDaemon(True)
</t>
<t tx="ekr.20190812072050.374">def start(self):
    """ start()
    Start the server in a separate thread.
    """
    self._stop_me = False
    threading.Thread.start(self)
</t>
<t tx="ekr.20190812072050.375">def stop(self):
    """ stop()
    Stop the server.
    """
    self._stop_me = True
</t>
<t tx="ekr.20190812072050.376">def run(self):
    """ run()
    The server's main loop.
    """

    # Get socket instance
    s = self._bsd_socket

    # Notify
    hostname, port = s.getsockname()
    if self._verbose:
        print('Yoton: hosting at %s, port %i' % (hostname, port))

    # Tell the socket it is a host, accept multiple
    s.listen(1)

    # Set timeout so that we can check _stop_me from time to time
    self._bsd_socket.settimeout(0.25)

    # Enter main loop
    while not self._stop_me:
        try:
            s, addr = self._bsd_socket.accept()
        except socket.timeout:
            pass
        except InterruptedError:
            pass
        else:
            # Show handling?
            if self._verbose:
                print('handling request from: '+str(addr))
            # Handle request
            if self._async :
                rh = SocketHandler(self, s)
                rh.start()
            else:
                self._handle_connection(s)

    # Close down
    try:
        self._bsd_socket.close()
    except socket.error:
        pass
</t>
<t tx="ekr.20190812072050.377">def _handle_connection(self, s):
    """ _handle_connection(s)
    Handle an incoming connection.
    """
    try:
        self._really_handle_connection(s)
    except Exception:
        print('Error handling request:')
        print(getErrorMsg())
</t>
<t tx="ekr.20190812072050.378">def _really_handle_connection(self, s):
    """ _really_handle_connection(s)
    Really handle an incoming connection.
    """
    # Get request
    request = recv_all(s, True)
    if request is None:
        return

    # Get reply
    reply = self.handle_request(request)

    # Test
    if not isinstance(reply, basestring):
        raise ValueError('handle_request() should return a string.')

    # Send reply
    send_all(s, reply, True)

    # Close the socket
    try:
        s.close()
    except socket.error:
        pass
</t>
<t tx="ekr.20190812072050.379">def handle_request(self, request):
    """ handle_request(request)

    Return a reply, given the request. Overload this method to create
    a server.

    De standard implementation echos the request, waits one second
    when receiving 'wait' and stop the server when receiving 'stop'.

    """
    # Special cases
    if request == 'wait':
        time.sleep(1.0)
    elif request == 'stop':
        self._stop_me = True

    # Echo
    return 'Requested: ' + request
</t>
<t tx="ekr.20190812072050.38">def _idle(self):
    # Make a copy of the set if item
    with self._lock:
        items = set(self._pathProxies)
    # Process them
    for item in items:
        if self._interrupt:
            return
        self._processItem(item)
</t>
<t tx="ekr.20190812072050.380">class SocketHandler(threading.Thread):
    """ SocketHandler(server, s)
    Simple thread that handles a connection.
    """
    @others
</t>
<t tx="ekr.20190812072050.381">def __init__(self, server, s):
    threading.Thread.__init__(self)
    self._server = server
    self._bsd_socket = s
</t>
<t tx="ekr.20190812072050.382">def run(self):
    self._server._handle_connection(self._bsd_socket)
</t>
<t tx="ekr.20190812072050.383">def do_request(address, request, timeout=-1):
    """ do_request(address, request, timeout=-1)

    Do a request at the server at the specified address. The server can
    be a yoton.RequestServer, or any other server listening on a socket
    and following a REQ/REP pattern, such as html or telnet. For example:
    ``html = do_request('www.google.com:80', 'GET http/1.1\\r\\n')``

    Parameters
    ----------
    address : str
        Should be of the shape hostname:port.
    request : string
        The request to make.
    timeout : float
        If larger than 0, will wait that many seconds for the respons, and
        return None if timed out.

    Notes on hostname
    -----------------
    The hostname can be:
      * The IP address, or the string hostname of this computer.
      * 'localhost': the connections is only visible from this computer.
        Also some low level networking layers are bypassed, which results
        in a faster connection. The other context should also connect to
        'localhost'.
      * 'publichost': the connection is visible by other computers on the
        same network.

    """

    # Determine host (assume tcp)
    protocol, host, port = split_address(address)

    # Check request
    if not isinstance(request, basestring):
        raise ValueError('request should be a string.')

    # Check timeout
    if timeout is None:
        timeout = -1

    # Create socket and connect
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.connect((host,port))
    except socket.error:
        raise RuntimeError('No server is listening at the given port.')

    # Send request
    send_all(s, request, True)

    # Receive reply
    reply = recv_all(s, timeout)

    # Close socket
    try:
        s.close()
    except socket.error:
        pass

    # Done
    return reply
</t>
<t tx="ekr.20190812072050.384">@path pyzo/yoton/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.385"># -*- coding: utf-8 -*-
import os
import threading

import yoton
from yoton.misc import basestring
from yoton.misc import Property

# Minimum timout
TIMEOUT_MIN = 0.5

# For the status
STATUS_CLOSED = 0
STATUS_CLOSING = 1
STATUS_WAITING = 2
STATUS_HOSTING = 3
STATUS_CONNECTED = 4

STATUSMAP = ['closed', 'closing', 'waiting', 'hosting', 'connected', ]

# Reasons to stop the connection
STOP_DEFAULT_REASON = 'Closed on command.'
STOP_UNSPECIFIED_PROBLEM = 'Unspecified problem'
STOP_INVALID_REASON = 'Invalid stop reason specified (must be string).'
STOP_TIMEOUT = "Connection timed out." # Can be used by user
STOP_HANDSHAKE_TIMEOUT = "Handshake timed out."
STOP_HANDSHAKE_FAILED = "Handshake failed."
STOP_HANDSHAKE_SELF = "Handshake failed (context cannot connect to self)."
STOP_CLOSED_FROM_THERE = "Closed from other end."
</t>
<t tx="ekr.20190812072050.386">class ConnectionCollection(list):
    """ ContextConnectionCollection()

    A list class that allows indexing using the name of the required
    Connection instance.

    """

    @others
</t>
<t tx="ekr.20190812072050.387">def __getitem__(self, key):
    if isinstance(key, basestring):
        if not key:
            raise KeyError('An empty string is not a valid key.')
        for c in self:
            if c.name == key:
                return c
        else:
            raise KeyError('No connection know by the name %s' % key)
    else:
        return list.__getitem__(self, key)
</t>
<t tx="ekr.20190812072050.388">class Connection(object):
    """ Connection(context, name='')

    Abstract base class for a connection between two Context objects.
    This base class defines the full interface; subclasses only need
    to implement a few private methods.

    The connection classes are intended as a simple interface for the
    user, for example to query port number, and be notified of timeouts
    and closing of the connection.

    All connection instances are intended for one-time use. To make
    a new connection, instantiate a new Connection object. After
    instantiation, either _bind() or _connect() should be called.

    """

    @others
</t>
<t tx="ekr.20190812072050.389">def __init__(self, context, name=''):

    # Store context and name
    self._context = context
    self._name = name

    # Init hostname and port
    self._hostname1 = ''
    self._hostname2 = ''
    self._port1 = 0
    self._port2 = 0

    # Init id and pid of target context (set during handshake)
    # We can easily retrieve our own id and pid; no need to store
    self._id2 = 0
    self._pid2 = 0

    # Timeout value (if no data is received for this long,
    # the timedout signal is fired). Because we do not know the timeout
    # that the other side uses, we apply a minimum timeout.
    self._timeout = TIMEOUT_MIN

    # Create signals
    self._timedout_signal = yoton.Signal()
    self._closed_signal = yoton.Signal()

    # Lock to make setting and getting the status thread safe
    self._lock = threading.RLock()

    # Init variables to disconnected state
    self._set_status(0)

## Properties
</t>
<t tx="ekr.20190812072050.39">def _processItem(self, pathProxy, forceUpdate=False):

    # Slow down a bit
    if forceUpdate:
        time.sleep(self.QUEUE_DELAY)
    else:
        time.sleep(self.IDLE_DELAY)

    # Process
    try:
        pathProxy._process(forceUpdate)
    except Exception as err:
        pathProxy.errored.emit(str(err))

    # Process tasks
    pathProxy._processTasks()

# To overload ...
</t>
<t tx="ekr.20190812072050.390">@property
def hostname1(self):
    """ Get the hostname corresponding to this end of the connection.
    """
    return self._hostname1
</t>
<t tx="ekr.20190812072050.391">@property
def hostname2(self):
    """ Get the hostname for the other end of this connection.
    Is empty string if not connected.
    """
    return self._hostname2
</t>
<t tx="ekr.20190812072050.392">@property
def port1(self):
    """ Get the port number corresponding to this end of the connection.
    When binding, use this port to connect the other context.
    """
    return self._port1
</t>
<t tx="ekr.20190812072050.393">@property
def port2(self):
    """ Get the port number for the other end of the connection.
    Is zero when not connected.
    """
    return self._port2
</t>
<t tx="ekr.20190812072050.394">@property
def id1(self):
    """ The id of the context on this side of the connection.
    """
    return self._context._id
</t>
<t tx="ekr.20190812072050.395">@property
def id2(self):
    """ The id of the context on the other side of the connection.
    """
    return self._id2
</t>
<t tx="ekr.20190812072050.396">@property
def pid1(self):
    """ The pid of the context on this side of the connection.
    (hint: os.getpid())
    """
    return os.getpid()
</t>
<t tx="ekr.20190812072050.397">@property
def pid2(self):
    """ The pid of the context on the other side of the connection.
    """
    return self._pid2
</t>
<t tx="ekr.20190812072050.398">@property
def is_alive(self):
    """ Get whether this connection instance is alive (i.e. either
    waiting or connected, and not in the process of closing).
    """
    self._lock.acquire()
    try:
        return self._status &gt;= 2
    finally:
        self._lock.release()
</t>
<t tx="ekr.20190812072050.399">@property
def is_connected(self):
    """ Get whether this connection instance is connected.
    """
    self._lock.acquire()
    try:
        return self._status &gt;= 3
    finally:
        self._lock.release()
</t>
<t tx="ekr.20190812072050.4">def __init__(self, **params):
    if not params:
        params = None
    self._params = params
    self._result = None
    self._error = None
</t>
<t tx="ekr.20190812072050.40">def listDirs(self, path):
    raise NotImplementedError() # Should rerurn None if it does not exist
</t>
<t tx="ekr.20190812072050.400">@property
def is_waiting(self):
    """ Get whether this connection instance is waiting for a connection.
    This is the state after using bind() and before another context
    connects to it.
    """
    self._lock.acquire()
    try:
        return self._status == 2
    finally:
        self._lock.release()
</t>
<t tx="ekr.20190812072050.401">@property
def closed(self):
    """ Signal emitted when the connection closes. The first argument
    is the ContextConnection instance, the second argument is the
    reason for the disconnection (as a string).
    """
    return self._closed_signal
</t>
<t tx="ekr.20190812072050.402">@Property
def timeout():
    """ Set/get the amount of seconds that no data is received from
    the other side after which the timedout signal is emitted.
    """
    def fget(self):
        return self._timeout
    def fset(self, value):
        if not isinstance(value, (int,float)):
            raise ValueError('timeout must be a number.')
        if value &lt; TIMEOUT_MIN:
            raise ValueError('timeout must be at least %1.2f.' % TIMEOUT_MIN)
        self._timeout = value
    return locals()
</t>
<t tx="ekr.20190812072050.403">@property
def timedout(self):
    """ This signal is emitted when no data has been received for
    over 'timeout' seconds. This can mean that the connection is unstable,
    or that the other end is running extension code.

    Handlers are called with two arguments: the ContextConnection
    instance, and a boolean. The latter is True when the connection
    times out, and False when data is received again.
    """
    return self._timedout_signal
</t>
<t tx="ekr.20190812072050.404">@Property
def name():
    """ Set/get the name that this connection is known by. This name
    can be used to obtain the instance using the Context.connections
    property. The name can be used in networks in which each context
    has a particular role, to easier distinguish between the different
    connections. Other than that, the name has no function.
    """
    def fget(self):
        return self._name
    def fset(self, value):
        if not isinstance(value, basestring):
            raise ValueError('name must be a string.')
        self._name = value
    return locals()

## Public methods
</t>
<t tx="ekr.20190812072050.405">def flush(self, timeout=3.0):
    """ flush(timeout=3.0)

    Wait until all pending packages are send. An error
    is raised when the timeout passes while doing so.

    """
    return self._flush(timeout)
</t>
<t tx="ekr.20190812072050.406">def close(self, reason=None):
    """ close(reason=None)

    Close the connection, disconnecting the two contexts and
    stopping all trafic. If the connection was waiting for a
    connection, it stops waiting.

    Optionally, a reason for closing can be specified. A closed
    connection cannot be reused.

    """

    # No reason, user invoked close
    if reason is None:
        reason = STOP_DEFAULT_REASON

    # If already closed or closing, do nothing
    if self._status in [STATUS_CLOSED, STATUS_CLOSING]:
        return

    # Go!
    return self._general_close_method(reason, True)
</t>
<t tx="ekr.20190812072050.407">def close_on_problem(self, reason=None):
    """ close_on_problem(reason=None)

    Disconnect the connection, stopping all trafic. If it was
    waiting for a connection, we stop waiting.

    Optionally, a reason for stopping can be specified. This is highly
    recommended in case the connection is closed due to a problem.

    In contrast to the normal close() method, this method does not
    try to notify the other end of the closing.

    """

    # No reason, some unspecified problem
    if reason is None:
        reason = STOP_UNSPECIFIED_PROBLEM

    # If already closed (status==0), do nothing
    if self._status == STATUS_CLOSED:
        return

    # If a connecion problem occurs during closing, we close the connection
    # so that flush will not block.
    # The closing that is now in progress will emit the event, so we
    # do not need to go into the _general_close_method().
    if self._status == STATUS_CLOSING:
        self._set_status(STATUS_CLOSED)
        return

    # Go!
    return self._general_close_method(reason, False)
</t>
<t tx="ekr.20190812072050.408">def _general_close_method(self, reason, send_stop_message):
    """ general close method used by both close() and close_on_problem()
    """

    # Remember current status. Set status to closing, which means that
    # the connection is still alive but cannot be closed again.
    old_status = self._status
    self._set_status(STATUS_CLOSING)

    # Check reason
    if not isinstance(reason, basestring):
        reason = STOP_INVALID_REASON

    # Tell other end to close?
    if send_stop_message and self.is_connected:
        self._notify_other_end_of_closing()

    # Close socket and set attributes to None
    self._set_status(STATUS_CLOSED)

    # Notify user, but only once
    self.closed.emit(self, reason)

    # Notify user ++
    if self._context._verbose:
        tmp = STATUSMAP[old_status]
        print("Yoton: %s connection closed: %s" % (tmp, reason))
#         if True:
#             tmp = STATUSMAP[old_status]
#             sys.__stdout__.write("Yoton: %s connection closed: %s" % (tmp, reason))
#             sys.__stdout__.flush()

## Methods to overload
</t>
<t tx="ekr.20190812072050.409">def _bind(self, hostname, port, max_tries):
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072050.41">def listFiles(self, path):
    raise NotImplementedError() # Should rerurn None if it does not exist
</t>
<t tx="ekr.20190812072050.410">def _connect(self, hostname, port, timeout):
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072050.411">def _flush(self, timeout):
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072050.412">def _notify_other_end_of_closing(self):
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072050.413">def _send_package(self, package):
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072050.414">def _inject_package(self, package):
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072050.415">def _set_status(self, status):
    """ Used to change the status. Subclasses can reimplement this
    to get the desired behavior.
    """
    self._lock.acquire()
    try:

        # Store status
        self._status = status

        # Notify user ++
        if (status &gt; 0) and self._context._verbose:
            action = STATUSMAP[status]
            print("Yoton: %s at %s:%s." % (action, self._hostname1, self._port1))

    finally:
        self._lock.release()
</t>
<t tx="ekr.20190812072050.416">## More ideas for connections

class InterConnection(Connection):
    """ InterConnection(context, hostname, port, name='')

    Not implemented.

    Communication between two processes on the same machine can also
    be implemented via a memory mapped file or a pype. Would there
    be an advantage over the TcpConnection?

    """
    pass
</t>
<t tx="ekr.20190812072050.417">class UDPConnection(Connection):
    """ UDPConnection(context, hostname, port, name='')

    Not implemented.

    Communication can also be done over UDP, but need protocol on top
    of UDP to make the connection robust. Is there a reason to implement
    this if we have Tcp?

    """
    pass
</t>
<t tx="ekr.20190812072050.418">@path pyzo/yoton/
# -*- coding: utf-8 -*-
# flake8: noqa
@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072050.419">import sys
import time

import yoton
from yoton.misc import basestring, bytes, str
from yoton.misc import Property, getErrorMsg, UID
from yoton.misc import PackageQueue

from yoton.connection import Connection, TIMEOUT_MIN
from yoton.connection import STATUS_CLOSED, STATUS_WAITING, STATUS_HOSTING
from yoton.connection import STATUS_CONNECTED, STATUS_CLOSING
</t>
<t tx="ekr.20190812072050.42">def modified(self, path):
    raise NotImplementedError() # Should rerurn None if it does not exist
</t>
<t tx="ekr.20190812072050.420">class ItcConnection(Connection):
    """ ItcConnection(context, hostname, port, name='')

    Not implemented .

    The inter-thread-communication connection class implements a
    connection between two contexts that are in the same process.
    Two instances of this class are connected using a weak reference.
    In case one of the ends is cleaned up by the garbadge collector,
    the other end will close the connection.

    """
    pass
    # todo: implement me
</t>
<t tx="ekr.20190812072050.421">@path pyzo/yoton/
@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072050.422"># -*- coding: utf-8 -*-
import os
import sys
import time
import socket
import threading

from yoton.misc import basestring, bytes, str
from yoton.misc import getErrorMsg, UID
from yoton.misc import TinyPackageQueue
from yoton.core import Package, PACKAGE_HEARTBEAT, PACKAGE_CLOSE, EINTR
from yoton.core import can_recv, send_all, recv_all, HEADER_SIZE

from yoton.connection import Connection, TIMEOUT_MIN  # noqa
from yoton.connection import STATUS_CLOSED, STATUS_WAITING, STATUS_HOSTING  # noqa
from yoton.connection import STATUS_CONNECTED, STATUS_CLOSING  # noqa

# Note that time.sleep(0) yields the current thread's timeslice to any
# other &gt;= priority thread in the process, but is otherwise equivalent 0 delay.

# Reasons to stop the connection
STOP_SOCKET_ERROR = "Socket error." # the error message is appended
STOP_EOF = "Other end dropped the connection."
STOP_HANDSHAKE_TIMEOUT = "Handshake timed out."
STOP_HANDSHAKE_FAILED = "Handshake failed."
STOP_HANDSHAKE_SELF = "Handshake failed (context cannot connect to self)."
STOP_CLOSED_FROM_THERE = "Closed from other end."
STOP_LOST_TRACK = "Lost track of the stream."
STOP_THREAD_ERROR = "Error in io thread."

# Use a relatively small buffer size, to keep the channels better in sync
SOCKET_BUFFERS_SIZE = 10*1024
</t>
<t tx="ekr.20190812072050.423">class TcpConnection(Connection):
    """ TcpConnection(context, name='')

    The TcpConnection class implements a connection between two
    contexts that are in differenr processes or on different machines
    connected via the internet.

    This class handles the low-level communication for the context.
    A ContextConnection instance wraps a single BSD socket for its
    communication, and uses TCP/IP as the underlying communication
    protocol. A persisten connection is used (the BSD sockets stay
    connected). This allows to better distinguish between connection
    problems and timeouts caused by the other side being busy.

    """

    @others
</t>
<t tx="ekr.20190812072050.424">def __init__(self, context, name=''):

    # Variables to hold threads
    self._sendingThread = None
    self._receivingThread = None

    # Create queue for outgoing packages.
    self._qout = TinyPackageQueue(64, *context._queue_params)

    # Init normally (calls _set_status(0)
    Connection.__init__(self, context, name)
</t>
<t tx="ekr.20190812072050.425">def _set_status(self, status, bsd_socket=None):
    """ _connected(status, bsd_socket=None)

    This method is called when a connection is made.

    Private method to apply the bsd_socket.
    Sets the socket and updates the status.
    Also instantiates the IO threads.

    """

    # Lock the connection while we change its status
    self._lock.acquire()

    # Update hostname and port number; for hosting connections the port
    # may be different if max_tries &gt; 0. Each client connection will be
    # assigned a different ephemeral port number.
    # http://www.tcpipguide.com/free/t_TCPPortsConnectionsandConnectionIdentification-2.htm
    # Also get hostname and port for other end
    if bsd_socket is not None:
        if True:
            self._hostname1, self._port1 = bsd_socket.getsockname()
        if status != STATUS_WAITING:
            self._hostname2, self._port2 = bsd_socket.getpeername()

    # Set status as normal
    Connection._set_status(self, status)

    try:

        if status in [STATUS_HOSTING, STATUS_CONNECTED]:
            # Really connected

            # Store socket
            self._bsd_socket = bsd_socket

            # Set socket to blocking. Needed explicitly on Windows
            # One of these things it takes you hours to find out ...
            bsd_socket.setblocking(1)

            # Create and start io threads
            self._sendingThread = SendingThread(self)
            self._receivingThread = ReceivingThread(self)
            #
            self._sendingThread.start()
            self._receivingThread.start()

        if status == 0:

            # Close bsd socket
            try:
                self._bsd_socket.shutdown()
            except Exception:
                pass
            try:
                self._bsd_socket.close()
            except Exception:
                pass
            self._bsd_socket = None

            # Remove references to threads
            self._sendingThread = None
            self._receivingThread = None

    finally:
        self._lock.release()
</t>
<t tx="ekr.20190812072050.426">def _bind(self, hostname, port, max_tries=1):
    """ Bind the bsd socket. Launches a dedicated thread that waits
    for incoming connections and to do the handshaking procedure.
    """

    # Create socket.
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # Set buffer size to be fairly small (less than 10 packages)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, SOCKET_BUFFERS_SIZE)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, SOCKET_BUFFERS_SIZE)

    # Apply SO_REUSEADDR when binding, so that an improperly closed
    # socket on the same port will not prevent us from connecting.
    # It also allows a connection to bind at the same port number,
    # but only after the previous binding connection has connected
    # (and has closed the listen-socket).
    #
    # SO_REUSEADDR means something different on win32 than it does
    # for Linux sockets. To get the intended behavior on Windows,
    # we don't have to do anything. Also see:
    #  * http://msdn.microsoft.com/en-us/library/ms740621%28VS.85%29.aspx
    #  * http://twistedmatrix.com/trac/ticket/1151
    #  * http://www.tcpipguide.com/free/t_TCPPortsConnectionsandConnectionIdentification-2.htm
    if not sys.platform.startswith('win'):
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    # Try all ports in the specified range
    for port2 in range(port, port+max_tries):
        try:
            s.bind((hostname,port2))
            break
        except Exception:
            # Raise the socket exception if we were asked to try
            # just one port. Otherwise just try the next
            if max_tries == 1:
                raise
            continue
    else:
        # We tried all ports without success
        tmp = str(max_tries)
        tmp = "Could not bind to any of the " + tmp + " ports tried."
        raise IOError(tmp)

    # Tell the socket it is a host. Backlog of at least 1 to avoid linux
    # kernel from detecting SYN flood and throttling the connection (#381)
    s.listen(1)

    # Set connected (status 1: waiting for connection)
    # Will be called with status 2 by the hostThread on success
    self._set_status(STATUS_WAITING, s)

    # Start thread to wait for a connection
    # (keep reference so the thread-object stays alive)
    self._hostThread = HostThread(self, s)
    self._hostThread.start()
</t>
<t tx="ekr.20190812072050.427">def _connect(self, hostname, port, timeout=1.0):
    """ Connect to a bound socket.
    """

    # Create socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # Set buffer size to be fairly small (less than 10 packages)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, SOCKET_BUFFERS_SIZE)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, SOCKET_BUFFERS_SIZE)

    # Refuse rediculously low timeouts
    if timeout&lt;= 0.01:
        timeout = 0.01

    # Try to connect
    ok = False
    timestamp = time.time() + timeout
    while not ok and time.time()&lt;timestamp:
        try:
            s.connect((hostname, port))
            ok = True
        except socket.error:
            pass
        except socket.timeout:
            pass
        time.sleep(timeout/100.0)

    # Did it work?
    if not ok:
        type, value, tb = sys.exc_info()
        del tb
        err = str(value)
        raise IOError("Cannot connect to %s on %i: %s" % (hostname, port, err))

    # Shake hands
    h = HandShaker(s)
    success, info = h.shake_hands_as_client(self.id1)

    # Problem?
    if not success:
        self._set_status(0)
        if not info:
            info = 'problem during handshake'
        raise IOError('Could not connect: '+ info)

    # Store id
    self._id2, self._pid2 = info

    # Set connected (status 3: connected as client)
    self._set_status(STATUS_CONNECTED, s)
</t>
<t tx="ekr.20190812072050.428">def _notify_other_end_of_closing(self):
    """ Send PACKAGE_CLOSE.
    """
    self._qout.push(PACKAGE_CLOSE)
    try:
        self.flush(1.0)
    except Exception:
        pass # Well, we tried ...
</t>
<t tx="ekr.20190812072050.429">def _flush(self, timeout=5.0):
    """ Put a dummy message on the queue and spinlock until
    the thread has popped it from the queue.
    """

    # Check
    if not self.is_connected:
        RuntimeError('Cannot flush if not connected.')

    # Put dummy package on the queue
    self._qout.push(PACKAGE_HEARTBEAT)

    # Wait for the queue to empty. If it is, the heart beat package
    # may not been send yet, but every package befor it is.
    timestamp = time.time() + timeout
    while self.is_connected and not self._qout.empty():
        time.sleep(0.01)
        if time.time() &gt; timestamp:
            raise RuntimeError('Sending the packages timed out.')
</t>
<t tx="ekr.20190812072050.43">def fileSize(self, path):
    raise NotImplementedError() # Should rerurn None if it does not exist
</t>
<t tx="ekr.20190812072050.430">def _send_package(self, package):
    """ Put package on the queue, where the sending thread will
    pick it up.
    """
    self._qout.push(package)
</t>
<t tx="ekr.20190812072050.431">def _inject_package(self, package):
    """ Put package in queue, but bypass potential blocking.
    """
    self._qout._q.append(package)
</t>
<t tx="ekr.20190812072050.432">class HostThread(threading.Thread):
    """ HostThread(context_connection, bds_socket)

    The host thread is used by the ContextConnection when hosting a
    connection. This thread waits for another context to connect
    to it, and then performs the handshaking procedure.

    When a successful connection is made, the context_connection's
    _connected() method is called and this thread then exits.

    """

    @others
</t>
<t tx="ekr.20190812072050.433">def __init__(self, context_connection, bsd_socket):
    threading.Thread.__init__(self)

    # Store connection and socket
    self._context_connection = context_connection
    self._bsd_host_socket = bsd_socket

    # Make deamon
    self.setDaemon(True)
</t>
<t tx="ekr.20190812072050.434">def run(self):
    """ run()

    The main loop. Waits for a connection and performs handshaking
    if successfull.

    """

    # Try making a connection until success or the context is stopped
    while self._context_connection.is_waiting:

        # Wait for connection
        s = self._wait_for_connection()
        if not s:
            continue

        # Check if not closed in the mean time
        if not self._context_connection.is_waiting:
            break

        # Do handshaking
        hs = HandShaker(s)
        success, info = hs.shake_hands_as_host(self._context_connection.id1)
        if success:
            self._context_connection._id2 = info[0]
            self._context_connection._pid2 = info[1]
        else:
            print('Yoton: Handshake failed: '+info)
            continue

        # Success!
        # Close hosting socket, thereby enabling rebinding at the same port
        self._bsd_host_socket.close()
        # Update the status of the connection
        self._context_connection._set_status(STATUS_HOSTING, s)
        # Break out of the loop
        break

    # Remove ref
    del self._context_connection
    del self._bsd_host_socket
</t>
<t tx="ekr.20190812072050.435">def _wait_for_connection(self):
    """ _wait_for_connection()

    The thread will wait here until someone connects. When a
    connections is made, the new socket is returned.

    """

    # Set timeout so that we can check _stop_me from time to time
    self._bsd_host_socket.settimeout(0.25)

    # Wait
    while self._context_connection.is_waiting:
        try:
            s, addr = self._bsd_host_socket.accept()
            return s  # Return the new socket
        except socket.timeout:
            pass
        except socket.error:
            # Skip errors caused by interruptions.
            type, value, tb = sys.exc_info()
            del tb
            if value.errno != EINTR:
                raise
</t>
<t tx="ekr.20190812072050.436">class HandShaker:
    """ HandShaker(bsd_socket)

    Class that performs the handshaking procedure for Tcp connections.

    Essentially, the connecting side starts by sending 'YOTON!'
    followed by its id as a hex string. The hosting side responds
    with the same message (but with a different id).

    This process is very similar to a client/server pattern (both
    messages are also terminated with '\r\n'). This is done such that
    if for example a web client tries to connect, a sensible error
    message can be returned. Or when a ContextConnection tries to connect
    to a web server, it will be able to determine the error gracefully.

    """

    @others
</t>
<t tx="ekr.20190812072050.437">def __init__(self, bsd_socket):

    # Store bsd socket
    self._bsd_socket = bsd_socket
</t>
<t tx="ekr.20190812072050.438">def shake_hands_as_host(self, id):
    """ _shake_hands_as_host(id)

    As the host, we wait for the client to ask stuff, so when
    for example a http client connects, we can stop the connection.

    Returns (success, info), where info is the id of the context at
    the other end, or the error message in case success is False.

    """

    # Make our message with id and pid
    message = 'YOTON!%s.%i' % (UID(id).get_hex(), os.getpid())

    # Get request
    request = self._recv_during_handshaking()

    if not request:
        return False, STOP_HANDSHAKE_TIMEOUT
    elif request.startswith('YOTON!'):
        # Get id
        try:
            tmp = request[6:].split('.',1) # partition not in Python24
            id2_str, pid2_str = tmp[0], tmp[1]
            id2, pid2 = int(id2_str, 16), int(pid2_str, 10)
        except Exception:
            self._send_during_handshaking('ERROR: could not parse id.')
            return False, STOP_HANDSHAKE_FAILED
        # Respond and return
        self._send_during_handshaking(message)  # returns error?
        if id == id2:
            return False, STOP_HANDSHAKE_SELF
        else:
            return True, (id2, pid2)
    else:
        # Client is not yoton
        self._send_during_handshaking('ERROR: this is Yoton.')
        return False, STOP_HANDSHAKE_FAILED
</t>
<t tx="ekr.20190812072050.439">def shake_hands_as_client(self, id):
    """ _shake_hands_as_client(id)

    As the client, we ask the host whether it is a Yoton context
    and whether the channels we want to support are all right.

    Returns (success, info), where info is the id of the context at
    the other end, or the error message in case success is False.

    """

    # Make our message with id and pif
    message = 'YOTON!%s.%i' % (UID(id).get_hex(), os.getpid())

    # Do request
    self._send_during_handshaking(message)  # returns error?

    # Get response
    response = self._recv_during_handshaking()

    # Process
    if not response:
        return False, STOP_HANDSHAKE_TIMEOUT
    elif response.startswith('YOTON!'):
        # Get id
        try:
            tmp = response[6:].split('.',1) # Partition not in Python24
            id2_str, pid2_str = tmp[0], tmp[1]
            id2, pid2 = int(id2_str, 16), int(pid2_str, 10)
        except Exception:
            return False, STOP_HANDSHAKE_FAILED
        if id == id2:
            return False, STOP_HANDSHAKE_SELF
        else:
            return True, (id2, pid2)
    else:
        return False, STOP_HANDSHAKE_FAILED
</t>
<t tx="ekr.20190812072050.44">def read(self, path):
    raise NotImplementedError() # Should rerurn None if it does not exist
</t>
<t tx="ekr.20190812072050.440">def _send_during_handshaking(self, text, shutdown=False):
    return send_all(self._bsd_socket, text+'\r\n', shutdown)
</t>
<t tx="ekr.20190812072050.441">def _recv_during_handshaking(self):
    return recv_all(self._bsd_socket, 2.0, True)
</t>
<t tx="ekr.20190812072050.442">class BaseIOThread(threading.Thread):
    """ The base class for the sending and receiving IO threads.
    Implements some common functionality.
    """

    @others
</t>
<t tx="ekr.20190812072050.443">def __init__(self, context_connection):
    threading.Thread.__init__(self)

    # Thread will "destruct" when the interpreter shuts down
    self.setDaemon(True)

    # Store (temporarily) the ref to the context connection
    # Also of bsd_socket, because it might be removed before the
    # thread is well up and running.
    self._context_connection = context_connection
    self._bsd_socket = context_connection._bsd_socket
</t>
<t tx="ekr.20190812072050.444">def run(self):
    """ Method to prepare to enter main loop. There is a try-except here
    to catch exceptions caused by interpreter shutdown.
    """

    # Get ref to context connection but make sure the ref
    # if not stored if the thread stops
    context_connection = self._context_connection
    bsd_socket = self._bsd_socket
    del self._context_connection
    del self._bsd_socket

    try:
        # Run and handle exceptions if someting goes wrong
        self.run2(context_connection, bsd_socket)
    except Exception:
        # An error while handling an exception, most probably
        #interpreter shutdown
        pass
</t>
<t tx="ekr.20190812072050.445">def run2(self, context_connection, bsd_socket):
    """ Method to enter main loop. There is a try-except here to
    catch exceptions in the main loop (such as socket errors and
    errors due to bugs in the code.
    """

    # Get classname to use in messages
    className = 'yoton.' + self.__class__.__name__

    # Define function to write errors
    def writeErr(err):
        sys.__stderr__.write(str(err)+'\n')
        sys.__stderr__.flush()

    try:

        # Enter mainloop
        stop_reason = self._run(context_connection, bsd_socket)

        # Was there a specific reason to stop?
        if stop_reason:
            context_connection.close_on_problem(stop_reason)
        else:
            pass # Stopped because the connection is gone (already stopped)

    except socket.error:
        # Socket error. Can happen if the other end closed not so nice
        # Do get the socket error message and pass it on.
        msg = STOP_SOCKET_ERROR + getErrorMsg()
        context_connection.close_on_problem('%s, %s' % (className, msg))

    except Exception:
        # Else: woops, an error!
        errmsg = getErrorMsg()
        msg = STOP_THREAD_ERROR + errmsg
        context_connection.close_on_problem('%s, %s' % (className, msg))
        writeErr('Exception in %s.' % className)
        writeErr(errmsg)
</t>
<t tx="ekr.20190812072050.446">class SendingThread(BaseIOThread):
    """ The thread that reads packages from the queue and sends them over
    the socket. It uses a timeout while reading from the queue, so it can
    send heart beat packages if no packages are send.
    """

    @others
</t>
<t tx="ekr.20190812072050.447">def _run(self, context_connection, bsd_socket):
    """  The main loop. Get package from queue, send package to socket.
    """

    timeout = 0.5*TIMEOUT_MIN
    queue = context_connection._qout
    socket_sendall = bsd_socket.sendall

    while True:
        time.sleep(0) # Be nice

        # Get package from the queue. Use heartbeat package
        # if there have been no packages for a too long time
        try:
            package = queue.pop(timeout)
        except queue.Empty:
            # Use heartbeat package then
            package = PACKAGE_HEARTBEAT
            # Should we stop?
            if not context_connection.is_connected:
                return None # No need for a stop message

        # Process the package in parts to avoid data copying (header+data)
        for part in package.parts():
            socket_sendall(part)
</t>
<t tx="ekr.20190812072050.448">class ReceivingThread(BaseIOThread):
    """ The thread that reads packages from the socket and passes them to
    the kernel. It uses select() to see if data is available on the socket.
    This allows using a timeout without putting the socket in timeout mode.

    If the timeout has expired, the timedout event for the connection is
    emitted.

    Upon receiving a package, the _recv_package() method of the context
    is called, so this thread will eventually dispose the package in
    one or more queues (of the channel or of another connection).

    """

    @others
</t>
<t tx="ekr.20190812072050.449">def _run(self, context_connection, bsd_socket):
    """ The main loop. Get package from socket, deposit package in queue(s).
    """

    # Short names in local namespace avoid dictionary lookups
    socket_recv = bsd_socket.recv
    recv_package = context_connection._context._recv_package
    package_from_header = Package.from_header
    HS = HEADER_SIZE

    # Variable to keep track if we emitted a timedout signal
    timedOut = False

    while True:
        time.sleep(0) # Be nice

        # Use select call on a timeout to test if data is available
        while True:
            try:
                ok = can_recv(bsd_socket, context_connection._timeout)
            except Exception:
                # select() has it's share of weird errors
                raise socket.error('select(): ' + getErrorMsg())
            if ok:
                # Set timedout ex?
                if timedOut:
                    timedOut = False
                    context_connection.timedout.emit(context_connection, False)
                # Exit from loop
                break
            else:
                # Should we stop?
                if not context_connection.is_connected:
                    return # No need for a stop message
                # Should we do a timeout?
                if not timedOut:
                    timedOut = True
                    context_connection.timedout.emit(context_connection, True)
                # Continue in loop
                continue

        # Get package
        package = self._getPackage(socket_recv, HS, package_from_header)
        if package is None:
            continue
        elif isinstance(package, basestring):
            return package # error msg

        # Let context handle package further (but happens in this thread)
        try:
            recv_package(package, context_connection)
        except Exception:
            print("Error depositing package in ReceivingThread.")
            print(getErrorMsg())
</t>
<t tx="ekr.20190812072050.45">def write(self, path, bb):
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072050.450">def _getPackage(self, socket_recv, HS, package_from_header):
    """ Get exactly one package from the socket. Blocking.
    """

    # Get header and instantiate package object from it
    try:
        header = self._recv_n_bytes(socket_recv, HS)
    except EOFError:
        return STOP_EOF
    package, size = package_from_header(header)

    # Does it look like a good package?
    if not package:
        return STOP_LOST_TRACK

    if size == 0:
        # A special package! (or someone sending a
        # package with no content, which is discarted)
        if package._source_seq == 0:
            pass # Heart beat
        elif package._source_seq == 1:
            return STOP_CLOSED_FROM_THERE
        return None

    else:
        # Get package data
        try:
            package._data = self._recv_n_bytes(socket_recv, size)
        except EOFError:
            return STOP_EOF
        return package
</t>
<t tx="ekr.20190812072050.451">def _recv_n_bytes(self, socket_recv, n):
    """ Receive exactly n bytes from the socket.
    """

    # First round
    data = socket_recv(n)
    if len(data) == 0:
        raise EOFError()

    # How many more do we need? For small n, we probably only need 1 round
    n -= len(data)
    if n==0:
        return data  # We're lucky!

    # Else, we need more than one round
    parts = [data]
    while n:
        data = socket_recv(n)
        parts.append(data)
        n -= len(data)

    # Return combined data of multiple rounds
    return bytes().join(parts)
</t>
<t tx="ekr.20190812072050.452">@path pyzo/yoton/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.453"># -*- coding: utf-8 -*-
""" Module yoton.context

Defines the context class.

"""

import threading

from yoton import connection

from yoton.misc import str, split_address
from yoton.misc import UID, PackageQueue
from yoton.core import Package, BUF_MAX_LEN
from yoton.core import SLOT_CONTEXT

from yoton.connection import ConnectionCollection
from yoton.connection_tcp import TcpConnection
from yoton.connection_itc import ItcConnection
</t>
<t tx="ekr.20190812072050.454">class Context(object):
    """ Context(verbose=0, queue_params=None)

    A context represents a node in the network. It can connect to
    multiple other contexts (using a yoton.Connection.
    These other contexts can be in
    another process on the same machine, or on another machine
    connected via a network or the internet.

    This class represents a context that can be used by channel instances
    to communicate to other channels in the network. (Thus the name.)

    The context is the entity that queue routes the packages produced
    by the channels to the other context in the network, where
    the packages are distributed to the right channels. A context queues
    packages while it is not connected to any other context.

    If messages are send on a channel registered at this context while
    the context is not connected, the messages are stored by the
    context and will be send to the first connecting context.

    Example 1
    ---------
    # Create context and bind to a port on localhost
    context = yoton.Context()
    context.bind('localhost:11111')
    # Create a channel and send a message
    pub = yoton.PubChannel(context, 'test')
    pub.send('Hello world!')

    Example 2
    ---------
    # Create context and connect to the port on localhost
    context = yoton.Context()
    context.connect('localhost:11111')
    # Create a channel and receive a message
    sub = yoton.SubChannel(context, 'test')
    print(sub.recv() # Will print 'Hello world!'

    Queue params
    ------------
    The queue_params parameter allows one to specify the package queues
    used in the system. It is recommended to use the same parameters
    for every context in the network. The value of queue_params should
    be a 2-element tuple specifying queue size and discard mode. The
    latter can be 'old' (default) or 'new', meaning that if the queue
    is full, either the oldest or newest messages are discarted.

    """

    @others
</t>
<t tx="ekr.20190812072050.455">def __init__(self, verbose=0, queue_params=None):

    # Whether or not to write status information
    self._verbose = verbose

    # Store queue parameters
    if queue_params is None:
        queue_params = BUF_MAX_LEN, 'old'
    if not (isinstance(queue_params, tuple) and len(queue_params) == 2):
        raise ValueError('queue_params should be a 2-element tuple.')
    self._queue_params = queue_params

    # Create unique key to identify this context
    self._id = UID().get_int()

    # Channels currently registered. Maps slots to channel instance.
    self._sending_channels = {}
    self._receiving_channels = {}

    # The list of connections
    self._connections = []
    self._connections_lock = threading.RLock()

    # Queue used during startup to collect packages
    # This queue is also subject to the _connections_lock
    self._startupQueue = PackageQueue(*queue_params)

    # For numbering and routing the packages
    self._send_seq = 0
    self._recv_seq = 0
    self._source_map = {}
</t>
<t tx="ekr.20190812072050.456">def close(self):
    """ close()

    Close the context in a nice way, by closing all connections
    and all channels.

    Closing a connection means disconnecting two contexts. Closing
    a channel means disasociating a channel from its context.
    Unlike connections and channels, a Context instance can be reused
    after closing (although this might not always the best strategy).

    """

    # Close all connections (also the waiting connections!)
    for c in self.connections_all:
        c.close('Closed by the context.')

    # Close all channels
    self.close_channels()
</t>
<t tx="ekr.20190812072050.457">def close_channels(self):
    """ close_channels()

    Close all channels associated with this context. This does
    not close the connections. See also close().

    """

    # Get all channels
    channels1 = [c for c in self._sending_channels.values()]
    channels2 = [c for c in self._receiving_channels.values()]

    # Close all channels
    for c in set(channels1+channels2):
        c.close()

## Properties
</t>
<t tx="ekr.20190812072050.458">@property
def connections_all(self):
    """ Get a list of all Connection instances currently
    associated with this context, including pending connections
    (connections waiting for another end to connect).
    In addition to normal list indexing, the connections objects can be
    queried from this list using their name.
    """

    # Lock
    self._connections_lock.acquire()
    try:
        return [c for c in self._connections if c.is_alive]
    finally:
        self._connections_lock.release()
</t>
<t tx="ekr.20190812072050.459">@property
def connections(self):
    """ Get a list of the Connection instances currently
    active for this context.
    In addition to normal list indexing, the connections objects can be
    queried  from this list using their name.
    """
    # Lock
    self._connections_lock.acquire()

    try:

        # Clean up any dead connections
        copy = ConnectionCollection()
        to_remove = []
        for c in self._connections:
            if not c.is_alive:
                to_remove.append(c)
            elif c.is_connected:
                copy.append(c)

        # Clean
        for c in to_remove:
            self._connections.remove(c)

        # Return copy
        return copy

    finally:
        self._connections_lock.release()
</t>
<t tx="ekr.20190812072050.46">def rename(self, path):
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072050.460">@property
def connection_count(self):
    """ Get the number of connected contexts. Can be used as a boolean
    to check if the context is connected to any other context.
    """
    return len(self.connections)
</t>
<t tx="ekr.20190812072050.461">@property
def id(self):
    """ The 8-byte UID of this context.
    """
    return self._id

## Public methods
</t>
<t tx="ekr.20190812072050.462">def bind(self, address, max_tries=1, name=''):
    """ bind(address, max_tries=1, name='')

    Setup a connection with another Context, by being the host.
    This method starts a thread that waits for incoming connections.
    Error messages are printed when an attemped connect fails. the
    thread keeps trying until a successful connection is made, or until
    the connection is closed.

    Returns a Connection instance that represents the
    connection to the other context. These connection objects
    can also be obtained via the Context.connections property.

    Parameters
    ----------
    address : str
        Should be of the shape hostname:port. The port should be an
        integer number between 1024 and 2**16. If port does not
        represent a number, a valid port number is created using a
        hash function.
    max_tries : int
        The number of ports to try; starting from the given port,
        subsequent ports are tried until a free port is available.
        The final port can be obtained using the 'port' property of
        the returned Connection instance.
    name : string
        The name for the created Connection instance. It can
        be used as a key in the connections property.

    Notes on hostname
    -----------------
    The hostname can be:
      * The IP address, or the string hostname of this computer.
      * 'localhost': the connections is only visible from this computer.
        Also some low level networking layers are bypassed, which results
        in a faster connection. The other context should also connect to
        'localhost'.
      * 'publichost': the connection is visible by other computers on the
        same network. Optionally an integer index can be appended if
        the machine has multiple IP addresses (see socket.gethostbyname_ex).

    """

    # Trigger cleanup of closed connections
    self.connections

    # Split address in protocol, real hostname and port number
    protocol, hostname, port = split_address(address)

    # Based on protocol, instantiate connection class (currently only tcp)
    if False:#protocol == 'itc':
        connection = ItcConnection(self, name)
    else:
        connection = TcpConnection(self, name)

    # Bind connection
    connection._bind(hostname, port, max_tries)

    # Save connection instance
    self._connections_lock.acquire()
    try:
        # Push packages from startup queue
        while len(self._startupQueue):
            connection._inject_package(self._startupQueue.pop())
        # Add connection object to list of connections
        self._connections.append(connection)
    finally:
        self._connections_lock.release()

    # Return Connection instance
    return connection
</t>
<t tx="ekr.20190812072050.463">def connect(self, address, timeout=1.0, name=''):
    """ connect(self, address, timeout=1.0, name='')

    Setup a connection with another context, by connection to a
    hosting context. An error is raised when the connection could
    not be made.

    Returns a Connection instance that represents the
    connection to the other context. These connection objects
    can also be obtained via the Context.connections property.

    Parameters
    ----------
    address : str
        Should be of the shape hostname:port. The port should be an
        integer number between 1024 and 2**16. If port does not
        represent a number, a valid port number is created using a
        hash function.
    max_tries : int
        The number of ports to try; starting from the given port,
        subsequent ports are tried until a free port is available.
        The final port can be obtained using the 'port' property of
        the returned Connection instance.
    name : string
        The name for the created Connection instance. It can
        be used as a key in the connections property.

    Notes on hostname
    -----------------
    The hostname can be:
      * The IP address, or the string hostname of this computer.
      * 'localhost': the connection is only visible from this computer.
        Also some low level networking layers are bypassed, which results
        in a faster connection. The other context should also host as
        'localhost'.
      * 'publichost': the connection is visible by other computers on the
        same network. Optionally an integer index can be appended if
        the machine has multiple IP addresses (see socket.gethostbyname_ex).

    """

    # Trigger cleanup of closed connections
    self.connections

    # Split address in protocol, real hostname and port number
    protocol, hostname, port = split_address(address)

    # Based on protocol, instantiate connection class (currently only tcp)
    if False:#protocol == 'itc':
        connection = ItcConnection(self, name)
    else:
        connection = TcpConnection(self, name)

    # Create new connection and connect it
    connection._connect(hostname, port, timeout)

    # Save connection instance
    self._connections_lock.acquire()
    try:
        # Push packages from startup queue
        while self._startupQueue:
            connection._inject_package(self._startupQueue.pop())
        # Add connection object to list of connections
        self._connections.append(connection)
    finally:
        self._connections_lock.release()

    # Send message in the network to signal a new connection
    bb = 'NEW_CONNECTION'.encode('utf-8')
    p = Package(bb, SLOT_CONTEXT, self._id, 0,0,0,0)
    self._send_package(p)

    # Return Connection instance
    return connection
</t>
<t tx="ekr.20190812072050.464">def flush(self, timeout=5.0):
    """ flush(timeout=5.0)

    Wait until all pending messages are send. This will flush all
    messages posted from the calling thread. However, it is not
    guaranteed that no new messages are posted from another thread.

    Raises an error when the flushing times out.

    """
    # Flush all connections
    for c in self.connections:
        c.flush(timeout)

    # Done (backward compatibility)
    return True

## Private methods used by the Channel classes
</t>
<t tx="ekr.20190812072050.465">def _register_sending_channel(self, channel, slot, slotname=''):
    """ _register_sending_channel(channel, slot, slotname='')

    The channel objects use this method to register themselves
    at a particular slot.

    """

    # Check if this slot is free
    if slot in self._sending_channels:
        raise ValueError("Slot not free: " + str(slotname))

    # Register
    self._sending_channels[slot] = channel
</t>
<t tx="ekr.20190812072050.466">def _register_receiving_channel(self, channel, slot, slotname=''):
    """ _register_receiving_channel(channel, slot, slotname='')

    The channel objects use this method to register themselves
    at a particular slot.

    """

    # Check if this slot is free
    if slot in self._receiving_channels:
        raise ValueError("Slot not free: " + str(slotname))

    # Register
    self._receiving_channels[slot] = channel
</t>
<t tx="ekr.20190812072050.467">def _unregister_channel(self, channel):
    """ _unregister_channel(channel)

    Unregisters the given channel. That channel can no longer
    receive messages, and should no longer send messages.

    """
    for D in [self._receiving_channels, self._sending_channels]:
        for key in [key for key in D.keys()]:
            if D[key] == channel:
                D.pop(key)

## Private methods to pass packages between context and io-threads
</t>
<t tx="ekr.20190812072050.468">def _send_package(self, package):
    """ _send_package(package)

    Used by the channels to send a package into the network.
    This method routes the package to all currentlt connected
    connections. If there are none, the packages is queued at
    the context.

    """

    # Add number
    self._send_seq += 1
    package._source_seq = self._send_seq

    # Send to all connections, or queue if there are none
    self._connections_lock.acquire()
    try:
        ok = False
        for c in self._connections:
            if c.is_alive: # Waiting or connected
                c._send_package(package)
                ok = True
        # Should we queue the package?
        if not ok:
            self._startupQueue.push(package)
    finally:
        self._connections_lock.release()
</t>
<t tx="ekr.20190812072050.469">def _recv_package(self, package, connection):
    """ _recv_package(package, connection)

    Used by the connections to receive a package at this
    context. The package is distributed to all connections
    except the calling one. The package is also distributed
    to the right channel (if applicable).

    """

    # Get slot
    slot = package._slot

    # Init what to do with the package
    send_further = False
    deposit_here = False

    # Get what to do with the package
    last_seq = self._source_map.get(package._source_id, 0)
    if last_seq &lt; package._source_seq:
        # Update source map
        self._source_map[package._source_id] = package._source_seq
        if package._dest_id == 0:
            # Add to both lists, first attach seq nr
            self._recv_seq += 1
            package._recv_seq = self._recv_seq
            send_further, deposit_here = True, True
        elif package._dest_id == self._id:
            # Add only to process list, first attach seq nr
            self._recv_seq += 1
            package._recv_seq = self._recv_seq
            deposit_here = True
        else:
            # Send package to connected nodes
            send_further = True

    # Send package to other context (over all alive connections)
    if send_further:
        self._connections_lock.acquire()
        try:
            for c in self._connections:
                if c is connection or not c.is_alive:
                    continue
                c._send_package(package)
        finally:
            self._connections_lock.release()

    # Process package here or pass to channel
    if deposit_here:
        if slot == SLOT_CONTEXT:
            # Context-to-context messaging;
            # A slot starting with a space reprsents the context
            self._recv_context_package(package)
        else:
            # Give package to a channel (if applicable)
            channel = self._receiving_channels.get(slot, None)
            if channel is not None:
                channel._recv_package(package)
</t>
<t tx="ekr.20190812072050.47">def remove(self, path):
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072050.470">def _recv_context_package(self, package):
    """ _recv_context_package(package)

    Process a package addressed at the context itself. This is how
    the context handles higher-level connection tasks.

    """

    # Get message: context messages are always utf-8 encoded strings
    message = package._data.decode('utf-8')

    if message == 'CLOSE_CONNECTION':
        # Close the connection. Check which one of our connections is
        # connected with the context that send this message.
        self._connections_lock.acquire()
        try:
            for c in self.connections:
                if c.is_connected and c.id2 == package._source_id:
                    c.close(connection.STOP_CLOSED_FROM_THERE, False)
        finally:
            self._connections_lock.release()

    elif message == 'NEW_CONNECTION':
        # Resend all status channels
        for channel in self._sending_channels.values():
            if hasattr(channel, '_current_message') and hasattr(channel, 'send_last'):
                channel.send_last()

    else:
        print('Yoton: Received unknown context message: '+message)
</t>
<t tx="ekr.20190812072050.471">@path pyzo/yoton/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.472"># -*- coding: utf-8 -*-
import sys
import time
import struct
import socket

# import select  # to determine wheter a socket can receive data
if sys.platform.startswith('java'):  # Jython
    from select import cpython_compatible_select as select, error as SelectErr
else:
    from select import select, error as SelectErr

from yoton.misc import bytes

## Constants

# Error code for interruptions
try:
    from errno import EINTR
except ImportError:
    EINTR = None

# Queue size
BUF_MAX_LEN = 10000

# Define buffer size. For recv 4096 or 8192 chunk size is recommended.
# For sending, in principle as large as possible, but prevent too much
# message copying.
BUFFER_SIZE_IN = 2**13
BUFFER_SIZE_OUT = 1*2**20

# Reserved slots (slot 0 does not exist, so we can test "if slot: ")
# The actual slots start counting from 8.
# SLOT_TEST = 3 -&gt; Deprecated
SLOT_CONTEXT = 2
SLOT_DUMMY = 1

# Struct header packing
HEADER_FORMAT = '&lt;QQQQQQQ'
HEADER_SIZE = struct.calcsize(HEADER_FORMAT)

# Constant for control bytes
CONTROL_BYTES = struct.unpack('&lt;Q', 'YOTON   '.encode('utf-8'))[0]

## Helper functions
</t>
<t tx="ekr.20190812072050.473">def can_send(s, timeout=0.0):
    """ can_send(bsd_socket, timeout=0.0)

    Given a socket, uses select() to determine whether it can be used
    for sending. This function can deal with system interrupts.

    """
    while True:
        try:
            can_recv, can_send, tmp = select([], [s], [], timeout)
            break
        except SelectErr:
            # Skip errors caused by interruptions.
            type, value, tb = sys.exc_info()
            del tb
            if value.args[0] != EINTR:
                raise
    return bool(can_send)
</t>
<t tx="ekr.20190812072050.474">def can_recv(s, timeout=0.0):
    """ can_recv(bsd_socket, timeout=0.0)

    Given a socket, uses select() to determine whether it can be used
    for receiving. This function can deal with system interrupts.

    """
    while True:
        try:
            can_recv, can_send, tmp = select([s], [], [], timeout)
            break
        except SelectErr:
            # Skip errors caused by interruptions.
            type, value, tb = sys.exc_info()
            del tb
            if value.args[0] != EINTR:
                raise
    return bool(can_recv)
</t>
<t tx="ekr.20190812072050.475">def send_all(s, text, stutdown_after_sending=True):
    """ send_all(socket, text, stutdown_after_sending=True)

    Send all text to the socket. Used during handshaking and in
    the clientserver module.

    If stutdown_after_sending, the socket is shut down. Some protocols
    rely on this.

    It is made sure that the text ends with a CRLF double-newline code.

    """

    # Ensure closing chars
    if not text.endswith('\r\n'):
        text += '\r\n'

    # Make bytes
    bb = text.encode('utf-8')

    # Send all bytes
    try:
        s.sendall(bb)  # -&gt; n
    except socket.error:
        return -1 # Socket closed down badly

    # Shutdown connection nicely from here
    if stutdown_after_sending:
        try:
            s.shutdown(socket.SHUT_WR)
        except socket.error:
            pass
</t>
<t tx="ekr.20190812072050.476">def recv_all(s, timeout=-1, end_at_crlf=True):
    """ recv_all(socket, timeout=-1, end_at_crlf=True)

    Receive text from the socket (untill socket receiving is shut down).
    Used during handshaking and in the clientserver module.

    If end_at_crlf, a message is also ended at a CRLF double-newline code,
    and a shutdown is not necessary. This takes a tiny bit longer.

    """

    # Init parts (start with one byte, such that len(parts) is always &gt;= 2
    parts = [' '.encode('ascii'),]

    # Determine number of bytes to get per recv
    nbytesToGet = BUFFER_SIZE_IN
    if end_at_crlf:
        nbytesToGet = 1

    # Set end bytes
    end_bytes = '\r\n'.encode('ascii')

    # Set max time
    if timeout &lt;= 0:
        timeout = 2**32
    maxtime = time.time() + timeout

    # Receive data
    while True:

        # Receive if we can
        if can_recv(s):

            # Get part
            try:
                part = s.recv(nbytesToGet)
                parts.append(part)
            except socket.error:
                return None # Socket closed down badly

            # Detect end by shutdown (EOF)
            if not part:
                break

            # Detect end by \r\n
            if end_at_crlf and (parts[-2] + parts[-1]).endswith(end_bytes):
                break

        else:
            # Sleep
            time.sleep(0.01)

            # Check time
            if time.time() &gt; maxtime:
                bb  = bytes().join(parts[1:])
                return bb.decode('utf-8', 'ignore')

    # Combine parts (discared first (dummy) part)
    bb = bytes().join(parts[1:])

    # Try returning as Unicode
    try:
        return bb.decode('utf-8','ignore')
    except UnicodeError:
        return '&lt;UnicodeError&gt;'

## Package class
</t>
<t tx="ekr.20190812072050.477">class Package(object):
    """ Package(data, slot, source_id, source_seq, dest_id, dest_seq, recv_seq)

    Represents a package of bytes to be send from one Context instance
    to another. A package consists of a header and the encoded message.

    To make this class as fast as reasonably possible, its interface
    is rather minimalistic and few convenience stuff is implemented.

    Parameters
    ----------
    data : bytes
        The message itself.
    slot : long
        The slot at which the package is directed. The integer is a hash of
        a string slot name.
    source_id : long
        The id of the context that sent this package.
    source_seq : long
        The sequence number of this package, counted at the sending context.
        Together with source_id, this fully identifies a package.
    dest_id : long (default 0)
        The id of the package that this package replies to.
    dest_seq : long (default 0)
        The sequence number of the package that this package replies to.
    recv_seq : long (default 0)
        The sequence number of this package counted at the receiving context.
        This is used to synchronize channels.

    When send, the header is composed of four control bytes, the slot,
    the source_id, source_seq, dest_id and dest_seq.

    Notes
    -----
    A package should always have content. Packages without content are only
    used for low-level communication between two ContextConnection instances.
    The source_seq is then used as the signal. All other package attributes
    are ignored.

    """

    # The __slots__ makes instances of this class consume &lt; 20% of memory
    # Note that this only works for new style classes.
    # This is important because many packages can exist at the same time
    # if a receiver cant keep up with a sender. Further, although Python's
    # garbage collector collects the objects after they're "consumed",
    # it does not release the memory, because it hopes to reuse it in
    # an efficient way later.
    __slots__ = [   '_data', '_slot',
                    '_source_id', '_source_seq',
                    '_dest_id', '_dest_seq',
                    '_recv_seq']

    @others
# Constant Package instances (source_seq represents the signal)
PACKAGE_HEARTBEAT   = Package(bytes(), SLOT_DUMMY, 0, 0, 0, 0, 0)
PACKAGE_CLOSE       = Package(bytes(), SLOT_DUMMY, 0, 1, 0, 0, 0)
</t>
<t tx="ekr.20190812072050.478">def __init__(self, data, slot,
            source_id, source_seq, dest_id, dest_seq, recv_seq):
    self._data = data
    self._slot = slot
    #
    self._source_id = source_id
    self._source_seq = source_seq
    self._dest_id = dest_id
    self._dest_seq = dest_seq
    self._recv_seq = recv_seq
</t>
<t tx="ekr.20190812072050.479">def parts(self):
    """ parts()

    Get list of bytes that represents this package.
    By not concatenating the header and content parts,
    we prevent unnecesary copying of data.

    """

    # Obtain header
    L = len(self._data)
    header = struct.pack(HEADER_FORMAT, CONTROL_BYTES, self._slot,
                        self._source_id, self._source_seq,
                        self._dest_id, self._dest_seq,
                        L)

    # Return header and message
    return header, self._data
</t>
<t tx="ekr.20190812072050.48">def createDir(self, path):
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072050.480">def __str__(self):
    """ Representation of the package. Mainly for debugging. """
    return 'At slot %i: %s' % (self._slot, repr(self._data))
</t>
<t tx="ekr.20190812072050.481">@classmethod
def from_header(cls, header):
    """ from_header(header)

    Create a package (without data) from the header of a message.
    Returns (package, data_length). If the header is invalid (checked
    using the four control bytes) this method returns (None, None).

    """
    # Unpack
    tmp = struct.unpack(HEADER_FORMAT, header)
    CTRL, slot, source_id, source_seq, dest_id, dest_seq, L = tmp
    # Create package
    p = Package(None, slot, source_id, source_seq, dest_id, dest_seq, 0)
    # Return
    if CTRL == CONTROL_BYTES:
        return p, L
    else:
        return None, None

</t>
<t tx="ekr.20190812072050.482">@path pyzo/yoton/
# -*- coding: utf-8 -*-

# This code is loosely based on the event system of Visvis and on the
# signals system of Qt.

# Note: Python has a buildin module (sched) that does some of the things
# here. Hoever, only since Python3.3 is this buildin functionality
# thread safe. And we need thread safety!

@others
# Instantiate an application object
app = YotonApplication()
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.483">""" Module yoton.events

Yoton comes with a simple event system to enable event-driven applications.

All channels are capable of running without the event system, but some
channels have limitations. See the documentation of the channels for
more information. Note that signals only work if events are processed.

"""

import time
import threading
import weakref

from yoton.misc import Property, getErrorMsg, PackageQueue
</t>
<t tx="ekr.20190812072050.484">class CallableObject(object):
    """ CallableObject(callable)

    A class to hold a callable. If it is a plain function, its reference
    is held (because it might be a closure). If it is a method, we keep
    the function name and a weak reference to the object. In this way,
    having for instance a signal bound to a method, the object is not
    prevented from being cleaned up.

    """
    __slots__ = ['_ob', '_func']  # Use __slots__ to reduce memory footprint

    @others
</t>
<t tx="ekr.20190812072050.485">def __init__(self, c):

    # Check
    if not hasattr(c, '__call__'):
        raise ValueError('Error: given callback is not callable.')

    # Store funcion and object
    if hasattr(c, '__self__'):
        # Method, store object and method name
        self._ob = weakref.ref(c.__self__)
        self._func = c.__func__.__name__
    elif hasattr(c, 'im_self'):
        # Method in older Python
        self._ob = weakref.ref(c.im_self)
        self._func = c.im_func.__name__
    else:
        # Plain function
        self._func = c
        self._ob = None
</t>
<t tx="ekr.20190812072050.486">def isdead(self):
    """ Get whether the weak ref is dead.
    """
    if self._ob:
        # Method
        return self._ob() is None
    else:
        return False
</t>
<t tx="ekr.20190812072050.487">def compare(self, other):
    """ compare this instance with another.
    """
    if self._ob and other._ob:
        return (self._ob() is other._ob()) and (self._func == other._func)
    elif not (self._ob or other._ob):
        return self._func == other._func
    else:
        return False
</t>
<t tx="ekr.20190812072050.488">def __str__(self):
    return self._func.__str__()
</t>
<t tx="ekr.20190812072050.489">def call(self, *args, **kwargs):
    """ call(*args, **kwargs)
    Call the callable. Exceptions are caught and printed.
    """
    if self.isdead():
        return

    # Get function
    try:
        if self._ob:
            func = getattr(self._ob(), self._func)
        else:
            func = self._func
    except Exception:
        return

    # Call it
    try:
        return func(*args, **kwargs)
    except Exception:
        print('Exception while handling event:')
        print(getErrorMsg())
</t>
<t tx="ekr.20190812072050.49">class NativeFSProxy(BaseFSProxy):
    """ File system proxy for the native file system.
    """

    @others
</t>
<t tx="ekr.20190812072050.490">class Event(object):
    """ Event(callable, *args, **kwargs)

    An Event instance represents something that is going to be done.
    It consists of a callable and arguments to call it with.

    Instances of this class populate the event queue.

    """
    __slots__ = ['_callable', '_args', '_kwargs', '_timeout']
    @others
</t>
<t tx="ekr.20190812072050.491">def __init__(self, callable, *args, **kwargs):
    if isinstance(callable, CallableObject):
        self._callable = callable
    else:
        self._callable = CallableObject(callable)
    self._args = args
    self._kwargs = kwargs
</t>
<t tx="ekr.20190812072050.492">def dispatch(self):
    """ dispatch()
    Call the callable with the arguments and keyword-arguments specified
    at initialization.
    """
    self._callable.call(*self._args, **self._kwargs)
</t>
<t tx="ekr.20190812072050.493">def _on_timeout(self):
    """ This is what theTimerThread calls.
    """
    app.post_event(self)
</t>
<t tx="ekr.20190812072050.494">class Signal:
    """ Signal()

    The purpose of a signal is to provide an interface to bind/unbind
    to events and to fire them.

    One can bind() or unbind() a callable to the signal. When emitted, an
    event is created for each bound handler. Therefore, the event loop
    must run for signals to work.

    Some signals call the handlers using additional arguments to
    specify specific information.

    """

    @others
</t>
<t tx="ekr.20190812072050.495">def __init__(self):
    self._handlers = []
</t>
<t tx="ekr.20190812072050.496">@property
def type(self):
    """ The type (__class__) of this event.
    """
    return self.__class__
</t>
<t tx="ekr.20190812072050.497">def bind(self, func):
    """ bind(func)

    Add an eventhandler to this event.

    The callback/handler (func) must be a callable. It is called
    with one argument: the event instance, which can contain
    additional information about the event.

    """

    # make callable object (checks whether func is callable)
    cnew = CallableObject(func)

    # check -&gt; warn
    for c in self._handlers:
        if cnew.compare(c):
            print("Warning: handler %s already present for %s" %(func, self))
            return

    # add the handler
    self._handlers.append(cnew)
</t>
<t tx="ekr.20190812072050.498">def unbind(self, func=None):
    """ unbind(func=None)

    Unsubscribe a handler, If func is None, remove all handlers.

    """
    if func is None:
        self._handlers[:] = []
    else:
        cref = CallableObject(func)
        for c in [c for c in self._handlers]:
            # remove if callable matches func or object is destroyed
            if c.compare(cref) or c.isdead():
                self._handlers.remove( c )
</t>
<t tx="ekr.20190812072050.499">def emit(self, *args, **kwargs):
    """ emit(*args, **kwargs)

    Emit the signal, calling all bound callbacks with *args and **kwargs.
    An event is queues for each callback registered to this signal.
    Therefore it is safe to call this method from another thread.

    """

    # Add an event for each callback
    toremove = []
    for func in self._handlers:
        if func.isdead():
            toremove.append(func)
        else:
            event = Event(func, *args, **kwargs)
            app.post_event(event)

    # Remove dead ones
    for func in toremove:
        self._handlers.remove(func)
</t>
<t tx="ekr.20190812072050.5">def process(self, proxy, **params):
    """ process(pathProxy, **params):
    This is the method that represents the task. Overload this to make
    the task do what is intended.
    """
    pass
</t>
<t tx="ekr.20190812072050.50">def listDirs(self, path):
    if isdir(path):
        pp = [op.join(path, p) for p in os.listdir(path)]
        return [str(p) for p in pp if isdir(p)]
</t>
<t tx="ekr.20190812072050.500">def emit_now(self, *args, **kwargs):
    """ emit_now(*args, **kwargs)

    Emit the signal *now*. All handlers are called from the calling
    thread. Beware, this should only be done from the same thread
    that runs the event loop.

    """

    # Add an event for each callback
    toremove = []
    for func in self._handlers:
        if func.isdead():
            toremove.append(func)
        else:
            func.call(*args, **kwargs)

    # Remove dead ones
    for func in toremove:
        self._handlers.remove(func)
</t>
<t tx="ekr.20190812072050.501">class TheTimerThread(threading.Thread):
    """ TheTimerThread is a singleton thread that is used by all timers
    and delayed events to wait for a while (in a separate thread) and then
    post an event to the event-queue. By sharing a single thread timers
    stay lightweight and there is no time spend on initializing or tearing
    down threads. The downside is that when there are a lot of timers running
    at the same time, adding a timer may become a bit inefficient because
    the registered objects must be sorted each time an object is added.
    """
    @others
# Instantiate and start the single timer thread
# We can do this as long as we do not wait for the threat, and the threat
# does not do any imports:
# http://docs.python.org/library/threading.html#importing-in-threaded-code
theTimerThread = TheTimerThread()
theTimerThread.start()
</t>
<t tx="ekr.20190812072050.502">def __init__(self):
    threading.Thread.__init__(self)
    self.setDaemon(True)
    self._exit = False
    self._timers = []
    self._somethingChanged = False
    self._condition = threading.Condition(threading.Lock())
</t>
<t tx="ekr.20190812072050.503">def stop(self, timeout=1.0):
    self._exit = True
    self._condition.acquire()
    try:
        self._condition.notify()
    finally:
        self._condition.release()
    self.join(timeout)
</t>
<t tx="ekr.20190812072050.504">def add(self, timer):
    """ add(timer)
    Add item to the list of objects to track. The object should
    have a _timeout attribute, representing the time.time() at which
    it runs out, and an _on_timeout() method to call when it does.
    """
    # Check
    if not (hasattr(timer, '_timeout') and hasattr(timer, '_on_timeout')):
        raise ValueError('Cannot add this object to theTimerThread.')
    # Add item
    self._condition.acquire()
    try:
        if timer not in self._timers:
            self._timers.append(timer)
            self._sort()
            self._somethingChanged = True
        self._condition.notify()
    finally:
        self._condition.release()
</t>
<t tx="ekr.20190812072050.505">def _sort(self):
    self._timers = sorted(self._timers,
            key=lambda x: x._timeout, reverse=True)
</t>
<t tx="ekr.20190812072050.506">def discard(self, timer):
    """Stop the timer if it hasn't finished yet"""
    self._condition.acquire()
    try:
        if timer in self._timers:
            self._timers.remove(timer)
        self._somethingChanged = True
        self._condition.notify()
    finally:
        self._condition.release()
</t>
<t tx="ekr.20190812072050.507">def run(self):
    self._condition.acquire()
    try:
        self._mainloop()
    finally:
        self._condition.release()
</t>
<t tx="ekr.20190812072050.508">def _mainloop(self):
    while not self._exit:

        # Set flag
        self._somethingChanged = False

        # Wait here, in wait() the undelying lock is released
        if self._timers:
            timer = self._timers[-1]
            timeout = timer._timeout - time.time()
            if timeout &gt; 0:
                self._condition.wait(timeout)
        else:
            timer = None
            self._condition.wait()

        # Here the lock has been re-acquired. Take action?
        if self._exit:
            break
        if (timer is not None) and (not self._somethingChanged):
            if timer._on_timeout():
                self._sort()  # Keep and resort
            else:
                self._timers.pop() # Pop

</t>
<t tx="ekr.20190812072050.509">class Timer(Signal):
    """ Timer(interval=1.0, oneshot=True)

    Timer class. You can bind callbacks to the timer. The timer is
    fired when it runs out of time.

    Parameters
    ----------
    interval : number
        The interval of the timer in seconds.
    oneshot : bool
        Whether the timer should do a single shot, or run continuously.

    """

    @others
</t>
<t tx="ekr.20190812072050.51">def listFiles(self, path):
    if isdir(path):
        pp = [op.join(path, p) for p in os.listdir(path)]
        return [str(p) for p in pp if op.isfile(p)]
</t>
<t tx="ekr.20190812072050.510">def __init__(self, interval=1.0, oneshot=True):
    Signal.__init__(self)

    # store Timer specific properties
    self.interval = interval
    self.oneshot = oneshot
    #
    self._timeout = 0
</t>
<t tx="ekr.20190812072050.511">@Property
def interval():
    """ Set/get the timer's interval in seconds.
    """
    def fget(self):
        return self._interval
    def fset(self, value):
        if not isinstance(value, (int, float)):
            raise ValueError('interval must be a float or integer.')
        if value &lt;= 0:
            raise ValueError('interval must be larger than 0.')
        self._interval = float(value)
    return locals()
</t>
<t tx="ekr.20190812072050.512">@Property
def oneshot():
    """ Set/get whether this is a oneshot timer. If not is runs
    continuously.
    """
    def fget(self):
        return self._oneshot
    def fset(self, value):
        self._oneshot = bool(value)
    return locals()
</t>
<t tx="ekr.20190812072050.513">@property
def running(self):
    """ Get whether the timer is running.
    """
    return self._timeout &gt; 0
</t>
<t tx="ekr.20190812072050.514">def start(self, interval=None, oneshot=None):
    """ start(interval=None, oneshot=None)

    Start the timer. If interval or oneshot are not given,
    their current values are used.

    """
    # set properties?
    if interval is not None:
        self.interval = interval
    if oneshot is not None:
        self.oneshot = oneshot

    # put on
    self._timeout = time.time() + self.interval
    theTimerThread.add(self)
</t>
<t tx="ekr.20190812072050.515">def stop(self):
    """ stop()

    Stop the timer from running.

    """
    theTimerThread.discard(self)
    self._timeout = 0
</t>
<t tx="ekr.20190812072050.516">def _on_timeout(self):
    """ Method to call when the timer finishes. Called from
    event-loop-thread.
    """

    # Emit signal
    self.emit()
    #print('timer timeout', self.oneshot)
    # Do we need to stop it now, or restart it
    if self.oneshot:
        # This timer instance is removed from the list of Timers
        # when the timeout is reached.
        self._timeout = 0
        return False
    else:
        # keep in the thread
        self._timeout = time.time() + self.interval
        return True
</t>
<t tx="ekr.20190812072050.517">class YotonApplication(object):
    """ YotonApplication

    Represents the yoton application and contains functions for
    the event system. Multiple instances can be created, they will
    all operate on the same event queue and share attributes
    (because these are on the class, not on the instance).

    One instance of this class is always accesible via yoton.app.
    For convenience, several of its methods are also accessible
    directly from the yoton module namespace.

    """

    # Event queues
    _event_queue = PackageQueue(10000, 'new')

    # Flag to stop event loop
    _stop_event_loop = False

    # Flag to signal whether we are in an event loop
    # Can be set externally if the event loop is hijacked.
    _in_event_loop = False

    # To allow other event loops to embed the yoton event loop
    _embedding_callback1 = None # The reference
    _embedding_callback2 = None # Used in post_event

    @others

</t>
<t tx="ekr.20190812072050.518">def call_later(self, func, timeout=0.0, *args, **kwargs):
    """ call_later(func, timeout=0.0, *args, **kwargs)

    Call the given function after the specified timeout.

    Parameters
    ----------
    func : callable
        The function to call.
    timeout : number
        The time to wait in seconds. If zero, the event is put on the event
        queue. If negative, the event will be put at the front of the event
        queue, so that it's processed asap.
    args : arguments
        The arguments to call func with.
    kwargs: keyword arguments.
        The keyword arguments to call func with.

    """

    # Wrap the object in an event
    event = Event(func, *args, **kwargs)

    # Put it in the queue
    if timeout &gt; 0:
        self.post_event_later(event, timeout)
    elif timeout &lt; 0:
        self.post_event_asap(event) # priority event
    else:
        self.post_event(event)
</t>
<t tx="ekr.20190812072050.519">def post_event(self, event):
    """ post_event(events)

    Post an event to the event queue.

    """
    YotonApplication._event_queue.push(event)
    #
    if YotonApplication._embedding_callback2 is not None:
        YotonApplication._embedding_callback2 = None
        YotonApplication._embedding_callback1()
</t>
<t tx="ekr.20190812072050.52">def modified(self, path):
    if op.isfile(path):
        return op.getmtime(path)
</t>
<t tx="ekr.20190812072050.520">def post_event_asap(self, event):
    """ post_event_asap(event)

    Post an event to the event queue. Handle as soon as possible;
    putting it in front of the queue.

    """
    YotonApplication._event_queue.insert(event)
    #
    if YotonApplication._embedding_callback2 is not None:
        YotonApplication._embedding_callback2 = None
        YotonApplication._embedding_callback1()
</t>
<t tx="ekr.20190812072050.521">def post_event_later(self, event, delay):
    """ post_event_later(event, delay)

    Post an event to the event queue, but with a certain delay.

    """
    event._timeout = time.time() + delay
    theTimerThread.add(event)
    # Calls post_event in due time
</t>
<t tx="ekr.20190812072050.522">def process_events(self, block=False):
    """ process_events(block=False)

    Process all yoton events currently in the queue.
    This function should be called periodically
    in order to keep the yoton event system running.

    block can be False (no blocking), True (block), or a float
    blocking for maximally 'block' seconds.

    """
    # Reset callback for the embedding event loop
    YotonApplication._embedding_callback2 = YotonApplication._embedding_callback1

    # Process events
    try:
        while True:
            event = YotonApplication._event_queue.pop(block)
            event.dispatch()
            block = False # Proceed until there are now more events
    except PackageQueue.Empty:
        pass
</t>
<t tx="ekr.20190812072050.523">def start_event_loop(self):
    """ start_event_loop()

    Enter an event loop that keeps calling yoton.process_events().
    The event loop can be stopped using stop_event_loop().

    """

    # Dont go if we are in an event loop
    if YotonApplication._in_event_loop:
        return

    # Set flags
    YotonApplication._stop_event_loop = False
    YotonApplication._in_event_loop = True

    try:
        # Keep blocking for 3 seconds so a keyboardinterrupt still works
        while not YotonApplication._stop_event_loop:
            self.process_events(3.0)
    finally:
        # Unset flag
        YotonApplication._in_event_loop = False
</t>
<t tx="ekr.20190812072050.524">def stop_event_loop(self):
    """ stop_event_loop()

    Stops the event loop if it is running.

    """
    if not YotonApplication._stop_event_loop:
        # Signal stop
        YotonApplication._stop_event_loop = True
        # Push an event so that process_events() unblocks
        def dummy():
            pass
        self.post_event(Event(dummy))
</t>
<t tx="ekr.20190812072050.525">def embed_event_loop(self, callback):
    """ embed_event_loop(callback)

    Embed the yoton event loop in another event loop. The given callback
    is called whenever a new yoton event is created. The callback
    should create an event in the other event-loop, which should
    lead to a call to the process_events() method. The given callback
    should be thread safe.

    Use None as an argument to disable the embedding.

    """
    YotonApplication._embedding_callback1 = callback
    YotonApplication._embedding_callback2 = callback
</t>
<t tx="ekr.20190812072050.526">@path pyzo/yoton/
# -*- coding: utf-8 -*-

@others
@language python
@tabwidth -4
@nopyflakes
</t>
<t tx="ekr.20190812072050.527">try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo.yoton.misc.py')
except Exception:
    leo_g = None

""" Module yoton.misc

Defines a few basic constants, classes and functions.

Most importantly, it defines a couple of specific buffer classes that
are used for the low-level messaging.

"""

import sys, time
import struct
import socket
import threading
import random
from collections import deque

# Version dependent defs
V2 = sys.version_info[0] == 2
if V2:
    if sys.platform.startswith('java'):
        import __builtin__ as D  # Jython
    else:
        D = __builtins__
    if not isinstance(D, dict):
        D = D.__dict__
    bytes = D['str']
    str = D['unicode']
    xrange = D['xrange']
    basestring = basestring  # noqa
    long = long  # noqa
else:
    basestring = str  # to check if instance is string
    bytes, str = bytes, str
    long = int # for the port
    xrange = range
</t>
<t tx="ekr.20190812072050.528">def Property(function):
    """ Property(function)

    A property decorator which allows to define fget, fset and fdel
    inside the function.

    Note that the class to which this is applied must inherit from object!
    Code based on an example posted by Walker Hale:
    http://code.activestate.com/recipes/410698/#c6

    """

    # Define known keys
    known_keys = 'fget', 'fset', 'fdel', 'doc'

    # Get elements for defining the property. This should return a dict
    func_locals = function()
    if not isinstance(func_locals, dict):
        raise RuntimeError('Property function should "return locals()".')

    # Create dict with kwargs for property(). Init doc with docstring.
    D = {'doc': function.__doc__}

    # Copy known keys. Check if there are invalid keys
    for key in func_locals.keys():
        if key in known_keys:
            D[key] = func_locals[key]
        else:
            raise RuntimeError('Invalid Property element: %s' % key)

    # Done
    return property(**D)
</t>
<t tx="ekr.20190812072050.529">def getErrorMsg():
    """ getErrorMsg()
    Return a string containing the error message. This is usefull, because
    there is no uniform way to catch exception objects in Python 2.x and
    Python 3.x.
    """

    # Get traceback info
    type, value, tb = sys.exc_info()

    # Store for debugging?
    if True:
        sys.last_type = type
        sys.last_value = value
        sys.last_traceback = tb

    # Print
    err = ''
    try:
        if not isinstance(value, (OverflowError, SyntaxError, ValueError)):
            while tb:
                err = "line %i of %s." % (
                        tb.tb_frame.f_lineno, tb.tb_frame.f_code.co_filename)
                tb = tb.tb_next
    finally:
        del tb
    return str(value) + "\n" + err
</t>
<t tx="ekr.20190812072050.53">def fileSize(self, path):
    if op.isfile(path):
        return op.getsize(path)
</t>
<t tx="ekr.20190812072050.530">def slot_hash(name):
    """ slot_hash(name)

    Given a string (the slot name) returns a number between 8 and 2**64-1
    (just small enough to fit in a 64 bit unsigned integer). The number
    is used as a slot id.

    Slots 0-7 are reseved slots.

    """
    fac = 0xd2d84a61
    val = 0
    offset = 8
    for c in name:
        val += ( val&gt;&gt;3 ) + ( ord(c)*fac )
    val += (val&gt;&gt;3) + (len(name)*fac)
    return offset + (val % (2**64-offset))
</t>
<t tx="ekr.20190812072050.531">def port_hash(name):
    """ port_hash(name)

    Given a string, returns a port number between 49152 and 65535.
    (2**14 (16384) different posibilities)
    This range is the range for dynamic and/or private ports
    (ephemeral ports) specified by iana.org.
    The algorithm is deterministic, thus providing a way to map names
    to port numbers.

    """
    fac = 0xd2d84a61
    val = 0
    for c in name:
        val += ( val&gt;&gt;3 ) + ( ord(c)*fac )
    val += (val&gt;&gt;3) + (len(name)*fac)
    # print('port_hash', 49152 + (val % 2**14)) # EKR
    return 49152 + (val % 2**14)
</t>
<t tx="ekr.20190812072050.532">def split_address(address):
    """ split_address(address) -&gt; (protocol, hostname, port)

    Split address in protocol, hostname and port. The address has the
    following format: "protocol://hostname:port". If the protocol is
    omitted, TCP is assumed.

    The hostname is the name or ip-address of the computer to connect to.
    One can use "localhost" for a connection that bypasses some
    network layers (and is not visible from the outside). One can use
    "publichost" for a connection at the current computers IP address
    that is visible from the outside.

    The port can be an integer, or a sting. In the latter case the integer
    port number is calculated using a hash. One can also use "portname+offset"
    to specify an integer offset for the port number.

    """

    # Check
    if not isinstance(address, basestring):
        raise ValueError("Address should be a string.")
    if not ":" in address:
        raise ValueError("Address should be in format 'host:port'.")

    # Is the protocol explicitly defined (zeromq compatibility)
    protocol = ''
    if '://' in address:
        # Get protocol and stripped address
        tmp = address.split('://',1)
        protocol = tmp[0].lower()
        address = tmp[1]
    if not protocol:
        protocol = 'tcp'

    # Split
    tmp = address.split(':',1)
    host, port = tuple(tmp)

    # Process host
    if host.lower() == 'localhost':
        host = '127.0.0.1'
    if host.lower() == 'publichost':
        host = 'publichost' + '0'
    if host.lower().startswith('publichost') and host[10:] in '0123456789':
        index = int(host[10:])
        hostname = socket.gethostname()
        tmp = socket.gethostbyname_ex(hostname)
        try:
            host = tmp[2][index]  # This resolves to 127.0.1.1 on some Linuxes
        except IndexError:
            raise ValueError('Invalid index (%i) in public host addresses.' % index)

    # Process port
    try:
        port = int(port)
    except ValueError:
        # Convert to int, using a hash

        # Is there an offset?
        offset = 0
        if "+" in port:
            tmp = port.split('+',1)
            port, offset = tuple(tmp)
            try:
                offset = int(offset)
            except ValueError:
                raise ValueError("Invalid offset in address")

        # Convert
        port = port_hash(port) + offset

    # Check port
    #if port &lt; 1024 or port &gt; 2**16:
    #    raise ValueError("The port must be in the range [1024, 2^16&gt;.")
    if port &gt; 2**16:
        raise ValueError("The port must be in the range [0, 2^16&gt;.")

    # Done
    return protocol, host, port
</t>
<t tx="ekr.20190812072050.533">class UID:
    """ UID

    Represents an 8-byte (64 bit) Unique Identifier.

    """

    _last_timestamp = 0

    @others
</t>
<t tx="ekr.20190812072050.534">def __init__(self, id=None):
    # Create nr consisting of two parts
    if id is None:
        self._nr = self._get_time_int() &lt;&lt; 32
        self._nr += self._get_random_int()
    elif isinstance(id, (int, long)):
        self._nr = id
    else:
        raise ValueError('The id given to UID() should be an int.')
</t>
<t tx="ekr.20190812072050.535">def __repr__(self):
    h = self.get_hex()
    return "&lt;UID %s-%s&gt;" % (h[:8], h[8:])
</t>
<t tx="ekr.20190812072050.536">def get_hex(self):
    """ get_hex()

    Get the hexadecimal representation of this UID. The returned
    string is 16 characters long.

    """
    h = hex(self._nr)
    h = h[2:].rstrip('L')
    h = h.ljust(2*8, '0')
    return h
</t>
<t tx="ekr.20190812072050.537">def get_bytes(self):
    """ get_bytes()

    Get the UID as bytes.

    """
    return struct.pack('&lt;Q', self._nr)
</t>
<t tx="ekr.20190812072050.538">def get_int(self):
    """ get_int()

    Get the UID as a 64 bit (long) integer.

    """
    return self._nr
</t>
<t tx="ekr.20190812072050.539">def _get_random_int(self):
    return random.randrange(0xffffffff)
</t>
<t tx="ekr.20190812072050.54">def read(self, path):
    if op.isfile(path):
        return open(path, 'rb').read()
</t>
<t tx="ekr.20190812072050.540">def _get_time_int(self):
    # Get time stamp in steps of miliseconds
    timestamp = int(time.time() * 1000)
    # Increase by one if the same as last time
    if timestamp &lt;= UID._last_timestamp:
        timestamp = UID._last_timestamp + 1
    # Store for next time
    UID._last_timestamp = timestamp
    # Truncate to 4 bytes. If the time goes beyond the integer limit, we just
    # restart counting. With this setup, the cycle is almost 25 days
    timestamp  = timestamp &amp; 0xffffffff
    # Don't allow 0
    if timestamp == 0:
        timestamp += 1
        UID._last_timestamp += 1
    return timestamp
</t>
<t tx="ekr.20190812072050.541">class PackageQueue(object):
    """ PackageQueue(N, discard_mode='old')

    A queue implementation that can be used in blocking and non-blocking
    mode and allows peeking. The queue has a limited size. The user
    can specify whether old or new messages should be discarted.

    Uses a deque object for the queue and a threading.Condition for
    the blocking.

    """

    @others
</t>
<t tx="ekr.20190812072050.542">class Empty(Exception):
    @others
</t>
<t tx="ekr.20190812072050.543">def __init__(self):
    Exception.__init__(self, 'pop from an empty PackageQueue')
pass
</t>
<t tx="ekr.20190812072050.544">def __init__(self, N, discard_mode='old'):

    # Instantiate queue and condition
    self._q = deque()
    self._condition = threading.Condition()

    # Store max number of elements in queue
    self._maxlen = int(N)

    # Store discard mode as integer
    discard_mode = discard_mode.lower()
    if discard_mode == 'old':
        self._discard_mode = 1
    elif discard_mode == 'new':
        self._discard_mode = 2
    else:
        raise ValueError('Invalid discard mode.')
</t>
<t tx="ekr.20190812072050.545">def full(self):
    """ full()

    Returns True if the number of elements is at its maximum right now.
    Note that in theory, another thread might pop an element right
    after this function returns.

    """
    return len(self) &gt;= self._maxlen
</t>
<t tx="ekr.20190812072050.546">def empty(self):
    """ empty()

    Returns True if the number of elements is zero right now. Note
    that in theory, another thread might add an element right
    after this function returns.

    """
    return len(self) == 0
</t>
<t tx="ekr.20190812072050.547">def push(self, x):
    """ push(item)

    Add an item to the queue. If the queue is full, the oldest
    item in the queue, or the given item is discarted.

    """

    condition = self._condition
    condition.acquire()
    try:
        q = self._q

        if len(q) &lt; self._maxlen:
            # Add now and notify any waiting threads in get()
            q.append(x)
            condition.notify() # code at wait() procedes
        else:
            # Full, either discard or pop (no need to notify)
            if self._discard_mode == 1:
                q.popleft() # pop old
                q.append(x)
            elif self._discard_mode == 2:
                pass # Simply do not add

    finally:
        condition.release()
</t>
<t tx="ekr.20190812072050.548">def insert(self, x):
    """ insert(x)

    Insert an item at the front of the queue. A call to pop() will
    get this item first. This should be used in rare circumstances
    to give an item priority. This method never causes items to
    be discarted.

    """

    condition = self._condition
    condition.acquire()
    try:
        self._q.appendleft(x)
        condition.notify() # code at wait() procedes
    finally:
        condition.release()
</t>
<t tx="ekr.20190812072050.549">def pop(self, block=True):
    """ pop(block=True)

    Pop the oldest item from the queue. If there are no items in the
    queue:
      * the calling thread is blocked until an item is available
        (if block=True, default);
      * an PackageQueue.Empty exception is raised (if block=False);
      * the calling thread is blocked for 'block' seconds (if block
        is a float).

    """

    condition = self._condition
    condition.acquire()
    try:
        q = self._q

        if not block:
            # Raise empty if no items in the queue
            if not len(q):
                raise self.Empty()
        elif block is True:
            # Wait for notify (awakened does not guarantee len(q)&gt;0)
            while not len(q):
                condition.wait()
        elif isinstance(block, float):
            # Wait if no items, then raise error if still no items
            if not len(q):
                condition.wait(block)
                if not len(q):
                    raise self.Empty()
        else:
            raise ValueError('Invalid value for block in PackageQueue.pop().')

        # Return item
        return q.popleft()

    finally:
        condition.release()
</t>
<t tx="ekr.20190812072050.55">def write(self, path, bb):
    with open(path, 'wb') as f:
        f.write(bb)
</t>
<t tx="ekr.20190812072050.550">def peek(self, index=0):
    """ peek(index=0)

    Get an item from the queue without popping it. index=0 gets the
    oldest item, index=-1 gets the newest item. Note that index access
    slows to O(n) time in the middle of the queue (due to the undelying
    deque object).

    Raises an IndexError if the index is out of range.

    """
    return self._q[index]
</t>
<t tx="ekr.20190812072050.551">def __len__(self):
    return self._q.__len__()
</t>
<t tx="ekr.20190812072050.552">def clear(self):
    """ clear()

    Remove all items from the queue.

    """

    self._condition.acquire()
    try:
        self._q.clear()
    finally:
        self._condition.release()
</t>
<t tx="ekr.20190812072050.553">class TinyPackageQueue(PackageQueue):
    """ TinyPackageQueue(N1, N2, discard_mode='old', timeout=1.0)

    A queue implementation that can be used in blocking and non-blocking
    mode and allows peeking. The queue has a tiny-size (N1). When this size
    is reached, a call to push() blocks for up to timeout seconds. The
    real size (N2) is the same as in the PackageQueue class.

    The tinysize mechanism can be used to semi-synchronize a consumer
    and a producer, while still having a small queue and without having
    the consumer fully block.

    Uses a deque object for the queue and a threading.Condition for
    the blocking.

    """

    @others
</t>
<t tx="ekr.20190812072050.554">def __init__(self, N1, N2, discard_mode='old', timeout=1.0):
    PackageQueue.__init__(self, N2, discard_mode)

    # Store limit above which the push() method will block
    self._tinylen = int(N1)

    # Store timeout
    self._timeout = timeout
</t>
<t tx="ekr.20190812072050.555">def push(self, x):
    """ push(item)

    Add an item to the queue. If the queue has &gt;= n1 values,
    this function will block timeout seconds, or until an item is
    popped from another thread.

    """

    condition = self._condition
    condition.acquire()
    try:
        q = self._q
        lq = len(q)

        if lq &lt; self._tinylen:
            # We are on safe side. Wake up any waiting threads if queue was empty
            q.append(x)
            condition.notify() # pop() at wait() procedes
        elif lq &lt; self._maxlen:
            # The queue is above its limit, but not full
            condition.wait(self._timeout)
            q.append(x)
        else:
            # Full, either discard or pop (no need to notify)
            if self._discard_mode == 1:
                q.popleft() # pop old
                q.append(x)
            elif self._discard_mode == 2:
                pass # Simply do not add

    finally:
        condition.release()
</t>
<t tx="ekr.20190812072050.556">def pop(self, block=True):
    """ pop(block=True)

    Pop the oldest item from the queue. If there are no items in the
    queue:
      * the calling thread is blocked until an item is available
        (if block=True, default);
      * a PackageQueue.Empty exception is raised (if block=False);
      * the calling thread is blocked for 'block' seconds (if block
        is a float).

    """

    condition = self._condition
    condition.acquire()
    try:
        q = self._q

        if not block:
            # Raise empty if no items in the queue
            if not len(q):
                raise self.Empty()
        elif block is True:
            # Wait for notify (awakened does not guarantee len(q)&gt;0)
            while not len(q):
                condition.wait()
        elif isinstance(block, float):
            # Wait if no items, then raise error if still no items
            if not len(q):
                condition.wait(block)
                if not len(q):
                    raise self.Empty()
        else:
            raise ValueError('Invalid value for block in PackageQueue.pop().')

         # Notify if this pop would reduce the length below the threshold
        if len(q) &lt;= self._tinylen:
            condition.notifyAll() # wait() procedes

        # Return item
        return q.popleft()

    finally:
        condition.release()
</t>
<t tx="ekr.20190812072050.557">def clear(self):
    """ clear()

    Remove all items from the queue.

    """

    self._condition.acquire()
    try:
        lq = len(self._q)
        self._q.clear()
        if lq &gt;= self._tinylen:
            self._condition.notify()
    finally:
        self._condition.release()
</t>
<t tx="ekr.20190812072050.558">@path pyzo/yoton/
# -*- coding: utf-8 -*-
# flake8: noqa
@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072050.559">"""
Yoton is a Python package that provides a simple interface
to communicate between two or more processes.

Yoton is ...
  * lightweight
  * written in pure Python
  * without dependencies (except Python)
  * available on Python version &gt;= 2.4, including Python 3
  * cross-platform
  * pretty fast

"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('IMPORT pyzo.yoton')
except Exception:
    leo_g = None
# Import stuff from misc and events
from yoton.misc import UID, str, bytes
from yoton.events import Signal, Timer, app

# Inject app function in yoton namespace for convenience
call_later = app.call_later
process_events = app.process_events
start_event_loop = app.start_event_loop
stop_event_loop = app.stop_event_loop
embed_event_loop = app.embed_event_loop

# Import more
from yoton.core import Package
from yoton.connection import Connection, ConnectionCollection
from yoton.connection_tcp import TcpConnection
from yoton.context import Context
from yoton.clientserver import RequestServer, do_request
from yoton.channels import *

# Set yoton version
__version__ = '2.2'
# Define convenience class
</t>
<t tx="ekr.20190812072050.56">def rename(self, path1, path2):
    os.rename(path1, path2)
</t>
<t tx="ekr.20190812072050.560">class SimpleSocket(Context):
    """ SimpleSocket()

    A simple socket has an API similar to a BSD socket. This socket
    sends whole text messages from one end to the other.

    This class subclasses the Yoton.Context class, which makes setting
    up this socket very easy.

    Example
    -------
    # One end
    s = SimpleSocket()
    s.bind('localhost:test')
    s.send("Hi")

    # Other end
    s = SimpleSocket()
    s.connect('localhost:test')
    print(s.recv())

    """

    @others
</t>
<t tx="ekr.20190812072050.561">def __init__(self, verbose=False):
    Context.__init__(self, verbose)

    # Create channels
    self._cs = PubChannel(self, 'text')
    self._cr = SubChannel(self, 'text')
</t>
<t tx="ekr.20190812072050.562">def send(self, s):
    """ send(message)

    Send a text message. The message is queued and send
    over the socket by the IO-thread.

    """
    self._cs.send(s)
</t>
<t tx="ekr.20190812072050.563">def recv(self, block=None):
    """ recv(block=None):

    Read a text from the channel. What was send as one message is
    always received as one message.

    If the channel is closed and all messages are read, returns ''.

    """
    return self._cr.recv(block)
</t>
<t tx="ekr.20190812072050.57">def remove(self, path):
    if op.isfile(path):
        os.remove(path)
    elif isdir(path):
        os.rmdir(path)
</t>
<t tx="ekr.20190812072050.58">def createDir(self, path):
    if not isdir(path):
        os.makedirs(path)
</t>
<t tx="ekr.20190812072050.59">@path pyzo/tools/pyzoFileBrowser/
# -*- coding: utf-8 -*-
# Copyright (C) 2013 Almar Klein
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.6">def _run(self, proxy):
    """ Run the task. Don't overload or use this.
    """
    try:
        params = self._params or {}
        self._result = self.process(proxy, **params)
    except Exception as err:
        self._error = 'Task failed: {}:\n{}'.format(self, str(err))
        print(self._error)
</t>
<t tx="ekr.20190812072050.60">"""
Define tasks that can be executed by the file browser.
These inherit from proxies.Task and implement that specific interface.
"""

import re
from . import proxies

</t>
<t tx="ekr.20190812072050.61">class SearchTask(proxies.Task):
    __slots__ = []

    @others
</t>
<t tx="ekr.20190812072050.62">def process(self, proxy, pattern=None, matchCase=False, regExp=False, **rest):

    # Quick test
    if not pattern:
        return

    # Get text
    text = self._getText(proxy)
    if not text:
        return

    # Get search text. Deal with case sensitivity
    searchText = text
    if not matchCase:
        searchText = searchText.lower()
        pattern = pattern.lower()

    # Search indices
    if regExp:
        indices = self._getIndicesRegExp(searchText, pattern)
    else:
        indices = self._getIndicesNormal1(searchText, pattern)

    # Return as lines
    if indices:
        return self._indicesToLines(text, indices)
    else:
        return []
</t>
<t tx="ekr.20190812072050.63">def _getText(self, proxy):

    # Init
    path = proxy.path()
    fsProxy = proxy._fsProxy

    # Get file size
    try:
        size = fsProxy.fileSize(path)
    except NotImplementedError:
        pass
    size = size or 0

    # Search all Python files. Other files need be &lt; xx bytes
    if path.lower().endswith('.py') or size &lt; 100*1024:
        pass
    else:
        return None

    # Get text
    bb = fsProxy.read(path)
    if bb is None:
        return
    try:
        return bb.decode('utf-8')
    except UnicodeDecodeError:
        # todo: right now we only do utf-8
        return None
</t>
<t tx="ekr.20190812072050.64">def _getIndicesRegExp(self, text, pattern):
    indices = []
    for match in re.finditer(pattern, text, re.MULTILINE | re.UNICODE):
            indices.append( match.start() )
    return indices
</t>
<t tx="ekr.20190812072050.65">def _getIndicesNormal1(self, text, pattern):
    indices = []
    i = -1
    while True:
        i = text.find(pattern,i+1)
        if i&gt;=0:
            indices.append(i)
        else:
            break
    return indices
</t>
<t tx="ekr.20190812072050.66">def _getIndicesNormal2(self, text, pattern):
    indices = []
    i = 0
    for line in text.splitlines(True):
        i2 = line.find(pattern)
        if i2&gt;=0:
            indices.append(i+i2)
        i += len(line)
    return indices
</t>
<t tx="ekr.20190812072050.67">def _indicesToLines(self, text, indices):

    # Determine line endings
    LE = self._determineLineEnding(text)

    # Obtain line and line numbers
    lines = []
    for i in indices:
        # Get linenr and index of the line
        linenr = text.count(LE, 0, i) + 1
        i1 = text.rfind(LE, 0, i)
        i2 = text.find(LE, i)
        # Get line and strip
        if i1&lt;0:
            i1 = 0
        line = text[i1:i2].strip()[:80]
        # Store
        lines.append( (linenr, repr(line)) )

    # Set result
    return lines
</t>
<t tx="ekr.20190812072050.68">def _determineLineEnding(self, text):
    """ function to determine quickly whether LF or CR is used
    as line endings. Windows endings (CRLF) result in LF
    (you can split lines with either char).
    """
    i = 0
    LE = '\n'
    while i &lt; len(text):
        i += 128
        LF = text.count('\n', 0, i)
        CR = text.count('\r', 0, i)
        if LF or CR:
            if CR &gt; LF:
                LE = '\r'
            break
    return LE
</t>
<t tx="ekr.20190812072050.69">class PeekTask(proxies.Task):
    """ To peek the high level structure of a task.
    """
    __slots__ = []

    stringStart = re.compile('("""|\'\'\'|"|\')|#')
    endProgs = {
        "'": re.compile(r"(^|[^\\])(\\\\)*'"),
        '"': re.compile(r'(^|[^\\])(\\\\)*"'),
        "'''": re.compile(r"(^|[^\\])(\\\\)*'''"),
        '"""': re.compile(r'(^|[^\\])(\\\\)*"""')
        }

    definition = re.compile(r'^(def|class)\s*(\w*)')

    @others
</t>
<t tx="ekr.20190812072050.7">def result(self):
    """ Get the result. Raises an error if the task failed.
    """
    if self._error:
        raise Exception(self._error)
    else:
        return self._result
</t>
<t tx="ekr.20190812072050.70">def process(self, proxy):
    path = proxy.path()
    fsProxy = proxy._fsProxy

    # Search only Python files
    if not path.lower().endswith('.py'):
        return None

    # Get text
    bb = fsProxy.read(path)
    if bb is None:
        return
    try:
        text = bb.decode('utf-8')
        del bb
    except UnicodeDecodeError:
        # todo: right now we only do utf-8
        return

    # Parse
    return list(self._parseLines(text.splitlines()))
</t>
<t tx="ekr.20190812072050.71">def _parseLines(self, lines):

    stringEndProg = None

    linenr = 0
    for line in lines:
        linenr += 1

        # If we are in a triple-quoted multi-line string, find the end
        if stringEndProg is None:
            pos = 0
        else:
            endMatch = stringEndProg.search(line)
            if endMatch is None:
                continue
            else:
                pos = endMatch.end()
                stringEndProg = None

        # Now process all tokens
        while True:
            match = self.stringStart.search(line, pos)

            if pos == 0: # If we are at the start of the line, see if we have a top-level class or method definition
                end = len(line) if match is None else match.start()
                definitionMatch = self.definition.search(line[:end])
                if definitionMatch is not None:
                    if definitionMatch.group(1) == 'def':
                        yield (linenr, 'def ' + definitionMatch.group(2))
                    else:
                        yield (linenr, 'class ' + definitionMatch.group(2))

            if match is None:
                break # Go to next line
            if match.group()=="#":
                # comment
                # yield 'C:'
                break # Go to next line
            else:
                endMatch = self.endProgs[match.group()].search(line[match.end():])
                if endMatch is None:
                    if len(match.group()) == 3 or line.endswith('\\'):
                        # Multi-line string
                        stringEndProg = self.endProgs[match.group()]
                        break
                    else: # incorrect end of single-quoted string
                        break

                # yield 'S:' + (match.group() + line[match.end():][:endMatch.end()])
                pos = match.end() + endMatch.end()
</t>
<t tx="ekr.20190812072050.72">class DocstringTask(proxies.Task):
    __slots__ = []

    @others
</t>
<t tx="ekr.20190812072050.73">def process(self, proxy):
    path = proxy.path()
    fsProxy = proxy._fsProxy

    # Search only Python files
    if not path.lower().endswith('.py'):
        return None

    # Get text
    bb = fsProxy.read(path)
    if bb is None:
        return
    try:
        text = bb.decode('utf-8')
        del bb
    except UnicodeDecodeError:
        # todo: right now we only do utf-8
        return

    # Find docstring
    lines = []
    delim = None # Not started, in progress, done
    count = 0
    for line in text.splitlines():
        count += 1
        if count &gt; 200:
            break
        # Try to find a start
        if not delim:
            if line.startswith('"""'):
                delim = '"""'
                line = line.lstrip('"')
            elif line.startswith("'''"):
                delim = "'''"
                line = line.lstrip("'")
        # Try to find an end (may be on the same line as the start)
        if delim and delim in line:
            line = line.split(delim, 1)[0]
            count = 999999999  # Stop; we found the end
        # Add this line
        if delim:
            lines.append(line)

    # Limit number of lines
    if len(lines) &gt; 16:
        lines = lines[:16] + ['...']
    # Make text and strip
    doc = '\n'.join(lines)
    doc = doc.strip()

    return doc
</t>
<t tx="ekr.20190812072050.74">class RenameTask(proxies.Task):
    __slots__ = []

    @others
</t>
<t tx="ekr.20190812072050.75">def process(self, proxy, newpath=None, removeold=False):
    path = proxy.path()
    fsProxy = proxy._fsProxy

    if not newpath:
        return

    if removeold:
        # Works for files and dirs
        fsProxy.rename(path, newpath)
        # The fsProxy will detect that this file is now deleted
    else:
        # Work only for files: duplicate
        # Read bytes
        bb = fsProxy.read(path)
        if bb is None:
            return
        # write back with new name
        fsProxy.write(newpath, bb)
</t>
<t tx="ekr.20190812072050.76">class CreateTask(proxies.Task):
    __slots__ = []

    @others
</t>
<t tx="ekr.20190812072050.77">def process(self, proxy, newpath=None, file=True):
    proxy.path()
    fsProxy = proxy._fsProxy

    if not newpath:
        return

    if file:
        fsProxy.write(newpath, b'')
    else:
        fsProxy.createDir(newpath)
</t>
<t tx="ekr.20190812072050.78">class RemoveTask(proxies.Task):
    __slots__ = []

    @others
</t>
<t tx="ekr.20190812072050.79">def process(self, proxy):
    path = proxy.path()
    fsProxy = proxy._fsProxy

    # Remove
    fsProxy.remove(path)
    # The fsProxy will detect that this file is now deleted
</t>
<t tx="ekr.20190812072050.8">## Proxy classes for directories and files
class PathProxy(QtCore.QObject):
    """ Proxy base class for DirProxy and FileProxy.

    A proxy object is used to get information on a path (folder
    contents, or file modification time), and keep being updated about
    changes in that information.

    One uses an object by connecting to the 'changed' or 'deleted' signal.
    Use setActive(True) to receive updates on these signals. If the proxy
    is no longer needed, use close() to unregister it.

    """

    changed = QtCore.Signal()
    deleted = QtCore.Signal()
    errored = QtCore.Signal(str) # Or should we pass an error per 'action'?

    taskFinished = QtCore.Signal(Task)

    @others
</t>
<t tx="ekr.20190812072050.80">@path pyzo/tools/pyzoFileBrowser/
# -*- coding: utf-8 -*-
# Copyright (C) 2013 Almar Klein
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072050.81">"""
Defines the tree widget to display the contents of a selected directory.
"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('pyzo.tools.pyzoFileBrowser.tree.py')
except Exception:
    leo_g = None
import os
import sys
import subprocess
import fnmatch
import os.path as op

import pyzo
from pyzo import translate
from . import QtCore, QtGui, QtWidgets

from . import tasks
from .utils import hasHiddenAttribute, getMounts, cleanpath, isdir, ext

# How to name the list of drives/mounts (i.e. 'my computer')
MOUNTS = 'drives'

# Create icon provider
iconprovider = QtWidgets.QFileIconProvider()
</t>
<t tx="ekr.20190812072050.82">def addIconOverlays(icon, *overlays, offset=(8,0), overlay_offset=(0,0)):
    """ Create an overlay for an icon.
    """
    # Create painter and pixmap
    pm0 = QtGui.QPixmap(16+offset[0],16)#icon.pixmap(16+offset[0],16+offset[1])
    pm0.fill(QtGui.QColor(0,0,0,0))
    painter = QtGui.QPainter()
    painter.begin(pm0)
    # Draw original icon
    painter.drawPixmap(offset[0], offset[1], icon.pixmap(16,16))
    # Draw overlays
    for overlay in overlays:
        pm1 = overlay.pixmap(16,16)
        painter.drawPixmap(overlay_offset[0],overlay_offset[1], pm1)
    # Finish
    painter.end()
    # Done (return resulting icon)
    return QtGui.QIcon(pm0)
</t>
<t tx="ekr.20190812072050.83">def _filterFileByName(basename, filters):

    # Init default; return True if there are no filters
    default = True

    for filter in filters:
        # Process filters in order
        if filter.startswith('!'):
            # If the filename matches a filter starting with !, hide it
            if fnmatch.fnmatch(basename,filter[1:]):
                return False
            default = True
        else:
            # If the file name matches a filter not starting with!, show it
            if fnmatch.fnmatch(basename, filter):
                return True
            default = False

    return default
</t>
<t tx="ekr.20190812072050.84">def createMounts(browser, tree):
    """ Create items for all known mount points (i.e. drives on Windows).
    """
    fsProxy = browser._fsProxy

    mountPoints = getMounts()
    mountPoints.sort(key=lambda x: x.lower())
    for entry in mountPoints:
        entry = cleanpath(entry)
        DriveItem(tree, fsProxy.dir(entry))
</t>
<t tx="ekr.20190812072050.85">def createItemsFun(browser, parent):
    """ Create the tree widget items for a Tree or DirItem.
    """

    # Get file system proxy and dir proxy for which we shall create items
    fsProxy = browser._fsProxy
    dirProxy = parent._proxy

    # Get meta information from browser
    searchFilter = browser.searchFilter()
    searchFilter = searchFilter if searchFilter['pattern'] else None
    expandedDirs = browser.expandedDirs
    starredDirs = browser.starredDirs

    # Prepare name filter info
    nameFilters = browser.nameFilter().replace(',', ' ').split()
    hideHidden = '!hidden' in nameFilters
    nameFilters = [f for f in nameFilters if f not in ('', '!hiddden', 'hidden')]

    # Filter the contents of this folder
    try:
        dirs = []
        for entry in dirProxy.dirs():
            entry = cleanpath(entry)
            if hideHidden and op.basename(entry).startswith('.'):
                continue # Skip hidden files
            if hideHidden and hasHiddenAttribute(entry):
                continue # Skip hidden files on Windows
            if op.basename(entry) == '__pycache__':
                continue
            dirs.append(entry)

        files = []
        for entry in dirProxy.files():
            entry = cleanpath(entry)
            if hideHidden and op.basename(entry).startswith('.'):
                continue # Skip hidden files
            if hideHidden and hasHiddenAttribute(entry):
                continue # Skip hidden files on Windows
            if not _filterFileByName(op.basename(entry), nameFilters):
                continue
            files.append(entry)

    except (OSError, IOError) as err:
        ErrorItem(parent, str(err))
        return

    # Sort dirs (case insensitive)
    dirs.sort(key=filename2sortkey)

    # Sort files (first by type, then by name, logically)
    files.sort(key=filename2sortkey)

    if not searchFilter:

        # Create dirs
        for path in dirs:
            starred = op.normcase(path) in starredDirs
            item = DirItem(parent, fsProxy.dir(path), starred)
            # Set hidden, we can safely expand programmatically when hidden
            item.setHidden(True)
            # Set expanded and visibility
            if op.normcase(path) in expandedDirs:
                item.setExpanded(True)
            item.setHidden(False)

        # Create files
        for path in files:
            item = FileItem(parent, fsProxy.file(path))

    else:

        # If searching, inject everything in the tree
        # And every item is hidden at first
        parent = browser._tree
        if parent.topLevelItemCount():
            searchInfoItem = parent.topLevelItem(0)
        else:
            searchInfoItem = SearchInfoItem(parent)

        # Increase number of found files
        searchInfoItem.increaseTotal(len(files))

        # Create temporary file items
        for path in files:
            item = TemporaryFileItem(parent, fsProxy.file(path))
            item.search(searchFilter)

        # Create temporary dir items
        if searchFilter['subDirs']:
            for path in dirs:
                item = TemporaryDirItem(parent, fsProxy.dir(path))

    # Return number of files added
    return len(dirs) + len(files)
</t>
<t tx="ekr.20190812072050.86">def filename2sortkey(name):
    """ Convert a file or dir name to a tuple that can be used to
    logically sort them. Sorting first by extension.
    """
    # Normalize name
    name = os.path.basename(name).lower()
    name, e = os.path.splitext(name)
    # Split the name in logical parts
    try:
        numbers = '0123456789'
        name1 = name.lstrip(numbers)
        name2 = name1.rstrip(numbers)
        n_pre = len(name) - len(name1)
        n_post = len(name1) - len(name2)
        pre = int(name[:n_pre]) if n_pre else 999999999
        post = int(name[-n_post:]) if n_post else -1
        return e, pre, name2, post
    except Exception as err:
        # I cannot see how this could fail, but lets be safe, as it would break so badly
        print('Warning: could not filename2sortkey(%r), please report:\n%s' % (name, str(err)))
        return (e, 999999999, name, -1)
</t>
<t tx="ekr.20190812072050.87">class BrowserItem(QtWidgets.QTreeWidgetItem):
    """ Abstract item in the tree widget.
    """

    @others
</t>
<t tx="ekr.20190812072050.88">def __init__(self, parent, pathProxy, *args):
    self._proxy = pathProxy
    QtWidgets.QTreeWidgetItem.__init__(self, parent, [], *args)
    # Set pathname to show, and icon
    strippedParentPath = parent.path().rstrip('/\\')
    if self.path().startswith(strippedParentPath):
        basename = self.path()[len(strippedParentPath)+1:]
    else:
        basename = self.path() #  For mount points
    self.setText(0, basename)
    self.setFileIcon()
    # Setup interface with proxy
    self._proxy.changed.connect(self.onChanged)
    self._proxy.deleted.connect(self.onDeleted)
    self._proxy.errored.connect(self.onErrored)
    self._proxy.taskFinished.connect(self.onTaskFinished)
</t>
<t tx="ekr.20190812072050.89">def path(self):
    return self._proxy.path()
</t>
<t tx="ekr.20190812072050.9">def __init__(self, fsProxy, path):
    QtCore.QObject.__init__(self)
    self._lock = threading.RLock()
    self._fsProxy = fsProxy
    self._path = path
    self._cancelled = False
    # For tasks
    self._pendingTasks = []
    self._finishedTasks = []
</t>
<t tx="ekr.20190812072050.90">def _createDummyItem(self, txt):
    ErrorItem(self, txt)
    #QtWidgets.QTreeWidgetItem(self, [txt])
</t>
<t tx="ekr.20190812072050.91">def onDestroyed(self):
    self._proxy.cancel()
</t>
<t tx="ekr.20190812072050.92">def clear(self):
    """ Clear method that calls onDestroyed on its children.
    """
    for i in reversed(range(self.childCount())):
        item = self.child(i)
        if hasattr(item, 'onDestroyed'):
            item.onDestroyed()
        self.removeChild(item)

# To overload ...
</t>
<t tx="ekr.20190812072050.93">def onChanged(self):
    pass
</t>
<t tx="ekr.20190812072050.94">def onDeleted(self):
    pass
</t>
<t tx="ekr.20190812072050.95">def onErrored(self, err):
    self.clear()
    self._createDummyItem('Error: ' + err)
</t>
<t tx="ekr.20190812072050.96">def onTaskFinished(self, task):
    # Getting the result raises exception if an error occured.
    # Which is what we want; so it is visible in the logger shell
    task.result()
</t>
<t tx="ekr.20190812072050.97">class DriveItem(BrowserItem):
    """ Tree widget item for directories.
    """

    @others
</t>
<t tx="ekr.20190812072050.98">def __init__(self, parent, pathProxy):
    BrowserItem.__init__(self, parent, pathProxy)
    # Item is not expandable
</t>
<t tx="ekr.20190812072050.99">def setFileIcon(self):
    # Use folder icon
    self.setIcon(0, pyzo.icons.drive)
</t>
<t tx="ekr.20190812072051.10">def _send(self, message, dest_id=0, dest_seq=0):
    """ _send(message, dest_id=0, dest_seq=0)

    Sends a message of raw bytes without checking whether they're bytes.
    Optionally, dest_id and dest_seq represent the message that
    this message  replies to. These are used for the request/reply
    pattern.

    Returns the package that will be send (or None). The context
    will set _source_id on the package right before
    sending it away.

    """

    # Check if still open
    if self._closed:
        className = self.__class__.__name__
        raise IOError("Cannot send from closed %s %i." % (className, id(self)))

    if message:
        # If send_locked, wait at most one second
        if self._is_send_locked:
            self._send_condition.acquire()
            try:
                self._send_condition.wait(1.0) # wait for notify
            finally:
                self._send_condition.release()
                if time.time() &gt; self._is_send_locked:
                    self._is_send_locked = 0
        # Push it on the queue as a package
        slot = self._slot_out_h
        cid = self._context._id
        p = Package(message, slot, cid, 0, dest_id, dest_seq, 0)
        self._context._send_package(p)
        # Return package
        return p
    else:
        return None
</t>
<t tx="ekr.20190812072051.100">@path pyzo/yoton/channels/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.101"># -*- coding: utf-8 -*-
""" Module yoton.channels.channels_state

Defines the channel class for state.

"""

from yoton.misc import bytes
from yoton.channels import BaseChannel
</t>
<t tx="ekr.20190812072051.102">class StateChannel(BaseChannel):
    """ StateChannel(context, slot_base, message_type=yoton.TEXT)

    Channel class for the state messaging pattern. A state is synchronized
    over all state channels of the same slot. Each channel can
    send (i.e. set) the state and recv (i.e. get) the current state.
    Note however, that if two StateChannel instances set the state
    around the same time, due to the network delay, it is undefined
    which one sets the state the last.

    The context will automatically call this channel's send_last()
    method when a new context enters the network.

    The recv() call is always non-blocking and always returns the last
    received message: i.e. the current state.

    There are no limitations for this channel if events are not
    processed, except that the received signal is not emitted.

    Parameters
    ----------
    context : yoton.Context instance
        The context that this channel uses to send messages in a network.
    slot_base : string
        The base slot name. The channel appends an extension to indicate
        message type and messaging pattern to create the final slot name.
        The final slot is used to connect channels at different contexts
        in a network
    message_type : yoton.MessageType instance
        (default is yoton.TEXT)
        Object to convert messages to bytes and bytes to messages.
        Users can create their own message_type class to let channels
        any type of message they want.

    """

    @others
</t>
<t tx="ekr.20190812072051.103">def __init__(self, *args, **kwargs):
    BaseChannel.__init__(self, *args, **kwargs)

    # Variables to hold the current state. We use only the message
    # as a reference, so we dont need a lock.
    # The package is used to make _recv() function more or less,
    # and to be able to determine if a state was set (because the
    # message may be set to None)
    self._current_package = None
    self._current_message = self.message_from_bytes(bytes())
</t>
<t tx="ekr.20190812072051.104">def _messaging_patterns(self):
    return 'state', 'state'
</t>
<t tx="ekr.20190812072051.105">def send(self, message):
    """ send(message)

    Set the state of this channel.

    The state-message is queued and send over the socket by the IO-thread.
    Zero-length messages are ignored.

    """
    # Send message only if it is different from the current state
    # set current_message by unpacking the send binary. This ensures
    # that if someone does this, things still go well:
    #    a = [1,2,3]
    #    status.send(a)
    #    a.append(4)
    #    status.send(a)
    if message != self._current_message:
        self._current_package = self._send( self.message_to_bytes(message) )
        self._current_message = self.message_from_bytes(self._current_package._data)
</t>
<t tx="ekr.20190812072051.106">def send_last(self):
    """ send_last()

    Resend the last message.

    """
    if self._current_package is not None:
        self._send( self.message_to_bytes(self._current_message) )
</t>
<t tx="ekr.20190812072051.107">def recv(self, block=False):
    """ recv(block=False)

    Get the state of the channel. Always non-blocking. Returns the
    most up to date state.

    """
    return self._current_message
</t>
<t tx="ekr.20190812072051.108">def _recv_package(self, package):
    """ _recv_package(package)

    Bypass queue and just store it in a variable.

    """
    self._current_message = self.message_from_bytes(package._data)
    self._current_package = package
    #
    self._maybe_emit_received()
</t>
<t tx="ekr.20190812072051.109">def _inject_package(self, package):
    """ Non-blocking version of recv_package. Does the same.
    """
    self._current_message = self.message_from_bytes(package._data)
    self._current_package = package
    #
    self._maybe_emit_received()
</t>
<t tx="ekr.20190812072051.11">def _recv(self, block):
    """ _recv(block)

    Receive a package (or None).

    """

    if block is True:
        # Block for 0.25 seconds so that KeyboardInterrupt works
        while not self._closed:
            try:
                return self._q_in.pop(0.25)
            except self._q_in.Empty:
                continue

    else:
        # Block normal
        try:
            return self._q_in.pop(block)
        except self._q_in.Empty:
            return None
</t>
<t tx="ekr.20190812072051.110">def _recv(self, block=None):
    """ _recv(block=None)

    Returns the last received or send set package. The package
    may not reflect the current state.

    """
    return self._current_package
</t>
<t tx="ekr.20190812072051.111">@path pyzo/yoton/channels/
# -*- coding: utf-8 -*-
""" Module yoton.channels.message_types

Defines a few basic message_types for the channels. A MessageType object
defines how a message of that type should be converted to bytes and
vice versa.

The Packer and Unpacker classes for the ObjectMessageType are based on
the xdrrpc Python module by Rob Reilink and Windel Bouwman.

"""

@others

# Define constants
TEXT = TextMessageType()
BINARY = BinaryMessageType()
OBJECT = ObjectMessageType()

if __name__ == '__main__':
    # Test

    s = {}
    s['foo'] = 3
    s['bar'] = 9
    s['empty'] = []
    s[(2,'aa',3)] = ['pretty', ('nice', 'eh'), 4]

    bb = OBJECT.message_to_bytes(s)
    s2 = OBJECT.message_from_bytes(bb)
    print(s)
    print(s2)
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.112">import sys
import struct
from yoton.misc import bytes, basestring, long

# To decode P2k strings that are not unicode
if sys.__stdin__ and sys.__stdin__.encoding:
    STDINENC = sys.__stdin__.encoding
elif sys.stdin and sys.stdin.encoding:
    STDINENC = sys.stdin.encoding
else:
    STDINENC = 'utf-8'
</t>
<t tx="ekr.20190812072051.113">class MessageType(object):
    """ MessageType()

    Instances of this class are used to convert messages to bytes and
    bytes to messages.

    Users can easily inherit from this class to make channels work for
    user specific message types. Three methods should be overloaded:
      * message_to_bytes()  - given a message, returns bytes
      * message_from_bytes() - given bytes, returns the message
      * message_type_name() - a string (for example 'text', 'array')

    The message_type_name() method is used by the channel to add an
    extension to the slot name, such that only channels of the same
    message type (well, with the same message type name) can connect.

    """

    @others
</t>
<t tx="ekr.20190812072051.114">def message_to_bytes(self, message):
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072051.115">def message_from_bytes(self, bb):
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072051.116">def message_type_name(self):
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072051.117">class BinaryMessageType(MessageType):
    """ BinaryMessageType()

    To let channels handle binary messages.
    Available as yoton.BINARY.

    """

    @others
</t>
<t tx="ekr.20190812072051.118">def message_type_name(self):
    return 'bin'
</t>
<t tx="ekr.20190812072051.119">def message_to_bytes(self, message):
    if not isinstance(message, bytes):
        raise ValueError("Binary channel requires byte messages.")
    return message
</t>
<t tx="ekr.20190812072051.12">def _set_send_lock(self, value):
    """ _set_send_lock(self, value)

    Set or unset the blocking for the _send() method.

    """
    # Set send lock variable. We adopt a timeout (10s) just in case
    # the SubChannel that locks the PubChannel gets disconnected and
    # is unable to unlock it.
    if value:
        self._is_send_locked = time.time() + 10.0
    else:
        self._is_send_locked = 0
    # Notify any threads that are waiting in _send()
    if not value:
        self._send_condition.acquire()
        try:
            self._send_condition.notifyAll()
        finally:
            self._send_condition.release()

## How packages are inserted in this channel for receiving
</t>
<t tx="ekr.20190812072051.120">def message_from_bytes(self, bb):
    return bb
</t>
<t tx="ekr.20190812072051.121">class TextMessageType(MessageType):
    """ BinaryMessageType()

    To let channels handle Unicode text messages.
    Available as yoton.TEXT.

    """

    @others
</t>
<t tx="ekr.20190812072051.122">def message_type_name(self):
    return 'txt'
</t>
<t tx="ekr.20190812072051.123">def message_to_bytes(self, message):

    # Check
    if not isinstance(message, basestring):
        raise ValueError("Text channel requires string messages.")

    # If using py2k and the string is not unicode, make unicode first
    # by try encoding using UTF-8. When a piece of code stored
    # in a unicode string is executed, str objects are utf-8 encoded.
    # Otherwise they are encoded using __stdin__.encoding. In specific
    # cases, a non utf-8 encoded str might be succesfully encoded
    # using utf-8, but this is rare. Since I would not
    # know how to tell the encoding beforehand, we'll take our
    # chances... Note that in Pyzo (for which this package was created,
    # all executed code is unicode, so str instrances are always
    # utf-8 encoded.
    if isinstance(message, bytes):
        try:
            message = message.decode('utf-8')
        except UnicodeError:
            try:
                message = message.decode(STDINENC)
            except UnicodeError:
                # Probably not really a string then?
                message = repr(message)

    # Encode and send
    return message.encode('utf-8')
</t>
<t tx="ekr.20190812072051.124">def message_from_bytes(self, bb):
    return bb.decode('utf-8')
</t>
<t tx="ekr.20190812072051.125">class ObjectMessageType(MessageType):
    """ ObjectMessageType()

    To let channels handle messages consisting of any of the following
    Python objects: None, bool, int, float, string, list, tuple, dict.
    Available as yoton.OBJECT.

    """

    @others
</t>
<t tx="ekr.20190812072051.126">def message_type_name(self):
    return 'obj'
</t>
<t tx="ekr.20190812072051.127">def message_to_bytes(self, message):
    packer = Packer()
    packer.pack_object(message)
    return packer.get_buffer()
</t>
<t tx="ekr.20190812072051.128">def message_from_bytes(self, bb):
    if bb:
        unpacker = Unpacker(bb)
        return unpacker.unpack_object()
    else:
        return None

</t>
<t tx="ekr.20190812072051.129"># Formats
_FMT_TYPE = '&lt;B'
_FMT_BOOL = '&lt;B'
_FMT_INT = '&lt;q'
_FMT_FLOAT = '&lt;d'

# Types
_TYPE_NONE = ord('n')
_TYPE_BOOL = ord('b')
_TYPE_INT = ord('i')
_TYPE_FLOAT = ord('f')
_TYPE_STRING = ord('s')
_TYPE_LIST = ord('l')
_TYPE_TUPLE = ord('t')
_TYPE_DICT = ord('d')
class Packer:

    # Note that while xdrlib uses StringIO/BytesIO, this approach using
    # a list is actually faster.

    @others
</t>
<t tx="ekr.20190812072051.13">def _inject_package(self, package):
    """ _inject_package(package)

    Same as _recv_package, but by definition do not block.
    _recv_package is overloaded in SubChannel. _inject_package is not.

    """
    self._q_in.push(package)
    self._maybe_emit_received()
</t>
<t tx="ekr.20190812072051.130">def __init__(self):
    self._buf = []
</t>
<t tx="ekr.20190812072051.131">def get_buffer(self):
    return bytes().join(self._buf)
</t>
<t tx="ekr.20190812072051.132">def write(self, bb):
    self._buf.append(bb)
</t>
<t tx="ekr.20190812072051.133">def write_number(self, n):
    if n &lt; 255:
        self.write( struct.pack('&lt;B', n) )
    else:
        self.write( struct.pack('&lt;B', 255) )
        self.write( struct.pack('&lt;Q', n) )
</t>
<t tx="ekr.20190812072051.134">def pack_object(self, object):

    if object is None:
        self.write( struct.pack(_FMT_TYPE, _TYPE_NONE) )
    elif isinstance(object, bool):
        self.write( struct.pack(_FMT_TYPE, _TYPE_BOOL) )
        self.write( struct.pack(_FMT_BOOL, object) )
    elif isinstance(object, (int, long)):
        self.write( struct.pack(_FMT_TYPE, _TYPE_INT) )
        self.write( struct.pack(_FMT_INT, object) )
    elif isinstance(object, float):
        self.write( struct.pack(_FMT_TYPE, _TYPE_FLOAT) )
        self.write( struct.pack(_FMT_FLOAT, object) )
    elif isinstance(object, basestring):
        bb = object.encode('utf-8')
        self.write( struct.pack(_FMT_TYPE, _TYPE_STRING) )
        self.write_number(len(bb))
        self.write( bb )
    elif isinstance(object, list):
        self.write( struct.pack(_FMT_TYPE, _TYPE_LIST) )
        self.write_number(len(object))
        for value in object:
            self.pack_object(value) # call recursive
    elif isinstance(object, tuple):
        self.write( struct.pack(_FMT_TYPE, _TYPE_TUPLE) )
        self.write_number(len(object))
        for value in object:
            self.pack_object(value) # call recursive
    elif isinstance(object, dict):
        self.write( struct.pack(_FMT_TYPE, _TYPE_DICT) )
        self.write_number(len(object))
        # call recursive
        for key in object:
            self.pack_object(key)
            self.pack_object(object[key])
    else:
        raise ValueError("Unsupported type: %s" % repr(type(object)))
</t>
<t tx="ekr.20190812072051.135">class Unpacker:

    @others
</t>
<t tx="ekr.20190812072051.136">def __init__(self, data):
    self._buf = data
    self._pos = 0
</t>
<t tx="ekr.20190812072051.137">def read(self, n):
    i1 = self._pos
    i2 = self._pos + n
    if i2 &gt; len(self._buf):
        raise EOFError
    else:
        self._pos = i2
        return self._buf[i1:i2]
</t>
<t tx="ekr.20190812072051.138">def read_number(self):
    n, = struct.unpack('&lt;B', self.read(1))
    if n == 255:
        n, = struct.unpack('&lt;Q', self.read(8))
    return n
</t>
<t tx="ekr.20190812072051.139">def unpack(self, fmt, n):
    i1 = self._pos
    i2 = self._pos + n
    if i2 &gt; len(self._buf):
        raise EOFError
    else:
        self._pos = i2
        data = self._buf[i1:i2]
        return struct.unpack(fmt, data)[0]
</t>
<t tx="ekr.20190812072051.14">def _recv_package(self, package):
    """ _recv_package(package)

    Put package in the queue.

    """
    self._q_in.push(package)
    self._maybe_emit_received()
</t>
<t tx="ekr.20190812072051.140">def unpack_object(self):

    object_type = self.unpack(_FMT_TYPE, 1)

    if object_type == _TYPE_NONE:
        return None
    elif object_type == _TYPE_BOOL:
        return bool( self.unpack(_FMT_BOOL, 1) )
    elif object_type == _TYPE_INT:
        return self.unpack(_FMT_INT, 8)
    elif object_type == _TYPE_FLOAT:
        return self.unpack(_FMT_FLOAT, 8)
    elif object_type == _TYPE_STRING:
        n = self.read_number()
        return self.read(n).decode('utf-8')
    elif object_type == _TYPE_LIST:
        object = []
        for i in range(self.read_number()):
            object.append( self.unpack_object() )
        return object
    elif object_type == _TYPE_TUPLE:
        object = []
        for i in range(self.read_number()):
            object.append( self.unpack_object() )
        return tuple(object)
    elif object_type == _TYPE_DICT:
        object = {}
        for i in range(self.read_number()):
            key = self.unpack_object()
            object[key] = self.unpack_object()
        return object
    else:
        raise ValueError("Unsupported type: %s" % repr(object_type))
</t>
<t tx="ekr.20190812072051.141">@path pyzo/yoton/channels/
# -*- coding: utf-8 -*-
# flake8: noqa
@others
@language python
@tabwidth -4
@nopyflakes</t>
<t tx="ekr.20190812072051.142">"""
The channel classes represent the mechanism for the user to send
messages into the network and receive messages from it. A channel
needs a context to function; the context represents a node in the
network.
"""
try:
    import leo.core.leoGlobals as leo_g
    # leo_g.pr('IMPORT pyzo.yoton.channels')
except Exception:
    leo_g = None
from yoton.channels.message_types import MessageType, TEXT, BINARY, OBJECT
from yoton.channels.channels_base import BaseChannel
from yoton.channels.channels_pubsub import PubChannel, SubChannel, select_sub_channel
from yoton.channels.channels_reqrep import ReqChannel, RepChannel, Future, TimeoutError, CancelledError
from yoton.channels.channels_state import StateChannel
from yoton.channels.channels_file import FileWrapper
</t>
<t tx="ekr.20190812072051.144"></t>
<t tx="ekr.20190812072051.145">@path pyzo/yoton/tests/
@others
if __name__ == '__main__':

    # Get path of yoton
    path = os.path.dirname(os.path.abspath(__file__))
    path = os.path.split(path)[0]

    # Init files
    files = []
    # Get files in root
    for fname in os.listdir(path):
        files.append(fname)
    # Get files in channels
    for fname in os.listdir(os.path.join(path,'channels')):
        fname = os.path.join('channels', fname)
        files.append(fname)

    N1, N2, N3, N4 = 0, 0, 0, 0
    for fname in files:
        if not fname.endswith('.py'):
            continue
        n1, n2, n3, n4 = count_lines(os.path.join(path, fname))
        N1 += n1
        N2 += n2
        N3 += n3
        N4 += n4
        print('%i lines in %s' % (n1, fname))

    print('yoton has %i lines in its source' % (N1+N2+N3+N4))
    print('yoton has %i lines of code' % N1)
    print('yoton has %i lines of docstring' % N2)
    print('yoton has %i comment lines' % N3)
    print('yoton has %i lines of whitespace' % N4)
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.146">import os
</t>
<t tx="ekr.20190812072051.147">def count_lines(filename):

    # Get text
    text = open(filename, 'r').read()

    # Init counts: code, docstring, comments, whitespace
    count1, count2, count3, count4 = 0, 0, 0, 0

    inDocstring = False
    for line in text.splitlines():
        line = line.strip()
        if '"'*3 in line:
            inDocstring = not inDocstring
        if not line:
            count4 += 1
        elif inDocstring:
            count2 += 1
        elif line.startswith('#') or line.startswith('%'):
            count3 += 1
        else:
            count1 += 1

    # Done
    return count1, count2, count3, count4
</t>
<t tx="ekr.20190812072051.148">@path pyzo/yoton/tests/
# -*- coding: utf-8 -*-
# This example demponstrates simple req rep.
#
# This time in event driven mode. This example only works locally, as
# we cannot start two event loops :)

## ========== One end

import yoton
verbosity = 0

&lt;&lt; define class Reducer &gt;&gt;

# Create a context and a rep channel
ct1 = yoton.Context(verbose=verbosity)
rep = Reducer(ct1, 'reduce')

# Connect and turn duplicator on
ct1.bind('publichost:test')
rep.set_mode('event')

## ========== Other end

import yoton
import time
verbosity = 0

# Create a context and a req channel
ct2 = yoton.Context(verbose=verbosity)
req = yoton.ReqChannel(ct2, 'reduce')

# Connect
ct2.connect('publichost:test')

# Create reply handler and bind it
&lt;&lt; define reply_handler &gt;&gt;
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.15">def _maybe_emit_received(self):
    """ _maybe_emit_received()

    We want to emit a signal, but in such a way that multiple
    arriving packages result in a single emit. This methods
    only posts an event if it has not been done, or if the previous
    event has been handled.

    """
    if not self._posted_received_event:
        self._posted_received_event = True
        event = yoton.events.Event(self._emit_received)
        yoton.app.post_event(event)
</t>
<t tx="ekr.20190812072051.150"># Create a replier class by subclassing RepChannel
class Reducer(yoton.RepChannel):
    @others
</t>
<t tx="ekr.20190812072051.151">def reduce(self, item):
    if item == 2:
        raise ValueError('I do not like 2.')
    return item - 1
</t>
<t tx="ekr.20190812072051.152">def reply_handler(future):

    # Check error, cancelled, or get number
    if future.exception():
        # Calling result() would raise the exception, so lets just
        # print it and make up our own number
        print('oops: ' + str(future.exception()))
        number = 1
    elif future.cancelled():
        print('oops: request was cancelled.')
    else:
        number = future.result()

    if number &gt; 0:
        print('we now have %i.' % number)
        time.sleep(0.5)
        new_future = req.reduce(number)
        new_future.add_done_callback(reply_handler)
    else:
        print('Done')
        yoton.stop_event_loop()

# Send first message
new_future = req.reduce(7)
new_future.add_done_callback(reply_handler)

# Enter event loop
yoton.start_event_loop()
</t>
<t tx="ekr.20190812072051.153">@path pyzo/yoton/tests/
# -*- coding: utf-8 -*-
# This example demponstrates simple pub sub.
#
# This time in event driven mode. This example only works locally, as
# we cannot start two event loops :)

## ========== One end

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.154">import yoton
verbosity = 0

# Create a context and a pub channel
ct1 = yoton.Context(verbose=verbosity)
pub = yoton.PubChannel(ct1, 'foo')

# Connect and turn duplicator on
ct1.bind('publichost:test')

## ========== Other end

import yoton
verbosity = 0

# Create a context and a sub channel
ct2 = yoton.Context(verbose=verbosity)
sub = yoton.SubChannel(ct2, 'foo')

# Connect, set channel to event driven mode
ct2.connect('publichost:test')

# Create message handler
</t>
<t tx="ekr.20190812072051.155">def message_handler():
    message = sub.recv(False)
    if message:
        print(message)
        if message.lower() == 'stop':
            yoton.stop_event_loop()

# Bind handler to a timer
timer = yoton.Timer(0.1, False)
timer.bind(message_handler)
timer.start()

# Send messages
yoton.call_later(pub.send, 8, 'stop')
yoton.call_later(pub.send, 2, '2 seconds')
yoton.call_later(pub.send, 4, '4 seconds')
yoton.call_later(pub.send, 6, 'almost done')

# Enter event loop
yoton.start_event_loop()
</t>
<t tx="ekr.20190812072051.156">@path pyzo/yoton/tests/
# -*- coding: utf-8 -*-
# This example illustrates a simple pub/sub pattern.
# This example can be run in one go or in two parts running in
# different processes.

## ========== One end

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.157">import yoton
verbosity = 0 # Python 2.4 can crash with verbosity on

# Create one context and a pub channel
ct1 = yoton.Context(verbose=verbosity)
pub = yoton.PubChannel(ct1, 'chat')

# Connect
ct1.bind('publichost:test')

# Send
pub.send('hello world')

## ========== Other end

import yoton
verbosity = 0

# Create another context and a sub channel
ct2 = yoton.Context(verbose=verbosity)
sub = yoton.SubChannel(ct2, 'chat')

# Connect
ct2.connect('publichost:test')

# Receive
print(sub.recv())

##
c1 = ct1.connections[0]
c2 = ct2.connections[0]
c1s = c1._sendingThread
c1r = c1._receivingThread
c2s = c2._sendingThread
c2r = c2._receivingThread
</t>
<t tx="ekr.20190812072051.158">@path pyzo/yoton/tests/
# -*- coding: utf-8 -*-
# This example creates three contexts that are connected in a row.
# A message is send at the first and received at the last.

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.159">import yoton

# Three contexts
verbosity = 2
c1 = yoton.Context(verbosity)
c2 = yoton.Context(verbosity)
c3 = yoton.Context(verbosity)
c4 = yoton.Context(verbosity)

# Connect in a row
addr = 'localhost:whop'
c1.bind(addr+'+1')
c2.connect(addr+'+1')
c2.bind(addr+'+2')
c3.connect(addr+'+2')
c3.bind(addr+'+3')
c4.connect(addr+'+3')

# Create pub at first and sub at last
p = yoton.PubChannel(c1, 'hop')
s = yoton.SubChannel(c4, 'hop')

# Send a message.
p.send('hophophop')
print(s.recv())
</t>
<t tx="ekr.20190812072051.16">def _emit_received(self):
    """ _emit_received()

    Emits the "received" signal. This method is called once new data
    has been received. However, multiple arrived messages may
    result in a single call to this method. There is also no
    guarantee that recv() has not been called in the mean time.

    Also sets the variabele so that a new event for this may be
    created. This method is called from the event loop.

    """
    self._posted_received_event = False # Reset
    self.received.emit_now(self)

# Received property sits on the BaseChannel because is is used by almost
# all channels. Note that PubChannels never emit this signal as they
# catch status messages from the SubChannel by overloading _recv_package().
</t>
<t tx="ekr.20190812072051.160">@path pyzo/yoton/tests/
# -*- coding: utf-8 -*-

# This example defines a message type and sends such a message over pub/sub.
# This example can be run in one go or in two parts running in
# different processes.

## ========== One end

import yoton
verbosity = 0

&lt;&lt; class NumberMessageType 1 &gt;&gt;

# Create context, a channel, and connect
ct1 = yoton.Context(verbose=verbosity)
pub = yoton.PubChannel(ct1, 'numbers', NumberMessageType)
ct1.bind('publichost:test')

# Send a message
pub.send(42.9)

## ========== Other end

import yoton
verbosity = 0

&lt;&lt; class NumberMessageType 2 &gt;&gt;
# Create a context, a channel, and connect
ct2 = yoton.Context(verbose=verbosity)
sub = yoton.SubChannel(ct2, 'numbers', NumberMessageType)
ct2.connect('publichost:test')

# Duplicate a string and a number
print(sub.recv())
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.162"># Create custom message type. (should be defined at both ends)
class NumberMessageType(yoton.MessageType):
    @others
</t>
<t tx="ekr.20190812072051.163">def message_from_bytes(self, bb):
    return float(bb.decode('utf-8'))
</t>
<t tx="ekr.20190812072051.164">def message_to_bytes(self, number):
    return str(number).encode('utf-8')
</t>
<t tx="ekr.20190812072051.165">def message_type_name(self):
    return 'num'
</t>
<t tx="ekr.20190812072051.17">@property
def received(self):
    """ Signal that is emitted when new data is received. Multiple
    arrived messages may result in a single call to this method.
    There is no guarantee that recv() has not been called in the
    mean time. The signal is emitted with the channel instance
    as argument.
    """
    return self._received_signal

## Properties
</t>
<t tx="ekr.20190812072051.170">@path pyzo/yoton/tests/
# -*- coding: utf-8 -*-
# This example demponstrates simple req rep.
# This example can be run in one go or in two parts running in
# different processes.

## ========== One end

import yoton
verbosity = 0
@others

# Create a context and a rep channel
ct1 = yoton.Context(verbose=verbosity)
rep = Adder(ct1, 'duplicate')

# Connect and turn duplicator on
ct1.bind('publichost:test')
rep.set_mode('thread')

## ========== Other end

import yoton
verbosity = 0

# Create a context and a req channel
ct2 = yoton.Context(verbose=verbosity)
req = yoton.ReqChannel(ct2, 'duplicate')

# Connect
ct2.connect('publichost:test')

# Duplicate a string
print(req.add('foo', 'bar').result(1))
print(req.add(3,4).result(1))
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.172"># Create a replier class by subclassing RepChannel
class Adder(yoton.RepChannel):
    @others
</t>
<t tx="ekr.20190812072051.173">def add(self, item1, item2):
    return item1 + item2
</t>
<t tx="ekr.20190812072051.174">@path pyzo/yoton/tests/
# -*- coding: utf-8 -*-

@others
if True:
    pub1 = yoton.PubChannel(ct1, 'splittest')
    sub1 = yoton.SubChannel(ct3, 'splittest')
    sub2 = yoton.SubChannel(ct5, 'splittest')
else:
    pub1 = yoton.StateChannel(ct1, 'splittest')
    sub1 = yoton.StateChannel(ct3, 'splittest')
    sub2 = yoton.StateChannel(ct5, 'splittest')

# Go!
pub1.send('Hello you two!')
time.sleep(0.5)
print(sub1.recv())
print(sub2.recv())
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.175">import yoton
import time

# Create contexts
ct1 = yoton.Context()
ct2 = yoton.Context()
ct3 = yoton.Context()
ct4 = yoton.Context()
ct5 = yoton.Context()

# Connect
#            / ct3
# ct1 - ct2
#            \ ct4 - ct5
ct1.bind('localhost:split1')
ct2.connect('localhost:split1')
#
ct2.bind('localhost:split2')
ct3.connect('localhost:split2')
#
ct2.bind('localhost:split3')
ct4.connect('localhost:split3')
#
ct4.bind('localhost:split4')
ct5.connect('localhost:split4')

# Create channels
</t>
<t tx="ekr.20190812072051.176">@path pyzo/yoton/tests/
# -*- coding: utf-8 -*-

## Connect two context

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.177">import yoton
import time

# Context 1
ct1 = yoton.Context()
pub1 = yoton.StateChannel(ct1, 'state A')
pub1.send('READY')

# Context 2
ct2 = yoton.Context()
pub2 = yoton.StateChannel(ct2, 'state A')

# Context 3
ct3 = yoton.Context()
sub1 = yoton.StateChannel(ct3, 'state A')

# Connect
ct1.bind('localhost:test1')
ct2.connect('localhost:test1')
ct2.bind('localhost:test2')
ct3.connect('localhost:test2')

# Get status (but wait first)
time.sleep(0.3)
print(sub1.recv())

# New status
pub2.send('READY2')
time.sleep(0.3)
print(sub1.recv())

# And back to first
pub1.send('READY')
time.sleep(0.3)
print(sub1.recv())

## Now attach another context
# Upon connecting, the connecting context will issue a context-to-context
# message to indicate a new connection. All contexts will then call
# the send_last() methods of their state channels.

# Context 2
ct4 = yoton.Context()
sub2 = yoton.StateChannel(ct4, 'state A')

# Connect
ct2.bind('localhost:test3')
ct4.connect('localhost:test3')

# Get status (but wait first)
time.sleep(0.3)
print(sub2.recv())

# Ask status again (simply gives last message)
print(sub2.recv())

## Using received signals
</t>
<t tx="ekr.20190812072051.178">def on_new_state(channel):
    state = channel.recv()
    print('%i received state %s' % (id(channel), state))
    if state == 'stop':
        yoton.stop_event_loop()

# Bind
sub1.received.bind(on_new_state)
sub2.received.bind(on_new_state)

# Have some calls made
yoton.call_later(pub1.send, 1.0, 'hello')
yoton.call_later(pub1.send, 1.5, 'there')
yoton.call_later(pub1.send, 2.0, 'now')
yoton.call_later(pub1.send, 2.5, 'stop')

# Go!
yoton.start_event_loop()
</t>
<t tx="ekr.20190812072051.179">@path pyzo/yoton/tests/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.18">@property
def pending(self):
    """ Get the number of pending incoming messages.
    """
    return len(self._q_in)
</t>
<t tx="ekr.20190812072051.180">import yoton
import threading
import time
</t>
<t tx="ekr.20190812072051.181">class Sender(threading.Thread):
    @others
</t>
<t tx="ekr.20190812072051.182">def run(self):
    for i in range(100):
        time.sleep(0.02)
        q.push('haha! ' + repr(self))
    q.push('stop')
</t>
<t tx="ekr.20190812072051.183">class Receiver(threading.Thread):
    @others
q = yoton.misc.TinyPackageQueue(10, 1000)

S = []
for i in range(10):
    t = Sender()
    t.start()
    S.append(t)

R = []
for i in range(3):
    t = Receiver()
    t.start()
    R.append(t)

for r in R:
    r.join()
    r.show()
</t>
<t tx="ekr.20190812072051.184">def run(self):
    M = []
    L = []
    while True:
        L.append(len(q))
        m = q.pop(True)
        #time.sleep(0.02)
        if m == 'stop':
            break
        else:
            M.append(m)

    self.M = M
    self.avSize = float(sum(L)) / len(L)
</t>
<t tx="ekr.20190812072051.185">def show(self):
    M = self.M
    nrs = {}
    for m in M:
        nr = m.split('-',1)[1].split(',',1)[0]
        if nr not in nrs:
            nrs[nr] = 0
        nrs[nr] += 1

    print('received %i messages' % len(M))
    print('average queue size was %1.2f' % self.avSize)
    for nr in nrs:
        print('  from %s received %i' % (nr, nrs[nr]))
</t>
<t tx="ekr.20190812072051.186">@path pyzo/yoton/tests/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.187">import yoton

verbosity = 0
</t>
<t tx="ekr.20190812072051.188">def connect_test():
    c1 = yoton.Context(verbosity)
    c2 = yoton.Context(verbosity)
    c3 = yoton.Context(verbosity)

    c1.bind('localhost:test1')
    c2.connect('localhost:test1')

    c2.bind('localhost:test2')
    c3.connect('localhost:test2')

    c1.close()
    c2.close()
    c3.close()

for i in range(5):
    print('iter', i)
    connect_test()
</t>
<t tx="ekr.20190812072051.189">@path pyzo/yoton/tests/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.19">@property
def closed(self):
    """ Get whether the channel is closed.
    """
    return self._closed
</t>
<t tx="ekr.20190812072051.190">""" Simple script to make a performance plot of the speed for sending
different package sizes.
"""

# Go up one directory and then import the codeeditor package
import os, sys
os.chdir('../..')
sys.path.insert(0,'.')

# Import yoton from there
import yoton

# Normal imports
import math
import time
import visvis as vv

## Run experiment with different message sizes

# Setup host
ct1 = yoton.Context()
ct1.bind('localhost:test')
c1 = yoton.PubChannel(ct1, 'speedTest')

# Setup client
ct2 = yoton.SimpleSocket()
ct2.connect('localhost:test')
c2 = yoton.SubChannel(ct2, 'speedTest')

# Init
minSize, maxSize = 2, 100*2**20
BPS = []
TPM = []
N = []
SIZE = []

# Loop
size = minSize
while size &lt; maxSize:

    # Calculate amount
    n = int(200 * 2**20 / size)
    n = min(yoton.core.BUF_MAX_LEN, n)

    t0 = time.time()

    # Send messages
    message = 'T'*int(size)
    for i in range(n):
        c1.send(message)
    ct1.flush(20.0)

    t1= time.time()

    # In the mean while two threads are working their asses off to pop
    # the packages from one queue, send them over a socket, and push
    # them on another queue.

    # Receive messages
    for i in range(n):
        c2.recv()

    t2= time.time()

    # Calculate speed
    etime = t2-t0
    bps = n * size / etime # bytes per second
    tpm = etime/n

    # Make strings
    bps_ = '%1.2f B/s' % bps
    size_ = '%i B' % size
    #
    D = {2**10: 'KB', 2**20: 'MB', 2**30: 'GB'}
    for factor in D:
        if bps &gt;= factor:
            bps_ = '%1.2f %s/s' % (bps/factor, D[factor])
        if size &gt;= factor:
            size_ = '%1.2f %s' % (size/factor, D[factor])

    # Show result
    print('Sent %i messages of %s in %1.2f s: %s' %
            (n, size_, etime, bps_) )

    # Store stuff
    N.append(n)
    SIZE.append(size)
    BPS.append(bps)
    TPM.append(tpm)

    # Prepare for next round
    size *= 1.9

## Visualize
</t>
<t tx="ekr.20190812072051.191">def logticks10(unit='', factor=10):
    SIZE_TICKS = [factor**i for i in range(-50,30,1)]
    D = {}
    for i in SIZE_TICKS:
        il = math.log(i,factor)
        for j,c in reversed(zip([-6, -3, 1, 3],['\\mu','m','','K'])):
            jj = float(factor)**j
            if i&gt;=jj:
                i = '%1.0f %s%s' % (i/jj, c, unit)
                D[il] = i
                break
    return D
</t>
<t tx="ekr.20190812072051.192">def logticks2(unit='', factor=2):
    SIZE_TICKS = [factor**i for i in range(-50,30,3)]
    D = {}
    for i in SIZE_TICKS:
        il = math.log(i,factor)
        for j,c in reversed(zip([1, 10,20,30],['','K', 'M', 'G'])):
            jj = float(factor)**j
            if i&gt;=jj:
                i = '%1.0f %s%s' % (i/jj, c, unit)
                D[il] = i
                break
    return D

SIZE_log = [math.log(i,2) for i in SIZE]
BPS_log = [math.log(i,2) for i in BPS]
TPM_log = [math.log(i,10) for i in TPM]

fig = vv.figure(1); vv.clf()
#
a1 = vv.subplot(211)
vv.plot(SIZE_log, BPS_log, ms='.')
vv.ylabel('speed [bytes/s]')
a1.axis.yTicks = logticks2()
#
a2 = vv.subplot(212)
vv.plot(SIZE_log, TPM_log, ms='.') # 0.001 0.4
vv.ylabel('time per message [s]')
a2.axis.yTicks = logticks10('s')

for a in [a1, a2]:
    a.axis.xLabel = 'message size'
    a.axis.showGrid = True
    a.axis.xTicks = logticks2('B')

# vv.screenshot('c:/almar/projects/yoton_performance.jpg', fig)
</t>
<t tx="ekr.20190812072051.193">@path pyzo/yoton/tests/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.194">""" _utest.py

Unit tests for yoton.

"""

import sys, os, time
import unittest

# Go up one directory and then import the yoton package
os.chdir('..')
os.chdir('..')
sys.path.insert(0,'.')

# Import yoton from there
import yoton
from yoton.misc import long
</t>
<t tx="ekr.20190812072051.195">class Tester(unittest.TestCase):
    """ Perform a set of tests using three contexts and
    each of the six channels at each context.

    """

    @others
if __name__ == '__main__':

    suite = unittest.TestLoader().loadTestsFromTestCase(Tester)
    unittest.TextTestRunner(verbosity=2).run(suite)
    print('')
</t>
<t tx="ekr.20190812072051.196">def setUp(self):

    # Create contexts
    self._context1 = c1 = yoton.Context()
    self._context2 = c2 = yoton.Context()
    self._context3 = c3 = yoton.Context()

    # Create pub sub channels
    self._channel_pub1 = yoton.PubChannel(c1,'foo')
    self._channel_pub2 = yoton.PubChannel(c2,'foo')
    self._channel_pub3 = yoton.PubChannel(c3,'foo')
    #
    self._channel_sub1 = yoton.SubChannel(c1,'foo')
    self._channel_sub2 = yoton.SubChannel(c2,'foo')
    self._channel_sub3 = yoton.SubChannel(c3,'foo')

    # Create req rep channels
    self._channel_req1 = yoton.ReqChannel(c1,'bar')
    self._channel_req2 = yoton.ReqChannel(c2,'bar')
    self._channel_req3 = yoton.ReqChannel(c3,'bar')
    #
    self._channel_rep1 = yoton.RepChannel(c1,'bar')
    self._channel_rep2 = yoton.RepChannel(c2,'bar')
    self._channel_rep3 = yoton.RepChannel(c3,'bar')

    # Create state channels
    self._channel_state1 = yoton.StateChannel(c1, 'spam')
    self._channel_state2 = yoton.StateChannel(c2, 'spam')
    self._channel_state3 = yoton.StateChannel(c3, 'spam')
</t>
<t tx="ekr.20190812072051.197">def tearDown(self):
    self._context1.close()
    self._context2.close()
    self._context3.close()
</t>
<t tx="ekr.20190812072051.198">def test_connecting(self):

    # Connect
    self._context1.bind('localhost:test1')
    self._context2.connect('localhost:test1')
    time.sleep(0.1) # Give time for binding to finish

    # Test if connected
    self.assertEqual(self._context1.connection_count, 1)
    self.assertEqual(self._context2.connection_count, 1)
    self.assertEqual(self._context3.connection_count, 0)

    # Connect more
    self._context1.bind('localhost:test2')
    self._context3.connect('localhost:test2')
    time.sleep(0.1) # Give time for binding to finish

    # Test if connected
    self.assertEqual(self._context1.connection_count, 2)
    self.assertEqual(self._context2.connection_count, 1)
    self.assertEqual(self._context3.connection_count, 1)
</t>
<t tx="ekr.20190812072051.199">def test_closing_channel(self):

    # Connect
    self._context1.bind('localhost:test')
    self._context2.connect('localhost:test')

    # Send data
    self._channel_pub1.send('hello')

    # Receive data
    self.assertEqual(self._channel_sub2.recv(), 'hello')
    self.assertEqual(self._channel_sub2.recv(False), '')

    # Close channel
    self._channel_sub2.close()
    self.assertEqual(self._channel_sub2.recv(), '')
    self.assertTrue(self._channel_sub2.closed)
</t>
<t tx="ekr.20190812072051.2"></t>
<t tx="ekr.20190812072051.20">@property
def slot_outgoing(self):
    """ Get the outgoing slot name.
    """
    return self._slot_out
</t>
<t tx="ekr.20190812072051.200">def test_pub_sub(self):

    # also test hopping

    # Connect
    self._context1.bind('localhost:test1')
    self._context2.connect('localhost:test1')
    self._context2.bind('localhost:test2')
    self._context3.connect('localhost:test2')

    # Send messages
    self._channel_pub1.send('msg1')
    time.sleep(0.1)
    self._channel_pub2.send('msg2')
    time.sleep(0.1)

    # Receive msssages
    self.assertEqual(self._channel_sub2.recv(), 'msg1')
    self.assertEqual(self._channel_sub3.recv(), 'msg1')
    self.assertEqual(self._channel_sub3.recv(), 'msg2')
</t>
<t tx="ekr.20190812072051.201">def test_pub_sub_select_channel(self):

    # Connect
    self._context1.bind('localhost:test1')
    self._context2.connect('localhost:test1')

    # Create channels
    pub1 = yoton.PubChannel(self._context1, 'foo1')
    pub2 = yoton.PubChannel(self._context1, 'foo2')
    #
    sub1 = yoton.SubChannel(self._context2, 'foo1')
    sub2 = yoton.SubChannel(self._context2, 'foo2')

    # Send a bunch of messages
    I = [0,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,1,0,1]
    for i in range(len(I)):
        pub = [pub1, pub2][I[i]]
        pub.send(str(i))

    time.sleep(0.1)

    # Receive in right order
    count = 0
    while True:
        sub = yoton.select_sub_channel(sub1, sub2)
        if sub:
            i = int(sub.recv())
            self.assertEqual(i, count)
            count += 1
        else:
            break

    # Test count
    self.assertEqual(count, len(I))
</t>
<t tx="ekr.20190812072051.202">def test_pubstate_substate(self):

    # also test hopping

    # Set status before connecting
    self._channel_state1.send('status1')

    # Connect
    self._context1.bind('localhost:test1')
    self._context2.connect('localhost:test1')
    self._context2.bind('localhost:test2')
    self._context3.connect('localhost:test2')
    time.sleep(0.1)

    # Receive msssages
    self.assertEqual(self._channel_state2.recv(), 'status1')
    self.assertEqual(self._channel_state2.recv(), 'status1')
    self.assertEqual(self._channel_state3.recv(), 'status1')
    self.assertEqual(self._channel_state3.recv(), 'status1')

    # Update status
    self._channel_state1.send('status2')
    time.sleep(0.1)

    # Receive msssages (recv multiple times should return last status)
    self.assertEqual(self._channel_state2.recv(), 'status2')
    self.assertEqual(self._channel_state2.recv(), 'status2')
    self.assertEqual(self._channel_state3.recv(), 'status2')
    self.assertEqual(self._channel_state3.recv(), 'status2')
</t>
<t tx="ekr.20190812072051.203">def test_req_rep1(self):

    # Connect
    self._context1.bind('localhost:test1')
    self._context2.connect('localhost:test1')
    self._context2.bind('localhost:test2')
    self._context3.connect('localhost:test2')

    # Turn on one replier
    self._channel_rep3.set_mode('thread')

    # Do requests
    foo, id1 = self._channel_req1.echo('foo').result(1)
    bar, id2 = self._channel_req1.echo('bar').result(1)

    # Check reply
    self.assertEqual(foo, 'foo')
    self.assertEqual(bar, 'bar')
    self.assertEqual(id1, hex(self._context3.id))
    self.assertEqual(id2, hex(self._context3.id))
</t>
<t tx="ekr.20190812072051.204">def test_req_rep2(self):

    # Test multiple requesters and multiple repliers

    # Connect
    if True:
        self._context1.bind('localhost:test1')
        self._context3.connect('localhost:test1')
        #
        self._context1.bind('localhost:test2')
        self._context2.connect('localhost:test2')
    else:
        freeNode = yoton.Context()
        #
        self._context1.bind('localhost:test1')
        freeNode.connect('localhost:test1')
        freeNode.bind('localhost:test1f')
        self._context3.connect('localhost:test1f')
        #
        self._context1.bind('localhost:test2')
        self._context2.connect('localhost:test2')
    time.sleep(0.1)

    # Turn on 2 requesters and 3 repliers
    self._channel_rep1.set_mode('thread') # threaded because simulating
    self._channel_rep2.set_mode('thread') # different processes
    self._channel_rep3.set_mode('thread')

    # Define and register reply handler
    def reply_handler(future):
        reply = future.result()
        reqnr = future.reqnr

        echo, id = reply
        if echo.lower() == 'stop':
            yoton.stop_event_loop()
        else:
            self.assertEqual(echo[:3], 'msg')
            contextnr = {   self._context1.id:1,
                            self._context2.id:2,
                            self._context3.id:3}[long(id,16)]
            print('request %s from %i handled by context %i.' %
                                            (echo, reqnr, contextnr))

    # Get echo functions
    echoFun1 = self._channel_req1.echo
    echoFun2 = self._channel_req2.echo

    # Send requests on req 1
    sleepTimes = [1, 0.1, 1, 0.6, 0.6, 0.6, 0.6, 0.6]
    for i in range(len(sleepTimes)):
        f = echoFun1('msg%i'%i, sleepTimes[i])
        f.add_done_callback(reply_handler)
        f.reqnr = 1

    # Send requests on req 2
    sleepTimes = [0.4, 0.4, 0.4, 0.4, 0.4]
    for i in range(len(sleepTimes)):
        f = echoFun2('msg%i'%i, sleepTimes[i])
        f.add_done_callback(reply_handler)
        f.reqnr = 2

    # Stop
    f = echoFun1('stop')
    f.add_done_callback(reply_handler)
    f.reqnr = 1

    # Enter event loop
    yoton.start_event_loop()
</t>
<t tx="ekr.20190812072051.205">@path pyzo/yoton/tests/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.206">import numpy as np
import scipy as sp
# import scipy.linalg
import time

t0 = time.time()
a = np.random.normal(size=(1600,1600))
sp.linalg.svd(a)
print( time.time()-t0 )

# For channels.py, this results in pyzo closing the connection because
# the other side seems unresponsive.
</t>
<t tx="ekr.20190812072051.207">@path pyzo/yoton/tests/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.208">import time
</t>
<t tx="ekr.20190812072051.209">class Message(str):
    pass

# Create loads of messages of pure strings and Message instances with an attr
L1, L2 = [], []
for i in range(100000):
    text = 'blabla'+str(i)
    tmp = Message(text)
    tmp._seq = i
    L1.append(text)
    L2.append(tmp)

# Test time to join
t0 = time.time()
for i in range(20):
    tmp = ''.join(L1)
t1 = time.time()-t0
print(t1, 'seconds for pure strings')
#
t0 = time.time()
for i in range(20):
    tmp = ''.join(L2)
t2 = time.time()-t0
print(t2, 'seconds for Message objects', 100*(t2-t1)/t1, '% slower')

# Test looking up
t0 = time.time()
for i in range(len(L2)):
    if L2[i]._seq &gt; 9999999999999:
        break
print('i =',i, '  ', time.time()-t0, 'seconds to check _seq attr')

t0 = time.time()
for i in range(0,len(L2),10):
    if L2[i]._seq &gt; 9999999999999:
        break
for i in range(i-10,i):
    if L2[i]._seq &gt; 9999999999999:
        break
print('i =',i, '  ', time.time()-t0, 'seconds to check _seq attr')
</t>
<t tx="ekr.20190812072051.21">@property
def slot_incoming(self):
    """ Get the incoming slot name.
    """
    return self._slot_in
</t>
<t tx="ekr.20190812072051.22">@path pyzo/yoton/channels/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.23"># -*- coding: utf-8 -*-
""" Module yoton.channels.file

Defines a class that can be used to wrap a channel to give it
a file like interface.

"""

import sys
import os

from yoton.channels import PubChannel, SubChannel

PY2 = sys.version_info[0] == 2
</t>
<t tx="ekr.20190812072051.24">class FileWrapper(object):
    """ FileWrapper(channel, chunksize=0, echo=None)

    Class that wraps a PubChannel or SubChannel instance to provide
    a file-like interface by implementing methods such as read() and
    write(), and other stuff specified in:
    [[http://docs.python.org/library/stdtypes.html#bltin-file-objects]]

    The file wrapper also splits messages into smaller messages if they
    are above the chunksize (only if chunksize &gt; 0).

    On Python 2, the read methods return str (utf-8 encoded Unicode).

    """

    # Our file-like objects should not implement:
    # explicitly stated: fileno, isatty
    # don't seem to make sense: readlines, seek, tell, truncate, errors,
    # mode, name,

    @others
</t>
<t tx="ekr.20190812072051.25">def __init__(self, channel, chunksize=0, echo=None, isatty=False):
    if not isinstance(channel, (PubChannel, SubChannel)):
        raise ValueError('FileWrapper needs a PubChannel or SubChannel.')
    if echo is not None:
        if not isinstance(echo, PubChannel):
            raise ValueError('FileWrapper echo needs to be a PubChannel.')

    self._channel = channel
    self._chunksize = int(chunksize)
    self._echo = echo
    self._pid = os.getpid()  # To detect whether we are in multi-process
    self.errors = 'strict'  # compat
    self._isatty = isatty
</t>
<t tx="ekr.20190812072051.26">def close(self):
    """ Close the file object.
    """
    # Deal with multiprocessing
    if self._pid != os.getpid():
        if self is sys.stdin:
            sys.__stdin__.close()
        elif self is sys.stdout:
            sys.__stdout__.close()
        elif self is sys.stderr:
            sys.__stderr__.close()
        return
    # Normal behavior
    self._channel.close()
</t>
<t tx="ekr.20190812072051.27">@property
def encoding(self):
    """ The encoding used to encode strings to bytes and vice versa.
    """
    return 'UTF-8'
</t>
<t tx="ekr.20190812072051.28">@property
def closed(self):
    """ Get whether the file is closed.
    """
    return self._channel._closed
</t>
<t tx="ekr.20190812072051.29">def flush(self):
    """ flush()

    Wait here until all messages have been send.

    """
    self._channel._context.flush()
</t>
<t tx="ekr.20190812072051.3">@path pyzo/yoton/channels/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.30">@property
def newlines(self):
    """ The type of newlines used. Returns None; we never know what the
    other end could be sending!
    """
    return None

# this is for the print statement to keep track spacing stuff
</t>
<t tx="ekr.20190812072051.31">def _set_softspace(self, value):
    self._softspace = bool(value)
</t>
<t tx="ekr.20190812072051.32">def _get_softspace(self):
    return hasattr(self, '_softspace') and self._softspace
softspace = property(_get_softspace, _set_softspace, None, '')
</t>
<t tx="ekr.20190812072051.33">def read(self, block=None):
    """ read(block=None)

    Alias for recv().

    """
    res = self._channel.recv(block)
    if res and self._echo is not None:
        self._echo.send(res)
    if PY2:
        return res.encode('utf-8')
    else:
        return res
</t>
<t tx="ekr.20190812072051.34">def write(self, message):
    """ write(message)

    Uses channel.send() to send the message over the Yoton network.
    The message is partitioned in smaller parts if it is larger than
    the chunksize.

    """
    # Deal with multiprocessing
    if self._pid != os.getpid():
        realfile = None
        if self is sys.stdout:
            realfile = sys.__stdout__
        elif self is sys.stderr:
            realfile = sys.__stderr__
        if realfile is not None:
            sys.__stderr__.write(message)
            sys.__stderr__.flush()
        return

    chunkSize = self._chunksize
    if chunkSize &gt; 0 and chunkSize &lt; len(message):
        for i in range(0, len(message), chunkSize):
            self._channel.send( message[i:i+chunkSize] )
    else:
        self._channel.send(message)
</t>
<t tx="ekr.20190812072051.35">def writelines(self, lines):
    """ writelines(lines)

    Write a sequence of messages to the channel.

    """
    for line in lines:
        self._channel.send(line)
</t>
<t tx="ekr.20190812072051.36">def readline(self, size=0):
    """ readline(size=0)

    Read one string that was send as one from the other end (always
    in blocking mode). A newline character is appended if it does not
    end with one.

    If size is given, returns only up to that many characters, the rest
    of the message is thrown away.

    """

    # Get line
    line = self._channel.recv(True)

    # Echo
    if line and self._echo is not None:
        self._echo.send(line)

    # Make sure it ends with newline
    if not line.endswith('\n'):
        line += '\n'

    # Decrease size?
    if size:
        line = line[:size]

    # Done
    if PY2:
        return line.encode('utf-8')
    else:
        return line
</t>
<t tx="ekr.20190812072051.37">def isatty(self):
    """ Get whether this is a terminal.
    """
    return self._isatty
</t>
<t tx="ekr.20190812072051.38">@path pyzo/yoton/channels/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.39"># -*- coding: utf-8 -*-
""" Module yoton.channels.channels_pubsub

Defines the channel classes for the pub/sub pattern.

"""

import time

from yoton.misc import bytes, xrange
from yoton.channels import BaseChannel

QUEUE_NULL = 0
QUEUE_OK = 1
QUEUE_FULL = 2
</t>
<t tx="ekr.20190812072051.4"># -*- coding: utf-8 -*-
""" Module yoton.channels.channels_base

Defines the base channel class and the MessageType class.

"""

import time
import threading

import yoton
from yoton.misc import basestring
from yoton.misc import slot_hash, PackageQueue
from yoton.core import Package
from yoton.context import Context
from yoton.channels.message_types import MessageType, TEXT
</t>
<t tx="ekr.20190812072051.40">class PubChannel(BaseChannel):
    """ PubChannel(context, slot_base, message_type=yoton.TEXT)

    The publish part of the publish/subscribe messaging pattern.
    Sent messages are received by all yoton.SubChannel instances with
    the same slot.

    There are no limitations for this channel if events are not processed.

    Parameters
    ----------
    context : yoton.Context instance
        The context that this channel uses to send messages in a network.
    slot_base : string
        The base slot name. The channel appends an extension to indicate
        message type and messaging pattern to create the final slot name.
        The final slot is used to connect channels at different contexts
        in a network
    message_type : yoton.MessageType instance
        (default is yoton.TEXT)
        Object to convert messages to bytes and bytes to messages.
        Users can create their own message_type class to let channels
        any type of message they want.

    """

    @others
</t>
<t tx="ekr.20190812072051.41">def __init__(self, *args, **kwargs):
    BaseChannel.__init__(self, *args, **kwargs)
    self._source_set = set()
</t>
<t tx="ekr.20190812072051.42">def _messaging_patterns(self):
    return 'pub-sub', 'sub-pub'
</t>
<t tx="ekr.20190812072051.43">def send(self, message):
    """ send(message)

    Send a message over the channel. What is send as one
    message will also be received as one message.

    The message is queued and delivered to all corresponding
    SubChannels (i.e. with the same slot) in the network.

    """
    self._send( self.message_to_bytes(message) )
</t>
<t tx="ekr.20190812072051.44">def _recv_package(self, package):
    """ Overloaded to set blocking mode.
    Do not call _maybe_emit_received(), a PubChannel never emits
    the "received" signal.
    """

    message = package._data.decode('utf-8')
    source_id = package._source_id

    # Keep track of who's queues are full
    if message == 'full':
        self._source_set.add(source_id)
    else:
        self._source_set.discard(source_id)

    # Set lock if there is a channel with a full queue,
    # Unset if there are none
    if self._source_set:
        self._set_send_lock(True)
        #sys.stderr.write('setting lock\n')
    else:
        self._set_send_lock(False)
        #sys.stderr.write('unsetting lock\n')
</t>
<t tx="ekr.20190812072051.45">class SubChannel(BaseChannel):
    """ SubChannel(context, slot_base, message_type=yoton.TEXT)

    The subscribe part of the publish/subscribe messaging pattern.
    Received messages were sent by a yoton.PubChannel instance at the
    same slot.

    This channel can be used as an iterator, which yields all pending
    messages. The function yoton.select_sub_channel can
    be used to synchronize multiple SubChannel instances.

    If no events being processed this channel works as normal, except
    that the received signal will not be emitted, and sync mode will
    not work.

    Parameters
    ----------
    context : yoton.Context instance
        The context that this channel uses to send messages in a network.
    slot_base : string
        The base slot name. The channel appends an extension to indicate
        message type and messaging pattern to create the final slot name.
        The final slot is used to connect channels at different contexts
        in a network
    message_type : yoton.MessageType instance
        (default is yoton.TEXT)
        Object to convert messages to bytes and bytes to messages.
        Users can create their own message_type class to let channels
        any type of message they want.

    """

    @others
</t>
<t tx="ekr.20190812072051.46">def __init__(self, *args, **kwargs):
    BaseChannel.__init__(self, *args, **kwargs)

    # To detect when to block the sending side
    self._queue_status = QUEUE_NULL
    self._queue_status_timeout = 0
    self._HWM = 32
    self._LWM = 16

    # Automatically check queue status when new data
    # enters the system
    self.received.bind(self._check_queue_status)
</t>
<t tx="ekr.20190812072051.47">def _messaging_patterns(self):
    return 'sub-pub', 'pub-sub'
</t>
<t tx="ekr.20190812072051.48">def __iter__(self):
    return self
</t>
<t tx="ekr.20190812072051.49">def __next__(self): # Python 3.x
    m = self.recv(False)
    if m:
        return m
    else:
        raise StopIteration()
</t>
<t tx="ekr.20190812072051.5">class BaseChannel(object):
    """ BaseChannel(context, slot_base, message_type=yoton.TEXT)

    Abstract class for all channels.

    Parameters
    ----------
    context : yoton.Context instance
        The context that this channel uses to send messages in a network.
    slot_base : string
        The base slot name. The channel appends an extension to indicate
        message type and messaging pattern to create the final slot name.
        The final slot is used to connect channels at different contexts
        in a network
    message_type : yoton.MessageType instance
        (default is yoton.TEXT)
        Object to convert messages to bytes and bytes to messages.
        Users can create their own message_type class to enable
        communicating any type of message they want.

    Details
    -------
    Messages send via a channel are delivered asynchronically to the
    corresponding channels.

    All channels are associated with a context and can be used to send
    messages to other channels in the network. Each channel is also
    associated with a slot, which is a string that represents a kind
    of address. A message send by a channel at slot X can only be received
    by a channel with slot X.

    Note that the channel appends an extension
    to the user-supplied slot name, that represents the message type
    and messaging pattern of the channel. In this way, it is prevented
    that for example a PubChannel can communicate with a RepChannel.

    """

    @others
</t>
<t tx="ekr.20190812072051.50">def next(self): # Python 2.x
    """ next()

    Return the next message, or raises StopIteration if non available.

    """
    return self.__next__()

## For sync mode
</t>
<t tx="ekr.20190812072051.51">def set_sync_mode(self, value):
    """ set_sync_mode(value)

    Set or unset the SubChannel in sync mode. When in sync mode, all
    channels that send messages to this channel are blocked if
    the queue for this SubChannel reaches a certain size.

    This feature can be used to limit the rate of senders if the consumer
    (i.e. the one that calls recv()) cannot keep up with processing
    the data.

    This feature requires the yoton event loop to run at the side
    of the SubChannel (not necessary for the yoton.PubChannel side).

    """
    value = bool(value)

    # First reset block status if necessary
    if self._queue_status == QUEUE_FULL:
        self._send_block_message_to_senders('ok')

    # Set new queue status flag
    if value:
        self._queue_status = QUEUE_OK
    else:
        self._queue_status = QUEUE_NULL
</t>
<t tx="ekr.20190812072051.52">def _send_block_message_to_senders(self, what):
    """ _send_block_message_to_senders(what)

    Send a message to the PubChannel side to make it block/unblock.

    """

    # Check
    if not self._context.connection_count:
        return

    # Send
    try:
        self._send(what.encode('utf-8'))
    except IOError:
        # If self._closed
        self._check_queue_status = QUEUE_NULL
</t>
<t tx="ekr.20190812072051.53">def _check_queue_status(self, dummy=None):
    """ _check_queue_status()

    Check the queue status. Returns immediately unless this receiving
    channel runs in sync mode.

    If the queue is above a certain size, will send out a package that
    will make the sending side block. If the queue is below a certain
    size, will send out a package that will make the sending side unblock.

    """

    if self._queue_status == QUEUE_NULL:
        return
    elif len(self._q_in) &gt; self._HWM:
        if self._queue_status == QUEUE_OK:
            self._queue_status = QUEUE_FULL
            self._queue_status_timeout = time.time() + 4.0
            self._send_block_message_to_senders('full')
    elif len(self._q_in) &lt; self._LWM:
        if self._queue_status == QUEUE_FULL:
            self._queue_status = QUEUE_OK
            self._queue_status_timeout = time.time() + 4.0
            self._send_block_message_to_senders('ok')

    # Resend every so often. After 10s the PubChannel will unlock itself
    if self._queue_status_timeout &lt; time.time():
        self._queue_status_timeout = time.time() + 4.0
        if self._queue_status == QUEUE_OK:
            self._send_block_message_to_senders('ok')
        else:
            self._send_block_message_to_senders('full')

## Receive methods
</t>
<t tx="ekr.20190812072051.54">def recv(self, block=True):
    """ recv(block=True)

    Receive a message from the channel. What was send as one
    message is also received as one message.

    If block is False, returns empty message if no data is available.
    If block is True, waits forever until data is available.
    If block is an int or float, waits that many seconds.
    If the channel is closed, returns empty message.

    """

    # Check queue status, maybe we need to block the sender
    self._check_queue_status()

    # Get package
    package = self._recv(block)

    # Return message content or None
    if package is not None:
        return self.message_from_bytes(package._data)
    else:
        return self.message_from_bytes(bytes())
</t>
<t tx="ekr.20190812072051.55">def recv_all(self):
    """ recv_all()

    Receive a list of all pending messages. The list can be empty.

    """

    # Check queue status, maybe we need to block the sender
    self._check_queue_status()

    # Pop all messages and return as a list
    pop = self._q_in.pop
    packages = [pop() for i in xrange(len(self._q_in))]
    return [self.message_from_bytes(p._data) for p in packages]
</t>
<t tx="ekr.20190812072051.56">def recv_selected(self):
    """ recv_selected()

    Receive a list of messages. Use only after calling
    yoton.select_sub_channel with this channel as one of the arguments.

    The returned messages are all received before the first pending
    message in the other SUB-channels given to select_sub_channel.

    The combination of this method and the function select_sub_channel
    enables users to combine multiple SUB-channels in a way that
    preserves the original order of the messages.

    """

    # No need to check queue status, we've done that in the
    # _get_pending_sequence_numbers() method

    # Prepare
    q = self._q_in
    ref_seq = self._ref_seq
    popped = []

    # Pop all messages that have sequence number lower than reference
    try:
        for i in xrange(len(q)):
            part = q.pop()
            if part._recv_seq &gt; ref_seq:
                q.insert(part) # put back in queue
                break
            else:
                popped.append(part)
    except IndexError:
        pass

    # Done; return messages
    return [self.message_from_bytes(p._data) for p in popped]
</t>
<t tx="ekr.20190812072051.57">def _get_pending_sequence_numbers(self):
    """ _get_pending_sequence_numbers()

    Get the sequence numbers of the first and last pending messages.
    Returns (-1,-1) if no messages are pending.

    Used by select_sub_channel() to determine which channel should
    be read from first and what the reference sequence number is.

    """

    # Check queue status, maybe we need to block the sender
    self._check_queue_status()

    # Peek
    try:
        q = self._q_in
        return q.peek(0)._recv_seq, q.peek(-1)._recv_seq + 1
    except IndexError:
        return -1, -1
</t>
<t tx="ekr.20190812072051.58">def select_sub_channel(*args):
    """ select_sub_channel(channel1, channel2, ...)

    Returns the channel that has the oldest pending message of all
    given yoton.SubCannel instances. Returns None if there are no pending
    messages.

    This function can be used to read from SubCannels instances in the
    order that the messages were send.

    After calling this function, use channel.recv_selected() to obtain
    all messages that are older than any pending messages in the other
    given channels.

    """

    # Init
    smallest_seq1 = 99999999999999999999999999
    smallest_seq2 = 99999999999999999999999999
    first_channel = None

    # For each channel ...
    for channel in args:

        # Check if channel is of right type
        if not isinstance(channel, SubChannel):
            raise ValueError('select_sub_channel() only accepts SUB channels.')

        # Get and check sequence
        seq1, seq2 = channel._get_pending_sequence_numbers()
        if seq1 &gt;= 0:
            if seq1 &lt; smallest_seq1:
                # Cannot go beyond number of packages in queue,
                # or than seq1 of earlier selected channel.
                smallest_seq2 = min(smallest_seq1, smallest_seq2, seq2)
                # Store
                smallest_seq1 = seq1
                first_channel = channel
            else:
                # The first_channel cannot go beyond the 1st package in THIS queue
                smallest_seq2 = min(smallest_seq2, seq1)

    # Set flag at channel and return
    if first_channel:
        first_channel._ref_seq = smallest_seq2
        return first_channel
    else:
        return None
</t>
<t tx="ekr.20190812072051.59">@path pyzo/yoton/channels/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190812072051.6">def __init__(self, context, slot_base, message_type=None):

    # Store context
    if not isinstance(context, Context):
        raise ValueError('Context not valid.')
    self._context = context

    # Check message type
    if message_type is None:
        message_type = TEXT
    if isinstance(message_type, type) and issubclass(message_type, MessageType):
        message_type = message_type()
    if isinstance(message_type, MessageType):
        message_type = message_type
    else:
        raise ValueError('message_type should be a MessageType instance.')

    # Store message type and conversion methods
    self._message_type_instance = message_type
    self.message_from_bytes = message_type.message_from_bytes
    self.message_to_bytes = message_type.message_to_bytes

    # Queue for incoming trafic (not used for pure sending channels)
    self._q_in = PackageQueue(*context._queue_params)

    # For sending channels: to lock the channel for sending
    self._send_condition = threading.Condition()
    self._is_send_locked = 0 # "True" is the timeout time

    # Signal for receiving data
    self._received_signal = yoton.events.Signal()
    self._posted_received_event = False

    # Channels can be closed
    self._closed = False

    # Event driven mode
    self._run_mode = 0

    # Init slots
    self._init_slots(slot_base)
</t>
<t tx="ekr.20190812072051.60"># -*- coding: utf-8 -*-
""" Module yoton.channels.channels_reqprep

Defines the channel classes for the req/rep pattern.

"""

import time
import threading

import yoton
from yoton.misc import basestring, bytes
from yoton.misc import getErrorMsg
from yoton.channels import BaseChannel, OBJECT

# For the req/rep channels to negotiate (simple load balancing)
REQREP_SEQ_REF = 2**63

# Define object to recognize errors
ERROR_OBJECT = 'yoton_ERROR_HANDLING_REQUEST'

# Define exceoptions
</t>
<t tx="ekr.20190812072051.61">class TimeoutError(Exception):
    pass
</t>
<t tx="ekr.20190812072051.62">class CancelledError(Exception):
    pass
# # Try loading the exceptions from the concurrency framework
# # (or maybe not; it makes yoton less lightweight)
# try:
#     from concurrent.futures import TimeoutError, CancelledError
# except ImportError:
#     pass
</t>
<t tx="ekr.20190812072051.63">class Future(object):
    """ Future(req_channel, req, request_id)

    The Future object represents the future result of a request done at
    a yoton.ReqChannel.

    It enables:
      * checking whether the request is done.
      * getting the result or the exception raised during handling the request.
      * canceling the request (if it is not yet running)
      * registering callbacks to handle the result when it is available

    """

    @others
</t>
<t tx="ekr.20190812072051.64">def __init__(self, req_channel, req, request_id):

    # For being a Future object
    self._result = None
    self._status = 0 # 0:waiting, 1:running, 2:canceled, 3:error, 4:success
    self._callbacks = []

    # For handling req/rep
    self._req_channel = req_channel
    self._req = req
    self._request_id = request_id
    self._rep = bytes()
    self._replier = 0

    # For resending
    self._first_send_time = time.time()
    self._next_send_time = self._first_send_time + 0.5
    self._auto_cancel_timeout = 10.0
</t>
<t tx="ekr.20190812072051.65">def _send(self, msg):
    """ _send(msg)

    For sending pre-request messages 'req?', 'req-'.

    """
    msg = msg.encode('utf-8')
    try:
        self._req_channel._send(msg, 0, self._request_id+REQREP_SEQ_REF)
    except IOError:
        # if self._closed, will call _send again, and catch IOerror,
        # which will result in one more call to cancel().
        self.cancel()
</t>
<t tx="ekr.20190812072051.66">def _resend_if_necessary(self):
    """ _resend_if_necessary()

    Resends the pre-request message if we have not done so for the last
    0.5 second.

    This will also auto-cancel the message if it is resend over 20 times.

    """
    timetime = time.time()
    if self._status != 0:
        pass
    elif timetime &gt; self._first_send_time + self._auto_cancel_timeout:
        self.cancel()
    elif timetime &gt; self._next_send_time:
        self._send('req?')
        self._next_send_time = timetime + 0.5
</t>
<t tx="ekr.20190812072051.67">def set_auto_cancel_timeout(self, timeout):
    """ set_auto_cancel_timeout(timeout):

    Set the timeout after which the call is automatically cancelled
    if it is not done yet. By default, this value is 10 seconds.

    If timeout is None, there is no limit to the wait time.

    """
    if timeout is None:
        timeout = 999999999999999999.0
    if timeout &gt; 0:
        self._auto_cancel_timeout = float(timeout)
    else:
        raise ValueError('A timeout cannot be negative')
</t>
<t tx="ekr.20190812072051.68">def cancel(self):
    """ cancel()

    Attempt to cancel the call. If the call is currently being executed
    and cannot be cancelled then the method will return False, otherwise
    the call will be cancelled and the method will return True.

    """

    if self._status == 1:
        # Running, cannot cancel
        return False
    elif self._status == 0:
        # Cancel now
        self._status = 2
        self._send('req-')
        for fn in self._callbacks:
            yoton.call_later(fn, 0, self)
        return True
    else:
        # Already done or canceled
        return True
</t>
<t tx="ekr.20190812072051.69">def cancelled(self):
    """ cancelled()

    Return True if the call was successfully cancelled.

    """
    return self._status == 2
</t>
<t tx="ekr.20190812072051.7">def _init_slots(self, slot_base):
    """ _init_slots(slot_base)

    Called from __init__ to initialize the slots and perform all checks.

    """

    # Check if slot is string
    if not isinstance(slot_base, basestring):
        raise ValueError('slot_base must be a string.')

    # Get full slot names, init byte versions
    slots_t = []
    slots_h = []

    # Get extension for message type and messaging pattern
    ext_type = self._message_type_instance.message_type_name()
    ext_patterns = self._messaging_patterns() # (incoming, outgoing)

    # Normalize and check slot names
    for ext_pattern in ext_patterns:
        if not ext_pattern:
            slots_t.append(None)
            slots_h.append(0)
            continue
        # Get full name
        slot = slot_base + '.' + ext_type + '.' + ext_pattern
        # Store text version
        slots_t.append(slot)
        # Strip and make lowercase
        slot = slot.strip().lower()
        # Hash
        slots_h.append(slot_hash(slot))

    # Store slots
    self._slot_out = slots_t[0]
    self._slot_in = slots_t[1]
    self._slot_out_h = slots_h[0]
    self._slot_in_h = slots_h[1]

    # Register slots (warn if neither slot is valid)
    if self._slot_out_h:
        self._context._register_sending_channel(self, self._slot_out_h, self._slot_out)
    if self._slot_in_h:
        self._context._register_receiving_channel(self, self._slot_in_h, self._slot_in)
    if not self._slot_out_h and not self._slot_in_h:
        raise ValueError('This channel does not have valid slots.')
</t>
<t tx="ekr.20190812072051.70">def running(self):
    """ running()

    Return True if the call is currently being executed and cannot be
    cancelled.

    """
    return self._status == 1
</t>
<t tx="ekr.20190812072051.71">def done(self):
    """ done()

    Return True if the call was successfully cancelled or finished running.

    """
    return self._status in [2,3,4]
</t>
<t tx="ekr.20190812072051.72">def _wait(self, timeout):
    """ _wait(timeout)

    Wait for the request to be handled for the specified amount of time.
    While waiting, the ReqChannel local event loop is called so that
    pre-request messages can be exchanged.

    """

    # No timout means a veeeery long timeout
    if timeout is None:
        timeout = 999999999999999999.0

    # Receive packages untill we receive the one we want,
    # or untill time runs out
    timestamp = time.time() + timeout
    while (self._status &lt; 2) and (time.time() &lt; timestamp):
        self._req_channel._process_events_local()
        time.sleep(0.01) # 10 ms
</t>
<t tx="ekr.20190812072051.73">def result(self, timeout=None):
    """ result(timeout=None)

    Return the value returned by the call. If the call hasnt yet
    completed then this method will wait up to timeout seconds. If
    the call hasnt completed in timeout seconds, then a TimeoutError
    will be raised. timeout can be an int or float. If timeout is not
    specified or None, there is no limit to the wait time.

    If the future is cancelled before completing then CancelledError
    will be raised.

    If the call raised, this method will raise the same exception.

    """

    # Wait
    self._wait(timeout)

    # Return or raise error
    if self._status &lt; 2 :
        raise TimeoutError('Result unavailable within the specified time.')
    elif self._status == 2:
        raise CancelledError('Result unavailable because request was cancelled.')
    elif self._status == 3:
        raise self._result
    else:
        return self._result
</t>
<t tx="ekr.20190812072051.74">def result_or_cancel(self, timeout=1.0):
    """ result_or_cancel(timeout=1.0)

    Return the value returned by the call. If the call hasnt yet
    completed then this method will wait up to timeout seconds. If
    the call hasnt completed in timeout seconds, then the call is
    cancelled and the method will return None.

    """

    # Wait
    self._wait(timeout)

    # Return
    if self._status == 4:
        return self._result
    else:
        self.cancel()
        return None
</t>
<t tx="ekr.20190812072051.75">def exception(self, timeout=None):
    """ exception(timeout)

    Return the exception raised by the call. If the call hasnt yet
    completed then this method will wait up to timeout seconds. If
    the call hasnt completed in timeout seconds, then a TimeoutError
    will be raised. timeout can be an int or float. If timeout is not
    specified or None, there is no limit to the wait time.

    If the future is cancelled before completing then CancelledError
    will be raised.

    If the call completed without raising, None is returned.

    """

    # Wait
    self._wait(timeout)

    # Return or raise error
    if self._status &lt; 2 :
        raise TimeoutError('Exception unavailable within the specified time.')
    elif self._status == 2:
        raise CancelledError('Exception unavailable because request was cancelled.')
    elif self._status == 3:
        return self._result
    else:
        return None # no exception
</t>
<t tx="ekr.20190812072051.76">def add_done_callback(self, fn):
    """ add_done_callback(fn)

    Attaches the callable fn to the future. fn will be called, with
    the future as its only argument, when the future is cancelled or
    finishes running.

    Added callables are called in the order that they were added. If
    the callable raises a Exception subclass, it will be logged and
    ignored. If the callable raises a BaseException subclass, the
    behavior is undefined.

    If the future has already completed or been cancelled, fn will be
    called immediately.

    """

    # Check
    if not hasattr(fn, '__call__'):
        raise ValueError('add_done_callback expects a callable.')

    # Add
    if self.done():
        yoton.call_later(fn, 0, self)
    else:
        self._callbacks.append(fn)
</t>
<t tx="ekr.20190812072051.77">def set_running_or_notify_cancel(self):
    """ set_running_or_notify_cancel()

    This method should only be called by Executor implementations before
    executing the work associated with the Future and by unit tests.

    If the method returns False then the Future was cancelled, i.e.
    Future.cancel() was called and returned True.

    If the method returns True then the Future was not cancelled and
    has been put in the running state, i.e. calls to Future.running()
    will return True.

    This method can only be called once and cannot be called after
    Future.set_result() or Future.set_exception() have been called.

    """

    if self._status == 2:
        return False
    elif self._status == 0:
        self._status = 1
        return True
    else:
        raise RuntimeError('set_running_or_notify_cancel should be called when in a clear state.')
</t>
<t tx="ekr.20190812072051.78">def set_result(self, result):
    """ set_result(result)

    Sets the result of the work associated with the Future to result.
    This method should only be used by Executor implementations and
    unit tests.

    """

    # Set result if indeed in running state
    if self._status == 1:
        self._result = result
        self._status = 4
        for fn in self._callbacks:
            yoton.call_later(fn, 0, self)
</t>
<t tx="ekr.20190812072051.79">def set_exception(self, exception):
    """ set_exception(exception)

    Sets the result of the work associated with the Future to the
    Exception exception. This method should only be used by Executor
    implementations and unit tests.

    """

    # Check
    if isinstance(exception, basestring):
        exception = Exception(exception)
    if not isinstance(exception, Exception):
        raise ValueError('exception must be an Exception instance.')

    # Set result if indeed in running state
    if self._status == 1:
        self._result = exception
        self._status = 3
        for fn in self._callbacks:
            yoton.call_later(fn, 0, self)
</t>
<t tx="ekr.20190812072051.8">def _messaging_patterns(self):
    """ _messaging_patterns()

    Implement to return a string that specifies the pattern
    for sending and receiving, respecitively.

    """
    raise NotImplementedError()
</t>
<t tx="ekr.20190812072051.80">class ReqChannel(BaseChannel):
    """ ReqChannel(context, slot_base)

    The request part of the request/reply messaging pattern.
    A ReqChannel instance sends request and receive the corresponding
    replies. The requests are replied by a yoton.RepChannel instance.

    This class adopts req/rep in a remote procedure call (RPC) scheme.
    The handling of the result is done using a yoton.Future object, which
    follows the approach specified in PEP 3148. Note that for the use
    of callbacks, the yoton event loop must run.

    Basic load balancing is performed by first asking all potential
    repliers whether they can handle a request. The actual request
    is then send to the first replier to respond.

    Parameters
    ----------
    context : yoton.Context instance
        The context that this channel uses to send messages in a network.
    slot_base : string
        The base slot name. The channel appends an extension to indicate
        message type and messaging pattern to create the final slot name.
        The final slot is used to connect channels at different contexts
        in a network

    Usage
    -----
    One performs a call on a virtual method of this object. The actual
    method is executed by the yoton.RepChannel instance. The method can be
    called with normal and keyword arguments, which can be (a
    combination of): None, bool, int, float, string, list, tuple, dict.

    Example
    -------
    # Fast, but process is idling when waiting for the response.
    reply = req.add(3,4).result(2.0) # Wait two seconds

    # Asynchronous processing, but no waiting.
    def reply_handler(future):
        ... # Handle reply
    future = req.add(3,4)
    future.add_done_callback(reply_handler)

    """

    # Notes on load balancing:
    #
    # Firstly, each request has an id. Which is an integer number
    # which is increased at each new request. The id is send via
    # the dest_seq. For pre-request messages an offset is added
    # to recognize these meta-messages.
    #
    # We use an approach I call pre-request. The req channel sends
    # a pre-request to all repliers (on the same slot) asking whether
    # they want to handle a request. The content is 'req?' and the
    # dest_seq is the request-id + offset.
    #
    # The repliers collects and queues all pre-requests. It will then
    # send a reply to acknowledge the first received pre-request. The
    # content is 'req!' and dest_seq is again request-id + offset.
    #
    # The replier is now in a state of waiting for the actual request.
    # It will not acknowledge pre-requests, but keeps queing them.
    #
    # Upon receiving the acknowledge, the requester sends (directed
    # at only the first replier to acknowledge) the real request.
    # The content is the real request and dest_seq is the request-id.
    # Right after this, a pre-request cancel message is sent to all
    # repliers. The content is 'req-' and dest_seq is request-id + offset.
    #
    # When a replier receives a pre-request cancel message, it will
    # remove the pre-request from the list. If this cancels the
    # request it was currently waiting for, the replier will go back
    # to its default state, and acknowledge the first next pre-request
    # in the queue.
    #
    # When the replier answers a request, it will go back to its default
    # state, and acknowledge the first next pre-request in the queue.
    # The replier tries to answer as quickly to pre-requests as possible.
    #
    # On the request channel, a dictionary of request items is maintained.
    # Each item has an attribute specifying whether a replier has
    # acknowledged it (and which one).

    @others
</t>
<t tx="ekr.20190812072051.81">def __init__(self, context, slot_base):
    BaseChannel.__init__(self, context, slot_base, OBJECT)

    # Queue with pending requests
    self._request_items = {}

    # Timeout
    self._next_recheck_time = time.time() + 0.2

    # Counter
    self._request_counter = 0

    # The req channel is always in event driven mode
    self._run_mode = 1

    # Bind signals to process the events for this channel
    # Bind to "received" signal for quick response and a timer
    # so we can resend requests if we do not receive anything.
    self.received.bind(self._process_events_local)
    self._timer = yoton.events.Timer(0.5, False)
    self._timer.bind(self._process_events_local)
    self._timer.start()
</t>
<t tx="ekr.20190812072051.82">def _messaging_patterns(self):
    return 'req-rep', 'rep-req'
</t>
<t tx="ekr.20190812072051.83">def __getattr__(self, name):
    if name.startswith('_'):
        return object.__getattribute__(self, name)
    try:
        return object.__getattribute__(self, name)
    except AttributeError:
        def proxy_function(*args, **kwargs):
            return self._handle_request(name, *args, **kwargs)
        return proxy_function
</t>
<t tx="ekr.20190812072051.84">def _handle_request(self, name, *args, **kwargs):
    """ _handle_request(request, callback, **kwargs)

    Post a request. This creates a Future instance and stores
    it. A message is send asking any repliers to respond.

    The actual request will be send when a reply to our pre-request
    is received. This all hapens in the yoton event loop.

    """

    # Create request object
    request = name, args, kwargs

    # Check and convert request message
    bb = self.message_to_bytes(request)

    # Get new request id
    request_id = self._request_counter = self._request_counter + 1

    # Create new item for this request and store under the request id
    item = Future(self, bb, request_id)
    self._request_items[request_id] = item

    # Send pre-request (ask repliers who want to reply to a request)
    item._send('req?')

    # Return the Future instance
    return item
</t>
<t tx="ekr.20190812072051.85">def _resend_requests(self):
    """ _resend_requests()

    See if we should resend our older requests. Periodically calling
    this method enables doing a request while the replier is not yet
    attached to the network.

    This also allows the Future objects to cancel themselves if it
    takes too long.

    """
    for request_id in [key for key in self._request_items.keys()]:
        item = self._request_items[request_id]
        # Remove items that are really old
        if item.cancelled():
            self._request_items.pop(request_id)
        else:
            item._resend_if_necessary()
</t>
<t tx="ekr.20190812072051.86">def _recv_item(self):
    """ _recv_item()

    Receive item. If a reply is send that is an acknowledgement
    of a replier that it wants to handle our request, the
    correpsonding request is send to that replier.

    This is a kind of mini-event loop thingy that should be
    called periodically to keep things going.

    """

    # Receive package
    package = self._recv(False)
    if not package:
        return

    # Get the package reply id and sequence number
    dest_id = package._dest_id
    request_id = package._dest_seq

    # Check dest_id
    if not dest_id:
        return # We only want messages that are directed directly at us
    elif dest_id != self._context._id:
        return # This should not happen; context should make sure

    if request_id &gt; REQREP_SEQ_REF:
        # We received a reply to us asking who can handle the request.
        # Get item, send actual request. We set the replier to indicate
        # that this request is being handled, and we can any further
        # acknowledgements from other repliers.
        request_id -= REQREP_SEQ_REF
        item = self._request_items.get(request_id, None)

        if item and not item._replier:
            # Status now changes to "running" canceling is not possible
            ok = item.set_running_or_notify_cancel()
            if not ok:
                return

            # Send actual request to specific replier
            try:
                self._send(item._req, package._source_id, request_id)
            except IOError:
                pass # Channel closed, will auto-cancel at item._send()
            item._replier = package._source_id # mark as being processed

            # Send pre-request-cancel message to everyone
            item._send('req-')

    elif request_id &gt; 0:
        # We received a reply to an actual request

        # Get item, remove from queue, set reply, return
        item = self._request_items.pop(request_id, None)
        if item:
            item._rep = package._data
            return item
</t>
<t tx="ekr.20190812072051.87">def _process_events_local(self, dummy=None):
    """ _process_events_local()

    Process events only for this object. Used by _handle_now().

    """

    # Check periodically if we should resend (or clean up) old requests
    if time.time() &gt; self._next_recheck_time:
        self._resend_requests()
        self._next_recheck_time = time.time() + 0.1

    # Process all received messages
    while self.pending:
        item = self._recv_item()
        if item:
            reply = self.message_from_bytes(item._rep)
            if isinstance(reply, tuple) and len(reply)==2 and reply[0]==ERROR_OBJECT:
                item.set_exception(reply[1])
            else:
                item.set_result(reply)
</t>
<t tx="ekr.20190812072051.88">class RepChannel(BaseChannel):
    """ RepChannel(context, slot_base)

    The reply part of the request/reply messaging pattern.
    A RepChannel instance receives request and sends the corresponding
    replies. The requests are send from a yoton.ReqChannel instance.

    This class adopts req/rep in a remote procedure call (RPC) scheme.

    To use a RepChannel, subclass this class and implement the methods
    that need to be available. The reply should be (a combination of)
    None, bool, int, float, string, list, tuple, dict.

    This channel needs to be set to event or thread mode to function
    (in the first case yoton events need to be processed too).
    To stop handling events again, use set_mode('off').

    Parameters
    ----------
    context : yoton.Context instance
        The context that this channel uses to send messages in a network.
    slot_base : string
        The base slot name. The channel appends an extension to indicate
        message type and messaging pattern to create the final slot name.
        The final slot is used to connect channels at different contexts
        in a network

    """

    @others
</t>
<t tx="ekr.20190812072051.89">def __init__(self, context, slot_base):
    BaseChannel.__init__(self, context, slot_base, OBJECT)

    # Pending pre-requests
    self._pre_requests = []

    # Current pre-request and time that it was acknowledged
    self._pre_request = None
    self._pre_request_time = 0

    # Create thread
    self._thread = ThreadForReqChannel(self)

    # Create timer (do not start)
    self._timer = yoton.events.Timer(2.0, False)
    self._timer.bind(self._process_events_local)

    # By default, the replier is off
    self._run_mode = 0
</t>
<t tx="ekr.20190812072051.9">def close(self):
    """ close()

    Close the channel, i.e. unregisters this channel at the context.
    A closed channel cannot be reused.

    Future attempt to send() messages will result in an IOError
    being raised. Messages currently in the channel's queue can
    still be recv()'ed, but no new messages will be delivered at
    this channel.

    """
    # We keep a reference to the context, otherwise we need locks
    # The context clears the reference to this channel when unregistering.
    self._closed = True
    self._context._unregister_channel(self)
</t>
<t tx="ekr.20190812072051.90">def _messaging_patterns(self):
    return 'rep-req', 'req-rep'

# Node that setters for normal and event_driven mode are specified in
# channels_base.py
</t>
<t tx="ekr.20190812072051.91">def set_mode(self, mode):
    """ set_mode(mode)

    Set the replier to its operating mode, or turn it off.

    Modes:
      * 0 or 'off': do not process requests
      * 1 or 'event': use the yoton event loop to process requests
      * 2 or 'thread': process requests in a separate thread

    """

    if isinstance(mode, basestring):
        mode = mode.lower()

    if mode in [0, 'off']:
        self._run_mode = 0
    elif mode in [1, 'event', 'event-driven']:
        self._run_mode = 1
        self.received.bind(self._process_events_local)
        self._timer.start()
    elif mode in [2, 'thread', 'thread-driven']:
        self._run_mode = 2
        if not self._thread.isAlive():
            self._thread.start()
    else:
        raise ValueError('Invalid mode for ReqChannel instance.')
</t>
<t tx="ekr.20190812072051.92">def _handle_request(self, message):
    """ _handle_request(message)

    This method is called for each request, and should return
    a reply. The message contains the name of the method to call,
    this function calls that method.

    """
    # Get name and args
    name, args, kwargs = message

    # Get function
    if not hasattr(self, name):
        raise RuntimeError("Method '%s' not implemented." % name)
    else:
        func = getattr(self, name)

    # Call
    return func(*args, **kwargs)
</t>
<t tx="ekr.20190812072051.93">def _acknowledge_next_pre_request(self):

    # Cancel current pre-request ourselves if it takes too long.
    # Failsafe, only for if resetting by requester fails somehow.
    if time.time() - self._pre_request_time &gt; 10.0:
        self._pre_request = None

    # Send any pending pre requests
    if self._pre_requests and not self._pre_request:

        # Set current pre-request and its ack time
        package = self._pre_requests.pop(0)
        self._pre_request = package
        self._pre_request_time = time.time()

        # Send acknowledgement
        msg = 'req!'.encode('utf-8')
        try:
            self._send(msg, package._source_id, package._dest_seq)
        except IOError:
            pass # Channel closed, nothing we can do about that
        #
        #print 'ack', self._context.id,  package._dest_seq-REQREP_SEQ_REF
</t>
<t tx="ekr.20190812072051.94">def _replier_iteration(self, package):
    """ _replier_iteration()

    Do one iteration: process one request.

    """

    # Get request id
    request_id = package._dest_seq

    if request_id &gt; REQREP_SEQ_REF:
        # Pre-request stuff

        # Remove offset
        request_id -= REQREP_SEQ_REF

        # Get action and pre request id
        action = package._data.decode('utf-8')

        # Remove pre-request from pending requests in case of both actions:
        # Cancel pending pre-request, prevent stacking of the same request.
        for prereq in [prereq for prereq in self._pre_requests]:
            if (    package._source_id == prereq._source_id and
                    package._dest_seq == prereq._dest_seq):
                self._pre_requests.remove(prereq)

        if action == 'req-':
            # Cancel current pre-request
            if (    self._pre_request and
                    package._source_id == self._pre_request._source_id and
                    package._dest_seq == self._pre_request._dest_seq):
                self._pre_request = None

        elif action == 'req?':
            # New pre-request
            self._pre_requests.append(package)

    else:
        # We are asked to handle an actual request

        # We can reset the state
        self._pre_request = None

        # Get request
        request = self.message_from_bytes(package._data)

        # Get reply
        try:
            reply = self._handle_request(request)
        except Exception:
            reply = ERROR_OBJECT, getErrorMsg()
            print('yoton.RepChannel: error handling request:')
            print(reply[1])

        # Send reply
        if True:
            try:
                bb = self.message_to_bytes(reply)
                self._send(bb, package._source_id, request_id)
            except IOError:
                pass # Channel is closed
            except Exception:
                # Probably wrong type of reply returned by handle_request()
                print('Warning: request could not be send:')
                print(getErrorMsg())
</t>
<t tx="ekr.20190812072051.95">def _process_events_local(self, dummy=None):
    """ _process_events_local()

    Called when a message (or more) has been received.

    """

    # If closed, unregister from signal and stop the timer
    if self.closed or self._run_mode!=1:
        self.received.unbind(self._process_events_local)
        self._timer.stop()

    # Iterate while we receive data
    while True:
        package = self._recv(False)
        if package:
            self._replier_iteration(package)
            self._acknowledge_next_pre_request()
        else:
            # We always enter this the last time
            self._acknowledge_next_pre_request()
            return
</t>
<t tx="ekr.20190812072051.96">def echo(self, arg1, sleep=0.0):
    """ echo(arg1, sleep=0.0)

    Default procedure that can be used for testing. It returns
    a tuple (first_arg, context_id)

    """
    time.sleep(sleep)
    return arg1, hex(self._context.id)
</t>
<t tx="ekr.20190812072051.97">class ThreadForReqChannel(threading.Thread):
    """ ThreadForReqChannel(channel)

    Thread to run a RepChannel in threaded mode.

    """

    @others
</t>
<t tx="ekr.20190812072051.98">def __init__(self, channel):
    threading.Thread.__init__(self)

    # Check channel
    if not isinstance(channel, RepChannel):
        raise ValueError('The given channel must be a REP channel.')

    # Store channel
    self._channel = channel

    # Make deamon
    self.setDaemon(True)
</t>
<t tx="ekr.20190812072051.99">def run(self):
    """ run()

    The handler's main loop.

    """

    # Get ref to channel. Remove ref from instance
    channel = self._channel
    del self._channel

    while True:

        # Stop?
        if channel.closed or channel._run_mode!=2:
            break

        # Wait for data (blocking, look Rob, without spinlocks :)
        package = channel._recv(2.0)
        if package:
            channel._replier_iteration(package)
            channel._acknowledge_next_pre_request()
        else:
            channel._acknowledge_next_pre_request()
</t>
<t tx="ekr.20190812074300.1">"""
Pyzo is a cross-platform Python IDE focused on
interactivity and introspection, which makes it very suitable for
scientific computing. Its practical design is aimed at simplicity and
efficiency.

Pyzo is written in Python 3 and Qt. Binaries are available for Windows,
Linux, and Mac. For questions, there is a discussion group.

**Two components + tools**


Pyzo consists of two main components, the editor and the shell, and uses
a set of pluggable tools to help the programmer in various ways. Some
example tools are source structure, project manager, interactive help,
and workspace.

**Some key features**


* Powerful *introspection* (autocompletion, calltips, interactive help)
* Allows various ways to *run code interactively* or to run a file as a script.
* The shells runs in a *subprocess* and can therefore be interrupted or killed.
* *Multiple shells* can be used at the same time, and can be of different
  Python versions (from v2.4 to 3.x, including pypy)
* Support for using several *GUI toolkits* interactively: PySide, PyQt4,
  wx, fltk, GTK, Tk.
* Run IPython shell or native shell.
* *Full Unicode support* in both editor and shell.
* Various handy *tools*, plus the ability to make your own.
* Matlab-style *cell notation* to mark code sections (by starting a line
  with '##').

"""
</t>
<t tx="ekr.20190812074328.1">
import sys # EKR:change
try:
    import leo.core.leoGlobals as leo_g
except Exception:
    # This gets trapped by the frozen import logic.
    # Print statements or calls to pdb.set_trace are futile.
    leo_g = None
    
# leo_g.printObj(sys.path, tag="pyzo.__init__: sys.path")

# Instantiate the application
import os
# import sys # EKR:change: imported above.
import locale
import traceback

# Check Python version
if sys.version &lt; '3':
    raise RuntimeError('Pyzo requires Python 3.x to run.')
    
# if leo_g: leo_g.pr('pyzo/__init__.py: starts command server')

# Make each OS find platform plugins etc.
if hasattr(sys, 'frozen') and sys.frozen:
    app_dir = os.path.dirname(sys.executable)
    if sys.platform.startswith('win'):
        os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = app_dir
    if sys.platform.startswith('linux'):
        os.environ['QT_XKB_CONFIG_ROOT'] = '.'
        os.environ['FONTCONFIG_FILE'] = os.path.join(
            app_dir,
            'source/pyzo/resources',
            'fonts/linux_fonts.conf')

# Import yoton as an absolute package
from pyzo import yotonloader  # noqa
assert yotonloader
from pyzo.util import paths

# If there already is an instance of Pyzo, and the user is trying an
# Pyzo command, we should send the command to the other process and quit.
# We do this here, were we have not yet loaded Qt, so we are very light.

# Causes problems in the pyzo_file_browser plugin, but we can't change this.
from pyzo.core import commandline
if commandline.is_our_server_running():
    print('Started our command server')
else:
    # Handle command line args now
    res = commandline.handle_cmd_args()
    if res:
        print(res)
        sys.exit()
    else:
        # No args, proceed with starting up
        print('\nOur command server is *not* running')
        print('\nEKR: check permissions for localhost!\n')

from pyzo.util import zon as ssdf  # zon is ssdf-light
from pyzo.util.qt import QtCore, QtGui, QtWidgets

# Import language/translation tools
from pyzo.util._locale import translate, setLanguage  # noqa
assert translate
# Set environ to let kernel know some stats about us
os.environ['PYZO_PREFIX'] = sys.prefix
_is_pyqt4 = hasattr(QtCore, 'PYQT_VERSION_STR')
os.environ['PYZO_QTLIB'] = 'PyQt4' if _is_pyqt4 else 'PySide'
</t>
<t tx="ekr.20190812074841.1">## Init

# List of names that are later overriden (in main.py)
editors = None # The editor stack instance
shells = None # The shell stack instance
main = None # The mainwindow
icon = None # The icon
parser = None # The source parser
status = None # The statusbar (or None)

# Get directories of interest
pyzoDir, appDataDir = getResourceDirs()

# Whether the config file should be saved
_saveConfigFile = True

# Create ssdf in module namespace, and fill it
config = ssdf.new()
loadConfig()

# Init default style name (set in main.restorePyzoState())
defaultQtStyleName = ''
</t>
<t tx="ekr.20190812081316.1">""" Package tools of pyzo

A tool consists of a module which contains a class. The id of a tool is its
module name made lower case. The module should contain a class
corresponding to its id.

We advise starting the class name with a capital letter, but case does not
matter for the tool to work. For instance, the tool "pyzologger" is the
class "PyzoLogger" found in module "pyzoLogger"

The module may contain the following extra variables (which should
be placed within the first 50 lines of code):

tool_name - A readable name for the tool (may contain spaces,
will be shown in the tab)

tool_summary - A single line short summary of the tool. To be
displayed in the statusbar.
"""

# tools I'd like:
# - find in files
# - workspace
# - source tree
# - snipet manager
# - file browser
# - pythonpath editor, startupfile editor (or as part of pyzo?)
</t>
<t tx="ekr.20190812090629.1">def banner(message): #EKR:change-new.
    print('')
    print(message)
    print('')
</t>
<t tx="ekr.20190814050007.1">def make_dock(c, name, widget): # pyzo_file_browser.py
    """Create a dock with the given name and widget in c's main window."""
    dw = c.frame.top
    dock = g.app.gui.create_dock_widget(
        closeable=True,
        moveable=True,
        height=100,
        name=name,
    )
    dw.leo_docks.append(dock)
    dock.setWidget(widget)
    area = QtCore.Qt.LeftDockWidgetArea
    dw.addDockWidget(area, dock)
    widget.show()
</t>
<t tx="ekr.20190829074237.1">@others
</t>
<t tx="ekr.20190829074429.1">@others
</t>
<t tx="ekr.20190829074722.1">@others
</t>
<t tx="ekr.20190829074851.1">@others
</t>
<t tx="ekr.20190829074851.2"># Create custom message type. (should be defined at both ends)
class NumberMessageType(yoton.MessageType):
    @others
</t>
<t tx="ekr.20190829074851.3">def message_from_bytes(self, bb):
    return float(bb)
</t>
<t tx="ekr.20190829074851.4">def message_to_bytes(self, number):
    return str(number).encode('utf-8')
</t>
<t tx="ekr.20190829074851.5">def message_type_name(self):
    return 'num'

</t>
<t tx="rogererens.20041130095659">@ It is possible to link to nodes within the same file.  However clones might be better.
</t>
</tnodes>
</leo_file>
